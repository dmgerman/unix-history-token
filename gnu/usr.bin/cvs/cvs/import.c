begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  * Copyright (c) 1989-1992, Brian Berliner  *  * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.4 kit.  *  * "import" checks in the vendor release located in the current directory into  * the CVS source repository.  The CVS vendor branch support is utilized.  *  * At least three arguments are expected to follow the options:  *	repository	Where the source belongs relative to the CVSROOT  *	VendorTag	Vendor's major tag  *	VendorReleTag	Tag for this particular release  *  * Additional arguments specify more Vendor Release Tags.  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$CVSid: @(#)import.c 1.63 94/09/30 $"
decl_stmt|;
end_decl_stmt

begin_macro
name|USE
argument_list|(
argument|rcsid
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FILE_HOLDER
value|".#cvsxxx"
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_comment
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|user
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_rcs_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|message
operator|,
name|char
operator|*
name|rcs
operator|,
name|char
operator|*
name|user
operator|,
name|char
operator|*
name|vtag
operator|,
name|int
name|targc
operator|,
name|char
operator|*
name|targv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|expand_at_signs
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|,
name|off_t
name|size
operator|,
name|FILE
operator|*
name|fp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_rev
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|message
operator|,
name|char
operator|*
name|rcs
operator|,
name|char
operator|*
name|vfile
operator|,
name|char
operator|*
name|vers
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_tags
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|rcs
operator|,
name|char
operator|*
name|vfile
operator|,
name|char
operator|*
name|vtag
operator|,
name|int
name|targc
operator|,
name|char
operator|*
name|targv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|import_descend
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|message
operator|,
name|char
operator|*
name|vtag
operator|,
name|int
name|targc
operator|,
name|char
operator|*
name|targv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|import_descend_dir
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|message
operator|,
name|char
operator|*
name|dir
operator|,
name|char
operator|*
name|vtag
operator|,
name|int
name|targc
operator|,
name|char
operator|*
name|targv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|process_import_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|message
operator|,
name|char
operator|*
name|vfile
operator|,
name|char
operator|*
name|vtag
operator|,
name|int
name|targc
operator|,
name|char
operator|*
name|targv
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|update_rcs_file
name|PROTO
argument_list|(
operator|(
name|char
operator|*
name|message
operator|,
name|char
operator|*
name|vfile
operator|,
name|char
operator|*
name|vtag
operator|,
name|int
name|targc
operator|,
name|char
operator|*
name|targv
index|[]
operator|,
name|int
name|inattic
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_log
name|PROTO
argument_list|(
operator|(
name|int
name|ch
operator|,
name|char
operator|*
name|fname
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|str2expmode
name|PROTO
argument_list|(
operator|(
name|char
specifier|const
operator|*
name|expstring
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|strn2expmode
name|PROTO
argument_list|(
operator|(
name|char
specifier|const
operator|*
name|expstring
operator|,
name|size_t
name|n
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|repos_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|vhead
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|vbranch
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|logfp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|repository
index|[
name|PATH_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|conflicts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|use_file_modtime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|keyword_opt
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|import_usage
index|[]
init|=
block|{
literal|"Usage: %s %s [-Qq] [-d] [-k subst] [-I ign] [-m msg] [-b branch]\n"
block|,
literal|"    repository vendor-tag release-tags...\n"
block|,
literal|"\t-Q\tReally quiet.\n"
block|,
literal|"\t-q\tSomewhat quiet.\n"
block|,
literal|"\t-d\tUse the file's modification time as the time of import.\n"
block|,
literal|"\t-k sub\tSet default RCS keyword substitution mode.\n"
block|,
literal|"\t-I ign\tMore files to ignore (! to reset).\n"
block|,
literal|"\t-b bra\tVendor branch id.\n"
block|,
literal|"\t-m msg\tLog message.\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|keyword_usage
index|[]
init|=
block|{
literal|"%s %s: invalid RCS keyword expansion mode\n"
block|,
literal|"Valid expansion modes include:\n"
block|,
literal|"   -kkv\tGenerate keywords using the default form.\n"
block|,
literal|"   -kkvl\tLike -kkv, except locker's name inserted.\n"
block|,
literal|"   -kk\tGenerate only keyword names in keyword strings.\n"
block|,
literal|"   -kv\tGenerate only keyword values in keyword strings.\n"
block|,
literal|"   -ko\tGenerate the old keyword string (no changes from checked in file).\n"
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|import
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|message
init|=
name|NULL
decl_stmt|;
name|char
name|tmpfile
index|[
name|L_tmpnam
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|msglen
decl_stmt|,
name|err
decl_stmt|;
name|List
modifier|*
name|ulist
decl_stmt|;
name|Node
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|argc
operator|==
operator|-
literal|1
condition|)
name|usage
argument_list|(
name|import_usage
argument_list|)
expr_stmt|;
name|ign_setup
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|vbranch
argument_list|,
name|CVSBRANCH
argument_list|)
expr_stmt|;
name|optind
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"Qqdb:m:I:k:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'Q'
case|:
name|really_quiet
operator|=
literal|1
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|use_file_modtime
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|vbranch
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
ifdef|#
directive|ifdef
name|FORCE_USE_EDITOR
name|use_editor
operator|=
name|TRUE
expr_stmt|;
else|#
directive|else
name|use_editor
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
name|message
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|ign_add
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|str2expmode
argument_list|(
name|optarg
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|keyword_opt
operator|=
name|optarg
expr_stmt|;
else|else
name|usage
argument_list|(
name|keyword_usage
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
name|import_usage
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
name|usage
argument_list|(
name|import_usage
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
comment|/* check the tags for validity */
name|RCS_check_tag
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* XXX - this should be a module, not just a pathname */
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
if|if
condition|(
name|CVSroot
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"missing CVSROOT environment variable\n"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Set it or specify the '-d' option to %s."
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|repository
argument_list|,
literal|"%s/%s"
argument_list|,
name|CVSroot
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|repos_len
operator|=
name|strlen
argument_list|(
name|CVSroot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|repository
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|repos_len
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * Consistency checks on the specified vendor branch.  It must be      * composed of only numbers and dots ('.').  Also, for now we only      * support branching to a single level, so the specified vendor branch      * must only have two dots in it (like "1.1.1").      */
for|for
control|(
name|cp
operator|=
name|vbranch
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
operator|*
name|cp
operator|!=
literal|'.'
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s is not a numeric branch"
argument_list|,
name|vbranch
argument_list|)
expr_stmt|;
if|if
condition|(
name|numdots
argument_list|(
name|vbranch
argument_list|)
operator|!=
literal|2
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Only branches with two dots are supported: %s"
argument_list|,
name|vbranch
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|vhead
argument_list|,
name|vbranch
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|vhead
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|use_editor
condition|)
block|{
name|do_editor
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|message
argument_list|,
name|repository
argument_list|,
operator|(
name|List
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|msglen
operator|=
name|message
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|msglen
operator|==
literal|0
operator|||
name|message
index|[
name|msglen
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|char
modifier|*
name|nm
init|=
name|xmalloc
argument_list|(
name|msglen
operator|+
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|message
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|nm
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|nm
operator|+
name|msglen
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|message
operator|=
name|nm
expr_stmt|;
block|}
comment|/*      * Make all newly created directories writable.  Should really use a more      * sophisticated security mechanism here.      */
operator|(
name|void
operator|)
name|umask
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|make_directories
argument_list|(
name|repository
argument_list|)
expr_stmt|;
comment|/* Create the logfile that will be logged upon completion */
if|if
condition|(
operator|(
name|logfp
operator|=
name|fopen
argument_list|(
name|tmpnam
argument_list|(
name|tmpfile
argument_list|)
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot create temporary file `%s'"
argument_list|,
name|tmpfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpfile
argument_list|)
expr_stmt|;
comment|/* to be sure it goes away */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"\nVendor Tag:\t%s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"Release Tags:\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"%s\n\t\t"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Just Do It.  */
name|err
operator|=
name|import_descend
argument_list|(
name|message
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argc
operator|-
literal|2
argument_list|,
name|argv
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflicts
condition|)
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n%d conflicts created by this import.\n"
argument_list|,
name|conflicts
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Use the following command to help the merge:\n\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%s checkout -j%s:yesterday -j%s %s\n\n"
argument_list|,
name|program_name
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"\n%d conflicts created by this import.\n"
argument_list|,
name|conflicts
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"Use the following command to help the merge:\n\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"\t%s checkout -j%s:yesterday -j%s %s\n\n"
argument_list|,
name|program_name
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\nNo conflicts created by this import\n\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"\nNo conflicts created by this import\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Write out the logfile and clean up.      */
name|ulist
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|UPDATE
expr_stmt|;
name|p
operator|->
name|delproc
operator|=
name|update_delproc
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
literal|"- Imported sources"
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|T_TITLE
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
name|ulist
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|Update_Logfile
argument_list|(
name|repository
argument_list|,
name|message
argument_list|,
name|vbranch
argument_list|,
name|logfp
argument_list|,
name|ulist
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|ulist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|logfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
condition|)
name|free
argument_list|(
name|message
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * process all the files in ".", then descend into other directories.  */
end_comment

begin_function
specifier|static
name|int
name|import_descend
parameter_list|(
name|message
parameter_list|,
name|vtag
parameter_list|,
name|targc
parameter_list|,
name|targv
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|char
modifier|*
name|vtag
decl_stmt|;
name|int
name|targc
decl_stmt|;
name|char
modifier|*
name|targv
index|[]
decl_stmt|;
block|{
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|has_dirs
init|=
literal|0
decl_stmt|;
comment|/* first, load up any per-directory ignore lists */
name|ign_add_file
argument_list|(
name|CVSDOTIGNORE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|err
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ign_name
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
condition|)
block|{
name|add_log
argument_list|(
literal|'I'
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|isdir
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
condition|)
block|{
name|has_dirs
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|islink
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
condition|)
block|{
name|add_log
argument_list|(
literal|'L'
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
block|}
else|else
block|{
name|err
operator|+=
name|process_import_file
argument_list|(
name|message
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|vtag
argument_list|,
name|targc
argument_list|,
name|targv
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_dirs
condition|)
block|{
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
operator|++
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"."
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
literal|".."
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
operator|||
name|ign_name
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
condition|)
continue|continue;
name|err
operator|+=
name|import_descend_dir
argument_list|(
name|message
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|vtag
argument_list|,
name|targc
argument_list|,
name|targv
argument_list|)
expr_stmt|;
comment|/* need to re-load .cvsignore after each dir traversal */
name|ign_add_file
argument_list|(
name|CVSDOTIGNORE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process the argument import file.  */
end_comment

begin_function
specifier|static
name|int
name|process_import_file
parameter_list|(
name|message
parameter_list|,
name|vfile
parameter_list|,
name|vtag
parameter_list|,
name|targc
parameter_list|,
name|targv
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|char
modifier|*
name|vfile
decl_stmt|;
name|char
modifier|*
name|vtag
decl_stmt|;
name|int
name|targc
decl_stmt|;
name|char
modifier|*
name|targv
index|[]
decl_stmt|;
block|{
name|char
name|attic_name
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|rcs
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|inattic
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|rcs
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|vfile
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|rcs
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|attic_name
argument_list|,
literal|"%s/%s/%s%s"
argument_list|,
name|repository
argument_list|,
name|CVSATTIC
argument_list|,
name|vfile
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isfile
argument_list|(
name|attic_name
argument_list|)
condition|)
block|{
comment|/* 	     * A new import source file; it doesn't exist as a ,v within the 	     * repository nor in the Attic -- create it anew. 	     */
name|add_log
argument_list|(
literal|'N'
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|add_rcs_file
argument_list|(
name|message
argument_list|,
name|rcs
argument_list|,
name|vfile
argument_list|,
name|vtag
argument_list|,
name|targc
argument_list|,
name|targv
argument_list|)
operator|)
return|;
block|}
name|inattic
operator|=
literal|1
expr_stmt|;
block|}
comment|/*      * an rcs file exists. have to do things the official, slow, way.      */
return|return
operator|(
name|update_rcs_file
argument_list|(
name|message
argument_list|,
name|vfile
argument_list|,
name|vtag
argument_list|,
name|targc
argument_list|,
name|targv
argument_list|,
name|inattic
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The RCS file exists; update it by adding the new import file to the  * (possibly already existing) vendor branch.  */
end_comment

begin_function
specifier|static
name|int
name|update_rcs_file
parameter_list|(
name|message
parameter_list|,
name|vfile
parameter_list|,
name|vtag
parameter_list|,
name|targc
parameter_list|,
name|targv
parameter_list|,
name|inattic
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|char
modifier|*
name|vfile
decl_stmt|;
name|char
modifier|*
name|vtag
decl_stmt|;
name|int
name|targc
decl_stmt|;
name|char
modifier|*
name|targv
index|[]
decl_stmt|;
name|int
name|inattic
decl_stmt|;
block|{
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|int
name|letter
decl_stmt|;
name|int
name|ierrno
decl_stmt|;
name|char
modifier|*
name|tmpdir
decl_stmt|;
name|vers
operator|=
name|Version_TS
argument_list|(
name|repository
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|vbranch
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|vfile
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|(
name|List
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|List
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vers
operator|->
name|vn_rcs
operator|!=
name|NULL
condition|)
block|{
name|char
name|xtmpfile
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|different
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
name|tmpdir
operator|=
name|getenv
argument_list|(
literal|"TMPDIR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpdir
operator|==
name|NULL
operator|||
name|tmpdir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|tmpdir
operator|=
literal|"/tmp"
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|xtmpfile
argument_list|,
literal|"%s/cvs-imp%d"
argument_list|,
name|tmpdir
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
comment|/* 	 * The rcs file does have a revision on the vendor branch. Compare 	 * this revision with the import file; if they match exactly, there 	 * is no need to install the new import file as a new revision to the 	 * branch.  Just tag the revision with the new import tags. 	 * 	 * This is to try to cut down the number of "C" conflict messages for 	 * locally modified import source files. 	 */
ifdef|#
directive|ifdef
name|HAVE_RCS5
name|run_setup
argument_list|(
literal|"%s%s -q -f -r%s -p -ko"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS_CO
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
else|#
directive|else
name|run_setup
argument_list|(
literal|"%s%s -q -f -r%s -p"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS_CO
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|run_arg
argument_list|(
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|xtmpfile
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
operator||
name|RUN_REALLY
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|ierrno
else|:
literal|0
argument_list|,
literal|"ERROR: cannot co revision %s of file %s"
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|ierrno
else|:
literal|0
argument_list|,
literal|"ERROR: cannot co revision %s of file %s"
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|,
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|xtmpfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|different
operator|=
name|xcmp
argument_list|(
name|xtmpfile
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|xtmpfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|different
condition|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
comment|/* 	     * The two files are identical.  Just update the tags, print the 	     * "U", signifying that the file has changed, but needs no 	     * attention, and we're done. 	     */
if|if
condition|(
name|add_tags
argument_list|(
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|,
name|vfile
argument_list|,
name|vtag
argument_list|,
name|targc
argument_list|,
name|targv
argument_list|)
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
name|add_log
argument_list|(
literal|'U'
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
block|}
comment|/* We may have failed to parse the RCS file; check just in case */
if|if
condition|(
name|vers
operator|->
name|srcfile
operator|==
name|NULL
operator|||
name|add_rev
argument_list|(
name|message
argument_list|,
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|,
name|vfile
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|)
operator|||
name|add_tags
argument_list|(
name|vers
operator|->
name|srcfile
operator|->
name|path
argument_list|,
name|vfile
argument_list|,
name|vtag
argument_list|,
name|targc
argument_list|,
name|targv
argument_list|)
condition|)
block|{
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|vers
operator|->
name|srcfile
operator|->
name|branch
operator|==
name|NULL
operator|||
name|inattic
operator|||
name|strcmp
argument_list|(
name|vers
operator|->
name|srcfile
operator|->
name|branch
argument_list|,
name|vbranch
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|conflicts
operator|++
expr_stmt|;
name|letter
operator|=
literal|'C'
expr_stmt|;
block|}
else|else
name|letter
operator|=
literal|'U'
expr_stmt|;
name|add_log
argument_list|(
name|letter
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add the revision to the vendor branch  */
end_comment

begin_function
specifier|static
name|int
name|add_rev
parameter_list|(
name|message
parameter_list|,
name|rcs
parameter_list|,
name|vfile
parameter_list|,
name|vers
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|char
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|vfile
decl_stmt|;
name|char
modifier|*
name|vers
decl_stmt|;
block|{
name|int
name|locked
decl_stmt|,
name|status
decl_stmt|,
name|ierrno
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|locked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vers
operator|!=
name|NULL
condition|)
block|{
name|run_setup
argument_list|(
literal|"%s%s -q -l%s"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS
argument_list|,
name|vbranch
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|DEVNULL
argument_list|,
name|DEVNULL
argument_list|,
name|RUN_NORMAL
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|locked
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|retcode
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"fork failed"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|link_file
argument_list|(
name|vfile
argument_list|,
name|FILE_HOLDER
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EEXIST
condition|)
block|{
operator|(
name|void
operator|)
name|unlink_file
argument_list|(
name|FILE_HOLDER
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|link_file
argument_list|(
name|vfile
argument_list|,
name|FILE_HOLDER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"ERROR: cannot create link to %s"
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"ERROR: cannot create link to %s"
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|run_setup
argument_list|(
literal|"%s%s -q -f -r%s"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS_CI
argument_list|,
name|vbranch
argument_list|)
expr_stmt|;
name|run_args
argument_list|(
literal|"-m%s"
argument_list|,
name|message
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_file_modtime
condition|)
name|run_arg
argument_list|(
literal|"-d"
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
name|status
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
name|ierrno
operator|=
name|errno
expr_stmt|;
name|rename_file
argument_list|(
name|FILE_HOLDER
argument_list|,
name|vfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
if|if
condition|(
operator|!
name|noexec
condition|)
block|{
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|status
operator|==
operator|-
literal|1
condition|?
name|ierrno
else|:
literal|0
argument_list|,
literal|"ERROR: Check-in of %s failed"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|status
operator|==
operator|-
literal|1
condition|?
name|ierrno
else|:
literal|0
argument_list|,
literal|"ERROR: Check-in of %s failed"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|locked
condition|)
block|{
name|run_setup
argument_list|(
literal|"%s%s -q -u%s"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS
argument_list|,
name|vbranch
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add the vendor branch tag and all the specified import release tags to the  * RCS file.  The vendor branch tag goes on the branch root (1.1.1) while the  * vendor release tags go on the newly added leaf of the branch (1.1.1.1,  * 1.1.1.2, ...).  */
end_comment

begin_function
specifier|static
name|int
name|add_tags
parameter_list|(
name|rcs
parameter_list|,
name|vfile
parameter_list|,
name|vtag
parameter_list|,
name|targc
parameter_list|,
name|targv
parameter_list|)
name|char
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|vfile
decl_stmt|;
name|char
modifier|*
name|vtag
decl_stmt|;
name|int
name|targc
decl_stmt|;
name|char
modifier|*
name|targv
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|ierrno
decl_stmt|;
name|Vers_TS
modifier|*
name|vers
decl_stmt|;
name|int
name|retcode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|run_setup
argument_list|(
literal|"%s%s -q -N%s:%s"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS
argument_list|,
name|vtag
argument_list|,
name|vbranch
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|ierrno
else|:
literal|0
argument_list|,
literal|"ERROR: Failed to set tag %s in %s"
argument_list|,
name|vtag
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|ierrno
else|:
literal|0
argument_list|,
literal|"ERROR: Failed to set tag %s in %s"
argument_list|,
name|vtag
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|vers
operator|=
name|Version_TS
argument_list|(
name|repository
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|vtag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|vfile
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|(
name|List
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|List
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|targc
condition|;
name|i
operator|++
control|)
block|{
name|run_setup
argument_list|(
literal|"%s%s -q -N%s:%s"
argument_list|,
name|Rcsbin
argument_list|,
name|RCS
argument_list|,
name|targv
index|[
name|i
index|]
argument_list|,
name|vers
operator|->
name|vn_rcs
argument_list|)
expr_stmt|;
name|run_arg
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retcode
operator|=
name|run_exec
argument_list|(
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_TTY
argument_list|,
name|RUN_NORMAL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|ierrno
else|:
literal|0
argument_list|,
literal|"WARNING: Couldn't add tag %s to %s"
argument_list|,
name|targv
index|[
name|i
index|]
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|retcode
operator|==
operator|-
literal|1
condition|?
name|ierrno
else|:
literal|0
argument_list|,
literal|"WARNING: Couldn't add tag %s to %s"
argument_list|,
name|targv
index|[
name|i
index|]
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
block|}
block|}
name|freevers_ts
argument_list|(
operator|&
name|vers
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Stolen from rcs/src/rcsfnms.c, and adapted/extended.  */
end_comment

begin_struct
struct|struct
name|compair
block|{
name|char
modifier|*
name|suffix
decl_stmt|,
modifier|*
name|comlead
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|compair
name|comtable
index|[]
init|=
block|{
comment|/*  * comtable pairs each filename suffix with a comment leader. The comment  * leader is placed before each line generated by the $Log keyword. This  * table is used to guess the proper comment leader from the working file's  * suffix during initial ci (see InitAdmin()). Comment leaders are needed for  * languages without multiline comments; for others they are optional.  */
literal|"a"
block|,
literal|"-- "
block|,
comment|/* Ada		 */
literal|"ada"
block|,
literal|"-- "
block|,
literal|"adb"
block|,
literal|"-- "
block|,
literal|"asm"
block|,
literal|";; "
block|,
comment|/* assembler (MS-DOS) */
literal|"ads"
block|,
literal|"-- "
block|,
comment|/* Ada		 */
literal|"bat"
block|,
literal|":: "
block|,
comment|/* batch (MS-DOS) */
literal|"body"
block|,
literal|"-- "
block|,
comment|/* Ada		 */
literal|"c"
block|,
literal|" * "
block|,
comment|/* C		 */
literal|"c++"
block|,
literal|"// "
block|,
comment|/* C++ in all its infinite guises */
literal|"cc"
block|,
literal|"// "
block|,
literal|"cpp"
block|,
literal|"// "
block|,
literal|"cxx"
block|,
literal|"// "
block|,
literal|"cl"
block|,
literal|";;; "
block|,
comment|/* Common Lisp	 */
literal|"cmd"
block|,
literal|":: "
block|,
comment|/* command (OS/2) */
literal|"cmf"
block|,
literal|"c "
block|,
comment|/* CM Fortran	 */
literal|"cs"
block|,
literal|" * "
block|,
comment|/* C*		 */
literal|"csh"
block|,
literal|"# "
block|,
comment|/* shell	 */
literal|"e"
block|,
literal|"# "
block|,
comment|/* efl		 */
literal|"epsf"
block|,
literal|"% "
block|,
comment|/* encapsulated postscript */
literal|"epsi"
block|,
literal|"% "
block|,
comment|/* encapsulated postscript */
literal|"el"
block|,
literal|"; "
block|,
comment|/* Emacs Lisp	 */
literal|"f"
block|,
literal|"c "
block|,
comment|/* Fortran	 */
literal|"for"
block|,
literal|"c "
block|,
literal|"h"
block|,
literal|" * "
block|,
comment|/* C-header	 */
literal|"hh"
block|,
literal|"// "
block|,
comment|/* C++ header	 */
literal|"hpp"
block|,
literal|"// "
block|,
literal|"hxx"
block|,
literal|"// "
block|,
literal|"in"
block|,
literal|"# "
block|,
comment|/* for Makefile.in */
literal|"l"
block|,
literal|" * "
block|,
comment|/* lex (conflict between lex and 					 * franzlisp) */
literal|"mac"
block|,
literal|";; "
block|,
comment|/* macro (DEC-10, MS-DOS, PDP-11, 					 * VMS, etc) */
literal|"me"
block|,
literal|".\\\" "
block|,
comment|/* me-macros	t/nroff	 */
literal|"ml"
block|,
literal|"; "
block|,
comment|/* mocklisp	 */
literal|"mm"
block|,
literal|".\\\" "
block|,
comment|/* mm-macros	t/nroff	 */
literal|"ms"
block|,
literal|".\\\" "
block|,
comment|/* ms-macros	t/nroff	 */
literal|"man"
block|,
literal|".\\\" "
block|,
comment|/* man-macros	t/nroff	 */
literal|"1"
block|,
literal|".\\\" "
block|,
comment|/* feeble attempt at man pages... */
literal|"2"
block|,
literal|".\\\" "
block|,
literal|"3"
block|,
literal|".\\\" "
block|,
literal|"4"
block|,
literal|".\\\" "
block|,
literal|"5"
block|,
literal|".\\\" "
block|,
literal|"6"
block|,
literal|".\\\" "
block|,
literal|"7"
block|,
literal|".\\\" "
block|,
literal|"8"
block|,
literal|".\\\" "
block|,
literal|"9"
block|,
literal|".\\\" "
block|,
literal|"p"
block|,
literal|" * "
block|,
comment|/* pascal	 */
literal|"pas"
block|,
literal|" * "
block|,
literal|"pl"
block|,
literal|"# "
block|,
comment|/* perl	(conflict with Prolog) */
literal|"ps"
block|,
literal|"% "
block|,
comment|/* postscript	 */
literal|"r"
block|,
literal|"# "
block|,
comment|/* ratfor	 */
literal|"red"
block|,
literal|"% "
block|,
comment|/* psl/rlisp	 */
ifdef|#
directive|ifdef
name|sparc
literal|"s"
block|,
literal|"! "
block|,
comment|/* assembler	 */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|mc68000
literal|"s"
block|,
literal|"| "
block|,
comment|/* assembler	 */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|pdp11
literal|"s"
block|,
literal|"/ "
block|,
comment|/* assembler	 */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|vax
literal|"s"
block|,
literal|"# "
block|,
comment|/* assembler	 */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__ksr__
literal|"s"
block|,
literal|"# "
block|,
comment|/* assembler	 */
literal|"S"
block|,
literal|"# "
block|,
comment|/* Macro assembler */
endif|#
directive|endif
literal|"sh"
block|,
literal|"# "
block|,
comment|/* shell	 */
literal|"sl"
block|,
literal|"% "
block|,
comment|/* psl		 */
literal|"spec"
block|,
literal|"-- "
block|,
comment|/* Ada		 */
literal|"tex"
block|,
literal|"% "
block|,
comment|/* tex		 */
literal|"y"
block|,
literal|" * "
block|,
comment|/* yacc		 */
literal|"ye"
block|,
literal|" * "
block|,
comment|/* yacc-efl	 */
literal|"yr"
block|,
literal|" * "
block|,
comment|/* yacc-ratfor	 */
literal|""
block|,
literal|"# "
block|,
comment|/* default for empty suffix	 */
name|NULL
block|,
literal|"# "
comment|/* default for unknown suffix;	 */
comment|/* must always be last		 */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|get_comment
parameter_list|(
name|user
parameter_list|)
name|char
modifier|*
name|user
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|suffix
decl_stmt|;
name|char
name|suffix_path
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cp
operator|=
name|strrchr
argument_list|(
name|user
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|++
expr_stmt|;
comment|/* 	 * Convert to lower-case, since we are not concerned about the 	 * case-ness of the suffix. 	 */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|suffix_path
argument_list|,
name|cp
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|suffix_path
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
name|tolower
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|suffix
operator|=
name|suffix_path
expr_stmt|;
block|}
else|else
name|suffix
operator|=
literal|""
expr_stmt|;
comment|/* will use the default */
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|comtable
index|[
name|i
index|]
operator|.
name|suffix
operator|==
name|NULL
condition|)
comment|/* default */
return|return
operator|(
name|comtable
index|[
name|i
index|]
operator|.
name|comlead
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|suffix
argument_list|,
name|comtable
index|[
name|i
index|]
operator|.
name|suffix
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|comtable
index|[
name|i
index|]
operator|.
name|comlead
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|add_rcs_file
parameter_list|(
name|message
parameter_list|,
name|rcs
parameter_list|,
name|user
parameter_list|,
name|vtag
parameter_list|,
name|targc
parameter_list|,
name|targv
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|char
modifier|*
name|rcs
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
name|char
modifier|*
name|vtag
decl_stmt|;
name|int
name|targc
decl_stmt|;
name|char
modifier|*
name|targv
index|[]
decl_stmt|;
block|{
name|FILE
modifier|*
name|fprcs
decl_stmt|,
modifier|*
name|fpuser
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|tm
modifier|*
name|ftm
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|char
name|altdate1
index|[
literal|50
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|HAVE_RCS5
name|char
name|altdate2
index|[
literal|50
index|]
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|author
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|mode
decl_stmt|,
name|ierrno
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|noexec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|fprcs
operator|=
name|open_file
argument_list|(
name|rcs
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
name|fpuser
operator|=
name|open_file
argument_list|(
name|user
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/*      * putadmin()      */
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"head     %s;\n"
argument_list|,
name|vhead
argument_list|)
operator|==
name|EOF
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"branch   %s;\n"
argument_list|,
name|vbranch
argument_list|)
operator|==
name|EOF
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"access   ;\n"
argument_list|)
operator|==
name|EOF
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"symbols  "
argument_list|)
operator|==
name|EOF
condition|)
block|{
goto|goto
name|write_error
goto|;
block|}
for|for
control|(
name|i
operator|=
name|targc
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
comment|/* RCS writes the symbols backwards */
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"%s:%s.1 "
argument_list|,
name|targv
index|[
name|i
index|]
argument_list|,
name|vbranch
argument_list|)
operator|==
name|EOF
condition|)
goto|goto
name|write_error
goto|;
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"%s:%s;\n"
argument_list|,
name|vtag
argument_list|,
name|vbranch
argument_list|)
operator|==
name|EOF
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"locks    ; strict;\n"
argument_list|)
operator|==
name|EOF
operator|||
comment|/* XXX - make sure @@ processing works in the RCS file */
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"comment  @%s@;\n"
argument_list|,
name|get_comment
argument_list|(
name|user
argument_list|)
argument_list|)
operator|==
name|EOF
condition|)
block|{
goto|goto
name|write_error
goto|;
block|}
if|if
condition|(
name|keyword_opt
operator|!=
name|NULL
condition|)
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"expand   @%s@;\n"
argument_list|,
name|keyword_opt
argument_list|)
operator|==
name|EOF
condition|)
block|{
goto|goto
name|write_error
goto|;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"\n"
argument_list|)
operator|==
name|EOF
condition|)
goto|goto
name|write_error
goto|;
comment|/*      * puttree()      */
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fpuser
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot fstat %s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_file_modtime
condition|)
name|now
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_RCS5
name|ftm
operator|=
name|gmtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
else|#
directive|else
name|ftm
operator|=
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|altdate1
argument_list|,
name|DATEFORM
argument_list|,
name|ftm
operator|->
name|tm_year
operator|+
operator|(
name|ftm
operator|->
name|tm_year
operator|<
literal|100
condition|?
literal|0
else|:
literal|1900
operator|)
argument_list|,
name|ftm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_RCS5
define|#
directive|define
name|altdate2
value|altdate1
else|#
directive|else
comment|/*      * If you don't have RCS V5 or later, you need to lie about the ci      * time, since RCS V4 and earlier insist that the times differ.      */
name|now
operator|++
expr_stmt|;
name|ftm
operator|=
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|altdate2
argument_list|,
name|DATEFORM
argument_list|,
name|ftm
operator|->
name|tm_year
operator|+
operator|(
name|ftm
operator|->
name|tm_year
operator|<
literal|100
condition|?
literal|0
else|:
literal|1900
operator|)
argument_list|,
name|ftm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|ftm
operator|->
name|tm_mday
argument_list|,
name|ftm
operator|->
name|tm_hour
argument_list|,
name|ftm
operator|->
name|tm_min
argument_list|,
name|ftm
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|author
operator|=
name|getcaller
argument_list|()
expr_stmt|;
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"\n%s\n"
argument_list|,
name|vhead
argument_list|)
operator|==
name|EOF
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"date     %s;  author %s;  state Exp;\n"
argument_list|,
name|altdate1
argument_list|,
name|author
argument_list|)
operator|==
name|EOF
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"branches %s.1;\n"
argument_list|,
name|vbranch
argument_list|)
operator|==
name|EOF
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"next     ;\n"
argument_list|)
operator|==
name|EOF
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"\n%s.1\n"
argument_list|,
name|vbranch
argument_list|)
operator|==
name|EOF
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"date     %s;  author %s;  state Exp;\n"
argument_list|,
name|altdate2
argument_list|,
name|author
argument_list|)
operator|==
name|EOF
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"branches ;\n"
argument_list|)
operator|==
name|EOF
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"next     ;\n\n"
argument_list|)
operator|==
name|EOF
operator|||
comment|/* 	 * putdesc() 	 */
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"\ndesc\n"
argument_list|)
operator|==
name|EOF
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"@@\n\n\n"
argument_list|)
operator|==
name|EOF
operator|||
comment|/* 	 * putdelta() 	 */
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"\n%s\n"
argument_list|,
name|vhead
argument_list|)
operator|==
name|EOF
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"log\n"
argument_list|)
operator|==
name|EOF
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"@Initial revision\n@\n"
argument_list|)
operator|==
name|EOF
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"text\n@"
argument_list|)
operator|==
name|EOF
condition|)
block|{
goto|goto
name|write_error
goto|;
block|}
if|if
condition|(
name|sb
operator|.
name|st_size
operator|>
literal|0
condition|)
block|{
name|off_t
name|size
decl_stmt|;
name|size
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
operator|(
name|int
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|,
literal|1
argument_list|,
name|fpuser
argument_list|)
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot read file %s for copying"
argument_list|,
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|expand_at_signs
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|fprcs
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|write_error
goto|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"@\n\n"
argument_list|)
operator|==
name|EOF
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"\n%s.1\n"
argument_list|,
name|vbranch
argument_list|)
operator|==
name|EOF
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"log\n@"
argument_list|)
operator|==
name|EOF
operator|||
name|expand_at_signs
argument_list|(
name|message
argument_list|,
operator|(
name|off_t
operator|)
name|strlen
argument_list|(
name|message
argument_list|)
argument_list|,
name|fprcs
argument_list|)
operator|==
name|EOF
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"@\ntext\n"
argument_list|)
operator|==
name|EOF
operator|||
name|fprintf
argument_list|(
name|fprcs
argument_list|,
literal|"@@\n"
argument_list|)
operator|==
name|EOF
condition|)
block|{
goto|goto
name|write_error
goto|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fprcs
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
goto|goto
name|write_error_noclose
goto|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fpuser
argument_list|)
expr_stmt|;
comment|/*      * Fix the modes on the RCS files.  They must maintain the same modes as      * the original user file, except that all write permissions must be      * turned off.      */
name|mode
operator|=
name|sb
operator|.
name|st_mode
operator|&
operator|~
operator|(
name|S_IWRITE
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|rcs
argument_list|,
name|mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"WARNING: cannot change mode of file %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"WARNING: cannot change mode of file %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
name|write_error
label|:
name|ierrno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fprcs
argument_list|)
expr_stmt|;
name|write_error_noclose
label|:
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fpuser
argument_list|)
expr_stmt|;
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"ERROR: cannot write file %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"ERROR: cannot write file %s"
argument_list|,
name|rcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ierrno
operator|==
name|ENOSPC
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|rcs
argument_list|)
expr_stmt|;
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ERROR: out of space - aborting"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"ERROR: out of space - aborting"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sigh..  need to expand @ signs into double @ signs  */
end_comment

begin_function
specifier|static
name|int
name|expand_at_signs
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|,
name|fp
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|off_t
name|size
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|end
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|buf
operator|,
name|end
operator|=
name|buf
operator|+
name|size
init|;
name|cp
operator|<
name|end
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'@'
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'@'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|putc
argument_list|(
operator|*
name|cp
argument_list|,
name|fp
argument_list|)
operator|==
name|EOF
condition|)
return|return
operator|(
name|EOF
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write an update message to (potentially) the screen and the log file.  */
end_comment

begin_function
specifier|static
name|void
name|add_log
parameter_list|(
name|ch
parameter_list|,
name|fname
parameter_list|)
name|int
name|ch
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|really_quiet
condition|)
comment|/* write to terminal */
block|{
if|if
condition|(
name|repos_len
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%c %s/%s\n"
argument_list|,
name|ch
argument_list|,
name|repository
operator|+
name|repos_len
operator|+
literal|1
argument_list|,
name|fname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|repository
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%c %s/%s\n"
argument_list|,
name|ch
argument_list|,
name|repository
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%c %s\n"
argument_list|,
name|ch
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|repos_len
condition|)
comment|/* write to logfile */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"%c %s/%s\n"
argument_list|,
name|ch
argument_list|,
name|repository
operator|+
name|repos_len
operator|+
literal|1
argument_list|,
name|fname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|repository
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"%c %s/%s\n"
argument_list|,
name|ch
argument_list|,
name|repository
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logfp
argument_list|,
literal|"%c %s\n"
argument_list|,
name|ch
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the recursive function that walks the argument directory looking  * for sub-directories that have CVS administration files in them and updates  * them recursively.  *  * Note that we do not follow symbolic links here, which is a feature!  */
end_comment

begin_function
specifier|static
name|int
name|import_descend_dir
parameter_list|(
name|message
parameter_list|,
name|dir
parameter_list|,
name|vtag
parameter_list|,
name|targc
parameter_list|,
name|targv
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|vtag
decl_stmt|;
name|int
name|targc
decl_stmt|;
name|char
modifier|*
name|targv
index|[]
decl_stmt|;
block|{
name|char
name|cwd
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|ierrno
decl_stmt|,
name|err
decl_stmt|;
if|if
condition|(
name|islink
argument_list|(
name|dir
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|getwd
argument_list|(
name|cwd
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ERROR: cannot get working directory: %s"
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ERROR: cannot get working directory: %s"
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|repository
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|repository
argument_list|,
name|dir
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|repository
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|repository
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Importing %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"ERROR: cannot chdir to %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"ERROR: cannot chdir to %s"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|isdir
argument_list|(
name|repository
argument_list|)
condition|)
block|{
if|if
condition|(
name|isfile
argument_list|(
name|repository
argument_list|)
condition|)
block|{
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ERROR: %s is a file, should be a directory!"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ERROR: %s is a file, should be a directory!"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|noexec
operator|==
literal|0
operator|&&
name|mkdir
argument_list|(
name|repository
argument_list|,
literal|0777
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ierrno
operator|=
name|errno
expr_stmt|;
name|fperror
argument_list|(
name|logfp
argument_list|,
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"ERROR: cannot mkdir %s -- not added"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|0
argument_list|,
name|ierrno
argument_list|,
literal|"ERROR: cannot mkdir %s -- not added"
argument_list|,
name|repository
argument_list|)
expr_stmt|;
name|err
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|err
operator|=
name|import_descend
argument_list|(
name|message
argument_list|,
name|vtag
argument_list|,
name|targc
argument_list|,
name|targv
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|repository
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
else|else
name|repository
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|cwd
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot chdir to %s"
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/* the following code is taken from code in rcs/src/rcssyn.c, and returns a  * positive value if 'expstring' contains a valid RCS expansion token for  * the -k option.  If an invalid expansion is named, then return -1.  */
end_comment

begin_decl_stmt
name|char
specifier|const
modifier|*
specifier|const
name|expand_names
index|[]
init|=
block|{
comment|/* These must agree with *_EXPAND in rcs/src/rcsbase.h.  */
literal|"kv"
block|,
literal|"kvl"
block|,
literal|"k"
block|,
literal|"v"
block|,
literal|"o"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|str2expmode
parameter_list|(
name|s
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
comment|/* Yield expand mode corresponding to S, or -1 if bad.  */
block|{
return|return
name|strn2expmode
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|strn2expmode
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
name|size_t
name|n
decl_stmt|;
block|{
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|expand_names
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|memcmp
argument_list|(
operator|*
name|p
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
operator|!
operator|(
operator|*
name|p
operator|)
index|[
name|n
index|]
condition|)
return|return
name|p
operator|-
name|expand_names
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

end_unit

