begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.4 kit.  *   * General recursion handler  *   */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_include
include|#
directive|include
file|"save-cwd.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$CVSid: @(#)recurse.c 1.31 94/09/30 $"
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|USE
argument_list|(
name|rcsid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|do_dir_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_file_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|addlist
name|PROTO
argument_list|(
operator|(
name|List
operator|*
operator|*
name|listp
operator|,
name|char
operator|*
name|key
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unroll_files_proc
name|PROTO
argument_list|(
operator|(
name|Node
operator|*
name|p
operator|,
name|void
operator|*
name|closure
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|addfile
name|PROTO
argument_list|(
operator|(
name|List
operator|*
operator|*
name|listp
operator|,
name|char
operator|*
name|dir
operator|,
name|char
operator|*
name|file
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local static versions eliminates the need for globals  */
end_comment

begin_decl_stmt
specifier|static
name|FILEPROC
name|fileproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILESDONEPROC
name|filesdoneproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DIRENTPROC
name|direntproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DIRLEAVEPROC
name|dirleaveproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|which
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Dtype
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readlock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dosrcs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|update_dir
index|[
name|PATH_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|repository
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|entries
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|srcfiles
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|filelist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* holds list of files on which to operate */
end_comment

begin_decl_stmt
specifier|static
name|List
modifier|*
name|dirlist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* holds list of directories on which to operate */
end_comment

begin_struct
struct|struct
name|recursion_frame
block|{
name|FILEPROC
name|fileproc
decl_stmt|;
name|FILESDONEPROC
name|filesdoneproc
decl_stmt|;
name|DIRENTPROC
name|direntproc
decl_stmt|;
name|DIRLEAVEPROC
name|dirleaveproc
decl_stmt|;
name|Dtype
name|flags
decl_stmt|;
name|int
name|which
decl_stmt|;
name|int
name|aflag
decl_stmt|;
name|int
name|readlock
decl_stmt|;
name|int
name|dosrcs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Called to start a recursive command.  *  * Command line arguments dictate the directories and files on which  * we operate.  In the special case of no arguments, we default to  * ".".  *  * The general algorithm is as follows.  */
end_comment

begin_function
name|int
name|start_recursion
parameter_list|(
name|fileproc
parameter_list|,
name|filesdoneproc
parameter_list|,
name|direntproc
parameter_list|,
name|dirleaveproc
parameter_list|,
name|argc
parameter_list|,
name|argv
parameter_list|,
name|local
parameter_list|,
name|which
parameter_list|,
name|aflag
parameter_list|,
name|readlock
parameter_list|,
name|update_preload
parameter_list|,
name|dosrcs
parameter_list|,
name|wd_is_repos
parameter_list|)
name|FILEPROC
name|fileproc
decl_stmt|;
name|FILESDONEPROC
name|filesdoneproc
decl_stmt|;
name|DIRENTPROC
name|direntproc
decl_stmt|;
name|DIRLEAVEPROC
name|dirleaveproc
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|local
decl_stmt|;
name|int
name|which
decl_stmt|;
name|int
name|aflag
decl_stmt|;
name|int
name|readlock
decl_stmt|;
name|char
modifier|*
name|update_preload
decl_stmt|;
name|int
name|dosrcs
decl_stmt|;
name|int
name|wd_is_repos
decl_stmt|;
comment|/* Set if caller has already cd'd to the repository */
block|{
name|int
name|i
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|Dtype
name|flags
decl_stmt|;
name|List
modifier|*
name|files_by_dir
init|=
name|NULL
decl_stmt|;
name|struct
name|recursion_frame
name|frame
decl_stmt|;
if|if
condition|(
name|update_preload
operator|==
name|NULL
condition|)
name|update_dir
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|update_dir
argument_list|,
name|update_preload
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|flags
operator|=
name|R_SKIP_DIRS
expr_stmt|;
else|else
name|flags
operator|=
name|R_PROCESS
expr_stmt|;
comment|/* clean up from any previous calls to start_recursion */
if|if
condition|(
name|repository
condition|)
block|{
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|repository
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|entries
condition|)
block|{
name|Entries_Close
argument_list|(
name|entries
argument_list|)
expr_stmt|;
name|entries
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|srcfiles
condition|)
name|dellist
argument_list|(
operator|&
name|srcfiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|filelist
condition|)
name|dellist
argument_list|(
operator|&
name|filelist
argument_list|)
expr_stmt|;
comment|/* FIXME-krp: no longer correct. */
comment|/* FIXME-krp: clean up files_by_dir */
if|if
condition|(
name|dirlist
condition|)
name|dellist
argument_list|(
operator|&
name|dirlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
comment|/* 	 * There were no arguments, so we'll probably just recurse. The 	 * exception to the rule is when we are called from a directory 	 * without any CVS administration files.  That has always meant to 	 * process each of the sub-directories, so we pretend like we were 	 * called with the list of sub-dirs of the current dir as args 	 */
if|if
condition|(
operator|(
name|which
operator|&
name|W_LOCAL
operator|)
operator|&&
operator|!
name|isdir
argument_list|(
name|CVSADM
argument_list|)
condition|)
name|dirlist
operator|=
name|Find_Dirs
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|W_LOCAL
argument_list|)
expr_stmt|;
else|else
name|addlist
argument_list|(
operator|&
name|dirlist
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|err
operator|+=
name|do_recursion
argument_list|(
name|fileproc
argument_list|,
name|filesdoneproc
argument_list|,
name|direntproc
argument_list|,
name|dirleaveproc
argument_list|,
name|flags
argument_list|,
name|which
argument_list|,
name|aflag
argument_list|,
name|readlock
argument_list|,
name|dosrcs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/*      * There were arguments, so we have to handle them by hand. To do      * that, we set up the filelist and dirlist with the arguments and      * call do_recursion.  do_recursion recognizes the fact that the      * lists are non-null when it starts and doesn't update them.      *      * explicitly named directories are stored in dirlist.      * explicitly named files are stored in filelist.      * other possibility is named entities whicha are not currently in      * the working directory.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
comment|/* if this argument is a directory, then add it to the list of 	   directories. */
if|if
condition|(
operator|!
name|wrap_name_has
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|WRAP_TOCVS
argument_list|)
operator|&&
name|isdir
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|addlist
argument_list|(
operator|&
name|dirlist
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* otherwise, split argument into directory and component names. */
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|comp
decl_stmt|;
name|char
name|tmp
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|file_to_try
decl_stmt|;
name|dir
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|comp
operator|=
name|strrchr
argument_list|(
name|dir
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* no dir component.  What we have is an implied "./" */
name|comp
operator|=
name|dir
expr_stmt|;
name|dir
operator|=
name|xstrdup
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
init|=
name|comp
decl_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|comp
operator|=
name|xstrdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* if this argument exists as a file in the current 	       working directory tree, then add it to the files list.  */
if|if
condition|(
name|wd_is_repos
condition|)
block|{
comment|/* If doing rtag, we've done a chdir to the repository. */
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s%s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|RCSEXT
argument_list|)
expr_stmt|;
name|file_to_try
operator|=
name|tmp
expr_stmt|;
block|}
else|else
name|file_to_try
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|file_to_try
argument_list|)
condition|)
name|addfile
argument_list|(
operator|&
name|files_by_dir
argument_list|,
name|dir
argument_list|,
name|comp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isdir
argument_list|(
name|dir
argument_list|)
condition|)
block|{
if|if
condition|(
name|isdir
argument_list|(
name|CVSADM
argument_list|)
condition|)
block|{
comment|/* otherwise, look for it in the repository. */
name|char
modifier|*
name|save_update_dir
decl_stmt|;
name|char
modifier|*
name|repos
decl_stmt|;
comment|/* save& set (aka push) update_dir */
name|save_update_dir
operator|=
name|xstrdup
argument_list|(
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|update_dir
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* look for it in the repository. */
name|repos
operator|=
name|Name_Repository
argument_list|(
name|dir
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|repos
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wrap_name_has
argument_list|(
name|comp
argument_list|,
name|WRAP_TOCVS
argument_list|)
operator|&&
name|isdir
argument_list|(
name|tmp
argument_list|)
condition|)
name|addlist
argument_list|(
operator|&
name|dirlist
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|addfile
argument_list|(
operator|&
name|files_by_dir
argument_list|,
name|dir
argument_list|,
name|comp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|update_dir
argument_list|,
literal|"%s"
argument_list|,
name|save_update_dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|save_update_dir
argument_list|)
expr_stmt|;
block|}
else|else
name|addfile
argument_list|(
operator|&
name|files_by_dir
argument_list|,
name|dir
argument_list|,
name|comp
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"no such directory `%s'"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|comp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* At this point we have looped over all named arguments and built        a coupla lists.  Now we unroll the lists, setting up and        calling do_recursion. */
name|frame
operator|.
name|fileproc
operator|=
name|fileproc
expr_stmt|;
name|frame
operator|.
name|filesdoneproc
operator|=
name|filesdoneproc
expr_stmt|;
name|frame
operator|.
name|direntproc
operator|=
name|direntproc
expr_stmt|;
name|frame
operator|.
name|dirleaveproc
operator|=
name|dirleaveproc
expr_stmt|;
name|frame
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
name|frame
operator|.
name|which
operator|=
name|which
expr_stmt|;
name|frame
operator|.
name|aflag
operator|=
name|aflag
expr_stmt|;
name|frame
operator|.
name|readlock
operator|=
name|readlock
expr_stmt|;
name|frame
operator|.
name|dosrcs
operator|=
name|dosrcs
expr_stmt|;
name|err
operator|+=
name|walklist
argument_list|(
name|files_by_dir
argument_list|,
name|unroll_files_proc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|frame
argument_list|)
expr_stmt|;
comment|/* then do_recursion on the dirlist. */
if|if
condition|(
name|dirlist
operator|!=
name|NULL
condition|)
name|err
operator|+=
name|do_recursion
argument_list|(
name|frame
operator|.
name|fileproc
argument_list|,
name|frame
operator|.
name|filesdoneproc
argument_list|,
name|frame
operator|.
name|direntproc
argument_list|,
name|frame
operator|.
name|dirleaveproc
argument_list|,
name|frame
operator|.
name|flags
argument_list|,
name|frame
operator|.
name|which
argument_list|,
name|frame
operator|.
name|aflag
argument_list|,
name|frame
operator|.
name|readlock
argument_list|,
name|frame
operator|.
name|dosrcs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Implement the recursive policies on the local directory.  This may be  * called directly, or may be called by start_recursion  */
end_comment

begin_function
name|int
name|do_recursion
parameter_list|(
name|xfileproc
parameter_list|,
name|xfilesdoneproc
parameter_list|,
name|xdirentproc
parameter_list|,
name|xdirleaveproc
parameter_list|,
name|xflags
parameter_list|,
name|xwhich
parameter_list|,
name|xaflag
parameter_list|,
name|xreadlock
parameter_list|,
name|xdosrcs
parameter_list|)
name|FILEPROC
name|xfileproc
decl_stmt|;
name|FILESDONEPROC
name|xfilesdoneproc
decl_stmt|;
name|DIRENTPROC
name|xdirentproc
decl_stmt|;
name|DIRLEAVEPROC
name|xdirleaveproc
decl_stmt|;
name|Dtype
name|xflags
decl_stmt|;
name|int
name|xwhich
decl_stmt|;
name|int
name|xaflag
decl_stmt|;
name|int
name|xreadlock
decl_stmt|;
name|int
name|xdosrcs
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|dodoneproc
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|srepository
decl_stmt|;
comment|/* do nothing if told */
if|if
condition|(
name|xflags
operator|==
name|R_SKIP_ALL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* set up the static vars */
name|fileproc
operator|=
name|xfileproc
expr_stmt|;
name|filesdoneproc
operator|=
name|xfilesdoneproc
expr_stmt|;
name|direntproc
operator|=
name|xdirentproc
expr_stmt|;
name|dirleaveproc
operator|=
name|xdirleaveproc
expr_stmt|;
name|flags
operator|=
name|xflags
expr_stmt|;
name|which
operator|=
name|xwhich
expr_stmt|;
name|aflag
operator|=
name|xaflag
expr_stmt|;
name|readlock
operator|=
name|noexec
condition|?
literal|0
else|:
name|xreadlock
expr_stmt|;
name|dosrcs
operator|=
name|xdosrcs
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SERVER_SUPPORT
argument_list|)
operator|&&
name|defined
argument_list|(
name|SERVER_FLOWCONTROL
argument_list|)
comment|/*      * Now would be a good time to check to see if we need to stop      * generating data, to give the buffers a chance to drain to the      * remote client.  We should not have locks active at this point.      */
if|if
condition|(
name|server_active
comment|/* If there are writelocks around, we cannot pause here.  */
operator|&&
operator|(
name|readlock
operator|||
name|noexec
operator|)
condition|)
name|server_pause_check
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/*      * Fill in repository with the current repository      */
if|if
condition|(
name|which
operator|&
name|W_LOCAL
condition|)
block|{
if|if
condition|(
name|isdir
argument_list|(
name|CVSADM
argument_list|)
condition|)
name|repository
operator|=
name|Name_Repository
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
else|else
name|repository
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|repository
operator|=
name|xmalloc
argument_list|(
name|PATH_MAX
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getwd
argument_list|(
name|repository
argument_list|)
expr_stmt|;
block|}
name|srepository
operator|=
name|repository
expr_stmt|;
comment|/* remember what to free */
comment|/*      * The filesdoneproc needs to be called for each directory where files      * processed, or each directory that is processed by a call where no      * directories were passed in.  In fact, the only time we don't want to      * call back the filesdoneproc is when we are processing directories that      * were passed in on the command line (or in the special case of `.' when      * we were called with no args      */
if|if
condition|(
name|dirlist
operator|!=
name|NULL
operator|&&
name|filelist
operator|==
name|NULL
condition|)
name|dodoneproc
operator|=
literal|0
expr_stmt|;
comment|/*      * If filelist or dirlist is already set, we don't look again. Otherwise,      * find the files and directories      */
if|if
condition|(
name|filelist
operator|==
name|NULL
operator|&&
name|dirlist
operator|==
name|NULL
condition|)
block|{
comment|/* both lists were NULL, so start from scratch */
if|if
condition|(
name|fileproc
operator|!=
name|NULL
operator|&&
name|flags
operator|!=
name|R_SKIP_FILES
condition|)
block|{
name|int
name|lwhich
init|=
name|which
decl_stmt|;
comment|/* be sure to look in the attic if we have sticky tags/date */
if|if
condition|(
operator|(
name|lwhich
operator|&
name|W_ATTIC
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|isreadable
argument_list|(
name|CVSADM_TAG
argument_list|)
condition|)
name|lwhich
operator||=
name|W_ATTIC
expr_stmt|;
comment|/* find the files and fill in entries if appropriate */
name|filelist
operator|=
name|Find_Names
argument_list|(
name|repository
argument_list|,
name|lwhich
argument_list|,
name|aflag
argument_list|,
operator|&
name|entries
argument_list|)
expr_stmt|;
block|}
comment|/* find sub-directories if we will recurse */
if|if
condition|(
name|flags
operator|!=
name|R_SKIP_DIRS
condition|)
name|dirlist
operator|=
name|Find_Dirs
argument_list|(
name|repository
argument_list|,
name|which
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* something was passed on the command line */
if|if
condition|(
name|filelist
operator|!=
name|NULL
operator|&&
name|fileproc
operator|!=
name|NULL
condition|)
block|{
comment|/* we will process files, so pre-parse entries */
if|if
condition|(
name|which
operator|&
name|W_LOCAL
condition|)
name|entries
operator|=
name|Entries_Open
argument_list|(
name|aflag
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* process the files (if any) */
if|if
condition|(
name|filelist
operator|!=
name|NULL
condition|)
block|{
comment|/* read lock it if necessary */
if|if
condition|(
name|readlock
operator|&&
name|repository
operator|&&
name|Reader_Lock
argument_list|(
name|repository
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"read lock failed - giving up"
argument_list|)
expr_stmt|;
comment|/* pre-parse the source files */
if|if
condition|(
name|dosrcs
operator|&&
name|repository
condition|)
name|srcfiles
operator|=
name|RCS_parsefiles
argument_list|(
name|filelist
argument_list|,
name|repository
argument_list|)
expr_stmt|;
else|else
name|srcfiles
operator|=
operator|(
name|List
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* process the files */
name|err
operator|+=
name|walklist
argument_list|(
name|filelist
argument_list|,
name|do_file_proc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* unlock it */
if|if
condition|(
name|readlock
condition|)
name|Lock_Cleanup
argument_list|()
expr_stmt|;
comment|/* clean up */
name|dellist
argument_list|(
operator|&
name|filelist
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|srcfiles
argument_list|)
expr_stmt|;
name|Entries_Close
argument_list|(
name|entries
argument_list|)
expr_stmt|;
name|entries
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* call-back files done proc (if any) */
if|if
condition|(
name|dodoneproc
operator|&&
name|filesdoneproc
operator|!=
name|NULL
condition|)
name|err
operator|=
name|filesdoneproc
argument_list|(
name|err
argument_list|,
name|repository
argument_list|,
name|update_dir
index|[
literal|0
index|]
condition|?
name|update_dir
else|:
literal|"."
argument_list|)
expr_stmt|;
comment|/* process the directories (if necessary) */
if|if
condition|(
name|dirlist
operator|!=
name|NULL
condition|)
name|err
operator|+=
name|walklist
argument_list|(
name|dirlist
argument_list|,
name|do_dir_proc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
elseif|else
if|if
condition|(
name|dirleaveproc
operator|!=
name|NULL
condition|)
name|err
operator|+=
name|dirleaveproc
argument_list|(
literal|"."
argument_list|,
name|err
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dellist
argument_list|(
operator|&
name|dirlist
argument_list|)
expr_stmt|;
comment|/* free the saved copy of the pointer if necessary */
if|if
condition|(
name|srepository
condition|)
block|{
name|free
argument_list|(
name|srepository
argument_list|)
expr_stmt|;
name|repository
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process each of the files in the list with the callback proc  */
end_comment

begin_function
specifier|static
name|int
name|do_file_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
if|if
condition|(
name|fileproc
operator|!=
name|NULL
condition|)
return|return
operator|(
name|fileproc
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|update_dir
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|,
name|srcfiles
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process each of the directories in the list (recursing as we go)  */
end_comment

begin_function
specifier|static
name|int
name|do_dir_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|char
modifier|*
name|dir
init|=
name|p
operator|->
name|key
decl_stmt|;
name|char
name|newrepos
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|List
modifier|*
name|sdirlist
decl_stmt|;
name|char
modifier|*
name|srepository
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|Dtype
name|dir_return
init|=
name|R_PROCESS
decl_stmt|;
name|int
name|stripped_dot
init|=
literal|0
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|saved_cwd
name|cwd
decl_stmt|;
comment|/* set up update_dir - skip dots if not at start */
if|if
condition|(
name|strcmp
argument_list|(
name|dir
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|update_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* 	 * Here we need a plausible repository name for the sub-directory. We 	 * create one by concatenating the new directory name onto the 	 * previous repository name.  The only case where the name should be 	 * used is in the case where we are creating a new sub-directory for 	 * update -d and in that case the generated name will be correct. 	 */
if|if
condition|(
name|repository
operator|==
name|NULL
condition|)
name|newrepos
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|newrepos
argument_list|,
literal|"%s/%s"
argument_list|,
name|repository
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|update_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|repository
operator|==
name|NULL
condition|)
name|newrepos
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|newrepos
argument_list|,
name|repository
argument_list|)
expr_stmt|;
block|}
comment|/* call-back dir entry proc (if any) */
if|if
condition|(
name|direntproc
operator|!=
name|NULL
condition|)
name|dir_return
operator|=
name|direntproc
argument_list|(
name|dir
argument_list|,
name|newrepos
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
comment|/* only process the dir if the return code was 0 */
if|if
condition|(
name|dir_return
operator|!=
name|R_SKIP_ALL
condition|)
block|{
comment|/* save our current directory and static vars */
if|if
condition|(
name|save_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sdirlist
operator|=
name|dirlist
expr_stmt|;
name|srepository
operator|=
name|repository
expr_stmt|;
name|dirlist
operator|=
name|NULL
expr_stmt|;
comment|/* cd to the sub-directory */
if|if
condition|(
name|chdir
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* honor the global SKIP_DIRS (a.k.a. local) */
if|if
condition|(
name|flags
operator|==
name|R_SKIP_DIRS
condition|)
name|dir_return
operator|=
name|R_SKIP_DIRS
expr_stmt|;
comment|/* remember if the `.' will be stripped for subsequent dirs */
if|if
condition|(
name|strcmp
argument_list|(
name|update_dir
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|update_dir
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|stripped_dot
operator|=
literal|1
expr_stmt|;
block|}
comment|/* make the recursive call */
name|err
operator|+=
name|do_recursion
argument_list|(
name|fileproc
argument_list|,
name|filesdoneproc
argument_list|,
name|direntproc
argument_list|,
name|dirleaveproc
argument_list|,
name|dir_return
argument_list|,
name|which
argument_list|,
name|aflag
argument_list|,
name|readlock
argument_list|,
name|dosrcs
argument_list|)
expr_stmt|;
comment|/* put the `.' back if necessary */
if|if
condition|(
name|stripped_dot
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|update_dir
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
comment|/* call-back dir leave proc (if any) */
if|if
condition|(
name|dirleaveproc
operator|!=
name|NULL
condition|)
name|err
operator|=
name|dirleaveproc
argument_list|(
name|dir
argument_list|,
name|err
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
comment|/* get back to where we started and restore state vars */
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
name|dirlist
operator|=
name|sdirlist
expr_stmt|;
name|repository
operator|=
name|srepository
expr_stmt|;
block|}
comment|/* put back update_dir */
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|update_dir
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
else|else
name|update_dir
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a node to a list allocating the list if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|addlist
parameter_list|(
name|listp
parameter_list|,
name|key
parameter_list|)
name|List
modifier|*
modifier|*
name|listp
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|listp
operator|==
name|NULL
condition|)
operator|*
name|listp
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|FILES
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|addnode
argument_list|(
operator|*
name|listp
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
name|freenode
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|addfile
parameter_list|(
name|listp
parameter_list|,
name|dir
parameter_list|,
name|file
parameter_list|)
name|List
modifier|*
modifier|*
name|listp
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|Node
modifier|*
name|n
decl_stmt|;
comment|/* add this dir. */
name|addlist
argument_list|(
name|listp
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|n
operator|=
name|findnode
argument_list|(
operator|*
name|listp
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"can't find recently added dir node `%s' in start_recursion."
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
name|n
operator|->
name|type
operator|=
name|DIRS
expr_stmt|;
name|addlist
argument_list|(
operator|(
name|List
operator|*
operator|*
operator|)
operator|&
name|n
operator|->
name|data
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|unroll_files_proc
parameter_list|(
name|p
parameter_list|,
name|closure
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|Node
modifier|*
name|n
decl_stmt|;
name|struct
name|recursion_frame
modifier|*
name|frame
init|=
operator|(
expr|struct
name|recursion_frame
operator|*
operator|)
name|closure
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|List
modifier|*
name|save_dirlist
decl_stmt|;
name|char
modifier|*
name|save_update_dir
init|=
name|NULL
decl_stmt|;
name|struct
name|saved_cwd
name|cwd
decl_stmt|;
comment|/* if this dir was also an explicitly named argument, then skip        it.  We'll catch it later when we do dirs. */
name|n
operator|=
name|findnode
argument_list|(
name|dirlist
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* otherwise, call dorecusion for this list of files. */
name|filelist
operator|=
operator|(
name|List
operator|*
operator|)
name|p
operator|->
name|data
expr_stmt|;
name|save_dirlist
operator|=
name|dirlist
expr_stmt|;
name|dirlist
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|key
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|save_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|p
operator|->
name|key
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
name|save_update_dir
operator|=
name|xstrdup
argument_list|(
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|update_dir
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
name|p
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
name|err
operator|+=
name|do_recursion
argument_list|(
name|frame
operator|->
name|fileproc
argument_list|,
name|frame
operator|->
name|filesdoneproc
argument_list|,
name|frame
operator|->
name|direntproc
argument_list|,
name|frame
operator|->
name|dirleaveproc
argument_list|,
name|frame
operator|->
name|flags
argument_list|,
name|frame
operator|->
name|which
argument_list|,
name|frame
operator|->
name|aflag
argument_list|,
name|frame
operator|->
name|readlock
argument_list|,
name|frame
operator|->
name|dosrcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_update_dir
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|update_dir
argument_list|,
name|save_update_dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|save_update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|restore_cwd
argument_list|(
operator|&
name|cwd
argument_list|,
name|NULL
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|free_cwd
argument_list|(
operator|&
name|cwd
argument_list|)
expr_stmt|;
block|}
name|dirlist
operator|=
name|save_dirlist
expr_stmt|;
name|filelist
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

