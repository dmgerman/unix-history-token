begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, Brian Berliner and Jeff Polk  *   * You may distribute under the terms of the GNU General Public License as  * specified in the README file that comes with the CVS 1.3 kit.  *   * General recursion handler  *   */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"@(#)recurse.c 1.22 92/04/10"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function_decl
specifier|static
name|int
name|do_dir_proc
parameter_list|(
name|Node
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_file_proc
parameter_list|(
name|Node
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|addlist
parameter_list|(
name|List
modifier|*
modifier|*
name|listp
parameter_list|,
name|char
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|int
name|do_file_proc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_dir_proc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|addlist
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STDC__ */
end_comment

begin_comment
comment|/*  * Local static versions eliminates the need for globals  */
end_comment

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|fileproc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|filesdoneproc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Dtype
function_decl|(
modifier|*
name|direntproc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|dirleaveproc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|which
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Dtype
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readlock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dosrcs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|update_dir
index|[
name|PATH_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|repository
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|entries
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|srcfiles
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|filelist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|List
modifier|*
name|dirlist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Called to start a recursive command Command line arguments are processed  * if present, otherwise the local directory is processed.  */
end_comment

begin_decl_stmt
name|int
name|start_recursion
argument_list|(
name|fileproc
argument_list|,
name|filesdoneproc
argument_list|,
name|direntproc
argument_list|,
name|dirleaveproc
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|local
argument_list|,
name|which
argument_list|,
name|aflag
argument_list|,
name|readlock
argument_list|,
name|update_preload
argument_list|,
name|dosrcs
argument_list|)
name|int
argument_list|(
operator|*
name|fileproc
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|filesdoneproc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Dtype
function_decl|(
modifier|*
name|direntproc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|dirleaveproc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|local
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|which
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|aflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|readlock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|update_preload
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dosrcs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|Dtype
name|flags
decl_stmt|;
if|if
condition|(
name|update_preload
operator|==
name|NULL
condition|)
name|update_dir
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|update_dir
argument_list|,
name|update_preload
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
name|flags
operator|=
name|R_SKIP_DIRS
expr_stmt|;
else|else
name|flags
operator|=
name|R_PROCESS
expr_stmt|;
comment|/* clean up from any previous calls to start_recursion */
if|if
condition|(
name|repository
condition|)
block|{
name|free
argument_list|(
name|repository
argument_list|)
expr_stmt|;
name|repository
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|entries
condition|)
name|dellist
argument_list|(
operator|&
name|entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcfiles
condition|)
name|dellist
argument_list|(
operator|&
name|srcfiles
argument_list|)
expr_stmt|;
if|if
condition|(
name|filelist
condition|)
name|dellist
argument_list|(
operator|&
name|filelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirlist
condition|)
name|dellist
argument_list|(
operator|&
name|dirlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
comment|/* 	 * There were no arguments, so we'll probably just recurse. The 	 * exception to the rule is when we are called from a directory 	 * without any CVS administration files.  That has always meant to 	 * process each of the sub-directories, so we pretend like we were 	 * called with the list of sub-dirs of the current dir as args 	 */
if|if
condition|(
operator|(
name|which
operator|&
name|W_LOCAL
operator|)
operator|&&
operator|!
name|isdir
argument_list|(
name|CVSADM
argument_list|)
operator|&&
operator|!
name|isdir
argument_list|(
name|OCVSADM
argument_list|)
condition|)
name|dirlist
operator|=
name|Find_Dirs
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|W_LOCAL
argument_list|)
expr_stmt|;
else|else
name|addlist
argument_list|(
operator|&
name|dirlist
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|err
operator|+=
name|do_recursion
argument_list|(
name|fileproc
argument_list|,
name|filesdoneproc
argument_list|,
name|direntproc
argument_list|,
name|dirleaveproc
argument_list|,
name|flags
argument_list|,
name|which
argument_list|,
name|aflag
argument_list|,
name|readlock
argument_list|,
name|dosrcs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * There were arguments, so we have to handle them by hand. To do 	 * that, we set up the filelist and dirlist with the arguments and 	 * call do_recursion.  do_recursion recognizes the fact that the 	 * lists are non-null when it starts and doesn't update them 	 */
comment|/* look for args with /-s in them */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|index
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
comment|/* if we didn't find any hard one's, do it the easy way */
if|if
condition|(
name|i
operator|==
name|argc
condition|)
block|{
comment|/* set up the lists */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isdir
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|addlist
argument_list|(
operator|&
name|dirlist
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|isdir
argument_list|(
name|CVSADM
argument_list|)
operator|||
name|isdir
argument_list|(
name|OCVSADM
argument_list|)
condition|)
block|{
name|char
modifier|*
name|repos
decl_stmt|;
name|char
name|tmp
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|repos
operator|=
name|Name_Repository
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|repos
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdir
argument_list|(
name|tmp
argument_list|)
condition|)
name|addlist
argument_list|(
operator|&
name|dirlist
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|addlist
argument_list|(
operator|&
name|filelist
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repos
argument_list|)
expr_stmt|;
block|}
else|else
name|addlist
argument_list|(
operator|&
name|filelist
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* we aren't recursive if no directories were specified */
if|if
condition|(
name|dirlist
operator|==
name|NULL
condition|)
name|local
operator|=
literal|1
expr_stmt|;
comment|/* process the lists */
name|err
operator|+=
name|do_recursion
argument_list|(
name|fileproc
argument_list|,
name|filesdoneproc
argument_list|,
name|direntproc
argument_list|,
name|dirleaveproc
argument_list|,
name|flags
argument_list|,
name|which
argument_list|,
name|aflag
argument_list|,
name|readlock
argument_list|,
name|dosrcs
argument_list|)
expr_stmt|;
block|}
comment|/* otherwise - do it the hard way */
else|else
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|dir
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|char
modifier|*
name|comp
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|char
modifier|*
name|oldupdate
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|char
name|savewd
index|[
name|PATH_MAX
index|]
decl_stmt|;
if|if
condition|(
name|getwd
argument_list|(
name|savewd
argument_list|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"could not get working directory: %s"
argument_list|,
name|savewd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
comment|/* split the arg into the dir and component parts */
name|dir
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|dir
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|comp
operator|=
name|xstrdup
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|oldupdate
operator|=
name|xstrdup
argument_list|(
name|update_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|comp
operator|=
name|xstrdup
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
condition|)
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|dir
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* chdir to the appropriate place if necessary */
if|if
condition|(
name|dir
operator|&&
name|chdir
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* set up the list */
if|if
condition|(
name|isdir
argument_list|(
name|comp
argument_list|)
condition|)
name|addlist
argument_list|(
operator|&
name|dirlist
argument_list|,
name|comp
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|isdir
argument_list|(
name|CVSADM
argument_list|)
operator|||
name|isdir
argument_list|(
name|OCVSADM
argument_list|)
condition|)
block|{
name|char
modifier|*
name|repos
decl_stmt|;
name|char
name|tmp
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|repos
operator|=
name|Name_Repository
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|repos
argument_list|,
name|comp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdir
argument_list|(
name|tmp
argument_list|)
condition|)
name|addlist
argument_list|(
operator|&
name|dirlist
argument_list|,
name|comp
argument_list|)
expr_stmt|;
else|else
name|addlist
argument_list|(
operator|&
name|filelist
argument_list|,
name|comp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|repos
argument_list|)
expr_stmt|;
block|}
else|else
name|addlist
argument_list|(
operator|&
name|filelist
argument_list|,
name|comp
argument_list|)
expr_stmt|;
block|}
comment|/* do the recursion */
name|err
operator|+=
name|do_recursion
argument_list|(
name|fileproc
argument_list|,
name|filesdoneproc
argument_list|,
name|direntproc
argument_list|,
name|dirleaveproc
argument_list|,
name|flags
argument_list|,
name|which
argument_list|,
name|aflag
argument_list|,
name|readlock
argument_list|,
name|dosrcs
argument_list|)
expr_stmt|;
comment|/* chdir back and fix update_dir if necessary */
if|if
condition|(
name|dir
operator|&&
name|chdir
argument_list|(
name|savewd
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldupdate
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|update_dir
argument_list|,
name|oldupdate
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oldupdate
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dir
condition|)
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp
condition|)
name|free
argument_list|(
name|comp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Implement the recursive policies on the local directory.  This may be  * called directly, or may be called by start_recursion  */
end_comment

begin_decl_stmt
name|int
name|do_recursion
argument_list|(
name|xfileproc
argument_list|,
name|xfilesdoneproc
argument_list|,
name|xdirentproc
argument_list|,
name|xdirleaveproc
argument_list|,
name|xflags
argument_list|,
name|xwhich
argument_list|,
name|xaflag
argument_list|,
name|xreadlock
argument_list|,
name|xdosrcs
argument_list|)
name|int
argument_list|(
operator|*
name|xfileproc
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|xfilesdoneproc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|Dtype
function_decl|(
modifier|*
name|xdirentproc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|xdirleaveproc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|Dtype
name|xflags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xwhich
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xaflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xreadlock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xdosrcs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|dodoneproc
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|srepository
decl_stmt|;
comment|/* do nothing if told */
if|if
condition|(
name|xflags
operator|==
name|R_SKIP_ALL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* set up the static vars */
name|fileproc
operator|=
name|xfileproc
expr_stmt|;
name|filesdoneproc
operator|=
name|xfilesdoneproc
expr_stmt|;
name|direntproc
operator|=
name|xdirentproc
expr_stmt|;
name|dirleaveproc
operator|=
name|xdirleaveproc
expr_stmt|;
name|flags
operator|=
name|xflags
expr_stmt|;
name|which
operator|=
name|xwhich
expr_stmt|;
name|aflag
operator|=
name|xaflag
expr_stmt|;
name|readlock
operator|=
name|noexec
condition|?
literal|0
else|:
name|xreadlock
expr_stmt|;
name|dosrcs
operator|=
name|xdosrcs
expr_stmt|;
comment|/*      * Fill in repository with the current repository      */
if|if
condition|(
name|which
operator|&
name|W_LOCAL
condition|)
block|{
if|if
condition|(
name|isdir
argument_list|(
name|CVSADM
argument_list|)
operator|||
name|isdir
argument_list|(
name|OCVSADM
argument_list|)
condition|)
name|repository
operator|=
name|Name_Repository
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
else|else
name|repository
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|repository
operator|=
name|xmalloc
argument_list|(
name|PATH_MAX
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getwd
argument_list|(
name|repository
argument_list|)
expr_stmt|;
block|}
name|srepository
operator|=
name|repository
expr_stmt|;
comment|/* remember what to free */
comment|/*      * The filesdoneproc needs to be called for each directory where files      * processed, or each directory that is processed by a call where no      * directories were passed in.  In fact, the only time we don't want to      * call back the filesdoneproc is when we are processing directories that      * were passed in on the command line (or in the special case of `.' when      * we were called with no args      */
if|if
condition|(
name|dirlist
operator|!=
name|NULL
operator|&&
name|filelist
operator|==
name|NULL
condition|)
name|dodoneproc
operator|=
literal|0
expr_stmt|;
comment|/*      * If filelist or dirlist is already set, we don't look again. Otherwise,      * find the files and directories      */
if|if
condition|(
name|filelist
operator|==
name|NULL
operator|&&
name|dirlist
operator|==
name|NULL
condition|)
block|{
comment|/* both lists were NULL, so start from scratch */
if|if
condition|(
name|fileproc
operator|!=
name|NULL
operator|&&
name|flags
operator|!=
name|R_SKIP_FILES
condition|)
block|{
name|int
name|lwhich
init|=
name|which
decl_stmt|;
comment|/* be sure to look in the attic if we have sticky tags/date */
if|if
condition|(
operator|(
name|lwhich
operator|&
name|W_ATTIC
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
name|isreadable
argument_list|(
name|CVSADM_TAG
argument_list|)
condition|)
name|lwhich
operator||=
name|W_ATTIC
expr_stmt|;
comment|/* find the files and fill in entries if appropriate */
name|filelist
operator|=
name|Find_Names
argument_list|(
name|repository
argument_list|,
name|lwhich
argument_list|,
name|aflag
argument_list|,
operator|&
name|entries
argument_list|)
expr_stmt|;
block|}
comment|/* find sub-directories if we will recurse */
if|if
condition|(
name|flags
operator|!=
name|R_SKIP_DIRS
condition|)
name|dirlist
operator|=
name|Find_Dirs
argument_list|(
name|repository
argument_list|,
name|which
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* something was passed on the command line */
if|if
condition|(
name|filelist
operator|!=
name|NULL
operator|&&
name|fileproc
operator|!=
name|NULL
condition|)
block|{
comment|/* we will process files, so pre-parse entries */
if|if
condition|(
name|which
operator|&
name|W_LOCAL
condition|)
name|entries
operator|=
name|ParseEntries
argument_list|(
name|aflag
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* process the files (if any) */
if|if
condition|(
name|filelist
operator|!=
name|NULL
condition|)
block|{
comment|/* read lock it if necessary */
if|if
condition|(
name|readlock
operator|&&
name|repository
operator|&&
name|Reader_Lock
argument_list|(
name|repository
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"read lock failed - giving up"
argument_list|)
expr_stmt|;
comment|/* pre-parse the source files */
if|if
condition|(
name|dosrcs
operator|&&
name|repository
condition|)
name|srcfiles
operator|=
name|RCS_parsefiles
argument_list|(
name|filelist
argument_list|,
name|repository
argument_list|)
expr_stmt|;
else|else
name|srcfiles
operator|=
operator|(
name|List
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* process the files */
name|err
operator|+=
name|walklist
argument_list|(
name|filelist
argument_list|,
name|do_file_proc
argument_list|)
expr_stmt|;
comment|/* unlock it */
if|if
condition|(
name|readlock
condition|)
name|Lock_Cleanup
argument_list|()
expr_stmt|;
comment|/* clean up */
name|dellist
argument_list|(
operator|&
name|filelist
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|srcfiles
argument_list|)
expr_stmt|;
name|dellist
argument_list|(
operator|&
name|entries
argument_list|)
expr_stmt|;
block|}
comment|/* call-back files done proc (if any) */
if|if
condition|(
name|dodoneproc
operator|&&
name|filesdoneproc
operator|!=
name|NULL
condition|)
name|err
operator|=
name|filesdoneproc
argument_list|(
name|err
argument_list|,
name|repository
argument_list|,
name|update_dir
index|[
literal|0
index|]
condition|?
name|update_dir
else|:
literal|"."
argument_list|)
expr_stmt|;
comment|/* process the directories (if necessary) */
if|if
condition|(
name|dirlist
operator|!=
name|NULL
condition|)
name|err
operator|+=
name|walklist
argument_list|(
name|dirlist
argument_list|,
name|do_dir_proc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
elseif|else
if|if
condition|(
name|dirleaveproc
operator|!=
name|NULL
condition|)
name|err
operator|+=
name|dirleaveproc
argument_list|(
literal|"."
argument_list|,
name|err
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dellist
argument_list|(
operator|&
name|dirlist
argument_list|)
expr_stmt|;
comment|/* free the saved copy of the pointer if necessary */
if|if
condition|(
name|srepository
condition|)
block|{
operator|(
name|void
operator|)
name|free
argument_list|(
name|srepository
argument_list|)
expr_stmt|;
name|repository
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Process each of the files in the list with the callback proc  */
end_comment

begin_function
specifier|static
name|int
name|do_file_proc
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|fileproc
operator|!=
name|NULL
condition|)
return|return
operator|(
name|fileproc
argument_list|(
name|p
operator|->
name|key
argument_list|,
name|update_dir
argument_list|,
name|repository
argument_list|,
name|entries
argument_list|,
name|srcfiles
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process each of the directories in the list (recursing as we go)  */
end_comment

begin_function
specifier|static
name|int
name|do_dir_proc
parameter_list|(
name|p
parameter_list|)
name|Node
modifier|*
name|p
decl_stmt|;
block|{
name|char
modifier|*
name|dir
init|=
name|p
operator|->
name|key
decl_stmt|;
name|char
name|savewd
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|newrepos
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|List
modifier|*
name|sdirlist
decl_stmt|;
name|char
modifier|*
name|srepository
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|Dtype
name|dir_return
init|=
name|R_PROCESS
decl_stmt|;
name|int
name|stripped_dot
init|=
literal|0
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* set up update_dir - skip dots if not at start */
if|if
condition|(
name|strcmp
argument_list|(
name|dir
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|update_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|update_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* 	 * Here we need a plausible repository name for the sub-directory. We 	 * create one by concatenating the new directory name onto the 	 * previous repository name.  The only case where the name should be 	 * used is in the case where we are creating a new sub-directory for 	 * update -d and in that case the generated name will be correct. 	 */
if|if
condition|(
name|repository
operator|==
name|NULL
condition|)
name|newrepos
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|newrepos
argument_list|,
literal|"%s/%s"
argument_list|,
name|repository
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|update_dir
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|update_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|repository
operator|==
name|NULL
condition|)
name|newrepos
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|newrepos
argument_list|,
name|repository
argument_list|)
expr_stmt|;
block|}
comment|/* call-back dir entry proc (if any) */
if|if
condition|(
name|direntproc
operator|!=
name|NULL
condition|)
name|dir_return
operator|=
name|direntproc
argument_list|(
name|dir
argument_list|,
name|newrepos
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
comment|/* only process the dir if the return code was 0 */
if|if
condition|(
name|dir_return
operator|!=
name|R_SKIP_ALL
condition|)
block|{
comment|/* save our current directory and static vars */
if|if
condition|(
name|getwd
argument_list|(
name|savewd
argument_list|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"could not get working directory: %s"
argument_list|,
name|savewd
argument_list|)
expr_stmt|;
name|sdirlist
operator|=
name|dirlist
expr_stmt|;
name|srepository
operator|=
name|repository
expr_stmt|;
name|dirlist
operator|=
name|NULL
expr_stmt|;
comment|/* cd to the sub-directory */
if|if
condition|(
name|chdir
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* honor the global SKIP_DIRS (a.k.a. local) */
if|if
condition|(
name|flags
operator|==
name|R_SKIP_DIRS
condition|)
name|dir_return
operator|=
name|R_SKIP_DIRS
expr_stmt|;
comment|/* remember if the `.' will be stripped for subsequent dirs */
if|if
condition|(
name|strcmp
argument_list|(
name|update_dir
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|update_dir
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|stripped_dot
operator|=
literal|1
expr_stmt|;
block|}
comment|/* make the recursive call */
name|err
operator|+=
name|do_recursion
argument_list|(
name|fileproc
argument_list|,
name|filesdoneproc
argument_list|,
name|direntproc
argument_list|,
name|dirleaveproc
argument_list|,
name|dir_return
argument_list|,
name|which
argument_list|,
name|aflag
argument_list|,
name|readlock
argument_list|,
name|dosrcs
argument_list|)
expr_stmt|;
comment|/* put the `.' back if necessary */
if|if
condition|(
name|stripped_dot
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|update_dir
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
comment|/* call-back dir leave proc (if any) */
if|if
condition|(
name|dirleaveproc
operator|!=
name|NULL
condition|)
name|err
operator|=
name|dirleaveproc
argument_list|(
name|dir
argument_list|,
name|err
argument_list|,
name|update_dir
argument_list|)
expr_stmt|;
comment|/* get back to where we started and restore state vars */
if|if
condition|(
name|chdir
argument_list|(
name|savewd
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"could not chdir to %s"
argument_list|,
name|savewd
argument_list|)
expr_stmt|;
name|dirlist
operator|=
name|sdirlist
expr_stmt|;
name|repository
operator|=
name|srepository
expr_stmt|;
block|}
comment|/* put back update_dir */
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|update_dir
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
else|else
name|update_dir
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a node to a list allocating the list if necessary  */
end_comment

begin_function
specifier|static
name|void
name|addlist
parameter_list|(
name|listp
parameter_list|,
name|key
parameter_list|)
name|List
modifier|*
modifier|*
name|listp
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
block|{
name|Node
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|listp
operator|==
name|NULL
condition|)
operator|*
name|listp
operator|=
name|getlist
argument_list|()
expr_stmt|;
name|p
operator|=
name|getnode
argument_list|()
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|FILES
expr_stmt|;
name|p
operator|->
name|key
operator|=
name|xstrdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|addnode
argument_list|(
operator|*
name|listp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

