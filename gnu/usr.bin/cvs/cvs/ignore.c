begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * .cvsignore file support contributed by David G. Grubbs<dgg@odi.com>  */
end_comment

begin_include
include|#
directive|include
file|"cvs.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$CVSid: @(#)ignore.c 1.16 94/09/24 $"
decl_stmt|;
end_decl_stmt

begin_macro
name|USE
argument_list|(
argument|rcsid
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Ignore file section.  *   *	"!" may be included any time to reset the list (i.e. ignore nothing);  *	"*" may be specified to ignore everything.  It stays as the first  *	    element forever, unless a "!" clears it out.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|ign_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of files to ignore in update 					 * and import */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|s_ign_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ign_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of active entries */
end_comment

begin_decl_stmt
specifier|static
name|int
name|s_ign_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ign_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This many slots available (plus 					 * one for a NULL) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ign_hold
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index where first "temporary" item 					 * is held */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ign_default
init|=
literal|". .. core RCSLOG tags TAGS RCS SCCS .make.state .nse_depinfo #* .#* cvslog.* ,* CVS* .del-* *.a *.o *.so *.Z *~ *.old *.elc *.ln *.bak *.BAK *.orig *.rej *.info *.db"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IGN_GROW
value|16
end_define

begin_comment
comment|/* grow the list by 16 elements at a 					 * time */
end_comment

begin_comment
comment|/*  * To the "ignore list", add the hard-coded default ignored wildcards above,  * the wildcards found in $CVSROOT/CVSROOT/cvsignore, the wildcards found in  * ~/.cvsignore and the wildcards found in the CVSIGNORE environment  * variable.  */
end_comment

begin_function
name|void
name|ign_setup
parameter_list|()
block|{
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|char
name|file
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
comment|/* Start with default list and special case */
name|tmp
operator|=
name|xstrdup
argument_list|(
name|ign_default
argument_list|)
expr_stmt|;
name|ign_add
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
comment|/* Then add entries found in repository, if it exists */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|CVSroot
argument_list|,
name|CVSROOTADM
argument_list|,
name|CVSROOTADM_IGNORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|file
argument_list|)
condition|)
name|ign_add_file
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Then add entries found in home dir, (if user has one) and file exists */
if|if
condition|(
operator|(
name|pw
operator|=
operator|(
expr|struct
name|passwd
operator|*
operator|)
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|)
operator|&&
name|pw
operator|->
name|pw_dir
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"%s/%s"
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|,
name|CVSDOTIGNORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
argument_list|(
name|file
argument_list|)
condition|)
name|ign_add_file
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Then add entries found in CVSIGNORE environment variable. */
name|ign_add
argument_list|(
name|getenv
argument_list|(
name|IGNORE_ENV
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Later, add ignore entries found in -I arguments */
block|}
end_function

begin_comment
comment|/*  * Open a file and read lines, feeding each line to a line parser. Arrange  * for keeping a temporary list of wildcards at the end, if the "hold"  * argument is set.  */
end_comment

begin_function
name|void
name|ign_add_file
parameter_list|(
name|file
parameter_list|,
name|hold
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|hold
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|line
index|[
literal|1024
index|]
decl_stmt|;
comment|/* restore the saved list (if any) */
if|if
condition|(
name|s_ign_list
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s_ign_count
condition|;
name|i
operator|++
control|)
name|ign_list
index|[
name|i
index|]
operator|=
name|s_ign_list
index|[
name|i
index|]
expr_stmt|;
name|ign_count
operator|=
name|s_ign_count
expr_stmt|;
name|ign_list
index|[
name|ign_count
index|]
operator|=
name|NULL
expr_stmt|;
name|s_ign_count
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|s_ign_list
argument_list|)
expr_stmt|;
name|s_ign_list
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* is this a temporary ignore file? */
if|if
condition|(
name|hold
condition|)
block|{
comment|/* re-set if we had already done a temporary file */
if|if
condition|(
name|ign_hold
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ign_hold
init|;
name|i
operator|<
name|ign_count
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|ign_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ign_count
operator|=
name|ign_hold
expr_stmt|;
name|ign_list
index|[
name|ign_count
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ign_hold
operator|=
name|ign_count
expr_stmt|;
block|}
block|}
comment|/* load the file */
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
return|return;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
name|ign_add
argument_list|(
name|line
argument_list|,
name|hold
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a line of space-separated wildcards and add them to the list. */
end_comment

begin_function
name|void
name|ign_add
parameter_list|(
name|ign
parameter_list|,
name|hold
parameter_list|)
name|char
modifier|*
name|ign
decl_stmt|;
name|int
name|hold
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|ign
operator|||
operator|!
operator|*
name|ign
condition|)
return|return;
for|for
control|(
init|;
operator|*
name|ign
condition|;
name|ign
operator|++
control|)
block|{
name|char
modifier|*
name|mark
decl_stmt|;
name|char
name|save
decl_stmt|;
comment|/* ignore whitespace before the token */
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|ign
argument_list|)
condition|)
continue|continue;
comment|/* 	 * if we find a single character !, we must re-set the ignore list 	 * (saving it if necessary).  We also catch * as a special case in a 	 * global ignore file as an optimization 	 */
if|if
condition|(
operator|(
operator|!
operator|*
operator|(
name|ign
operator|+
literal|1
operator|)
operator|||
name|isspace
argument_list|(
operator|*
operator|(
name|ign
operator|+
literal|1
operator|)
argument_list|)
operator|)
operator|&&
operator|(
operator|*
name|ign
operator|==
literal|'!'
operator|||
operator|*
name|ign
operator|==
literal|'*'
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|hold
condition|)
block|{
comment|/* permanently reset the ignore list */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ign_count
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|ign_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ign_count
operator|=
literal|0
expr_stmt|;
name|ign_list
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* if we are doing a '!', continue; otherwise add the '*' */
if|if
condition|(
operator|*
name|ign
operator|==
literal|'!'
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|*
name|ign
operator|==
literal|'!'
condition|)
block|{
comment|/* temporarily reset the ignore list */
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ign_hold
condition|)
block|{
for|for
control|(
name|i
operator|=
name|ign_hold
init|;
name|i
operator|<
name|ign_count
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|ign_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ign_hold
operator|=
literal|0
expr_stmt|;
block|}
name|s_ign_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|ign_count
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ign_count
condition|;
name|i
operator|++
control|)
name|s_ign_list
index|[
name|i
index|]
operator|=
name|ign_list
index|[
name|i
index|]
expr_stmt|;
name|s_ign_count
operator|=
name|ign_count
expr_stmt|;
name|ign_count
operator|=
literal|0
expr_stmt|;
name|ign_list
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* If we have used up all the space, add some more */
if|if
condition|(
name|ign_count
operator|>=
name|ign_size
condition|)
block|{
name|ign_size
operator|+=
name|IGN_GROW
expr_stmt|;
name|ign_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ign_list
argument_list|,
operator|(
name|ign_size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* find the end of this token */
for|for
control|(
name|mark
operator|=
name|ign
init|;
operator|*
name|mark
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|mark
argument_list|)
condition|;
name|mark
operator|++
control|)
comment|/* do nothing */
empty_stmt|;
name|save
operator|=
operator|*
name|mark
expr_stmt|;
operator|*
name|mark
operator|=
literal|'\0'
expr_stmt|;
name|ign_list
index|[
name|ign_count
operator|++
index|]
operator|=
name|xstrdup
argument_list|(
name|ign
argument_list|)
expr_stmt|;
name|ign_list
index|[
name|ign_count
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|mark
operator|=
name|save
expr_stmt|;
if|if
condition|(
name|save
condition|)
name|ign
operator|=
name|mark
expr_stmt|;
else|else
name|ign
operator|=
name|mark
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if the given filename should be ignored by update or import. */
end_comment

begin_function
name|int
name|ign_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|cpp
init|=
name|ign_list
decl_stmt|;
if|if
condition|(
name|cpp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
operator|*
name|cpp
condition|)
if|if
condition|(
name|fnmatch
argument_list|(
operator|*
name|cpp
operator|++
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|dir_ign_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dir_ign_max
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dir_ign_current
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* add a directory to list of dirs to ignore */
end_comment

begin_function
name|void
name|ign_dir_add
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
comment|/* make sure we've got the space for the entry */
if|if
condition|(
name|dir_ign_current
operator|<=
name|dir_ign_max
condition|)
block|{
name|dir_ign_max
operator|+=
name|IGN_GROW
expr_stmt|;
name|dir_ign_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dir_ign_list
argument_list|,
operator|(
name|dir_ign_max
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dir_ign_list
index|[
name|dir_ign_current
index|]
operator|=
name|name
expr_stmt|;
name|dir_ign_current
operator|+=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* this function returns 1 (true) if the given directory name is part of  * the list of directories to ignore  */
end_comment

begin_function
name|int
name|ignore_directory
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dir_ign_list
condition|)
return|return
literal|0
return|;
name|i
operator|=
name|dir_ign_current
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|dir_ign_list
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|dir_ign_list
index|[
name|i
index|]
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

