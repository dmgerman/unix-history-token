begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* #ifdef-format output routines for GNU DIFF.    Copyright (C) 1989, 91, 92, 93 Free Software Foundation, Inc.  This file is part of GNU DIFF.  GNU DIFF is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU DIFF General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU DIFF, but only under the conditions described in the GNU DIFF General Public License.   A copy of this license is supposed to have been given to you along with GNU DIFF so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_struct
struct|struct
name|group
block|{
name|struct
name|file_data
specifier|const
modifier|*
name|file
decl_stmt|;
name|int
name|from
decl_stmt|,
name|upto
decl_stmt|;
comment|/* start and limit lines for this group of lines */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
modifier|*
name|format_group
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|group
specifier|const
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scan_char_literal
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scan_printf_spec
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|groups_letter_value
name|PARAMS
argument_list|(
operator|(
expr|struct
name|group
specifier|const
index|[]
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|format_ifdef
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_ifdef_hunk
name|PARAMS
argument_list|(
operator|(
expr|struct
name|change
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_ifdef_lines
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|group
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|next_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print the edit-script SCRIPT as a merged #ifdef file.  */
end_comment

begin_function
name|void
name|print_ifdef_script
parameter_list|(
name|script
parameter_list|)
name|struct
name|change
modifier|*
name|script
decl_stmt|;
block|{
name|next_line
operator|=
operator|-
name|files
index|[
literal|0
index|]
operator|.
name|prefix_lines
expr_stmt|;
name|print_script
argument_list|(
name|script
argument_list|,
name|find_change
argument_list|,
name|print_ifdef_hunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_line
operator|<
name|files
index|[
literal|0
index|]
operator|.
name|valid_lines
condition|)
block|{
name|begin_output
argument_list|()
expr_stmt|;
name|format_ifdef
argument_list|(
name|group_format
index|[
name|UNCHANGED
index|]
argument_list|,
name|next_line
argument_list|,
name|files
index|[
literal|0
index|]
operator|.
name|valid_lines
argument_list|,
name|next_line
operator|-
name|files
index|[
literal|0
index|]
operator|.
name|valid_lines
operator|+
name|files
index|[
literal|1
index|]
operator|.
name|valid_lines
argument_list|,
name|files
index|[
literal|1
index|]
operator|.
name|valid_lines
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a hunk of an ifdef diff.    This is a contiguous portion of a complete edit script,    describing changes in consecutive lines.  */
end_comment

begin_function
specifier|static
name|void
name|print_ifdef_hunk
parameter_list|(
name|hunk
parameter_list|)
name|struct
name|change
modifier|*
name|hunk
decl_stmt|;
block|{
name|int
name|first0
decl_stmt|,
name|last0
decl_stmt|,
name|first1
decl_stmt|,
name|last1
decl_stmt|,
name|deletes
decl_stmt|,
name|inserts
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
comment|/* Determine range of line numbers involved in each file.  */
name|analyze_hunk
argument_list|(
name|hunk
argument_list|,
operator|&
name|first0
argument_list|,
operator|&
name|last0
argument_list|,
operator|&
name|first1
argument_list|,
operator|&
name|last1
argument_list|,
operator|&
name|deletes
argument_list|,
operator|&
name|inserts
argument_list|)
expr_stmt|;
if|if
condition|(
name|inserts
condition|)
name|format
operator|=
name|deletes
condition|?
name|group_format
index|[
name|CHANGED
index|]
else|:
name|group_format
index|[
name|NEW
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|deletes
condition|)
name|format
operator|=
name|group_format
index|[
name|OLD
index|]
expr_stmt|;
else|else
return|return;
name|begin_output
argument_list|()
expr_stmt|;
comment|/* Print lines up to this change.  */
if|if
condition|(
name|next_line
operator|<
name|first0
condition|)
name|format_ifdef
argument_list|(
name|group_format
index|[
name|UNCHANGED
index|]
argument_list|,
name|next_line
argument_list|,
name|first0
argument_list|,
name|next_line
operator|-
name|first0
operator|+
name|first1
argument_list|,
name|first1
argument_list|)
expr_stmt|;
comment|/* Print this change.  */
name|next_line
operator|=
name|last0
operator|+
literal|1
expr_stmt|;
name|format_ifdef
argument_list|(
name|format
argument_list|,
name|first0
argument_list|,
name|next_line
argument_list|,
name|first1
argument_list|,
name|last1
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a set of lines according to FORMAT.    Lines BEG0 up to END0 are from the first file;    lines BEG1 up to END1 are from the second file.  */
end_comment

begin_function
specifier|static
name|void
name|format_ifdef
parameter_list|(
name|format
parameter_list|,
name|beg0
parameter_list|,
name|end0
parameter_list|,
name|beg1
parameter_list|,
name|end1
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
name|int
name|beg0
decl_stmt|,
name|end0
decl_stmt|,
name|beg1
decl_stmt|,
name|end1
decl_stmt|;
block|{
name|struct
name|group
name|groups
index|[
literal|2
index|]
decl_stmt|;
name|groups
index|[
literal|0
index|]
operator|.
name|file
operator|=
operator|&
name|files
index|[
literal|0
index|]
expr_stmt|;
name|groups
index|[
literal|0
index|]
operator|.
name|from
operator|=
name|beg0
expr_stmt|;
name|groups
index|[
literal|0
index|]
operator|.
name|upto
operator|=
name|end0
expr_stmt|;
name|groups
index|[
literal|1
index|]
operator|.
name|file
operator|=
operator|&
name|files
index|[
literal|1
index|]
expr_stmt|;
name|groups
index|[
literal|1
index|]
operator|.
name|from
operator|=
name|beg1
expr_stmt|;
name|groups
index|[
literal|1
index|]
operator|.
name|upto
operator|=
name|end1
expr_stmt|;
name|format_group
argument_list|(
name|outfile
argument_list|,
name|format
argument_list|,
literal|'\0'
argument_list|,
name|groups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print to file OUT a set of lines according to FORMAT.    The format ends at the first free instance of ENDCHAR.    Yield the address of the terminating character.    GROUPS specifies which lines to print.    If OUT is zero, do not actually print anything; just scan the format.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|format_group
parameter_list|(
name|out
parameter_list|,
name|format
parameter_list|,
name|endchar
parameter_list|,
name|groups
parameter_list|)
specifier|register
name|FILE
modifier|*
name|out
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|int
name|endchar
decl_stmt|;
name|struct
name|group
specifier|const
name|groups
index|[]
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|f
init|=
name|format
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|f
operator|)
operator|!=
name|endchar
operator|&&
name|c
operator|!=
literal|0
condition|)
block|{
name|f
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
name|char
modifier|*
name|spec
init|=
name|f
decl_stmt|;
switch|switch
condition|(
operator|(
name|c
operator|=
operator|*
name|f
operator|++
operator|)
condition|)
block|{
case|case
literal|'%'
case|:
break|break;
case|case
literal|'('
case|:
comment|/* Print if-then-else format e.g. `%(n=1?thenpart:elsepart)'.  */
block|{
name|int
name|i
decl_stmt|,
name|value
index|[
literal|2
index|]
decl_stmt|;
name|FILE
modifier|*
name|thenout
decl_stmt|,
modifier|*
name|elseout
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|f0
init|=
name|f
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|f0
argument_list|)
condition|)
block|{
name|value
index|[
name|i
index|]
operator|=
name|atoi
argument_list|(
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|++
name|f
argument_list|)
condition|)
continue|continue;
block|}
else|else
block|{
name|value
index|[
name|i
index|]
operator|=
name|groups_letter_value
argument_list|(
name|groups
argument_list|,
name|f0
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
index|[
name|i
index|]
operator|<
literal|0
condition|)
goto|goto
name|bad_format
goto|;
name|f
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|f
operator|++
operator|!=
literal|"=?"
index|[
name|i
index|]
condition|)
goto|goto
name|bad_format
goto|;
block|}
if|if
condition|(
name|value
index|[
literal|0
index|]
operator|==
name|value
index|[
literal|1
index|]
condition|)
name|thenout
operator|=
name|out
operator|,
name|elseout
operator|=
literal|0
expr_stmt|;
else|else
name|thenout
operator|=
literal|0
operator|,
name|elseout
operator|=
name|out
expr_stmt|;
name|f
operator|=
name|format_group
argument_list|(
name|thenout
argument_list|,
name|f
argument_list|,
literal|':'
argument_list|,
name|groups
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|f
condition|)
block|{
name|f
operator|=
name|format_group
argument_list|(
name|elseout
argument_list|,
name|f
operator|+
literal|1
argument_list|,
literal|')'
argument_list|,
name|groups
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|f
condition|)
name|f
operator|++
expr_stmt|;
block|}
block|}
continue|continue;
case|case
literal|'<'
case|:
comment|/* Print lines deleted from first file.  */
name|print_ifdef_lines
argument_list|(
name|out
argument_list|,
name|line_format
index|[
name|OLD
index|]
argument_list|,
operator|&
name|groups
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'='
case|:
comment|/* Print common lines.  */
name|print_ifdef_lines
argument_list|(
name|out
argument_list|,
name|line_format
index|[
name|UNCHANGED
index|]
argument_list|,
operator|&
name|groups
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'>'
case|:
comment|/* Print lines inserted from second file.  */
name|print_ifdef_lines
argument_list|(
name|out
argument_list|,
name|line_format
index|[
name|NEW
index|]
argument_list|,
operator|&
name|groups
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
continue|continue;
default|default:
block|{
name|int
name|value
decl_stmt|;
name|char
modifier|*
name|speclim
decl_stmt|;
name|f
operator|=
name|scan_printf_spec
argument_list|(
name|spec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
goto|goto
name|bad_format
goto|;
name|speclim
operator|=
name|f
expr_stmt|;
name|c
operator|=
operator|*
name|f
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\''
case|:
name|f
operator|=
name|scan_char_literal
argument_list|(
name|f
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
goto|goto
name|bad_format
goto|;
break|break;
default|default:
name|value
operator|=
name|groups_letter_value
argument_list|(
name|groups
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
goto|goto
name|bad_format
goto|;
break|break;
block|}
if|if
condition|(
name|out
condition|)
block|{
comment|/* Temporarily replace e.g. "%3dnx" with "%3d\0x".  */
operator|*
name|speclim
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
name|spec
operator|-
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Undo the temporary replacement.  */
operator|*
name|speclim
operator|=
name|c
expr_stmt|;
block|}
block|}
continue|continue;
name|bad_format
label|:
name|c
operator|=
literal|'%'
expr_stmt|;
name|f
operator|=
name|spec
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|out
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/* For the line group pair G, return the number corresponding to LETTER.    Return -1 if LETTER is not a group format letter.  */
end_comment

begin_function
specifier|static
name|int
name|groups_letter_value
parameter_list|(
name|g
parameter_list|,
name|letter
parameter_list|)
name|struct
name|group
specifier|const
name|g
index|[]
decl_stmt|;
name|int
name|letter
decl_stmt|;
block|{
if|if
condition|(
name|isupper
argument_list|(
name|letter
argument_list|)
condition|)
block|{
name|g
operator|++
expr_stmt|;
name|letter
operator|=
name|tolower
argument_list|(
name|letter
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|letter
condition|)
block|{
case|case
literal|'e'
case|:
return|return
name|translate_line_number
argument_list|(
name|g
operator|->
name|file
argument_list|,
name|g
operator|->
name|from
argument_list|)
operator|-
literal|1
return|;
case|case
literal|'f'
case|:
return|return
name|translate_line_number
argument_list|(
name|g
operator|->
name|file
argument_list|,
name|g
operator|->
name|from
argument_list|)
return|;
case|case
literal|'l'
case|:
return|return
name|translate_line_number
argument_list|(
name|g
operator|->
name|file
argument_list|,
name|g
operator|->
name|upto
argument_list|)
operator|-
literal|1
return|;
case|case
literal|'m'
case|:
return|return
name|translate_line_number
argument_list|(
name|g
operator|->
name|file
argument_list|,
name|g
operator|->
name|upto
argument_list|)
return|;
case|case
literal|'n'
case|:
return|return
name|g
operator|->
name|upto
operator|-
name|g
operator|->
name|from
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Print to file OUT, using FORMAT to print the line group GROUP.    But do nothing if OUT is zero.  */
end_comment

begin_function
specifier|static
name|void
name|print_ifdef_lines
parameter_list|(
name|out
parameter_list|,
name|format
parameter_list|,
name|group
parameter_list|)
specifier|register
name|FILE
modifier|*
name|out
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|struct
name|group
specifier|const
modifier|*
name|group
decl_stmt|;
block|{
name|struct
name|file_data
specifier|const
modifier|*
name|file
init|=
name|group
operator|->
name|file
decl_stmt|;
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|linbuf
init|=
name|file
operator|->
name|linbuf
decl_stmt|;
name|int
name|from
init|=
name|group
operator|->
name|from
decl_stmt|,
name|upto
init|=
name|group
operator|->
name|upto
decl_stmt|;
if|if
condition|(
operator|!
name|out
condition|)
return|return;
comment|/* If possible, use a single fwrite; it's faster.  */
if|if
condition|(
operator|!
name|tab_expand_flag
operator|&&
name|format
index|[
literal|0
index|]
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
name|format
index|[
literal|1
index|]
operator|==
literal|'l'
operator|&&
name|format
index|[
literal|2
index|]
operator|==
literal|'\n'
operator|&&
operator|!
name|format
index|[
literal|3
index|]
condition|)
block|{
name|fwrite
argument_list|(
name|linbuf
index|[
name|from
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|linbuf
index|[
name|upto
index|]
operator|+
operator|(
name|linbuf
index|[
name|upto
index|]
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
operator|)
operator|-
name|linbuf
index|[
name|from
index|]
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|format
index|[
literal|1
index|]
operator|==
literal|'L'
operator|&&
operator|!
name|format
index|[
literal|2
index|]
condition|)
block|{
name|fwrite
argument_list|(
name|linbuf
index|[
name|from
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|linbuf
index|[
name|upto
index|]
operator|-
name|linbuf
index|[
name|from
index|]
argument_list|,
name|out
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
for|for
control|(
init|;
name|from
operator|<
name|upto
condition|;
name|from
operator|++
control|)
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|f
init|=
name|format
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|f
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
block|{
name|char
modifier|*
name|spec
init|=
name|f
decl_stmt|;
switch|switch
condition|(
operator|(
name|c
operator|=
operator|*
name|f
operator|++
operator|)
condition|)
block|{
case|case
literal|'%'
case|:
break|break;
case|case
literal|'l'
case|:
name|output_1_line
argument_list|(
name|linbuf
index|[
name|from
index|]
argument_list|,
name|linbuf
index|[
name|from
operator|+
literal|1
index|]
operator|-
operator|(
name|linbuf
index|[
name|from
operator|+
literal|1
index|]
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'L'
case|:
name|output_1_line
argument_list|(
name|linbuf
index|[
name|from
index|]
argument_list|,
name|linbuf
index|[
name|from
operator|+
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
default|default:
block|{
name|int
name|value
decl_stmt|;
name|char
modifier|*
name|speclim
decl_stmt|;
name|f
operator|=
name|scan_printf_spec
argument_list|(
name|spec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
goto|goto
name|bad_format
goto|;
name|speclim
operator|=
name|f
expr_stmt|;
name|c
operator|=
operator|*
name|f
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\''
case|:
name|f
operator|=
name|scan_char_literal
argument_list|(
name|f
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
goto|goto
name|bad_format
goto|;
break|break;
case|case
literal|'n'
case|:
name|value
operator|=
name|translate_line_number
argument_list|(
name|file
argument_list|,
name|from
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad_format
goto|;
block|}
comment|/* Temporarily replace e.g. "%3dnx" with "%3d\0x".  */
operator|*
name|speclim
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
name|spec
operator|-
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Undo the temporary replacement.  */
operator|*
name|speclim
operator|=
name|c
expr_stmt|;
block|}
continue|continue;
name|bad_format
label|:
name|c
operator|=
literal|'%'
expr_stmt|;
name|f
operator|=
name|spec
expr_stmt|;
break|break;
block|}
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Scan the character literal represented in the string LIT; LIT points just    after the initial apostrophe.  Put the literal's value into *INTPTR.    Yield the address of the first character after the closing apostrophe,    or zero if the literal is ill-formed.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|scan_char_literal
parameter_list|(
name|lit
parameter_list|,
name|intptr
parameter_list|)
name|char
modifier|*
name|lit
decl_stmt|;
name|int
modifier|*
name|intptr
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|lit
decl_stmt|;
name|int
name|value
decl_stmt|,
name|digits
decl_stmt|;
name|char
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|'\''
case|:
return|return
literal|0
return|;
case|case
literal|'\\'
case|:
name|value
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\''
condition|)
block|{
name|unsigned
name|digit
init|=
name|c
operator|-
literal|'0'
decl_stmt|;
if|if
condition|(
literal|8
operator|<=
name|digit
condition|)
return|return
literal|0
return|;
name|value
operator|=
literal|8
operator|*
name|value
operator|+
name|digit
expr_stmt|;
block|}
name|digits
operator|=
name|p
operator|-
name|lit
operator|-
literal|2
expr_stmt|;
if|if
condition|(
operator|!
operator|(
literal|1
operator|<=
name|digits
operator|&&
name|digits
operator|<=
literal|3
operator|)
condition|)
return|return
literal|0
return|;
break|break;
default|default:
name|value
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\''
condition|)
return|return
literal|0
return|;
break|break;
block|}
operator|*
name|intptr
operator|=
name|value
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Scan optional printf-style SPEC of the form `-*[0-9]*(.[0-9]*)?[cdoxX]'.    Return the address of the character following SPEC, or zero if failure.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|scan_printf_spec
parameter_list|(
name|spec
parameter_list|)
specifier|register
name|char
modifier|*
name|spec
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|spec
operator|++
operator|)
operator|==
literal|'-'
condition|)
continue|continue;
while|while
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
operator|*
name|spec
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
while|while
condition|(
name|isdigit
argument_list|(
name|c
operator|=
operator|*
name|spec
operator|++
argument_list|)
condition|)
continue|continue;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'o'
case|:
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
return|return
name|spec
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

end_unit

