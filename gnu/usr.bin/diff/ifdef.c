begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* #ifdef-format output routines for GNU DIFF.    Copyright (C) 1989, 91, 92 Free Software Foundation, Inc.  This file is part of GNU DIFF.  GNU DIFF is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU DIFF General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU DIFF, but only under the conditions described in the GNU DIFF General Public License.   A copy of this license is supposed to have been given to you along with GNU DIFF so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_include
include|#
directive|include
file|"diff.h"
end_include

begin_function_decl
specifier|static
name|void
name|format_ifdef
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_ifdef_hunk
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_ifdef_lines
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|change
modifier|*
name|find_change
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|next_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print the edit-script SCRIPT as a merged #ifdef file.  */
end_comment

begin_function
name|void
name|print_ifdef_script
parameter_list|(
name|script
parameter_list|)
name|struct
name|change
modifier|*
name|script
decl_stmt|;
block|{
name|next_line
operator|=
operator|-
name|files
index|[
literal|0
index|]
operator|.
name|prefix_lines
expr_stmt|;
name|print_script
argument_list|(
name|script
argument_list|,
name|find_change
argument_list|,
name|print_ifdef_hunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_line
operator|<
name|files
index|[
literal|0
index|]
operator|.
name|valid_lines
condition|)
block|{
name|begin_output
argument_list|()
expr_stmt|;
name|format_ifdef
argument_list|(
name|group_format
index|[
name|UNCHANGED
index|]
argument_list|,
name|next_line
argument_list|,
name|files
index|[
literal|0
index|]
operator|.
name|valid_lines
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a hunk of an ifdef diff.    This is a contiguous portion of a complete edit script,    describing changes in consecutive lines.  */
end_comment

begin_function
specifier|static
name|void
name|print_ifdef_hunk
parameter_list|(
name|hunk
parameter_list|)
name|struct
name|change
modifier|*
name|hunk
decl_stmt|;
block|{
name|int
name|first0
decl_stmt|,
name|last0
decl_stmt|,
name|first1
decl_stmt|,
name|last1
decl_stmt|,
name|deletes
decl_stmt|,
name|inserts
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
comment|/* Determine range of line numbers involved in each file.  */
name|analyze_hunk
argument_list|(
name|hunk
argument_list|,
operator|&
name|first0
argument_list|,
operator|&
name|last0
argument_list|,
operator|&
name|first1
argument_list|,
operator|&
name|last1
argument_list|,
operator|&
name|deletes
argument_list|,
operator|&
name|inserts
argument_list|)
expr_stmt|;
if|if
condition|(
name|inserts
condition|)
name|format
operator|=
name|deletes
condition|?
name|group_format
index|[
name|CHANGED
index|]
else|:
name|group_format
index|[
name|NEW
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|deletes
condition|)
name|format
operator|=
name|group_format
index|[
name|OLD
index|]
expr_stmt|;
else|else
return|return;
name|begin_output
argument_list|()
expr_stmt|;
comment|/* Print lines up to this change.  */
if|if
condition|(
name|next_line
operator|<
name|first0
condition|)
name|format_ifdef
argument_list|(
name|group_format
index|[
name|UNCHANGED
index|]
argument_list|,
name|next_line
argument_list|,
name|first0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Print this change.  */
name|next_line
operator|=
name|last0
operator|+
literal|1
expr_stmt|;
name|format_ifdef
argument_list|(
name|format
argument_list|,
name|first0
argument_list|,
name|next_line
argument_list|,
name|first1
argument_list|,
name|last1
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a set of lines according to FORMAT.    Lines BEG0 up to END0 are from the first file.    If END1 is -1, then the second file's lines are identical to the first;    otherwise, lines BEG1 up to END1 are from the second file.  */
end_comment

begin_function
specifier|static
name|void
name|format_ifdef
parameter_list|(
name|format
parameter_list|,
name|beg0
parameter_list|,
name|end0
parameter_list|,
name|beg1
parameter_list|,
name|end1
parameter_list|)
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
name|int
name|beg0
decl_stmt|,
name|end0
decl_stmt|,
name|beg1
decl_stmt|,
name|end1
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|out
init|=
name|outfile
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|f
init|=
name|format
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|f
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
switch|switch
condition|(
operator|(
name|c
operator|=
operator|*
name|f
operator|++
operator|)
condition|)
block|{
case|case
literal|0
case|:
return|return;
case|case
literal|'<'
case|:
comment|/* Print lines deleted from first file.  */
name|print_ifdef_lines
argument_list|(
name|line_format
index|[
name|OLD
index|]
argument_list|,
operator|&
name|files
index|[
literal|0
index|]
argument_list|,
name|beg0
argument_list|,
name|end0
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'='
case|:
comment|/* Print common lines.  */
name|print_ifdef_lines
argument_list|(
name|line_format
index|[
name|UNCHANGED
index|]
argument_list|,
operator|&
name|files
index|[
literal|0
index|]
argument_list|,
name|beg0
argument_list|,
name|end0
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'>'
case|:
comment|/* Print lines inserted from second file.  */
if|if
condition|(
name|end1
operator|==
operator|-
literal|1
condition|)
name|print_ifdef_lines
argument_list|(
name|line_format
index|[
name|NEW
index|]
argument_list|,
operator|&
name|files
index|[
literal|0
index|]
argument_list|,
name|beg0
argument_list|,
name|end0
argument_list|)
expr_stmt|;
else|else
name|print_ifdef_lines
argument_list|(
name|line_format
index|[
name|NEW
index|]
argument_list|,
operator|&
name|files
index|[
literal|1
index|]
argument_list|,
name|beg1
argument_list|,
name|end1
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'0'
case|:
name|c
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Use FORMAT to print each line of CURRENT starting with FROM    and continuing up to UPTO.  */
end_comment

begin_function
specifier|static
name|void
name|print_ifdef_lines
parameter_list|(
name|format
parameter_list|,
name|current
parameter_list|,
name|from
parameter_list|,
name|upto
parameter_list|)
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
specifier|const
name|struct
name|file_data
modifier|*
name|current
decl_stmt|;
name|int
name|from
decl_stmt|,
name|upto
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|linbuf
init|=
name|current
operator|->
name|linbuf
decl_stmt|;
comment|/* If possible, use a single fwrite; it's faster.  */
if|if
condition|(
operator|!
name|tab_expand_flag
operator|&&
name|strcmp
argument_list|(
name|format
argument_list|,
literal|"%l\n"
argument_list|)
operator|==
literal|0
condition|)
name|fwrite
argument_list|(
name|linbuf
index|[
name|from
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|linbuf
index|[
name|upto
index|]
operator|+
operator|(
name|linbuf
index|[
name|upto
index|]
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
operator|)
operator|-
name|linbuf
index|[
name|from
index|]
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|tab_expand_flag
operator|&&
name|strcmp
argument_list|(
name|format
argument_list|,
literal|"%L"
argument_list|)
operator|==
literal|0
condition|)
name|fwrite
argument_list|(
name|linbuf
index|[
name|from
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|linbuf
index|[
name|upto
index|]
operator|-
name|linbuf
index|[
name|from
index|]
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
name|from
operator|<
name|upto
condition|;
name|from
operator|++
control|)
block|{
specifier|register
name|FILE
modifier|*
name|out
init|=
name|outfile
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|f
init|=
name|format
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|f
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'%'
condition|)
switch|switch
condition|(
operator|(
name|c
operator|=
operator|*
name|f
operator|++
operator|)
condition|)
block|{
case|case
literal|0
case|:
goto|goto
name|format_done
goto|;
case|case
literal|'l'
case|:
name|output_1_line
argument_list|(
name|linbuf
index|[
name|from
index|]
argument_list|,
name|linbuf
index|[
name|from
operator|+
literal|1
index|]
operator|-
operator|(
name|linbuf
index|[
name|from
operator|+
literal|1
index|]
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'L'
case|:
name|output_1_line
argument_list|(
name|linbuf
index|[
name|from
index|]
argument_list|,
name|linbuf
index|[
name|from
operator|+
literal|1
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'0'
case|:
name|c
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|format_done
label|:
empty_stmt|;
block|}
block|}
end_function

end_unit

