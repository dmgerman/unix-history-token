begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * man.c  *  * Copyright (c) 1990, 1991, John W. Eaton.  *  * You may distribute under the terms of the GNU General Public  * License as specified in the file COPYING that comes with the man  * distribution.  *  * John W. Eaton  * jwe@che.utexas.edu  * Department of Chemical Engineering  * The University of Texas at Austin  * Austin, Texas  78712  */
end_comment

begin_define
define|#
directive|define
name|MAN_MAIN
end_define

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"gripes.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|POSIX
end_ifndef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|R_OK
end_ifndef

begin_define
define|#
directive|define
name|R_OK
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SECURE_MAN_UID
end_ifdef

begin_function_decl
specifier|extern
name|uid_t
name|getuid
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|setuid
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|STDC_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|system
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|strcmp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|strncmp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|exit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|fflush
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|printf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|fprintf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|fopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|fclose
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|sprintf
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|char
modifier|*
name|strdup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
modifier|*
name|glob_vector
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
modifier|*
name|glob_filename
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|access
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|unlink
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|system
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|chmod
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|is_newer
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|is_directory
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|do_system_command
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|prognam
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pager
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|manp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|manpathlist
index|[
name|MAXDIRS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|section
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|colon_sep_section_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|section_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|roff_directive
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|apropos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|whatis
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|findall
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|print_where
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ALT_SYSTEMS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|alt_system
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|alt_system_name
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|troff
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_TROFF
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|ALT_SYSTEMS
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|args
index|[]
init|=
literal|"M:P:S:adfhkm:p:tw?"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
name|args
index|[]
init|=
literal|"M:P:S:adfhkp:tw?"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|ALT_SYSTEMS
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|args
index|[]
init|=
literal|"M:P:S:adfhkm:p:w?"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
name|args
index|[]
init|=
literal|"M:P:S:adfhkp:w?"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SETREUID
end_ifdef

begin_decl_stmt
name|uid_t
name|ruid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uid_t
name|euid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uid_t
name|rgid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uid_t
name|egid
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|nextarg
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
specifier|extern
name|char
modifier|*
name|mkprogname
parameter_list|()
function_decl|;
name|char
modifier|*
name|is_section
parameter_list|()
function_decl|;
name|char
modifier|*
modifier|*
name|get_section_list
parameter_list|()
function_decl|;
name|void
name|man_getopt
parameter_list|()
function_decl|;
name|void
name|do_apropos
parameter_list|()
function_decl|;
name|void
name|do_whatis
parameter_list|()
function_decl|;
name|int
name|man
parameter_list|()
function_decl|;
name|prognam
operator|=
name|mkprogname
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|man_getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
name|gripe_no_name
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|section_list
operator|=
name|get_section_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|optind
operator|==
name|argc
operator|-
literal|1
condition|)
block|{
name|tmp
operator|=
name|is_section
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
name|gripe_no_name
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SETREUID
name|ruid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|rgid
operator|=
name|getgid
argument_list|()
expr_stmt|;
name|euid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
name|egid
operator|=
name|getegid
argument_list|()
expr_stmt|;
name|setreuid
argument_list|(
operator|-
literal|1
argument_list|,
name|ruid
argument_list|)
expr_stmt|;
name|setregid
argument_list|(
operator|-
literal|1
argument_list|,
name|rgid
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|nextarg
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
comment|/*        * See if this argument is a valid section name.  If not,        * is_section returns NULL.        */
name|tmp
operator|=
name|is_section
argument_list|(
name|nextarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
name|section
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nsection: %s\n"
argument_list|,
name|section
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|apropos
condition|)
name|do_apropos
argument_list|(
name|nextarg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|whatis
condition|)
name|do_whatis
argument_list|(
name|nextarg
argument_list|)
expr_stmt|;
else|else
block|{
name|status
operator|=
name|man
argument_list|(
name|nextarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|gripe_not_found
argument_list|(
name|nextarg
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|status
operator|==
literal|0
operator|)
return|;
comment|/* status==1 --> exit(0),                                  status==0 --> exit(1) */
block|}
end_function

begin_function
name|void
name|usage
parameter_list|()
block|{
specifier|static
name|char
name|usage_string
index|[
literal|1024
index|]
init|=
literal|"%s, version %s\n\n"
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_TROFF
ifdef|#
directive|ifdef
name|ALT_SYSTEMS
specifier|static
name|char
name|s1
index|[]
init|=
literal|"usage: %s [-adfhktw] [section] [-M path] [-P pager] [-S list]\n\            [-m system] [-p string] name ...\n\n"
decl_stmt|;
else|#
directive|else
specifier|static
name|char
name|s1
index|[]
init|=
literal|"usage: %s [-adfhktw] [section] [-M path] [-P pager] [-S list]\n\            [-p string] name ...\n\n"
decl_stmt|;
endif|#
directive|endif
else|#
directive|else
ifdef|#
directive|ifdef
name|ALT_SYSTEMS
specifier|static
name|char
name|s1
index|[]
init|=
literal|"usage: %s [-adfhkw] [section] [-M path] [-P pager] [-S list]\n\            [-m system] [-p string] name ...\n\n"
decl_stmt|;
else|#
directive|else
specifier|static
name|char
name|s1
index|[]
init|=
literal|"usage: %s [-adfhkw] [section] [-M path] [-P pager] [-S list]\n\            [-p string] name ...\n\n"
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
specifier|static
name|char
name|s2
index|[]
init|=
literal|"  a : find all matching entries\n\   d : print gobs of debugging information\n\   f : same as whatis(1)\n\   h : print this help message\n\   k : same as apropos(1)\n"
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_TROFF
specifier|static
name|char
name|s3
index|[]
init|=
literal|"  t : use troff to format pages for printing\n"
decl_stmt|;
endif|#
directive|endif
specifier|static
name|char
name|s4
index|[]
init|=
literal|"  w : print location of man page(s) that would be displayed\n\n\   M path   : set search path for manual pages to `path'\n\   P pager  : use program `pager' to display pages\n\   S list   : colon separated section list\n"
decl_stmt|;
ifdef|#
directive|ifdef
name|ALT_SYSTEMS
specifier|static
name|char
name|s5
index|[]
init|=
literal|"  m system : search for alternate system's man pages\n"
decl_stmt|;
endif|#
directive|endif
specifier|static
name|char
name|s6
index|[]
init|=
literal|"  p string : string tells which preprocessors to run\n\                e - [n]eqn(1)   p - pic(1)    t - tbl(1)\n\                g - grap(1)     r - refer(1)  v - vgrind(1)\n"
decl_stmt|;
name|strcat
argument_list|(
name|usage_string
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|usage_string
argument_list|,
name|s2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_TROFF
name|strcat
argument_list|(
name|usage_string
argument_list|,
name|s3
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcat
argument_list|(
name|usage_string
argument_list|,
name|s4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALT_SYSTEMS
name|strcat
argument_list|(
name|usage_string
argument_list|,
name|s5
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcat
argument_list|(
name|usage_string
argument_list|,
name|s6
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|usage_string
argument_list|,
name|prognam
argument_list|,
name|version
argument_list|,
name|prognam
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
modifier|*
name|add_dir_to_mpath_list
parameter_list|(
name|mp
parameter_list|,
name|p
parameter_list|)
name|char
modifier|*
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|is_directory
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
operator|&&
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: couldn't stat file %s!\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
literal|0
operator|&&
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: %s isn't a directory!\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"adding %s to manpathlist\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|++
operator|=
name|strdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
name|mp
return|;
block|}
end_function

begin_comment
comment|/*  * Get options from the command line and user environment.  */
end_comment

begin_function
name|void
name|man_getopt
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
specifier|register
name|int
name|argc
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|mp
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|int
name|getopt
parameter_list|()
function_decl|;
specifier|extern
name|void
name|downcase
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|manpath
parameter_list|()
function_decl|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|args
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'M'
case|:
name|manp
operator|=
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|pager
operator|=
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|colon_sep_section_list
operator|=
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|findall
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|debug
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|troff
condition|)
name|gripe_incompatible
argument_list|(
literal|"-f and -t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|apropos
condition|)
name|gripe_incompatible
argument_list|(
literal|"-f and -k"
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_where
condition|)
name|gripe_incompatible
argument_list|(
literal|"-f and -w"
argument_list|)
expr_stmt|;
name|whatis
operator|++
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|troff
condition|)
name|gripe_incompatible
argument_list|(
literal|"-k and -t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|whatis
condition|)
name|gripe_incompatible
argument_list|(
literal|"-k and -f"
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_where
condition|)
name|gripe_incompatible
argument_list|(
literal|"-k and -w"
argument_list|)
expr_stmt|;
name|apropos
operator|++
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|ALT_SYSTEMS
case|case
literal|'m'
case|:
name|alt_system
operator|++
expr_stmt|;
name|alt_system_name
operator|=
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'p'
case|:
name|roff_directive
operator|=
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAS_TROFF
case|case
literal|'t'
case|:
if|if
condition|(
name|apropos
condition|)
name|gripe_incompatible
argument_list|(
literal|"-t and -k"
argument_list|)
expr_stmt|;
if|if
condition|(
name|whatis
condition|)
name|gripe_incompatible
argument_list|(
literal|"-t and -f"
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_where
condition|)
name|gripe_incompatible
argument_list|(
literal|"-t and -w"
argument_list|)
expr_stmt|;
name|troff
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'w'
case|:
if|if
condition|(
name|apropos
condition|)
name|gripe_incompatible
argument_list|(
literal|"-w and -k"
argument_list|)
expr_stmt|;
if|if
condition|(
name|whatis
condition|)
name|gripe_incompatible
argument_list|(
literal|"-w and -f"
argument_list|)
expr_stmt|;
if|if
condition|(
name|troff
condition|)
name|gripe_incompatible
argument_list|(
literal|"-w and -t"
argument_list|)
expr_stmt|;
name|print_where
operator|++
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pager
operator|==
name|NULL
operator|||
operator|*
name|pager
operator|==
literal|'\0'
condition|)
if|if
condition|(
operator|(
name|pager
operator|=
name|getenv
argument_list|(
literal|"PAGER"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|pager
operator|=
name|strdup
argument_list|(
name|PAGER
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nusing %s as pager\n"
argument_list|,
name|pager
argument_list|)
expr_stmt|;
if|if
condition|(
name|manp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|manp
operator|=
name|manpath
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|gripe_manpath
argument_list|()
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nsearch path for pages determined by manpath is\n%s\n\n"
argument_list|,
name|manp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ALT_SYSTEMS
if|if
condition|(
name|alt_system_name
operator|==
name|NULL
operator|||
operator|*
name|alt_system_name
operator|==
literal|'\0'
condition|)
if|if
condition|(
operator|(
name|alt_system_name
operator|=
name|getenv
argument_list|(
literal|"SYSTEM"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|alt_system_name
operator|=
name|strdup
argument_list|(
name|alt_system_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt_system_name
operator|!=
name|NULL
operator|&&
operator|*
name|alt_system_name
operator|!=
literal|'\0'
condition|)
name|downcase
argument_list|(
name|alt_system_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*    * Expand the manpath into a list for easier handling.    */
name|mp
operator|=
name|manpathlist
expr_stmt|;
for|for
control|(
name|p
operator|=
name|manp
init|;
condition|;
name|p
operator|=
name|end
operator|+
literal|1
control|)
block|{
if|if
condition|(
operator|(
name|end
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|ALT_SYSTEMS
if|if
condition|(
name|alt_system
condition|)
block|{
name|char
name|buf
index|[
name|FILENAME_MAX
index|]
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Alternate system `%s' specified\n"
argument_list|,
name|alt_system_name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|alt_system_name
argument_list|)
expr_stmt|;
name|mp
operator|=
name|add_dir_to_mpath_list
argument_list|(
name|mp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|=
name|add_dir_to_mpath_list
argument_list|(
name|mp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|mp
operator|=
name|add_dir_to_mpath_list
argument_list|(
name|mp
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|end
operator|==
name|NULL
condition|)
break|break;
operator|*
name|end
operator|=
literal|':'
expr_stmt|;
block|}
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see if the argument is a valid section number.  If the  * first character of name is a numeral, or the name matches one of  * the sections listed in section_list, we'll assume that it's a section.  * The list of sections in config.h simply allows us to specify oddly  * named directories like .../man3f.  Yuk.  */
end_comment

begin_function
name|char
modifier|*
name|is_section
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|vs
decl_stmt|;
for|for
control|(
name|vs
operator|=
name|section_list
init|;
operator|*
name|vs
operator|!=
name|NULL
condition|;
name|vs
operator|++
control|)
if|if
condition|(
operator|(
name|strcmp
argument_list|(
operator|*
name|vs
argument_list|,
name|name
argument_list|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|isdigit
argument_list|(
name|name
index|[
literal|0
index|]
argument_list|)
operator|&&
name|strlen
argument_list|(
name|name
argument_list|)
operator|==
literal|1
operator|)
condition|)
return|return
name|strdup
argument_list|(
name|name
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Handle the apropos option.  Cheat by using another program.  */
end_comment

begin_function
name|void
name|do_apropos
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|command
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|APROPOS
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|gripe_alloc
argument_list|(
name|len
argument_list|,
literal|"command"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"%s %s"
argument_list|,
name|APROPOS
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|do_system_command
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle the whatis option.  Cheat by using another program.  */
end_comment

begin_function
name|void
name|do_whatis
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|command
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|WHATIS
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|command
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|gripe_alloc
argument_list|(
name|len
argument_list|,
literal|"command"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"%s %s"
argument_list|,
name|WHATIS
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|do_system_command
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change a name of the form ...man/man1/name.1 to ...man/cat1/name.1  * or a name of the form ...man/cat1/name.1 to ...man/man1/name.1  */
end_comment

begin_function
name|char
modifier|*
name|convert_name
parameter_list|(
name|name
parameter_list|,
name|to_cat
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|to_cat
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|to_name
decl_stmt|;
specifier|register
name|char
modifier|*
name|t1
decl_stmt|;
specifier|register
name|char
modifier|*
name|t2
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|DO_COMPRESS
if|if
condition|(
name|to_cat
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|3
decl_stmt|;
name|int
name|cextlen
init|=
name|strlen
argument_list|(
name|COMPRESS_EXT
argument_list|)
decl_stmt|;
name|to_name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_name
operator|==
name|NULL
condition|)
name|gripe_alloc
argument_list|(
name|len
argument_list|,
literal|"to_name"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|to_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Avoid tacking it on twice */
if|if
condition|(
name|strcmp
argument_list|(
name|name
operator|+
operator|(
name|len
operator|-
operator|(
literal|3
operator|+
name|cextlen
operator|)
operator|)
argument_list|,
name|COMPRESS_EXT
argument_list|)
condition|)
name|strcat
argument_list|(
name|to_name
argument_list|,
name|COMPRESS_EXT
argument_list|)
expr_stmt|;
block|}
else|else
name|to_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|to_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|t1
operator|=
name|strrchr
argument_list|(
name|to_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|NULL
condition|)
block|{
operator|*
name|t1
operator|=
name|NULL
expr_stmt|;
name|t2
operator|=
name|strrchr
argument_list|(
name|to_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
operator|*
name|t1
operator|=
literal|'/'
expr_stmt|;
block|}
if|if
condition|(
name|t2
operator|==
name|NULL
condition|)
name|gripe_converting_name
argument_list|(
name|name
argument_list|,
name|to_cat
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_cat
condition|)
block|{
operator|*
operator|(
operator|++
name|t2
operator|)
operator|=
literal|'c'
expr_stmt|;
operator|*
operator|(
name|t2
operator|+
literal|2
operator|)
operator|=
literal|'t'
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
operator|++
name|t2
operator|)
operator|=
literal|'m'
expr_stmt|;
operator|*
operator|(
name|t2
operator|+
literal|2
operator|)
operator|=
literal|'n'
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"to_name in convert_name () is: %s\n"
argument_list|,
name|to_name
argument_list|)
expr_stmt|;
return|return
name|to_name
return|;
block|}
end_function

begin_comment
comment|/*  * Try to find the man page corresponding to the given name.  The  * reason we do this with globbing is because some systems have man  * page directories named man3 which contain files with names like  * XtPopup.3Xt.  Rather than requiring that this program know about  * all those possible names, we simply try to match things like  * .../man[sect]/name[sect]*.  This is *much* easier.  *  * Note that globbing is only done when the section is unspecified.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|glob_for_file
parameter_list|(
name|path
parameter_list|,
name|section
parameter_list|,
name|name
parameter_list|,
name|cat
parameter_list|)
specifier|register
name|char
modifier|*
name|path
decl_stmt|;
specifier|register
name|char
modifier|*
name|section
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|cat
decl_stmt|;
block|{
name|char
name|pathname
index|[
name|FILENAME_MAX
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|gf
decl_stmt|;
if|if
condition|(
name|cat
condition|)
name|sprintf
argument_list|(
name|pathname
argument_list|,
literal|"%s/cat%s/%s.%s*"
argument_list|,
name|path
argument_list|,
name|section
argument_list|,
name|name
argument_list|,
name|section
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|pathname
argument_list|,
literal|"%s/man%s/%s.%s*"
argument_list|,
name|path
argument_list|,
name|section
argument_list|,
name|name
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"globbing %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|gf
operator|=
name|glob_filename
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gf
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
operator|-
literal|1
operator|||
operator|*
name|gf
operator|==
name|NULL
operator|)
operator|&&
name|isdigit
argument_list|(
operator|*
name|section
argument_list|)
condition|)
block|{
if|if
condition|(
name|cat
condition|)
name|sprintf
argument_list|(
name|pathname
argument_list|,
literal|"%s/cat%s/%s.%c*"
argument_list|,
name|path
argument_list|,
name|section
argument_list|,
name|name
argument_list|,
operator|*
name|section
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|pathname
argument_list|,
literal|"%s/man%s/%s.%c*"
argument_list|,
name|path
argument_list|,
name|section
argument_list|,
name|name
argument_list|,
operator|*
name|section
argument_list|)
expr_stmt|;
name|gf
operator|=
name|glob_filename
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|gf
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
operator|-
literal|1
operator|||
operator|*
name|gf
operator|==
name|NULL
operator|)
operator|&&
name|isdigit
argument_list|(
operator|*
name|section
argument_list|)
condition|)
block|{
if|if
condition|(
name|cat
condition|)
name|sprintf
argument_list|(
name|pathname
argument_list|,
literal|"%s/cat%s/%s.0*"
argument_list|,
name|path
argument_list|,
name|section
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|pathname
argument_list|,
literal|"%s/man%s/%s.0*"
argument_list|,
name|path
argument_list|,
name|section
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"globbing %s\n"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|gf
operator|=
name|glob_filename
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
block|}
return|return
name|gf
return|;
block|}
end_function

begin_comment
comment|/*  * Return an un-globbed name in the same form as if we were doing  * globbing.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|make_name
parameter_list|(
name|path
parameter_list|,
name|section
parameter_list|,
name|name
parameter_list|,
name|cat
parameter_list|)
specifier|register
name|char
modifier|*
name|path
decl_stmt|;
specifier|register
name|char
modifier|*
name|section
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|cat
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
name|names
index|[
literal|3
index|]
decl_stmt|;
name|char
name|buf
index|[
name|FILENAME_MAX
index|]
decl_stmt|;
if|if
condition|(
name|cat
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/cat%s/%s.%s"
argument_list|,
name|path
argument_list|,
name|section
argument_list|,
name|name
argument_list|,
name|section
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/man%s/%s.%s"
argument_list|,
name|path
argument_list|,
name|section
argument_list|,
name|name
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|buf
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
name|names
index|[
name|i
operator|++
index|]
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/*    * If we're given a section that looks like `3f', we may want to try    * file names like .../man3/foo.3f as well.  This seems a bit    * kludgey to me, but what the hey...    */
if|if
condition|(
name|section
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|cat
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/cat%c/%s.%s"
argument_list|,
name|path
argument_list|,
name|section
index|[
literal|0
index|]
argument_list|,
name|name
argument_list|,
name|section
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s/man%c/%s.%s"
argument_list|,
name|path
argument_list|,
name|section
index|[
literal|0
index|]
argument_list|,
name|name
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|buf
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
name|names
index|[
name|i
operator|++
index|]
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|names
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|names
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|get_expander
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|char
modifier|*
name|end
init|=
name|file
operator|+
operator|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|-
literal|1
operator|)
decl_stmt|;
while|while
condition|(
name|end
operator|>
name|file
operator|&&
name|end
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
condition|)
operator|--
name|end
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|file
condition|)
return|return
name|NULL
return|;
ifdef|#
directive|ifdef
name|FCAT
if|if
condition|(
operator|*
name|end
operator|==
literal|'F'
condition|)
return|return
name|FCAT
return|;
endif|#
directive|endif
comment|/* FCAT */
ifdef|#
directive|ifdef
name|YCAT
if|if
condition|(
operator|*
name|end
operator|==
literal|'Y'
condition|)
return|return
name|YCAT
return|;
endif|#
directive|endif
comment|/* YCAT */
ifdef|#
directive|ifdef
name|ZCAT
if|if
condition|(
operator|*
name|end
operator|==
literal|'Z'
operator|||
operator|!
name|strcmp
argument_list|(
name|end
argument_list|,
literal|"gz"
argument_list|)
condition|)
return|return
name|ZCAT
return|;
endif|#
directive|endif
comment|/* ZCAT */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Simply display the preformatted page.  */
end_comment

begin_function
name|int
name|display_cat_file
parameter_list|(
name|file
parameter_list|)
specifier|register
name|char
modifier|*
name|file
decl_stmt|;
block|{
specifier|register
name|int
name|found
decl_stmt|;
name|char
name|command
index|[
name|FILENAME_MAX
index|]
decl_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|file
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|expander
init|=
name|get_expander
argument_list|(
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|expander
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"%s %s | %s"
argument_list|,
name|expander
argument_list|,
name|file
argument_list|,
name|pager
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"%s %s"
argument_list|,
name|pager
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|found
operator|=
name|do_system_command
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/*  * Try to find the ultimate source file.  If the first line of the  * current file is not of the form  *  *      .so man3/printf.3s  *  * the input file name is returned.  */
end_comment

begin_function
name|char
modifier|*
name|ultimate_source
parameter_list|(
name|name
parameter_list|,
name|path
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|static
name|char
name|ult
index|[
name|FILENAME_MAX
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|beg
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|strcpy
argument_list|(
name|ult
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|next
label|:
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|ult
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|buf
return|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|BUFSIZ
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|ult
return|;
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|<
literal|5
condition|)
return|return
name|ult
return|;
name|beg
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|*
name|beg
operator|++
operator|==
literal|'.'
operator|&&
operator|*
name|beg
operator|++
operator|==
literal|'s'
operator|&&
operator|*
name|beg
operator|++
operator|==
literal|'o'
condition|)
block|{
while|while
condition|(
operator|(
operator|*
name|beg
operator|==
literal|' '
operator|||
operator|*
name|beg
operator|==
literal|'\t'
operator|)
operator|&&
operator|*
name|beg
operator|!=
literal|'\0'
condition|)
name|beg
operator|++
expr_stmt|;
name|end
operator|=
name|beg
expr_stmt|;
while|while
condition|(
operator|*
name|end
operator|!=
literal|' '
operator|&&
operator|*
name|end
operator|!=
literal|'\t'
operator|&&
operator|*
name|end
operator|!=
literal|'\n'
operator|&&
operator|*
name|end
operator|!=
literal|'\0'
condition|)
name|end
operator|++
expr_stmt|;
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|ult
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ult
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ult
argument_list|,
name|beg
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|ult
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"found ultimate source file %s\n"
argument_list|,
name|ult
argument_list|)
expr_stmt|;
return|return
name|ult
return|;
block|}
end_function

begin_function
name|void
name|add_directive
parameter_list|(
name|first
parameter_list|,
name|d
parameter_list|,
name|file
parameter_list|,
name|buf
parameter_list|)
name|int
modifier|*
name|first
decl_stmt|;
name|char
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|d
argument_list|,
literal|""
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|first
condition|)
block|{
operator|*
name|first
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" | "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|parse_roff_directive
parameter_list|(
name|cp
parameter_list|,
name|file
parameter_list|,
name|buf
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
name|int
name|tbl_found
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'e'
case|:
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"found eqn(1) directive\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|troff
condition|)
name|add_directive
argument_list|(
operator|&
name|first
argument_list|,
name|EQN
argument_list|,
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|add_directive
argument_list|(
operator|&
name|first
argument_list|,
name|NEQN
argument_list|,
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"found grap(1) directive\n"
argument_list|)
expr_stmt|;
name|add_directive
argument_list|(
operator|&
name|first
argument_list|,
name|GRAP
argument_list|,
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"found pic(1) directive\n"
argument_list|)
expr_stmt|;
name|add_directive
argument_list|(
operator|&
name|first
argument_list|,
name|PIC
argument_list|,
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"found tbl(1) directive\n"
argument_list|)
expr_stmt|;
name|tbl_found
operator|++
expr_stmt|;
name|add_directive
argument_list|(
operator|&
name|first
argument_list|,
name|TBL
argument_list|,
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"found vgrind(1) directive\n"
argument_list|)
expr_stmt|;
name|add_directive
argument_list|(
operator|&
name|first
argument_list|,
name|VGRIND
argument_list|,
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"found refer(1) directive\n"
argument_list|)
expr_stmt|;
name|add_directive
argument_list|(
operator|&
name|first
argument_list|,
name|REFER
argument_list|,
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
goto|goto
name|done
goto|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
name|done
label|:
if|if
condition|(
name|first
condition|)
return|return
literal|1
return|;
ifdef|#
directive|ifdef
name|HAS_TROFF
if|if
condition|(
name|troff
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" | "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|TROFF
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" | "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|NROFF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tbl_found
operator|&&
operator|!
name|troff
operator|&&
name|strcmp
argument_list|(
name|COL
argument_list|,
literal|""
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" | "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|COL
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|make_roff_command
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|roff_directive
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"parsing directive from command line\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|parse_roff_directive
argument_list|(
name|roff_directive
argument_list|,
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
return|return
name|buf
return|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
name|gripe_roff_command_from_command_line
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
name|line
expr_stmt|;
name|fgets
argument_list|(
name|line
argument_list|,
literal|100
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|==
literal|'\''
operator|&&
operator|*
name|cp
operator|++
operator|==
literal|'\\'
operator|&&
operator|*
name|cp
operator|++
operator|==
literal|'"'
operator|&&
operator|*
name|cp
operator|++
operator|==
literal|' '
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"parsing directive from file\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|parse_roff_directive
argument_list|(
name|cp
argument_list|,
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
return|return
name|buf
return|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
name|gripe_roff_command_from_file
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*        * Is there really any point in continuing to look for        * preprocessor options if we can't even read the man page source?        */
name|gripe_reading_man_file
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"MANROFFSEQ"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"parsing directive from environment\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|parse_roff_directive
argument_list|(
name|cp
argument_list|,
name|file
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
return|return
name|buf
return|;
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
name|gripe_roff_command_from_env
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"using default preprocessor sequence\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|get_expander
argument_list|(
name|file
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|cp
operator|=
literal|"cat"
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %s | "
argument_list|,
name|cp
argument_list|,
name|file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_TROFF
if|if
condition|(
name|troff
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|TBL
argument_list|,
literal|""
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
name|TBL
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" | "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|TROFF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
name|TROFF
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|TBL
argument_list|,
literal|""
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
name|TBL
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" | "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|NROFF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|NROFF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|COL
argument_list|,
literal|""
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" | "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|COL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/*  * Try to format the man page and create a new formatted file.  Return  * 1 for success and 0 for failure.  */
end_comment

begin_function
name|int
name|make_cat_file
parameter_list|(
name|path
parameter_list|,
name|man_file
parameter_list|,
name|cat_file
parameter_list|)
specifier|register
name|char
modifier|*
name|path
decl_stmt|;
specifier|register
name|char
modifier|*
name|man_file
decl_stmt|;
specifier|register
name|char
modifier|*
name|cat_file
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|roff_command
decl_stmt|;
name|char
name|command
index|[
name|FILENAME_MAX
index|]
decl_stmt|;
name|char
name|temp
index|[
name|FILENAME_MAX
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s.tmp"
argument_list|,
name|cat_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|temp
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|roff_command
operator|=
name|make_roff_command
argument_list|(
name|man_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|roff_command
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
else|else
ifdef|#
directive|ifdef
name|DO_COMPRESS
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"(cd %s ; %s | %s> %s)"
argument_list|,
name|path
argument_list|,
name|roff_command
argument_list|,
name|COMPRESSOR
argument_list|,
name|temp
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"(cd %s ; %s> %s)"
argument_list|,
name|path
argument_list|,
name|roff_command
argument_list|,
name|temp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*        * Don't let the user interrupt the system () call and screw up        * the formatted man page if we're not done yet.        */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Formatting page, please wait..."
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|status
operator|=
name|do_system_command
argument_list|(
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed.\n"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|rename
argument_list|(
name|temp
argument_list|,
name|cat_file
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* FS might be sticky */
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"cp %s %s"
argument_list|,
name|temp
argument_list|,
name|cat_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|system
argument_list|(
name|command
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nHmm!  Can't seem to rename %s to %s, check permissions on man dir!\n"
argument_list|,
name|temp
argument_list|,
name|cat_file
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Done.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|1
condition|)
block|{
name|mode
operator|=
name|CATMODE
expr_stmt|;
name|chmod
argument_list|(
name|cat_file
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mode of %s is now %o\n"
argument_list|,
name|cat_file
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Couldn't open %s for writing.\n"
argument_list|,
name|cat_file
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Try to format the man page source and save it, then display it.  If  * that's not possible, try to format the man page source and display  * it directly.  *  * Note that we've already been handed the name of the ultimate source  * file at this point.  */
end_comment

begin_function
name|int
name|format_and_display
parameter_list|(
name|path
parameter_list|,
name|man_file
parameter_list|,
name|cat_file
parameter_list|)
specifier|register
name|char
modifier|*
name|path
decl_stmt|;
specifier|register
name|char
modifier|*
name|man_file
decl_stmt|;
specifier|register
name|char
modifier|*
name|cat_file
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
specifier|register
name|int
name|found
decl_stmt|;
name|char
modifier|*
name|roff_command
decl_stmt|;
name|char
name|command
index|[
name|FILENAME_MAX
index|]
decl_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|man_file
argument_list|,
name|R_OK
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|troff
condition|)
block|{
name|roff_command
operator|=
name|make_roff_command
argument_list|(
name|man_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|roff_command
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
else|else
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"(cd %s ; %s)"
argument_list|,
name|path
argument_list|,
name|roff_command
argument_list|)
expr_stmt|;
name|found
operator|=
name|do_system_command
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|is_newer
argument_list|(
name|man_file
argument_list|,
name|cat_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"status from is_newer() = %d\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|1
operator|||
name|status
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* 	   * Cat file is out of date.  Try to format and save it. 	   */
if|if
condition|(
name|print_where
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|man_file
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SETREUID
name|setreuid
argument_list|(
operator|-
literal|1
argument_list|,
name|euid
argument_list|)
expr_stmt|;
name|setregid
argument_list|(
operator|-
literal|1
argument_list|,
name|egid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|found
operator|=
name|make_cat_file
argument_list|(
name|path
argument_list|,
name|man_file
argument_list|,
name|cat_file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SETREUID
name|setreuid
argument_list|(
operator|-
literal|1
argument_list|,
name|ruid
argument_list|)
expr_stmt|;
name|setregid
argument_list|(
operator|-
literal|1
argument_list|,
name|rgid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
block|{
comment|/* Try again as real user - see note below. 		     By running with 		       effective group (user) ID == real group (user) ID 		     except for the call above, I believe the problems 		     of reading private man pages is avoided.  */
name|found
operator|=
name|make_cat_file
argument_list|(
name|path
argument_list|,
name|man_file
argument_list|,
name|cat_file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SECURE_MAN_UID
if|if
condition|(
operator|!
name|found
condition|)
block|{
comment|/* 		   * Try again as real user.  Note that for private 		   * man pages, we won't even get this far unless the 		   * effective user can read the real user's man page 		   * source.  Also, if we are trying to find all the 		   * man pages, this will probably make it impossible 		   * to make cat files in the system directories if 		   * the real user's man directories are searched 		   * first, because there's no way to undo this (is 		   * there?).  Yikes, am I missing something obvious? 		   */
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|found
operator|=
name|make_cat_file
argument_list|(
name|path
argument_list|,
name|man_file
argument_list|,
name|cat_file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|found
condition|)
block|{
comment|/* 		   * Creating the cat file worked.  Now just display it. 		   */
operator|(
name|void
operator|)
name|display_cat_file
argument_list|(
name|cat_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		   * Couldn't create cat file.  Just format it and 		   * display it through the pager. 		   */
name|roff_command
operator|=
name|make_roff_command
argument_list|(
name|man_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|roff_command
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
else|else
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"(cd %s ; %s | %s)"
argument_list|,
name|path
argument_list|,
name|roff_command
argument_list|,
name|pager
argument_list|)
expr_stmt|;
name|found
operator|=
name|do_system_command
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|access
argument_list|(
name|cat_file
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 	   * Formatting not necessary.  Cat file is newer than source 	   * file, or source file is not present but cat file is. 	   */
if|if
condition|(
name|print_where
condition|)
block|{
name|printf
argument_list|(
literal|"%s (source: %s)\n"
argument_list|,
name|cat_file
argument_list|,
name|man_file
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
else|else
block|{
name|found
operator|=
name|display_cat_file
argument_list|(
name|cat_file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/*  * See if the preformatted man page or the source exists in the given  * section.  */
end_comment

begin_function
name|int
name|try_section
parameter_list|(
name|path
parameter_list|,
name|section
parameter_list|,
name|name
parameter_list|,
name|glob
parameter_list|)
specifier|register
name|char
modifier|*
name|path
decl_stmt|;
specifier|register
name|char
modifier|*
name|section
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|glob
decl_stmt|;
block|{
specifier|register
name|int
name|found
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|to_cat
decl_stmt|;
specifier|register
name|int
name|cat
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|names
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|np
decl_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
if|if
condition|(
name|glob
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"trying section %s with globbing\n"
argument_list|,
name|section
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"trying section %s without globbing\n"
argument_list|,
name|section
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NROFF_MISSING
comment|/*    * Look for man page source files.    */
name|cat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|glob
condition|)
name|names
operator|=
name|glob_for_file
argument_list|(
name|path
argument_list|,
name|section
argument_list|,
name|name
argument_list|,
name|cat
argument_list|)
expr_stmt|;
else|else
name|names
operator|=
name|make_name
argument_list|(
name|path
argument_list|,
name|section
argument_list|,
name|name
argument_list|,
name|cat
argument_list|)
expr_stmt|;
if|if
condition|(
name|names
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
operator|-
literal|1
operator|||
operator|*
name|names
operator|==
name|NULL
condition|)
comment|/*      * No files match.  See if there's a preformatted page around that      * we can display.      */
endif|#
directive|endif
comment|/* NROFF_MISSING */
block|{
if|if
condition|(
operator|!
name|troff
condition|)
block|{
name|cat
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|glob
condition|)
name|names
operator|=
name|glob_for_file
argument_list|(
name|path
argument_list|,
name|section
argument_list|,
name|name
argument_list|,
name|cat
argument_list|)
expr_stmt|;
else|else
name|names
operator|=
name|make_name
argument_list|(
name|path
argument_list|,
name|section
argument_list|,
name|name
argument_list|,
name|cat
argument_list|)
expr_stmt|;
if|if
condition|(
name|names
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
operator|-
literal|1
operator|&&
operator|*
name|names
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|np
operator|=
name|names
init|;
operator|*
name|np
operator|!=
name|NULL
condition|;
name|np
operator|++
control|)
block|{
if|if
condition|(
name|print_where
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
operator|*
name|np
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
else|else
block|{
name|found
operator|+=
name|display_cat_file
argument_list|(
operator|*
name|np
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|NROFF_MISSING
else|else
block|{
for|for
control|(
name|np
operator|=
name|names
init|;
operator|*
name|np
operator|!=
name|NULL
condition|;
name|np
operator|++
control|)
block|{
specifier|register
name|char
modifier|*
name|cat_file
init|=
name|NULL
decl_stmt|;
specifier|register
name|char
modifier|*
name|man_file
decl_stmt|;
name|man_file
operator|=
name|ultimate_source
argument_list|(
operator|*
name|np
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|troff
condition|)
block|{
name|to_cat
operator|=
literal|1
expr_stmt|;
name|cat_file
operator|=
name|convert_name
argument_list|(
name|man_file
argument_list|,
name|to_cat
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"will try to write %s if needed\n"
argument_list|,
name|cat_file
argument_list|)
expr_stmt|;
block|}
name|found
operator|+=
name|format_and_display
argument_list|(
name|path
argument_list|,
name|man_file
argument_list|,
name|cat_file
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* NROFF_MISSING */
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/*  * Search for manual pages.  *  * If preformatted manual pages are supported, look for the formatted  * file first, then the man page source file.  If they both exist and  * the man page source file is newer, or only the source file exists,  * try to reformat it and write the results in the cat directory.  If  * it is not possible to write the cat file, simply format and display  * the man file.  *  * If preformatted pages are not supported, or the troff option is  * being used, only look for the man page source file.  *  */
end_comment

begin_function
name|int
name|man
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|found
decl_stmt|;
specifier|register
name|int
name|glob
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|mp
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|sp
decl_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|mp
operator|=
name|manpathlist
init|;
operator|*
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|++
control|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nsearching in %s\n"
argument_list|,
operator|*
name|mp
argument_list|)
expr_stmt|;
name|glob
operator|=
literal|1
expr_stmt|;
name|found
operator|+=
name|try_section
argument_list|(
operator|*
name|mp
argument_list|,
name|section
argument_list|,
name|name
argument_list|,
name|glob
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|&&
operator|!
name|findall
condition|)
comment|/* i.e. only do this section... */
return|return
name|found
return|;
block|}
block|}
else|else
block|{
for|for
control|(
name|sp
operator|=
name|section_list
init|;
operator|*
name|sp
operator|!=
name|NULL
condition|;
name|sp
operator|++
control|)
block|{
for|for
control|(
name|mp
operator|=
name|manpathlist
init|;
operator|*
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|++
control|)
block|{
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nsearching in %s\n"
argument_list|,
operator|*
name|mp
argument_list|)
expr_stmt|;
name|glob
operator|=
literal|1
expr_stmt|;
name|found
operator|+=
name|try_section
argument_list|(
operator|*
name|mp
argument_list|,
operator|*
name|sp
argument_list|,
name|name
argument_list|,
name|glob
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|&&
operator|!
name|findall
condition|)
comment|/* i.e. only do this section... */
return|return
name|found
return|;
block|}
block|}
block|}
return|return
name|found
return|;
block|}
end_function

begin_function
name|char
modifier|*
modifier|*
name|get_section_list
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
specifier|static
name|char
modifier|*
name|tmp_section_list
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
name|colon_sep_section_list
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|getenv
argument_list|(
literal|"MANSECT"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
name|std_sections
return|;
block|}
else|else
block|{
name|colon_sep_section_list
operator|=
name|strdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|colon_sep_section_list
init|;
condition|;
name|p
operator|=
name|end
operator|+
literal|1
control|)
block|{
if|if
condition|(
operator|(
name|end
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
name|tmp_section_list
index|[
name|i
operator|++
index|]
operator|=
name|strdup
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|NULL
condition|)
break|break;
block|}
name|tmp_section_list
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|tmp_section_list
return|;
block|}
end_function

end_unit

