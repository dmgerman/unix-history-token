begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* File-name wildcard pattern matching for GNU.    Copyright (C) 1985, 1988, 1989, 1990, 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 1, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* To whomever it may concern: I have never seen the code which most    Unix programs use to perform this function.  I wrote this from scratch    based on specifications for the pattern matching.  --RMS.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SHELL
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SHELL */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USGr3
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DIRENT
argument_list|)
end_if

begin_define
define|#
directive|define
name|DIRENT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USGr3 */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|Xenix
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SYSNDIR
argument_list|)
end_if

begin_define
define|#
directive|define
name|SYSNDIR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Xenix */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|POSIX
argument_list|)
operator|||
name|defined
argument_list|(
name|DIRENT
argument_list|)
operator|||
name|defined
argument_list|(
name|__GNU_LIBRARY__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_define
define|#
directive|define
name|direct
value|dirent
end_define

begin_define
define|#
directive|define
name|D_NAMLEN
parameter_list|(
name|d
parameter_list|)
value|strlen((d)->d_name)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not POSIX or DIRENT or __GNU_LIBRARY__ */
end_comment

begin_define
define|#
directive|define
name|D_NAMLEN
parameter_list|(
name|d
parameter_list|)
value|((d)->d_namlen)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYSNDIR
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ndir.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SYSNDIR */
end_comment

begin_include
include|#
directive|include
file|"ndir.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not SYSNDIR */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not USG */
end_comment

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* POSIX or DIRENT or __GNU_LIBRARY__ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_SOURCE
argument_list|)
end_if

begin_comment
comment|/* Posix does not require that the d_ino field be present, and some    systems do not provide it. */
end_comment

begin_define
define|#
directive|define
name|REAL_DIR_ENTRY
parameter_list|(
name|dp
parameter_list|)
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|REAL_DIR_ENTRY
parameter_list|(
name|dp
parameter_list|)
value|(dp->d_ino != 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _POSIX_SOURCE */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
operator|||
name|defined
argument_list|(
name|__GNU_LIBRARY__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|STDC_STRINGS
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* STDC_HEADERS or __GNU_LIBRARY__ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|POSIX
end_ifndef

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* POSIX */
end_comment

begin_define
define|#
directive|define
name|STDC_STRINGS
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not USG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NeXT
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* NeXT */
end_comment

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NeXT */
end_comment

begin_comment
comment|/* Declaring bcopy causes errors on systems whose declarations are different.    If the declaration is omitted, everything works fine.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not USG */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Not STDC_HEADERS or __GNU_LIBRARY__.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STDC_STRINGS
end_ifdef

begin_define
define|#
directive|define
name|bcopy
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|n
parameter_list|)
value|memcpy ((d), (s), (n))
end_define

begin_define
define|#
directive|define
name|index
value|strchr
end_define

begin_define
define|#
directive|define
name|rindex
value|strrchr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STDC_STRINGS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|alloca
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Not GCC.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|sparc
end_ifdef

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Not sparc.  */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sparc.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GCC.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero if '*' and '?' do not match an initial '.' for glob_filename.  */
end_comment

begin_decl_stmt
name|int
name|noglob_dot_filenames
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|glob_match_after_star
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_function
specifier|static
name|int
name|collate_range_cmp
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
specifier|static
name|char
name|s
index|[
literal|2
index|]
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
name|a
operator|==
operator|(
name|unsigned
name|char
operator|)
name|b
condition|)
return|return
literal|0
return|;
name|s
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|a
expr_stmt|;
name|s
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|b
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|strcoll
argument_list|(
name|s
index|[
literal|0
index|]
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|r
operator|=
operator|(
name|unsigned
name|char
operator|)
name|a
operator|-
operator|(
name|unsigned
name|char
operator|)
name|b
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Return nonzero if PATTERN has any special globbing chars in it.  */
end_comment

begin_function
name|int
name|glob_pattern_p
parameter_list|(
name|pattern
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|pattern
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|int
name|open
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'?'
case|:
case|case
literal|'*'
case|:
return|return
literal|1
return|;
case|case
literal|'['
case|:
comment|/* Only accept an open brace if there is a close */
name|open
operator|++
expr_stmt|;
comment|/* brace to match it.  Bracket expressions must be */
continue|continue;
comment|/* complete, according to Posix.2 */
case|case
literal|']'
case|:
if|if
condition|(
name|open
condition|)
return|return
literal|1
return|;
continue|continue;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Match the pattern PATTERN against the string TEXT;    return 1 if it matches, 0 otherwise.     A match means the entire string TEXT is used up in matching.     In the pattern string, `*' matches any sequence of characters,    `?' matches any character, [SET] matches any character in the specified set,    [!SET] matches any character not in the specified set.     A set is composed of characters or ranges; a range looks like    character hyphen character (as in 0-9 or A-Z).    [0-9a-zA-Z_] is the set of characters allowed in C identifiers.    Any other character in the pattern must be matched exactly.     To suppress the special syntactic significance of any of `[]*?!-\',    and match the character exactly, precede it with a `\'.     If DOT_SPECIAL is nonzero,    `*' and `?' do not match `.' at the beginning of TEXT.  */
end_comment

begin_function
name|int
name|glob_match
parameter_list|(
name|pattern
parameter_list|,
name|text
parameter_list|,
name|dot_special
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|,
decl|*
name|text
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|dot_special
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|pattern
decl_stmt|,
modifier|*
name|t
init|=
name|text
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'?'
case|:
if|if
condition|(
operator|*
name|t
operator|==
literal|'\0'
operator|||
operator|(
name|dot_special
operator|&&
name|t
operator|==
name|text
operator|&&
operator|*
name|t
operator|==
literal|'.'
operator|)
condition|)
return|return
literal|0
return|;
else|else
operator|++
name|t
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|t
operator|++
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
name|dot_special
operator|&&
name|t
operator|==
name|text
operator|&&
operator|*
name|t
operator|==
literal|'.'
condition|)
return|return
literal|0
return|;
return|return
name|glob_match_after_star
argument_list|(
name|p
argument_list|,
name|t
argument_list|)
return|;
case|case
literal|'['
case|:
block|{
specifier|register
name|char
name|c1
init|=
operator|*
name|t
operator|++
decl_stmt|;
name|int
name|invert
decl_stmt|;
name|char
modifier|*
name|cp1
init|=
name|p
decl_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
name|invert
operator|=
operator|(
operator|*
name|p
operator|==
literal|'!'
operator|)
expr_stmt|;
if|if
condition|(
name|invert
condition|)
name|p
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|char
name|cstart
init|=
name|c
decl_stmt|,
name|cend
init|=
name|c
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|cstart
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|cend
operator|=
name|cstart
expr_stmt|;
block|}
if|if
condition|(
name|cstart
operator|==
literal|'\0'
condition|)
block|{
comment|/* Missing ']'. */
if|if
condition|(
name|c1
operator|!=
literal|'['
condition|)
return|return
literal|0
return|;
comment|/* matched a single bracket */
name|p
operator|=
name|cp1
expr_stmt|;
goto|goto
name|breakbracket
goto|;
block|}
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
name|cend
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|cend
operator|==
literal|'\\'
condition|)
name|cend
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|cend
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|collate_range_cmp
argument_list|(
name|c1
argument_list|,
name|cstart
argument_list|)
operator|>=
literal|0
operator|&&
name|collate_range_cmp
argument_list|(
name|c1
argument_list|,
name|cend
argument_list|)
operator|<=
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|c1
operator|>=
name|cstart
operator|&&
name|c1
operator|<=
name|cend
condition|)
endif|#
directive|endif
goto|goto
name|match
goto|;
if|if
condition|(
name|c
operator|==
literal|']'
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|invert
condition|)
return|return
literal|0
return|;
break|break;
name|match
label|:
comment|/* Skip the rest of the [...] construct that already matched.  */
while|while
condition|(
name|c
operator|!=
literal|']'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|invert
condition|)
return|return
literal|0
return|;
name|breakbracket
label|:
break|break;
block|}
default|default:
if|if
condition|(
name|c
operator|!=
operator|*
name|t
operator|++
condition|)
return|return
literal|0
return|;
block|}
return|return
operator|*
name|t
operator|==
literal|'\0'
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Like glob_match, but match PATTERN against any final segment of TEXT.  */
end_comment

begin_function
specifier|static
name|int
name|glob_match_after_star
parameter_list|(
name|pattern
parameter_list|,
name|text
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|,
decl|*
name|text
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|pattern
decl_stmt|,
modifier|*
name|t
init|=
name|text
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|,
name|c1
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|==
literal|'?'
operator|||
name|c
operator|==
literal|'*'
condition|)
if|if
condition|(
name|c
operator|==
literal|'?'
operator|&&
operator|*
name|t
operator|++
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|c1
operator|=
operator|*
name|p
expr_stmt|;
else|else
name|c1
operator|=
name|c
expr_stmt|;
operator|--
name|p
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|==
literal|'['
operator|||
operator|*
name|t
operator|==
name|c1
operator|)
operator|&&
name|glob_match
argument_list|(
name|p
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|*
name|t
operator|++
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Return a vector of names of files in directory DIR    whose names match glob pattern PAT.    The names are not in any particular order.    Wildcards at the beginning of PAT do not match an initial period    if noglob_dot_filenames is nonzero.     The vector is terminated by an element that is a null pointer.     To free the space allocated, first free the vector's elements,    then free the vector.     Return NULL if cannot get enough memory to hold the pointer    and the names.     Return -1 if cannot access directory DIR.    Look in errno for more information.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|glob_vector
parameter_list|(
name|pat
parameter_list|,
name|dir
parameter_list|)
name|char
modifier|*
name|pat
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
block|{
struct|struct
name|globval
block|{
name|struct
name|globval
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
name|DIR
modifier|*
name|d
decl_stmt|;
specifier|register
name|struct
name|direct
modifier|*
name|dp
decl_stmt|;
name|struct
name|globval
modifier|*
name|lastlink
decl_stmt|;
specifier|register
name|struct
name|globval
modifier|*
name|nextlink
decl_stmt|;
specifier|register
name|char
modifier|*
name|nextname
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|int
name|lose
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|name_vector
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|ALLOCA_MISSING
name|struct
name|globval
modifier|*
name|templink
decl_stmt|;
endif|#
directive|endif
name|d
operator|=
name|opendir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
return|return
operator|(
name|char
operator|*
operator|*
operator|)
operator|-
literal|1
return|;
name|lastlink
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|lose
operator|=
literal|0
expr_stmt|;
comment|/* Scan the directory, finding all names that match.      For each name that matches, allocate a struct globval      on the stack and store the name in it.      Chain those structs together; lastlink is the front of the chain.  */
while|while
condition|(
literal|1
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
comment|/* Make globbing interruptible in the bash shell. */
specifier|extern
name|int
name|interrupt_state
decl_stmt|;
if|if
condition|(
name|interrupt_state
condition|)
block|{
name|closedir
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|lose
operator|=
literal|1
expr_stmt|;
goto|goto
name|lost
goto|;
block|}
endif|#
directive|endif
comment|/* SHELL */
name|dp
operator|=
name|readdir
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|REAL_DIR_ENTRY
argument_list|(
name|dp
argument_list|)
operator|&&
name|glob_match
argument_list|(
name|pat
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|noglob_dot_filenames
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ALLOCA_MISSING
name|nextlink
operator|=
operator|(
expr|struct
name|globval
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|globval
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|nextlink
operator|=
operator|(
expr|struct
name|globval
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|globval
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nextlink
operator|->
name|next
operator|=
name|lastlink
expr_stmt|;
name|i
operator|=
name|D_NAMLEN
argument_list|(
name|dp
argument_list|)
operator|+
literal|1
expr_stmt|;
name|nextname
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextname
operator|==
name|NULL
condition|)
block|{
name|lose
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|lastlink
operator|=
name|nextlink
expr_stmt|;
name|nextlink
operator|->
name|name
operator|=
name|nextname
expr_stmt|;
name|bcopy
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|nextname
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
name|closedir
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lose
condition|)
block|{
name|name_vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|lose
operator||=
name|name_vector
operator|==
name|NULL
expr_stmt|;
block|}
comment|/* Have we run out of memory?  */
ifdef|#
directive|ifdef
name|SHELL
name|lost
label|:
endif|#
directive|endif
if|if
condition|(
name|lose
condition|)
block|{
comment|/* Here free the strings we have got.  */
while|while
condition|(
name|lastlink
condition|)
block|{
name|free
argument_list|(
name|lastlink
operator|->
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALLOCA_MISSING
name|templink
operator|=
name|lastlink
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lastlink
argument_list|)
expr_stmt|;
name|lastlink
operator|=
name|templink
expr_stmt|;
else|#
directive|else
name|lastlink
operator|=
name|lastlink
operator|->
name|next
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|NULL
return|;
block|}
comment|/* Copy the name pointers from the linked list into the vector.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|name_vector
index|[
name|i
index|]
operator|=
name|lastlink
operator|->
name|name
expr_stmt|;
ifdef|#
directive|ifdef
name|ALLOCA_MISSING
name|templink
operator|=
name|lastlink
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lastlink
argument_list|)
expr_stmt|;
name|lastlink
operator|=
name|templink
expr_stmt|;
else|#
directive|else
name|lastlink
operator|=
name|lastlink
operator|->
name|next
expr_stmt|;
endif|#
directive|endif
block|}
name|name_vector
index|[
name|count
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|name_vector
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a new array, replacing ARRAY, which is the concatenation    of each string in ARRAY to DIR.    Return NULL if out of memory.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|glob_dir_to_array
parameter_list|(
name|dir
parameter_list|,
name|array
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|,
decl|*
modifier|*
name|array
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
name|int
name|add_slash
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|result
decl_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
name|array
return|;
if|if
condition|(
name|dir
index|[
name|l
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|add_slash
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|array
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|array
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|result
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|1
operator|+
name|l
operator|+
name|add_slash
operator|+
name|strlen
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
index|[
name|i
index|]
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|strcpy
argument_list|(
name|result
index|[
name|i
index|]
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_slash
condition|)
name|result
index|[
name|i
index|]
index|[
name|l
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|result
index|[
name|i
index|]
operator|+
name|l
operator|+
name|add_slash
argument_list|,
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|result
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Free the input array.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|array
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|array
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Do globbing on PATHNAME.  Return an array of pathnames that match,    marking the end of the array with a null-pointer as an element.    If no pathnames match, then the array is empty (first element is null).    If there isn't enough memory, then return NULL.    If a file system error occurs, return -1; `errno' has the error code.     Wildcards at the beginning of PAT, or following a slash,    do not match an initial period if noglob_dot_filenames is nonzero.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|glob_filename
parameter_list|(
name|pathname
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|result
decl_stmt|;
name|unsigned
name|int
name|result_size
decl_stmt|;
name|char
modifier|*
name|directory_name
decl_stmt|,
modifier|*
name|filename
decl_stmt|;
name|unsigned
name|int
name|directory_len
decl_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|result_size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|result
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Find the filename.  */
name|filename
operator|=
name|rindex
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
block|{
name|filename
operator|=
name|pathname
expr_stmt|;
name|directory_name
operator|=
literal|""
expr_stmt|;
name|directory_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|directory_len
operator|=
operator|(
name|filename
operator|-
name|pathname
operator|)
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|ALLOCA_MISSING
name|directory_name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|directory_len
operator|+
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|directory_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|directory_len
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
name|pathname
argument_list|,
name|directory_name
argument_list|,
name|directory_len
argument_list|)
expr_stmt|;
name|directory_name
index|[
name|directory_len
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|filename
expr_stmt|;
block|}
comment|/* If directory_name contains globbing characters, then we      have to expand the previous levels.  Just recurse. */
if|if
condition|(
name|glob_pattern_p
argument_list|(
name|directory_name
argument_list|)
condition|)
block|{
name|char
modifier|*
modifier|*
name|directories
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|directory_name
index|[
name|directory_len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|directory_name
index|[
name|directory_len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|directories
operator|=
name|glob_filename
argument_list|(
name|directory_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALLOCA_MISSING
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|directory_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|directories
operator|==
name|NULL
condition|)
goto|goto
name|memory_error
goto|;
elseif|else
if|if
condition|(
name|directories
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
operator|-
literal|1
condition|)
return|return
operator|(
name|char
operator|*
operator|*
operator|)
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|*
name|directories
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|directories
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|*
operator|)
operator|-
literal|1
return|;
block|}
comment|/* We have successfully globbed the preceding directory name. 	 For each name in DIRECTORIES, call glob_vector on it and 	 FILENAME.  Concatenate the results together.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|directories
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
modifier|*
name|temp_results
init|=
name|glob_vector
argument_list|(
name|filename
argument_list|,
name|directories
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp_results
operator|==
name|NULL
condition|)
goto|goto
name|memory_error
goto|;
elseif|else
if|if
condition|(
name|temp_results
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
operator|-
literal|1
condition|)
comment|/* This filename is probably not a directory.  Ignore it.  */
empty_stmt|;
else|else
block|{
name|char
modifier|*
modifier|*
name|array
init|=
name|glob_dir_to_array
argument_list|(
name|directories
index|[
name|i
index|]
argument_list|,
name|temp_results
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|int
name|l
decl_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|array
index|[
name|l
index|]
operator|!=
name|NULL
condition|)
operator|++
name|l
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|result
argument_list|,
operator|(
name|result_size
operator|+
name|l
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
goto|goto
name|memory_error
goto|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|array
index|[
name|l
index|]
operator|!=
name|NULL
condition|;
operator|++
name|l
control|)
name|result
index|[
name|result_size
operator|++
operator|-
literal|1
index|]
operator|=
name|array
index|[
name|l
index|]
expr_stmt|;
name|result
index|[
name|result_size
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|array
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Free the directories.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|directories
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|directories
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|directories
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* If there is only a directory name, return it. */
if|if
condition|(
operator|*
name|filename
operator|==
literal|'\0'
condition|)
block|{
name|result
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|result
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
block|{
name|result
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|directory_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|ALLOCA_MISSING
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|directory_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|memory_error
goto|;
block|}
name|bcopy
argument_list|(
name|directory_name
argument_list|,
name|result
index|[
literal|0
index|]
argument_list|,
name|directory_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|result
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ALLOCA_MISSING
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|directory_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
else|else
block|{
comment|/* Otherwise, just return what glob_vector 	 returns appended to the directory name. */
name|char
modifier|*
modifier|*
name|temp_results
init|=
name|glob_vector
argument_list|(
name|filename
argument_list|,
operator|(
name|directory_len
operator|==
literal|0
condition|?
literal|"."
else|:
name|directory_name
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp_results
operator|==
name|NULL
operator|||
name|temp_results
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|NO_ALLOCA
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|directory_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|temp_results
return|;
block|}
name|temp_results
operator|=
name|glob_dir_to_array
argument_list|(
name|directory_name
argument_list|,
name|temp_results
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_ALLOCA
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|directory_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|temp_results
return|;
block|}
comment|/* We get to memory error if the program has run out of memory, or      if this is the shell, and we have been interrupted. */
name|memory_error
label|:
if|if
condition|(
name|result
operator|!=
name|NULL
condition|)
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|result
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|result
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|result
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SHELL
argument_list|)
block|{
specifier|extern
name|int
name|interrupt_state
decl_stmt|;
if|if
condition|(
name|interrupt_state
condition|)
name|throw_to_top_level
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SHELL */
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|value
decl_stmt|;
name|int
name|i
decl_stmt|,
name|optind
decl_stmt|;
for|for
control|(
name|optind
operator|=
literal|1
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
name|value
operator|=
name|glob_filename
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
name|puts
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
operator|-
literal|1
condition|)
name|perror
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|value
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|puts
argument_list|(
name|value
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST */
end_comment

end_unit

