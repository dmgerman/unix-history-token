begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * util.c  *  * Copyright (c) 1990, 1991, John W. Eaton.  *  * You may distribute under the terms of the GNU General Public  * License as specified in the file COPYING that comes with the man  * distribution.  *  * John W. Eaton  * jwe@che.utexas.edu  * Department of Chemical Engineering  * The University of Texas at Austin  * Austin, Texas  78712  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|STDC_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|int
name|fprintf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|tolower
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|char
modifier|*
name|strdup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|system
parameter_list|()
function_decl|;
end_function_decl

begin_include
include|#
directive|include
file|"gripes.h"
end_include

begin_comment
comment|/*  * Extract last element of a name like /foo/bar/baz.  */
end_comment

begin_function
name|char
modifier|*
name|mkprogname
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|strrchr
argument_list|(
name|s
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|t
operator|=
name|s
expr_stmt|;
else|else
name|t
operator|++
expr_stmt|;
return|return
name|strdup
argument_list|(
name|t
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|downcase
parameter_list|(
name|s
parameter_list|)
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
operator|*
name|s
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Is file a newer than file b?  *  * case:  *  *   a newer than b         returns    1  *   a older than b         returns    0  *   stat on a fails        returns   -1  *   stat on b fails        returns   -2  *   stat on a and b fails  returns   -3  */
end_comment

begin_function
name|int
name|is_newer
parameter_list|(
name|fa
parameter_list|,
name|fb
parameter_list|)
specifier|register
name|char
modifier|*
name|fa
decl_stmt|;
specifier|register
name|char
modifier|*
name|fb
decl_stmt|;
block|{
name|struct
name|stat
name|fa_sb
decl_stmt|;
name|struct
name|stat
name|fb_sb
decl_stmt|;
specifier|register
name|int
name|fa_stat
decl_stmt|;
specifier|register
name|int
name|fb_stat
decl_stmt|;
specifier|register
name|int
name|status
init|=
literal|0
decl_stmt|;
name|fa_stat
operator|=
name|stat
argument_list|(
name|fa
argument_list|,
operator|&
name|fa_sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|fa_stat
operator|!=
literal|0
condition|)
name|status
operator|=
literal|1
expr_stmt|;
name|fb_stat
operator|=
name|stat
argument_list|(
name|fb
argument_list|,
operator|&
name|fb_sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|fb_stat
operator|!=
literal|0
condition|)
name|status
operator||=
literal|2
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
operator|-
name|status
return|;
return|return
operator|(
name|fa_sb
operator|.
name|st_mtime
operator|>
name|fb_sb
operator|.
name|st_mtime
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Is path a directory?  */
end_comment

begin_function
name|int
name|is_directory
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
specifier|register
name|int
name|status
decl_stmt|;
name|status
operator|=
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IFDIR
operator|)
operator|==
name|S_IFDIR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt a system () call.  Return 1 for success and 0 for failure  * (handy for counting successes :-).  */
end_comment

begin_function
name|int
name|do_system_command
parameter_list|(
name|command
parameter_list|)
name|char
modifier|*
name|command
decl_stmt|;
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
specifier|extern
name|int
name|debug
decl_stmt|;
comment|/*    * If we're debugging, don't really execute the command -- you never    * know what might be in that mangled string :-O.    */
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ntrying command: %s\n"
argument_list|,
name|command
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|system
argument_list|(
name|command
argument_list|)
expr_stmt|;
comment|/* check return value from system() function first */
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"wait() for exit status of shell failed in function system()\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
literal|127
operator|||
name|status
operator|==
operator|(
literal|127
operator|<<
literal|8
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"execution of the shell failed in function system()\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|gripe_system_command
argument_list|(
name|status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
literal|1
return|;
block|}
end_function

end_unit

