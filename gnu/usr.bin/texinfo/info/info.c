begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* info.c -- Display nodes of Info files in multiple windows. */
end_comment

begin_comment
comment|/* This file is part of GNU Info, a program for reading online documentation    stored in Info format.     Copyright (C) 1993 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     Written by Brian Fox (bfox@ai.mit.edu). */
end_comment

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_include
include|#
directive|include
file|"dribble.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_comment
comment|/* The version numbers of this version of Info. */
end_comment

begin_decl_stmt
name|int
name|info_major_version
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|info_minor_version
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|info_patch_level
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means search all indices for APROPOS_SEARCH_STRING. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|apropos_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variable containing the string to search for when apropos_p is non-zero. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|apropos_search_string
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means print version info only. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_version_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means print a short description of the options. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_help_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of the names of nodes that the user specified with "--node" on the    command line. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|user_nodenames
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|user_nodenames_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|user_nodenames_slots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String specifying the first file to load.  This string can only be set    by the user specifying "--file" on the command line. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|user_filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String specifying the name of the file to dump nodes to.  This value is    filled if the user speficies "--output" on the command line. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|user_output_filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero indicates that when "--output" is specified, all of the menu    items of the specified nodes (and their subnodes as well) should be    dumped in the order encountered.  This basically can print a book. */
end_comment

begin_decl_stmt
name|int
name|dump_subnodes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure describing the options that Info accepts.  We pass this structure    to getopt_long ().  If you add or otherwise change this structure, you must    also change the string which follows it. */
end_comment

begin_define
define|#
directive|define
name|APROPOS_OPTION
value|1
end_define

begin_define
define|#
directive|define
name|DRIBBLE_OPTION
value|2
end_define

begin_define
define|#
directive|define
name|RESTORE_OPTION
value|3
end_define

begin_decl_stmt
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"apropos"
block|,
literal|1
block|,
literal|0
block|,
name|APROPOS_OPTION
block|}
block|,
block|{
literal|"directory"
block|,
literal|1
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"node"
block|,
literal|1
block|,
literal|0
block|,
literal|'n'
block|}
block|,
block|{
literal|"file"
block|,
literal|1
block|,
literal|0
block|,
literal|'f'
block|}
block|,
block|{
literal|"subnodes"
block|,
literal|0
block|,
operator|&
name|dump_subnodes
block|,
literal|1
block|}
block|,
block|{
literal|"output"
block|,
literal|1
block|,
literal|0
block|,
literal|'o'
block|}
block|,
block|{
literal|"help"
block|,
literal|0
block|,
operator|&
name|print_help_p
block|,
literal|1
block|}
block|,
block|{
literal|"version"
block|,
literal|0
block|,
operator|&
name|print_version_p
block|,
literal|1
block|}
block|,
block|{
literal|"dribble"
block|,
literal|1
block|,
literal|0
block|,
name|DRIBBLE_OPTION
block|}
block|,
block|{
literal|"restore"
block|,
literal|1
block|,
literal|0
block|,
name|RESTORE_OPTION
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String describing the shorthand versions of the long options found above. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|short_options
init|=
literal|"d:n:f:o:s"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When non-zero, the Info window system has been initialized. */
end_comment

begin_decl_stmt
name|int
name|info_windows_initialized_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some "forward" declarations. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|usage
argument_list|()
decl_stmt|,
name|info_short_help
argument_list|()
decl_stmt|,
name|remember_info_program_name
argument_list|()
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		  Main Entry Point to the Info Program		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|getopt_long_index
decl_stmt|;
comment|/* Index returned by getopt_long (). */
name|NODE
modifier|*
name|initial_node
decl_stmt|;
comment|/* First node loaded by Info. */
if|#
directive|if
name|defined
argument_list|(
name|NeXT
argument_list|)
operator|&&
name|defined
argument_list|(
name|NOTDEF
argument_list|)
name|malloc_debug
argument_list|(
literal|0x0ffffffff
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NeXT&& NOTDEF */
name|remember_info_program_name
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|option_character
decl_stmt|;
name|option_character
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|short_options
argument_list|,
name|long_options
argument_list|,
operator|&
name|getopt_long_index
argument_list|)
expr_stmt|;
comment|/* getopt_long () returns EOF when there are no more long options. */
if|if
condition|(
name|option_character
operator|==
name|EOF
condition|)
break|break;
comment|/* If this is a long option, then get the short version of it. */
if|if
condition|(
name|option_character
operator|==
literal|0
operator|&&
name|long_options
index|[
name|getopt_long_index
index|]
operator|.
name|flag
operator|==
literal|0
condition|)
name|option_character
operator|=
name|long_options
index|[
name|getopt_long_index
index|]
operator|.
name|val
expr_stmt|;
comment|/* Case on the option that we have received. */
switch|switch
condition|(
name|option_character
condition|)
block|{
case|case
literal|0
case|:
break|break;
comment|/* User wants to add a directory. */
case|case
literal|'d'
case|:
name|info_add_path
argument_list|(
name|optarg
argument_list|,
name|INFOPATH_PREPEND
argument_list|)
expr_stmt|;
break|break;
comment|/* User is specifying a particular node. */
case|case
literal|'n'
case|:
name|add_pointer_to_array
argument_list|(
name|optarg
argument_list|,
name|user_nodenames_index
argument_list|,
name|user_nodenames
argument_list|,
name|user_nodenames_slots
argument_list|,
literal|10
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
break|break;
comment|/* User is specifying a particular Info file. */
case|case
literal|'f'
case|:
if|if
condition|(
name|user_filename
condition|)
name|free
argument_list|(
name|user_filename
argument_list|)
expr_stmt|;
name|user_filename
operator|=
name|savestring
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
comment|/* User is specifying the name of a file to output to. */
case|case
literal|'o'
case|:
if|if
condition|(
name|user_output_filename
condition|)
name|free
argument_list|(
name|user_output_filename
argument_list|)
expr_stmt|;
name|user_output_filename
operator|=
name|savestring
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
comment|/* User is specifying that she wishes to dump the subnodes of 	     the node that she is dumping. */
case|case
literal|'s'
case|:
name|dump_subnodes
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* User has specified a string to search all indices for. */
case|case
name|APROPOS_OPTION
case|:
name|apropos_p
operator|=
literal|1
expr_stmt|;
name|maybe_free
argument_list|(
name|apropos_search_string
argument_list|)
expr_stmt|;
name|apropos_search_string
operator|=
name|savestring
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
comment|/* User has specified a dribble file to receive keystrokes. */
case|case
name|DRIBBLE_OPTION
case|:
name|close_dribble_file
argument_list|()
expr_stmt|;
name|open_dribble_file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
comment|/* User has specified an alternate input stream. */
case|case
name|RESTORE_OPTION
case|:
name|info_set_input_from_file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If the user specified --version, then show the version and exit. */
if|if
condition|(
name|print_version_p
condition|)
block|{
name|printf
argument_list|(
literal|"GNU Info, Version %s.\n"
argument_list|,
name|version_string
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If the `--help' option was present, show the help and exit. */
if|if
condition|(
name|print_help_p
condition|)
block|{
name|info_short_help
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If the user hasn't specified a path for Info files, default that path      now. */
if|if
condition|(
operator|!
name|infopath
condition|)
block|{
name|char
modifier|*
name|path_from_env
decl_stmt|,
modifier|*
name|getenv
argument_list|()
decl_stmt|;
name|path_from_env
operator|=
name|getenv
argument_list|(
literal|"INFOPATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_from_env
condition|)
name|info_add_path
argument_list|(
name|path_from_env
argument_list|)
expr_stmt|;
else|else
name|info_add_path
argument_list|(
name|DEFAULT_INFOPATH
argument_list|)
expr_stmt|;
block|}
comment|/* If the user specified a particular filename, add the path of that      file to the contents of INFOPATH. */
if|if
condition|(
name|user_filename
condition|)
block|{
name|char
modifier|*
name|directory_name
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|directory_name
operator|=
name|savestring
argument_list|(
name|user_filename
argument_list|)
expr_stmt|;
name|temp
operator|=
name|filename_non_directory
argument_list|(
name|directory_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|directory_name
condition|)
block|{
operator|*
name|temp
operator|=
literal|0
expr_stmt|;
name|info_add_path
argument_list|(
name|directory_name
argument_list|,
name|INFOPATH_PREPEND
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|directory_name
argument_list|)
expr_stmt|;
block|}
comment|/* If the user wants to search every known index for a given string,      do that now, and report the results. */
if|if
condition|(
name|apropos_p
condition|)
block|{
name|info_apropos
argument_list|(
name|apropos_search_string
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Get the initial Info node.  It is either "(dir)Top", or what the user      specifed with values in user_filename and user_nodenames. */
if|if
condition|(
name|user_nodenames
condition|)
name|initial_node
operator|=
name|info_get_node
argument_list|(
name|user_filename
argument_list|,
name|user_nodenames
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|initial_node
operator|=
name|info_get_node
argument_list|(
name|user_filename
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* If we couldn't get the initial node, this user is in trouble. */
if|if
condition|(
operator|!
name|initial_node
condition|)
block|{
if|if
condition|(
name|info_recent_file_error
condition|)
name|info_error
argument_list|(
name|info_recent_file_error
argument_list|)
expr_stmt|;
else|else
name|info_error
argument_list|(
name|CANT_FIND_NODE
argument_list|,
name|user_nodenames
condition|?
name|user_nodenames
index|[
literal|0
index|]
else|:
literal|"Top"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Special cases for when the user specifies multiple nodes.  If we are      dumping to an output file, dump all of the nodes specified.  Otherwise,      attempt to create enough windows to handle the nodes that this user wants      displayed. */
if|if
condition|(
name|user_nodenames_index
operator|>
literal|1
condition|)
block|{
name|free
argument_list|(
name|initial_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|user_output_filename
condition|)
name|dump_nodes_to_file
argument_list|(
name|user_filename
argument_list|,
name|user_nodenames
argument_list|,
name|user_output_filename
argument_list|,
name|dump_subnodes
argument_list|)
expr_stmt|;
else|else
name|begin_multiple_window_info_session
argument_list|(
name|user_filename
argument_list|,
name|user_nodenames
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If there are arguments remaining, they are the names of menu items      in sequential info files starting from the first one loaded.  That      file name is either "dir", or the contents of user_filename if one      was specified. */
while|while
condition|(
name|optind
operator|!=
name|argc
condition|)
block|{
name|REFERENCE
modifier|*
modifier|*
name|menu
decl_stmt|;
name|REFERENCE
modifier|*
name|entry
decl_stmt|;
name|NODE
modifier|*
name|node
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
comment|/* Remember the name of the menu entry we want. */
name|arg
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
comment|/* Build and return a list of the menu items in this node. */
name|menu
operator|=
name|info_menu_of_node
argument_list|(
name|initial_node
argument_list|)
expr_stmt|;
comment|/* If there wasn't a menu item in this node, stop here, but let 	 the user continue to use Info.  Perhaps they wanted this node 	 and didn't realize it. */
if|if
condition|(
operator|!
name|menu
condition|)
block|{
name|begin_info_session_with_error
argument_list|(
name|initial_node
argument_list|,
literal|"There is no menu in this node."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Find the specified menu item. */
name|entry
operator|=
name|info_get_labeled_reference
argument_list|(
name|arg
argument_list|,
name|menu
argument_list|)
expr_stmt|;
comment|/* If the item wasn't found, search the list sloppily.  Perhaps this 	 user typed "buffer" when they really meant "Buffers". */
if|if
condition|(
operator|!
name|entry
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|entry
operator|=
name|menu
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strnicmp
argument_list|(
name|entry
operator|->
name|label
argument_list|,
name|arg
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* If we failed to find the reference, start Info with the current 	 node anyway.  It is probably a misspelling. */
if|if
condition|(
operator|!
name|entry
condition|)
block|{
name|char
modifier|*
name|error_message
init|=
literal|"There is no menu item \"%s\" in this node."
decl_stmt|;
name|info_free_references
argument_list|(
name|menu
argument_list|)
expr_stmt|;
comment|/* If we were supposed to dump this node, complain. */
if|if
condition|(
name|user_output_filename
condition|)
name|info_error
argument_list|(
name|error_message
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
name|begin_info_session_with_error
argument_list|(
name|initial_node
argument_list|,
name|error_message
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We have found the reference that the user specified.  Clean it 	 up a little bit. */
if|if
condition|(
operator|!
name|entry
operator|->
name|filename
condition|)
block|{
if|if
condition|(
name|initial_node
operator|->
name|parent
condition|)
name|entry
operator|->
name|filename
operator|=
name|savestring
argument_list|(
name|initial_node
operator|->
name|parent
argument_list|)
expr_stmt|;
else|else
name|entry
operator|->
name|filename
operator|=
name|savestring
argument_list|(
name|initial_node
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
comment|/* Find this node.  If we can find it, then turn the initial_node 	 into this one.  If we cannot find it, try using the label of the 	 entry as a file (i.e., "(LABEL)Top").  Otherwise the Info file is 	 malformed in some way, and we will just use the current value of 	 initial node. */
name|node
operator|=
name|info_get_node
argument_list|(
name|entry
operator|->
name|filename
argument_list|,
name|entry
operator|->
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
operator|&&
name|entry
operator|->
name|nodename
operator|&&
operator|(
name|strcmp
argument_list|(
name|entry
operator|->
name|label
argument_list|,
name|entry
operator|->
name|nodename
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|node
operator|=
name|info_get_node
argument_list|(
name|entry
operator|->
name|label
argument_list|,
literal|"Top"
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|free
argument_list|(
name|initial_node
argument_list|)
expr_stmt|;
name|initial_node
operator|=
name|node
expr_stmt|;
name|info_free_references
argument_list|(
name|menu
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|temp
init|=
name|savestring
argument_list|(
name|entry
operator|->
name|label
argument_list|)
decl_stmt|;
name|char
modifier|*
name|error_message
decl_stmt|;
name|error_message
operator|=
literal|"Unable to find the node referenced by \"%s\"."
expr_stmt|;
name|info_free_references
argument_list|(
name|menu
argument_list|)
expr_stmt|;
comment|/* If we were trying to dump the node, then give up.  Otherwise, 	     start the session with an error message. */
if|if
condition|(
name|user_output_filename
condition|)
name|info_error
argument_list|(
name|error_message
argument_list|,
name|temp
argument_list|)
expr_stmt|;
else|else
name|begin_info_session_with_error
argument_list|(
name|initial_node
argument_list|,
name|error_message
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the user specified that this node should be output, then do that      now.  Otherwise, start the Info session with this node. */
if|if
condition|(
name|user_output_filename
condition|)
name|dump_node_to_file
argument_list|(
name|initial_node
argument_list|,
name|user_output_filename
argument_list|,
name|dump_subnodes
argument_list|)
expr_stmt|;
else|else
name|begin_info_session
argument_list|(
name|initial_node
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a string describing the current version of Info. */
end_comment

begin_function
name|char
modifier|*
name|version_string
parameter_list|()
block|{
specifier|static
name|char
modifier|*
name|vstring
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|vstring
condition|)
block|{
name|vstring
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|vstring
argument_list|,
literal|"%d.%d"
argument_list|,
name|info_major_version
argument_list|,
name|info_minor_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_patch_level
condition|)
name|sprintf
argument_list|(
name|vstring
operator|+
name|strlen
argument_list|(
name|vstring
argument_list|)
argument_list|,
literal|"-p%d"
argument_list|,
name|info_patch_level
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|vstring
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		   Error Handling for Info			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|program_name
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|remember_info_program_name
parameter_list|(
name|fullpath
parameter_list|)
name|char
modifier|*
name|fullpath
decl_stmt|;
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|filename
operator|=
name|filename_non_directory
argument_list|(
name|fullpath
argument_list|)
expr_stmt|;
name|program_name
operator|=
name|savestring
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Non-zero if an error has been signalled. */
end_comment

begin_decl_stmt
name|int
name|info_error_was_printed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means ring terminal bell on errors. */
end_comment

begin_decl_stmt
name|int
name|info_error_rings_bell_p
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print FORMAT with ARG1 and ARG2.  If the window system was initialized,    then the message is printed in the echo area.  Otherwise, a message is    output to stderr. */
end_comment

begin_function
name|void
name|info_error
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
name|void
modifier|*
name|arg1
decl_stmt|,
decl|*
name|arg2
decl_stmt|;
end_function

begin_block
block|{
name|info_error_was_printed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|info_windows_initialized_p
operator|||
name|display_inhibited
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|echo_area_is_active
condition|)
block|{
if|if
condition|(
name|info_error_rings_bell_p
condition|)
name|terminal_ring_bell
argument_list|()
expr_stmt|;
name|window_message_in_echo_area
argument_list|(
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NODE
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|build_message_node
argument_list|(
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_error_rings_bell_p
condition|)
name|terminal_ring_bell
argument_list|()
expr_stmt|;
name|inform_in_echo_area
argument_list|(
name|temp
operator|->
name|contents
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|contents
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Produce a very brief descripton of the available options and exit with    an error. */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n%s\n%s\n%s\n%s\n"
argument_list|,
literal|"Usage: info [-d dir-path] [-f info-file] [-o output-file] [-n node-name]..."
argument_list|,
literal|"            [--directory dir-path] [--file info-file] [--node node-name]..."
argument_list|,
literal|"            [--help] [--output output-file] [--subnodes] [--version]"
argument_list|,
literal|"            [--dribble dribble-file] [--restore from-file]"
argument_list|,
literal|"            [menu-selection ...]"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Produce a scaled down description of the available options to Info. */
end_comment

begin_function
specifier|static
name|void
name|info_short_help
parameter_list|()
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
literal|"\ Here is a quick description of Info's options.  For a more complete\n\ description of how to use Info, type `info info options'.\n\ \n\    --directory DIR		Add DIR to INFOPATH.\n\    --file FILENAME		Specify Info file to visit.\n\    --node NODENAME		Specify nodes in first visited Info file.\n\    --output FILENAME		Output selected nodes to FILENAME.\n\    --dribble FILENAME		Remember user keystrokes in FILENAME.\n\    --restore FILENAME		Read initial keystrokes from FILENAME.\n\    --subnodes			Recursively output menu items.\n\    --help			Get this help message.\n\    --version			Display Info's version information.\n\ \n\ Remaining arguments to Info are treated as the names of menu\n\ items in the initial node visited.  You can easily move to the\n\ node of your choice by specifying the menu names which describe\n\ the path to that node.  For example, `info emacs buffers'.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

