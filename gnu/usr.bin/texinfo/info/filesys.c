begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* filesys.c -- File system specific functions for hacking this system. */
end_comment

begin_comment
comment|/* This file is part of GNU Info, a program for reading online documentation    stored in Info format.     Copyright (C) 1993 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     Written by Brian Fox (bfox@ai.mit.edu). */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|"general.h"
end_include

begin_include
include|#
directive|include
file|"tilde.h"
end_include

begin_include
include|#
directive|include
file|"filesys.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|O_RDONLY
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_FCNTL_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !HAVE_SYS_FCNTL_H */
end_comment

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_SYS_FCNTL_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !O_RDONLY */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|errno
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !errno */
end_comment

begin_comment
comment|/* Found in info-utils.c. */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|filename_non_directory
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BUILDING_LIBRARY
argument_list|)
end_if

begin_comment
comment|/* Found in session.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|info_windows_initialized_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Found in window.c. */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|message_in_echo_area
argument_list|()
decl_stmt|,
name|unmessage_in_echo_area
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !BUILDING_LIBRARY */
end_comment

begin_comment
comment|/* Local to this file. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|info_file_in_path
argument_list|()
decl_stmt|,
modifier|*
name|lookup_info_filename
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remember_info_filename
argument_list|()
decl_stmt|,
name|maybe_initialize_infopath
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NULL
argument_list|)
end_if

begin_define
define|#
directive|define
name|NULL
value|0x0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !NULL */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|suffix
decl_stmt|;
name|char
modifier|*
name|decompressor
decl_stmt|;
block|}
name|COMPRESSION_ALIST
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|info_suffixes
index|[]
init|=
block|{
literal|""
block|,
literal|".info"
block|,
literal|"-info"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|COMPRESSION_ALIST
name|compress_suffixes
index|[]
init|=
block|{
block|{
literal|".Z"
block|,
literal|"uncompress"
block|}
block|,
block|{
literal|".Y"
block|,
literal|"unyabba"
block|}
block|,
block|{
literal|".z"
block|,
literal|"gunzip"
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The path on which we look for info files.  You can initialize this    from the environment variable INFOPATH if there is one, or you can    call info_add_path () to add paths to the beginning or end of it.    You can call zap_infopath () to make the path go away. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|infopath
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|infopath_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expand the filename in PARTIAL to make a real name for this operating    system.  This looks in INFO_PATHS in order to find the correct file.    If it can't find the file, it returns NULL. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|local_temp_filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|local_temp_filename_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|info_find_fullpath
parameter_list|(
name|partial
parameter_list|)
name|char
modifier|*
name|partial
decl_stmt|;
block|{
name|int
name|initial_character
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|filesys_error_number
operator|=
literal|0
expr_stmt|;
name|maybe_initialize_infopath
argument_list|()
expr_stmt|;
if|if
condition|(
name|partial
operator|&&
operator|(
name|initial_character
operator|=
operator|*
name|partial
operator|)
condition|)
block|{
name|char
modifier|*
name|expansion
decl_stmt|;
name|expansion
operator|=
name|lookup_info_filename
argument_list|(
name|partial
argument_list|)
expr_stmt|;
if|if
condition|(
name|expansion
condition|)
return|return
operator|(
name|expansion
operator|)
return|;
comment|/* If we have the full path to this file, we still may have to add 	 various extensions to it.  I guess we have to stat this file 	 after all. */
if|if
condition|(
name|initial_character
operator|==
literal|'/'
condition|)
name|temp
operator|=
name|info_file_in_path
argument_list|(
name|partial
operator|+
literal|1
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|initial_character
operator|==
literal|'~'
condition|)
block|{
name|expansion
operator|=
name|tilde_expand_word
argument_list|(
name|partial
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|expansion
operator|==
literal|'/'
condition|)
block|{
name|temp
operator|=
name|info_file_in_path
argument_list|(
name|expansion
operator|+
literal|1
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|expansion
argument_list|)
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|expansion
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|initial_character
operator|==
literal|'.'
operator|&&
operator|(
name|partial
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
operator|(
name|partial
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|partial
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|local_temp_filename_size
operator|<
literal|1024
condition|)
name|local_temp_filename
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|local_temp_filename
argument_list|,
operator|(
name|local_temp_filename_size
operator|=
literal|1024
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETCWD
argument_list|)
if|if
condition|(
operator|!
name|getcwd
argument_list|(
name|local_temp_filename
argument_list|,
name|local_temp_filename_size
argument_list|)
condition|)
else|#
directive|else
comment|/*  !HAVE_GETCWD */
if|if
condition|(
operator|!
name|getwd
argument_list|(
name|local_temp_filename
argument_list|)
condition|)
endif|#
directive|endif
comment|/* !HAVE_GETCWD */
block|{
name|filesys_error_number
operator|=
name|errno
expr_stmt|;
return|return
operator|(
name|partial
operator|)
return|;
block|}
name|strcat
argument_list|(
name|local_temp_filename
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|local_temp_filename
argument_list|,
name|partial
argument_list|)
expr_stmt|;
return|return
operator|(
name|local_temp_filename
operator|)
return|;
block|}
else|else
name|temp
operator|=
name|info_file_in_path
argument_list|(
name|partial
argument_list|,
name|infopath
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|remember_info_filename
argument_list|(
name|partial
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|temp
argument_list|)
operator|>
name|local_temp_filename_size
condition|)
name|local_temp_filename
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|local_temp_filename
argument_list|,
operator|(
name|local_temp_filename_size
operator|=
operator|(
literal|50
operator|+
name|strlen
argument_list|(
name|temp
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|local_temp_filename
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|local_temp_filename
operator|)
return|;
block|}
block|}
return|return
operator|(
name|partial
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Scan the list of directories in PATH looking for FILENAME.  If we find    one that is a regular file, return it as a new string.  Otherwise, return    a NULL pointer. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|info_file_in_path
parameter_list|(
name|filename
parameter_list|,
name|path
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|,
decl|*
name|path
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|stat
name|finfo
decl_stmt|;
name|char
modifier|*
name|temp_dirname
decl_stmt|;
name|int
name|statable
decl_stmt|,
name|dirname_index
decl_stmt|;
name|dirname_index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|temp_dirname
operator|=
name|extract_colon_unit
argument_list|(
name|path
argument_list|,
operator|&
name|dirname_index
argument_list|)
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|pre_suffix_length
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
comment|/* Expand a leading tilde if one is present. */
if|if
condition|(
operator|*
name|temp_dirname
operator|==
literal|'~'
condition|)
block|{
name|char
modifier|*
name|expanded_dirname
decl_stmt|;
name|expanded_dirname
operator|=
name|tilde_expand_word
argument_list|(
name|temp_dirname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_dirname
argument_list|)
expr_stmt|;
name|temp_dirname
operator|=
name|expanded_dirname
expr_stmt|;
block|}
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|30
operator|+
name|strlen
argument_list|(
name|temp_dirname
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp
argument_list|,
name|temp_dirname
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
index|[
operator|(
name|strlen
argument_list|(
name|temp
argument_list|)
operator|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|strcat
argument_list|(
name|temp
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|pre_suffix_length
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_dirname
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|info_suffixes
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|strcpy
argument_list|(
name|temp
operator|+
name|pre_suffix_length
argument_list|,
name|info_suffixes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|statable
operator|=
operator|(
name|stat
argument_list|(
name|temp
argument_list|,
operator|&
name|finfo
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* If we have found a regular file, then use that.  Else, if we 	     have found a directory, look in that directory for this file. */
if|if
condition|(
name|statable
condition|)
block|{
if|if
condition|(
name|S_ISREG
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
block|{
return|return
operator|(
name|temp
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|char
modifier|*
name|newpath
decl_stmt|,
modifier|*
name|filename_only
decl_stmt|,
modifier|*
name|newtemp
decl_stmt|;
name|newpath
operator|=
name|savestring
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|filename_only
operator|=
name|filename_non_directory
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|newtemp
operator|=
name|info_file_in_path
argument_list|(
name|filename_only
argument_list|,
name|newpath
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|newtemp
condition|)
block|{
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|newtemp
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* Add various compression suffixes to the name to see if 		 the file is present in compressed format. */
specifier|register
name|int
name|j
decl_stmt|,
name|pre_compress_suffix_length
decl_stmt|;
name|pre_compress_suffix_length
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|compress_suffixes
index|[
name|j
index|]
operator|.
name|suffix
condition|;
name|j
operator|++
control|)
block|{
name|strcpy
argument_list|(
name|temp
operator|+
name|pre_compress_suffix_length
argument_list|,
name|compress_suffixes
index|[
name|j
index|]
operator|.
name|suffix
argument_list|)
expr_stmt|;
name|statable
operator|=
operator|(
name|stat
argument_list|(
name|temp
argument_list|,
operator|&
name|finfo
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|statable
operator|&&
operator|(
name|S_ISREG
argument_list|(
name|finfo
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
return|return
operator|(
name|temp
operator|)
return|;
block|}
block|}
block|}
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Given a string containing units of information separated by colons,    return the next one pointed to by IDX, or NULL if there are no more.    Advance IDX to the character after the colon. */
end_comment

begin_function
name|char
modifier|*
name|extract_colon_unit
parameter_list|(
name|string
parameter_list|,
name|idx
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|idx
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|start
decl_stmt|;
name|i
operator|=
name|start
operator|=
operator|*
name|idx
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|>=
name|strlen
argument_list|(
name|string
argument_list|)
operator|)
operator|||
operator|!
name|string
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
while|while
condition|(
name|string
index|[
name|i
index|]
operator|&&
name|string
index|[
name|i
index|]
operator|!=
literal|':'
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|start
condition|)
block|{
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|char
modifier|*
name|value
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
operator|(
name|i
operator|-
name|start
operator|)
argument_list|)
decl_stmt|;
name|strncpy
argument_list|(
name|value
argument_list|,
operator|&
name|string
index|[
name|start
index|]
argument_list|,
operator|(
name|i
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
name|value
index|[
name|i
operator|-
name|start
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|string
index|[
name|i
index|]
condition|)
operator|++
name|i
expr_stmt|;
operator|*
name|idx
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* A structure which associates a filename with its expansion. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|expansion
decl_stmt|;
block|}
name|FILENAME_LIST
typedef|;
end_typedef

begin_comment
comment|/* An array of remembered arguments and results. */
end_comment

begin_decl_stmt
specifier|static
name|FILENAME_LIST
modifier|*
modifier|*
name|names_and_files
init|=
operator|(
name|FILENAME_LIST
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|names_and_files_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|names_and_files_slots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Find the result for having already called info_find_fullpath () with    FILENAME. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|lookup_info_filename
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
if|if
condition|(
name|filename
operator|&&
name|names_and_files
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|names_and_files
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|names_and_files
index|[
name|i
index|]
operator|->
name|filename
argument_list|,
name|filename
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|names_and_files
index|[
name|i
index|]
operator|->
name|expansion
operator|)
return|;
block|}
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|NULL
return|;
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Add a filename and its expansion to our list. */
end_comment

begin_function
specifier|static
name|void
name|remember_info_filename
parameter_list|(
name|filename
parameter_list|,
name|expansion
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|,
decl|*
name|expansion
decl_stmt|;
end_function

begin_block
block|{
name|FILENAME_LIST
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|names_and_files_index
operator|+
literal|2
operator|>
name|names_and_files_slots
condition|)
block|{
name|int
name|alloc_size
decl_stmt|;
name|names_and_files_slots
operator|+=
literal|10
expr_stmt|;
name|alloc_size
operator|=
name|names_and_files_slots
operator|*
sizeof|sizeof
argument_list|(
name|FILENAME_LIST
operator|*
argument_list|)
expr_stmt|;
name|names_and_files
operator|=
operator|(
name|FILENAME_LIST
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|names_and_files
argument_list|,
name|alloc_size
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
operator|(
name|FILENAME_LIST
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FILENAME_LIST
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|filename
operator|=
name|savestring
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|new
operator|->
name|expansion
operator|=
name|expansion
condition|?
name|savestring
argument_list|(
name|expansion
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|names_and_files
index|[
name|names_and_files_index
operator|++
index|]
operator|=
name|new
expr_stmt|;
name|names_and_files
index|[
name|names_and_files_index
index|]
operator|=
operator|(
name|FILENAME_LIST
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|maybe_initialize_infopath
parameter_list|()
block|{
if|if
condition|(
operator|!
name|infopath_size
condition|)
block|{
name|infopath
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|infopath_size
operator|=
operator|(
literal|1
operator|+
name|strlen
argument_list|(
name|DEFAULT_INFOPATH
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|infopath
argument_list|,
name|DEFAULT_INFOPATH
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add PATH to the list of paths found in INFOPATH.  2nd argument says    whether to put PATH at the front or end of INFOPATH. */
end_comment

begin_function
name|void
name|info_add_path
parameter_list|(
name|path
parameter_list|,
name|where
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|where
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|infopath
condition|)
block|{
name|infopath
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|infopath_size
operator|=
literal|200
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|infopath
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
name|strlen
argument_list|(
name|infopath
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
literal|2
operator|>=
name|infopath_size
condition|)
name|infopath
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|infopath
argument_list|,
operator|(
name|infopath_size
operator|+=
operator|(
literal|2
operator|*
name|len
operator|)
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|infopath
condition|)
name|strcpy
argument_list|(
name|infopath
argument_list|,
name|path
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|where
operator|==
name|INFOPATH_APPEND
condition|)
block|{
name|strcat
argument_list|(
name|infopath
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|infopath
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|where
operator|==
name|INFOPATH_PREPEND
condition|)
block|{
name|char
modifier|*
name|temp
init|=
name|savestring
argument_list|(
name|infopath
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|infopath
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|infopath
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|infopath
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Make INFOPATH have absolutely nothing in it. */
end_comment

begin_function
name|void
name|zap_infopath
parameter_list|()
block|{
if|if
condition|(
name|infopath
condition|)
name|free
argument_list|(
name|infopath
argument_list|)
expr_stmt|;
name|infopath
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|infopath_size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the contents of PATHNAME, returning a buffer with the contents of    that file in it, and returning the size of that buffer in FILESIZE.    FINFO is a stat struct which has already been filled in by the caller.    If the file cannot be read, return a NULL pointer. */
end_comment

begin_function
name|char
modifier|*
name|filesys_read_info_file
parameter_list|(
name|pathname
parameter_list|,
name|filesize
parameter_list|,
name|finfo
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
name|long
modifier|*
name|filesize
decl_stmt|;
name|struct
name|stat
modifier|*
name|finfo
decl_stmt|;
block|{
operator|*
name|filesize
operator|=
name|filesys_error_number
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|compressed_filename_p
argument_list|(
name|pathname
argument_list|)
condition|)
return|return
operator|(
name|filesys_read_compressed
argument_list|(
name|pathname
argument_list|,
name|filesize
argument_list|,
name|finfo
argument_list|)
operator|)
return|;
else|else
block|{
name|int
name|descriptor
decl_stmt|;
name|char
modifier|*
name|contents
decl_stmt|;
name|descriptor
operator|=
name|open
argument_list|(
name|pathname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
comment|/* If the file couldn't be opened, give up. */
if|if
condition|(
name|descriptor
operator|<
literal|0
condition|)
block|{
name|filesys_error_number
operator|=
name|errno
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
comment|/* Try to read the contents of this file. */
name|contents
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|finfo
operator|->
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|read
argument_list|(
name|descriptor
argument_list|,
name|contents
argument_list|,
name|finfo
operator|->
name|st_size
argument_list|)
operator|)
operator|!=
name|finfo
operator|->
name|st_size
condition|)
block|{
name|filesys_error_number
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|contents
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|close
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
operator|*
name|filesize
operator|=
name|finfo
operator|->
name|st_size
expr_stmt|;
return|return
operator|(
name|contents
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Typically, pipe buffers are 4k. */
end_comment

begin_define
define|#
directive|define
name|BASIC_PIPE_BUFFER
value|(4 * 1024)
end_define

begin_comment
comment|/* We use some large multiple of that. */
end_comment

begin_define
define|#
directive|define
name|FILESYS_PIPE_BUFFER_SIZE
value|(16 * BASIC_PIPE_BUFFER)
end_define

begin_function
name|char
modifier|*
name|filesys_read_compressed
parameter_list|(
name|pathname
parameter_list|,
name|filesize
parameter_list|,
name|finfo
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
name|long
modifier|*
name|filesize
decl_stmt|;
name|struct
name|stat
modifier|*
name|finfo
decl_stmt|;
block|{
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|command
decl_stmt|,
modifier|*
name|decompressor
decl_stmt|;
name|char
modifier|*
name|contents
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
operator|*
name|filesize
operator|=
name|filesys_error_number
operator|=
literal|0
expr_stmt|;
name|decompressor
operator|=
name|filesys_decompressor_for_file
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|decompressor
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
name|command
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
operator|+
name|strlen
argument_list|(
name|pathname
argument_list|)
operator|+
name|strlen
argument_list|(
name|decompressor
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"%s< %s"
argument_list|,
name|decompressor
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BUILDING_LIBRARY
argument_list|)
if|if
condition|(
name|info_windows_initialized_p
condition|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|5
operator|+
name|strlen
argument_list|(
name|command
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s..."
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|message_in_echo_area
argument_list|(
literal|"%s"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !BUILDING_LIBRARY */
name|stream
operator|=
name|popen
argument_list|(
name|command
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|command
argument_list|)
expr_stmt|;
comment|/* Read chunks from this file until there are none left to read. */
if|if
condition|(
name|stream
condition|)
block|{
name|int
name|offset
decl_stmt|,
name|size
decl_stmt|;
name|char
modifier|*
name|chunk
decl_stmt|;
name|offset
operator|=
name|size
operator|=
literal|0
expr_stmt|;
name|chunk
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|FILESYS_PIPE_BUFFER_SIZE
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|bytes_read
decl_stmt|;
name|bytes_read
operator|=
name|fread
argument_list|(
name|chunk
argument_list|,
literal|1
argument_list|,
name|FILESYS_PIPE_BUFFER_SIZE
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|+
name|offset
operator|>=
name|size
condition|)
name|contents
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|contents
argument_list|,
name|size
operator|+=
operator|(
literal|2
operator|*
name|FILESYS_PIPE_BUFFER_SIZE
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|contents
operator|+
name|offset
argument_list|,
name|chunk
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|!=
name|FILESYS_PIPE_BUFFER_SIZE
condition|)
break|break;
block|}
name|free
argument_list|(
name|chunk
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|contents
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|contents
argument_list|,
name|offset
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|filesize
operator|=
name|offset
expr_stmt|;
block|}
else|else
block|{
name|filesys_error_number
operator|=
name|errno
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BUILDING_LIBARARY
argument_list|)
if|if
condition|(
name|info_windows_initialized_p
condition|)
name|unmessage_in_echo_area
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* !BUILDING_LIBRARY */
return|return
operator|(
name|contents
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if FILENAME belongs to a compressed file. */
end_comment

begin_function
name|int
name|compressed_filename_p
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|decompressor
decl_stmt|;
comment|/* Find the final extension of this filename, and see if it matches one      of our known ones. */
name|decompressor
operator|=
name|filesys_decompressor_for_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|decompressor
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the command string that would be used to decompress FILENAME. */
end_comment

begin_function
name|char
modifier|*
name|filesys_decompressor_for_file
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|extension
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* Find the final extension of FILENAME, and see if it appears in our      list of known compression extensions. */
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|filename
index|[
name|i
index|]
operator|==
literal|'.'
condition|)
block|{
name|extension
operator|=
name|filename
operator|+
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|extension
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|compress_suffixes
index|[
name|i
index|]
operator|.
name|suffix
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|extension
argument_list|,
name|compress_suffixes
index|[
name|i
index|]
operator|.
name|suffix
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|compress_suffixes
index|[
name|i
index|]
operator|.
name|decompressor
operator|)
return|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The number of the most recent file system error. */
end_comment

begin_decl_stmt
name|int
name|filesys_error_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_STRERROR
argument_list|)
end_if

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
specifier|const
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|strerror
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
if|if
condition|(
name|num
operator|>=
name|sys_nerr
condition|)
return|return
operator|(
literal|""
operator|)
return|;
else|else
return|return
operator|(
name|sys_errlist
index|[
name|num
index|]
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_STRERROR */
end_comment

begin_comment
comment|/* A function which returns a pointer to a static buffer containing    an error message for FILENAME and ERROR_NUM. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|errmsg_buf
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|errmsg_buf_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|filesys_error_string
parameter_list|(
name|filename
parameter_list|,
name|error_num
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|error_num
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|error_num
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
name|result
operator|=
name|strerror
argument_list|(
name|error_num
argument_list|)
expr_stmt|;
name|len
operator|=
literal|4
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|errmsg_buf_size
condition|)
name|errmsg_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|errmsg_buf
argument_list|,
operator|(
name|errmsg_buf_size
operator|=
literal|2
operator|+
name|len
operator|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errmsg_buf
argument_list|,
literal|"%s: %s"
argument_list|,
name|filename
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|errmsg_buf
operator|)
return|;
block|}
end_function

end_unit

