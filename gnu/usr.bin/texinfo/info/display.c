begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* display.c -- How to display Info windows. */
end_comment

begin_comment
comment|/* This file is part of GNU Info, a program for reading online documentation    stored in Info format.     Copyright (C) 1993 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     Written by Brian Fox (bfox@ai.mit.edu). */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"display.h"
end_include

begin_function_decl
specifier|extern
name|int
name|info_any_buffered_input_p
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Found in session.c. */
end_comment

begin_function_decl
specifier|static
name|void
name|free_display
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|DISPLAY_LINE
modifier|*
modifier|*
name|make_display
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* An array of display lines which tell us what is currently visible on    the display.  */
end_comment

begin_decl_stmt
name|DISPLAY_LINE
modifier|*
modifier|*
name|the_display
init|=
operator|(
name|DISPLAY_LINE
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means do no output. */
end_comment

begin_decl_stmt
name|int
name|display_inhibited
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize THE_DISPLAY to WIDTH and HEIGHT, with nothing in it. */
end_comment

begin_function
name|void
name|display_initialize_display
parameter_list|(
name|width
parameter_list|,
name|height
parameter_list|)
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
block|{
name|free_display
argument_list|(
name|the_display
argument_list|)
expr_stmt|;
name|the_display
operator|=
name|make_display
argument_list|(
name|width
argument_list|,
name|height
argument_list|)
expr_stmt|;
name|display_clear_display
argument_list|(
name|the_display
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear all of the lines in DISPLAY making the screen blank. */
end_comment

begin_function
name|void
name|display_clear_display
parameter_list|(
name|display
parameter_list|)
name|DISPLAY_LINE
modifier|*
modifier|*
name|display
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|DISPLAY_LINE
modifier|*
name|display_line
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|display_line
operator|=
name|display
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|display
index|[
name|i
index|]
operator|->
name|text
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|display
index|[
name|i
index|]
operator|->
name|textlen
operator|=
literal|0
expr_stmt|;
name|display
index|[
name|i
index|]
operator|->
name|inverse
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Non-zero if we didn't completely redisplay a window. */
end_comment

begin_decl_stmt
name|int
name|display_was_interrupted_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Update the windows pointed to by WINDOW in the_display.  This actually    writes the text on the screen. */
end_comment

begin_function
name|void
name|display_update_display
parameter_list|(
name|window
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
specifier|register
name|WINDOW
modifier|*
name|win
decl_stmt|;
name|display_was_interrupted_p
operator|=
literal|0
expr_stmt|;
comment|/* For every window in the list, check contents against the display. */
for|for
control|(
name|win
operator|=
name|window
init|;
name|win
condition|;
name|win
operator|=
name|win
operator|->
name|next
control|)
block|{
comment|/* Only re-display visible windows which need updating. */
if|if
condition|(
operator|(
operator|(
name|win
operator|->
name|flags
operator|&
name|W_WindowVisible
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|win
operator|->
name|flags
operator|&
name|W_UpdateWindow
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|win
operator|->
name|height
operator|==
literal|0
operator|)
condition|)
continue|continue;
name|display_update_one_window
argument_list|(
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
name|display_was_interrupted_p
condition|)
break|break;
block|}
comment|/* Always update the echo area. */
name|display_update_one_window
argument_list|(
name|the_echo_area
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Display WIN on the_display.  Unlike display_update_display (), this    function only does one window. */
end_comment

begin_function
name|void
name|display_update_one_window
parameter_list|(
name|win
parameter_list|)
name|WINDOW
modifier|*
name|win
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|nodetext
decl_stmt|;
comment|/* Current character to display. */
specifier|register
name|char
modifier|*
name|last_node_char
decl_stmt|;
comment|/* Position of the last character in node. */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* General use index. */
name|char
modifier|*
name|printed_line
decl_stmt|;
comment|/* Buffer for a printed line. */
name|int
name|pl_index
init|=
literal|0
decl_stmt|;
comment|/* Index into PRINTED_LINE. */
name|int
name|line_index
init|=
literal|0
decl_stmt|;
comment|/* Number of lines done so far. */
name|DISPLAY_LINE
modifier|*
modifier|*
name|display
init|=
name|the_display
decl_stmt|;
comment|/* If display is inhibited, that counts as an interrupted display. */
if|if
condition|(
name|display_inhibited
condition|)
name|display_was_interrupted_p
operator|=
literal|1
expr_stmt|;
comment|/* If the window has no height, or display is inhibited, quit now. */
if|if
condition|(
operator|!
name|win
operator|->
name|height
operator|||
name|display_inhibited
condition|)
return|return;
comment|/* If the window's first row doesn't appear in the_screen, then it      cannot be displayed.  This can happen when the_echo_area is the      window to be displayed, and the screen has shrunk to less than one      line. */
if|if
condition|(
operator|(
name|win
operator|->
name|first_row
operator|<
literal|0
operator|)
operator|||
operator|(
name|win
operator|->
name|first_row
operator|>
name|the_screen
operator|->
name|height
operator|)
condition|)
return|return;
comment|/* Print each line in the window into our local buffer, and then      check the contents of that buffer against the display.  If they      differ, update the display. */
name|printed_line
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|win
operator|->
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|win
operator|->
name|node
operator|||
operator|!
name|win
operator|->
name|line_starts
condition|)
goto|goto
name|done_with_node_display
goto|;
name|nodetext
operator|=
name|win
operator|->
name|line_starts
index|[
name|win
operator|->
name|pagetop
index|]
expr_stmt|;
name|last_node_char
operator|=
name|win
operator|->
name|node
operator|->
name|contents
operator|+
name|win
operator|->
name|node
operator|->
name|nodelen
expr_stmt|;
for|for
control|(
init|;
name|nodetext
operator|<
name|last_node_char
condition|;
name|nodetext
operator|++
control|)
block|{
name|char
modifier|*
name|rep
decl_stmt|,
modifier|*
name|rep_carried_over
decl_stmt|,
name|rep_temp
index|[
literal|2
index|]
decl_stmt|;
name|int
name|replen
decl_stmt|;
if|if
condition|(
name|isprint
argument_list|(
operator|*
name|nodetext
argument_list|)
condition|)
block|{
name|rep_temp
index|[
literal|0
index|]
operator|=
operator|*
name|nodetext
expr_stmt|;
name|replen
operator|=
literal|1
expr_stmt|;
name|rep_temp
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rep
operator|=
name|rep_temp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|nodetext
operator|==
literal|'\r'
operator|||
operator|*
name|nodetext
operator|==
literal|'\n'
condition|)
block|{
name|replen
operator|=
name|win
operator|->
name|width
operator|-
name|pl_index
expr_stmt|;
block|}
else|else
block|{
name|rep
operator|=
name|printed_representation
argument_list|(
operator|*
name|nodetext
argument_list|,
name|pl_index
argument_list|)
expr_stmt|;
name|replen
operator|=
name|strlen
argument_list|(
name|rep
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this character can be printed without passing the width of 	 the line, then stuff it into the line. */
if|if
condition|(
name|replen
operator|+
name|pl_index
operator|<
name|win
operator|->
name|width
condition|)
block|{
comment|/* Optimize if possible. */
if|if
condition|(
name|replen
operator|==
literal|1
condition|)
block|{
name|printed_line
index|[
name|pl_index
operator|++
index|]
operator|=
operator|*
name|rep
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|replen
condition|;
name|i
operator|++
control|)
name|printed_line
index|[
name|pl_index
operator|++
index|]
operator|=
name|rep
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|DISPLAY_LINE
modifier|*
name|entry
decl_stmt|;
comment|/* If this character cannot be printed in this line, we have 	     found the end of this line as it would appear on the screen. 	     Carefully print the end of the line, and then compare. */
if|if
condition|(
operator|*
name|nodetext
operator|==
literal|'\n'
operator|||
operator|*
name|nodetext
operator|==
literal|'\r'
operator|||
operator|*
name|nodetext
operator|==
literal|'\t'
condition|)
block|{
name|printed_line
index|[
name|pl_index
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rep_carried_over
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* The printed representation of this character extends into 		 the next line.  Remember the offset of the last character 		 printed out of REP so that we can carry the character over 		 to the next line. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pl_index
operator|<
operator|(
name|win
operator|->
name|width
operator|-
literal|1
operator|)
condition|;
control|)
name|printed_line
index|[
name|pl_index
operator|++
index|]
operator|=
name|rep
index|[
name|i
operator|++
index|]
expr_stmt|;
name|rep_carried_over
operator|=
name|rep
operator|+
name|i
expr_stmt|;
comment|/* If printing the last character in this window couldn't 		 possibly cause the screen to scroll, place a backslash 		 in the rightmost column. */
if|if
condition|(
literal|1
operator|+
name|line_index
operator|+
name|win
operator|->
name|first_row
operator|<
name|the_screen
operator|->
name|height
condition|)
block|{
if|if
condition|(
name|win
operator|->
name|flags
operator|&
name|W_NoWrap
condition|)
name|printed_line
index|[
name|pl_index
operator|++
index|]
operator|=
literal|'$'
expr_stmt|;
else|else
name|printed_line
index|[
name|pl_index
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
block|}
name|printed_line
index|[
name|pl_index
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* We have the exact line as it should appear on the screen. 	     Check to see if this line matches the one already appearing 	     on the screen. */
name|entry
operator|=
name|display
index|[
name|line_index
operator|+
name|win
operator|->
name|first_row
index|]
expr_stmt|;
comment|/* If the screen line is inversed, then we have to clear 	     the line from the screen first.  Why, I don't know. */
if|if
condition|(
name|entry
operator|->
name|inverse
condition|)
block|{
name|terminal_goto_xy
argument_list|(
literal|0
argument_list|,
name|line_index
operator|+
name|win
operator|->
name|first_row
argument_list|)
expr_stmt|;
name|terminal_clear_to_eol
argument_list|()
expr_stmt|;
name|entry
operator|->
name|inverse
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|text
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|entry
operator|->
name|textlen
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Find the offset where these lines differ. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pl_index
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|printed_line
index|[
name|i
index|]
operator|!=
name|entry
operator|->
name|text
index|[
name|i
index|]
condition|)
break|break;
comment|/* If the lines are not the same length, or if they differed 	     at all, we must do some redrawing. */
if|if
condition|(
operator|(
name|i
operator|!=
name|pl_index
operator|)
operator|||
operator|(
name|pl_index
operator|!=
name|entry
operator|->
name|textlen
operator|)
condition|)
block|{
comment|/* Move to the proper point on the terminal. */
name|terminal_goto_xy
argument_list|(
name|i
argument_list|,
name|line_index
operator|+
name|win
operator|->
name|first_row
argument_list|)
expr_stmt|;
comment|/* If there is any text to print, print it. */
if|if
condition|(
name|i
operator|!=
name|pl_index
condition|)
name|terminal_put_text
argument_list|(
name|printed_line
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* If the printed text didn't extend all the way to the edge 		 of the window, and text was appearing between here and the 		 edge of the window, clear from here to the end of the line. */
if|if
condition|(
operator|(
name|pl_index
operator|<
name|win
operator|->
name|width
operator|&&
name|pl_index
operator|<
name|entry
operator|->
name|textlen
operator|)
operator|||
operator|(
name|entry
operator|->
name|inverse
operator|)
condition|)
name|terminal_clear_to_eol
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Update the display text buffer. */
name|strcpy
argument_list|(
name|entry
operator|->
name|text
operator|+
name|i
argument_list|,
name|printed_line
operator|+
name|i
argument_list|)
expr_stmt|;
name|entry
operator|->
name|textlen
operator|=
name|pl_index
expr_stmt|;
comment|/* Lines showing node text are not in inverse.  Only modelines 		 have that distinction. */
name|entry
operator|->
name|inverse
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We have done at least one line.  Increment our screen line 	     index, and check against the bottom of the window. */
if|if
condition|(
operator|++
name|line_index
operator|==
name|win
operator|->
name|height
condition|)
break|break;
comment|/* A line has been displayed, and the screen reflects that state. 	     If there is typeahead pending, then let that typeahead be read 	     now, instead of continuing with the display. */
if|if
condition|(
name|info_any_buffered_input_p
argument_list|()
condition|)
block|{
name|free
argument_list|(
name|printed_line
argument_list|)
expr_stmt|;
name|display_was_interrupted_p
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* Reset PL_INDEX to the start of the line. */
name|pl_index
operator|=
literal|0
expr_stmt|;
comment|/* If there are characters from REP left to print, stuff them 	     into the buffer now. */
if|if
condition|(
name|rep_carried_over
condition|)
for|for
control|(
init|;
name|rep
index|[
name|pl_index
index|]
condition|;
name|pl_index
operator|++
control|)
name|printed_line
index|[
name|pl_index
index|]
operator|=
name|rep
index|[
name|pl_index
index|]
expr_stmt|;
comment|/* If this window has chosen not to wrap lines, skip to the end 	     of the physical line in the buffer, and start a new line here. */
if|if
condition|(
name|pl_index
operator|&&
operator|(
name|win
operator|->
name|flags
operator|&
name|W_NoWrap
operator|)
condition|)
block|{
name|char
modifier|*
name|begin
decl_stmt|;
name|pl_index
operator|=
literal|0
expr_stmt|;
name|printed_line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|begin
operator|=
name|nodetext
expr_stmt|;
while|while
condition|(
operator|(
name|nodetext
operator|<
name|last_node_char
operator|)
operator|&&
operator|(
operator|*
name|nodetext
operator|!=
literal|'\n'
operator|)
condition|)
name|nodetext
operator|++
expr_stmt|;
block|}
block|}
block|}
name|done_with_node_display
label|:
comment|/* We have reached the end of the node or the end of the window.  If it      is the end of the node, then clear the lines of the window from here      to the end of the window. */
for|for
control|(
init|;
name|line_index
operator|<
name|win
operator|->
name|height
condition|;
name|line_index
operator|++
control|)
block|{
name|DISPLAY_LINE
modifier|*
name|entry
init|=
name|display
index|[
name|line_index
operator|+
name|win
operator|->
name|first_row
index|]
decl_stmt|;
comment|/* If this line has text on it then make it go away. */
if|if
condition|(
name|entry
operator|&&
name|entry
operator|->
name|textlen
condition|)
block|{
name|entry
operator|->
name|textlen
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|text
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|terminal_goto_xy
argument_list|(
literal|0
argument_list|,
name|line_index
operator|+
name|win
operator|->
name|first_row
argument_list|)
expr_stmt|;
name|terminal_clear_to_eol
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Finally, if this window has a modeline it might need to be redisplayed.      Check the window's modeline against the one in the display, and update      if necessary. */
if|if
condition|(
operator|(
name|win
operator|->
name|flags
operator|&
name|W_InhibitMode
operator|)
operator|==
literal|0
condition|)
block|{
name|window_make_modeline
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|line_index
operator|=
name|win
operator|->
name|first_row
operator|+
name|win
operator|->
name|height
expr_stmt|;
comment|/* This display line must both be in inverse, and have the same 	 contents. */
if|if
condition|(
operator|(
operator|!
name|display
index|[
name|line_index
index|]
operator|->
name|inverse
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|display
index|[
name|line_index
index|]
operator|->
name|text
argument_list|,
name|win
operator|->
name|modeline
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|terminal_goto_xy
argument_list|(
literal|0
argument_list|,
name|line_index
argument_list|)
expr_stmt|;
name|terminal_begin_inverse
argument_list|()
expr_stmt|;
name|terminal_put_text
argument_list|(
name|win
operator|->
name|modeline
argument_list|)
expr_stmt|;
name|terminal_end_inverse
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|display
index|[
name|line_index
index|]
operator|->
name|text
argument_list|,
name|win
operator|->
name|modeline
argument_list|)
expr_stmt|;
name|display
index|[
name|line_index
index|]
operator|->
name|inverse
operator|=
literal|1
expr_stmt|;
name|display
index|[
name|line_index
index|]
operator|->
name|textlen
operator|=
name|strlen
argument_list|(
name|win
operator|->
name|modeline
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Okay, this window doesn't need updating anymore. */
name|win
operator|->
name|flags
operator|&=
operator|~
name|W_UpdateWindow
expr_stmt|;
name|free
argument_list|(
name|printed_line
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scroll the region of the_display starting at START, ending at END, and    moving the lines AMOUNT lines.  If AMOUNT is less than zero, the lines    are moved up in the screen, otherwise down.  Actually, it is possible    for no scrolling to take place in the case that the terminal doesn't    support it.  This doesn't matter to us. */
end_comment

begin_function
name|void
name|display_scroll_display
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|,
name|amount
parameter_list|)
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|amount
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|last
decl_stmt|;
name|DISPLAY_LINE
modifier|*
name|temp
decl_stmt|;
comment|/* If this terminal cannot do scrolling, give up now. */
if|if
condition|(
operator|!
name|terminal_can_scroll
condition|)
return|return;
comment|/* If there isn't anything displayed on the screen because it is too      small, quit now. */
if|if
condition|(
operator|!
name|the_display
index|[
literal|0
index|]
condition|)
return|return;
comment|/* If there is typeahead pending, then don't actually do any scrolling. */
if|if
condition|(
name|info_any_buffered_input_p
argument_list|()
condition|)
return|return;
comment|/* Do it on the screen. */
name|terminal_scroll_terminal
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|amount
argument_list|)
expr_stmt|;
comment|/* Now do it in the display buffer so our contents match the screen. */
if|if
condition|(
name|amount
operator|>
literal|0
condition|)
block|{
name|last
operator|=
name|end
operator|+
name|amount
expr_stmt|;
comment|/* Shift the lines to scroll right into place. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|end
operator|-
name|start
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|the_display
index|[
name|last
operator|-
name|i
index|]
expr_stmt|;
name|the_display
index|[
name|last
operator|-
name|i
index|]
operator|=
name|the_display
index|[
name|end
operator|-
name|i
index|]
expr_stmt|;
name|the_display
index|[
name|end
operator|-
name|i
index|]
operator|=
name|temp
expr_stmt|;
block|}
comment|/* The lines have been shifted down in the buffer.  Clear all of the 	 lines that were vacated. */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|!=
operator|(
name|start
operator|+
name|amount
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|the_display
index|[
name|i
index|]
operator|->
name|text
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|the_display
index|[
name|i
index|]
operator|->
name|textlen
operator|=
literal|0
expr_stmt|;
name|the_display
index|[
name|i
index|]
operator|->
name|inverse
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|amount
operator|<
literal|0
condition|)
block|{
name|last
operator|=
name|start
operator|+
name|amount
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|end
operator|-
name|start
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|the_display
index|[
name|last
operator|+
name|i
index|]
expr_stmt|;
name|the_display
index|[
name|last
operator|+
name|i
index|]
operator|=
name|the_display
index|[
name|start
operator|+
name|i
index|]
expr_stmt|;
name|the_display
index|[
name|start
operator|+
name|i
index|]
operator|=
name|temp
expr_stmt|;
block|}
comment|/* The lines have been shifted up in the buffer.  Clear all of the 	 lines that are left over. */
for|for
control|(
name|i
operator|=
name|end
operator|+
name|amount
init|;
name|i
operator|!=
name|end
condition|;
name|i
operator|++
control|)
block|{
name|the_display
index|[
name|i
index|]
operator|->
name|text
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|the_display
index|[
name|i
index|]
operator|->
name|textlen
operator|=
literal|0
expr_stmt|;
name|the_display
index|[
name|i
index|]
operator|->
name|inverse
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Try to scroll lines in WINDOW.  OLD_PAGETOP is the pagetop of WINDOW before    having had its line starts recalculated.  OLD_STARTS is the list of line    starts that used to appear in this window.  OLD_COUNT is the number of lines    that appear in the OLD_STARTS array. */
end_comment

begin_function
name|void
name|display_scroll_line_starts
parameter_list|(
name|window
parameter_list|,
name|old_pagetop
parameter_list|,
name|old_starts
parameter_list|,
name|old_count
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|int
name|old_pagetop
decl_stmt|,
name|old_count
decl_stmt|;
name|char
modifier|*
modifier|*
name|old_starts
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|old
decl_stmt|,
name|new
decl_stmt|;
comment|/* Indices into the line starts arrays. */
name|int
name|last_new
decl_stmt|,
name|last_old
decl_stmt|;
comment|/* Index of the last visible line. */
name|int
name|old_first
decl_stmt|,
name|new_first
decl_stmt|;
comment|/* Index of the first changed line. */
name|int
name|unchanged_at_top
init|=
literal|0
decl_stmt|;
name|int
name|already_scrolled
init|=
literal|0
decl_stmt|;
comment|/* Locate the first line which was displayed on the old window. */
name|old_first
operator|=
name|old_pagetop
expr_stmt|;
name|new_first
operator|=
name|window
operator|->
name|pagetop
expr_stmt|;
comment|/* Find the last line currently visible in this window. */
name|last_new
operator|=
name|window
operator|->
name|pagetop
operator|+
operator|(
name|window
operator|->
name|height
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|last_new
operator|>
name|window
operator|->
name|line_count
condition|)
name|last_new
operator|=
name|window
operator|->
name|line_count
operator|-
literal|1
expr_stmt|;
comment|/* Find the last line which used to be currently visible in this window. */
name|last_old
operator|=
name|old_pagetop
operator|+
operator|(
name|window
operator|->
name|height
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|last_old
operator|>
name|old_count
condition|)
name|last_old
operator|=
name|old_count
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|old
operator|=
name|old_first
operator|,
name|new
operator|=
name|new_first
init|;
name|old
operator|<
name|last_old
operator|&&
name|new
operator|<
name|last_new
condition|;
name|old
operator|++
operator|,
name|new
operator|++
control|)
if|if
condition|(
name|old_starts
index|[
name|old
index|]
operator|!=
name|window
operator|->
name|line_starts
index|[
name|new
index|]
condition|)
break|break;
else|else
name|unchanged_at_top
operator|++
expr_stmt|;
comment|/* Loop through the old lines looking for a match in the new lines. */
for|for
control|(
name|old
operator|=
name|old_first
operator|+
name|unchanged_at_top
init|;
name|old
operator|<
name|last_old
condition|;
name|old
operator|++
control|)
block|{
for|for
control|(
name|new
operator|=
name|new_first
init|;
name|new
operator|<
name|last_new
condition|;
name|new
operator|++
control|)
if|if
condition|(
name|old_starts
index|[
name|old
index|]
operator|==
name|window
operator|->
name|line_starts
index|[
name|new
index|]
condition|)
block|{
comment|/* Find the extent of the matching lines. */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|old
operator|+
name|i
operator|)
operator|<
name|last_old
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|old_starts
index|[
name|old
operator|+
name|i
index|]
operator|!=
name|window
operator|->
name|line_starts
index|[
name|new
operator|+
name|i
index|]
condition|)
break|break;
comment|/* Scroll these lines if there are enough of them. */
block|{
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|amount
decl_stmt|;
name|start
operator|=
operator|(
name|window
operator|->
name|first_row
operator|+
operator|(
operator|(
name|old
operator|+
name|already_scrolled
operator|)
operator|-
name|old_pagetop
operator|)
operator|)
expr_stmt|;
name|amount
operator|=
name|new
operator|-
operator|(
name|old
operator|+
name|already_scrolled
operator|)
expr_stmt|;
name|end
operator|=
name|window
operator|->
name|first_row
operator|+
name|window
operator|->
name|height
expr_stmt|;
comment|/* If we are shifting the block of lines down, then the last 		 AMOUNT lines will become invisible.  Thus, don't bother 		 scrolling them. */
if|if
condition|(
name|amount
operator|>
literal|0
condition|)
name|end
operator|-=
name|amount
expr_stmt|;
if|if
condition|(
operator|(
name|end
operator|-
name|start
operator|)
operator|>
literal|0
condition|)
block|{
name|display_scroll_display
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|amount
argument_list|)
expr_stmt|;
comment|/* Some lines have been scrolled.  Simulate the scrolling 		     by offsetting the value of the old index. */
name|old
operator|+=
name|i
expr_stmt|;
name|already_scrolled
operator|+=
name|amount
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Move the screen cursor to directly over the current character in WINDOW. */
end_comment

begin_function
name|void
name|display_cursor_at_point
parameter_list|(
name|window
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
name|int
name|vpos
decl_stmt|,
name|hpos
decl_stmt|;
name|vpos
operator|=
name|window_line_of_point
argument_list|(
name|window
argument_list|)
operator|-
name|window
operator|->
name|pagetop
operator|+
name|window
operator|->
name|first_row
expr_stmt|;
name|hpos
operator|=
name|window_get_cursor_column
argument_list|(
name|window
argument_list|)
expr_stmt|;
name|terminal_goto_xy
argument_list|(
name|hpos
argument_list|,
name|vpos
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		     Functions Static to this File		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Make a DISPLAY_LINE ** with width and height. */
end_comment

begin_function
specifier|static
name|DISPLAY_LINE
modifier|*
modifier|*
name|make_display
parameter_list|(
name|width
parameter_list|,
name|height
parameter_list|)
name|int
name|width
decl_stmt|,
name|height
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|DISPLAY_LINE
modifier|*
modifier|*
name|display
decl_stmt|;
name|display
operator|=
operator|(
name|DISPLAY_LINE
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|height
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|DISPLAY_LINE
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|height
condition|;
name|i
operator|++
control|)
block|{
name|display
index|[
name|i
index|]
operator|=
operator|(
name|DISPLAY_LINE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DISPLAY_LINE
argument_list|)
argument_list|)
expr_stmt|;
name|display
index|[
name|i
index|]
operator|->
name|text
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|width
argument_list|)
expr_stmt|;
name|display
index|[
name|i
index|]
operator|->
name|textlen
operator|=
literal|0
expr_stmt|;
name|display
index|[
name|i
index|]
operator|->
name|inverse
operator|=
literal|0
expr_stmt|;
block|}
name|display
index|[
name|i
index|]
operator|=
operator|(
name|DISPLAY_LINE
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|display
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free the storage allocated to DISPLAY. */
end_comment

begin_function
specifier|static
name|void
name|free_display
parameter_list|(
name|display
parameter_list|)
name|DISPLAY_LINE
modifier|*
modifier|*
name|display
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|DISPLAY_LINE
modifier|*
name|display_line
decl_stmt|;
if|if
condition|(
operator|!
name|display
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|display_line
operator|=
name|display
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|display_line
operator|->
name|text
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|display_line
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|display
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

