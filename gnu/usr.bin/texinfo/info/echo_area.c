begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* echo_area.c -- How to read a line in the echo area. */
end_comment

begin_comment
comment|/* This file is part of GNU Info, a program for reading online documentation    stored in Info format.     Copyright (C) 1993 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     Written by Brian Fox (bfox@ai.mit.edu). */
end_comment

begin_include
include|#
directive|include
file|"info.h"
end_include

begin_comment
comment|/* Non-zero means that C-g was used to quit reading input. */
end_comment

begin_decl_stmt
name|int
name|info_aborted_echo_area
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that the echo area is being used to read input. */
end_comment

begin_decl_stmt
name|int
name|echo_area_is_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The address of the last command executed in the echo area. */
end_comment

begin_decl_stmt
name|VFunction
modifier|*
name|ea_last_executed_command
init|=
operator|(
name|VFunction
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that the last command executed while reading input    killed some text. */
end_comment

begin_decl_stmt
name|int
name|echo_area_last_command_was_kill
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables which hold on to the current state of the input line. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|input_line
index|[
literal|1
operator|+
name|EA_MAX_INPUT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|input_line_prompt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|input_line_point
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|input_line_beg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|input_line_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NODE
name|input_line_node
init|=
block|{
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
name|input_line
block|,
name|EA_MAX_INPUT
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|echo_area_initialize_node
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|push_echo_area
argument_list|()
decl_stmt|,
name|pop_echo_area
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|echo_area_stack_depth
argument_list|()
decl_stmt|,
name|echo_area_stack_contains_completions_p
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ea_kill_text
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Non-zero means we force the user to complete. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|echo_area_must_complete_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|completions_window_p
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* If non-null, this is a window which was specifically created to display    possible completions output.  We remember it so we can delete it when    appropriate. */
end_comment

begin_decl_stmt
specifier|static
name|WINDOW
modifier|*
name|echo_area_completions_window
init|=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables which keep track of the window which was active prior to    entering the echo area. */
end_comment

begin_decl_stmt
specifier|static
name|WINDOW
modifier|*
name|calling_window
init|=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NODE
modifier|*
name|calling_window_node
init|=
operator|(
name|NODE
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|calling_window_point
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|calling_window_pagetop
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remember the node and pertinent variables of the calling window. */
end_comment

begin_function
specifier|static
name|void
name|remember_calling_window
parameter_list|(
name|window
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
comment|/* Only do this if the calling window is not the completions window, or,      if it is the completions window and there is no other window. */
if|if
condition|(
operator|!
name|completions_window_p
argument_list|(
name|window
argument_list|)
operator|||
operator|(
operator|(
name|window
operator|==
name|windows
operator|)
operator|&&
operator|!
operator|(
name|window
operator|->
name|next
operator|)
operator|)
condition|)
block|{
name|calling_window
operator|=
name|window
expr_stmt|;
name|calling_window_node
operator|=
name|window
operator|->
name|node
expr_stmt|;
name|calling_window_point
operator|=
name|window
operator|->
name|point
expr_stmt|;
name|calling_window_pagetop
operator|=
name|window
operator|->
name|pagetop
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Restore the caller's window so that it shows the node that it was showing    on entry to info_read_xxx_echo_area (). */
end_comment

begin_function
specifier|static
name|void
name|restore_calling_window
parameter_list|()
block|{
specifier|register
name|WINDOW
modifier|*
name|win
decl_stmt|,
modifier|*
name|compwin
init|=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* If the calling window is still visible, and it is the window that      we used for completions output, then restore the calling window. */
for|for
control|(
name|win
operator|=
name|windows
init|;
name|win
condition|;
name|win
operator|=
name|win
operator|->
name|next
control|)
block|{
if|if
condition|(
name|completions_window_p
argument_list|(
name|win
argument_list|)
condition|)
name|compwin
operator|=
name|win
expr_stmt|;
if|if
condition|(
name|win
operator|==
name|calling_window
operator|&&
name|win
operator|==
name|compwin
condition|)
block|{
name|window_set_node_of_window
argument_list|(
name|calling_window
argument_list|,
name|calling_window_node
argument_list|)
expr_stmt|;
name|calling_window
operator|->
name|point
operator|=
name|calling_window_point
expr_stmt|;
name|calling_window
operator|->
name|pagetop
operator|=
name|calling_window_pagetop
expr_stmt|;
name|compwin
operator|=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
expr_stmt|;
break|break;
block|}
block|}
comment|/* Delete the completions window if it is still present, it isn't the      last window on the screen, and there aren't any prior echo area reads      pending which created a completions window. */
if|if
condition|(
name|compwin
condition|)
block|{
if|if
condition|(
operator|(
name|compwin
operator|!=
name|windows
operator|||
name|windows
operator|->
name|next
operator|)
operator|&&
operator|!
name|echo_area_stack_contains_completions_p
argument_list|()
condition|)
block|{
name|WINDOW
modifier|*
name|next
decl_stmt|;
name|int
name|pagetop
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|,
name|amount
decl_stmt|;
name|next
operator|=
name|compwin
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
block|{
name|start
operator|=
name|next
operator|->
name|first_row
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|next
operator|->
name|height
expr_stmt|;
name|amount
operator|=
operator|-
operator|(
name|compwin
operator|->
name|height
operator|+
literal|1
operator|)
expr_stmt|;
name|pagetop
operator|=
name|next
operator|->
name|pagetop
expr_stmt|;
block|}
name|info_delete_window_internal
argument_list|(
name|compwin
argument_list|)
expr_stmt|;
comment|/* This is not necessary because info_delete_window_internal () 	     calls echo_area_inform_of_deleted_window (), which does the 	     right thing. */
if|#
directive|if
name|defined
argument_list|(
name|UNNECESSARY
argument_list|)
name|echo_area_completions_window
operator|=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* UNNECESSARY */
if|if
condition|(
name|next
condition|)
block|{
name|display_scroll_display
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|amount
argument_list|)
expr_stmt|;
name|next
operator|->
name|pagetop
operator|=
name|pagetop
expr_stmt|;
name|display_update_display
argument_list|(
name|windows
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Set up a new input line with PROMPT. */
end_comment

begin_function
specifier|static
name|void
name|initialize_input_line
parameter_list|(
name|prompt
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
block|{
name|input_line_prompt
operator|=
name|prompt
expr_stmt|;
if|if
condition|(
name|prompt
condition|)
name|strcpy
argument_list|(
name|input_line
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
else|else
name|input_line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|input_line_beg
operator|=
name|input_line_end
operator|=
name|input_line_point
operator|=
name|strlen
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|echo_area_after_read
parameter_list|()
block|{
name|char
modifier|*
name|return_value
decl_stmt|;
if|if
condition|(
name|info_aborted_echo_area
condition|)
block|{
name|info_aborted_echo_area
operator|=
literal|0
expr_stmt|;
name|return_value
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|input_line_beg
operator|==
name|input_line_end
condition|)
name|return_value
operator|=
name|savestring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|line_len
init|=
name|input_line_end
operator|-
name|input_line_beg
decl_stmt|;
name|return_value
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|line_len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|return_value
argument_list|,
operator|&
name|input_line
index|[
name|input_line_beg
index|]
argument_list|,
name|line_len
argument_list|)
expr_stmt|;
name|return_value
index|[
name|line_len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
return|return
operator|(
name|return_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read a line of text in the echo area.  Return a malloc ()'ed string,    or NULL if the user aborted out of this read.  WINDOW is the currently    active window, so that we can restore it when we need to.  PROMPT, if    non-null, is a prompt to print before reading the line. */
end_comment

begin_function
name|char
modifier|*
name|info_read_in_echo_area
parameter_list|(
name|window
parameter_list|,
name|prompt
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|char
modifier|*
name|prompt
decl_stmt|;
block|{
name|char
modifier|*
name|line
decl_stmt|;
comment|/* If the echo area is already active, remember the current state. */
if|if
condition|(
name|echo_area_is_active
condition|)
name|push_echo_area
argument_list|()
expr_stmt|;
comment|/* Initialize our local variables. */
name|initialize_input_line
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
comment|/* Initialize the echo area for the first (but maybe not the last) time. */
name|echo_area_initialize_node
argument_list|()
expr_stmt|;
comment|/* Save away the original node of this window, and the window itself,      so echo area commands can temporarily use this window. */
name|remember_calling_window
argument_list|(
name|window
argument_list|)
expr_stmt|;
comment|/* Let the rest of Info know that the echo area is active. */
name|echo_area_is_active
operator|++
expr_stmt|;
name|active_window
operator|=
name|the_echo_area
expr_stmt|;
comment|/* Read characters in the echo area. */
name|info_read_and_dispatch
argument_list|()
expr_stmt|;
name|echo_area_is_active
operator|--
expr_stmt|;
comment|/* Restore the original active window and show point in it. */
name|active_window
operator|=
name|calling_window
expr_stmt|;
name|restore_calling_window
argument_list|()
expr_stmt|;
name|display_cursor_at_point
argument_list|(
name|active_window
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Get the value of the line. */
name|line
operator|=
name|echo_area_after_read
argument_list|()
expr_stmt|;
comment|/* If there is a previous loop waiting for us, restore it now. */
if|if
condition|(
name|echo_area_is_active
condition|)
name|pop_echo_area
argument_list|()
expr_stmt|;
comment|/* Return the results to the caller. */
return|return
operator|(
name|line
operator|)
return|;
block|}
end_function

begin_comment
comment|/* (re) Initialize the echo area node. */
end_comment

begin_function
specifier|static
name|void
name|echo_area_initialize_node
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|input_line_end
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|input_line
argument_list|)
condition|;
name|i
operator|++
control|)
name|input_line
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
name|input_line
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
name|window_set_node_of_window
argument_list|(
name|the_echo_area
argument_list|,
operator|&
name|input_line_node
argument_list|)
expr_stmt|;
name|input_line
index|[
name|input_line_end
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prepare to read characters in the echo area.  This can initialize the    echo area node, but its primary purpose is to side effect the input    line buffer contents. */
end_comment

begin_function
name|void
name|echo_area_prep_read
parameter_list|()
block|{
if|if
condition|(
name|the_echo_area
operator|->
name|node
operator|!=
operator|&
name|input_line_node
condition|)
name|echo_area_initialize_node
argument_list|()
expr_stmt|;
name|the_echo_area
operator|->
name|point
operator|=
name|input_line_point
expr_stmt|;
name|input_line
index|[
name|input_line_end
index|]
operator|=
literal|'\n'
expr_stmt|;
name|display_update_one_window
argument_list|(
name|the_echo_area
argument_list|)
expr_stmt|;
name|display_cursor_at_point
argument_list|(
name|active_window
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		     Echo Area Movement Commands		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|ea_forward
argument_list|,
literal|"Move forward a character"
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|ea_backward
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
name|input_line_point
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|input_line_point
operator|>
name|input_line_end
condition|)
name|input_line_point
operator|=
name|input_line_end
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|ea_backward
argument_list|,
literal|"Move backward a character"
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|ea_forward
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
name|input_line_point
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|input_line_point
operator|<
name|input_line_beg
condition|)
name|input_line_point
operator|=
name|input_line_beg
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|ea_beg_of_line
argument_list|,
literal|"Move to the start of this line"
argument_list|)
end_macro

begin_block
block|{
name|input_line_point
operator|=
name|input_line_beg
expr_stmt|;
block|}
end_block

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|ea_end_of_line
argument_list|,
literal|"Move to the end of this line"
argument_list|)
end_macro

begin_block
block|{
name|input_line_point
operator|=
name|input_line_end
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|alphabetic
parameter_list|(
name|c
parameter_list|)
value|(islower (c) || isupper (c) || isdigit (c))
end_define

begin_comment
comment|/* Move forward a word in the input line. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|ea_forward_word
argument_list|,
literal|"Move forward a word"
argument_list|)
end_macro

begin_block
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|ea_backward_word
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|count
operator|--
condition|)
block|{
if|if
condition|(
name|input_line_point
operator|==
name|input_line_end
condition|)
return|return;
comment|/* If we are not in a word, move forward until we are in one. 	     Then, move forward until we hit a non-alphabetic character. */
name|c
operator|=
name|input_line
index|[
name|input_line_point
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
block|{
while|while
condition|(
operator|++
name|input_line_point
operator|<
name|input_line_end
condition|)
block|{
name|c
operator|=
name|input_line
index|[
name|input_line_point
index|]
expr_stmt|;
if|if
condition|(
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|input_line_point
operator|==
name|input_line_end
condition|)
return|return;
while|while
condition|(
operator|++
name|input_line_point
operator|<
name|input_line_end
condition|)
block|{
name|c
operator|=
name|input_line
index|[
name|input_line_point
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
block|}
block|}
block|}
end_block

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|ea_backward_word
argument_list|,
literal|"Move backward a word"
argument_list|)
end_macro

begin_block
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|ea_forward_word
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|count
operator|--
condition|)
block|{
if|if
condition|(
name|input_line_point
operator|==
name|input_line_beg
condition|)
return|return;
comment|/* Like ea_forward_word (), except that we look at the 	     characters just before point. */
name|c
operator|=
name|input_line
index|[
name|input_line_point
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
block|{
while|while
condition|(
operator|--
name|input_line_point
condition|)
block|{
name|c
operator|=
name|input_line
index|[
name|input_line_point
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
block|}
while|while
condition|(
name|input_line_point
operator|!=
name|input_line_beg
condition|)
block|{
name|c
operator|=
name|input_line
index|[
name|input_line_point
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|alphabetic
argument_list|(
name|c
argument_list|)
condition|)
break|break;
else|else
operator|--
name|input_line_point
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|ea_delete
argument_list|,
literal|"Delete the character under the cursor"
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|ea_rubout
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|input_line_point
operator|==
name|input_line_end
condition|)
return|return;
if|if
condition|(
name|info_explicit_arg
operator|||
name|count
operator|>
literal|1
condition|)
block|{
name|int
name|orig_point
decl_stmt|;
name|orig_point
operator|=
name|input_line_point
expr_stmt|;
name|ea_forward
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|ea_kill_text
argument_list|(
name|orig_point
argument_list|,
name|input_line_point
argument_list|)
expr_stmt|;
name|input_line_point
operator|=
name|orig_point
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|input_line_point
init|;
name|i
operator|<
name|input_line_end
condition|;
name|i
operator|++
control|)
name|input_line
index|[
name|i
index|]
operator|=
name|input_line
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|input_line_end
operator|--
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|ea_rubout
argument_list|,
literal|"Delete the character behind the cursor"
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|ea_delete
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|start
decl_stmt|;
if|if
condition|(
name|input_line_point
operator|==
name|input_line_beg
condition|)
return|return;
name|start
operator|=
name|input_line_point
expr_stmt|;
name|ea_backward
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_explicit_arg
operator|||
name|count
operator|>
literal|1
condition|)
name|ea_kill_text
argument_list|(
name|start
argument_list|,
name|input_line_point
argument_list|)
expr_stmt|;
else|else
name|ea_delete
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|ea_abort
argument_list|,
literal|"Cancel or quit operation"
argument_list|)
end_macro

begin_block
block|{
comment|/* If any text, just discard it, and restore the calling window's node.      If no text, quit. */
if|if
condition|(
name|input_line_end
operator|!=
name|input_line_beg
condition|)
block|{
name|terminal_ring_bell
argument_list|()
expr_stmt|;
name|input_line_end
operator|=
name|input_line_point
operator|=
name|input_line_beg
expr_stmt|;
if|if
condition|(
name|calling_window
operator|->
name|node
operator|!=
name|calling_window_node
condition|)
name|restore_calling_window
argument_list|()
expr_stmt|;
block|}
else|else
name|info_aborted_echo_area
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|ea_newline
argument_list|,
literal|"Accept (or force completion of) this line"
argument_list|)
end_macro

begin_block
block|{
comment|/* Stub does nothing.  Simply here to see if it has been executed. */
block|}
end_block

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|ea_quoted_insert
argument_list|,
literal|"Insert next character verbatim"
argument_list|)
end_macro

begin_block
block|{
name|unsigned
name|char
name|character
decl_stmt|;
name|character
operator|=
name|info_get_another_input_char
argument_list|()
expr_stmt|;
name|ea_insert
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|character
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|ea_insert
argument_list|,
literal|"Insert this character"
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|input_line_end
operator|+
literal|1
operator|)
operator|==
name|EA_MAX_INPUT
condition|)
block|{
name|terminal_ring_bell
argument_list|()
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
name|input_line_end
operator|+
literal|1
init|;
name|i
operator|!=
name|input_line_point
condition|;
name|i
operator|--
control|)
name|input_line
index|[
name|i
index|]
operator|=
name|input_line
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|input_line
index|[
name|input_line_point
index|]
operator|=
name|key
expr_stmt|;
name|input_line_point
operator|++
expr_stmt|;
name|input_line_end
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|ea_tab_insert
argument_list|,
literal|"Insert a TAB character"
argument_list|)
end_macro

begin_block
block|{
name|ea_insert
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Transpose the characters at point.  If point is at the end of the line,    then transpose the characters before point. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|ea_transpose_chars
argument_list|,
literal|"Transpose characters at point"
argument_list|)
end_macro

begin_block
block|{
comment|/* Handle conditions that would make it impossible to transpose      characters. */
if|if
condition|(
operator|!
name|count
operator|||
operator|!
name|input_line_point
operator|||
operator|(
name|input_line_end
operator|-
name|input_line_beg
operator|)
operator|<
literal|2
condition|)
return|return;
while|while
condition|(
name|count
condition|)
block|{
name|int
name|t
decl_stmt|;
if|if
condition|(
name|input_line_point
operator|==
name|input_line_end
condition|)
block|{
name|t
operator|=
name|input_line
index|[
name|input_line_point
operator|-
literal|1
index|]
expr_stmt|;
name|input_line
index|[
name|input_line_point
operator|-
literal|1
index|]
operator|=
name|input_line
index|[
name|input_line_point
operator|-
literal|2
index|]
expr_stmt|;
name|input_line
index|[
name|input_line_point
operator|-
literal|2
index|]
operator|=
name|t
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|input_line
index|[
name|input_line_point
index|]
expr_stmt|;
name|input_line
index|[
name|input_line_point
index|]
operator|=
name|input_line
index|[
name|input_line_point
operator|-
literal|1
index|]
expr_stmt|;
name|input_line
index|[
name|input_line_point
operator|-
literal|1
index|]
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
operator|&&
name|input_line_point
operator|!=
name|input_line_beg
condition|)
name|input_line_point
operator|--
expr_stmt|;
else|else
name|input_line_point
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|count
operator|++
expr_stmt|;
else|else
name|count
operator|--
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		     Echo Area Killing and Yanking		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|kill_ring
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kill_ring_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of kills appearing in KILL_RING. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|kill_ring_slots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of slots allocated to KILL_RING. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|kill_ring_loc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Location of current yank pointer. */
end_comment

begin_comment
comment|/* The largest number of kills that we remember at one time. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_retained_kills
init|=
literal|15
decl_stmt|;
end_decl_stmt

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|ea_yank
argument_list|,
literal|"Yank back the contents of the last kill"
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|text
decl_stmt|;
if|if
condition|(
operator|!
name|kill_ring_index
condition|)
block|{
name|inform_in_echo_area
argument_list|(
literal|"Kill ring is empty"
argument_list|)
expr_stmt|;
return|return;
block|}
name|text
operator|=
name|kill_ring
index|[
name|kill_ring_loc
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|text
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|ea_insert
argument_list|(
name|window
argument_list|,
literal|1
argument_list|,
name|text
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* If the last command was yank, or yank_pop, and the text just before    point is identical to the current kill item, then delete that text    from the line, rotate the index down, and yank back some other text. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|ea_yank_pop
argument_list|,
literal|"Yank back a previous kill"
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ea_last_executed_command
operator|!=
name|ea_yank
operator|)
operator|&&
operator|(
name|ea_last_executed_command
operator|!=
name|ea_yank_pop
operator|)
operator|)
operator|||
operator|(
name|kill_ring_index
operator|==
literal|0
operator|)
condition|)
return|return;
name|len
operator|=
name|strlen
argument_list|(
name|kill_ring
index|[
name|kill_ring_loc
index|]
argument_list|)
expr_stmt|;
comment|/* Delete the last yanked item from the line. */
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|counter
decl_stmt|;
name|counter
operator|=
name|input_line_end
operator|-
name|input_line_point
expr_stmt|;
for|for
control|(
name|i
operator|=
name|input_line_point
operator|-
name|len
init|;
name|counter
condition|;
name|i
operator|++
operator|,
name|counter
operator|--
control|)
name|input_line
index|[
name|i
index|]
operator|=
name|input_line
index|[
name|i
operator|+
name|len
index|]
expr_stmt|;
name|input_line_end
operator|-=
name|len
expr_stmt|;
name|input_line_point
operator|-=
name|len
expr_stmt|;
block|}
comment|/* Get a previous kill, and yank that. */
name|kill_ring_loc
operator|--
expr_stmt|;
if|if
condition|(
name|kill_ring_loc
operator|<
literal|0
condition|)
name|kill_ring_loc
operator|=
name|kill_ring_index
operator|-
literal|1
expr_stmt|;
name|ea_yank
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Delete the text from point to end of line. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|ea_kill_line
argument_list|,
literal|"Kill to the end of the line"
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|ea_kill_text
argument_list|(
name|input_line_point
argument_list|,
name|input_line_beg
argument_list|)
expr_stmt|;
name|input_line_point
operator|=
name|input_line_beg
expr_stmt|;
block|}
else|else
name|ea_kill_text
argument_list|(
name|input_line_point
argument_list|,
name|input_line_end
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Delete the text from point to beg of line. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|ea_backward_kill_line
argument_list|,
literal|"Kill to the beginning of the line"
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|ea_kill_text
argument_list|(
name|input_line_point
argument_list|,
name|input_line_end
argument_list|)
expr_stmt|;
else|else
block|{
name|ea_kill_text
argument_list|(
name|input_line_point
argument_list|,
name|input_line_beg
argument_list|)
expr_stmt|;
name|input_line_point
operator|=
name|input_line_beg
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Delete from point to the end of the current word. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|ea_kill_word
argument_list|,
literal|"Kill the word following the cursor"
argument_list|)
end_macro

begin_block
block|{
name|int
name|orig_point
init|=
name|input_line_point
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|ea_backward_kill_word
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
name|ea_forward_word
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_line_point
operator|!=
name|orig_point
condition|)
name|ea_kill_text
argument_list|(
name|orig_point
argument_list|,
name|input_line_point
argument_list|)
expr_stmt|;
name|input_line_point
operator|=
name|orig_point
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Delete from point to the start of the current word. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|ea_backward_kill_word
argument_list|,
literal|"Kill the word preceding the cursor"
argument_list|)
end_macro

begin_block
block|{
name|int
name|orig_point
init|=
name|input_line_point
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|ea_kill_word
argument_list|(
name|window
argument_list|,
operator|-
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
name|ea_backward_word
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_line_point
operator|!=
name|orig_point
condition|)
name|ea_kill_text
argument_list|(
name|orig_point
argument_list|,
name|input_line_point
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* The way to kill something.  This appends or prepends to the last    kill, if the last command was a kill command.  If FROM is less    than TO, then the killed text is appended to the most recent kill,    otherwise it is prepended.  If the last command was not a kill command,    then a new slot is made for this kill. */
end_comment

begin_function
specifier|static
name|void
name|ea_kill_text
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|counter
decl_stmt|,
name|distance
decl_stmt|;
name|int
name|killing_backwards
decl_stmt|,
name|slot
decl_stmt|;
name|char
modifier|*
name|killed_text
decl_stmt|;
name|killing_backwards
operator|=
operator|(
name|from
operator|>
name|to
operator|)
expr_stmt|;
comment|/* If killing backwards, reverse the values of FROM and TO. */
if|if
condition|(
name|killing_backwards
condition|)
block|{
name|int
name|temp
init|=
name|from
decl_stmt|;
name|from
operator|=
name|to
expr_stmt|;
name|to
operator|=
name|temp
expr_stmt|;
block|}
comment|/* Remember the text that we are about to delete. */
name|distance
operator|=
name|to
operator|-
name|from
expr_stmt|;
name|killed_text
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|distance
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|killed_text
argument_list|,
operator|&
name|input_line
index|[
name|from
index|]
argument_list|,
name|distance
argument_list|)
expr_stmt|;
name|killed_text
index|[
name|distance
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Actually delete the text from the line. */
name|counter
operator|=
name|input_line_end
operator|-
name|to
expr_stmt|;
for|for
control|(
name|i
operator|=
name|from
init|;
name|counter
condition|;
name|i
operator|++
operator|,
name|counter
operator|--
control|)
name|input_line
index|[
name|i
index|]
operator|=
name|input_line
index|[
name|i
operator|+
name|distance
index|]
expr_stmt|;
name|input_line_end
operator|-=
name|distance
expr_stmt|;
comment|/* If the last command was a kill, append or prepend the killed text to      the last command's killed text. */
if|if
condition|(
name|echo_area_last_command_was_kill
condition|)
block|{
name|char
modifier|*
name|old
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|slot
operator|=
name|kill_ring_loc
expr_stmt|;
name|old
operator|=
name|kill_ring
index|[
name|slot
index|]
expr_stmt|;
name|new
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|old
argument_list|)
operator|+
name|strlen
argument_list|(
name|killed_text
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|killing_backwards
condition|)
block|{
comment|/* Prepend TEXT to current kill. */
name|strcpy
argument_list|(
name|new
argument_list|,
name|killed_text
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|new
argument_list|,
name|old
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Append TEXT to current kill. */
name|strcpy
argument_list|(
name|new
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|new
argument_list|,
name|killed_text
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|killed_text
argument_list|)
expr_stmt|;
name|kill_ring
index|[
name|slot
index|]
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
comment|/* Try to store the kill in a new slot, unless that would cause there 	 to be too many remembered kills. */
name|slot
operator|=
name|kill_ring_index
expr_stmt|;
if|if
condition|(
name|slot
operator|==
name|max_retained_kills
condition|)
name|slot
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|slot
operator|+
literal|1
operator|>
name|kill_ring_slots
condition|)
name|kill_ring
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|kill_ring
argument_list|,
operator|(
name|kill_ring_slots
operator|+=
name|max_retained_kills
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|!=
name|kill_ring_index
condition|)
name|free
argument_list|(
name|kill_ring
index|[
name|slot
index|]
argument_list|)
expr_stmt|;
else|else
name|kill_ring_index
operator|++
expr_stmt|;
name|kill_ring
index|[
name|slot
index|]
operator|=
name|killed_text
expr_stmt|;
name|kill_ring_loc
operator|=
name|slot
expr_stmt|;
block|}
comment|/* Notice that the last command was a kill. */
name|echo_area_last_command_was_kill
operator|++
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Echo Area Completion			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Pointer to an array of REFERENCE to complete over. */
end_comment

begin_decl_stmt
specifier|static
name|REFERENCE
modifier|*
modifier|*
name|echo_area_completion_items
init|=
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sorted array of REFERENCE * which is the possible completions found in    the variable echo_area_completion_items.  If there is only one element,    it is the only possible completion. */
end_comment

begin_decl_stmt
specifier|static
name|REFERENCE
modifier|*
modifier|*
name|completions_found
init|=
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|completions_found_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|completions_found_slots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The lowest common denominator found while completing. */
end_comment

begin_decl_stmt
specifier|static
name|REFERENCE
modifier|*
name|LCD_completion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Internal functions used by the user calls. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|build_completions
argument_list|()
decl_stmt|,
name|completions_must_be_rebuilt
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variable which holds the output of completions. */
end_comment

begin_decl_stmt
specifier|static
name|NODE
modifier|*
name|possible_completions_output_node
init|=
operator|(
name|NODE
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|compwin_name
init|=
literal|"*Completions*"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return non-zero if WINDOW is a window used for completions output. */
end_comment

begin_function
specifier|static
name|int
name|completions_window_p
parameter_list|(
name|window
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|internal_info_node_p
argument_list|(
name|window
operator|->
name|node
argument_list|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|window
operator|->
name|node
operator|->
name|nodename
argument_list|,
name|compwin_name
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|result
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Workhorse for completion readers.  If FORCE is non-zero, the user cannot    exit unless the line read completes, or is empty. */
end_comment

begin_function
name|char
modifier|*
name|info_read_completing_internal
parameter_list|(
name|window
parameter_list|,
name|prompt
parameter_list|,
name|completions
parameter_list|,
name|force
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|char
modifier|*
name|prompt
decl_stmt|;
name|REFERENCE
modifier|*
modifier|*
name|completions
decl_stmt|;
name|int
name|force
decl_stmt|;
block|{
name|char
modifier|*
name|line
decl_stmt|;
comment|/* If the echo area is already active, remember the current state. */
if|if
condition|(
name|echo_area_is_active
condition|)
name|push_echo_area
argument_list|()
expr_stmt|;
name|echo_area_must_complete_p
operator|=
name|force
expr_stmt|;
comment|/* Initialize our local variables. */
name|initialize_input_line
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
comment|/* Initialize the echo area for the first (but maybe not the last) time. */
name|echo_area_initialize_node
argument_list|()
expr_stmt|;
comment|/* Save away the original node of this window, and the window itself,      so echo area commands can temporarily use this window. */
name|remember_calling_window
argument_list|(
name|window
argument_list|)
expr_stmt|;
comment|/* Save away the list of items to complete over. */
name|echo_area_completion_items
operator|=
name|completions
expr_stmt|;
name|completions_must_be_rebuilt
argument_list|()
expr_stmt|;
name|active_window
operator|=
name|the_echo_area
expr_stmt|;
name|echo_area_is_active
operator|++
expr_stmt|;
comment|/* Read characters in the echo area. */
while|while
condition|(
literal|1
condition|)
block|{
name|info_read_and_dispatch
argument_list|()
expr_stmt|;
name|line
operator|=
name|echo_area_after_read
argument_list|()
expr_stmt|;
comment|/* Force the completion to take place if the user hasn't accepted 	 a default or aborted, and if FORCE is active. */
if|if
condition|(
name|force
operator|&&
name|line
operator|&&
operator|*
name|line
operator|&&
name|completions
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|build_completions
argument_list|()
expr_stmt|;
comment|/* If there is only one completion, then make the line be that 	     completion. */
if|if
condition|(
name|completions_found_index
operator|==
literal|1
condition|)
block|{
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|line
operator|=
name|savestring
argument_list|(
name|completions_found
index|[
literal|0
index|]
operator|->
name|label
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If one of the completions matches exactly, then that is okay, so 	     return the current line. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|completions_found_index
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|stricmp
argument_list|(
name|completions_found
index|[
name|i
index|]
operator|->
name|label
argument_list|,
name|line
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|line
operator|=
name|savestring
argument_list|(
name|completions_found
index|[
name|i
index|]
operator|->
name|label
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If no match, go back and try again. */
if|if
condition|(
name|i
operator|==
name|completions_found_index
condition|)
block|{
name|inform_in_echo_area
argument_list|(
literal|"Not complete"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
block|}
name|echo_area_is_active
operator|--
expr_stmt|;
comment|/* Restore the original active window and show point in it. */
name|active_window
operator|=
name|calling_window
expr_stmt|;
name|restore_calling_window
argument_list|()
expr_stmt|;
name|display_cursor_at_point
argument_list|(
name|active_window
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|echo_area_completion_items
operator|=
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|completions_must_be_rebuilt
argument_list|()
expr_stmt|;
comment|/* If there is a previous loop waiting for us, restore it now. */
if|if
condition|(
name|echo_area_is_active
condition|)
name|pop_echo_area
argument_list|()
expr_stmt|;
return|return
operator|(
name|line
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read a line in the echo area with completion over COMPLETIONS. */
end_comment

begin_function
name|char
modifier|*
name|info_read_completing_in_echo_area
parameter_list|(
name|window
parameter_list|,
name|prompt
parameter_list|,
name|completions
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|char
modifier|*
name|prompt
decl_stmt|;
name|REFERENCE
modifier|*
modifier|*
name|completions
decl_stmt|;
block|{
return|return
operator|(
name|info_read_completing_internal
argument_list|(
name|window
argument_list|,
name|prompt
argument_list|,
name|completions
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read a line in the echo area allowing completion over COMPLETIONS, but    not requiring it. */
end_comment

begin_function
name|char
modifier|*
name|info_read_maybe_completing
parameter_list|(
name|window
parameter_list|,
name|prompt
parameter_list|,
name|completions
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
name|char
modifier|*
name|prompt
decl_stmt|;
name|REFERENCE
modifier|*
modifier|*
name|completions
decl_stmt|;
block|{
return|return
operator|(
name|info_read_completing_internal
argument_list|(
name|window
argument_list|,
name|prompt
argument_list|,
name|completions
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|ea_possible_completions
argument_list|,
literal|"List possible completions"
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|echo_area_completion_items
condition|)
block|{
name|ea_insert
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
name|build_completions
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|completions_found_index
condition|)
block|{
name|terminal_ring_bell
argument_list|()
expr_stmt|;
name|inform_in_echo_area
argument_list|(
literal|"No completions"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|completions_found_index
operator|==
literal|1
operator|)
operator|&&
operator|(
name|key
operator|!=
literal|'?'
operator|)
condition|)
block|{
name|inform_in_echo_area
argument_list|(
literal|"Sole completion"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
name|int
name|limit
decl_stmt|,
name|count
decl_stmt|,
name|max_label
init|=
literal|0
decl_stmt|;
name|initialize_message_buffer
argument_list|()
expr_stmt|;
name|printf_to_message_buffer
argument_list|(
literal|"There %s %d "
argument_list|,
name|completions_found_index
operator|==
literal|1
condition|?
literal|"is"
else|:
literal|"are"
argument_list|,
name|completions_found_index
argument_list|)
expr_stmt|;
name|printf_to_message_buffer
argument_list|(
literal|"completion%s:\n"
argument_list|,
name|completions_found_index
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
comment|/* Find the maximum length of a label. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|completions_found_index
condition|;
name|i
operator|++
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|completions_found
index|[
name|i
index|]
operator|->
name|label
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|max_label
condition|)
name|max_label
operator|=
name|len
expr_stmt|;
block|}
name|max_label
operator|+=
literal|4
expr_stmt|;
comment|/* Find out how many columns we should print in. */
name|limit
operator|=
name|calling_window
operator|->
name|width
operator|/
name|max_label
expr_stmt|;
if|if
condition|(
name|limit
operator|!=
literal|1
operator|&&
operator|(
name|limit
operator|*
name|max_label
operator|==
name|calling_window
operator|->
name|width
operator|)
condition|)
name|limit
operator|--
expr_stmt|;
comment|/* Avoid a possible floating exception.  If max_label> width then 	 the limit will be 0 and a divide-by-zero fault will result. */
if|if
condition|(
name|limit
operator|==
literal|0
condition|)
name|limit
operator|=
literal|1
expr_stmt|;
comment|/* How many iterations of the printing loop? */
name|count
operator|=
operator|(
name|completions_found_index
operator|+
operator|(
name|limit
operator|-
literal|1
operator|)
operator|)
operator|/
name|limit
expr_stmt|;
comment|/* Watch out for special case.  If the number of completions is less 	 than LIMIT, then just do the inner printing loop. */
if|if
condition|(
name|completions_found_index
operator|<
name|limit
condition|)
name|count
operator|=
literal|1
expr_stmt|;
comment|/* Print the sorted items, up-and-down alphabetically. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|l
operator|=
name|i
init|;
name|j
operator|<
name|limit
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|l
operator|>=
name|completions_found_index
condition|)
break|break;
else|else
block|{
name|char
modifier|*
name|label
decl_stmt|;
name|int
name|printed_length
decl_stmt|,
name|k
decl_stmt|;
name|label
operator|=
name|completions_found
index|[
name|l
index|]
operator|->
name|label
expr_stmt|;
name|printed_length
operator|=
name|strlen
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|printf_to_message_buffer
argument_list|(
literal|"%s"
argument_list|,
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|+
literal|1
operator|<
name|limit
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|max_label
operator|-
name|printed_length
condition|;
name|k
operator|++
control|)
name|printf_to_message_buffer
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
name|l
operator|+=
name|count
expr_stmt|;
block|}
name|printf_to_message_buffer
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Make a new node to hold onto possible completions.  Don't destroy 	 dangling pointers. */
block|{
name|NODE
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|message_buffer_to_node
argument_list|()
expr_stmt|;
name|add_gcable_pointer
argument_list|(
name|temp
operator|->
name|contents
argument_list|)
expr_stmt|;
name|name_internal_node
argument_list|(
name|temp
argument_list|,
name|compwin_name
argument_list|)
expr_stmt|;
name|possible_completions_output_node
operator|=
name|temp
expr_stmt|;
block|}
comment|/* Find a suitable window for displaying the completions output. 	 First choice is an existing window showing completions output. 	 If there is only one window, and it is large, make another 	 (smaller) window, and use that one.  Otherwise, use the caller's 	 window. */
block|{
name|WINDOW
modifier|*
name|compwin
decl_stmt|;
name|compwin
operator|=
name|get_internal_info_window
argument_list|(
name|compwin_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|compwin
condition|)
block|{
comment|/* If we can split the window to display most of the completion 	       items, then do so. */
if|if
condition|(
name|calling_window
operator|->
name|height
operator|>
operator|(
name|count
operator|*
literal|2
operator|)
condition|)
block|{
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|pagetop
decl_stmt|;
name|active_window
operator|=
name|calling_window
expr_stmt|;
comment|/* Perhaps we can scroll this window on redisplay. */
name|start
operator|=
name|calling_window
operator|->
name|first_row
expr_stmt|;
name|pagetop
operator|=
name|calling_window
operator|->
name|pagetop
expr_stmt|;
name|compwin
operator|=
name|window_make_window
argument_list|(
name|possible_completions_output_node
argument_list|)
expr_stmt|;
name|active_window
operator|=
name|the_echo_area
expr_stmt|;
name|window_change_window_height
argument_list|(
name|compwin
argument_list|,
operator|-
operator|(
name|compwin
operator|->
name|height
operator|-
operator|(
name|count
operator|+
literal|2
operator|)
operator|)
argument_list|)
expr_stmt|;
name|window_adjust_pagetop
argument_list|(
name|calling_window
argument_list|)
expr_stmt|;
name|remember_calling_window
argument_list|(
name|calling_window
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SPLIT_BEFORE_ACTIVE
argument_list|)
comment|/* If the pagetop hasn't changed, scrolling the calling 		   window is a reasonable thing to do. */
if|if
condition|(
name|pagetop
operator|==
name|calling_window
operator|->
name|pagetop
condition|)
block|{
name|end
operator|=
name|start
operator|+
name|calling_window
operator|->
name|height
expr_stmt|;
name|display_scroll_display
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|calling_window
operator|->
name|prev
operator|->
name|height
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !SPLIT_BEFORE_ACTIVE */
comment|/* If the pagetop has changed, set the new pagetop here. */
if|if
condition|(
name|pagetop
operator|!=
name|calling_window
operator|->
name|pagetop
condition|)
block|{
name|int
name|newtop
init|=
name|calling_window
operator|->
name|pagetop
decl_stmt|;
name|calling_window
operator|->
name|pagetop
operator|=
name|pagetop
expr_stmt|;
name|set_window_pagetop
argument_list|(
name|calling_window
argument_list|,
name|newtop
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !SPLIT_BEFORE_ACTIVE */
name|echo_area_completions_window
operator|=
name|compwin
expr_stmt|;
name|remember_window_and_node
argument_list|(
name|compwin
argument_list|,
name|compwin
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|compwin
operator|=
name|calling_window
expr_stmt|;
block|}
if|if
condition|(
name|compwin
operator|->
name|node
operator|!=
name|possible_completions_output_node
condition|)
block|{
name|window_set_node_of_window
argument_list|(
name|compwin
argument_list|,
name|possible_completions_output_node
argument_list|)
expr_stmt|;
name|remember_window_and_node
argument_list|(
name|compwin
argument_list|,
name|compwin
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
name|display_update_display
argument_list|(
name|windows
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|ea_complete
argument_list|,
literal|"Insert completion"
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|echo_area_completion_items
condition|)
block|{
name|ea_insert
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If KEY is SPC, and we are not forcing completion to take place, simply      insert the key. */
if|if
condition|(
operator|!
name|echo_area_must_complete_p
operator|&&
name|key
operator|==
name|SPC
condition|)
block|{
name|ea_insert
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ea_last_executed_command
operator|==
name|ea_complete
condition|)
block|{
comment|/* If the keypress is a SPC character, and we have already tried 	 completing once, and there are several completions, then check 	 the batch of completions to see if any continue with a space. 	 If there are some, insert the space character and continue. */
if|if
condition|(
name|key
operator|==
name|SPC
operator|&&
name|completions_found_index
operator|>
literal|1
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|;
name|offset
operator|=
name|input_line_end
operator|-
name|input_line_beg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|completions_found_index
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|completions_found
index|[
name|i
index|]
operator|->
name|label
index|[
name|offset
index|]
operator|==
literal|' '
condition|)
break|break;
if|if
condition|(
name|completions_found
index|[
name|i
index|]
condition|)
name|ea_insert
argument_list|(
name|window
argument_list|,
literal|1
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
else|else
block|{
name|ea_possible_completions
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|ea_possible_completions
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|input_line_point
operator|=
name|input_line_end
expr_stmt|;
name|build_completions
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|completions_found_index
condition|)
name|terminal_ring_bell
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|LCD_completion
operator|->
name|label
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|ea_possible_completions
argument_list|(
name|window
argument_list|,
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|input_line_point
operator|=
name|input_line_end
operator|=
name|input_line_beg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|LCD_completion
operator|->
name|label
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|ea_insert
argument_list|(
name|window
argument_list|,
literal|1
argument_list|,
name|LCD_completion
operator|->
name|label
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Utility REFERENCE used to store possible LCD. */
end_comment

begin_decl_stmt
specifier|static
name|REFERENCE
name|LCD_reference
init|=
block|{
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|remove_completion_duplicates
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Variables which remember the state of the most recent call    to build_completions (). */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_completion_request
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|REFERENCE
modifier|*
modifier|*
name|last_completion_items
init|=
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to tell the completion builder to reset internal state. */
end_comment

begin_function
specifier|static
name|void
name|completions_must_be_rebuilt
parameter_list|()
block|{
name|maybe_free
argument_list|(
name|last_completion_request
argument_list|)
expr_stmt|;
name|last_completion_request
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|last_completion_items
operator|=
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Build a list of possible completions from echo_area_completion_items,    and the contents of input_line. */
end_comment

begin_function
specifier|static
name|void
name|build_completions
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|REFERENCE
modifier|*
name|entry
decl_stmt|;
name|char
modifier|*
name|request
decl_stmt|;
name|int
name|informed_of_lengthy_job
init|=
literal|0
decl_stmt|;
comment|/* If there are no items to complete over, exit immediately. */
if|if
condition|(
operator|!
name|echo_area_completion_items
condition|)
block|{
name|completions_found_index
operator|=
literal|0
expr_stmt|;
name|LCD_completion
operator|=
operator|(
name|REFERENCE
operator|*
operator|)
name|NULL
expr_stmt|;
return|return;
block|}
comment|/* Check to see if this call to build completions is the same as the last      call to build completions. */
name|len
operator|=
name|input_line_end
operator|-
name|input_line_beg
expr_stmt|;
name|request
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|request
argument_list|,
operator|&
name|input_line
index|[
name|input_line_beg
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|request
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|last_completion_request
operator|&&
name|last_completion_items
operator|&&
name|last_completion_items
operator|==
name|echo_area_completion_items
operator|&&
operator|(
name|strcmp
argument_list|(
name|last_completion_request
argument_list|,
name|request
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|free
argument_list|(
name|request
argument_list|)
expr_stmt|;
return|return;
block|}
name|maybe_free
argument_list|(
name|last_completion_request
argument_list|)
expr_stmt|;
name|last_completion_request
operator|=
name|request
expr_stmt|;
name|last_completion_items
operator|=
name|echo_area_completion_items
expr_stmt|;
comment|/* Always start at the beginning of the list. */
name|completions_found_index
operator|=
literal|0
expr_stmt|;
name|LCD_completion
operator|=
operator|(
name|REFERENCE
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|entry
operator|=
name|echo_area_completion_items
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strnicmp
argument_list|(
name|request
argument_list|,
name|entry
operator|->
name|label
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
name|add_pointer_to_array
argument_list|(
name|entry
argument_list|,
name|completions_found_index
argument_list|,
name|completions_found
argument_list|,
name|completions_found_slots
argument_list|,
literal|20
argument_list|,
name|REFERENCE
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|informed_of_lengthy_job
operator|&&
name|completions_found_index
operator|>
literal|100
condition|)
block|{
name|informed_of_lengthy_job
operator|=
literal|1
expr_stmt|;
name|window_message_in_echo_area
argument_list|(
literal|"Building completions..."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|completions_found_index
condition|)
return|return;
comment|/* Sort and prune duplicate entries from the completions array. */
name|remove_completion_duplicates
argument_list|()
expr_stmt|;
comment|/* If there is only one completion, just return that. */
if|if
condition|(
name|completions_found_index
operator|==
literal|1
condition|)
block|{
name|LCD_completion
operator|=
name|completions_found
index|[
literal|0
index|]
expr_stmt|;
return|return;
block|}
comment|/* Find the least common denominator. */
block|{
name|long
name|shortest
init|=
literal|100000
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|completions_found_index
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|c1
operator|=
name|info_tolower
argument_list|(
name|completions_found
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|label
index|[
name|j
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|c2
operator|=
name|info_tolower
argument_list|(
name|completions_found
index|[
name|i
index|]
operator|->
name|label
index|[
name|j
index|]
argument_list|)
operator|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|c1
operator|!=
name|c2
condition|)
break|break;
if|if
condition|(
name|shortest
operator|>
name|j
condition|)
name|shortest
operator|=
name|j
expr_stmt|;
block|}
name|maybe_free
argument_list|(
name|LCD_reference
operator|.
name|label
argument_list|)
expr_stmt|;
name|LCD_reference
operator|.
name|label
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|shortest
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|LCD_reference
operator|.
name|label
argument_list|,
name|completions_found
index|[
literal|0
index|]
operator|->
name|label
argument_list|,
name|shortest
argument_list|)
expr_stmt|;
name|LCD_reference
operator|.
name|label
index|[
name|shortest
index|]
operator|=
literal|'\0'
expr_stmt|;
name|LCD_completion
operator|=
operator|&
name|LCD_reference
expr_stmt|;
block|}
if|if
condition|(
name|informed_of_lengthy_job
condition|)
name|echo_area_initialize_node
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function called by qsort. */
end_comment

begin_function
specifier|static
name|int
name|compare_references
parameter_list|(
name|entry1
parameter_list|,
name|entry2
parameter_list|)
name|REFERENCE
modifier|*
modifier|*
name|entry1
decl_stmt|,
decl|*
modifier|*
name|entry2
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|stricmp
argument_list|(
operator|(
operator|*
name|entry1
operator|)
operator|->
name|label
argument_list|,
operator|(
operator|*
name|entry2
operator|)
operator|->
name|label
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Prune duplicate entries from COMPLETIONS_FOUND. */
end_comment

begin_function
specifier|static
name|void
name|remove_completion_duplicates
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|REFERENCE
modifier|*
modifier|*
name|temp
decl_stmt|;
name|int
name|newlen
decl_stmt|;
if|if
condition|(
operator|!
name|completions_found_index
condition|)
return|return;
comment|/* Sort the items. */
name|qsort
argument_list|(
name|completions_found
argument_list|,
name|completions_found_index
argument_list|,
sizeof|sizeof
argument_list|(
name|REFERENCE
operator|*
argument_list|)
argument_list|,
name|compare_references
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|newlen
operator|=
literal|1
init|;
name|i
operator|<
name|completions_found_index
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|completions_found
index|[
name|i
index|]
operator|->
name|label
argument_list|,
name|completions_found
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|label
argument_list|)
operator|==
literal|0
condition|)
name|completions_found
index|[
name|i
index|]
operator|=
operator|(
name|REFERENCE
operator|*
operator|)
name|NULL
expr_stmt|;
else|else
name|newlen
operator|++
expr_stmt|;
block|}
comment|/* We have marked all the dead slots.  It is faster to copy the live slots      twice than to prune the dead slots one by one. */
name|temp
operator|=
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|newlen
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|REFERENCE
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|completions_found_index
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|completions_found
index|[
name|i
index|]
condition|)
name|temp
index|[
name|j
operator|++
index|]
operator|=
name|completions_found
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|newlen
condition|;
name|i
operator|++
control|)
name|completions_found
index|[
name|i
index|]
operator|=
name|temp
index|[
name|i
index|]
expr_stmt|;
name|completions_found
index|[
name|i
index|]
operator|=
operator|(
name|REFERENCE
operator|*
operator|)
name|NULL
expr_stmt|;
name|completions_found_index
operator|=
name|newlen
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scroll the "other" window.  If there is a window showing completions, scroll    that one, otherwise scroll the window which was active on entering the read    function. */
end_comment

begin_macro
name|DECLARE_INFO_COMMAND
argument_list|(
argument|ea_scroll_completions_window
argument_list|,
literal|"Scroll the completions window"
argument_list|)
end_macro

begin_block
block|{
name|WINDOW
modifier|*
name|compwin
decl_stmt|;
name|int
name|old_pagetop
decl_stmt|;
name|compwin
operator|=
name|get_internal_info_window
argument_list|(
name|compwin_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|compwin
condition|)
name|compwin
operator|=
name|calling_window
expr_stmt|;
name|old_pagetop
operator|=
name|compwin
operator|->
name|pagetop
expr_stmt|;
comment|/* Let info_scroll_forward () do the work, and print any messages that      need to be displayed. */
name|info_scroll_forward
argument_list|(
name|compwin
argument_list|,
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Function which gets called when an Info window is deleted while the    echo area is active.  WINDOW is the window which has just been deleted. */
end_comment

begin_function
name|void
name|echo_area_inform_of_deleted_window
parameter_list|(
name|window
parameter_list|)
name|WINDOW
modifier|*
name|window
decl_stmt|;
block|{
comment|/* If this is the calling_window, forget what we remembered about it. */
if|if
condition|(
name|window
operator|==
name|calling_window
condition|)
block|{
if|if
condition|(
name|active_window
operator|!=
name|the_echo_area
condition|)
name|remember_calling_window
argument_list|(
name|active_window
argument_list|)
expr_stmt|;
else|else
name|remember_calling_window
argument_list|(
name|windows
argument_list|)
expr_stmt|;
block|}
comment|/* If this window was the echo_area_completions_window, then notice that      the window has been deleted. */
if|if
condition|(
name|window
operator|==
name|echo_area_completions_window
condition|)
name|echo_area_completions_window
operator|=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		   Pushing and Popping the Echo Area		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Push and Pop the echo area. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|prompt
decl_stmt|;
name|REFERENCE
modifier|*
modifier|*
name|comp_items
decl_stmt|;
name|int
name|point
decl_stmt|,
name|beg
decl_stmt|,
name|end
decl_stmt|;
name|int
name|must_complete
decl_stmt|;
name|NODE
name|node
decl_stmt|;
name|WINDOW
modifier|*
name|compwin
decl_stmt|;
block|}
name|PUSHED_EA
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|PUSHED_EA
modifier|*
modifier|*
name|pushed_echo_areas
init|=
operator|(
name|PUSHED_EA
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pushed_echo_areas_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pushed_echo_areas_slots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pushing the echo_area has a side effect of zeroing the completion_items. */
end_comment

begin_function
specifier|static
name|void
name|push_echo_area
parameter_list|()
block|{
name|PUSHED_EA
modifier|*
name|pushed
decl_stmt|;
name|pushed
operator|=
operator|(
name|PUSHED_EA
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PUSHED_EA
argument_list|)
argument_list|)
expr_stmt|;
name|pushed
operator|->
name|line
operator|=
name|savestring
argument_list|(
name|input_line
argument_list|)
expr_stmt|;
name|pushed
operator|->
name|prompt
operator|=
name|input_line_prompt
expr_stmt|;
name|pushed
operator|->
name|point
operator|=
name|input_line_point
expr_stmt|;
name|pushed
operator|->
name|beg
operator|=
name|input_line_beg
expr_stmt|;
name|pushed
operator|->
name|end
operator|=
name|input_line_end
expr_stmt|;
name|pushed
operator|->
name|node
operator|=
name|input_line_node
expr_stmt|;
name|pushed
operator|->
name|comp_items
operator|=
name|echo_area_completion_items
expr_stmt|;
name|pushed
operator|->
name|must_complete
operator|=
name|echo_area_must_complete_p
expr_stmt|;
name|pushed
operator|->
name|compwin
operator|=
name|echo_area_completions_window
expr_stmt|;
name|add_pointer_to_array
argument_list|(
name|pushed
argument_list|,
name|pushed_echo_areas_index
argument_list|,
name|pushed_echo_areas
argument_list|,
name|pushed_echo_areas_slots
argument_list|,
literal|4
argument_list|,
name|PUSHED_EA
operator|*
argument_list|)
expr_stmt|;
name|echo_area_completion_items
operator|=
operator|(
name|REFERENCE
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pop_echo_area
parameter_list|()
block|{
name|PUSHED_EA
modifier|*
name|popped
decl_stmt|;
name|popped
operator|=
name|pushed_echo_areas
index|[
operator|--
name|pushed_echo_areas_index
index|]
expr_stmt|;
name|strcpy
argument_list|(
name|input_line
argument_list|,
name|popped
operator|->
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|popped
operator|->
name|line
argument_list|)
expr_stmt|;
name|input_line_prompt
operator|=
name|popped
operator|->
name|prompt
expr_stmt|;
name|input_line_point
operator|=
name|popped
operator|->
name|point
expr_stmt|;
name|input_line_beg
operator|=
name|popped
operator|->
name|beg
expr_stmt|;
name|input_line_end
operator|=
name|popped
operator|->
name|end
expr_stmt|;
name|input_line_node
operator|=
name|popped
operator|->
name|node
expr_stmt|;
name|echo_area_completion_items
operator|=
name|popped
operator|->
name|comp_items
expr_stmt|;
name|echo_area_must_complete_p
operator|=
name|popped
operator|->
name|must_complete
expr_stmt|;
name|echo_area_completions_window
operator|=
name|popped
operator|->
name|compwin
expr_stmt|;
name|completions_must_be_rebuilt
argument_list|()
expr_stmt|;
comment|/* If the completion window no longer exists, forget about it. */
if|if
condition|(
name|echo_area_completions_window
condition|)
block|{
specifier|register
name|WINDOW
modifier|*
name|win
decl_stmt|;
for|for
control|(
name|win
operator|=
name|windows
init|;
name|win
condition|;
name|win
operator|=
name|win
operator|->
name|next
control|)
if|if
condition|(
name|echo_area_completions_window
operator|==
name|win
condition|)
break|break;
comment|/* If the window wasn't found, then it has already been deleted. */
if|if
condition|(
operator|!
name|win
condition|)
name|echo_area_completions_window
operator|=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|popped
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|echo_area_stack_depth
parameter_list|()
block|{
return|return
operator|(
name|pushed_echo_areas_index
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if any of the prior stacked calls to read in the echo    area produced a completions window. */
end_comment

begin_function
specifier|static
name|int
name|echo_area_stack_contains_completions_p
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pushed_echo_areas_index
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pushed_echo_areas
index|[
name|i
index|]
operator|->
name|compwin
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*	       Error Messages While Reading in Echo Area	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_TIME_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_define
define|#
directive|define
name|HAVE_STRUCT_TIMEVAL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_SYS_TIME_H */
end_comment

begin_function
specifier|static
name|void
name|pause_or_input
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|FD_SET
argument_list|)
name|struct
name|timeval
name|timer
decl_stmt|;
name|fd_set
name|readfds
decl_stmt|;
name|int
name|ready
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|timer
operator|.
name|tv_sec
operator|=
literal|2
expr_stmt|;
name|timer
operator|.
name|tv_usec
operator|=
literal|750
expr_stmt|;
name|ready
operator|=
name|select
argument_list|(
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|timer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FD_SET */
block|}
end_function

begin_comment
comment|/* Print MESSAGE right after the end of the current line, and wait    for input or 2.75 seconds, whichever comes first.  Then flush the    informational message that was printed. */
end_comment

begin_function
name|void
name|inform_in_echo_area
parameter_list|(
name|message
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|text
operator|=
name|savestring
argument_list|(
name|message
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|text
index|[
name|i
index|]
operator|&&
name|text
index|[
name|i
index|]
operator|!=
literal|'\n'
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|text
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|echo_area_initialize_node
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
operator|&
name|input_line
index|[
name|input_line_end
index|]
argument_list|,
literal|"%s[%s]\n"
argument_list|,
name|echo_area_is_active
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|the_echo_area
operator|->
name|point
operator|=
name|input_line_point
expr_stmt|;
name|display_update_one_window
argument_list|(
name|the_echo_area
argument_list|)
expr_stmt|;
name|display_cursor_at_point
argument_list|(
name|active_window
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|pause_or_input
argument_list|()
expr_stmt|;
name|echo_area_initialize_node
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

