begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* nodes.c -- How to get an Info file and node. */
end_comment

begin_comment
comment|/* This file is part of GNU Info, a program for reading online documentation    stored in Info format.     Copyright (C) 1993 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     Written by Brian Fox (bfox@ai.mit.edu). */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"nodes.h"
end_include

begin_include
include|#
directive|include
file|"search.h"
end_include

begin_include
include|#
directive|include
file|"filesys.h"
end_include

begin_include
include|#
directive|include
file|"info-utils.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|O_RDONLY
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_FCNTL_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !HAVE_SYS_FCNTL_H */
end_comment

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_SYS_FCNTL_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !O_RDONLY */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|errno
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !errno */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		     Functions Static to this File		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_decl_stmt
specifier|static
name|void
name|forget_info_file
argument_list|()
decl_stmt|,
name|remember_info_file
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_file_buffer_tags
argument_list|()
decl_stmt|,
name|free_info_tag
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|get_nodes_of_tags_table
argument_list|()
decl_stmt|,
name|get_nodes_of_info_file
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|get_tags_of_indirect_tags_table
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|info_reload_file_buffer_contents
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|adjust_nodestart
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FILE_BUFFER
modifier|*
name|make_file_buffer
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|FILE_BUFFER
modifier|*
name|info_load_file_internal
argument_list|()
decl_stmt|,
modifier|*
name|info_find_file_internal
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|NODE
modifier|*
name|info_node_of_file_buffer_tags
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|get_node_length
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Magic number that RMS used to decide how much a tags table pointer could    be off by.  I feel that it should be much smaller, like on the order of    4. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_INFO_FUDGE
value|1000
end_define

begin_comment
comment|/* Passed to *_internal functions.  INFO_GET_TAGS says to do what is    neccessary to fill in the nodes or tags arrays in FILE_BUFFER. */
end_comment

begin_define
define|#
directive|define
name|INFO_NO_TAGS
value|0
end_define

begin_define
define|#
directive|define
name|INFO_GET_TAGS
value|1
end_define

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			 Global Variables			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* When non-zero, this is a string describing the recent file error. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|info_recent_file_error
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of already loaded nodes. */
end_comment

begin_decl_stmt
name|FILE_BUFFER
modifier|*
modifier|*
name|info_loaded_files
init|=
operator|(
name|FILE_BUFFER
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of slots currently allocated to LOADED_FILES. */
end_comment

begin_decl_stmt
name|int
name|info_loaded_files_slots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		 Public Functions for Node Manipulation		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Used to build "dir" menu from "localdir" files found in INFOPATH. */
end_comment

begin_function_decl
specifier|extern
name|void
name|maybe_build_dir_node
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Return a pointer to a NODE structure for the Info node (FILENAME)NODENAME.    FILENAME can be passed as NULL, in which case the filename of "dir" is used.    NODENAME can be passed as NULL, in which case the nodename of "Top" is used.    If the node cannot be found, return a NULL pointer. */
end_comment

begin_function
name|NODE
modifier|*
name|info_get_node
parameter_list|(
name|filename
parameter_list|,
name|nodename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|,
decl|*
name|nodename
decl_stmt|;
end_function

begin_block
block|{
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
name|NODE
modifier|*
name|node
decl_stmt|;
name|file_buffer
operator|=
operator|(
name|FILE_BUFFER
operator|*
operator|)
name|NULL
expr_stmt|;
name|info_recent_file_error
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|info_parse_node
argument_list|(
name|nodename
argument_list|,
name|DONT_SKIP_NEWLINES
argument_list|)
expr_stmt|;
name|nodename
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|info_parsed_filename
condition|)
name|filename
operator|=
name|info_parsed_filename
expr_stmt|;
if|if
condition|(
name|info_parsed_nodename
condition|)
name|nodename
operator|=
name|info_parsed_nodename
expr_stmt|;
comment|/* If FILENAME is not specified, it defaults to "dir". */
if|if
condition|(
operator|!
name|filename
condition|)
name|filename
operator|=
literal|"dir"
expr_stmt|;
comment|/* If the file to be looked up is "dir", build the contents from all of      the "localdir"'s found in INFOPATH. */
if|if
condition|(
name|stricmp
argument_list|(
name|filename
argument_list|,
literal|"dir"
argument_list|)
operator|==
literal|0
condition|)
name|maybe_build_dir_node
argument_list|(
name|filename
argument_list|,
literal|"localdir"
argument_list|)
expr_stmt|;
comment|/* Find the correct info file. */
name|file_buffer
operator|=
name|info_find_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_buffer
condition|)
block|{
if|if
condition|(
name|filesys_error_number
condition|)
name|info_recent_file_error
operator|=
name|filesys_error_string
argument_list|(
name|filename
argument_list|,
name|filesys_error_number
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|NODE
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|node
operator|=
name|info_get_node_of_file_buffer
argument_list|(
name|nodename
argument_list|,
name|file_buffer
argument_list|)
expr_stmt|;
comment|/* If the node looked for was "Top", try again looking for the node under      a slightly different name. */
if|if
condition|(
operator|!
name|node
operator|&&
operator|(
name|nodename
operator|==
name|NULL
operator|||
name|stricmp
argument_list|(
name|nodename
argument_list|,
literal|"Top"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|node
operator|=
name|info_get_node_of_file_buffer
argument_list|(
literal|"Top"
argument_list|,
name|file_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
name|node
operator|=
name|info_get_node_of_file_buffer
argument_list|(
literal|"top"
argument_list|,
name|file_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
name|node
operator|=
name|info_get_node_of_file_buffer
argument_list|(
literal|"TOP"
argument_list|,
name|file_buffer
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|node
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Return a pointer to a NODE structure for the Info node NODENAME in    FILE_BUFFER.  NODENAME can be passed as NULL, in which case the    nodename of "Top" is used.  If the node cannot be found, return a    NULL pointer. */
end_comment

begin_function
name|NODE
modifier|*
name|info_get_node_of_file_buffer
parameter_list|(
name|nodename
parameter_list|,
name|file_buffer
parameter_list|)
name|char
modifier|*
name|nodename
decl_stmt|;
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
block|{
name|NODE
modifier|*
name|node
init|=
operator|(
name|NODE
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* If we are unable to find the file, we have to give up.  There isn't      anything else we can do. */
if|if
condition|(
operator|!
name|file_buffer
condition|)
return|return
operator|(
operator|(
name|NODE
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* If the file buffer was gc'ed, reload the contents now. */
if|if
condition|(
operator|!
name|file_buffer
operator|->
name|contents
condition|)
name|info_reload_file_buffer_contents
argument_list|(
name|file_buffer
argument_list|)
expr_stmt|;
comment|/* If NODENAME is not specified, it defaults to "Top". */
if|if
condition|(
operator|!
name|nodename
condition|)
name|nodename
operator|=
literal|"Top"
expr_stmt|;
comment|/* If the name of the node that we wish to find is exactly "*", then the      node body is the contents of the entire file.  Create and return such      a node. */
if|if
condition|(
name|strcmp
argument_list|(
name|nodename
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|node
operator|=
operator|(
name|NODE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NODE
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|filename
operator|=
name|file_buffer
operator|->
name|fullpath
expr_stmt|;
name|node
operator|->
name|parent
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|node
operator|->
name|nodename
operator|=
name|savestring
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|node
operator|->
name|contents
operator|=
name|file_buffer
operator|->
name|contents
expr_stmt|;
name|node
operator|->
name|nodelen
operator|=
name|file_buffer
operator|->
name|filesize
expr_stmt|;
name|node
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this is the "main" info file, it might contain a tags table.  Search      the tags table for an entry which matches the node that we want.  If      there is a tags table, get the file which contains this node, but don't      bother building a node list for it. */
elseif|else
if|if
condition|(
name|file_buffer
operator|->
name|tags
condition|)
name|node
operator|=
name|info_node_of_file_buffer_tags
argument_list|(
name|file_buffer
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
comment|/* Return the results of our node search. */
return|return
operator|(
name|node
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Locate the file named by FILENAME, and return the information structure    describing this file.  The file may appear in our list of loaded files    already, or it may not.  If it does not already appear, find the file,    and add it to the list of loaded files.  If the file cannot be found,    return a NULL FILE_BUFFER *. */
end_comment

begin_function
name|FILE_BUFFER
modifier|*
name|info_find_file
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
return|return
operator|(
name|info_find_file_internal
argument_list|(
name|filename
argument_list|,
name|INFO_GET_TAGS
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Load the info file FILENAME, remembering information about it in a    file buffer. */
end_comment

begin_function
name|FILE_BUFFER
modifier|*
name|info_load_file
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
return|return
operator|(
name|info_load_file_internal
argument_list|(
name|filename
argument_list|,
name|INFO_GET_TAGS
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		    Private Functions Implementation		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* The workhorse for info_find_file ().  Non-zero 2nd argument says to    try to build a tags table (or otherwise glean the nodes) for this    file once found.  By default, we build the tags table, but when this    function is called by info_get_node () when we already have a valid    tags table describing the nodes, it is unnecessary. */
end_comment

begin_function
specifier|static
name|FILE_BUFFER
modifier|*
name|info_find_file_internal
parameter_list|(
name|filename
parameter_list|,
name|get_tags
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|get_tags
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
comment|/* First try to find the file in our list of already loaded files. */
if|if
condition|(
name|info_loaded_files
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|file_buffer
operator|=
name|info_loaded_files
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|filename
argument_list|,
name|file_buffer
operator|->
name|filename
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|filename
argument_list|,
name|file_buffer
operator|->
name|fullpath
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
operator|*
name|filename
operator|!=
literal|'/'
operator|)
operator|&&
name|strcmp
argument_list|(
name|filename
argument_list|,
name|filename_non_directory
argument_list|(
name|file_buffer
operator|->
name|fullpath
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|struct
name|stat
name|new_info
decl_stmt|,
modifier|*
name|old_info
decl_stmt|;
comment|/* This file is loaded.  If the filename that we want is 	       specifically "dir", then simply return the file buffer. */
if|if
condition|(
name|stricmp
argument_list|(
name|filename_non_directory
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"dir"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|file_buffer
operator|)
return|;
comment|/* The file appears to be already loaded, and it is not "dir". 	       Check to see if it has changed since the last time it was 	       loaded. */
if|if
condition|(
name|stat
argument_list|(
name|file_buffer
operator|->
name|fullpath
argument_list|,
operator|&
name|new_info
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|filesys_error_number
operator|=
name|errno
expr_stmt|;
return|return
operator|(
operator|(
name|FILE_BUFFER
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|old_info
operator|=
operator|&
name|file_buffer
operator|->
name|finfo
expr_stmt|;
if|if
condition|(
operator|(
name|new_info
operator|.
name|st_size
operator|!=
name|old_info
operator|->
name|st_size
operator|)
operator|||
operator|(
name|new_info
operator|.
name|st_mtime
operator|!=
name|old_info
operator|->
name|st_mtime
operator|)
condition|)
block|{
comment|/* The file has changed.  Forget that we ever had loaded it 		   in the first place. */
name|forget_info_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* The info file exists, and has not changed since the last 		   time it was loaded.  If the caller requested a nodes list 		   for this file, and there isn't one here, build the nodes 		   for this file_buffer.  In any case, return the file_buffer 		   object. */
if|if
condition|(
name|get_tags
operator|&&
operator|!
name|file_buffer
operator|->
name|tags
condition|)
name|build_tags_and_nodes
argument_list|(
name|file_buffer
argument_list|)
expr_stmt|;
return|return
operator|(
name|file_buffer
operator|)
return|;
block|}
block|}
block|}
comment|/* The file wasn't loaded.  Try to load it now. */
name|file_buffer
operator|=
name|info_load_file_internal
argument_list|(
name|filename
argument_list|,
name|get_tags
argument_list|)
expr_stmt|;
comment|/* If the file was loaded, remember the name under which it was found. */
if|if
condition|(
name|file_buffer
condition|)
name|remember_info_file
argument_list|(
name|file_buffer
argument_list|)
expr_stmt|;
return|return
operator|(
name|file_buffer
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The workhorse function for info_load_file ().  Non-zero second argument    says to build a list of tags (or nodes) for this file.  This is the    default behaviour when info_load_file () is called, but it is not    necessary when loading a subfile for which we already have tags. */
end_comment

begin_function
specifier|static
name|FILE_BUFFER
modifier|*
name|info_load_file_internal
parameter_list|(
name|filename
parameter_list|,
name|get_tags
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|get_tags
decl_stmt|;
block|{
name|char
modifier|*
name|fullpath
decl_stmt|,
modifier|*
name|contents
decl_stmt|;
name|long
name|filesize
decl_stmt|;
name|struct
name|stat
name|finfo
decl_stmt|;
name|int
name|retcode
decl_stmt|;
name|FILE_BUFFER
modifier|*
name|file_buffer
init|=
operator|(
name|FILE_BUFFER
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* Get the full pathname of this file, as known by the info system.      That is to say, search along INFOPATH and expand tildes, etc. */
name|fullpath
operator|=
name|info_find_fullpath
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Did we actually find the file? */
name|retcode
operator|=
name|stat
argument_list|(
name|fullpath
argument_list|,
operator|&
name|finfo
argument_list|)
expr_stmt|;
comment|/* If the file referenced by the name returned from info_find_fullpath ()      doesn't exist, then try again with the last part of the filename      appearing in lowercase. */
if|if
condition|(
name|retcode
operator|<
literal|0
condition|)
block|{
name|char
modifier|*
name|lowered_name
decl_stmt|;
name|char
modifier|*
name|basename
decl_stmt|;
name|lowered_name
operator|=
name|savestring
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|basename
operator|=
operator|(
name|char
operator|*
operator|)
name|rindex
argument_list|(
name|lowered_name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|basename
condition|)
name|basename
operator|++
expr_stmt|;
else|else
name|basename
operator|=
name|lowered_name
expr_stmt|;
while|while
condition|(
operator|*
name|basename
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|basename
argument_list|)
condition|)
operator|*
name|basename
operator|=
name|tolower
argument_list|(
operator|*
name|basename
argument_list|)
expr_stmt|;
name|basename
operator|++
expr_stmt|;
block|}
name|fullpath
operator|=
name|info_find_fullpath
argument_list|(
name|lowered_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lowered_name
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|stat
argument_list|(
name|fullpath
argument_list|,
operator|&
name|finfo
argument_list|)
expr_stmt|;
block|}
comment|/* If the file wasn't found, give up, returning a NULL pointer. */
if|if
condition|(
name|retcode
operator|<
literal|0
condition|)
block|{
name|filesys_error_number
operator|=
name|errno
expr_stmt|;
return|return
operator|(
operator|(
name|FILE_BUFFER
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
comment|/* Otherwise, try to load the file. */
name|contents
operator|=
name|filesys_read_info_file
argument_list|(
name|fullpath
argument_list|,
operator|&
name|filesize
argument_list|,
operator|&
name|finfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|contents
condition|)
return|return
operator|(
operator|(
name|FILE_BUFFER
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* The file was found, and can be read.  Allocate FILE_BUFFER and fill      in the various members. */
name|file_buffer
operator|=
name|make_file_buffer
argument_list|()
expr_stmt|;
name|file_buffer
operator|->
name|filename
operator|=
name|savestring
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|file_buffer
operator|->
name|fullpath
operator|=
name|savestring
argument_list|(
name|fullpath
argument_list|)
expr_stmt|;
name|file_buffer
operator|->
name|finfo
operator|=
name|finfo
expr_stmt|;
name|file_buffer
operator|->
name|filesize
operator|=
name|filesize
expr_stmt|;
name|file_buffer
operator|->
name|contents
operator|=
name|contents
expr_stmt|;
if|if
condition|(
name|file_buffer
operator|->
name|filesize
operator|!=
name|file_buffer
operator|->
name|finfo
operator|.
name|st_size
condition|)
name|file_buffer
operator|->
name|flags
operator||=
name|N_IsCompressed
expr_stmt|;
comment|/* If requested, build the tags and nodes for this file buffer. */
if|if
condition|(
name|get_tags
condition|)
name|build_tags_and_nodes
argument_list|(
name|file_buffer
argument_list|)
expr_stmt|;
return|return
operator|(
name|file_buffer
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Grovel FILE_BUFFER->contents finding tags and nodes, and filling in the    various slots.  This can also be used to rebuild a tag or node table. */
end_comment

begin_function
name|void
name|build_tags_and_nodes
parameter_list|(
name|file_buffer
parameter_list|)
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
block|{
name|SEARCH_BINDING
name|binding
decl_stmt|;
name|long
name|position
decl_stmt|;
name|free_file_buffer_tags
argument_list|(
name|file_buffer
argument_list|)
expr_stmt|;
name|file_buffer
operator|->
name|flags
operator|&=
operator|~
name|N_HasTagsTable
expr_stmt|;
comment|/* See if there is a tags table in this info file. */
name|binding
operator|.
name|buffer
operator|=
name|file_buffer
operator|->
name|contents
expr_stmt|;
name|binding
operator|.
name|start
operator|=
name|file_buffer
operator|->
name|filesize
expr_stmt|;
name|binding
operator|.
name|end
operator|=
name|binding
operator|.
name|start
operator|-
literal|1000
expr_stmt|;
if|if
condition|(
name|binding
operator|.
name|end
operator|<
literal|0
condition|)
name|binding
operator|.
name|end
operator|=
literal|0
expr_stmt|;
name|binding
operator|.
name|flags
operator|=
name|S_FoldCase
expr_stmt|;
name|position
operator|=
name|search_backward
argument_list|(
name|TAGS_TABLE_END_LABEL
argument_list|,
operator|&
name|binding
argument_list|)
expr_stmt|;
comment|/* If there is a tag table, find the start of it, and grovel over it      extracting tag information. */
if|if
condition|(
name|position
operator|!=
operator|-
literal|1
condition|)
while|while
condition|(
literal|1
condition|)
block|{
name|long
name|tags_table_begin
decl_stmt|,
name|tags_table_end
decl_stmt|;
name|binding
operator|.
name|end
operator|=
name|position
expr_stmt|;
name|binding
operator|.
name|start
operator|=
name|binding
operator|.
name|end
operator|-
literal|5
operator|-
name|strlen
argument_list|(
name|TAGS_TABLE_END_LABEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|binding
operator|.
name|start
operator|<
literal|0
condition|)
name|binding
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|position
operator|=
name|find_node_separator
argument_list|(
operator|&
name|binding
argument_list|)
expr_stmt|;
comment|/* For this test, (and all others here) failure indicates a bogus 	   tags table.  Grovel the file. */
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/* Remember the end of the tags table. */
name|binding
operator|.
name|start
operator|=
name|position
expr_stmt|;
name|tags_table_end
operator|=
name|binding
operator|.
name|start
expr_stmt|;
name|binding
operator|.
name|end
operator|=
literal|0
expr_stmt|;
comment|/* Locate the start of the tags table. */
name|position
operator|=
name|search_backward
argument_list|(
name|TAGS_TABLE_BEG_LABEL
argument_list|,
operator|&
name|binding
argument_list|)
expr_stmt|;
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
break|break;
name|binding
operator|.
name|end
operator|=
name|position
expr_stmt|;
name|binding
operator|.
name|start
operator|=
name|binding
operator|.
name|end
operator|-
literal|5
operator|-
name|strlen
argument_list|(
name|TAGS_TABLE_BEG_LABEL
argument_list|)
expr_stmt|;
name|position
operator|=
name|find_node_separator
argument_list|(
operator|&
name|binding
argument_list|)
expr_stmt|;
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/* The file contains a valid tags table.  Fill the FILE_BUFFER's 	   tags member. */
name|file_buffer
operator|->
name|flags
operator||=
name|N_HasTagsTable
expr_stmt|;
name|tags_table_begin
operator|=
name|position
expr_stmt|;
comment|/* If this isn't an indirect tags table, just remember the nodes 	   described locally in this tags table.  Note that binding.end 	   is pointing to just after the beginning label. */
name|binding
operator|.
name|start
operator|=
name|binding
operator|.
name|end
expr_stmt|;
name|binding
operator|.
name|end
operator|=
name|file_buffer
operator|->
name|filesize
expr_stmt|;
if|if
condition|(
operator|!
name|looking_at
argument_list|(
name|TAGS_TABLE_IS_INDIRECT_LABEL
argument_list|,
operator|&
name|binding
argument_list|)
condition|)
block|{
name|binding
operator|.
name|start
operator|=
name|tags_table_begin
expr_stmt|;
name|binding
operator|.
name|end
operator|=
name|tags_table_end
expr_stmt|;
name|get_nodes_of_tags_table
argument_list|(
name|file_buffer
argument_list|,
operator|&
name|binding
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* This is an indirect tags table.  Build TAGS member. */
name|SEARCH_BINDING
name|indirect
decl_stmt|;
name|indirect
operator|.
name|start
operator|=
name|tags_table_begin
expr_stmt|;
name|indirect
operator|.
name|end
operator|=
literal|0
expr_stmt|;
name|indirect
operator|.
name|buffer
operator|=
name|binding
operator|.
name|buffer
expr_stmt|;
name|indirect
operator|.
name|flags
operator|=
name|S_FoldCase
expr_stmt|;
name|position
operator|=
name|search_backward
argument_list|(
name|INDIRECT_TAGS_TABLE_LABEL
argument_list|,
operator|&
name|indirect
argument_list|)
expr_stmt|;
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* This file is malformed.  Give up. */
return|return;
block|}
name|indirect
operator|.
name|start
operator|=
name|position
expr_stmt|;
name|indirect
operator|.
name|end
operator|=
name|tags_table_begin
expr_stmt|;
name|binding
operator|.
name|start
operator|=
name|tags_table_begin
expr_stmt|;
name|binding
operator|.
name|end
operator|=
name|tags_table_end
expr_stmt|;
name|get_tags_of_indirect_tags_table
argument_list|(
name|file_buffer
argument_list|,
operator|&
name|indirect
argument_list|,
operator|&
name|binding
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* This file doesn't contain any kind of tags table.  Grovel the      file and build node entries for it. */
name|get_nodes_of_info_file
argument_list|(
name|file_buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Search through FILE_BUFFER->contents building an array of TAG *,    one entry per each node present in the file.  Store the tags in    FILE_BUFFER->tags, and the number of allocated slots in    FILE_BUFFER->tags_slots. */
end_comment

begin_function
specifier|static
name|void
name|get_nodes_of_info_file
parameter_list|(
name|file_buffer
parameter_list|)
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
block|{
name|long
name|nodestart
decl_stmt|;
name|int
name|tags_index
init|=
literal|0
decl_stmt|;
name|SEARCH_BINDING
name|binding
decl_stmt|;
name|binding
operator|.
name|buffer
operator|=
name|file_buffer
operator|->
name|contents
expr_stmt|;
name|binding
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|binding
operator|.
name|end
operator|=
name|file_buffer
operator|->
name|filesize
expr_stmt|;
name|binding
operator|.
name|flags
operator|=
name|S_FoldCase
expr_stmt|;
while|while
condition|(
operator|(
name|nodestart
operator|=
name|find_node_separator
argument_list|(
operator|&
name|binding
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|char
modifier|*
name|nodeline
decl_stmt|;
name|TAG
modifier|*
name|entry
decl_stmt|;
comment|/* Skip past the characters just found. */
name|binding
operator|.
name|start
operator|=
name|nodestart
expr_stmt|;
name|binding
operator|.
name|start
operator|+=
name|skip_node_separator
argument_list|(
name|binding
operator|.
name|buffer
operator|+
name|binding
operator|.
name|start
argument_list|)
expr_stmt|;
comment|/* Move to the start of the line defining the node. */
name|nodeline
operator|=
name|binding
operator|.
name|buffer
operator|+
name|binding
operator|.
name|start
expr_stmt|;
comment|/* Find "Node:" */
name|start
operator|=
name|string_in_line
argument_list|(
name|INFO_NODE_LABEL
argument_list|,
name|nodeline
argument_list|)
expr_stmt|;
comment|/* If not there, this is not the start of a node. */
if|if
condition|(
name|start
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* Find the start of the nodename. */
name|start
operator|+=
name|skip_whitespace
argument_list|(
name|nodeline
operator|+
name|start
argument_list|)
expr_stmt|;
comment|/* Find the end of the nodename. */
name|end
operator|=
name|start
operator|+
name|skip_node_characters
argument_list|(
name|nodeline
operator|+
name|start
argument_list|,
name|DONT_SKIP_NEWLINES
argument_list|)
expr_stmt|;
comment|/* Okay, we have isolated the node name, and we know where the 	 node starts.  Remember this information in a NODE structure. */
name|entry
operator|=
operator|(
name|TAG
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TAG
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|nodename
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
operator|(
name|end
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|entry
operator|->
name|nodename
argument_list|,
name|nodeline
operator|+
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|entry
operator|->
name|nodename
index|[
name|end
operator|-
name|start
index|]
operator|=
literal|'\0'
expr_stmt|;
name|entry
operator|->
name|nodestart
operator|=
name|nodestart
expr_stmt|;
block|{
name|SEARCH_BINDING
name|node_body
decl_stmt|;
name|node_body
operator|.
name|buffer
operator|=
name|binding
operator|.
name|buffer
operator|+
name|binding
operator|.
name|start
expr_stmt|;
name|node_body
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|node_body
operator|.
name|end
operator|=
name|binding
operator|.
name|end
operator|-
name|binding
operator|.
name|start
expr_stmt|;
name|node_body
operator|.
name|flags
operator|=
name|S_FoldCase
expr_stmt|;
name|entry
operator|->
name|nodelen
operator|=
name|get_node_length
argument_list|(
operator|&
name|node_body
argument_list|)
expr_stmt|;
block|}
name|entry
operator|->
name|filename
operator|=
name|file_buffer
operator|->
name|fullpath
expr_stmt|;
comment|/* Add this tag to the array of tag structures in this FILE_BUFFER. */
name|add_pointer_to_array
argument_list|(
name|entry
argument_list|,
name|tags_index
argument_list|,
name|file_buffer
operator|->
name|tags
argument_list|,
name|file_buffer
operator|->
name|tags_slots
argument_list|,
literal|100
argument_list|,
name|TAG
operator|*
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the length of the node which starts at BINDING. */
end_comment

begin_function
specifier|static
name|long
name|get_node_length
parameter_list|(
name|binding
parameter_list|)
name|SEARCH_BINDING
modifier|*
name|binding
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|body
decl_stmt|;
comment|/* From the Info-RFC file:      [A node] ends with either a ^_, a ^L, or the end of file. */
for|for
control|(
name|i
operator|=
name|binding
operator|->
name|start
operator|,
name|body
operator|=
name|binding
operator|->
name|buffer
init|;
name|i
operator|<
name|binding
operator|->
name|end
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|body
index|[
name|i
index|]
operator|==
name|INFO_FF
operator|||
name|body
index|[
name|i
index|]
operator|==
name|INFO_COOKIE
condition|)
break|break;
block|}
return|return
operator|(
operator|(
name|long
operator|)
name|i
operator|-
name|binding
operator|->
name|start
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Build and save the array of nodes in FILE_BUFFER by searching through the    contents of BUFFER_BINDING for a tags table, and groveling the contents. */
end_comment

begin_function
specifier|static
name|void
name|get_nodes_of_tags_table
parameter_list|(
name|file_buffer
parameter_list|,
name|buffer_binding
parameter_list|)
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
name|SEARCH_BINDING
modifier|*
name|buffer_binding
decl_stmt|;
block|{
name|int
name|offset
decl_stmt|,
name|tags_index
init|=
literal|0
decl_stmt|;
name|SEARCH_BINDING
modifier|*
name|search
decl_stmt|;
name|long
name|position
decl_stmt|;
name|search
operator|=
name|copy_binding
argument_list|(
name|buffer_binding
argument_list|)
expr_stmt|;
comment|/* Find the start of the tags table. */
name|position
operator|=
name|find_tags_table
argument_list|(
name|search
argument_list|)
expr_stmt|;
comment|/* If none, we're all done. */
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
return|return;
comment|/* Move to one character before the start of the actual table. */
name|search
operator|->
name|start
operator|=
name|position
expr_stmt|;
name|search
operator|->
name|start
operator|+=
name|skip_node_separator
argument_list|(
name|search
operator|->
name|buffer
operator|+
name|search
operator|->
name|start
argument_list|)
expr_stmt|;
name|search
operator|->
name|start
operator|+=
name|strlen
argument_list|(
name|TAGS_TABLE_BEG_LABEL
argument_list|)
expr_stmt|;
name|search
operator|->
name|start
operator|--
expr_stmt|;
comment|/* The tag table consists of lines containing node names and positions.      Do each line until we find one that doesn't contain a node name. */
while|while
condition|(
operator|(
name|position
operator|=
name|search_forward
argument_list|(
literal|"\n"
argument_list|,
name|search
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|TAG
modifier|*
name|entry
decl_stmt|;
name|char
modifier|*
name|nodedef
decl_stmt|;
comment|/* Prepare to skip this line. */
name|search
operator|->
name|start
operator|=
name|position
expr_stmt|;
name|search
operator|->
name|start
operator|++
expr_stmt|;
comment|/* Skip past informative "(Indirect)" tags table line. */
if|if
condition|(
operator|!
name|tags_index
operator|&&
name|looking_at
argument_list|(
name|TAGS_TABLE_IS_INDIRECT_LABEL
argument_list|,
name|search
argument_list|)
condition|)
continue|continue;
comment|/* Find the label preceding the node name. */
name|offset
operator|=
name|string_in_line
argument_list|(
name|INFO_NODE_LABEL
argument_list|,
name|search
operator|->
name|buffer
operator|+
name|search
operator|->
name|start
argument_list|)
expr_stmt|;
comment|/* If not there, not a defining line, so we must be out of the 	 tags table. */
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/* Point to the beginning of the node definition. */
name|search
operator|->
name|start
operator|+=
name|offset
expr_stmt|;
name|nodedef
operator|=
name|search
operator|->
name|buffer
operator|+
name|search
operator|->
name|start
expr_stmt|;
name|nodedef
operator|+=
name|skip_whitespace
argument_list|(
name|nodedef
argument_list|)
expr_stmt|;
comment|/* Move past the node's name. */
for|for
control|(
name|offset
operator|=
literal|0
init|;
operator|(
name|nodedef
index|[
name|offset
index|]
operator|)
operator|&&
operator|(
name|nodedef
index|[
name|offset
index|]
operator|!=
name|INFO_TAGSEP
operator|)
condition|;
name|offset
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|nodedef
index|[
name|offset
index|]
operator|!=
name|INFO_TAGSEP
condition|)
continue|continue;
name|entry
operator|=
operator|(
name|TAG
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TAG
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|nodename
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|offset
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|entry
operator|->
name|nodename
argument_list|,
name|nodedef
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|entry
operator|->
name|nodename
index|[
name|offset
index|]
operator|=
literal|'\0'
expr_stmt|;
name|offset
operator|++
expr_stmt|;
name|entry
operator|->
name|nodestart
operator|=
operator|(
name|long
operator|)
name|atol
argument_list|(
name|nodedef
operator|+
name|offset
argument_list|)
expr_stmt|;
comment|/* We don't know the length of this node yet. */
name|entry
operator|->
name|nodelen
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* The filename of this node is currently known as the same as the 	 name of this file. */
name|entry
operator|->
name|filename
operator|=
name|file_buffer
operator|->
name|fullpath
expr_stmt|;
comment|/* Add this node structure to the array of node structures in this 	 FILE_BUFFER. */
name|add_pointer_to_array
argument_list|(
name|entry
argument_list|,
name|tags_index
argument_list|,
name|file_buffer
operator|->
name|tags
argument_list|,
name|file_buffer
operator|->
name|tags_slots
argument_list|,
literal|100
argument_list|,
name|TAG
operator|*
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|search
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A structure used only in get_tags_of_indirect_tags_table () to hold onto    an intermediate value. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|long
name|first_byte
decl_stmt|;
block|}
name|SUBFILE
typedef|;
end_typedef

begin_comment
comment|/* Remember in FILE_BUFFER the nodenames, subfilenames, and offsets within the    subfiles of every node which appears in TAGS_BINDING.  The 2nd argument is    a binding surrounding the indirect files list. */
end_comment

begin_function
specifier|static
name|void
name|get_tags_of_indirect_tags_table
parameter_list|(
name|file_buffer
parameter_list|,
name|indirect_binding
parameter_list|,
name|tags_binding
parameter_list|)
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
name|SEARCH_BINDING
modifier|*
name|indirect_binding
decl_stmt|,
decl|*
name|tags_binding
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|SUBFILE
modifier|*
modifier|*
name|subfiles
init|=
operator|(
name|SUBFILE
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|subfiles_index
init|=
literal|0
decl_stmt|,
name|subfiles_slots
init|=
literal|0
decl_stmt|;
name|TAG
modifier|*
name|entry
decl_stmt|;
comment|/* First get the list of tags from the tags table.  Then lookup the      associated file in the indirect list for each tag, and update it. */
name|get_nodes_of_tags_table
argument_list|(
name|file_buffer
argument_list|,
name|tags_binding
argument_list|)
expr_stmt|;
comment|/* We have the list of tags in file_buffer->tags.  Get the list of      subfiles from the indirect table. */
block|{
name|char
modifier|*
name|start
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|line
decl_stmt|;
name|SUBFILE
modifier|*
name|subfile
decl_stmt|;
name|start
operator|=
name|indirect_binding
operator|->
name|buffer
operator|+
name|indirect_binding
operator|->
name|start
expr_stmt|;
name|end
operator|=
name|indirect_binding
operator|->
name|buffer
operator|+
name|indirect_binding
operator|->
name|end
expr_stmt|;
name|line
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|line
operator|<
name|end
condition|)
block|{
name|int
name|colon
decl_stmt|;
name|colon
operator|=
name|string_in_line
argument_list|(
literal|":"
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|colon
operator|==
operator|-
literal|1
condition|)
break|break;
name|subfile
operator|=
operator|(
name|SUBFILE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SUBFILE
argument_list|)
argument_list|)
expr_stmt|;
name|subfile
operator|->
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|colon
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|subfile
operator|->
name|filename
argument_list|,
name|line
argument_list|,
name|colon
operator|-
literal|1
argument_list|)
expr_stmt|;
name|subfile
operator|->
name|filename
index|[
name|colon
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|subfile
operator|->
name|first_byte
operator|=
operator|(
name|long
operator|)
name|atol
argument_list|(
name|line
operator|+
name|colon
argument_list|)
expr_stmt|;
name|add_pointer_to_array
argument_list|(
name|subfile
argument_list|,
name|subfiles_index
argument_list|,
name|subfiles
argument_list|,
name|subfiles_slots
argument_list|,
literal|10
argument_list|,
name|SUBFILE
operator|*
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|line
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
block|}
block|}
comment|/* If we have successfully built the indirect files table, then      merge the information in the two tables. */
if|if
condition|(
operator|!
name|subfiles
condition|)
block|{
name|free_file_buffer_tags
argument_list|(
name|file_buffer
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
specifier|register
name|int
name|tags_index
decl_stmt|;
name|long
name|header_length
decl_stmt|;
name|SEARCH_BINDING
name|binding
decl_stmt|;
comment|/* Find the length of the header of the file containing the indirect 	 tags table.  This header appears at the start of every file.  We 	 want the absolute position of each node within each subfile, so 	 we subtract the start of the containing subfile from the logical 	 position of the node, and then add the length of the header in. */
name|binding
operator|.
name|buffer
operator|=
name|file_buffer
operator|->
name|contents
expr_stmt|;
name|binding
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|binding
operator|.
name|end
operator|=
name|file_buffer
operator|->
name|filesize
expr_stmt|;
name|binding
operator|.
name|flags
operator|=
name|S_FoldCase
expr_stmt|;
name|header_length
operator|=
name|find_node_separator
argument_list|(
operator|&
name|binding
argument_list|)
expr_stmt|;
if|if
condition|(
name|header_length
operator|==
operator|-
literal|1
condition|)
name|header_length
operator|=
literal|0
expr_stmt|;
comment|/* Build the file buffer's list of subfiles. */
block|{
name|char
modifier|*
name|containing_dir
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|int
name|len_containing_dir
decl_stmt|;
name|containing_dir
operator|=
name|savestring
argument_list|(
name|file_buffer
operator|->
name|fullpath
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|rindex
argument_list|(
name|containing_dir
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
operator|*
name|temp
operator|=
literal|'\0'
expr_stmt|;
name|len_containing_dir
operator|=
name|strlen
argument_list|(
name|containing_dir
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|subfiles
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|file_buffer
operator|->
name|subfiles
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|i
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|subfiles
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|fullpath
decl_stmt|;
name|fullpath
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|subfiles
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
operator|+
name|len_containing_dir
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fullpath
argument_list|,
literal|"%s/%s"
argument_list|,
name|containing_dir
argument_list|,
name|subfiles
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
expr_stmt|;
name|file_buffer
operator|->
name|subfiles
index|[
name|i
index|]
operator|=
name|fullpath
expr_stmt|;
block|}
name|file_buffer
operator|->
name|subfiles
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|free
argument_list|(
name|containing_dir
argument_list|)
expr_stmt|;
block|}
comment|/* For each node in the file's tags table, remember the starting 	 position. */
for|for
control|(
name|tags_index
operator|=
literal|0
init|;
name|entry
operator|=
name|file_buffer
operator|->
name|tags
index|[
name|tags_index
index|]
condition|;
name|tags_index
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|subfiles
index|[
name|i
index|]
operator|&&
name|entry
operator|->
name|nodestart
operator|>=
name|subfiles
index|[
name|i
index|]
operator|->
name|first_byte
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* If the Info file containing the indirect tags table is 	     malformed, then give up. */
if|if
condition|(
operator|!
name|i
condition|)
block|{
comment|/* The Info file containing the indirect tags table is 		 malformed.  Give up. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|subfiles
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|subfiles
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|subfiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file_buffer
operator|->
name|subfiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|file_buffer
operator|->
name|subfiles
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|free_file_buffer_tags
argument_list|(
name|file_buffer
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* SUBFILES[i] is the index of the first subfile whose logical 	     first byte is greater than the logical offset of this node's 	     starting position.  This means that the subfile directly 	     preceding this one is the one containing the node. */
name|entry
operator|->
name|filename
operator|=
name|file_buffer
operator|->
name|subfiles
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|entry
operator|->
name|nodestart
operator|-=
name|subfiles
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|first_byte
expr_stmt|;
name|entry
operator|->
name|nodestart
operator|+=
name|header_length
expr_stmt|;
name|entry
operator|->
name|nodelen
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* We have successfully built the tags table.  Remember that it 	 was indirect. */
name|file_buffer
operator|->
name|flags
operator||=
name|N_TagsIndirect
expr_stmt|;
block|}
comment|/* Free the structures assigned to SUBFILES.  Free the names as well      as the structures themselves, then finally, the array. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|subfiles
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|subfiles
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|subfiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|subfiles
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return the node from FILE_BUFFER which matches NODENAME by searching    the tags table in FILE_BUFFER.  If the node could not be found, return    a NULL pointer. */
end_comment

begin_function
specifier|static
name|NODE
modifier|*
name|info_node_of_file_buffer_tags
parameter_list|(
name|file_buffer
parameter_list|,
name|nodename
parameter_list|)
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
name|char
modifier|*
name|nodename
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|TAG
modifier|*
name|tag
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tag
operator|=
name|file_buffer
operator|->
name|tags
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|nodename
argument_list|,
name|tag
operator|->
name|nodename
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FILE_BUFFER
modifier|*
name|subfile
decl_stmt|;
name|subfile
operator|=
name|info_find_file_internal
argument_list|(
name|tag
operator|->
name|filename
argument_list|,
name|INFO_NO_TAGS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subfile
condition|)
return|return
operator|(
operator|(
name|NODE
operator|*
operator|)
name|NULL
operator|)
return|;
if|if
condition|(
operator|!
name|subfile
operator|->
name|contents
condition|)
name|info_reload_file_buffer_contents
argument_list|(
name|subfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|subfile
operator|->
name|contents
condition|)
return|return
operator|(
operator|(
name|NODE
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* If we were able to find this file and load it, then return 	   the node within it. */
block|{
name|NODE
modifier|*
name|node
decl_stmt|;
name|node
operator|=
operator|(
name|NODE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NODE
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|filename
operator|=
operator|(
name|subfile
operator|->
name|fullpath
operator|)
expr_stmt|;
name|node
operator|->
name|nodename
operator|=
name|tag
operator|->
name|nodename
expr_stmt|;
name|node
operator|->
name|contents
operator|=
name|subfile
operator|->
name|contents
operator|+
name|tag
operator|->
name|nodestart
expr_stmt|;
name|node
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|parent
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|file_buffer
operator|->
name|flags
operator|&
name|N_HasTagsTable
condition|)
block|{
name|node
operator|->
name|flags
operator||=
name|N_HasTagsTable
expr_stmt|;
if|if
condition|(
name|file_buffer
operator|->
name|flags
operator|&
name|N_TagsIndirect
condition|)
block|{
name|node
operator|->
name|flags
operator||=
name|N_TagsIndirect
expr_stmt|;
name|node
operator|->
name|parent
operator|=
name|file_buffer
operator|->
name|fullpath
expr_stmt|;
block|}
block|}
if|if
condition|(
name|subfile
operator|->
name|flags
operator|&
name|N_IsCompressed
condition|)
name|node
operator|->
name|flags
operator||=
name|N_IsCompressed
expr_stmt|;
comment|/* If TAG->nodelen hasn't been calculated yet, then we aren't 	     in a position to trust the entry pointer.  Adjust things so 	     that ENTRY->nodestart gets the exact address of the start of 	     the node separator which starts this node, and NODE->contents 	     gets the address of the line defining this node.  If we cannot 	     do that, the node isn't really here. */
if|if
condition|(
name|tag
operator|->
name|nodelen
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|min
decl_stmt|,
name|max
decl_stmt|;
name|char
modifier|*
name|node_sep
decl_stmt|;
name|SEARCH_BINDING
name|node_body
decl_stmt|;
name|char
modifier|*
name|buff_end
decl_stmt|;
name|min
operator|=
name|max
operator|=
name|DEFAULT_INFO_FUDGE
expr_stmt|;
if|if
condition|(
name|tag
operator|->
name|nodestart
operator|<
name|DEFAULT_INFO_FUDGE
condition|)
name|min
operator|=
name|tag
operator|->
name|nodestart
expr_stmt|;
if|if
condition|(
name|DEFAULT_INFO_FUDGE
operator|>
operator|(
name|subfile
operator|->
name|filesize
operator|-
name|tag
operator|->
name|nodestart
operator|)
condition|)
name|max
operator|=
name|subfile
operator|->
name|filesize
operator|-
name|tag
operator|->
name|nodestart
expr_stmt|;
comment|/* NODE_SEP gets the address of the separator which defines 		 this node, or (char *)NULL if the node wasn't found. 		 NODE->contents is side-effected to point to right after 		 the separator. */
name|node_sep
operator|=
name|adjust_nodestart
argument_list|(
name|node
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_sep
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|NODE
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
comment|/* Readjust tag->nodestart. */
name|tag
operator|->
name|nodestart
operator|=
name|node_sep
operator|-
name|subfile
operator|->
name|contents
expr_stmt|;
comment|/* Calculate the length of the current node. */
name|buff_end
operator|=
name|subfile
operator|->
name|contents
operator|+
name|subfile
operator|->
name|filesize
expr_stmt|;
name|node_body
operator|.
name|buffer
operator|=
name|node
operator|->
name|contents
expr_stmt|;
name|node_body
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|node_body
operator|.
name|end
operator|=
name|buff_end
operator|-
name|node_body
operator|.
name|buffer
expr_stmt|;
name|node_body
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|tag
operator|->
name|nodelen
operator|=
name|get_node_length
argument_list|(
operator|&
name|node_body
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Since we know the length of this node, we have already 		 adjusted tag->nodestart to point to the exact start of 		 it.  Simply skip the node separator. */
name|node
operator|->
name|contents
operator|+=
name|skip_node_separator
argument_list|(
name|node
operator|->
name|contents
argument_list|)
expr_stmt|;
block|}
name|node
operator|->
name|nodelen
operator|=
name|tag
operator|->
name|nodelen
expr_stmt|;
return|return
operator|(
name|node
operator|)
return|;
block|}
block|}
comment|/* There was a tag table for this file, and the node wasn't found.      Return NULL, since this file doesn't contain the desired node. */
return|return
operator|(
operator|(
name|NODE
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		Managing file_buffers, nodes, and tags.		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function
specifier|static
name|FILE_BUFFER
modifier|*
name|make_file_buffer
parameter_list|()
block|{
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
name|file_buffer
operator|=
operator|(
name|FILE_BUFFER
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FILE_BUFFER
argument_list|)
argument_list|)
expr_stmt|;
name|file_buffer
operator|->
name|filename
operator|=
name|file_buffer
operator|->
name|fullpath
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|file_buffer
operator|->
name|contents
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|file_buffer
operator|->
name|tags
operator|=
operator|(
name|TAG
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|file_buffer
operator|->
name|subfiles
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|file_buffer
operator|->
name|tags_slots
operator|=
literal|0
expr_stmt|;
name|file_buffer
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|file_buffer
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add FILE_BUFFER to our list of already loaded info files. */
end_comment

begin_function
specifier|static
name|void
name|remember_info_file
parameter_list|(
name|file_buffer
parameter_list|)
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|info_loaded_files
operator|&&
name|info_loaded_files
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|add_pointer_to_array
argument_list|(
name|file_buffer
argument_list|,
name|i
argument_list|,
name|info_loaded_files
argument_list|,
name|info_loaded_files_slots
argument_list|,
literal|10
argument_list|,
name|FILE_BUFFER
operator|*
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Forget the contents, tags table, nodes list, and names of FILENAME. */
end_comment

begin_function
specifier|static
name|void
name|forget_info_file
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
if|if
condition|(
operator|!
name|info_loaded_files
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|file_buffer
operator|=
name|info_loaded_files
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|filename
argument_list|,
name|file_buffer
operator|->
name|filename
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|filename
argument_list|,
name|file_buffer
operator|->
name|fullpath
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|free
argument_list|(
name|file_buffer
operator|->
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file_buffer
operator|->
name|fullpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_buffer
operator|->
name|contents
condition|)
name|free
argument_list|(
name|file_buffer
operator|->
name|contents
argument_list|)
expr_stmt|;
comment|/* Note that free_file_buffer_tags () also kills the subfiles 	   list, since the subfiles list is only of use in conjunction 	   with tags. */
name|free_file_buffer_tags
argument_list|(
name|file_buffer
argument_list|)
expr_stmt|;
while|while
condition|(
name|info_loaded_files
index|[
name|i
index|]
operator|=
name|info_loaded_files
index|[
operator|++
name|i
index|]
condition|)
empty_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Free the tags (if any) associated with FILE_BUFFER. */
end_comment

begin_function
specifier|static
name|void
name|free_file_buffer_tags
parameter_list|(
name|file_buffer
parameter_list|)
name|FILE_BUFFER
modifier|*
name|file_buffer
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|file_buffer
operator|->
name|tags
condition|)
block|{
specifier|register
name|TAG
modifier|*
name|tag
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tag
operator|=
name|file_buffer
operator|->
name|tags
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|free_info_tag
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file_buffer
operator|->
name|tags
argument_list|)
expr_stmt|;
name|file_buffer
operator|->
name|tags
operator|=
operator|(
name|TAG
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
name|file_buffer
operator|->
name|tags_slots
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|file_buffer
operator|->
name|subfiles
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|file_buffer
operator|->
name|subfiles
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|file_buffer
operator|->
name|subfiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file_buffer
operator|->
name|subfiles
argument_list|)
expr_stmt|;
name|file_buffer
operator|->
name|subfiles
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free the data associated with TAG, as well as TAG itself. */
end_comment

begin_function
specifier|static
name|void
name|free_info_tag
parameter_list|(
name|tag
parameter_list|)
name|TAG
modifier|*
name|tag
decl_stmt|;
block|{
name|free
argument_list|(
name|tag
operator|->
name|nodename
argument_list|)
expr_stmt|;
comment|/* We don't free tag->filename, because that filename is part of the      subfiles list for the containing FILE_BUFFER.  free_info_tags ()      will free the subfiles when it is appropriate. */
name|free
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Load the contents of FILE_BUFFER->contents.  This function is called    when a file buffer was loaded, and then in order to conserve memory, the    file buffer's contents were freed and the pointer was zero'ed.  Note that    the file was already loaded at least once successfully, so the tags and/or    nodes members are still correctly filled. */
end_comment

begin_function
specifier|static
name|void
name|info_reload_file_buffer_contents
parameter_list|(
name|fb
parameter_list|)
name|FILE_BUFFER
modifier|*
name|fb
decl_stmt|;
block|{
name|fb
operator|->
name|flags
operator|&=
operator|~
name|N_IsCompressed
expr_stmt|;
comment|/* Let the filesystem do all the work for us. */
name|fb
operator|->
name|contents
operator|=
name|filesys_read_info_file
argument_list|(
name|fb
operator|->
name|fullpath
argument_list|,
operator|&
operator|(
name|fb
operator|->
name|filesize
operator|)
argument_list|,
operator|&
operator|(
name|fb
operator|->
name|finfo
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|filesize
operator|!=
name|fb
operator|->
name|finfo
operator|.
name|st_size
condition|)
name|fb
operator|->
name|flags
operator||=
name|N_IsCompressed
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the actual starting memory location of NODE, side-effecting    NODE->contents.  MIN and MAX are bounds for a search if one is necessary.    Because of the way that tags are implemented, the physical nodestart may    not actually be where the tag says it is.  If that is the case, but the    node was found anyway, set N_UpdateTags in NODE->flags.  If the node is    found, return non-zero.  NODE->contents is returned positioned right after    the node separator that precedes this node, while the return value is    position directly on the separator that precedes this node.  If the node    could not be found, return a NULL pointer. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|adjust_nodestart
parameter_list|(
name|node
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|)
name|NODE
modifier|*
name|node
decl_stmt|;
name|int
name|min
decl_stmt|,
name|max
decl_stmt|;
block|{
name|long
name|position
decl_stmt|;
name|SEARCH_BINDING
name|node_body
decl_stmt|;
comment|/* Define the node body. */
name|node_body
operator|.
name|buffer
operator|=
name|node
operator|->
name|contents
expr_stmt|;
name|node_body
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|node_body
operator|.
name|end
operator|=
name|max
expr_stmt|;
name|node_body
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* Try the optimal case first.  Who knows?  This file may actually be      formatted (mostly) correctly. */
if|if
condition|(
name|node_body
operator|.
name|buffer
index|[
literal|0
index|]
operator|!=
name|INFO_COOKIE
operator|&&
name|min
operator|>
literal|2
condition|)
name|node_body
operator|.
name|buffer
operator|-=
literal|3
expr_stmt|;
name|position
operator|=
name|find_node_separator
argument_list|(
operator|&
name|node_body
argument_list|)
expr_stmt|;
comment|/* If we found a node start, then check it out. */
if|if
condition|(
name|position
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|sep_len
decl_stmt|;
name|sep_len
operator|=
name|skip_node_separator
argument_list|(
name|node
operator|->
name|contents
argument_list|)
expr_stmt|;
comment|/* If we managed to skip a node separator, then check for this node 	 being the right one. */
if|if
condition|(
name|sep_len
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|nodedef
decl_stmt|,
modifier|*
name|nodestart
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|nodestart
operator|=
name|node_body
operator|.
name|buffer
operator|+
name|position
operator|+
name|sep_len
expr_stmt|;
name|nodedef
operator|=
name|nodestart
expr_stmt|;
name|offset
operator|=
name|string_in_line
argument_list|(
name|INFO_NODE_LABEL
argument_list|,
name|nodedef
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
operator|-
literal|1
condition|)
block|{
name|nodedef
operator|+=
name|offset
expr_stmt|;
name|nodedef
operator|+=
name|skip_whitespace
argument_list|(
name|nodedef
argument_list|)
expr_stmt|;
name|offset
operator|=
name|skip_node_characters
argument_list|(
name|nodedef
argument_list|,
name|DONT_SKIP_NEWLINES
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|==
name|strlen
argument_list|(
name|node
operator|->
name|nodename
argument_list|)
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|node
operator|->
name|nodename
argument_list|,
name|nodedef
argument_list|,
name|offset
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|node
operator|->
name|contents
operator|=
name|nodestart
expr_stmt|;
return|return
operator|(
name|node_body
operator|.
name|buffer
operator|+
name|position
operator|)
return|;
block|}
block|}
block|}
block|}
comment|/* Oh well, I guess we have to try to find it in a larger area. */
name|node_body
operator|.
name|buffer
operator|=
name|node
operator|->
name|contents
operator|-
name|min
expr_stmt|;
name|node_body
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|node_body
operator|.
name|end
operator|=
name|min
operator|+
name|max
expr_stmt|;
name|node_body
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|position
operator|=
name|find_node_in_binding
argument_list|(
name|node
operator|->
name|nodename
argument_list|,
operator|&
name|node_body
argument_list|)
expr_stmt|;
comment|/* If the node couldn't be found, we lose big. */
if|if
condition|(
name|position
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* Otherwise, the node was found, but the tags table could need updating      (if we used a tag to get here, that is).  Set the flag in NODE->flags. */
name|node
operator|->
name|contents
operator|=
name|node_body
operator|.
name|buffer
operator|+
name|position
expr_stmt|;
name|node
operator|->
name|contents
operator|+=
name|skip_node_separator
argument_list|(
name|node
operator|->
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|N_HasTagsTable
condition|)
name|node
operator|->
name|flags
operator||=
name|N_UpdateTags
expr_stmt|;
return|return
operator|(
name|node_body
operator|.
name|buffer
operator|+
name|position
operator|)
return|;
block|}
end_function

end_unit

