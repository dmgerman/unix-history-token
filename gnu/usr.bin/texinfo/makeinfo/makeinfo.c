begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Makeinfo -- convert texinfo format files into info files.     Copyright (C) 1987, 1992, 1993 Free Software Foundation, Inc.     This file is part of GNU Info.     Makeinfo is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY.  No author or distributor accepts    responsibility to anyone for the consequences of using it or for    whether it serves any particular purpose or works at all, unless he    says so in writing.  Refer to the GNU Emacs General Public License    for full details.     Everyone is granted permission to copy, modify and redistribute    Makeinfo, but only under the conditions described in the GNU Emacs    General Public License.   A copy of this license is supposed to    have been given to you along with GNU Emacs so you can know your    rights and responsibilities.  It should be in a file named COPYING.    Among other things, the copyright notice and this notice must be    preserved on all copies.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This is Makeinfo version 1.55.  If you change the version number of    Makeinfo, please change it here and at the lines reading:      int major_version = 1;     int minor_version = 55;     in the code below.     Makeinfo is authored by Brian Fox (bfox@ai.mit.edu). */
end_comment

begin_comment
comment|/* You can change some of the behaviour of Makeinfo by changing the    following defines: */
end_comment

begin_comment
comment|/* Define INDENT_PARAGRAPHS_IN_TABLE if you want the paragraphs which    appear within an @table, @ftable, or @itemize environment to have    standard paragraph indentation.  Without this, such paragraphs have    no starting indentation. */
end_comment

begin_comment
comment|/* #define INDENT_PARAGRAPHS_IN_TABLE */
end_comment

begin_comment
comment|/* Define DEFAULT_INDENTATION_INCREMENT as an integer which is the amount    that @example should increase indentation by.  This incremement is used    for all insertions which indent the enclosed text. */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_INDENTATION_INCREMENT
value|5
end_define

begin_comment
comment|/* Define PARAGRAPH_START_INDENT to be the amount of indentation that    the first lines of paragraphs receive by default, where no other    value has been specified.  Users can change this value on the command    line, with the +paragraph-indent option, or within the texinfo file,    with the @paragraphindent command. */
end_comment

begin_define
define|#
directive|define
name|PARAGRAPH_START_INDENT
value|3
end_define

begin_comment
comment|/* Define DEFAULT_PARAGRAPH_SPACING as the number of blank lines that you    wish to appear between paragraphs.  A value of 1 creates a single blank    line between paragraphs.  Paragraphs are defined by 2 or more consecutive    newlines in the input file (i.e., one or more blank lines). */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_PARAGRAPH_SPACING
value|1
end_define

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Include File Declarations       	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Indent #pragma so that older Cpp's don't try to parse it. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_AIX
argument_list|)
end_if

begin_pragma
pragma|#
directive|pragma
name|alloca
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _AIX */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VARARGS_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_VARARGS_H */
end_comment

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<perror.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRING_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_STRING_H */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TM_IN_SYS_TIME
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !TM_IN_SYS_TIME */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_FCNTL_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_SYS_FCNTL_H */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_ALLOCA_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !HAVE_ALLOCA_H */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_AIX
argument_list|)
end_if

begin_function_decl
specifier|extern
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_AIX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_ALLOCA_H */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__GNUC__ */
end_comment

begin_decl_stmt
name|void
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|isolate_nodename
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Non-zero means that we are currently hacking the insides of an    insertion which would use a fixed width font. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|in_fixed_width_font
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that start_paragraph () MUST be called before we pay    any attention to close_paragraph () calls. */
end_comment

begin_decl_stmt
name|int
name|must_start_paragraph
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some systems don't declare this function in pwd.h. */
end_comment

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			      Global Defines  			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Error levels */
end_comment

begin_define
define|#
directive|define
name|NO_ERROR
value|0
end_define

begin_define
define|#
directive|define
name|SYNTAX
value|2
end_define

begin_define
define|#
directive|define
name|FATAL
value|4
end_define

begin_comment
comment|/* How to allocate permanent storage for STRING. */
end_comment

begin_define
define|#
directive|define
name|savestring
parameter_list|(
name|x
parameter_list|)
define|\
value|((char *)strcpy ((char *)xmalloc (1 + ((x) ? strlen (x) : 0)), \ 		   (x) ? (x) : ""))
end_define

begin_comment
comment|/* C's standard macros don't check to make sure that the characters being    changed are within range.  So I have to check explicitly. */
end_comment

begin_comment
comment|/* GNU Library doesn't have toupper().  Until GNU gets this fixed, I will    have to do it. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|toupper
end_ifndef

begin_define
define|#
directive|define
name|toupper
parameter_list|(
name|c
parameter_list|)
value|((c) - 32)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|coerce_to_upper
parameter_list|(
name|c
parameter_list|)
value|((islower(c) ? toupper(c) : (c)))
end_define

begin_define
define|#
directive|define
name|coerce_to_lower
parameter_list|(
name|c
parameter_list|)
value|((isupper(c) ? tolower(c) : (c)))
end_define

begin_define
define|#
directive|define
name|control_character_bit
value|0x40
end_define

begin_comment
comment|/* %01000000, must be off. */
end_comment

begin_define
define|#
directive|define
name|meta_character_bit
value|0x080
end_define

begin_comment
comment|/* %10000000, must be on.  */
end_comment

begin_define
define|#
directive|define
name|CTL
parameter_list|(
name|c
parameter_list|)
value|((c)& (~control_character_bit))
end_define

begin_define
define|#
directive|define
name|UNCTL
parameter_list|(
name|c
parameter_list|)
value|coerce_to_upper(((c)|control_character_bit))
end_define

begin_define
define|#
directive|define
name|META
parameter_list|(
name|c
parameter_list|)
value|((c) | (meta_character_bit))
end_define

begin_define
define|#
directive|define
name|UNMETA
parameter_list|(
name|c
parameter_list|)
value|((c)& (~meta_character_bit))
end_define

begin_define
define|#
directive|define
name|whitespace
parameter_list|(
name|c
parameter_list|)
value|(((c) == '\t') || ((c) == ' '))
end_define

begin_define
define|#
directive|define
name|sentence_ender
parameter_list|(
name|c
parameter_list|)
value|((c) == '.' || (c) == '?' || (c) == '!')
end_define

begin_define
define|#
directive|define
name|cr_or_whitespace
parameter_list|(
name|c
parameter_list|)
value|(((c) == '\t') || ((c) == ' ') || ((c) == '\n'))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|isletter
end_ifndef

begin_define
define|#
directive|define
name|isletter
parameter_list|(
name|c
parameter_list|)
value|(((c)>= 'A'&& (c)<= 'Z') || ((c)>= 'a'&& (c)<= 'z'))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|isupper
end_ifndef

begin_define
define|#
directive|define
name|isupper
parameter_list|(
name|c
parameter_list|)
value|((c)>= 'A'&& (c)<= 'Z')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|isdigit
end_ifndef

begin_define
define|#
directive|define
name|isdigit
parameter_list|(
name|c
parameter_list|)
value|((c)>= '0'&& (c)<= '9')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|digit_value
end_ifndef

begin_define
define|#
directive|define
name|digit_value
parameter_list|(
name|c
parameter_list|)
value|((c) - '0')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|member
parameter_list|(
name|c
parameter_list|,
name|s
parameter_list|)
value|(strchr (s, c) != NULL)
end_define

begin_define
define|#
directive|define
name|COMMAND_PREFIX
value|'@'
end_define

begin_comment
comment|/* Stuff for splitting large files. */
end_comment

begin_define
define|#
directive|define
name|SPLIT_SIZE_THRESHOLD
value|70000
end_define

begin_comment
comment|/* What's good enough for Stallman... */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_SPLIT_SIZE
value|50000
end_define

begin_comment
comment|/* Is probably good enough for me. */
end_comment

begin_decl_stmt
name|int
name|splitting
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Always true for now. */
end_comment

begin_typedef
typedef|typedef
name|int
name|FUNCTION
parameter_list|()
function_decl|;
end_typedef

begin_comment
comment|/* So I can say FUNCTION *foo; */
end_comment

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			    Global Variables			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Global pointer to argv[0]. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current input file state. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|input_filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|input_text
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size_of_input_text
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|input_text_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|line_number
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|curchar
parameter_list|()
value|input_text[input_text_offset]
end_define

begin_define
define|#
directive|define
name|command_char
parameter_list|(
name|c
parameter_list|)
value|((!whitespace(c))&& \ 			 ((c) != '\n')&& \ 			 ((c) != '{')&& \ 			 ((c) != '}')&& \ 			 ((c) != '='))
end_define

begin_define
define|#
directive|define
name|skip_whitespace
parameter_list|()
value|while (input_text_offset != size_of_input_text \&& whitespace(curchar()))\   input_text_offset++
end_define

begin_comment
comment|/* Return non-zero if STRING is the text at input_text + input_text_offset,    else zero. */
end_comment

begin_define
define|#
directive|define
name|looking_at
parameter_list|(
name|string
parameter_list|)
define|\
value|(strncmp (input_text + input_text_offset, string, strlen (string)) == 0)
end_define

begin_comment
comment|/* And writing to the output. */
end_comment

begin_comment
comment|/* The output file name. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|output_filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pretty_output_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of the output file that the user elected to pass on the command line.    Such a name overrides any name found with the @setfilename command. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|command_output_filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A colon separated list of directories to search for files included    with @include.  This can be controlled with the `-I' option to makeinfo. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|include_files_path
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current output stream. */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|output_stream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Position in the output file. */
end_comment

begin_decl_stmt
name|int
name|output_position
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output paragraph buffer. */
end_comment

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|output_paragraph
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offset into OUTPUT_PARAGRAPH. */
end_comment

begin_decl_stmt
name|int
name|output_paragraph_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The output paragraph "cursor" horizontal position. */
end_comment

begin_decl_stmt
name|int
name|output_column
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means output_paragraph contains text. */
end_comment

begin_decl_stmt
name|int
name|paragraph_is_open
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INITIAL_PARAGRAPH_SPACE
value|5000
end_define

begin_decl_stmt
name|int
name|paragraph_buffer_len
init|=
name|INITIAL_PARAGRAPH_SPACE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Filling.. */
end_comment

begin_comment
comment|/* Non-zero indicates that filling will take place on long lines. */
end_comment

begin_decl_stmt
name|int
name|filling_enabled
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that words are not to be split, even in long lines.  This    gets changed for cm_w (). */
end_comment

begin_decl_stmt
name|int
name|non_splitting_words
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero indicates that filling a line also indents the new line. */
end_comment

begin_decl_stmt
name|int
name|indented_fill
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The column at which long lines are broken. */
end_comment

begin_decl_stmt
name|int
name|fill_column
init|=
literal|72
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The amount of indentation to apply at the start of each line. */
end_comment

begin_decl_stmt
name|int
name|current_indent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The amount of indentation to add at the starts of paragraphs.    0 means don't change existing indentation at paragraph starts.> 0 is amount to indent new paragraphs by.< 0 means indent to column zero by removing indentation if necessary.     This is normally zero, but some people prefer paragraph starts to be    somewhat more indented than paragraph bodies.  A pretty value for    this is 3. */
end_comment

begin_decl_stmt
name|int
name|paragraph_start_indent
init|=
name|PARAGRAPH_START_INDENT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that the use of paragraph_start_indent is inhibited.    @example uses this to line up the left columns of the example text.    A negative value for this variable is incremented each time it is used.    @noindent uses this to inhibit indentation for a single paragraph.  */
end_comment

begin_decl_stmt
name|int
name|inhibit_paragraph_indentation
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indentation that is pending insertion.  We have this for hacking lines    which look blank, but contain whitespace.  We want to treat those as    blank lines. */
end_comment

begin_decl_stmt
name|int
name|pending_indent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The amount that indentation increases/decreases by. */
end_comment

begin_decl_stmt
name|int
name|default_indentation_increment
init|=
name|DEFAULT_INDENTATION_INCREMENT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero indicates that indentation is temporarily turned off. */
end_comment

begin_decl_stmt
name|int
name|no_indent
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means forcing output text to be flushright. */
end_comment

begin_decl_stmt
name|int
name|force_flush_right
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that the footnote style for this document was set on    the command line, which overrides any other settings. */
end_comment

begin_decl_stmt
name|int
name|footnote_style_preset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that we automatically number footnotes that have no    specified marker. */
end_comment

begin_decl_stmt
name|int
name|number_footnotes
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current footnote number in this node.  Each time a new node is    started this is reset to 1. */
end_comment

begin_decl_stmt
name|int
name|current_footnote_number
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command name in the process of being hacked. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|command
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The index in our internal command table of the currently    executing command. */
end_comment

begin_decl_stmt
name|int
name|command_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A stack of file information records.  If a new file is read in with    "@input", we remember the old input file state on this stack. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|fstack
block|{
name|struct
name|fstack
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|line_number
decl_stmt|;
block|}
name|FSTACK
typedef|;
end_typedef

begin_decl_stmt
name|FSTACK
modifier|*
name|filestack
init|=
operator|(
name|FSTACK
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stuff for nodes. */
end_comment

begin_comment
comment|/* The current nodes node name. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|current_node
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current nodes section level. */
end_comment

begin_decl_stmt
name|int
name|current_section
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The filename of the current input file.  This is never freed. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|node_filename
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What we remember for each node. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|tentry
block|{
name|struct
name|tentry
modifier|*
name|next_ent
decl_stmt|;
name|char
modifier|*
name|node
decl_stmt|;
comment|/* name of this node. */
name|char
modifier|*
name|prev
decl_stmt|;
comment|/* name of "Prev:" for this node. */
name|char
modifier|*
name|next
decl_stmt|;
comment|/* name of "Next:" for this node. */
name|char
modifier|*
name|up
decl_stmt|;
comment|/* name of "Up:" for this node.   */
name|int
name|position
decl_stmt|;
comment|/* output file position of this node. */
name|int
name|line_no
decl_stmt|;
comment|/* defining line in source file. */
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* The file that this node was found in. */
name|int
name|touched
decl_stmt|;
comment|/* non-zero means this node has been referenced. */
name|int
name|flags
decl_stmt|;
comment|/* Room for growth.  Right now, contains 1 bit. */
block|}
name|TAG_ENTRY
typedef|;
end_typedef

begin_comment
comment|/* If node-a has a "Next" for node-b, but node-b has no "Prev" for node-a,    we turn on this flag bit in node-b's tag entry.  This means that when    it is time to validate node-b, we don't report an additional error    if there was no "Prev" field. */
end_comment

begin_define
define|#
directive|define
name|PREV_ERROR
value|0x1
end_define

begin_define
define|#
directive|define
name|NEXT_ERROR
value|0x2
end_define

begin_define
define|#
directive|define
name|UP_ERROR
value|0x4
end_define

begin_define
define|#
directive|define
name|NO_WARN
value|0x8
end_define

begin_define
define|#
directive|define
name|IS_TOP
value|0x10
end_define

begin_decl_stmt
name|TAG_ENTRY
modifier|*
name|tag_table
init|=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HAVE_MACROS
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
end_if

begin_comment
comment|/* Macro definitions for user-defined commands. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of the macro. */
name|char
modifier|*
name|definition
decl_stmt|;
comment|/* Definition text. */
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* File where this macro is defined. */
name|int
name|lineno
decl_stmt|;
comment|/* Line number within FILENAME. */
block|}
name|MACRO_DEF
typedef|;
end_typedef

begin_decl_stmt
name|void
name|add_macro
argument_list|()
decl_stmt|,
name|execute_macro
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|MACRO_DEF
modifier|*
name|find_macro
argument_list|()
decl_stmt|,
modifier|*
name|delete_macro
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_MACROS */
end_comment

begin_comment
comment|/* Menu reference, *note reference, and validation hacking. */
end_comment

begin_comment
comment|/* The various references that we know about. */
end_comment

begin_enum
enum|enum
name|reftype
block|{
name|menu_reference
block|,
name|followed_reference
block|}
enum|;
end_enum

begin_comment
comment|/* A structure to remember references with.  A reference to a node is    either an entry in a menu, or a cross-reference made with [px]ref. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|node_ref
block|{
name|struct
name|node_ref
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|node
decl_stmt|;
comment|/* Name of node referred to. */
name|char
modifier|*
name|containing_node
decl_stmt|;
comment|/* Name of node containing this reference. */
name|int
name|line_no
decl_stmt|;
comment|/* Line number where the reference occurs. */
name|int
name|section
decl_stmt|;
comment|/* Section level where the reference occurs. */
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* Name of file where the reference occurs. */
name|enum
name|reftype
name|type
decl_stmt|;
comment|/* Type of reference, either menu or note. */
block|}
name|NODE_REF
typedef|;
end_typedef

begin_comment
comment|/* The linked list of such structures. */
end_comment

begin_decl_stmt
name|NODE_REF
modifier|*
name|node_references
init|=
operator|(
name|NODE_REF
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag which tells us whether to examine menu lines or not. */
end_comment

begin_decl_stmt
name|int
name|in_menu
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags controlling the operation of the program. */
end_comment

begin_comment
comment|/* Default is to notify users of bad choices. */
end_comment

begin_decl_stmt
name|int
name|print_warnings
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default is to check node references. */
end_comment

begin_decl_stmt
name|int
name|validating
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means do not output "Node: Foo" for node separations. */
end_comment

begin_decl_stmt
name|int
name|no_headers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of errors that we tolerate on a given fileset. */
end_comment

begin_decl_stmt
name|int
name|max_error_level
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of references to a single node before complaining. */
end_comment

begin_decl_stmt
name|int
name|reference_warning_limit
init|=
literal|1000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means print out information about what is going on when it    is going on. */
end_comment

begin_decl_stmt
name|int
name|verbose_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of commands that we hack in texinfo.  Each one    has an associated function.  When the command is encountered in the    text, the associated function is called with START as the argument.    If the function expects arguments in braces, it remembers itself on    the stack.  When the corresponding close brace is encountered, the    function is called with END as the argument. */
end_comment

begin_define
define|#
directive|define
name|START
value|0
end_define

begin_define
define|#
directive|define
name|END
value|1
end_define

begin_typedef
typedef|typedef
struct|struct
name|brace_element
block|{
name|struct
name|brace_element
modifier|*
name|next
decl_stmt|;
name|FUNCTION
modifier|*
name|proc
decl_stmt|;
name|int
name|pos
decl_stmt|,
name|line
decl_stmt|;
block|}
name|BRACE_ELEMENT
typedef|;
end_typedef

begin_decl_stmt
name|BRACE_ELEMENT
modifier|*
name|brace_stack
init|=
operator|(
name|BRACE_ELEMENT
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations. */
end_comment

begin_decl_stmt
name|int
name|insert_self
argument_list|()
decl_stmt|,
name|cm_ignore_line
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cm_tex
argument_list|()
decl_stmt|,
name|cm_asterisk
argument_list|()
decl_stmt|,
name|cm_dots
argument_list|()
decl_stmt|,
name|cm_bullet
argument_list|()
decl_stmt|,
name|cm_TeX
argument_list|()
decl_stmt|,
name|cm_copyright
argument_list|()
decl_stmt|,
name|cm_code
argument_list|()
decl_stmt|,
name|cm_samp
argument_list|()
decl_stmt|,
name|cm_file
argument_list|()
decl_stmt|,
name|cm_kbd
argument_list|()
decl_stmt|,
name|cm_key
argument_list|()
decl_stmt|,
name|cm_ctrl
argument_list|()
decl_stmt|,
name|cm_var
argument_list|()
decl_stmt|,
name|cm_dfn
argument_list|()
decl_stmt|,
name|cm_emph
argument_list|()
decl_stmt|,
name|cm_strong
argument_list|()
decl_stmt|,
name|cm_cite
argument_list|()
decl_stmt|,
name|cm_italic
argument_list|()
decl_stmt|,
name|cm_bold
argument_list|()
decl_stmt|,
name|cm_roman
argument_list|()
decl_stmt|,
name|cm_title
argument_list|()
decl_stmt|,
name|cm_w
argument_list|()
decl_stmt|,
name|cm_refill
argument_list|()
decl_stmt|,
name|cm_titlefont
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cm_chapter
argument_list|()
decl_stmt|,
name|cm_unnumbered
argument_list|()
decl_stmt|,
name|cm_appendix
argument_list|()
decl_stmt|,
name|cm_top
argument_list|()
decl_stmt|,
name|cm_section
argument_list|()
decl_stmt|,
name|cm_unnumberedsec
argument_list|()
decl_stmt|,
name|cm_appendixsec
argument_list|()
decl_stmt|,
name|cm_subsection
argument_list|()
decl_stmt|,
name|cm_unnumberedsubsec
argument_list|()
decl_stmt|,
name|cm_appendixsubsec
argument_list|()
decl_stmt|,
name|cm_subsubsection
argument_list|()
decl_stmt|,
name|cm_unnumberedsubsubsec
argument_list|()
decl_stmt|,
name|cm_appendixsubsubsec
argument_list|()
decl_stmt|,
name|cm_heading
argument_list|()
decl_stmt|,
name|cm_chapheading
argument_list|()
decl_stmt|,
name|cm_subheading
argument_list|()
decl_stmt|,
name|cm_subsubheading
argument_list|()
decl_stmt|,
name|cm_majorheading
argument_list|()
decl_stmt|,
name|cm_raisesections
argument_list|()
decl_stmt|,
name|cm_lowersections
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All @defxxx commands map to cm_defun (). */
end_comment

begin_function_decl
name|int
name|cm_defun
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|cm_node
argument_list|()
decl_stmt|,
name|cm_menu
argument_list|()
decl_stmt|,
name|cm_xref
argument_list|()
decl_stmt|,
name|cm_ftable
argument_list|()
decl_stmt|,
name|cm_vtable
argument_list|()
decl_stmt|,
name|cm_pxref
argument_list|()
decl_stmt|,
name|cm_inforef
argument_list|()
decl_stmt|,
name|cm_quotation
argument_list|()
decl_stmt|,
name|cm_display
argument_list|()
decl_stmt|,
name|cm_itemize
argument_list|()
decl_stmt|,
name|cm_enumerate
argument_list|()
decl_stmt|,
name|cm_table
argument_list|()
decl_stmt|,
name|cm_itemx
argument_list|()
decl_stmt|,
name|cm_noindent
argument_list|()
decl_stmt|,
name|cm_setfilename
argument_list|()
decl_stmt|,
name|cm_br
argument_list|()
decl_stmt|,
name|cm_sp
argument_list|()
decl_stmt|,
name|cm_page
argument_list|()
decl_stmt|,
name|cm_group
argument_list|()
decl_stmt|,
name|cm_center
argument_list|()
decl_stmt|,
name|cm_include
argument_list|()
decl_stmt|,
name|cm_bye
argument_list|()
decl_stmt|,
name|cm_item
argument_list|()
decl_stmt|,
name|cm_end
argument_list|()
decl_stmt|,
name|cm_infoinclude
argument_list|()
decl_stmt|,
name|cm_ifinfo
argument_list|()
decl_stmt|,
name|cm_kindex
argument_list|()
decl_stmt|,
name|cm_cindex
argument_list|()
decl_stmt|,
name|cm_findex
argument_list|()
decl_stmt|,
name|cm_pindex
argument_list|()
decl_stmt|,
name|cm_vindex
argument_list|()
decl_stmt|,
name|cm_tindex
argument_list|()
decl_stmt|,
name|cm_asis
argument_list|()
decl_stmt|,
name|cm_synindex
argument_list|()
decl_stmt|,
name|cm_printindex
argument_list|()
decl_stmt|,
name|cm_minus
argument_list|()
decl_stmt|,
name|cm_footnote
argument_list|()
decl_stmt|,
name|cm_force_abbreviated_whitespace
argument_list|()
decl_stmt|,
name|cm_example
argument_list|()
decl_stmt|,
name|cm_smallexample
argument_list|()
decl_stmt|,
name|cm_lisp
argument_list|()
decl_stmt|,
name|cm_format
argument_list|()
decl_stmt|,
name|cm_exdent
argument_list|()
decl_stmt|,
name|cm_defindex
argument_list|()
decl_stmt|,
name|cm_defcodeindex
argument_list|()
decl_stmt|,
name|cm_sc
argument_list|()
decl_stmt|,
name|cm_result
argument_list|()
decl_stmt|,
name|cm_expansion
argument_list|()
decl_stmt|,
name|cm_equiv
argument_list|()
decl_stmt|,
name|cm_print
argument_list|()
decl_stmt|,
name|cm_error
argument_list|()
decl_stmt|,
name|cm_point
argument_list|()
decl_stmt|,
name|cm_today
argument_list|()
decl_stmt|,
name|cm_flushleft
argument_list|()
decl_stmt|,
name|cm_flushright
argument_list|()
decl_stmt|,
name|cm_smalllisp
argument_list|()
decl_stmt|,
name|cm_finalout
argument_list|()
decl_stmt|,
name|cm_math
argument_list|()
decl_stmt|,
name|cm_cartouche
argument_list|()
decl_stmt|,
name|cm_ignore_sentence_ender
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Conditionals. */
end_comment

begin_decl_stmt
name|int
name|cm_set
argument_list|()
decl_stmt|,
name|cm_clear
argument_list|()
decl_stmt|,
name|cm_ifset
argument_list|()
decl_stmt|,
name|cm_ifclear
argument_list|()
decl_stmt|,
name|cm_value
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
end_if

begin_comment
comment|/* Define a user-defined command which is simple substitution. */
end_comment

begin_decl_stmt
name|int
name|cm_macro
argument_list|()
decl_stmt|,
name|cm_unmacro
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_MACROS */
end_comment

begin_comment
comment|/* Options. */
end_comment

begin_decl_stmt
name|int
name|cm_paragraphindent
argument_list|()
decl_stmt|,
name|cm_footnotestyle
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Internals. */
end_comment

begin_decl_stmt
name|int
name|do_nothing
argument_list|()
decl_stmt|,
name|command_name_condition
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|misplaced_brace
argument_list|()
decl_stmt|,
name|cm_obsolete
argument_list|()
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|FUNCTION
modifier|*
name|proc
decl_stmt|;
name|int
name|argument_in_braces
decl_stmt|;
block|}
name|COMMAND
typedef|;
end_typedef

begin_comment
comment|/* Stuff for defining commands on the fly. */
end_comment

begin_decl_stmt
name|COMMAND
modifier|*
modifier|*
name|user_command_array
init|=
operator|(
name|COMMAND
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|user_command_array_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NO_BRACE_ARGS
value|0
end_define

begin_define
define|#
directive|define
name|BRACE_ARGS
value|1
end_define

begin_decl_stmt
specifier|static
name|COMMAND
name|CommandTable
index|[]
init|=
block|{
block|{
literal|"!"
block|,
name|cm_ignore_sentence_ender
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"'"
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"*"
block|,
name|cm_asterisk
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"."
block|,
name|cm_ignore_sentence_ender
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|":"
block|,
name|cm_force_abbreviated_whitespace
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"?"
block|,
name|cm_ignore_sentence_ender
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"|"
block|,
name|do_nothing
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"@"
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|" "
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"\n"
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"TeX"
block|,
name|cm_TeX
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"`"
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"appendix"
block|,
name|cm_appendix
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"appendixsection"
block|,
name|cm_appendixsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"appendixsec"
block|,
name|cm_appendixsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"appendixsubsec"
block|,
name|cm_appendixsubsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"appendixsubsubsec"
block|,
name|cm_appendixsubsubsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"asis"
block|,
name|cm_asis
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"b"
block|,
name|cm_bold
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"br"
block|,
name|cm_br
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"bullet"
block|,
name|cm_bullet
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"bye"
block|,
name|cm_bye
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"c"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"cartouche"
block|,
name|cm_cartouche
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"center"
block|,
name|cm_center
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"chapheading"
block|,
name|cm_chapheading
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"chapter"
block|,
name|cm_chapter
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"cindex"
block|,
name|cm_cindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"cite"
block|,
name|cm_cite
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"clear"
block|,
name|cm_clear
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"code"
block|,
name|cm_code
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"comment"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"contents"
block|,
name|do_nothing
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"copyright"
block|,
name|cm_copyright
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"ctrl"
block|,
name|cm_ctrl
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"defcodeindex"
block|,
name|cm_defcodeindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defindex"
block|,
name|cm_defindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"dfn"
block|,
name|cm_dfn
block|,
name|BRACE_ARGS
block|}
block|,
comment|/* The `def' commands. */
block|{
literal|"deffn"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deffnx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defun"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defunx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defmac"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defmacx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defspec"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defspecx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defvr"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defvrx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defvar"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defvarx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defopt"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defoptx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypefn"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypefnx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypefun"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypefunx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypevr"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypevrx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypevar"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypevarx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defcv"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defcvx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defivar"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defivarx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defop"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defopx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defmethod"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"defmethodx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypemethod"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftypemethodx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftp"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"deftpx"
block|,
name|cm_defun
block|,
name|NO_BRACE_ARGS
block|}
block|,
comment|/* The end of the `def' commands. */
block|{
literal|"display"
block|,
name|cm_display
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"dots"
block|,
name|cm_dots
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"dmn"
block|,
name|do_nothing
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"emph"
block|,
name|cm_emph
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"end"
block|,
name|cm_end
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"enumerate"
block|,
name|cm_enumerate
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"equiv"
block|,
name|cm_equiv
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"error"
block|,
name|cm_error
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"example"
block|,
name|cm_example
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"exdent"
block|,
name|cm_exdent
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"expansion"
block|,
name|cm_expansion
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"file"
block|,
name|cm_file
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"findex"
block|,
name|cm_findex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"finalout"
block|,
name|do_nothing
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"flushleft"
block|,
name|cm_flushleft
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"flushright"
block|,
name|cm_flushright
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"format"
block|,
name|cm_format
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ftable"
block|,
name|cm_ftable
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"group"
block|,
name|cm_group
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"heading"
block|,
name|cm_heading
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"headings"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"i"
block|,
name|cm_italic
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"iappendix"
block|,
name|cm_appendix
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iappendixsection"
block|,
name|cm_appendixsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iappendixsec"
block|,
name|cm_appendixsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iappendixsubsec"
block|,
name|cm_appendixsubsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iappendixsubsubsec"
block|,
name|cm_appendixsubsubsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ichapter"
block|,
name|cm_chapter
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ifclear"
block|,
name|cm_ifclear
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ifinfo"
block|,
name|cm_ifinfo
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ifset"
block|,
name|cm_ifset
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iftex"
block|,
name|command_name_condition
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ignore"
block|,
name|command_name_condition
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"include"
block|,
name|cm_include
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"inforef"
block|,
name|cm_inforef
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"input"
block|,
name|cm_include
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"isection"
block|,
name|cm_section
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"isubsection"
block|,
name|cm_subsection
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"isubsubsection"
block|,
name|cm_subsubsection
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"item"
block|,
name|cm_item
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"itemize"
block|,
name|cm_itemize
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"itemx"
block|,
name|cm_itemx
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iunnumbered"
block|,
name|cm_unnumbered
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iunnumberedsec"
block|,
name|cm_unnumberedsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iunnumberedsubsec"
block|,
name|cm_unnumberedsubsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"iunnumberedsubsubsec"
block|,
name|cm_unnumberedsubsubsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"kbd"
block|,
name|cm_kbd
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"key"
block|,
name|cm_key
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"kindex"
block|,
name|cm_kindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"lowersections"
block|,
name|cm_lowersections
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"lisp"
block|,
name|cm_lisp
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"macro"
block|,
name|cm_macro
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"majorheading"
block|,
name|cm_majorheading
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"math"
block|,
name|cm_math
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"menu"
block|,
name|cm_menu
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"minus"
block|,
name|cm_minus
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"need"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"node"
block|,
name|cm_node
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"noindent"
block|,
name|cm_noindent
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"nwnode"
block|,
name|cm_node
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"overfullrule"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"page"
block|,
name|do_nothing
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"pindex"
block|,
name|cm_pindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"point"
block|,
name|cm_point
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"print"
block|,
name|cm_print
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"printindex"
block|,
name|cm_printindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"pxref"
block|,
name|cm_pxref
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"quotation"
block|,
name|cm_quotation
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"r"
block|,
name|cm_roman
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"raisesections"
block|,
name|cm_raisesections
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"ref"
block|,
name|cm_xref
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"refill"
block|,
name|cm_refill
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"result"
block|,
name|cm_result
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"samp"
block|,
name|cm_samp
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"sc"
block|,
name|cm_sc
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"section"
block|,
name|cm_section
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"set"
block|,
name|cm_set
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"setchapternewpage"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"setchapterstyle"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"setfilename"
block|,
name|cm_setfilename
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"settitle"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"shortcontents"
block|,
name|do_nothing
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"shorttitlepage"
block|,
name|command_name_condition
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"smallbook"
block|,
name|cm_ignore_line
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"smallexample"
block|,
name|cm_smallexample
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"smalllisp"
block|,
name|cm_smalllisp
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"sp"
block|,
name|cm_sp
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"strong"
block|,
name|cm_strong
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"subheading"
block|,
name|cm_subheading
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"subsection"
block|,
name|cm_subsection
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"subsubheading"
block|,
name|cm_subsubheading
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"subsubsection"
block|,
name|cm_subsubsection
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"summarycontents"
block|,
name|do_nothing
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"syncodeindex"
block|,
name|cm_synindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"synindex"
block|,
name|cm_synindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"t"
block|,
name|cm_title
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"table"
block|,
name|cm_table
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"tex"
block|,
name|command_name_condition
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"tindex"
block|,
name|cm_tindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"titlefont"
block|,
name|cm_titlefont
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"titlepage"
block|,
name|command_name_condition
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"titlespec"
block|,
name|command_name_condition
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"today"
block|,
name|cm_today
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"top"
block|,
name|cm_top
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"unmacro"
block|,
name|cm_unmacro
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"unnumbered"
block|,
name|cm_unnumbered
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"unnumberedsec"
block|,
name|cm_unnumberedsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"unnumberedsubsec"
block|,
name|cm_unnumberedsubsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"unnumberedsubsubsec"
block|,
name|cm_unnumberedsubsubsec
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"value"
block|,
name|cm_value
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"var"
block|,
name|cm_var
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"vindex"
block|,
name|cm_vindex
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"vtable"
block|,
name|cm_vtable
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"w"
block|,
name|cm_w
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"xref"
block|,
name|cm_xref
block|,
name|BRACE_ARGS
block|}
block|,
block|{
literal|"{"
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"}"
block|,
name|insert_self
block|,
name|NO_BRACE_ARGS
block|}
block|,
comment|/* Some obsoleted commands. */
block|{
literal|"infotop"
block|,
name|cm_obsolete
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"infounnumbered"
block|,
name|cm_obsolete
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"infounnumberedsec"
block|,
name|cm_obsolete
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"infounnumberedsubsec"
block|,
name|cm_obsolete
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"infounnumberedsubsubsec"
block|,
name|cm_obsolete
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"infoappendix"
block|,
name|cm_obsolete
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"infoappendixsec"
block|,
name|cm_obsolete
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"infoappendixsubsec"
block|,
name|cm_obsolete
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"infoappendixsubsubsec"
block|,
name|cm_obsolete
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"infochapter"
block|,
name|cm_obsolete
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"infosection"
block|,
name|cm_obsolete
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"infosubsection"
block|,
name|cm_obsolete
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"infosubsubsection"
block|,
name|cm_obsolete
block|,
name|NO_BRACE_ARGS
block|}
block|,
comment|/* Now @include does what this was supposed to. */
block|{
literal|"infoinclude"
block|,
name|cm_infoinclude
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"footnote"
block|,
name|cm_footnote
block|,
name|NO_BRACE_ARGS
block|}
block|,
comment|/* self-arg eater */
block|{
literal|"footnotestyle"
block|,
name|cm_footnotestyle
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
literal|"paragraphindent"
block|,
name|cm_paragraphindent
block|,
name|NO_BRACE_ARGS
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|FUNCTION
operator|*
operator|)
name|NULL
block|}
block|,
name|NO_BRACE_ARGS
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|major_version
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|minor_version
init|=
literal|55
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"error-limit"
block|,
literal|1
block|,
literal|0
block|,
literal|'e'
block|}
block|,
comment|/* formerly -el */
block|{
literal|"fill-column"
block|,
literal|1
block|,
literal|0
block|,
literal|'f'
block|}
block|,
comment|/* formerly -fc */
block|{
literal|"footnote-style"
block|,
literal|1
block|,
literal|0
block|,
literal|'s'
block|}
block|,
comment|/* formerly -ft */
block|{
literal|"no-headers"
block|,
literal|0
block|,
operator|&
name|no_headers
block|,
literal|1
block|}
block|,
comment|/* Do not output Node: foo */
block|{
literal|"no-pointer-validate"
block|,
literal|0
block|,
operator|&
name|validating
block|,
literal|0
block|}
block|,
comment|/* formerly -nv */
block|{
literal|"no-validate"
block|,
literal|0
block|,
operator|&
name|validating
block|,
literal|0
block|}
block|,
comment|/* formerly -nv */
block|{
literal|"no-split"
block|,
literal|0
block|,
operator|&
name|splitting
block|,
literal|0
block|}
block|,
comment|/* formerly -ns */
block|{
literal|"no-warn"
block|,
literal|0
block|,
operator|&
name|print_warnings
block|,
literal|0
block|}
block|,
comment|/* formerly -nw */
block|{
literal|"number-footnotes"
block|,
literal|0
block|,
operator|&
name|number_footnotes
block|,
literal|1
block|}
block|,
block|{
literal|"no-number-footnotes"
block|,
literal|0
block|,
operator|&
name|number_footnotes
block|,
literal|0
block|}
block|,
block|{
literal|"output"
block|,
literal|1
block|,
literal|0
block|,
literal|'o'
block|}
block|,
block|{
literal|"paragraph-indent"
block|,
literal|1
block|,
literal|0
block|,
literal|'p'
block|}
block|,
comment|/* formerly -pi */
block|{
literal|"reference-limit"
block|,
literal|1
block|,
literal|0
block|,
literal|'r'
block|}
block|,
comment|/* formerly -rl */
block|{
literal|"verbose"
block|,
literal|0
block|,
operator|&
name|verbose_mode
block|,
literal|1
block|}
block|,
comment|/* formerly -verbose */
block|{
literal|"version"
block|,
literal|0
block|,
literal|0
block|,
literal|'V'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Values for calling handle_variable_internal (). */
end_comment

begin_define
define|#
directive|define
name|SET
value|1
end_define

begin_define
define|#
directive|define
name|CLEAR
value|2
end_define

begin_define
define|#
directive|define
name|IFSET
value|3
end_define

begin_define
define|#
directive|define
name|IFCLEAR
value|4
end_define

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Main ()  Start of code  		    */
end_comment

begin_comment
comment|/*					        		    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* For each file mentioned in the command line, process it, turning    texinfo commands into wonderfully formatted output text. */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|extern
name|int
name|errors_printed
decl_stmt|;
name|char
modifier|*
name|filename_part
parameter_list|()
function_decl|;
name|int
name|c
decl_stmt|,
name|ind
decl_stmt|;
comment|/* The name of this program is the last filename in argv[0]. */
name|progname
operator|=
name|filename_part
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Parse argument flags from the input line. */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"D:U:I:f:o:p:e:r:s:V"
argument_list|,
name|long_options
argument_list|,
operator|&
name|ind
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
operator|&&
name|long_options
index|[
name|ind
index|]
operator|.
name|flag
operator|==
literal|0
condition|)
name|c
operator|=
name|long_options
index|[
name|ind
index|]
operator|.
name|val
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* User specified variable to set or clear? */
case|case
literal|'D'
case|:
case|case
literal|'U'
case|:
name|handle_variable_internal
argument_list|(
operator|(
name|c
operator|==
literal|'D'
operator|)
condition|?
name|SET
else|:
name|CLEAR
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
comment|/* User specified include file path? */
case|case
literal|'I'
case|:
if|if
condition|(
operator|!
name|include_files_path
condition|)
name|include_files_path
operator|=
name|savestring
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|include_files_path
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|include_files_path
argument_list|,
literal|2
operator|+
name|strlen
argument_list|(
name|include_files_path
argument_list|)
operator|+
name|strlen
argument_list|(
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|include_files_path
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|include_files_path
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
comment|/* User specified fill_column? */
case|case
literal|'f'
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|fill_column
argument_list|)
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
comment|/* User specified output file? */
case|case
literal|'o'
case|:
name|command_output_filename
operator|=
name|savestring
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
comment|/* User specified paragraph indent (paragraph_start_index)? */
case|case
literal|'p'
case|:
if|if
condition|(
name|set_paragraph_indent
argument_list|(
name|optarg
argument_list|)
operator|<
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
comment|/* User specified error level? */
case|case
literal|'e'
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|max_error_level
argument_list|)
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
comment|/* User specified reference warning limit? */
case|case
literal|'r'
case|:
if|if
condition|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|reference_warning_limit
argument_list|)
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
comment|/* User specified footnote style? */
case|case
literal|'s'
case|:
if|if
condition|(
name|set_footnote_style
argument_list|(
name|optarg
argument_list|)
operator|<
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
name|footnote_style_preset
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* User requested version info? */
case|case
literal|'V'
case|:
name|print_version_info
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|NO_ERROR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|verbose_mode
condition|)
name|print_version_info
argument_list|()
expr_stmt|;
comment|/* Remaining arguments are file names of texinfo files.      Convert them, one by one. */
while|while
condition|(
name|optind
operator|!=
name|argc
condition|)
name|convert
argument_list|(
name|argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|errors_printed
condition|)
name|exit
argument_list|(
name|SYNTAX
argument_list|)
expr_stmt|;
else|else
name|exit
argument_list|(
name|NO_ERROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Display the version info of this invocation of Makeinfo. */
end_comment

begin_macro
name|print_version_info
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"This is GNU Makeinfo version %d.%d.\n"
argument_list|,
name|major_version
argument_list|,
name|minor_version
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Generic Utilities			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Just like malloc, but kills the program in case of fatal error. */
end_comment

begin_function
name|void
modifier|*
name|xmalloc
parameter_list|(
name|nbytes
parameter_list|)
name|int
name|nbytes
decl_stmt|;
block|{
name|void
modifier|*
name|temp
init|=
operator|(
name|void
operator|*
operator|)
name|malloc
argument_list|(
name|nbytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|nbytes
operator|&&
name|temp
operator|==
operator|(
name|void
operator|*
operator|)
name|NULL
condition|)
name|memory_error
argument_list|(
literal|"xmalloc"
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Like realloc (), but barfs if there isn't enough memory. */
end_comment

begin_function
name|void
modifier|*
name|xrealloc
parameter_list|(
name|pointer
parameter_list|,
name|nbytes
parameter_list|)
name|void
modifier|*
name|pointer
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
name|void
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
operator|!
name|pointer
condition|)
name|temp
operator|=
operator|(
name|void
operator|*
operator|)
name|xmalloc
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
operator|(
name|void
operator|*
operator|)
name|realloc
argument_list|(
name|pointer
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|&&
operator|!
name|temp
condition|)
name|memory_error
argument_list|(
literal|"xrealloc"
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_macro
name|memory_error
argument_list|(
argument|callers_name
argument_list|,
argument|bytes_wanted
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|callers_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bytes_wanted
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|printable_string
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|printable_string
argument_list|,
literal|"Virtual memory exhausted in %s ()!  Needed %d bytes."
argument_list|,
name|callers_name
argument_list|,
name|bytes_wanted
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|printable_string
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Tell the user how to use this program. */
end_comment

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [options] texinfo-file...\n\ \n\ This program accepts as input files of texinfo commands and text\n\ and outputs a file suitable for reading with GNU Info.\n\ \n\ The options are:\n\ `-I DIR'              to add DIR to the directory search list for including\n\                       files with the `@include' command.\n\ -D VAR                to define a variable, as with `@set'.\n\ -U VAR                to undefine a variable, as with `@clear'.\n\ `--no-validate'       to suppress node cross reference validation.\n\ `--no-warn'           to suppress warning messages (errors are still output).\n\ `--no-split'          to suppress the splitting of large files.\n\ `--no-headers'        to suppress the output of Node: Foo headers.\n\ `--verbose'           to print information about what is being done.\n\ `--version'           to print the version number of Makeinfo.\n\ `--output FILE' or `-o FILE'\n\                       to specify the output file.  When you specify the\n\                       output file in this way, any `@setfilename' in the\n\                       input file is ignored.\n\ `--paragraph-indent NUM'\n\                       to set the paragraph indent to NUM (default %d).\n\ `--fill-column NUM'   to set the filling column to NUM (default %d).\n\ `--error-limit NUM'   to set the error limit to NUM (default %d).\n\ `--reference-limit NUM'\n\                       to set the reference warning limit to NUM (default %d).\n\ `--footnote-style STYLE'\n\                       to set the footnote style to STYLE.  STYLE should\n\                       either be `separate' to place footnotes in their own\n\                       node, or `end', to place the footnotes at the end of\n\                       the node in which they are defined (the default).\n\n"
argument_list|,
name|progname
argument_list|,
name|paragraph_start_indent
argument_list|,
name|fill_column
argument_list|,
name|max_error_level
argument_list|,
name|reference_warning_limit
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Manipulating Lists      		    */
end_comment

begin_comment
comment|/*					        		    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|generic_list
block|{
name|struct
name|generic_list
modifier|*
name|next
decl_stmt|;
block|}
name|GENERIC_LIST
typedef|;
end_typedef

begin_comment
comment|/* Reverse the chain of structures in LIST.  Output the new head    of the chain.  You should always assign the output value of this    function to something, or you will lose the chain. */
end_comment

begin_function
name|GENERIC_LIST
modifier|*
name|reverse_list
parameter_list|(
name|list
parameter_list|)
specifier|register
name|GENERIC_LIST
modifier|*
name|list
decl_stmt|;
block|{
specifier|register
name|GENERIC_LIST
modifier|*
name|next
decl_stmt|;
specifier|register
name|GENERIC_LIST
modifier|*
name|prev
init|=
operator|(
name|GENERIC_LIST
operator|*
operator|)
name|NULL
decl_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|next
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|list
operator|->
name|next
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|next
expr_stmt|;
block|}
return|return
operator|(
name|prev
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Pushing and Popping Files       	    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Find and load the file named FILENAME.  Return a pointer to    the loaded file, or NULL if it can't be loaded. */
end_comment

begin_function
name|char
modifier|*
name|find_and_load
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|struct
name|stat
name|fileinfo
decl_stmt|;
name|int
name|file
init|=
operator|-
literal|1
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|fullpath
decl_stmt|,
modifier|*
name|result
decl_stmt|,
modifier|*
name|get_file_info_in_path
argument_list|()
decl_stmt|;
name|result
operator|=
name|fullpath
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|fullpath
operator|=
name|get_file_info_in_path
argument_list|(
name|filename
argument_list|,
name|include_files_path
argument_list|,
operator|&
name|fileinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fullpath
condition|)
goto|goto
name|error_exit
goto|;
name|filename
operator|=
name|fullpath
expr_stmt|;
name|file
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|<
literal|0
condition|)
goto|goto
name|error_exit
goto|;
comment|/* Load the file. */
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|fileinfo
operator|.
name|st_size
argument_list|)
expr_stmt|;
comment|/* VMS stat lies about the st_size value.  The actual number of      readable bytes is always less than this value.  The arcane      mysteries of VMS/RMS are too much to probe, so this hack     suffices to make things work. */
if|#
directive|if
name|defined
argument_list|(
name|VMS
argument_list|)
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|file
argument_list|,
name|result
operator|+
name|count
argument_list|,
name|fileinfo
operator|.
name|st_size
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|count
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
comment|/* !VMS */
name|count
operator|=
name|fileinfo
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|file
argument_list|,
name|result
argument_list|,
name|fileinfo
operator|.
name|st_size
argument_list|)
operator|!=
name|fileinfo
operator|.
name|st_size
condition|)
endif|#
directive|endif
comment|/* !VMS */
name|error_exit
label|:
block|{
if|if
condition|(
name|result
condition|)
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullpath
condition|)
name|free
argument_list|(
name|fullpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|close
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* Set the globals to the new file. */
name|input_text
operator|=
name|result
expr_stmt|;
name|size_of_input_text
operator|=
name|count
expr_stmt|;
name|input_filename
operator|=
name|savestring
argument_list|(
name|fullpath
argument_list|)
expr_stmt|;
name|node_filename
operator|=
name|savestring
argument_list|(
name|fullpath
argument_list|)
expr_stmt|;
name|input_text_offset
operator|=
literal|0
expr_stmt|;
name|line_number
operator|=
literal|1
expr_stmt|;
comment|/* Not strictly necessary.  This magic prevents read_token () from doing      extra unnecessary work each time it is called (that is a lot of times).      The SIZE_OF_INPUT_TEXT is one past the actual end of the text. */
name|input_text
index|[
name|size_of_input_text
index|]
operator|=
literal|'\n'
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Save the state of the current input file. */
end_comment

begin_macro
name|pushfile
argument_list|()
end_macro

begin_block
block|{
name|FSTACK
modifier|*
name|newstack
init|=
operator|(
name|FSTACK
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FSTACK
argument_list|)
argument_list|)
decl_stmt|;
name|newstack
operator|->
name|filename
operator|=
name|input_filename
expr_stmt|;
name|newstack
operator|->
name|text
operator|=
name|input_text
expr_stmt|;
name|newstack
operator|->
name|size
operator|=
name|size_of_input_text
expr_stmt|;
name|newstack
operator|->
name|offset
operator|=
name|input_text_offset
expr_stmt|;
name|newstack
operator|->
name|line_number
operator|=
name|line_number
expr_stmt|;
name|newstack
operator|->
name|next
operator|=
name|filestack
expr_stmt|;
name|filestack
operator|=
name|newstack
expr_stmt|;
name|push_node_filename
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Make the current file globals be what is on top of the file stack. */
end_comment

begin_macro
name|popfile
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|executing_string
decl_stmt|;
name|FSTACK
modifier|*
name|temp
init|=
name|filestack
decl_stmt|;
if|if
condition|(
operator|!
name|filestack
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* My fault.  I wonder what I did? */
comment|/* Make sure that commands with braces have been satisfied. */
if|if
condition|(
operator|!
name|executing_string
condition|)
name|discard_braces
argument_list|()
expr_stmt|;
comment|/* Get the top of the stack into the globals. */
name|input_filename
operator|=
name|filestack
operator|->
name|filename
expr_stmt|;
name|input_text
operator|=
name|filestack
operator|->
name|text
expr_stmt|;
name|size_of_input_text
operator|=
name|filestack
operator|->
name|size
expr_stmt|;
name|input_text_offset
operator|=
name|filestack
operator|->
name|offset
expr_stmt|;
name|line_number
operator|=
name|filestack
operator|->
name|line_number
expr_stmt|;
comment|/* Pop the stack. */
name|filestack
operator|=
name|filestack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|pop_node_filename
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Flush all open files on the file stack. */
end_comment

begin_macro
name|flush_file_stack
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|filestack
condition|)
block|{
name|free
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_text
argument_list|)
expr_stmt|;
name|popfile
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
name|int
name|node_filename_stack_index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|node_filename_stack_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|node_filename_stack
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_macro
name|push_node_filename
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|node_filename_stack_index
operator|+
literal|1
operator|>
name|node_filename_stack_size
condition|)
block|{
if|if
condition|(
operator|!
name|node_filename_stack
condition|)
name|node_filename_stack
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|node_filename_stack_size
operator|+=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|node_filename_stack
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|node_filename_stack
argument_list|,
operator|(
name|node_filename_stack_size
operator|+
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|node_filename_stack
index|[
name|node_filename_stack_index
index|]
operator|=
name|node_filename
expr_stmt|;
name|node_filename_stack_index
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|pop_node_filename
argument_list|()
end_macro

begin_block
block|{
name|node_filename
operator|=
name|node_filename_stack
index|[
operator|--
name|node_filename_stack_index
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return just the simple part of the filename; i.e. the    filename without the path information, or extensions.    This conses up a new string. */
end_comment

begin_function
name|char
modifier|*
name|filename_part
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|basename
decl_stmt|;
name|basename
operator|=
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|basename
condition|)
name|basename
operator|=
name|filename
expr_stmt|;
else|else
name|basename
operator|++
expr_stmt|;
name|basename
operator|=
name|savestring
argument_list|(
name|basename
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|REMOVE_OUTPUT_EXTENSIONS
argument_list|)
comment|/* See if there is an extension to remove.  If so, remove it. */
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|strrchr
argument_list|(
name|basename
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
condition|)
operator|*
name|temp
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* REMOVE_OUTPUT_EXTENSIONS */
return|return
operator|(
name|basename
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the pathname part of filename.  This can be NULL. */
end_comment

begin_function
name|char
modifier|*
name|pathname_part
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|expand_filename
parameter_list|()
function_decl|;
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|filename
operator|=
name|expand_filename
argument_list|(
name|filename
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|filename
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|&&
name|filename
index|[
name|i
index|]
operator|!=
literal|'/'
condition|)
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|filename
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|i
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|result
argument_list|,
name|filename
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|result
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the expansion of FILENAME. */
end_comment

begin_function
name|char
modifier|*
name|expand_filename
parameter_list|(
name|filename
parameter_list|,
name|input_name
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|,
decl|*
name|input_name
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|full_pathname
parameter_list|()
function_decl|;
name|filename
operator|=
name|full_pathname
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
return|return
operator|(
name|filename
operator|)
return|;
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|&&
name|input_name
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* Make it so that relative names work. */
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|i
init|=
name|strlen
argument_list|(
name|input_name
argument_list|)
operator|-
literal|1
decl_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|input_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|input_name
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
index|[
name|i
index|]
operator|!=
literal|'/'
operator|&&
name|i
condition|)
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|result
index|[
name|i
index|]
operator|==
literal|'/'
condition|)
name|i
operator|++
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|result
index|[
name|i
index|]
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
return|return
operator|(
name|filename
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Return the full path to FILENAME. */
end_comment

begin_function
name|char
modifier|*
name|full_pathname
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|initial_character
decl_stmt|;
if|if
condition|(
name|filename
operator|&&
operator|(
name|initial_character
operator|=
operator|*
name|filename
operator|)
condition|)
block|{
if|if
condition|(
name|initial_character
operator|==
literal|'/'
condition|)
return|return
operator|(
name|savestring
argument_list|(
name|filename
argument_list|)
operator|)
return|;
if|if
condition|(
name|initial_character
operator|!=
literal|'~'
condition|)
block|{
return|return
operator|(
name|savestring
argument_list|(
name|filename
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|filename
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* Return the concatenation of HOME and the rest of the string. */
name|char
modifier|*
name|temp_home
decl_stmt|;
name|char
modifier|*
name|temp_name
decl_stmt|;
name|temp_home
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
name|temp_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
operator|&
name|filename
index|[
literal|2
index|]
argument_list|)
operator|+
literal|1
operator|+
name|temp_home
condition|?
name|strlen
argument_list|(
name|temp_home
argument_list|)
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_home
condition|)
name|strcpy
argument_list|(
name|temp_name
argument_list|,
name|temp_home
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp_name
argument_list|,
operator|&
name|filename
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp_name
operator|)
return|;
block|}
else|else
block|{
name|struct
name|passwd
modifier|*
name|user_entry
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|username
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|257
argument_list|)
decl_stmt|;
name|char
modifier|*
name|temp_name
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|c
operator|=
name|filename
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'/'
condition|)
break|break;
else|else
name|username
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|c
condition|)
name|username
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|user_entry
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|user_entry
condition|)
return|return
operator|(
name|savestring
argument_list|(
name|filename
argument_list|)
operator|)
return|;
name|temp_name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|user_entry
operator|->
name|pw_dir
argument_list|)
operator|+
name|strlen
argument_list|(
operator|&
name|filename
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp_name
argument_list|,
name|user_entry
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp_name
argument_list|,
operator|&
name|filename
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp_name
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
return|return
operator|(
name|savestring
argument_list|(
name|filename
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Error Handling				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Number of errors encountered. */
end_comment

begin_decl_stmt
name|int
name|errors_printed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print the last error gotten from the file system. */
end_comment

begin_macro
name|fs_error
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|remember_error
argument_list|()
expr_stmt|;
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Print an error message, and return false. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VARARGS_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_VFPRINTF
argument_list|)
end_if

begin_function
name|int
name|error
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|remember_error
argument_list|()
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Just like error (), but print the line number as well. */
end_comment

begin_function
name|int
name|line_error
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|remember_error
argument_list|()
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|input_filename
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|warning
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_warnings
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: Warning: "
argument_list|,
name|input_filename
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !(HAVE_VARARGS_H&& HAVE_VFPRINTF) */
end_comment

begin_function
name|int
name|error
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|,
name|arg4
parameter_list|,
name|arg5
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
block|{
name|remember_error
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Just like error (), but print the line number as well. */
end_comment

begin_function
name|int
name|line_error
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|,
name|arg4
parameter_list|,
name|arg5
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
block|{
name|remember_error
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|input_filename
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|warning
parameter_list|(
name|format
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|,
name|arg4
parameter_list|,
name|arg5
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
block|{
if|if
condition|(
name|print_warnings
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: Warning: "
argument_list|,
name|input_filename
argument_list|,
name|line_number
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|int
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !(HAVE_VARARGS_H&& HAVE_VFPRINTF) */
end_comment

begin_comment
comment|/* Remember that an error has been printed.  If this is the first    error printed, then tell them which program is printing them.    If more than max_error_level have been printed, then exit the    program. */
end_comment

begin_macro
name|remember_error
argument_list|()
end_macro

begin_block
block|{
name|errors_printed
operator|++
expr_stmt|;
if|if
condition|(
name|max_error_level
operator|&&
operator|(
name|errors_printed
operator|>
name|max_error_level
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many errors!  Gave up.\n"
argument_list|)
expr_stmt|;
name|flush_file_stack
argument_list|()
expr_stmt|;
name|cm_bye
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Hacking Tokens and Strings		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Return the next token as a string pointer.  We cons the    string. */
end_comment

begin_function
name|char
modifier|*
name|read_token
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|character
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
comment|/* If the first character to be read is self-delimiting, then that      is the command itself. */
name|character
operator|=
name|curchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|self_delimiting
argument_list|(
name|character
argument_list|)
condition|)
block|{
name|input_text_offset
operator|++
expr_stmt|;
name|result
operator|=
name|savestring
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|character
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|input_text_offset
operator|!=
name|size_of_input_text
operator|)
operator|&&
operator|(
name|character
operator|=
name|curchar
argument_list|()
operator|)
operator|&&
name|command_char
argument_list|(
name|character
argument_list|)
operator|)
condition|;
name|i
operator|++
operator|,
name|input_text_offset
operator|++
control|)
empty_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|result
argument_list|,
operator|&
name|input_text
index|[
name|input_text_offset
operator|-
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|result
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if CHARACTER is self-delimiting. */
end_comment

begin_function
name|int
name|self_delimiting
parameter_list|(
name|character
parameter_list|)
name|int
name|character
decl_stmt|;
block|{
return|return
operator|(
name|member
argument_list|(
name|character
argument_list|,
literal|"{}:.@*'`,!?; \n"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Clear whitespace from the front and end of string. */
end_comment

begin_macro
name|canon_white
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
return|return;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|len
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|cr_or_whitespace
argument_list|(
name|string
index|[
name|x
index|]
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|string
argument_list|,
name|string
operator|+
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|len
operator|--
expr_stmt|;
while|while
condition|(
name|len
operator|>
operator|-
literal|1
operator|&&
name|cr_or_whitespace
argument_list|(
name|string
index|[
name|len
index|]
argument_list|)
condition|)
name|len
operator|--
expr_stmt|;
name|string
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Bash STRING, replacing all whitespace with just one space. */
end_comment

begin_macro
name|fix_whitespace
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|string_index
init|=
literal|0
decl_stmt|;
name|int
name|temp_index
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|canon_white
argument_list|(
name|string
argument_list|)
expr_stmt|;
while|while
condition|(
name|string
index|[
name|string_index
index|]
condition|)
block|{
name|c
operator|=
name|temp
index|[
name|temp_index
operator|++
index|]
operator|=
name|string
index|[
name|string_index
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
block|{
name|temp
index|[
name|temp_index
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|string
index|[
name|string_index
index|]
operator|)
operator|&&
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
name|string_index
operator|++
expr_stmt|;
block|}
block|}
name|temp
index|[
name|temp_index
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|string
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Discard text until the desired string is found.  The string is    included in the discarded text. */
end_comment

begin_macro
name|discard_until
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|temp
init|=
name|search_forward
argument_list|(
name|string
argument_list|,
name|input_text_offset
argument_list|)
decl_stmt|;
name|int
name|tt
init|=
operator|(
name|temp
operator|<
literal|0
operator|)
condition|?
name|size_of_input_text
else|:
name|temp
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|from
init|=
name|input_text_offset
decl_stmt|;
comment|/* Find out what line we are on. */
while|while
condition|(
name|from
operator|!=
name|tt
condition|)
if|if
condition|(
name|input_text
index|[
name|from
operator|++
index|]
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|input_text_offset
operator|=
name|size_of_input_text
operator|-
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"\n"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|line_error
argument_list|(
literal|"Expected `%s'"
argument_list|,
name|string
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|input_text_offset
operator|=
name|temp
expr_stmt|;
name|input_text_offset
operator|+=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Read characters from the file until we are at MATCH.    Place the characters read into STRING.    On exit input_text_offset is after the match string.    Return the offset where the string starts. */
end_comment

begin_function
name|int
name|get_until
parameter_list|(
name|match
parameter_list|,
name|string
parameter_list|)
name|char
modifier|*
name|match
decl_stmt|,
decl|*
modifier|*
name|string
decl_stmt|;
end_function

begin_block
block|{
name|int
name|len
decl_stmt|,
name|current_point
decl_stmt|,
name|x
decl_stmt|,
name|new_point
decl_stmt|,
name|tem
decl_stmt|;
name|current_point
operator|=
name|x
operator|=
name|input_text_offset
expr_stmt|;
name|new_point
operator|=
name|search_forward
argument_list|(
name|match
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_point
operator|<
literal|0
condition|)
name|new_point
operator|=
name|size_of_input_text
expr_stmt|;
name|len
operator|=
name|new_point
operator|-
name|current_point
expr_stmt|;
comment|/* Keep track of which line number we are at. */
name|tem
operator|=
name|new_point
operator|+
operator|(
name|strlen
argument_list|(
name|match
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|x
operator|!=
name|tem
condition|)
if|if
condition|(
name|input_text
index|[
name|x
operator|++
index|]
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
operator|*
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|string
argument_list|,
operator|&
name|input_text
index|[
name|current_point
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
operator|*
name|string
operator|)
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Now leave input_text_offset in a consistent state. */
name|input_text_offset
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|input_text_offset
operator|>
name|size_of_input_text
condition|)
name|input_text_offset
operator|=
name|size_of_input_text
expr_stmt|;
return|return
operator|(
name|new_point
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Read characters from the file until we are at MATCH or end of line.    Place the characters read into STRING.  */
end_comment

begin_macro
name|get_until_in_line
argument_list|(
argument|match
argument_list|,
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|match
decl_stmt|,
modifier|*
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|real_bottom
decl_stmt|,
name|temp
decl_stmt|;
name|real_bottom
operator|=
name|size_of_input_text
expr_stmt|;
name|temp
operator|=
name|search_forward
argument_list|(
literal|"\n"
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
name|temp
operator|=
name|size_of_input_text
expr_stmt|;
name|size_of_input_text
operator|=
name|temp
expr_stmt|;
name|get_until
argument_list|(
name|match
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|size_of_input_text
operator|=
name|real_bottom
expr_stmt|;
block|}
end_block

begin_macro
name|get_rest_of_line
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|get_until
argument_list|(
literal|"\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
operator|*
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|'\n'
condition|)
comment|/* as opposed to the end of the file... */
block|{
name|line_number
operator|++
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Backup the input pointer to the previous character, keeping track    of the current line number. */
end_comment

begin_macro
name|backup_input_pointer
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|input_text_offset
condition|)
block|{
name|input_text_offset
operator|--
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|'\n'
condition|)
name|line_number
operator|--
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Read characters from the file until we are at MATCH or closing brace.    Place the characters read into STRING.  */
end_comment

begin_macro
name|get_until_in_braces
argument_list|(
argument|match
argument_list|,
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|match
decl_stmt|,
modifier|*
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|brace
init|=
literal|0
decl_stmt|;
name|int
name|match_len
init|=
name|strlen
argument_list|(
name|match
argument_list|)
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|i
operator|=
name|input_text_offset
init|;
name|i
operator|<
name|size_of_input_text
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|input_text
index|[
name|i
index|]
operator|==
literal|'{'
condition|)
name|brace
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|input_text
index|[
name|i
index|]
operator|==
literal|'}'
condition|)
name|brace
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|input_text
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
if|if
condition|(
name|brace
operator|<
literal|0
operator|||
operator|(
name|brace
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
name|input_text
operator|+
name|i
argument_list|,
name|match
argument_list|,
name|match_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
name|match_len
operator|=
name|i
operator|-
name|input_text_offset
expr_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
name|match_len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|temp
argument_list|,
name|input_text
operator|+
name|input_text_offset
argument_list|,
name|match_len
argument_list|)
expr_stmt|;
name|temp
index|[
name|match_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|input_text_offset
operator|=
name|i
expr_stmt|;
operator|*
name|string
operator|=
name|temp
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Converting the File     		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Convert the file named by NAME.  The output is saved on the file    named as the argument to the @setfilename command. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|suffixes
index|[]
init|=
block|{
literal|""
block|,
literal|".texinfo"
block|,
literal|".texi"
block|,
literal|".txinfo"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|convert
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|real_output_filename
decl_stmt|,
modifier|*
name|expand_filename
argument_list|()
decl_stmt|,
modifier|*
name|filename_part
argument_list|()
decl_stmt|;
name|char
modifier|*
name|filename
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|50
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|init_tag_table
argument_list|()
expr_stmt|;
name|init_indices
argument_list|()
expr_stmt|;
name|init_internals
argument_list|()
expr_stmt|;
name|init_paragraph
argument_list|()
expr_stmt|;
comment|/* Try to load the file specified by NAME.  If the file isn't found, and      there is no suffix in NAME, then try NAME.texinfo, and NAME.texi. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|suffixes
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|strcpy
argument_list|(
name|filename
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
name|suffixes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_and_load
argument_list|(
name|filename
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|suffixes
index|[
name|i
index|]
index|[
literal|0
index|]
operator|&&
name|strrchr
argument_list|(
name|filename
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
name|fs_error
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|suffixes
index|[
name|i
index|]
condition|)
block|{
name|fs_error
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
name|input_filename
operator|=
name|filename
expr_stmt|;
comment|/* Search this file looking for the special string which starts conversion.      Once found, we may truly begin. */
name|input_text_offset
operator|=
name|search_forward
argument_list|(
literal|"@setfilename"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_text_offset
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|command_output_filename
condition|)
block|{
name|error
argument_list|(
literal|"No `@setfilename' found in `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
block|}
else|else
name|input_text_offset
operator|+=
name|strlen
argument_list|(
literal|"@setfilename"
argument_list|)
expr_stmt|;
name|real_output_filename
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|command_output_filename
condition|)
name|get_until
argument_list|(
literal|"\n"
argument_list|,
operator|&
name|output_filename
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|input_text_offset
operator|!=
operator|-
literal|1
condition|)
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
else|else
name|input_text_offset
operator|=
literal|0
expr_stmt|;
name|real_output_filename
operator|=
name|output_filename
operator|=
name|command_output_filename
expr_stmt|;
name|command_output_filename
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|canon_white
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Making info file `%s' from `%s'.\n"
argument_list|,
name|output_filename
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose_mode
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  The input file contains %d characters.\n"
argument_list|,
name|size_of_input_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_output_filename
operator|&&
name|strcmp
argument_list|(
name|real_output_filename
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|output_stream
operator|=
name|stdout
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|real_output_filename
condition|)
name|real_output_filename
operator|=
name|expand_filename
argument_list|(
name|output_filename
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|output_stream
operator|=
name|fopen
argument_list|(
name|real_output_filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|output_stream
operator|==
name|NULL
condition|)
block|{
name|fs_error
argument_list|(
name|real_output_filename
argument_list|)
expr_stmt|;
goto|goto
name|finished
goto|;
block|}
comment|/* Make the displayable filename from output_filename.  Only the base      portion of the filename need be displayed. */
name|pretty_output_filename
operator|=
name|filename_part
argument_list|(
name|output_filename
argument_list|)
expr_stmt|;
comment|/* For this file only, count the number of newlines from the top of      the file to here.  This way, we keep track of line numbers for      error reporting.  Line_number starts at 1, since the user isn't      zero-based. */
block|{
name|int
name|temp
init|=
literal|0
decl_stmt|;
name|line_number
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|temp
operator|!=
name|input_text_offset
condition|)
if|if
condition|(
name|input_text
index|[
name|temp
operator|++
index|]
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|no_headers
condition|)
block|{
name|add_word_args
argument_list|(
literal|"This is Info file %s, produced by Makeinfo-%d.%d from "
argument_list|,
name|output_filename
argument_list|,
name|major_version
argument_list|,
name|minor_version
argument_list|)
expr_stmt|;
name|add_word_args
argument_list|(
literal|"the input file %s.\n"
argument_list|,
name|input_filename
argument_list|)
expr_stmt|;
block|}
name|close_paragraph
argument_list|()
expr_stmt|;
name|reader_loop
argument_list|()
expr_stmt|;
name|finished
label|:
name|close_paragraph
argument_list|()
expr_stmt|;
name|flush_file_stack
argument_list|()
expr_stmt|;
if|if
condition|(
name|output_stream
operator|!=
name|NULL
condition|)
block|{
name|output_pending_notes
argument_list|()
expr_stmt|;
name|free_pending_notes
argument_list|()
expr_stmt|;
if|if
condition|(
name|tag_table
operator|!=
name|NULL
condition|)
block|{
name|tag_table
operator|=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|reverse_list
argument_list|(
name|tag_table
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_headers
condition|)
name|write_tag_table
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|output_stream
operator|!=
name|stdout
condition|)
name|fclose
argument_list|(
name|output_stream
argument_list|)
expr_stmt|;
comment|/* If validating, then validate the entire file right now. */
if|if
condition|(
name|validating
condition|)
name|validate_file
argument_list|(
name|real_output_filename
argument_list|,
name|tag_table
argument_list|)
expr_stmt|;
comment|/* This used to test&& !errors_printed. 	 But some files might have legit warnings.  So split anyway.  */
if|if
condition|(
name|splitting
condition|)
name|split_file
argument_list|(
name|real_output_filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|free_and_clear
argument_list|(
argument|pointer
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|pointer
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
operator|*
name|pointer
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|*
name|pointer
argument_list|)
expr_stmt|;
operator|*
name|pointer
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Initialize some state. */
end_comment

begin_macro
name|init_internals
argument_list|()
end_macro

begin_block
block|{
name|free_and_clear
argument_list|(
operator|&
name|current_node
argument_list|)
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
name|output_filename
argument_list|)
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
name|command
argument_list|)
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
name|input_filename
argument_list|)
expr_stmt|;
name|free_node_references
argument_list|()
expr_stmt|;
name|init_insertion_stack
argument_list|()
expr_stmt|;
name|init_brace_stack
argument_list|()
expr_stmt|;
name|command_index
operator|=
literal|0
expr_stmt|;
name|in_menu
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|init_paragraph
argument_list|()
end_macro

begin_block
block|{
name|free_and_clear
argument_list|(
operator|&
name|output_paragraph
argument_list|)
expr_stmt|;
name|output_paragraph
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|paragraph_buffer_len
argument_list|)
expr_stmt|;
name|output_position
operator|=
literal|0
expr_stmt|;
name|output_paragraph
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|output_paragraph_offset
operator|=
literal|0
expr_stmt|;
name|output_column
operator|=
literal|0
expr_stmt|;
name|paragraph_is_open
operator|=
literal|0
expr_stmt|;
name|current_indent
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Okay, we are ready to start the conversion.  Call the reader on    some text, and fill the text as it is output.  Handle commands by    remembering things like open braces and the current file position on a    stack, and when the corresponding close brace is found, you can call    the function with the proper arguments. */
end_comment

begin_macro
name|reader_loop
argument_list|()
end_macro

begin_block
block|{
name|int
name|character
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|dash_count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|input_text_offset
operator|>=
name|size_of_input_text
condition|)
block|{
if|if
condition|(
name|filestack
condition|)
block|{
name|free
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|input_text
argument_list|)
expr_stmt|;
name|popfile
argument_list|()
expr_stmt|;
block|}
else|else
break|break;
block|}
name|character
operator|=
name|curchar
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|in_fixed_width_font
operator|&&
operator|(
name|character
operator|==
literal|'\''
operator|||
name|character
operator|==
literal|'`'
operator|)
operator|&&
name|input_text
index|[
name|input_text_offset
operator|+
literal|1
index|]
operator|==
name|character
condition|)
block|{
name|input_text_offset
operator|++
expr_stmt|;
name|character
operator|=
literal|'"'
expr_stmt|;
block|}
if|if
condition|(
name|character
operator|==
literal|'-'
condition|)
block|{
name|dash_count
operator|++
expr_stmt|;
if|if
condition|(
name|dash_count
operator|==
literal|2
operator|&&
operator|!
name|in_fixed_width_font
condition|)
block|{
name|input_text_offset
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|dash_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If this is a whitespace character, then check to see if the line 	 is blank.  If so, advance to the carriage return. */
if|if
condition|(
name|whitespace
argument_list|(
name|character
argument_list|)
condition|)
block|{
specifier|register
name|int
name|i
init|=
name|input_text_offset
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|size_of_input_text
operator|&&
name|whitespace
argument_list|(
name|input_text
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|size_of_input_text
operator|||
name|input_text
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|size_of_input_text
condition|)
name|i
operator|--
expr_stmt|;
name|input_text_offset
operator|=
name|i
expr_stmt|;
name|character
operator|=
name|curchar
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|character
operator|==
literal|'\n'
condition|)
block|{
name|line_number
operator|++
expr_stmt|;
comment|/* Check for a menu entry here, since the "escape sequence" 	     that begins menu entrys is "\n* ". */
if|if
condition|(
name|in_menu
operator|&&
name|input_text_offset
operator|+
literal|1
operator|<
name|size_of_input_text
condition|)
block|{
name|char
modifier|*
name|glean_node_from_menu
argument_list|()
decl_stmt|,
modifier|*
name|tem
decl_stmt|;
comment|/* Note that the value of TEM is discarded, since it is 		 gauranteed to be NULL when glean_node_from_menu () is 		 called with a non-zero argument. */
name|tem
operator|=
name|glean_node_from_menu
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|character
condition|)
block|{
case|case
name|COMMAND_PREFIX
case|:
name|read_command
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
literal|"bye"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|done
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'{'
case|:
comment|/* Special case.  I'm not supposed to see this character by itself. 	     If I do, it means there is a syntax error in the input text. 	     Report the error here, but remember this brace on the stack so 	     you can ignore its partner. */
name|line_error
argument_list|(
literal|"Misplaced `{'"
argument_list|)
expr_stmt|;
name|remember_brace
argument_list|(
name|misplaced_brace
argument_list|)
expr_stmt|;
comment|/* Don't advance input_text_offset since this happens in 	     remember_brace (). 	     input_text_offset++;            */
break|break;
case|case
literal|'}'
case|:
name|pop_and_call_brace
argument_list|()
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
break|break;
default|default:
name|add_char
argument_list|(
name|character
argument_list|)
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Find the command corresponding to STRING.  If the command    is found, return a pointer to the data structure.  Otherwise    return (-1). */
end_comment

begin_function
name|COMMAND
modifier|*
name|get_command_entry
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|CommandTable
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|CommandTable
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|string
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|&
name|CommandTable
index|[
name|i
index|]
operator|)
return|;
comment|/* This command is not in our predefined command table.  Perhaps      it is a user defined command. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|user_command_array_len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|user_command_array
index|[
name|i
index|]
operator|&&
operator|(
name|strcmp
argument_list|(
name|user_command_array
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|string
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|user_command_array
index|[
name|i
index|]
operator|)
return|;
comment|/* Nope, we never heard of this command. */
return|return
operator|(
operator|(
name|COMMAND
operator|*
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* input_text_offset is right at the command prefix character.    Read the next token to determine what to do. */
end_comment

begin_macro
name|read_command
argument_list|()
end_macro

begin_block
block|{
name|COMMAND
modifier|*
name|entry
decl_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
name|command
argument_list|)
expr_stmt|;
name|command
operator|=
name|read_token
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
comment|/* Check to see if this command is a macro.  If so, execute it here. */
block|{
name|MACRO_DEF
modifier|*
name|def
decl_stmt|;
name|def
operator|=
name|find_macro
argument_list|(
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
condition|)
block|{
name|execute_macro
argument_list|(
name|def
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_MACROS */
name|entry
operator|=
name|get_command_entry
argument_list|(
name|command
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|entry
operator|==
operator|-
literal|1
condition|)
block|{
name|line_error
argument_list|(
literal|"Unknown info command `%s'"
argument_list|,
name|command
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|entry
operator|->
name|argument_in_braces
condition|)
name|remember_brace
argument_list|(
name|entry
operator|->
name|proc
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|entry
operator|->
name|proc
operator|)
operator|)
operator|(
name|START
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return the string which invokes PROC; a pointer to a function. */
end_comment

begin_function
name|char
modifier|*
name|find_proc_name
parameter_list|(
name|proc
parameter_list|)
name|FUNCTION
modifier|*
name|proc
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|CommandTable
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|proc
operator|==
name|CommandTable
index|[
name|i
index|]
operator|.
name|proc
condition|)
return|return
operator|(
name|CommandTable
index|[
name|i
index|]
operator|.
name|name
operator|)
return|;
return|return
operator|(
literal|"NO_NAME!"
operator|)
return|;
block|}
end_function

begin_macro
name|init_brace_stack
argument_list|()
end_macro

begin_block
block|{
name|brace_stack
operator|=
operator|(
name|BRACE_ELEMENT
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_block

begin_macro
name|remember_brace
argument_list|(
argument|proc
argument_list|)
end_macro

begin_decl_stmt
name|FUNCTION
modifier|*
name|proc
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|curchar
argument_list|()
operator|!=
literal|'{'
condition|)
name|line_error
argument_list|(
literal|"@%s expected `{..}'"
argument_list|,
name|command
argument_list|)
expr_stmt|;
else|else
name|input_text_offset
operator|++
expr_stmt|;
name|remember_brace_1
argument_list|(
name|proc
argument_list|,
name|output_paragraph_offset
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Remember the current output position here.  Save PROC    along with it so you can call it later. */
end_comment

begin_macro
name|remember_brace_1
argument_list|(
argument|proc
argument_list|,
argument|position
argument_list|)
end_macro

begin_decl_stmt
name|FUNCTION
modifier|*
name|proc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|position
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|BRACE_ELEMENT
modifier|*
name|new
init|=
operator|(
name|BRACE_ELEMENT
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BRACE_ELEMENT
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|next
operator|=
name|brace_stack
expr_stmt|;
name|new
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|new
operator|->
name|pos
operator|=
name|position
expr_stmt|;
name|new
operator|->
name|line
operator|=
name|line_number
expr_stmt|;
name|brace_stack
operator|=
name|new
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Pop the top of the brace stack, and call the associated function    with the args END and POS. */
end_comment

begin_macro
name|pop_and_call_brace
argument_list|()
end_macro

begin_block
block|{
name|BRACE_ELEMENT
modifier|*
name|temp
decl_stmt|;
name|FUNCTION
modifier|*
name|proc
decl_stmt|;
name|int
name|pos
decl_stmt|;
if|if
condition|(
name|brace_stack
operator|==
operator|(
name|BRACE_ELEMENT
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|line_error
argument_list|(
literal|"Unmatched close brace"
argument_list|)
operator|)
return|;
name|pos
operator|=
name|brace_stack
operator|->
name|pos
expr_stmt|;
name|proc
operator|=
name|brace_stack
operator|->
name|proc
expr_stmt|;
name|temp
operator|=
name|brace_stack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|brace_stack
argument_list|)
expr_stmt|;
name|brace_stack
operator|=
name|temp
expr_stmt|;
return|return
operator|(
call|(
modifier|*
name|proc
call|)
argument_list|(
name|END
argument_list|,
name|pos
argument_list|,
name|output_paragraph_offset
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* You call discard_braces () when you shouldn't have any braces on the stack.    I used to think that this happens for commands that don't take arguments    in braces, but that was wrong because of things like @code{foo @@}.  So now    I only detect it at the beginning of nodes. */
end_comment

begin_macro
name|discard_braces
argument_list|()
end_macro

begin_block
block|{
name|int
name|temp_line_number
init|=
name|line_number
decl_stmt|;
name|char
modifier|*
name|proc_name
decl_stmt|;
if|if
condition|(
operator|!
name|brace_stack
condition|)
return|return;
while|while
condition|(
name|brace_stack
condition|)
block|{
name|line_number
operator|=
name|brace_stack
operator|->
name|line
expr_stmt|;
name|proc_name
operator|=
name|find_proc_name
argument_list|(
name|brace_stack
operator|->
name|proc
argument_list|)
expr_stmt|;
name|line_error
argument_list|(
literal|"@%s missing close brace"
argument_list|,
name|proc_name
argument_list|)
expr_stmt|;
name|line_number
operator|=
name|temp_line_number
expr_stmt|;
name|pop_and_call_brace
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|get_char_len
argument_list|(
argument|character
argument_list|)
end_macro

begin_decl_stmt
name|int
name|character
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Return the printed length of the character. */
name|int
name|len
decl_stmt|;
switch|switch
condition|(
name|character
condition|)
block|{
case|case
literal|'\t'
case|:
name|len
operator|=
operator|(
name|output_column
operator|+
literal|8
operator|)
operator|&
literal|0xf7
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|fill_column
condition|)
name|len
operator|=
name|fill_column
operator|-
name|output_column
expr_stmt|;
else|else
name|len
operator|=
name|len
operator|-
name|output_column
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|len
operator|=
name|fill_column
operator|-
name|output_column
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|character
operator|<
literal|' '
condition|)
name|len
operator|=
literal|2
expr_stmt|;
else|else
name|len
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_block

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VARARGS_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_VSPRINTF
argument_list|)
end_if

begin_macro
name|add_word_args
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|char
name|buffer
index|[
literal|1000
index|]
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buffer
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !(HAVE_VARARGS_H&& HAVE_VSPRINTF) */
end_comment

begin_macro
name|add_word_args
argument_list|(
argument|format
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|,
argument|arg4
argument_list|,
argument|arg5
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|format
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buffer
index|[
literal|1000
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !(HAVE_VARARGS_H&& HAVE_VSPRINTF) */
end_comment

begin_comment
comment|/* Add STRING to output_paragraph. */
end_comment

begin_macro
name|add_word
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|string
condition|)
name|add_char
argument_list|(
operator|*
name|string
operator|++
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Non-zero if the last character inserted has the syntax class of NEWLINE. */
end_comment

begin_decl_stmt
name|int
name|last_char_was_newline
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The actual last inserted character.  Note that this may be something    other than NEWLINE even if last_char_was_newline is 1. */
end_comment

begin_decl_stmt
name|int
name|last_inserted_character
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that a newline character has already been    inserted, so close_paragraph () should insert one less. */
end_comment

begin_decl_stmt
name|int
name|line_already_broken
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When non-zero we have finished an insertion (see end_insertion ()) and we    want to ignore false continued paragraph closings. */
end_comment

begin_decl_stmt
name|int
name|insertion_paragraph_closed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add the character to the current paragraph.  If filling_enabled is    non-zero, then do filling as well. */
end_comment

begin_macro
name|add_char
argument_list|(
argument|character
argument_list|)
end_macro

begin_decl_stmt
name|int
name|character
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* If we are avoiding outputting headers, and we are currently      in a menu, then simply return. */
if|if
condition|(
name|no_headers
operator|&&
name|in_menu
condition|)
return|return;
comment|/* If we are adding a character now, then we don't have to      ignore close_paragraph () calls any more. */
if|if
condition|(
name|must_start_paragraph
operator|&&
name|character
operator|!=
literal|'\n'
condition|)
block|{
name|must_start_paragraph
operator|=
literal|0
expr_stmt|;
name|line_already_broken
operator|=
literal|0
expr_stmt|;
comment|/* The line is no longer broken. */
if|if
condition|(
name|current_indent
operator|>
name|output_column
condition|)
block|{
name|indent
argument_list|(
name|current_indent
operator|-
name|output_column
argument_list|)
expr_stmt|;
name|output_column
operator|=
name|current_indent
expr_stmt|;
block|}
block|}
if|if
condition|(
name|non_splitting_words
operator|&&
name|member
argument_list|(
name|character
argument_list|,
literal|" \t\n"
argument_list|)
condition|)
name|character
operator|=
literal|' '
operator||
literal|0x80
expr_stmt|;
name|insertion_paragraph_closed
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|character
condition|)
block|{
case|case
literal|'\n'
case|:
if|if
condition|(
operator|!
name|filling_enabled
condition|)
block|{
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_flush_right
condition|)
block|{
name|close_paragraph
argument_list|()
expr_stmt|;
comment|/* Hack to force single blank lines out in this mode. */
name|flush_output
argument_list|()
expr_stmt|;
block|}
name|output_column
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|no_indent
operator|&&
name|paragraph_is_open
condition|)
name|indent
argument_list|(
name|output_column
operator|=
name|current_indent
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
comment|/* CHARACTER is newline, and filling is enabled. */
block|{
if|if
condition|(
name|sentence_ender
argument_list|(
name|last_inserted_character
argument_list|)
condition|)
block|{
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|output_column
operator|++
expr_stmt|;
name|last_inserted_character
operator|=
name|character
expr_stmt|;
block|}
block|}
if|if
condition|(
name|last_char_was_newline
condition|)
block|{
name|close_paragraph
argument_list|()
expr_stmt|;
name|pending_indent
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|last_char_was_newline
operator|=
literal|1
expr_stmt|;
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|output_column
operator|++
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|int
name|len
init|=
name|get_char_len
argument_list|(
name|character
argument_list|)
decl_stmt|;
name|int
name|suppress_insert
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|character
operator|==
literal|' '
operator|)
operator|&&
operator|(
name|last_char_was_newline
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|paragraph_is_open
condition|)
block|{
name|pending_indent
operator|++
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|paragraph_is_open
condition|)
block|{
name|start_paragraph
argument_list|()
expr_stmt|;
comment|/* If the paragraph is supposed to be indented a certain way, 	       then discard all of the pending whitespace.  Otherwise, we 	       let the whitespace stay. */
if|if
condition|(
operator|!
name|paragraph_start_indent
condition|)
name|indent
argument_list|(
name|pending_indent
argument_list|)
expr_stmt|;
name|pending_indent
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|output_column
operator|+=
name|len
operator|)
operator|>
name|fill_column
condition|)
block|{
if|if
condition|(
name|filling_enabled
condition|)
block|{
name|int
name|temp
init|=
name|output_paragraph_offset
decl_stmt|;
while|while
condition|(
operator|--
name|temp
operator|>
literal|0
operator|&&
name|output_paragraph
index|[
name|temp
index|]
operator|!=
literal|'\n'
condition|)
block|{
comment|/* If we have found a space, we have the place to break 		       the line. */
if|if
condition|(
name|output_paragraph
index|[
name|temp
index|]
operator|==
literal|' '
condition|)
block|{
comment|/* Remove trailing whitespace from output. */
while|while
condition|(
name|temp
operator|&&
name|whitespace
argument_list|(
name|output_paragraph
index|[
name|temp
operator|-
literal|1
index|]
argument_list|)
condition|)
name|temp
operator|--
expr_stmt|;
name|output_paragraph
index|[
name|temp
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
comment|/* We have correctly broken the line where we want 			   to.  What we don't want is spaces following where 			   we have decided to break the line.  We get rid of 			   them. */
block|{
name|int
name|t1
init|=
name|temp
decl_stmt|;
for|for
control|(
init|;
condition|;
name|t1
operator|++
control|)
block|{
if|if
condition|(
name|t1
operator|==
name|output_paragraph_offset
condition|)
block|{
if|if
condition|(
name|whitespace
argument_list|(
name|character
argument_list|)
condition|)
name|suppress_insert
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|whitespace
argument_list|(
name|output_paragraph
index|[
name|t1
index|]
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|t1
operator|!=
name|temp
condition|)
block|{
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|output_paragraph
index|[
name|temp
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|output_paragraph
index|[
name|t1
index|]
argument_list|,
operator|(
name|output_paragraph_offset
operator|-
name|t1
operator|)
argument_list|)
expr_stmt|;
name|output_paragraph_offset
operator|-=
operator|(
name|t1
operator|-
name|temp
operator|)
expr_stmt|;
block|}
block|}
comment|/* Filled, but now indent if that is right. */
if|if
condition|(
name|indented_fill
operator|&&
name|current_indent
condition|)
block|{
name|int
name|buffer_len
init|=
operator|(
operator|(
name|output_paragraph_offset
operator|-
name|temp
operator|)
operator|+
name|current_indent
operator|)
decl_stmt|;
name|char
modifier|*
name|temp_buffer
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|buffer_len
argument_list|)
decl_stmt|;
name|int
name|indentation
init|=
literal|0
decl_stmt|;
comment|/* We have to shift any markers that are in 			       front of the wrap point. */
block|{
specifier|register
name|BRACE_ELEMENT
modifier|*
name|stack
init|=
name|brace_stack
decl_stmt|;
while|while
condition|(
name|stack
condition|)
block|{
if|if
condition|(
name|stack
operator|->
name|pos
operator|>=
name|temp
condition|)
name|stack
operator|->
name|pos
operator|+=
name|current_indent
expr_stmt|;
name|stack
operator|=
name|stack
operator|->
name|next
expr_stmt|;
block|}
block|}
while|while
condition|(
name|current_indent
operator|>
literal|0
operator|&&
name|indentation
operator|!=
name|current_indent
condition|)
name|temp_buffer
index|[
name|indentation
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|temp_buffer
index|[
name|current_indent
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|output_paragraph
index|[
name|temp
index|]
argument_list|,
name|buffer_len
operator|-
name|current_indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_paragraph_offset
operator|+
name|buffer_len
operator|>=
name|paragraph_buffer_len
condition|)
block|{
name|unsigned
name|char
modifier|*
name|tt
init|=
name|xrealloc
argument_list|(
name|output_paragraph
argument_list|,
operator|(
name|paragraph_buffer_len
operator|+=
name|buffer_len
operator|)
argument_list|)
decl_stmt|;
name|output_paragraph
operator|=
name|tt
expr_stmt|;
block|}
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|output_paragraph
index|[
name|temp
index|]
argument_list|,
name|temp_buffer
argument_list|,
name|buffer_len
argument_list|)
expr_stmt|;
name|output_paragraph_offset
operator|+=
name|current_indent
expr_stmt|;
name|free
argument_list|(
name|temp_buffer
argument_list|)
expr_stmt|;
block|}
name|output_column
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|temp
operator|<
name|output_paragraph_offset
condition|)
name|output_column
operator|+=
name|get_char_len
argument_list|(
name|output_paragraph
index|[
name|temp
operator|++
index|]
argument_list|)
expr_stmt|;
name|output_column
operator|+=
name|len
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|suppress_insert
condition|)
block|{
name|insert
argument_list|(
name|character
argument_list|)
expr_stmt|;
name|last_inserted_character
operator|=
name|character
expr_stmt|;
block|}
name|last_char_was_newline
operator|=
literal|0
expr_stmt|;
name|line_already_broken
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Insert CHARACTER into OUTPUT_PARAGRAPH. */
end_comment

begin_macro
name|insert
argument_list|(
argument|character
argument_list|)
end_macro

begin_decl_stmt
name|int
name|character
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|output_paragraph
index|[
name|output_paragraph_offset
operator|++
index|]
operator|=
name|character
expr_stmt|;
if|if
condition|(
name|output_paragraph_offset
operator|==
name|paragraph_buffer_len
condition|)
block|{
name|output_paragraph
operator|=
name|xrealloc
argument_list|(
name|output_paragraph
argument_list|,
operator|(
name|paragraph_buffer_len
operator|+=
literal|100
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Remove upto COUNT characters of whitespace from the    the current output line.  If COUNT is less than zero,    then remove until none left. */
end_comment

begin_macro
name|kill_self_indent
argument_list|(
argument|count
argument_list|)
end_macro

begin_decl_stmt
name|int
name|count
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Handle infinite case first. */
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|output_column
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|output_paragraph_offset
condition|)
block|{
if|if
condition|(
name|whitespace
argument_list|(
name|output_paragraph
index|[
name|output_paragraph_offset
operator|-
literal|1
index|]
argument_list|)
condition|)
name|output_paragraph_offset
operator|--
expr_stmt|;
else|else
break|break;
block|}
block|}
else|else
block|{
while|while
condition|(
name|output_paragraph_offset
operator|&&
name|count
operator|--
condition|)
if|if
condition|(
name|whitespace
argument_list|(
name|output_paragraph
index|[
name|output_paragraph_offset
operator|-
literal|1
index|]
argument_list|)
condition|)
name|output_paragraph_offset
operator|--
expr_stmt|;
else|else
break|break;
block|}
block|}
end_block

begin_comment
comment|/* Non-zero means do not honor calls to flush_output (). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flushing_ignored
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prevent calls to flush_output () from having any effect. */
end_comment

begin_macro
name|inhibit_output_flushing
argument_list|()
end_macro

begin_block
block|{
name|flushing_ignored
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Allow calls to flush_output () to write the paragraph data. */
end_comment

begin_macro
name|uninhibit_output_flushing
argument_list|()
end_macro

begin_block
block|{
name|flushing_ignored
operator|--
expr_stmt|;
block|}
end_block

begin_macro
name|flush_output
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|output_paragraph_offset
operator|||
name|flushing_ignored
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|output_paragraph_offset
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|output_paragraph
index|[
name|i
index|]
operator|==
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|' '
operator||
literal|0x80
argument_list|)
operator|||
name|output_paragraph
index|[
name|i
index|]
operator|==
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|'\t'
operator||
literal|0x80
argument_list|)
operator|||
name|output_paragraph
index|[
name|i
index|]
operator|==
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|'\n'
operator||
literal|0x80
argument_list|)
operator|||
name|sentence_ender
argument_list|(
name|UNMETA
argument_list|(
name|output_paragraph
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
name|output_paragraph
index|[
name|i
index|]
operator|&=
literal|0x7f
expr_stmt|;
block|}
name|fwrite
argument_list|(
name|output_paragraph
argument_list|,
literal|1
argument_list|,
name|output_paragraph_offset
argument_list|,
name|output_stream
argument_list|)
expr_stmt|;
name|output_position
operator|+=
name|output_paragraph_offset
expr_stmt|;
name|output_paragraph_offset
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* How to close a paragraph controlling the number of lines between    this one and the last one. */
end_comment

begin_comment
comment|/* Paragraph spacing is controlled by this variable.  It is the number of    blank lines that you wish to appear between paragraphs.  A value of    1 creates a single blank line between paragraphs. */
end_comment

begin_decl_stmt
name|int
name|paragraph_spacing
init|=
name|DEFAULT_PARAGRAPH_SPACING
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Close the current paragraph, leaving no blank lines between them. */
end_comment

begin_macro
name|close_single_paragraph
argument_list|()
end_macro

begin_block
block|{
name|close_paragraph_with_lines
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Close a paragraph after an insertion has ended. */
end_comment

begin_macro
name|close_insertion_paragraph
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|insertion_paragraph_closed
condition|)
block|{
comment|/* Close the current paragraph, breaking the line. */
name|close_single_paragraph
argument_list|()
expr_stmt|;
comment|/* Start a new paragraph here, inserting whatever indention is correct 	 for the now current insertion level (one above the one that we are 	 ending). */
name|start_paragraph
argument_list|()
expr_stmt|;
comment|/* Tell close_paragraph () that the previous line has already been 	 broken, so it should insert one less newline. */
name|line_already_broken
operator|=
literal|1
expr_stmt|;
comment|/* Let functions such as add_char () know that we have already found a 	 newline. */
name|ignore_blank_line
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* If the insertion paragraph is closed already, then we are seeing 	 two `@end' commands in a row.  Note that the first one we saw was 	 handled in the first part of this if-then-else clause, and at that 	 time start_paragraph () was called, partially to handle the proper 	 indentation of the current line.  However, the indentation level 	 may have just changed again, so we may have to outdent the current 	 line to the new indentation level. */
if|if
condition|(
name|current_indent
operator|<
name|output_column
condition|)
name|kill_self_indent
argument_list|(
name|output_column
operator|-
name|current_indent
argument_list|)
expr_stmt|;
block|}
name|insertion_paragraph_closed
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|close_paragraph_with_lines
argument_list|(
argument|lines
argument_list|)
end_macro

begin_decl_stmt
name|int
name|lines
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|old_spacing
init|=
name|paragraph_spacing
decl_stmt|;
name|paragraph_spacing
operator|=
name|lines
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|paragraph_spacing
operator|=
name|old_spacing
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Close the currently open paragraph. */
end_comment

begin_macro
name|close_paragraph
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* The insertion paragraph is no longer closed. */
name|insertion_paragraph_closed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|paragraph_is_open
operator|&&
operator|!
name|must_start_paragraph
condition|)
block|{
specifier|register
name|int
name|tindex
decl_stmt|,
name|c
decl_stmt|;
name|tindex
operator|=
name|output_paragraph_offset
expr_stmt|;
comment|/* Back up to last non-newline/space character, forcing all such 	 subsequent characters to be newlines.  This isn't strictly 	 necessary, but a couple of functions use the presence of a newline 	 to make decisions. */
for|for
control|(
name|tindex
operator|=
name|output_paragraph_offset
operator|-
literal|1
init|;
name|tindex
operator|>=
literal|0
condition|;
operator|--
name|tindex
control|)
block|{
name|c
operator|=
name|output_paragraph
index|[
name|tindex
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
condition|)
name|output_paragraph
index|[
name|tindex
index|]
operator|=
literal|'\n'
expr_stmt|;
else|else
break|break;
block|}
comment|/* All trailing whitespace is ignored. */
name|output_paragraph_offset
operator|=
operator|++
name|tindex
expr_stmt|;
comment|/* Break the line if that is appropriate. */
if|if
condition|(
name|paragraph_spacing
operator|>=
literal|0
condition|)
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Add as many blank lines as is specified in PARAGRAPH_SPACING. */
if|if
condition|(
operator|!
name|force_flush_right
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|paragraph_spacing
operator|-
name|line_already_broken
operator|)
condition|;
name|i
operator|++
control|)
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
comment|/* If we are doing flush right indentation, then do it now 	 on the paragraph (really a single line). */
if|if
condition|(
name|force_flush_right
condition|)
name|do_flush_right_indentation
argument_list|()
expr_stmt|;
name|flush_output
argument_list|()
expr_stmt|;
name|paragraph_is_open
operator|=
literal|0
expr_stmt|;
name|no_indent
operator|=
literal|0
expr_stmt|;
name|output_column
operator|=
literal|0
expr_stmt|;
block|}
name|ignore_blank_line
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Make the last line just read look as if it were only a newline. */
end_comment

begin_macro
name|ignore_blank_line
argument_list|()
end_macro

begin_block
block|{
name|last_inserted_character
operator|=
literal|'\n'
expr_stmt|;
name|last_char_was_newline
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Align the end of the text in output_paragraph with fill_column. */
end_comment

begin_macro
name|do_flush_right_indentation
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|temp_len
decl_stmt|;
name|kill_self_indent
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_paragraph
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|output_paragraph
index|[
name|output_paragraph_offset
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|output_paragraph_offset
operator|<
name|fill_column
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fill_column
operator|>=
name|paragraph_buffer_len
condition|)
name|output_paragraph
operator|=
name|xrealloc
argument_list|(
name|output_paragraph
argument_list|,
operator|(
name|paragraph_buffer_len
operator|+=
name|fill_column
operator|)
argument_list|)
expr_stmt|;
name|temp_len
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|output_paragraph
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|temp_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|temp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|output_paragraph
argument_list|,
name|temp_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fill_column
operator|-
name|output_paragraph_offset
condition|;
name|i
operator|++
control|)
name|output_paragraph
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|output_paragraph
operator|+
name|i
argument_list|,
name|temp
argument_list|,
name|temp_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|output_paragraph_offset
operator|=
name|fill_column
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Begin a new paragraph. */
end_comment

begin_macro
name|start_paragraph
argument_list|()
end_macro

begin_block
block|{
comment|/* First close existing one. */
if|if
condition|(
name|paragraph_is_open
condition|)
name|close_paragraph
argument_list|()
expr_stmt|;
comment|/* In either case, the insertion paragraph is no longer closed. */
name|insertion_paragraph_closed
operator|=
literal|0
expr_stmt|;
comment|/* However, the paragraph is open! */
name|paragraph_is_open
operator|=
literal|1
expr_stmt|;
comment|/* If we MUST_START_PARAGRAPH, that simply means that start_paragraph ()      had to be called before we would allow any other paragraph operations      to have an effect. */
if|if
condition|(
operator|!
name|must_start_paragraph
condition|)
block|{
name|int
name|amount_to_indent
init|=
literal|0
decl_stmt|;
comment|/* If doing indentation, then insert the appropriate amount. */
if|if
condition|(
operator|!
name|no_indent
condition|)
block|{
if|if
condition|(
name|inhibit_paragraph_indentation
condition|)
block|{
name|amount_to_indent
operator|=
name|current_indent
expr_stmt|;
if|if
condition|(
name|inhibit_paragraph_indentation
operator|<
literal|0
condition|)
name|inhibit_paragraph_indentation
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|paragraph_start_indent
operator|<
literal|0
condition|)
name|amount_to_indent
operator|=
name|current_indent
expr_stmt|;
else|else
name|amount_to_indent
operator|=
name|current_indent
operator|+
name|paragraph_start_indent
expr_stmt|;
if|if
condition|(
name|amount_to_indent
operator|>=
name|output_column
condition|)
block|{
name|amount_to_indent
operator|-=
name|output_column
expr_stmt|;
name|indent
argument_list|(
name|amount_to_indent
argument_list|)
expr_stmt|;
name|output_column
operator|+=
name|amount_to_indent
expr_stmt|;
block|}
block|}
block|}
else|else
name|must_start_paragraph
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Insert the indentation specified by AMOUNT. */
end_comment

begin_macro
name|indent
argument_list|(
argument|amount
argument_list|)
end_macro

begin_decl_stmt
name|int
name|amount
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|BRACE_ELEMENT
modifier|*
name|elt
init|=
name|brace_stack
decl_stmt|;
comment|/* For every START_POS saved within the brace stack which will be affected      by this indentation, bump that start pos forward. */
while|while
condition|(
name|elt
condition|)
block|{
if|if
condition|(
name|elt
operator|->
name|pos
operator|>=
name|output_paragraph_offset
condition|)
name|elt
operator|->
name|pos
operator|+=
name|amount
expr_stmt|;
name|elt
operator|=
name|elt
operator|->
name|next
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|amount
operator|>=
literal|0
condition|)
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Search forward for STRING in input_text.    FROM says where where to start. */
end_comment

begin_macro
name|search_forward
argument_list|(
argument|string
argument_list|,
argument|from
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|from
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
while|while
condition|(
name|from
operator|<
name|size_of_input_text
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|input_text
operator|+
name|from
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|from
operator|)
return|;
name|from
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Whoops, Unix doesn't have stricmp. */
end_comment

begin_comment
comment|/* Case independent string compare. */
end_comment

begin_macro
name|stricmp
argument_list|(
argument|string1
argument_list|,
argument|string2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string1
decl_stmt|,
modifier|*
name|string2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|ch1
decl_stmt|,
name|ch2
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch1
operator|=
operator|*
name|string1
operator|++
expr_stmt|;
name|ch2
operator|=
operator|*
name|string2
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ch1
operator||
name|ch2
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ch1
operator|=
name|coerce_to_upper
argument_list|(
name|ch1
argument_list|)
expr_stmt|;
name|ch2
operator|=
name|coerce_to_upper
argument_list|(
name|ch2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch1
operator|!=
name|ch2
condition|)
return|return
operator|(
name|ch1
operator|-
name|ch2
operator|)
return|;
block|}
block|}
end_block

begin_enum
enum|enum
name|insertion_type
block|{
name|menu
block|,
name|quotation
block|,
name|lisp
block|,
name|smalllisp
block|,
name|example
block|,
name|smallexample
block|,
name|display
block|,
name|itemize
block|,
name|format
block|,
name|enumerate
block|,
name|cartouche
block|,
name|table
block|,
name|ftable
block|,
name|vtable
block|,
name|group
block|,
name|ifinfo
block|,
name|flushleft
block|,
name|flushright
block|,
name|ifset
block|,
name|ifclear
block|,
name|deffn
block|,
name|defun
block|,
name|defmac
block|,
name|defspec
block|,
name|defvr
block|,
name|defvar
block|,
name|defopt
block|,
name|deftypefn
block|,
name|deftypefun
block|,
name|deftypevr
block|,
name|deftypevar
block|,
name|defcv
block|,
name|defivar
block|,
name|defop
block|,
name|defmethod
block|,
name|deftypemethod
block|,
name|deftp
block|,
name|bad_type
block|}
enum|;
end_enum

begin_decl_stmt
name|char
modifier|*
name|insertion_type_names
index|[]
init|=
block|{
literal|"menu"
block|,
literal|"quotation"
block|,
literal|"lisp"
block|,
literal|"smalllisp"
block|,
literal|"example"
block|,
literal|"smallexample"
block|,
literal|"display"
block|,
literal|"itemize"
block|,
literal|"format"
block|,
literal|"enumerate"
block|,
literal|"cartouche"
block|,
literal|"table"
block|,
literal|"ftable"
block|,
literal|"vtable"
block|,
literal|"group"
block|,
literal|"ifinfo"
block|,
literal|"flushleft"
block|,
literal|"flushright"
block|,
literal|"ifset"
block|,
literal|"ifclear"
block|,
literal|"deffn"
block|,
literal|"defun"
block|,
literal|"defmac"
block|,
literal|"defspec"
block|,
literal|"defvr"
block|,
literal|"defvar"
block|,
literal|"defopt"
block|,
literal|"deftypefn"
block|,
literal|"deftypefun"
block|,
literal|"deftypevr"
block|,
literal|"deftypevar"
block|,
literal|"defcv"
block|,
literal|"defivar"
block|,
literal|"defop"
block|,
literal|"defmethod"
block|,
literal|"deftypemethod"
block|,
literal|"deftp"
block|,
literal|"bad_type"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|insertion_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|istack_elt
block|{
name|struct
name|istack_elt
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|item_function
decl_stmt|;
name|int
name|line_number
decl_stmt|;
name|int
name|filling_enabled
decl_stmt|;
name|int
name|indented_fill
decl_stmt|;
name|enum
name|insertion_type
name|insertion
decl_stmt|;
name|int
name|inhibited
decl_stmt|;
block|}
name|INSERTION_ELT
typedef|;
end_typedef

begin_decl_stmt
name|INSERTION_ELT
modifier|*
name|insertion_stack
init|=
operator|(
name|INSERTION_ELT
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_macro
name|init_insertion_stack
argument_list|()
end_macro

begin_block
block|{
name|insertion_stack
operator|=
operator|(
name|INSERTION_ELT
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return the type of the current insertion. */
end_comment

begin_function
name|enum
name|insertion_type
name|current_insertion_type
parameter_list|()
block|{
if|if
condition|(
operator|!
name|insertion_level
condition|)
return|return
operator|(
name|bad_type
operator|)
return|;
else|else
return|return
operator|(
name|insertion_stack
operator|->
name|insertion
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the string which is the function to wrap around    items. */
end_comment

begin_function
name|char
modifier|*
name|current_item_function
parameter_list|()
block|{
specifier|register
name|int
name|level
decl_stmt|,
name|done
decl_stmt|;
specifier|register
name|INSERTION_ELT
modifier|*
name|elt
decl_stmt|;
name|level
operator|=
name|insertion_level
expr_stmt|;
name|elt
operator|=
name|insertion_stack
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
comment|/* Skip down through the stack until we find a non-conditional insertion. */
while|while
condition|(
operator|!
name|done
condition|)
block|{
switch|switch
condition|(
name|elt
operator|->
name|insertion
condition|)
block|{
case|case
name|ifinfo
case|:
case|case
name|ifset
case|:
case|case
name|ifclear
case|:
case|case
name|cartouche
case|:
name|elt
operator|=
name|elt
operator|->
name|next
expr_stmt|;
name|level
operator|--
expr_stmt|;
break|break;
default|default:
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|level
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|elt
operator|->
name|item_function
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|get_item_function
parameter_list|()
block|{
name|char
modifier|*
name|item_function
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|item_function
argument_list|)
expr_stmt|;
name|backup_input_pointer
argument_list|()
expr_stmt|;
name|canon_white
argument_list|(
name|item_function
argument_list|)
expr_stmt|;
return|return
operator|(
name|item_function
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Push the state of the current insertion on the stack. */
end_comment

begin_expr_stmt
name|push_insertion
argument_list|(
name|type
argument_list|,
name|item_function
argument_list|)
expr|enum
name|insertion_type
name|type
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|item_function
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|INSERTION_ELT
modifier|*
name|new
init|=
operator|(
name|INSERTION_ELT
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|INSERTION_ELT
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|item_function
operator|=
name|item_function
expr_stmt|;
name|new
operator|->
name|filling_enabled
operator|=
name|filling_enabled
expr_stmt|;
name|new
operator|->
name|indented_fill
operator|=
name|indented_fill
expr_stmt|;
name|new
operator|->
name|insertion
operator|=
name|type
expr_stmt|;
name|new
operator|->
name|line_number
operator|=
name|line_number
expr_stmt|;
name|new
operator|->
name|inhibited
operator|=
name|inhibit_paragraph_indentation
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|insertion_stack
expr_stmt|;
name|insertion_stack
operator|=
name|new
expr_stmt|;
name|insertion_level
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Pop the value on top of the insertion stack into the     global variables. */
end_comment

begin_macro
name|pop_insertion
argument_list|()
end_macro

begin_block
block|{
name|INSERTION_ELT
modifier|*
name|temp
init|=
name|insertion_stack
decl_stmt|;
if|if
condition|(
name|temp
operator|==
operator|(
name|INSERTION_ELT
operator|*
operator|)
name|NULL
condition|)
return|return;
name|inhibit_paragraph_indentation
operator|=
name|temp
operator|->
name|inhibited
expr_stmt|;
name|filling_enabled
operator|=
name|temp
operator|->
name|filling_enabled
expr_stmt|;
name|indented_fill
operator|=
name|temp
operator|->
name|indented_fill
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
operator|(
name|temp
operator|->
name|item_function
operator|)
argument_list|)
expr_stmt|;
name|insertion_stack
operator|=
name|insertion_stack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|insertion_level
operator|--
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return a pointer to the print name of this     enumerated type. */
end_comment

begin_function
name|char
modifier|*
name|insertion_type_pname
parameter_list|(
name|type
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|type
operator|<
operator|(
name|int
operator|)
name|bad_type
condition|)
return|return
operator|(
name|insertion_type_names
index|[
operator|(
name|int
operator|)
name|type
index|]
operator|)
return|;
else|else
return|return
operator|(
literal|"Broken-Type in insertion_type_pname"
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the insertion_type associated with NAME.    If the type is not one of the known ones, return BAD_TYPE. */
end_comment

begin_function
name|enum
name|insertion_type
name|find_type_from_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|index
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|index
operator|<
operator|(
name|int
operator|)
name|bad_type
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|insertion_type_names
index|[
name|index
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
expr|enum
name|insertion_type
operator|)
name|index
return|;
name|index
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|bad_type
operator|)
return|;
block|}
end_function

begin_macro
name|do_nothing
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_function
name|int
name|defun_insertion
parameter_list|(
name|type
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|type
operator|==
name|deffn
operator|)
operator|||
operator|(
name|type
operator|==
name|defun
operator|)
operator|||
operator|(
name|type
operator|==
name|defmac
operator|)
operator|||
operator|(
name|type
operator|==
name|defspec
operator|)
operator|||
operator|(
name|type
operator|==
name|defvr
operator|)
operator|||
operator|(
name|type
operator|==
name|defvar
operator|)
operator|||
operator|(
name|type
operator|==
name|defopt
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypefn
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypefun
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypevr
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypevar
operator|)
operator|||
operator|(
name|type
operator|==
name|defcv
operator|)
operator|||
operator|(
name|type
operator|==
name|defivar
operator|)
operator|||
operator|(
name|type
operator|==
name|defop
operator|)
operator|||
operator|(
name|type
operator|==
name|defmethod
operator|)
operator|||
operator|(
name|type
operator|==
name|deftypemethod
operator|)
operator|||
operator|(
name|type
operator|==
name|deftp
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* MAX_NS is the maximum nesting level for enumerations.  I picked 100    which seemed reasonable.  This doesn't control the number of items,    just the number of nested lists. */
end_comment

begin_define
define|#
directive|define
name|max_stack_depth
value|100
end_define

begin_define
define|#
directive|define
name|ENUM_DIGITS
value|1
end_define

begin_define
define|#
directive|define
name|ENUM_ALPHA
value|2
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|enumtype
decl_stmt|;
name|int
name|enumval
decl_stmt|;
block|}
name|DIGIT_ALPHA
typedef|;
end_typedef

begin_decl_stmt
name|DIGIT_ALPHA
name|enumstack
index|[
name|max_stack_depth
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|enumstack_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_enumval
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_enumtype
init|=
name|ENUM_DIGITS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|enumeration_arg
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_macro
name|start_enumerating
argument_list|(
argument|at
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|at
decl_stmt|,
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|enumstack_offset
operator|+
literal|1
operator|)
operator|==
name|max_stack_depth
condition|)
block|{
name|line_error
argument_list|(
literal|"Enumeration stack overflow"
argument_list|)
expr_stmt|;
return|return;
block|}
name|enumstack
index|[
name|enumstack_offset
index|]
operator|.
name|enumtype
operator|=
name|current_enumtype
expr_stmt|;
name|enumstack
index|[
name|enumstack_offset
index|]
operator|.
name|enumval
operator|=
name|current_enumval
expr_stmt|;
name|enumstack_offset
operator|++
expr_stmt|;
name|current_enumval
operator|=
name|at
expr_stmt|;
name|current_enumtype
operator|=
name|type
expr_stmt|;
block|}
end_block

begin_macro
name|stop_enumerating
argument_list|()
end_macro

begin_block
block|{
operator|--
name|enumstack_offset
expr_stmt|;
if|if
condition|(
name|enumstack_offset
operator|<
literal|0
condition|)
name|enumstack_offset
operator|=
literal|0
expr_stmt|;
name|current_enumval
operator|=
name|enumstack
index|[
name|enumstack_offset
index|]
operator|.
name|enumval
expr_stmt|;
name|current_enumtype
operator|=
name|enumstack
index|[
name|enumstack_offset
index|]
operator|.
name|enumtype
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Place a letter or digits into the output stream. */
end_comment

begin_macro
name|enumerate_item
argument_list|()
end_macro

begin_block
block|{
name|char
name|temp
index|[
literal|10
index|]
decl_stmt|;
if|if
condition|(
name|current_enumtype
operator|==
name|ENUM_ALPHA
condition|)
block|{
if|if
condition|(
name|current_enumval
operator|==
operator|(
literal|'z'
operator|+
literal|1
operator|)
operator|||
name|current_enumval
operator|==
operator|(
literal|'Z'
operator|+
literal|1
operator|)
condition|)
block|{
name|current_enumval
operator|=
operator|(
operator|(
name|current_enumval
operator|-
literal|1
operator|)
operator|==
literal|'z'
condition|?
literal|'a'
else|:
literal|'A'
operator|)
expr_stmt|;
name|warning
argument_list|(
literal|"Lettering overflow, restarting at %c"
argument_list|,
name|current_enumval
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%c. "
argument_list|,
name|current_enumval
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%d. "
argument_list|,
name|current_enumval
argument_list|)
expr_stmt|;
name|indent
argument_list|(
name|output_column
operator|+=
operator|(
name|current_indent
operator|-
name|strlen
argument_list|(
name|temp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|add_word
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|current_enumval
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* This is where the work for all the "insertion" style    commands is done.  A huge switch statement handles the    various setups, and generic code is on both sides. */
end_comment

begin_expr_stmt
name|begin_insertion
argument_list|(
name|type
argument_list|)
expr|enum
name|insertion_type
name|type
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|no_discard
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|defun_insertion
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|push_insertion
argument_list|(
name|type
argument_list|,
name|savestring
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|no_discard
operator|++
expr_stmt|;
block|}
else|else
name|push_insertion
argument_list|(
name|type
argument_list|,
name|get_item_function
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|menu
case|:
if|if
condition|(
operator|!
name|no_headers
condition|)
name|close_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|no_indent
operator|=
literal|0
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|no_headers
condition|)
name|add_word
argument_list|(
literal|"* Menu:\n"
argument_list|)
expr_stmt|;
name|in_menu
operator|++
expr_stmt|;
name|no_discard
operator|++
expr_stmt|;
break|break;
comment|/* I think @quotation is meant to do filling. 	 If you don't want filling, then use @example. */
case|case
name|quotation
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|last_char_was_newline
operator|=
name|no_indent
operator|=
literal|0
expr_stmt|;
name|indented_fill
operator|=
name|filling_enabled
operator|=
literal|1
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
break|break;
case|case
name|display
case|:
case|case
name|example
case|:
case|case
name|smallexample
case|:
case|case
name|lisp
case|:
case|case
name|smalllisp
case|:
comment|/* Just like @example, but no indentation. */
case|case
name|format
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|in_fixed_width_font
operator|++
expr_stmt|;
name|filling_enabled
operator|=
literal|0
expr_stmt|;
name|last_char_was_newline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|format
condition|)
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
break|break;
case|case
name|table
case|:
case|case
name|ftable
case|:
case|case
name|vtable
case|:
case|case
name|itemize
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INDENT_PARAGRAPHS_IN_TABLE
argument_list|)
name|inhibit_paragraph_indentation
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* !INDENT_PARAGRAPHS_IN_TABLE */
comment|/* Make things work for losers who forget the itemize syntax. */
if|if
condition|(
name|type
operator|==
name|itemize
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|insertion_stack
operator|->
name|item_function
operator|)
condition|)
block|{
name|free
argument_list|(
name|insertion_stack
operator|->
name|item_function
argument_list|)
expr_stmt|;
name|insertion_stack
operator|->
name|item_function
operator|=
name|savestring
argument_list|(
literal|"@bullet"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|enumerate
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|no_indent
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INDENT_PARAGRAPHS_IN_TABLE
argument_list|)
name|inhibit_paragraph_indentation
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* !INDENT_PARAGRAPHS_IN_TABLE */
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|enumeration_arg
argument_list|)
condition|)
name|start_enumerating
argument_list|(
name|atoi
argument_list|(
name|enumeration_arg
argument_list|)
argument_list|,
name|ENUM_DIGITS
argument_list|)
expr_stmt|;
else|else
name|start_enumerating
argument_list|(
operator|*
name|enumeration_arg
argument_list|,
name|ENUM_ALPHA
argument_list|)
expr_stmt|;
break|break;
comment|/* Does nothing special in makeinfo. */
case|case
name|group
case|:
comment|/* Only close the paragraph if we are not inside of an @example. */
if|if
condition|(
operator|!
name|insertion_stack
operator|->
name|next
operator|||
name|insertion_stack
operator|->
name|next
operator|->
name|insertion
operator|!=
name|example
condition|)
name|close_single_paragraph
argument_list|()
expr_stmt|;
break|break;
comment|/* Insertions that are no-ops in info, but do something in TeX. */
case|case
name|ifinfo
case|:
case|case
name|ifset
case|:
case|case
name|ifclear
case|:
case|case
name|cartouche
case|:
if|if
condition|(
name|in_menu
condition|)
name|no_discard
operator|++
expr_stmt|;
break|break;
case|case
name|deffn
case|:
case|case
name|defun
case|:
case|case
name|defmac
case|:
case|case
name|defspec
case|:
case|case
name|defvr
case|:
case|case
name|defvar
case|:
case|case
name|defopt
case|:
case|case
name|deftypefn
case|:
case|case
name|deftypefun
case|:
case|case
name|deftypevr
case|:
case|case
name|deftypevar
case|:
case|case
name|defcv
case|:
case|case
name|defivar
case|:
case|case
name|defop
case|:
case|case
name|defmethod
case|:
case|case
name|deftypemethod
case|:
case|case
name|deftp
case|:
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|1
expr_stmt|;
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
name|no_indent
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|flushleft
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
name|no_indent
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|flushright
case|:
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
name|no_indent
operator|=
literal|0
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|force_flush_right
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|no_discard
condition|)
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Try to end the insertion with the specified TYPE.    TYPE, with a value of bad_type,  gets translated to match    the value currently on top of the stack.    Otherwise, if TYPE doesn't match the top of the insertion stack,    give error. */
end_comment

begin_expr_stmt
name|end_insertion
argument_list|(
name|type
argument_list|)
expr|enum
name|insertion_type
name|type
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|enum
name|insertion_type
name|temp_type
decl_stmt|;
if|if
condition|(
operator|!
name|insertion_level
condition|)
return|return;
name|temp_type
operator|=
name|current_insertion_type
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|bad_type
condition|)
name|type
operator|=
name|temp_type
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|temp_type
condition|)
block|{
name|line_error
argument_list|(
literal|"`%cend' expected `%s', but saw `%s'."
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|insertion_type_pname
argument_list|(
name|temp_type
argument_list|)
argument_list|,
name|insertion_type_pname
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|pop_insertion
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
comment|/* Insertions which have no effect on paragraph formatting. */
case|case
name|ifinfo
case|:
case|case
name|ifset
case|:
case|case
name|ifclear
case|:
break|break;
case|case
name|menu
case|:
name|in_menu
operator|--
expr_stmt|;
comment|/* No longer hacking menus. */
if|if
condition|(
operator|!
name|no_headers
condition|)
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
case|case
name|enumerate
case|:
name|stop_enumerating
argument_list|()
expr_stmt|;
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
break|break;
case|case
name|flushleft
case|:
case|case
name|group
case|:
case|case
name|cartouche
case|:
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
case|case
name|format
case|:
case|case
name|display
case|:
case|case
name|example
case|:
case|case
name|smallexample
case|:
case|case
name|lisp
case|:
case|case
name|smalllisp
case|:
case|case
name|quotation
case|:
comment|/* @quotation is the only one of the above without a fixed width 	 font. */
if|if
condition|(
name|type
operator|!=
name|quotation
condition|)
name|in_fixed_width_font
operator|--
expr_stmt|;
comment|/* @format is the only fixed_width insertion without a change 	 in indentation. */
if|if
condition|(
name|type
operator|!=
name|format
condition|)
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
comment|/* The ending of one of these insertions always marks the 	 start of a new paragraph. */
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
case|case
name|table
case|:
case|case
name|ftable
case|:
case|case
name|vtable
case|:
case|case
name|itemize
case|:
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
break|break;
case|case
name|flushright
case|:
name|force_flush_right
operator|--
expr_stmt|;
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
comment|/* Handle the @defun style insertions with a default clause. */
default|default:
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
name|close_insertion_paragraph
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/* Insertions cannot cross certain boundaries, such as node beginnings.  In    code that creates such boundaries, you should call discard_insertions ()    before doing anything else.  It prints the errors for you, and cleans up    the insertion stack. */
end_comment

begin_macro
name|discard_insertions
argument_list|()
end_macro

begin_block
block|{
name|int
name|real_line_number
init|=
name|line_number
decl_stmt|;
while|while
condition|(
name|insertion_stack
condition|)
block|{
if|if
condition|(
name|insertion_stack
operator|->
name|insertion
operator|==
name|ifinfo
operator|||
name|insertion_stack
operator|->
name|insertion
operator|==
name|ifset
operator|||
name|insertion_stack
operator|->
name|insertion
operator|==
name|ifclear
operator|||
name|insertion_stack
operator|->
name|insertion
operator|==
name|cartouche
condition|)
break|break;
else|else
block|{
name|char
modifier|*
name|offender
init|=
operator|(
name|char
operator|*
operator|)
name|insertion_type_pname
argument_list|(
name|insertion_stack
operator|->
name|insertion
argument_list|)
decl_stmt|;
name|line_number
operator|=
name|insertion_stack
operator|->
name|line_number
expr_stmt|;
name|line_error
argument_list|(
literal|"This `%s' doesn't have a matching `%cend %s'"
argument_list|,
name|offender
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|offender
argument_list|)
expr_stmt|;
name|pop_insertion
argument_list|()
expr_stmt|;
block|}
block|}
name|line_number
operator|=
name|real_line_number
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The actual commands themselves. */
end_comment

begin_comment
comment|/* Commands which insert themselves. */
end_comment

begin_macro
name|insert_self
argument_list|()
end_macro

begin_block
block|{
name|add_word
argument_list|(
name|command
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Force a line break in the output. */
end_comment

begin_macro
name|cm_asterisk
argument_list|()
end_macro

begin_block
block|{
name|close_single_paragraph
argument_list|()
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ASTERISK_NEW_PARAGRAPH
argument_list|)
name|cm_noindent
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* ASTERISK_NEW_PARAGRAPH */
block|}
end_block

begin_comment
comment|/* Insert ellipsis. */
end_comment

begin_macro
name|cm_dots
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_word
argument_list|(
literal|"..."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_bullet
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_char
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_minus
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Insert "TeX". */
end_comment

begin_macro
name|cm_TeX
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_word
argument_list|(
literal|"TeX"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_copyright
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_word
argument_list|(
literal|"(C)"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_today
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
modifier|*
name|months
index|[
literal|12
index|]
init|=
block|{
literal|"January"
block|,
literal|"February"
block|,
literal|"March"
block|,
literal|"April"
block|,
literal|"May"
block|,
literal|"June"
block|,
literal|"July"
block|,
literal|"August"
block|,
literal|"September"
block|,
literal|"October"
block|,
literal|"November"
block|,
literal|"December"
block|}
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
name|long
name|timer
init|=
operator|(
name|time
argument_list|(
literal|0
argument_list|)
operator|)
decl_stmt|;
name|struct
name|tm
modifier|*
name|ts
init|=
operator|(
name|localtime
argument_list|(
operator|&
name|timer
argument_list|)
operator|)
decl_stmt|;
name|add_word_args
argument_list|(
literal|"%d %s %d"
argument_list|,
operator|(
name|ts
operator|->
name|tm_mday
operator|)
argument_list|,
operator|(
name|months
index|[
name|ts
operator|->
name|tm_mon
index|]
operator|)
argument_list|,
operator|(
operator|(
name|ts
operator|->
name|tm_year
operator|)
operator|+
literal|1900
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|cm_code
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|printing_index
decl_stmt|;
if|if
condition|(
name|printing_index
condition|)
return|return;
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
name|in_fixed_width_font
operator|++
expr_stmt|;
name|add_char
argument_list|(
literal|'`'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_word
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|cm_samp
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cm_code
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_file
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cm_code
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_kbd
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cm_code
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_key
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_comment
comment|/* Convert the character at position into CTL. */
end_comment

begin_macro
name|cm_ctrl
argument_list|(
argument|arg
argument_list|,
argument|position
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|,
name|position
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|output_paragraph
index|[
name|position
operator|-
literal|1
index|]
operator|=
name|CTL
argument_list|(
name|output_paragraph
index|[
name|position
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Small Caps in makeinfo just does all caps. */
end_comment

begin_macro
name|cm_sc
argument_list|(
argument|arg
argument_list|,
argument|start_pos
argument_list|,
argument|end_pos
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|,
name|start_pos
decl_stmt|,
name|end_pos
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
block|{
while|while
condition|(
name|start_pos
operator|<
name|end_pos
condition|)
block|{
name|output_paragraph
index|[
name|start_pos
index|]
operator|=
name|coerce_to_upper
argument_list|(
name|output_paragraph
index|[
name|start_pos
index|]
argument_list|)
expr_stmt|;
name|start_pos
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* @var in makeinfo just uppercases the text. */
end_comment

begin_macro
name|cm_var
argument_list|(
argument|arg
argument_list|,
argument|start_pos
argument_list|,
argument|end_pos
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|,
name|start_pos
decl_stmt|,
name|end_pos
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
block|{
while|while
condition|(
name|start_pos
operator|<
name|end_pos
condition|)
block|{
name|output_paragraph
index|[
name|start_pos
index|]
operator|=
name|coerce_to_upper
argument_list|(
name|output_paragraph
index|[
name|start_pos
index|]
argument_list|)
expr_stmt|;
name|start_pos
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|cm_dfn
argument_list|(
argument|arg
argument_list|,
argument|position
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|,
name|position
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|add_char
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_emph
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|add_char
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_strong
argument_list|(
argument|arg
argument_list|,
argument|position
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|,
name|position
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cm_emph
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_cite
argument_list|(
argument|arg
argument_list|,
argument|position
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|,
name|position
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|add_word
argument_list|(
literal|"`"
argument_list|)
expr_stmt|;
else|else
name|add_word
argument_list|(
literal|"'"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Current text is italicized. */
end_comment

begin_macro
name|cm_italic
argument_list|(
argument|arg
argument_list|,
argument|start
argument_list|,
argument|end
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_comment
comment|/* Current text is highlighted. */
end_comment

begin_macro
name|cm_bold
argument_list|(
argument|arg
argument_list|,
argument|start
argument_list|,
argument|end
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cm_italic
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Current text is in roman font. */
end_comment

begin_macro
name|cm_roman
argument_list|(
argument|arg
argument_list|,
argument|start
argument_list|,
argument|end
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_comment
comment|/* Current text is in roman font. */
end_comment

begin_macro
name|cm_titlefont
argument_list|(
argument|arg
argument_list|,
argument|start
argument_list|,
argument|end
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_comment
comment|/* Italicize titles. */
end_comment

begin_macro
name|cm_title
argument_list|(
argument|arg
argument_list|,
argument|start
argument_list|,
argument|end
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cm_italic
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* @refill is a NOP. */
end_comment

begin_macro
name|cm_refill
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_comment
comment|/* Prevent the argument from being split across two lines. */
end_comment

begin_macro
name|cm_w
argument_list|(
argument|arg
argument_list|,
argument|start
argument_list|,
argument|end
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|non_splitting_words
operator|++
expr_stmt|;
else|else
name|non_splitting_words
operator|--
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Explain that this command is obsolete, thus the user shouldn't    do anything with it. */
end_comment

begin_macro
name|cm_obsolete
argument_list|(
argument|arg
argument_list|,
argument|start
argument_list|,
argument|end
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
name|warning
argument_list|(
literal|"The command `@%s' is obsolete"
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Insert the text following input_text_offset up to the end of the line    in a new, separate paragraph.  Directly underneath it, insert a    line of WITH_CHAR, the same length of the inserted text. */
end_comment

begin_macro
name|insert_and_underscore
argument_list|(
argument|with_char
argument_list|)
end_macro

begin_decl_stmt
name|int
name|with_char
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|,
name|i
decl_stmt|,
name|old_no_indent
decl_stmt|;
name|int
name|starting_pos
decl_stmt|,
name|ending_pos
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|0
expr_stmt|;
name|old_no_indent
operator|=
name|no_indent
expr_stmt|;
name|no_indent
operator|=
literal|1
expr_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
name|starting_pos
operator|=
name|output_position
operator|+
name|output_paragraph_offset
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s\n"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|ending_pos
operator|=
name|output_position
operator|+
name|output_paragraph_offset
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
name|ending_pos
operator|-
name|starting_pos
operator|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|add_char
argument_list|(
name|with_char
argument_list|)
expr_stmt|;
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
literal|1
expr_stmt|;
name|no_indent
operator|=
name|old_no_indent
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Here is a structure which associates sectioning commands with    an integer, hopefully to reflect the `depth' of the current    section. */
end_comment

begin_struct
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|level
decl_stmt|;
block|}
name|section_alist
index|[]
init|=
block|{
block|{
literal|"unnumberedsubsubsec"
block|,
literal|5
block|}
block|,
block|{
literal|"unnumberedsubsec"
block|,
literal|4
block|}
block|,
block|{
literal|"unnumberedsec"
block|,
literal|3
block|}
block|,
block|{
literal|"unnumbered"
block|,
literal|2
block|}
block|,
block|{
literal|"appendixsubsubsec"
block|,
literal|5
block|}
block|,
block|{
literal|"appendixsubsec"
block|,
literal|4
block|}
block|,
block|{
literal|"appendixsec"
block|,
literal|3
block|}
block|,
block|{
literal|"appendixsection"
block|,
literal|3
block|}
block|,
block|{
literal|"appendix"
block|,
literal|2
block|}
block|,
block|{
literal|"subsubsec"
block|,
literal|5
block|}
block|,
block|{
literal|"subsubsection"
block|,
literal|5
block|}
block|,
block|{
literal|"subsection"
block|,
literal|4
block|}
block|,
block|{
literal|"section"
block|,
literal|3
block|}
block|,
block|{
literal|"chapter"
block|,
literal|2
block|}
block|,
block|{
literal|"top"
block|,
literal|1
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Amount to offset the name of sectioning commands to levels by. */
end_comment

begin_decl_stmt
name|int
name|section_alist_offset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Shift the meaning of @section to @chapter. */
end_comment

begin_macro
name|cm_raisesections
argument_list|()
end_macro

begin_block
block|{
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|section_alist_offset
operator|--
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Shift the meaning of @chapter to @section. */
end_comment

begin_macro
name|cm_lowersections
argument_list|()
end_macro

begin_block
block|{
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|section_alist_offset
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return an integer which identifies the type section present in TEXT. */
end_comment

begin_function
name|int
name|what_section
parameter_list|(
name|text
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|find_section_command
label|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|text
index|[
name|j
index|]
operator|&&
name|cr_or_whitespace
argument_list|(
name|text
index|[
name|j
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|text
index|[
name|j
index|]
operator|!=
literal|'@'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|text
operator|=
name|text
operator|+
name|j
operator|+
literal|1
expr_stmt|;
comment|/* We skip @c, @comment, and @?index commands. */
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|text
argument_list|,
literal|"comment"
argument_list|,
name|strlen
argument_list|(
literal|"comment"
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|text
index|[
literal|0
index|]
operator|==
literal|'c'
operator|&&
name|cr_or_whitespace
argument_list|(
name|text
index|[
literal|1
index|]
argument_list|)
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|text
operator|+
literal|1
argument_list|,
literal|"index"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
while|while
condition|(
operator|*
name|text
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
goto|goto
name|find_section_command
goto|;
block|}
comment|/* Handle italicized sectioning commands. */
if|if
condition|(
operator|*
name|text
operator|==
literal|'i'
condition|)
name|text
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|text
index|[
name|j
index|]
operator|&&
operator|!
name|cr_or_whitespace
argument_list|(
name|text
index|[
name|j
index|]
argument_list|)
condition|;
name|j
operator|++
control|)
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|t
operator|=
name|section_alist
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|strlen
argument_list|(
name|t
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|t
argument_list|,
name|text
argument_list|,
name|j
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|return_val
decl_stmt|;
name|return_val
operator|=
operator|(
name|section_alist
index|[
name|i
index|]
operator|.
name|level
operator|+
name|section_alist_offset
operator|)
expr_stmt|;
if|if
condition|(
name|return_val
operator|<
literal|0
condition|)
name|return_val
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|return_val
operator|>
literal|5
condition|)
name|return_val
operator|=
literal|5
expr_stmt|;
return|return
operator|(
name|return_val
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Treat this just like @unnumbered.  The only difference is    in node defaulting. */
end_comment

begin_macro
name|cm_top
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|int
name|top_encountered
init|=
literal|0
decl_stmt|;
name|cm_unnumbered
argument_list|()
expr_stmt|;
comment|/* It is an error to have more than one @top. */
if|if
condition|(
name|top_encountered
condition|)
block|{
name|TAG_ENTRY
modifier|*
name|tag
init|=
name|tag_table
decl_stmt|;
name|line_error
argument_list|(
literal|"There already is a node having @top as a section"
argument_list|)
expr_stmt|;
while|while
condition|(
name|tag
operator|!=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|tag
operator|->
name|flags
operator|&
name|IS_TOP
operator|)
condition|)
block|{
name|int
name|old_line_number
init|=
name|line_number
decl_stmt|;
name|char
modifier|*
name|old_input_filename
init|=
name|input_filename
decl_stmt|;
name|line_number
operator|=
name|tag
operator|->
name|line_no
expr_stmt|;
name|input_filename
operator|=
name|tag
operator|->
name|filename
expr_stmt|;
name|line_error
argument_list|(
literal|"Here is the @top node."
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|old_input_filename
expr_stmt|;
name|line_number
operator|=
name|old_line_number
expr_stmt|;
return|return;
block|}
name|tag
operator|=
name|tag
operator|->
name|next_ent
expr_stmt|;
block|}
block|}
else|else
block|{
name|top_encountered
operator|=
literal|1
expr_stmt|;
comment|/* The most recently defined node is the top node. */
if|if
condition|(
name|tag_table
condition|)
name|tag_table
operator|->
name|flags
operator||=
name|IS_TOP
expr_stmt|;
comment|/* Now set the logical hierarchical level of the Top node. */
block|{
name|int
name|orig_offset
init|=
name|input_text_offset
decl_stmt|;
name|input_text_offset
operator|=
name|search_forward
argument_list|(
literal|"\n@node"
argument_list|,
name|orig_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_text_offset
operator|>
literal|0
condition|)
block|{
name|int
name|this_section
decl_stmt|;
comment|/* Move to the end of this line, and find out what the 	       sectioning command is here. */
while|while
condition|(
name|input_text
index|[
name|input_text_offset
index|]
operator|!=
literal|'\n'
condition|)
name|input_text_offset
operator|++
expr_stmt|;
if|if
condition|(
name|input_text_offset
operator|<
name|size_of_input_text
condition|)
name|input_text_offset
operator|++
expr_stmt|;
name|this_section
operator|=
name|what_section
argument_list|(
name|input_text
operator|+
name|input_text_offset
argument_list|)
expr_stmt|;
comment|/* If we found a sectioning command, then give the top section 	       a level of this section - 1. */
if|if
condition|(
name|this_section
operator|!=
operator|-
literal|1
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|section_alist
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|section_alist
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"Top"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|section_alist
index|[
name|i
index|]
operator|.
name|level
operator|=
name|this_section
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
name|input_text_offset
operator|=
name|orig_offset
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Organized by level commands.  That is, "*" == chapter, "=" == section. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|scoring_characters
init|=
literal|"*=-."
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|sectioning_underscore
parameter_list|(
name|command
parameter_list|)
name|char
modifier|*
name|command
decl_stmt|;
block|{
name|char
name|character
decl_stmt|;
name|int
name|level
decl_stmt|;
name|level
operator|=
name|what_section
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|level
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|level
operator|<
literal|0
condition|)
name|level
operator|=
literal|0
expr_stmt|;
name|character
operator|=
name|scoring_characters
index|[
name|level
index|]
expr_stmt|;
name|insert_and_underscore
argument_list|(
name|character
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The remainder of the text on this line is a chapter heading. */
end_comment

begin_macro
name|cm_chapter
argument_list|()
end_macro

begin_block
block|{
name|sectioning_underscore
argument_list|(
literal|"@chapter"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The remainder of the text on this line is a section heading. */
end_comment

begin_macro
name|cm_section
argument_list|()
end_macro

begin_block
block|{
name|sectioning_underscore
argument_list|(
literal|"@section"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The remainder of the text on this line is a subsection heading. */
end_comment

begin_macro
name|cm_subsection
argument_list|()
end_macro

begin_block
block|{
name|sectioning_underscore
argument_list|(
literal|"@subsection"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The remainder of the text on this line is a subsubsection heading. */
end_comment

begin_macro
name|cm_subsubsection
argument_list|()
end_macro

begin_block
block|{
name|sectioning_underscore
argument_list|(
literal|"@subsubsection"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The remainder of the text on this line is an unnumbered heading. */
end_comment

begin_macro
name|cm_unnumbered
argument_list|()
end_macro

begin_block
block|{
name|cm_chapter
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The remainder of the text on this line is an unnumbered section heading. */
end_comment

begin_macro
name|cm_unnumberedsec
argument_list|()
end_macro

begin_block
block|{
name|cm_section
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The remainder of the text on this line is an unnumbered    subsection heading. */
end_comment

begin_macro
name|cm_unnumberedsubsec
argument_list|()
end_macro

begin_block
block|{
name|cm_subsection
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The remainder of the text on this line is an unnumbered    subsubsection heading. */
end_comment

begin_macro
name|cm_unnumberedsubsubsec
argument_list|()
end_macro

begin_block
block|{
name|cm_subsubsection
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The remainder of the text on this line is an appendix heading. */
end_comment

begin_macro
name|cm_appendix
argument_list|()
end_macro

begin_block
block|{
name|cm_chapter
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The remainder of the text on this line is an appendix section heading. */
end_comment

begin_macro
name|cm_appendixsec
argument_list|()
end_macro

begin_block
block|{
name|cm_section
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The remainder of the text on this line is an appendix subsection heading. */
end_comment

begin_macro
name|cm_appendixsubsec
argument_list|()
end_macro

begin_block
block|{
name|cm_subsection
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The remainder of the text on this line is an appendix    subsubsection heading. */
end_comment

begin_macro
name|cm_appendixsubsubsec
argument_list|()
end_macro

begin_block
block|{
name|cm_subsubsection
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Compatibility functions substitute for chapter, section, etc. */
end_comment

begin_macro
name|cm_majorheading
argument_list|()
end_macro

begin_block
block|{
name|cm_chapheading
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|cm_chapheading
argument_list|()
end_macro

begin_block
block|{
name|cm_chapter
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|cm_heading
argument_list|()
end_macro

begin_block
block|{
name|cm_section
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|cm_subheading
argument_list|()
end_macro

begin_block
block|{
name|cm_subsection
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|cm_subsubheading
argument_list|()
end_macro

begin_block
block|{
name|cm_subsubsection
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*		   Adding nodes, and making tags		    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Start a new tag table. */
end_comment

begin_macro
name|init_tag_table
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|tag_table
operator|!=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|NULL
condition|)
block|{
name|TAG_ENTRY
modifier|*
name|temp
init|=
name|tag_table
decl_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|prev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|up
argument_list|)
expr_stmt|;
name|tag_table
operator|=
name|tag_table
operator|->
name|next_ent
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|write_tag_table
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|write_tag_table_internal
argument_list|(
literal|0
argument_list|)
operator|)
return|;
comment|/* Not indirect. */
block|}
end_block

begin_macro
name|write_tag_table_indirect
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|write_tag_table_internal
argument_list|(
literal|1
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Write out the contents of the existing tag table.    INDIRECT_P says how to format the output. */
end_comment

begin_macro
name|write_tag_table_internal
argument_list|(
argument|indirect_p
argument_list|)
end_macro

begin_decl_stmt
name|int
name|indirect_p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|TAG_ENTRY
modifier|*
name|node
init|=
name|tag_table
decl_stmt|;
name|int
name|old_indent
init|=
name|no_indent
decl_stmt|;
name|no_indent
operator|=
literal|1
expr_stmt|;
name|filling_enabled
operator|=
literal|0
expr_stmt|;
name|must_start_paragraph
operator|=
literal|0
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|indirect_p
condition|)
block|{
name|no_indent
operator|=
literal|1
expr_stmt|;
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|add_word_args
argument_list|(
literal|"\037\nTag Table:\n%s"
argument_list|,
name|indirect_p
condition|?
literal|"(Indirect)\n"
else|:
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
name|node
operator|!=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|NULL
condition|)
block|{
name|add_word_args
argument_list|(
literal|"Node: %s\177%d\n"
argument_list|,
name|node
operator|->
name|node
argument_list|,
name|node
operator|->
name|position
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|next_ent
expr_stmt|;
block|}
name|add_word
argument_list|(
literal|"\037\nEnd Tag Table\n"
argument_list|)
expr_stmt|;
name|flush_output
argument_list|()
expr_stmt|;
name|no_indent
operator|=
name|old_indent
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|get_node_token
parameter_list|()
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|get_until_in_line
argument_list|(
literal|","
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|','
condition|)
name|input_text_offset
operator|++
expr_stmt|;
name|canon_white
argument_list|(
name|string
argument_list|)
expr_stmt|;
comment|/* Allow things like @@nodename. */
name|normalize_node_name
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
operator|(
name|string
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given a node name in STRING, remove double @ signs, replacing them    with just one.  Convert "top" and friends into "Top". */
end_comment

begin_macro
name|normalize_node_name
argument_list|(
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|l
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|string
index|[
name|i
index|]
operator|==
literal|'@'
operator|&&
name|string
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'@'
condition|)
block|{
name|strncpy
argument_list|(
name|string
operator|+
name|i
argument_list|,
name|string
operator|+
name|i
operator|+
literal|1
argument_list|,
name|l
operator|-
name|i
argument_list|)
expr_stmt|;
name|l
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stricmp
argument_list|(
name|string
argument_list|,
literal|"Top"
argument_list|)
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|string
argument_list|,
literal|"Top"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Look up NAME in the tag table, and return the associated    tag_entry.  If the node is not in the table return NULL. */
end_comment

begin_function
name|TAG_ENTRY
modifier|*
name|find_node
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|TAG_ENTRY
modifier|*
name|tag
init|=
name|tag_table
decl_stmt|;
while|while
condition|(
name|tag
operator|!=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tag
operator|->
name|node
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|tag
operator|)
return|;
name|tag
operator|=
name|tag
operator|->
name|next_ent
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Remember NODE and associates. */
end_comment

begin_macro
name|remember_node
argument_list|(
argument|node
argument_list|,
argument|prev
argument_list|,
argument|next
argument_list|,
argument|up
argument_list|,
argument|position
argument_list|,
argument|line_no
argument_list|,
argument|no_warn
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|node
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|up
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|position
decl_stmt|,
name|line_no
decl_stmt|,
name|no_warn
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Check for existence of this tag already. */
if|if
condition|(
name|validating
condition|)
block|{
specifier|register
name|TAG_ENTRY
modifier|*
name|tag
init|=
name|find_node
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|tag
condition|)
block|{
name|line_error
argument_list|(
literal|"Node `%s' multiply defined (%d is first definition)"
argument_list|,
name|node
argument_list|,
name|tag
operator|->
name|line_no
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* First, make this the current node. */
name|current_node
operator|=
name|node
expr_stmt|;
comment|/* Now add it to the list. */
block|{
name|TAG_ENTRY
modifier|*
name|new
init|=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TAG_ENTRY
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|new
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|next
expr_stmt|;
name|new
operator|->
name|up
operator|=
name|up
expr_stmt|;
name|new
operator|->
name|position
operator|=
name|position
expr_stmt|;
name|new
operator|->
name|line_no
operator|=
name|line_no
expr_stmt|;
name|new
operator|->
name|filename
operator|=
name|node_filename
expr_stmt|;
name|new
operator|->
name|touched
operator|=
literal|0
expr_stmt|;
comment|/* not yet referenced. */
name|new
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|no_warn
condition|)
name|new
operator|->
name|flags
operator||=
name|NO_WARN
expr_stmt|;
name|new
operator|->
name|next_ent
operator|=
name|tag_table
expr_stmt|;
name|tag_table
operator|=
name|new
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* The order is: nodename, nextnode, prevnode, upnode.    If all of the NEXT, PREV, and UP fields are empty, they are defaulted.    You must follow a node command which has those fields defaulted    with a sectioning command (e.g. @chapter) giving the "level" of that node.    It is an error not to do so.    The defaults come from the menu in this nodes parent. */
end_comment

begin_macro
name|cm_node
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|node
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|up
decl_stmt|;
name|int
name|new_node_pos
decl_stmt|,
name|defaulting
decl_stmt|,
name|this_section
decl_stmt|,
name|no_warn
init|=
literal|0
decl_stmt|;
specifier|extern
name|int
name|already_outputting_pending_notes
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
literal|"nwnode"
argument_list|)
operator|==
literal|0
condition|)
name|no_warn
operator|=
literal|1
expr_stmt|;
comment|/* Get rid of unmatched brace arguments from previous commands. */
name|discard_braces
argument_list|()
expr_stmt|;
comment|/* There also might be insertions left lying around that haven't been      ended yet.  Do that also. */
name|discard_insertions
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|already_outputting_pending_notes
condition|)
block|{
name|close_paragraph
argument_list|()
expr_stmt|;
name|output_pending_notes
argument_list|()
expr_stmt|;
name|free_pending_notes
argument_list|()
expr_stmt|;
block|}
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|0
expr_stmt|;
name|new_node_pos
operator|=
name|output_position
expr_stmt|;
name|current_footnote_number
operator|=
literal|1
expr_stmt|;
name|node
operator|=
name|get_node_token
argument_list|()
expr_stmt|;
name|next
operator|=
name|get_node_token
argument_list|()
expr_stmt|;
name|prev
operator|=
name|get_node_token
argument_list|()
expr_stmt|;
name|up
operator|=
name|get_node_token
argument_list|()
expr_stmt|;
name|no_indent
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|no_headers
condition|)
name|add_word_args
argument_list|(
literal|"\037\nFile: %s,  Node: %s"
argument_list|,
name|pretty_output_filename
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* Check for defaulting of this node's next, prev, and up fields. */
name|defaulting
operator|=
operator|(
operator|(
name|strlen
argument_list|(
name|next
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strlen
argument_list|(
name|prev
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strlen
argument_list|(
name|up
argument_list|)
operator|==
literal|0
operator|)
operator|)
expr_stmt|;
name|this_section
operator|=
name|what_section
argument_list|(
name|input_text
operator|+
name|input_text_offset
argument_list|)
expr_stmt|;
comment|/* If we are defaulting, then look at the immediately following      sectioning command (error if none) to determine the node's      level.  Find the node that contains the menu mentioning this node      that is one level up (error if not found).  That node is the "Up"      of this node.  Default the "Next" and "Prev" from the menu. */
if|if
condition|(
name|defaulting
condition|)
block|{
name|NODE_REF
modifier|*
name|last_ref
init|=
operator|(
name|NODE_REF
operator|*
operator|)
name|NULL
decl_stmt|;
name|NODE_REF
modifier|*
name|ref
init|=
name|node_references
decl_stmt|;
if|if
condition|(
name|this_section
operator|<
literal|0
condition|)
block|{
name|char
modifier|*
name|polite_section_name
init|=
literal|"top"
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|section_alist
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|section_alist
index|[
name|i
index|]
operator|.
name|level
operator|==
name|current_section
operator|+
literal|1
condition|)
block|{
name|polite_section_name
operator|=
name|section_alist
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
break|break;
block|}
name|line_error
argument_list|(
literal|"Node `%s' requires a sectioning command (e.g. @%s)"
argument_list|,
name|node
argument_list|,
name|polite_section_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|stricmp
argument_list|(
name|node
argument_list|,
literal|"Top"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Default the NEXT pointer to be the first menu item in 		 this node, if there is a menu in this node. */
block|{
name|int
name|orig_offset
decl_stmt|,
name|orig_size
decl_stmt|;
name|char
modifier|*
name|glean_node_from_menu
parameter_list|()
function_decl|;
name|orig_offset
operator|=
name|input_text_offset
expr_stmt|;
name|orig_size
operator|=
name|search_forward
argument_list|(
literal|"\n@node "
argument_list|,
name|orig_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_size
operator|<
literal|0
condition|)
name|orig_size
operator|=
name|size_of_input_text
expr_stmt|;
name|input_text_offset
operator|=
name|search_forward
argument_list|(
literal|"\n@menu"
argument_list|,
name|orig_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_text_offset
operator|>
operator|-
literal|1
condition|)
block|{
name|char
modifier|*
name|nodename_from_menu
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
name|input_text_offset
operator|=
name|search_forward
argument_list|(
literal|"\n* "
argument_list|,
name|input_text_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_text_offset
operator|!=
operator|-
literal|1
condition|)
name|nodename_from_menu
operator|=
name|glean_node_from_menu
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodename_from_menu
condition|)
block|{
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|nodename_from_menu
expr_stmt|;
name|prev
operator|=
name|savestring
argument_list|(
literal|"(DIR)"
argument_list|)
expr_stmt|;
name|up
operator|=
name|savestring
argument_list|(
literal|"(DIR)"
argument_list|)
expr_stmt|;
block|}
block|}
name|input_text_offset
operator|=
name|orig_offset
expr_stmt|;
block|}
block|}
while|while
condition|(
name|ref
condition|)
block|{
if|if
condition|(
name|ref
operator|->
name|section
operator|==
operator|(
name|this_section
operator|-
literal|1
operator|)
operator|&&
name|ref
operator|->
name|type
operator|==
name|menu_reference
operator|&&
name|strcmp
argument_list|(
name|ref
operator|->
name|node
argument_list|,
name|node
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|containing_node
init|=
name|ref
operator|->
name|containing_node
decl_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
name|up
operator|=
name|savestring
argument_list|(
name|containing_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_ref
operator|&&
name|last_ref
operator|->
name|type
operator|==
name|menu_reference
operator|&&
operator|(
name|strcmp
argument_list|(
name|last_ref
operator|->
name|containing_node
argument_list|,
name|containing_node
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|savestring
argument_list|(
name|last_ref
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ref
operator|->
name|section
operator|==
name|this_section
operator|-
literal|1
operator|)
operator|&&
operator|(
name|ref
operator|->
name|next
operator|)
operator|&&
operator|(
name|ref
operator|->
name|next
operator|->
name|type
operator|!=
name|menu_reference
operator|)
condition|)
name|ref
operator|=
name|ref
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ref
operator|->
name|next
operator|&&
name|ref
operator|->
name|type
operator|==
name|menu_reference
operator|&&
operator|(
name|strcmp
argument_list|(
name|ref
operator|->
name|next
operator|->
name|containing_node
argument_list|,
name|containing_node
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|savestring
argument_list|(
name|ref
operator|->
name|next
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ref
operator|->
name|next
operator|&&
name|stricmp
argument_list|(
name|ref
operator|->
name|containing_node
argument_list|,
literal|"Top"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|savestring
argument_list|(
name|ref
operator|->
name|containing_node
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|last_ref
operator|=
name|ref
expr_stmt|;
name|ref
operator|=
name|ref
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|no_headers
condition|)
block|{
if|if
condition|(
operator|*
name|next
condition|)
name|add_word_args
argument_list|(
literal|",  Next: %s"
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|prev
condition|)
name|add_word_args
argument_list|(
literal|",  Prev: %s"
argument_list|,
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|up
condition|)
name|add_word_args
argument_list|(
literal|",  Up: %s"
argument_list|,
name|up
argument_list|)
expr_stmt|;
block|}
name|close_paragraph
argument_list|()
expr_stmt|;
name|no_indent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|node
condition|)
block|{
name|line_error
argument_list|(
literal|"No node name specified for `@%s' command"
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|*
name|next
condition|)
block|{
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|prev
condition|)
block|{
name|free
argument_list|(
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|up
condition|)
block|{
name|free
argument_list|(
name|up
argument_list|)
expr_stmt|;
name|up
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|remember_node
argument_list|(
name|node
argument_list|,
name|prev
argument_list|,
name|next
argument_list|,
name|up
argument_list|,
name|new_node_pos
argument_list|,
name|line_number
argument_list|,
name|no_warn
argument_list|)
expr_stmt|;
block|}
comment|/* Change the section only if there was a sectioning command. */
if|if
condition|(
name|this_section
operator|>=
literal|0
condition|)
name|current_section
operator|=
name|this_section
expr_stmt|;
name|filling_enabled
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Validation of an info file.    Scan through the list of tag entrys touching the Prev, Next, and Up    elements of each.  It is an error not to be able to touch one of them,    except in the case of external node references, such as "(DIR)".     If the Prev is different from the Up,    then the Prev node must have a Next pointing at this node.     Every node except Top must have an Up.    The Up node must contain some sort of reference, other than a Next,    to this node.     If the Next is different from the Next of the Up,    then the Next node must have a Prev pointing at this node. */
end_comment

begin_macro
name|validate_file
argument_list|(
argument|filename
argument_list|,
argument|tag_table
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TAG_ENTRY
modifier|*
name|tag_table
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|old_input_filename
init|=
name|input_filename
decl_stmt|;
name|TAG_ENTRY
modifier|*
name|tags
init|=
name|tag_table
decl_stmt|;
while|while
condition|(
name|tags
operator|!=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|NULL
condition|)
block|{
specifier|register
name|TAG_ENTRY
modifier|*
name|temp_tag
decl_stmt|;
name|input_filename
operator|=
name|tags
operator|->
name|filename
expr_stmt|;
name|line_number
operator|=
name|tags
operator|->
name|line_no
expr_stmt|;
comment|/* If this is a "no warn" node, don't validate it in any way. */
if|if
condition|(
name|tags
operator|->
name|flags
operator|&
name|NO_WARN
condition|)
block|{
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
continue|continue;
block|}
comment|/* If this node has a Next, then make sure that the Next exists. */
if|if
condition|(
name|tags
operator|->
name|next
condition|)
block|{
name|validate
argument_list|(
name|tags
operator|->
name|next
argument_list|,
name|tags
operator|->
name|line_no
argument_list|,
literal|"Next"
argument_list|)
expr_stmt|;
comment|/* If the Next node exists, and there is no Up, then make 	     sure that the Prev of the Next points back. */
if|if
condition|(
name|temp_tag
operator|=
name|find_node
argument_list|(
name|tags
operator|->
name|next
argument_list|)
condition|)
block|{
name|char
modifier|*
name|prev
decl_stmt|;
if|if
condition|(
name|temp_tag
operator|->
name|flags
operator|&
name|NO_WARN
condition|)
block|{
comment|/* Do nothing if we aren't supposed to issue warnings 		     about this node. */
block|}
else|else
block|{
name|prev
operator|=
name|temp_tag
operator|->
name|prev
expr_stmt|;
if|if
condition|(
operator|!
name|prev
operator|||
operator|(
name|strcmp
argument_list|(
name|prev
argument_list|,
name|tags
operator|->
name|node
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|line_error
argument_list|(
literal|"Node `%s''s Next field not pointed back to"
argument_list|,
name|tags
operator|->
name|node
argument_list|)
expr_stmt|;
name|line_number
operator|=
name|temp_tag
operator|->
name|line_no
expr_stmt|;
name|input_filename
operator|=
name|temp_tag
operator|->
name|filename
expr_stmt|;
name|line_error
argument_list|(
literal|"This node (`%s') is the one with the bad `Prev'"
argument_list|,
name|temp_tag
operator|->
name|node
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|tags
operator|->
name|filename
expr_stmt|;
name|line_number
operator|=
name|tags
operator|->
name|line_no
expr_stmt|;
name|temp_tag
operator|->
name|flags
operator||=
name|PREV_ERROR
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Validate the Prev field if there is one, and we haven't already 	 complained about it in some way.  You don't have to have a Prev 	 field at this stage. */
if|if
condition|(
operator|!
operator|(
name|tags
operator|->
name|flags
operator|&
name|PREV_ERROR
operator|)
operator|&&
name|tags
operator|->
name|prev
condition|)
block|{
name|int
name|valid
init|=
name|validate
argument_list|(
name|tags
operator|->
name|prev
argument_list|,
name|tags
operator|->
name|line_no
argument_list|,
literal|"Prev"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
name|tags
operator|->
name|flags
operator||=
name|PREV_ERROR
expr_stmt|;
else|else
block|{
comment|/* If the Prev field is not the same as the Up field, 		 then the node pointed to by the Prev field must have 		 a Next field which points to this node. */
if|if
condition|(
name|tags
operator|->
name|up
operator|&&
operator|(
name|strcmp
argument_list|(
name|tags
operator|->
name|prev
argument_list|,
name|tags
operator|->
name|up
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|temp_tag
operator|=
name|find_node
argument_list|(
name|tags
operator|->
name|prev
argument_list|)
expr_stmt|;
comment|/* If we aren't supposed to issue warnings about the 		     target node, do nothing. */
if|if
condition|(
operator|!
name|temp_tag
operator|||
operator|(
name|temp_tag
operator|->
name|flags
operator|&
name|NO_WARN
operator|)
condition|)
block|{
comment|/* Do nothing. */
block|}
else|else
block|{
if|if
condition|(
operator|!
name|temp_tag
operator|->
name|next
operator|||
operator|(
name|strcmp
argument_list|(
name|temp_tag
operator|->
name|next
argument_list|,
name|tags
operator|->
name|node
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|line_error
argument_list|(
literal|"Node `%s''s Prev field not pointed back to"
argument_list|,
name|tags
operator|->
name|node
argument_list|)
expr_stmt|;
name|line_number
operator|=
name|temp_tag
operator|->
name|line_no
expr_stmt|;
name|input_filename
operator|=
name|temp_tag
operator|->
name|filename
expr_stmt|;
name|line_error
argument_list|(
literal|"This node (`%s') is the one with the bad `Next'"
argument_list|,
name|temp_tag
operator|->
name|node
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|tags
operator|->
name|filename
expr_stmt|;
name|line_number
operator|=
name|tags
operator|->
name|line_no
expr_stmt|;
name|temp_tag
operator|->
name|flags
operator||=
name|NEXT_ERROR
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|tags
operator|->
name|up
operator|&&
operator|(
name|stricmp
argument_list|(
name|tags
operator|->
name|node
argument_list|,
literal|"Top"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|line_error
argument_list|(
literal|"Node `%s' is missing an \"Up\" field"
argument_list|,
name|tags
operator|->
name|node
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tags
operator|->
name|up
condition|)
block|{
name|int
name|valid
init|=
name|validate
argument_list|(
name|tags
operator|->
name|up
argument_list|,
name|tags
operator|->
name|line_no
argument_list|,
literal|"Up"
argument_list|)
decl_stmt|;
comment|/* If node X has Up: Y, then warn if Y fails to have a menu item 	     or note pointing at X, if Y isn't of the form "(Y)". */
if|if
condition|(
name|valid
operator|&&
operator|*
name|tags
operator|->
name|up
operator|!=
literal|'('
condition|)
block|{
name|NODE_REF
modifier|*
name|nref
decl_stmt|,
modifier|*
name|tref
decl_stmt|,
modifier|*
name|list
decl_stmt|;
name|NODE_REF
modifier|*
name|find_node_reference
parameter_list|()
function_decl|;
name|tref
operator|=
operator|(
name|NODE_REF
operator|*
operator|)
name|NULL
expr_stmt|;
name|list
operator|=
name|node_references
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|nref
operator|=
name|find_node_reference
argument_list|(
name|tags
operator|->
name|node
argument_list|,
name|list
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|nref
operator|->
name|containing_node
argument_list|,
name|tags
operator|->
name|up
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nref
operator|->
name|type
operator|!=
name|menu_reference
condition|)
block|{
name|tref
operator|=
name|nref
expr_stmt|;
name|list
operator|=
name|nref
operator|->
name|next
expr_stmt|;
block|}
else|else
break|break;
block|}
name|list
operator|=
name|nref
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nref
condition|)
block|{
name|temp_tag
operator|=
name|find_node
argument_list|(
name|tags
operator|->
name|up
argument_list|)
expr_stmt|;
name|line_number
operator|=
name|temp_tag
operator|->
name|line_no
expr_stmt|;
name|filename
operator|=
name|temp_tag
operator|->
name|filename
expr_stmt|;
if|if
condition|(
operator|!
name|tref
condition|)
name|line_error
argument_list|(
literal|"`%s' has an Up field of `%s', but `%s' has no menu item for `%s'"
argument_list|,
name|tags
operator|->
name|node
argument_list|,
name|tags
operator|->
name|up
argument_list|,
name|tags
operator|->
name|up
argument_list|,
name|tags
operator|->
name|node
argument_list|)
expr_stmt|;
name|line_number
operator|=
name|tags
operator|->
name|line_no
expr_stmt|;
name|filename
operator|=
name|tags
operator|->
name|filename
expr_stmt|;
block|}
block|}
block|}
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
block|}
name|validate_other_references
argument_list|(
name|node_references
argument_list|)
expr_stmt|;
comment|/* We have told the user about the references which didn't exist.      Now tell him about the nodes which aren't referenced. */
name|tags
operator|=
name|tag_table
expr_stmt|;
while|while
condition|(
name|tags
operator|!=
operator|(
name|TAG_ENTRY
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* If this node is a "no warn" node, do nothing. */
if|if
condition|(
name|tags
operator|->
name|flags
operator|&
name|NO_WARN
condition|)
block|{
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
continue|continue;
block|}
comment|/* Special hack.  If the node in question appears to have          been referenced more than REFERENCE_WARNING_LIMIT times,          give a warning. */
if|if
condition|(
name|tags
operator|->
name|touched
operator|>
name|reference_warning_limit
condition|)
block|{
name|input_filename
operator|=
name|tags
operator|->
name|filename
expr_stmt|;
name|line_number
operator|=
name|tags
operator|->
name|line_no
expr_stmt|;
name|warning
argument_list|(
literal|"Node `%s' has been referenced %d times"
argument_list|,
name|tags
operator|->
name|node
argument_list|,
name|tags
operator|->
name|touched
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tags
operator|->
name|touched
operator|==
literal|0
condition|)
block|{
name|input_filename
operator|=
name|tags
operator|->
name|filename
expr_stmt|;
name|line_number
operator|=
name|tags
operator|->
name|line_no
expr_stmt|;
comment|/* Notice that the node "Top" is special, and doesn't have to 	     be referenced. */
if|if
condition|(
name|stricmp
argument_list|(
name|tags
operator|->
name|node
argument_list|,
literal|"Top"
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"Unreferenced node `%s'"
argument_list|,
name|tags
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
block|}
name|input_filename
operator|=
name|old_input_filename
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return 1 if tag correctly validated, or 0 if not. */
end_comment

begin_macro
name|validate
argument_list|(
argument|tag
argument_list|,
argument|line
argument_list|,
argument|label
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|label
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|TAG_ENTRY
modifier|*
name|result
decl_stmt|;
comment|/* If there isn't a tag to verify, or if the tag is in another file,      then it must be okay. */
if|if
condition|(
operator|!
name|tag
operator|||
operator|!
operator|*
name|tag
operator|||
operator|*
name|tag
operator|==
literal|'('
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Otherwise, the tag must exist. */
name|result
operator|=
name|find_node
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|line_number
operator|=
name|line
expr_stmt|;
name|line_error
argument_list|(
literal|"Validation error.  `%s' field points to node `%s', which doesn't exist"
argument_list|,
name|label
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|result
operator|->
name|touched
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Split large output files into a series of smaller files.  Each file    is pointed to in the tag table, which then gets written out as the    original file.  The new files have the same name as the original file    with a "-num" attached.  SIZE is the largest number of bytes to allow    in any single split file. */
end_comment

begin_macro
name|split_file
argument_list|(
argument|filename
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|root_filename
decl_stmt|,
modifier|*
name|root_pathname
decl_stmt|;
name|char
modifier|*
name|the_file
decl_stmt|,
modifier|*
name|filename_part
argument_list|()
decl_stmt|;
name|struct
name|stat
name|fileinfo
decl_stmt|;
name|char
modifier|*
name|the_header
decl_stmt|;
name|int
name|header_size
decl_stmt|;
comment|/* Can only do this to files with tag tables. */
if|if
condition|(
operator|!
name|tag_table
condition|)
return|return;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
name|DEFAULT_SPLIT_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|fileinfo
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|fileinfo
operator|.
name|st_size
operator|<
name|SPLIT_SIZE_THRESHOLD
operator|)
condition|)
return|return;
name|the_file
operator|=
name|find_and_load
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|the_file
condition|)
return|return;
name|root_filename
operator|=
name|filename_part
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|root_pathname
operator|=
name|pathname_part
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|root_pathname
condition|)
name|root_pathname
operator|=
name|savestring
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Start splitting the file.  Walk along the tag table      outputting sections of the file.  When we have written      all of the nodes in the tag table, make the top-level      pointer file, which contains indirect pointers and      tags for the nodes. */
block|{
name|int
name|which_file
init|=
literal|1
decl_stmt|;
name|TAG_ENTRY
modifier|*
name|tags
init|=
name|tag_table
decl_stmt|;
name|char
modifier|*
name|indirect_info
init|=
operator|(
name|char
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* Remember the `header' of this file.  The first tag in the file is        the bottom of the header; the top of the file is the start. */
name|the_header
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
operator|(
name|header_size
operator|=
name|tags
operator|->
name|position
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|the_header
argument_list|,
name|the_file
argument_list|,
name|header_size
argument_list|)
expr_stmt|;
while|while
condition|(
name|tags
condition|)
block|{
name|int
name|file_top
decl_stmt|,
name|file_bot
decl_stmt|,
name|limit
decl_stmt|;
comment|/* Have to include the Control-_. */
name|file_top
operator|=
name|file_bot
operator|=
name|tags
operator|->
name|position
expr_stmt|;
name|limit
operator|=
name|file_top
operator|+
name|size
expr_stmt|;
comment|/* If the rest of this file is only one node, then 	   that is the entire subfile. */
if|if
condition|(
operator|!
name|tags
operator|->
name|next_ent
condition|)
block|{
name|int
name|i
init|=
name|tags
operator|->
name|position
operator|+
literal|1
decl_stmt|;
name|char
name|last_char
init|=
name|the_file
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|fileinfo
operator|.
name|st_size
condition|)
block|{
if|if
condition|(
operator|(
name|the_file
index|[
name|i
index|]
operator|==
literal|'\037'
operator|)
operator|&&
operator|(
operator|(
name|last_char
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|last_char
operator|==
literal|'\014'
operator|)
operator|)
condition|)
break|break;
else|else
name|last_char
operator|=
name|the_file
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|file_bot
operator|=
name|i
expr_stmt|;
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
goto|goto
name|write_region
goto|;
block|}
comment|/* Otherwise, find the largest number of nodes that can fit in 	   this subfile. */
for|for
control|(
init|;
name|tags
condition|;
name|tags
operator|=
name|tags
operator|->
name|next_ent
control|)
block|{
if|if
condition|(
operator|!
name|tags
operator|->
name|next_ent
condition|)
block|{
comment|/* This entry is the last node.  Search forward for the end 	           of this node, and that is the end of this file. */
name|int
name|i
init|=
name|tags
operator|->
name|position
operator|+
literal|1
decl_stmt|;
name|char
name|last_char
init|=
name|the_file
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|fileinfo
operator|.
name|st_size
condition|)
block|{
if|if
condition|(
operator|(
name|the_file
index|[
name|i
index|]
operator|==
literal|'\037'
operator|)
operator|&&
operator|(
operator|(
name|last_char
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|last_char
operator|==
literal|'\014'
operator|)
operator|)
condition|)
break|break;
else|else
name|last_char
operator|=
name|the_file
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|file_bot
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|file_bot
operator|<
name|limit
condition|)
block|{
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
goto|goto
name|write_region
goto|;
block|}
else|else
block|{
comment|/* Here we want to write out everything before the last 		       node, and then write the last node out in a file 		       by itself. */
name|file_bot
operator|=
name|tags
operator|->
name|position
expr_stmt|;
goto|goto
name|write_region
goto|;
block|}
block|}
if|if
condition|(
name|tags
operator|->
name|next_ent
operator|->
name|position
operator|>
name|limit
condition|)
block|{
if|if
condition|(
name|tags
operator|->
name|position
operator|==
name|file_top
condition|)
name|tags
operator|=
name|tags
operator|->
name|next_ent
expr_stmt|;
name|file_bot
operator|=
name|tags
operator|->
name|position
expr_stmt|;
name|write_region
label|:
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|split_filename
decl_stmt|;
name|split_filename
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
operator|+
name|strlen
argument_list|(
name|root_pathname
argument_list|)
operator|+
name|strlen
argument_list|(
name|root_filename
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|split_filename
argument_list|,
literal|"%s%s-%d"
argument_list|,
name|root_pathname
argument_list|,
name|root_filename
argument_list|,
name|which_file
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|split_filename
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|<
literal|0
operator|)
operator|||
operator|(
name|write
argument_list|(
name|fd
argument_list|,
name|the_header
argument_list|,
name|header_size
argument_list|)
operator|!=
name|header_size
operator|)
operator|||
operator|(
name|write
argument_list|(
name|fd
argument_list|,
name|the_file
operator|+
name|file_top
argument_list|,
name|file_bot
operator|-
name|file_top
argument_list|)
operator|!=
operator|(
name|file_bot
operator|-
name|file_top
operator|)
operator|)
operator|||
operator|(
operator|(
name|close
argument_list|(
name|fd
argument_list|)
operator|)
operator|<
literal|0
operator|)
condition|)
block|{
name|perror
argument_list|(
name|split_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|indirect_info
condition|)
block|{
name|indirect_info
operator|=
name|the_file
operator|+
name|file_top
expr_stmt|;
name|sprintf
argument_list|(
name|indirect_info
argument_list|,
literal|"\037\nIndirect:\n"
argument_list|)
expr_stmt|;
name|indirect_info
operator|+=
name|strlen
argument_list|(
name|indirect_info
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|indirect_info
argument_list|,
literal|"%s-%d: %d\n"
argument_list|,
name|root_filename
argument_list|,
name|which_file
argument_list|,
name|file_top
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|split_filename
argument_list|)
expr_stmt|;
name|indirect_info
operator|+=
name|strlen
argument_list|(
name|indirect_info
argument_list|)
expr_stmt|;
name|which_file
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* We have sucessfully created the subfiles.  Now write out the        original again.  We must use `output_stream', or        write_tag_table_indirect () won't know where to place the output. */
name|output_stream
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|output_stream
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL
argument_list|)
expr_stmt|;
block|}
block|{
name|int
name|distance
init|=
name|indirect_info
operator|-
name|the_file
decl_stmt|;
name|fwrite
argument_list|(
name|the_file
argument_list|,
literal|1
argument_list|,
name|distance
argument_list|,
name|output_stream
argument_list|)
expr_stmt|;
comment|/* Inhibit newlines. */
name|paragraph_is_open
operator|=
literal|0
expr_stmt|;
name|write_tag_table_indirect
argument_list|()
expr_stmt|;
name|fclose
argument_list|(
name|output_stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|the_header
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|the_file
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Some menu hacking.  This is used to remember menu references while    reading the input file.  After the output file has been written, if    validation is on, then we use the contents of NODE_REFERENCES as a    list of nodes to validate. */
end_comment

begin_function
name|char
modifier|*
name|reftype_type_string
parameter_list|(
name|type
parameter_list|)
name|enum
name|reftype
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|menu_reference
case|:
return|return
operator|(
literal|"Menu"
operator|)
return|;
case|case
name|followed_reference
case|:
return|return
operator|(
literal|"Followed-Reference"
operator|)
return|;
default|default:
return|return
operator|(
literal|"Internal-bad-reference-type"
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Remember this node name for later validation use. */
end_comment

begin_macro
name|remember_node_reference
argument_list|(
argument|node
argument_list|,
argument|line
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|reftype
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|NODE_REF
modifier|*
name|temp
init|=
operator|(
name|NODE_REF
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|NODE_REF
argument_list|)
argument_list|)
decl_stmt|;
name|temp
operator|->
name|next
operator|=
name|node_references
expr_stmt|;
name|temp
operator|->
name|node
operator|=
name|savestring
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|temp
operator|->
name|line_no
operator|=
name|line
expr_stmt|;
name|temp
operator|->
name|section
operator|=
name|current_section
expr_stmt|;
name|temp
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|temp
operator|->
name|containing_node
operator|=
name|savestring
argument_list|(
name|current_node
argument_list|)
expr_stmt|;
name|temp
operator|->
name|filename
operator|=
name|node_filename
expr_stmt|;
name|node_references
operator|=
name|temp
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|validate_other_references
argument_list|(
name|ref_list
argument_list|)
specifier|register
name|NODE_REF
operator|*
name|ref_list
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|old_input_filename
init|=
name|input_filename
decl_stmt|;
while|while
condition|(
name|ref_list
operator|!=
operator|(
name|NODE_REF
operator|*
operator|)
name|NULL
condition|)
block|{
name|input_filename
operator|=
name|ref_list
operator|->
name|filename
expr_stmt|;
name|validate
argument_list|(
name|ref_list
operator|->
name|node
argument_list|,
name|ref_list
operator|->
name|line_no
argument_list|,
name|reftype_type_string
argument_list|(
name|ref_list
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|ref_list
operator|=
name|ref_list
operator|->
name|next
expr_stmt|;
block|}
name|input_filename
operator|=
name|old_input_filename
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Find NODE in REF_LIST. */
end_comment

begin_function
name|NODE_REF
modifier|*
name|find_node_reference
parameter_list|(
name|node
parameter_list|,
name|ref_list
parameter_list|)
name|char
modifier|*
name|node
decl_stmt|;
specifier|register
name|NODE_REF
modifier|*
name|ref_list
decl_stmt|;
block|{
while|while
condition|(
name|ref_list
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|node
argument_list|,
name|ref_list
operator|->
name|node
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|ref_list
operator|=
name|ref_list
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|ref_list
operator|)
return|;
block|}
end_function

begin_macro
name|free_node_references
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|NODE_REF
modifier|*
name|list
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|list
operator|=
name|node_references
expr_stmt|;
while|while
condition|(
name|list
condition|)
block|{
name|temp
operator|=
name|list
expr_stmt|;
name|free
argument_list|(
name|list
operator|->
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
operator|->
name|containing_node
argument_list|)
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|node_references
operator|=
operator|(
name|NODE_REF
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/* This function gets called at the start of every line while inside of      a menu.  It checks to see if the line starts with "* ", and if so,      remembers the node reference that this menu refers to.      input_text_offset is at the \n just before the line start. */
end_comment

begin_define
define|#
directive|define
name|menu_starter
value|"* "
end_define

begin_function
name|char
modifier|*
name|glean_node_from_menu
parameter_list|(
name|remember_reference
parameter_list|)
name|int
name|remember_reference
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|orig_offset
init|=
name|input_text_offset
decl_stmt|;
name|char
modifier|*
name|nodename
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|input_text
index|[
name|input_text_offset
operator|+
literal|1
index|]
argument_list|,
name|menu_starter
argument_list|,
name|strlen
argument_list|(
name|menu_starter
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
else|else
name|input_text_offset
operator|+=
name|strlen
argument_list|(
name|menu_starter
argument_list|)
operator|+
literal|1
expr_stmt|;
name|get_until_in_line
argument_list|(
literal|":"
argument_list|,
operator|&
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|':'
condition|)
name|input_text_offset
operator|++
expr_stmt|;
name|canon_white
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|':'
condition|)
goto|goto
name|save_node
goto|;
name|free
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|nodename
argument_list|)
expr_stmt|;
comment|/* Special hack: If the nodename follows the menu item name,      then we have to read the rest of the line in order to find      out what the nodename is.  But we still have to read the      line later, in order to process any formatting commands that      might be present.  So un-count the carriage return that has just      been counted. */
name|line_number
operator|--
expr_stmt|;
name|isolate_nodename
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
name|save_node
label|:
name|input_text_offset
operator|=
name|orig_offset
expr_stmt|;
name|normalize_node_name
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&&
name|nodename
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
name|nodename
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|remember_reference
condition|)
block|{
name|remember_node_reference
argument_list|(
name|nodename
argument_list|,
name|line_number
argument_list|,
name|menu_reference
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
else|else
return|return
operator|(
name|nodename
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isolate_nodename
parameter_list|(
name|nodename
parameter_list|)
name|char
modifier|*
name|nodename
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|int
name|paren_seen
decl_stmt|,
name|paren
decl_stmt|;
if|if
condition|(
operator|!
name|nodename
condition|)
return|return;
name|canon_white
argument_list|(
name|nodename
argument_list|)
expr_stmt|;
name|paren_seen
operator|=
name|paren
operator|=
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|nodename
operator|==
literal|'.'
operator|||
operator|!
operator|*
name|nodename
condition|)
block|{
operator|*
name|nodename
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|nodename
operator|==
literal|'('
condition|)
block|{
name|paren
operator|++
expr_stmt|;
name|paren_seen
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|c
operator|=
name|nodename
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|paren
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
name|paren
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
name|paren
operator|--
expr_stmt|;
continue|continue;
block|}
comment|/* If the character following the close paren is a space, then this 	 node has no more characters associated with it. */
if|if
condition|(
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|','
operator|||
operator|(
operator|(
name|paren_seen
operator|&&
name|nodename
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|')'
operator|)
operator|&&
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'.'
operator|)
operator|)
operator|||
operator|(
name|c
operator|==
literal|'.'
operator|&&
operator|(
operator|(
operator|!
name|nodename
index|[
name|i
operator|+
literal|1
index|]
operator|||
operator|(
name|cr_or_whitespace
argument_list|(
name|nodename
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|)
operator|||
operator|(
name|nodename
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|')'
operator|)
operator|)
operator|)
operator|)
condition|)
break|break;
block|}
name|nodename
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_macro
name|cm_menu
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|menu
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Cross Reference Hacking			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_function
name|char
modifier|*
name|get_xref_token
parameter_list|()
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|get_until_in_braces
argument_list|(
literal|","
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|','
condition|)
name|input_text_offset
operator|++
expr_stmt|;
name|fix_whitespace
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
operator|(
name|string
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|px_ref_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls initial output string. */
end_comment

begin_comment
comment|/* Make a cross reference. */
end_comment

begin_macro
name|cm_xref
argument_list|(
argument|arg
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
name|char
modifier|*
name|arg1
decl_stmt|,
modifier|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|,
modifier|*
name|arg4
decl_stmt|,
modifier|*
name|arg5
decl_stmt|;
name|arg1
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|arg2
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|arg3
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|arg4
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|arg5
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|add_word_args
argument_list|(
literal|"%s"
argument_list|,
name|px_ref_flag
condition|?
literal|"*note "
else|:
literal|"*Note "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg5
operator|||
operator|*
name|arg4
condition|)
block|{
name|char
modifier|*
name|node_name
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|arg2
condition|)
block|{
if|if
condition|(
operator|*
name|arg3
condition|)
name|node_name
operator|=
name|arg3
expr_stmt|;
else|else
name|node_name
operator|=
name|arg1
expr_stmt|;
block|}
else|else
name|node_name
operator|=
name|arg2
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s: (%s)%s"
argument_list|,
name|node_name
argument_list|,
name|arg4
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|remember_node_reference
argument_list|(
name|arg1
argument_list|,
name|line_number
argument_list|,
name|followed_reference
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg3
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|arg2
condition|)
name|execute_string
argument_list|(
literal|"%s: %s"
argument_list|,
name|arg3
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s: %s"
argument_list|,
name|arg2
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|arg2
condition|)
name|execute_string
argument_list|(
literal|"%s: %s"
argument_list|,
name|arg2
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s::"
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check to make sure that the next non-whitespace character is either          a period or a comma. input_text_offset is pointing at the "}" which          ended the xref or pxref command. */
name|int
name|temp
init|=
name|input_text_offset
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|output_paragraph
index|[
name|output_paragraph_offset
operator|-
literal|2
index|]
operator|==
literal|':'
operator|&&
name|output_paragraph
index|[
name|output_paragraph_offset
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
return|return;
while|while
condition|(
name|temp
operator|<
name|size_of_input_text
condition|)
block|{
if|if
condition|(
name|cr_or_whitespace
argument_list|(
name|input_text
index|[
name|temp
index|]
argument_list|)
condition|)
name|temp
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|input_text
index|[
name|temp
index|]
operator|==
literal|'.'
operator|||
name|input_text
index|[
name|temp
index|]
operator|==
literal|','
operator|||
name|input_text
index|[
name|temp
index|]
operator|==
literal|'\t'
condition|)
return|return;
else|else
block|{
name|line_error
argument_list|(
literal|"Cross-reference must be terminated with a period or a comma"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
block|}
end_block

begin_macro
name|cm_pxref
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
name|px_ref_flag
operator|++
expr_stmt|;
name|cm_xref
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|px_ref_flag
operator|--
expr_stmt|;
block|}
else|else
name|add_char
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_inforef
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|START
condition|)
block|{
name|char
modifier|*
name|node
decl_stmt|,
modifier|*
name|pname
decl_stmt|,
modifier|*
name|file
decl_stmt|;
name|node
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|pname
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|file
operator|=
name|get_xref_token
argument_list|()
expr_stmt|;
name|execute_string
argument_list|(
literal|"*note %s: (%s)%s"
argument_list|,
name|pname
argument_list|,
name|file
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			Insertion Command Stubs			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_macro
name|cm_quotation
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|quotation
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_example
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|example
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_smallexample
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|smallexample
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_lisp
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|lisp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_smalllisp
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|smalllisp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* @cartouche/@end cartouche draws box with rounded corners in    TeX output.  Right now, just a NOP insertion. */
end_comment

begin_macro
name|cm_cartouche
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|cartouche
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_format
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|format
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_display
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|display
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_itemize
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|itemize
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_enumerate
argument_list|()
end_macro

begin_block
block|{
name|do_enumeration
argument_list|(
name|enumerate
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Start an enumeration insertion of type TYPE.  If the user supplied    no argument on the line, then use DEFAULT_STRING as the initial string. */
end_comment

begin_macro
name|do_enumeration
argument_list|(
argument|type
argument_list|,
argument|default_string
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|default_string
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|get_until_in_line
argument_list|(
literal|"."
argument_list|,
operator|&
name|enumeration_arg
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
name|enumeration_arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|enumeration_arg
condition|)
block|{
name|free
argument_list|(
name|enumeration_arg
argument_list|)
expr_stmt|;
name|enumeration_arg
operator|=
name|savestring
argument_list|(
name|default_string
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|enumeration_arg
argument_list|)
operator|&&
operator|!
name|isletter
argument_list|(
operator|*
name|enumeration_arg
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"%s requires a letter or a digit"
argument_list|,
name|insertion_type_pname
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|enumerate
case|:
name|default_string
operator|=
literal|"1"
expr_stmt|;
break|break;
block|}
name|enumeration_arg
operator|=
name|savestring
argument_list|(
name|default_string
argument_list|)
expr_stmt|;
block|}
name|begin_insertion
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_table
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_ftable
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|ftable
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_vtable
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|vtable
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_group
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|group
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_ifinfo
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|ifinfo
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Begin an insertion where the lines are not filled or indented. */
end_comment

begin_macro
name|cm_flushleft
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|flushleft
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Begin an insertion where the lines are not filled, and each line is    forced to the right-hand side of the page. */
end_comment

begin_macro
name|cm_flushright
argument_list|()
end_macro

begin_block
block|{
name|begin_insertion
argument_list|(
name|flushright
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			  Conditional Handling			    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* A structure which contains `defined' variables. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_defines
block|{
name|struct
name|_defines
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|}
name|DEFINE
typedef|;
end_typedef

begin_comment
comment|/* The linked list of `set' defines. */
end_comment

begin_decl_stmt
name|DEFINE
modifier|*
name|defines
init|=
operator|(
name|DEFINE
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add NAME to the list of `set' defines. */
end_comment

begin_macro
name|set
argument_list|(
argument|name
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|DEFINE
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|defines
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|temp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|temp
operator|->
name|value
argument_list|)
expr_stmt|;
name|temp
operator|->
name|value
operator|=
name|savestring
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
name|temp
operator|=
operator|(
name|DEFINE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DEFINE
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|defines
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|temp
operator|->
name|value
operator|=
name|savestring
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|defines
operator|=
name|temp
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Remove NAME from the list of `set' defines. */
end_comment

begin_macro
name|clear
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|DEFINE
modifier|*
name|temp
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|last
operator|=
operator|(
name|DEFINE
operator|*
operator|)
name|NULL
expr_stmt|;
name|temp
operator|=
name|defines
expr_stmt|;
while|while
condition|(
name|temp
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|temp
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|last
condition|)
name|last
operator|->
name|next
operator|=
name|temp
operator|->
name|next
expr_stmt|;
else|else
name|defines
operator|=
name|temp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
block|}
name|last
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Return the value of NAME.  The return value is NULL if NAME is unset. */
end_comment

begin_function
name|char
modifier|*
name|set_p
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|DEFINE
modifier|*
name|temp
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|defines
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|temp
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|temp
operator|->
name|value
operator|)
return|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Conditionally parse based on the current command name. */
end_comment

begin_macro
name|command_name_condition
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|discarder
decl_stmt|;
name|discarder
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|8
operator|+
name|strlen
argument_list|(
name|command
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|discarder
argument_list|,
literal|"\n@end %s"
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|discard_until
argument_list|(
name|discarder
argument_list|)
expr_stmt|;
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|discarder
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Create a variable whose name appears as the first word on this line. */
end_comment

begin_macro
name|cm_set
argument_list|()
end_macro

begin_block
block|{
name|handle_variable
argument_list|(
name|SET
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Remove a variable whose name appears as the first word on this line. */
end_comment

begin_macro
name|cm_clear
argument_list|()
end_macro

begin_block
block|{
name|handle_variable
argument_list|(
name|CLEAR
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_ifset
argument_list|()
end_macro

begin_block
block|{
name|handle_variable
argument_list|(
name|IFSET
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_ifclear
argument_list|()
end_macro

begin_block
block|{
name|handle_variable
argument_list|(
name|IFCLEAR
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cm_value
argument_list|(
argument|arg
argument_list|,
argument|start_pos
argument_list|,
argument|end_pos
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|,
name|start_pos
decl_stmt|,
name|end_pos
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|output_paragraph
index|[
name|start_pos
index|]
expr_stmt|;
name|output_paragraph
index|[
name|end_pos
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|value
operator|=
name|set_p
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|output_column
operator|-=
name|end_pos
operator|-
name|start_pos
expr_stmt|;
name|output_paragraph_offset
operator|=
name|start_pos
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|add_word_args
argument_list|(
literal|"{No Value For \"%s\"}"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Set, clear, or conditionalize based on ACTION. */
end_comment

begin_macro
name|handle_variable
argument_list|(
argument|action
argument_list|)
end_macro

begin_decl_stmt
name|int
name|action
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
name|backup_input_pointer
argument_list|()
expr_stmt|;
name|canon_white
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|handle_variable_internal
argument_list|(
name|action
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|handle_variable_internal
argument_list|(
argument|action
argument_list|,
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|int
name|action
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|delimiter
decl_stmt|,
name|additional_text_present
init|=
literal|0
decl_stmt|;
comment|/* Only the first word of NAME is a valid tag. */
name|temp
operator|=
name|name
expr_stmt|;
name|delimiter
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|temp
operator|&&
operator|(
name|delimiter
operator|||
operator|!
name|whitespace
argument_list|(
operator|*
name|temp
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SET_WITH_EQUAL
argument_list|)
if|if
condition|(
operator|*
name|temp
operator|==
literal|'"'
operator|||
operator|*
name|temp
operator|==
literal|'\''
condition|)
block|{
if|if
condition|(
operator|*
name|temp
operator|==
name|delimiter
condition|)
name|delimiter
operator|=
literal|0
expr_stmt|;
else|else
name|delimiter
operator|=
operator|*
name|temp
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SET_WITH_EQUAL */
name|temp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|temp
condition|)
name|additional_text_present
operator|++
expr_stmt|;
operator|*
name|temp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|name
condition|)
name|line_error
argument_list|(
literal|"@%s requires a name"
argument_list|,
name|command
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|SET
case|:
block|{
name|char
modifier|*
name|value
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SET_WITH_EQUAL
argument_list|)
comment|/* Allow a value to be saved along with a variable.  The value is 	       the text following an `=' sign in NAME, if any is present. */
for|for
control|(
name|value
operator|=
name|name
init|;
operator|*
name|value
operator|&&
operator|*
name|value
operator|!=
literal|'='
condition|;
name|value
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|value
condition|)
operator|*
name|value
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|value
operator|==
literal|'"'
operator|||
operator|*
name|value
operator|==
literal|'\''
condition|)
block|{
name|value
operator|++
expr_stmt|;
name|value
index|[
name|strlen
argument_list|(
name|value
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|#
directive|else
comment|/* !SET_WITH_EQUAL */
comment|/* The VALUE of NAME is the remainder of the line sans 	       whitespace. */
if|if
condition|(
name|additional_text_present
condition|)
block|{
name|value
operator|=
name|temp
operator|+
literal|1
expr_stmt|;
name|canon_white
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
name|value
operator|=
literal|""
expr_stmt|;
endif|#
directive|endif
comment|/* !SET_WITH_VALUE */
name|set
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLEAR
case|:
name|clear
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|IFSET
case|:
case|case
name|IFCLEAR
case|:
comment|/* If IFSET and NAME is not set, or if IFCLEAR and NAME is set, 	     read lines from the the file until we reach a matching 	     "@end CONDITION".  This means that we only take note of 	     "@ifset/clear" and "@end" commands. */
block|{
name|char
name|condition
index|[
literal|8
index|]
decl_stmt|;
name|int
name|condition_len
decl_stmt|;
if|if
condition|(
name|action
operator|==
name|IFSET
condition|)
name|strcpy
argument_list|(
name|condition
argument_list|,
literal|"ifset"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|condition
argument_list|,
literal|"ifclear"
argument_list|)
expr_stmt|;
name|condition_len
operator|=
name|strlen
argument_list|(
name|condition
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|action
operator|==
name|IFSET
operator|&&
operator|!
name|set_p
argument_list|(
name|name
argument_list|)
operator|)
operator|||
operator|(
name|action
operator|==
name|IFCLEAR
operator|&&
name|set_p
argument_list|(
name|name
argument_list|)
operator|)
condition|)
block|{
name|int
name|level
init|=
literal|0
decl_stmt|,
name|done
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|char
modifier|*
name|freeable_line
decl_stmt|,
modifier|*
name|line
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|freeable_line
argument_list|)
expr_stmt|;
for|for
control|(
name|line
operator|=
name|freeable_line
init|;
name|whitespace
argument_list|(
operator|*
name|line
argument_list|)
condition|;
name|line
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
name|COMMAND_PREFIX
operator|&&
operator|(
name|strncmp
argument_list|(
name|line
operator|+
literal|1
argument_list|,
name|condition
argument_list|,
name|condition_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|level
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|line
argument_list|,
literal|"@end"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|cname
init|=
name|line
operator|+
literal|4
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
while|while
condition|(
operator|*
name|cname
operator|&&
name|whitespace
argument_list|(
operator|*
name|cname
argument_list|)
condition|)
name|cname
operator|++
expr_stmt|;
name|temp
operator|=
name|cname
expr_stmt|;
while|while
condition|(
operator|*
name|temp
operator|&&
operator|!
name|whitespace
argument_list|(
operator|*
name|temp
argument_list|)
condition|)
name|temp
operator|++
expr_stmt|;
operator|*
name|temp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cname
argument_list|,
name|condition
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|level
condition|)
block|{
name|done
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|level
operator|--
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|freeable_line
argument_list|)
expr_stmt|;
block|}
comment|/* We found the end of a false @ifset/ifclear.  If we are 		 in a menu, back up over the newline that ends the ifset, 		 since that newline may also begin the next menu entry. */
break|break;
block|}
else|else
block|{
if|if
condition|(
name|action
operator|==
name|IFSET
condition|)
name|begin_insertion
argument_list|(
name|ifset
argument_list|)
expr_stmt|;
else|else
name|begin_insertion
argument_list|(
name|ifclear
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
block|}
end_block

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/*			@itemx, @item				    */
end_comment

begin_comment
comment|/*								    */
end_comment

begin_comment
comment|/* **************************************************************** */
end_comment

begin_comment
comment|/* Non-zero means a string is in execution, as opposed to a file. */
end_comment

begin_decl_stmt
name|int
name|executing_string
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Execute the string produced by formatting the ARGs with FORMAT.  This    is like submitting a new file with @include. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VARARGS_H
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_VSPRINTF
argument_list|)
end_if

begin_macro
name|execute_string
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
specifier|static
name|char
name|temp_string
index|[
literal|4000
index|]
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|temp_string
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !(HAVE_VARARGS_H&& HAVE_VSPRINTF) */
name|execute_string
argument_list|(
argument|format
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|,
argument|arg4
argument_list|,
argument|arg5
argument_list|)
name|char
modifier|*
name|format
decl_stmt|;
block|{
specifier|static
name|char
name|temp_string
index|[
literal|4000
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|temp_string
argument_list|,
name|format
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !(HAVE_VARARGS_H&& HAVE_VSPRINTF) */
name|strcat
argument_list|(
name|temp_string
argument_list|,
literal|"@bye\n"
argument_list|)
expr_stmt|;
name|pushfile
argument_list|()
expr_stmt|;
name|input_text_offset
operator|=
literal|0
expr_stmt|;
name|input_text
operator|=
name|temp_string
expr_stmt|;
name|input_filename
operator|=
name|savestring
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
name|size_of_input_text
operator|=
name|strlen
argument_list|(
name|temp_string
argument_list|)
expr_stmt|;
name|executing_string
operator|++
expr_stmt|;
name|reader_loop
argument_list|()
expr_stmt|;
name|popfile
argument_list|()
expr_stmt|;
name|executing_string
operator|--
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
name|command
argument_list|)
expr_stmt|;
name|command
operator|=
name|savestring
argument_list|(
literal|"not bye"
argument_list|)
expr_stmt|;
block|}
name|int
name|itemx_flag
init|=
literal|0
decl_stmt|;
name|cm_itemx
argument_list|()
block|{
name|itemx_flag
operator|++
expr_stmt|;
name|cm_item
argument_list|()
expr_stmt|;
name|itemx_flag
operator|--
expr_stmt|;
block|}
name|cm_item
argument_list|()
block|{
name|char
modifier|*
name|rest_of_line
decl_stmt|,
modifier|*
name|item_func
decl_stmt|;
comment|/* Can only hack "@item" while inside of an insertion. */
if|if
condition|(
name|insertion_level
condition|)
block|{
name|INSERTION_ELT
modifier|*
name|stack
init|=
name|insertion_stack
decl_stmt|;
name|int
name|original_input_text_offset
decl_stmt|;
name|skip_whitespace
argument_list|()
expr_stmt|;
name|original_input_text_offset
operator|=
name|input_text_offset
expr_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|rest_of_line
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
name|rest_of_line
argument_list|)
expr_stmt|;
name|item_func
operator|=
name|current_item_function
argument_list|()
expr_stmt|;
comment|/* Okay, do the right thing depending on which insertion function 	 is active. */
name|switch_top
label|:
switch|switch
condition|(
name|stack
operator|->
name|insertion
condition|)
block|{
case|case
name|ifinfo
case|:
case|case
name|ifset
case|:
case|case
name|ifclear
case|:
case|case
name|cartouche
case|:
name|stack
operator|=
name|stack
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|stack
condition|)
goto|goto
name|no_insertion
goto|;
else|else
goto|goto
name|switch_top
goto|;
break|break;
case|case
name|menu
case|:
case|case
name|quotation
case|:
case|case
name|example
case|:
case|case
name|smallexample
case|:
case|case
name|lisp
case|:
case|case
name|format
case|:
case|case
name|display
case|:
case|case
name|group
case|:
name|line_error
argument_list|(
literal|"The `@%s' command is meaningless within a `@%s' block"
argument_list|,
name|command
argument_list|,
name|insertion_type_pname
argument_list|(
name|current_insertion_type
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|itemize
case|:
case|case
name|enumerate
case|:
if|if
condition|(
name|itemx_flag
condition|)
block|{
name|line_error
argument_list|(
literal|"@itemx is not meaningful inside of a `%s' block"
argument_list|,
name|insertion_type_pname
argument_list|(
name|current_insertion_type
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|start_paragraph
argument_list|()
expr_stmt|;
name|kill_self_indent
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|current_insertion_type
argument_list|()
operator|==
name|itemize
condition|)
block|{
name|indent
argument_list|(
name|output_column
operator|=
name|current_indent
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* I need some way to determine whether this command 		     takes braces or not.  I believe the user can type 		     either "@bullet" or "@bullet{}".  Of course, they 		     can also type "o" or "#" or whatever else they want. */
if|if
condition|(
name|item_func
operator|&&
operator|*
name|item_func
condition|)
block|{
if|if
condition|(
operator|*
name|item_func
operator|==
literal|'@'
condition|)
if|if
condition|(
name|item_func
index|[
name|strlen
argument_list|(
name|item_func
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'}'
condition|)
name|execute_string
argument_list|(
literal|"%s{}"
argument_list|,
name|item_func
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|item_func
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|item_func
argument_list|)
expr_stmt|;
block|}
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|output_column
operator|++
expr_stmt|;
block|}
else|else
name|enumerate_item
argument_list|()
expr_stmt|;
comment|/* Special hack.  This makes close paragraph ignore you until 		 the start_paragraph () function has been called. */
name|must_start_paragraph
operator|=
literal|1
expr_stmt|;
comment|/* Ultra special hack.  It appears that some people incorrectly 		 place text directly after the @item, instead of on a new line 		 by itself.  This happens to work in TeX, so I make it work 		 here. */
if|if
condition|(
operator|*
name|rest_of_line
condition|)
block|{
name|line_number
operator|--
expr_stmt|;
name|input_text_offset
operator|=
name|original_input_text_offset
expr_stmt|;
block|}
block|}
break|break;
case|case
name|table
case|:
case|case
name|ftable
case|:
case|case
name|vtable
case|:
block|{
comment|/* Get rid of extra characters. */
name|kill_self_indent
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* close_paragraph () almost does what we want.  The problem 	       is when paragraph_is_open, and last_char_was_newline, and 	       the last newline has been turned into a space, because 	       filling_enabled. I handle it here. */
if|if
condition|(
name|last_char_was_newline
operator|&&
name|filling_enabled
operator|&&
name|paragraph_is_open
condition|)
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INDENT_PARAGRAPHS_IN_TABLE
argument_list|)
comment|/* Indent on a new line, but back up one indentation level. */
block|{
name|int
name|t
decl_stmt|;
name|t
operator|=
name|inhibit_paragraph_indentation
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
comment|/* At this point, inserting any non-whitespace character will 		 force the existing indentation to be output. */
name|add_char
argument_list|(
literal|'i'
argument_list|)
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
name|t
expr_stmt|;
block|}
else|#
directive|else
comment|/* !INDENT_PARAGRAPHS_IN_TABLE */
name|add_char
argument_list|(
literal|'i'
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !INDENT_PARAGRAPHS_IN_TABLE */
name|output_paragraph_offset
operator|--
expr_stmt|;
name|kill_self_indent
argument_list|(
name|default_indentation_increment
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Add item's argument to the line. */
name|filling_enabled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|item_func
operator|&&
operator|*
name|item_func
condition|)
name|execute_string
argument_list|(
literal|"%s{%s}"
argument_list|,
name|item_func
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_insertion_type
argument_list|()
operator|==
name|ftable
condition|)
name|execute_string
argument_list|(
literal|"@findex %s\n"
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_insertion_type
argument_list|()
operator|==
name|vtable
condition|)
name|execute_string
argument_list|(
literal|"@vindex %s\n"
argument_list|,
name|rest_of_line
argument_list|)
expr_stmt|;
comment|/* Start a new line, and let start_paragraph () 	       do the indenting of it for you. */
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|indented_fill
operator|=
name|filling_enabled
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|rest_of_line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|no_insertion
label|:
name|line_error
argument_list|(
literal|"@%s found outside of an insertion block"
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* **************************************************************** */
comment|/*								    */
comment|/*			Defun and Friends       		    */
comment|/*								    */
comment|/* **************************************************************** */
define|#
directive|define
name|DEFUN_SELF_DELIMITING
parameter_list|(
name|c
parameter_list|)
define|\
value|(((c) == '(')								\    || ((c) == ')')							\    || ((c) == '[')							\    || ((c) == ']'))
struct|struct
name|token_accumulator
block|{
name|unsigned
name|int
name|length
decl_stmt|;
name|unsigned
name|int
name|index
decl_stmt|;
name|char
modifier|*
modifier|*
name|tokens
decl_stmt|;
block|}
struct|;
name|void
name|initialize_token_accumulator
parameter_list|(
name|accumulator
parameter_list|)
name|struct
name|token_accumulator
modifier|*
name|accumulator
decl_stmt|;
block|{
operator|(
name|accumulator
operator|->
name|length
operator|)
operator|=
literal|0
expr_stmt|;
operator|(
name|accumulator
operator|->
name|index
operator|)
operator|=
literal|0
expr_stmt|;
operator|(
name|accumulator
operator|->
name|tokens
operator|)
operator|=
name|NULL
expr_stmt|;
block|}
name|void
name|accumulate_token
parameter_list|(
name|accumulator
parameter_list|,
name|token
parameter_list|)
name|struct
name|token_accumulator
modifier|*
name|accumulator
decl_stmt|;
name|char
modifier|*
name|token
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|accumulator
operator|->
name|index
operator|)
operator|>=
operator|(
name|accumulator
operator|->
name|length
operator|)
condition|)
block|{
operator|(
name|accumulator
operator|->
name|length
operator|)
operator|+=
literal|10
expr_stmt|;
operator|(
name|accumulator
operator|->
name|tokens
operator|)
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|accumulator
operator|->
name|tokens
argument_list|,
operator|(
name|accumulator
operator|->
name|length
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|accumulator
operator|->
name|tokens
index|[
name|accumulator
operator|->
name|index
index|]
operator|=
name|token
expr_stmt|;
name|accumulator
operator|->
name|index
operator|+=
literal|1
expr_stmt|;
block|}
name|char
modifier|*
name|copy_substring
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|,
modifier|*
name|scan
decl_stmt|,
modifier|*
name|scan_result
decl_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|end
operator|-
name|start
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|scan_result
operator|=
name|result
expr_stmt|;
name|scan
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|end
condition|)
operator|*
name|scan_result
operator|++
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
operator|*
name|scan_result
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* Given `string' pointing at an open brace, skip forward and return a    pointer to just past the matching close brace. */
name|int
name|scan_group_in_string
parameter_list|(
name|string_pointer
parameter_list|)
name|char
modifier|*
modifier|*
name|string_pointer
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|scan_string
decl_stmt|;
specifier|register
name|unsigned
name|int
name|level
init|=
literal|1
decl_stmt|;
name|scan_string
operator|=
operator|(
operator|*
name|string_pointer
operator|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|level
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|string_pointer
operator|)
operator|=
name|scan_string
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|c
operator|=
operator|(
operator|*
name|scan_string
operator|++
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/* Tweak line_number to compensate for fact that 	     we gobbled the whole line before coming here. */
name|line_number
operator|-=
literal|1
expr_stmt|;
name|line_error
argument_list|(
literal|"Missing `}' in @def arg"
argument_list|)
expr_stmt|;
name|line_number
operator|+=
literal|1
expr_stmt|;
operator|(
operator|*
name|string_pointer
operator|)
operator|=
operator|(
name|scan_string
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
name|level
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
name|level
operator|-=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Return a list of tokens from the contents of `string'.    Commands and brace-delimited groups count as single tokens.    Contiguous whitespace characters are converted to a token    consisting of a single space. */
name|char
modifier|*
modifier|*
name|args_from_string
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|struct
name|token_accumulator
name|accumulator
decl_stmt|;
specifier|register
name|char
modifier|*
name|scan_string
init|=
name|string
decl_stmt|;
name|char
modifier|*
name|token_start
decl_stmt|,
modifier|*
name|token_end
decl_stmt|;
name|initialize_token_accumulator
argument_list|(
operator|&
name|accumulator
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|scan_string
operator|)
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Replace arbitrary whitespace by a single space. */
if|if
condition|(
name|whitespace
argument_list|(
operator|*
name|scan_string
argument_list|)
condition|)
block|{
name|scan_string
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
name|whitespace
argument_list|(
operator|*
name|scan_string
argument_list|)
condition|)
name|scan_string
operator|+=
literal|1
expr_stmt|;
name|accumulate_token
argument_list|(
operator|(
operator|&
name|accumulator
operator|)
argument_list|,
operator|(
name|savestring
argument_list|(
literal|" "
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Commands count as single tokens. */
if|if
condition|(
operator|(
operator|*
name|scan_string
operator|)
operator|==
name|COMMAND_PREFIX
condition|)
block|{
name|token_start
operator|=
name|scan_string
expr_stmt|;
name|scan_string
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|self_delimiting
argument_list|(
operator|*
name|scan_string
argument_list|)
condition|)
name|scan_string
operator|+=
literal|1
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
operator|*
name|scan_string
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'{'
operator|)
operator|||
operator|(
name|whitespace
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
name|scan_string
operator|-=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|scan_string
operator|==
literal|'{'
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|scan_string
decl_stmt|;
operator|(
name|void
operator|)
name|scan_group_in_string
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|scan_string
operator|=
name|s
expr_stmt|;
block|}
block|}
name|token_end
operator|=
name|scan_string
expr_stmt|;
block|}
comment|/* Parentheses and brackets are self-delimiting. */
elseif|else
if|if
condition|(
name|DEFUN_SELF_DELIMITING
argument_list|(
operator|*
name|scan_string
argument_list|)
condition|)
block|{
name|token_start
operator|=
name|scan_string
expr_stmt|;
name|scan_string
operator|+=
literal|1
expr_stmt|;
name|token_end
operator|=
name|scan_string
expr_stmt|;
block|}
comment|/* Open brace introduces a group that is a single token. */
elseif|else
if|if
condition|(
operator|*
name|scan_string
operator|==
literal|'{'
condition|)
block|{
name|char
modifier|*
name|s
init|=
name|scan_string
decl_stmt|;
name|int
name|balanced
init|=
name|scan_group_in_string
argument_list|(
operator|&
name|s
argument_list|)
decl_stmt|;
name|token_start
operator|=
name|scan_string
operator|+
literal|1
expr_stmt|;
name|scan_string
operator|=
name|s
expr_stmt|;
name|token_end
operator|=
name|balanced
condition|?
operator|(
name|scan_string
operator|-
literal|1
operator|)
else|:
name|scan_string
expr_stmt|;
block|}
comment|/* Otherwise a token is delimited by whitespace, parentheses, 	 brackets, or braces.  A token is also ended by a command. */
else|else
block|{
name|token_start
operator|=
name|scan_string
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|scan_string
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|||
operator|(
name|whitespace
argument_list|(
name|c
argument_list|)
operator|||
name|DEFUN_SELF_DELIMITING
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'{'
operator|||
name|c
operator|==
literal|'}'
operator|)
condition|)
block|{
name|scan_string
operator|--
expr_stmt|;
break|break;
block|}
comment|/* If we encounter a command imbedded within a token, 		 then end the token. */
if|if
condition|(
name|c
operator|==
name|COMMAND_PREFIX
condition|)
block|{
name|scan_string
operator|--
expr_stmt|;
break|break;
block|}
block|}
name|token_end
operator|=
name|scan_string
expr_stmt|;
block|}
name|accumulate_token
argument_list|(
operator|&
name|accumulator
argument_list|,
name|copy_substring
argument_list|(
name|token_start
argument_list|,
name|token_end
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|accumulate_token
argument_list|(
operator|&
name|accumulator
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|accumulator
operator|.
name|tokens
operator|)
return|;
block|}
name|void
name|process_defun_args
parameter_list|(
name|defun_args
parameter_list|,
name|auto_var_p
parameter_list|)
name|char
modifier|*
modifier|*
name|defun_args
decl_stmt|;
name|int
name|auto_var_p
decl_stmt|;
block|{
name|int
name|pending_space
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|defun_arg
init|=
operator|*
name|defun_args
operator|++
decl_stmt|;
if|if
condition|(
name|defun_arg
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|defun_arg
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
block|{
name|pending_space
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pending_space
condition|)
block|{
name|add_char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|pending_space
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|DEFUN_SELF_DELIMITING
argument_list|(
name|defun_arg
index|[
literal|0
index|]
argument_list|)
condition|)
name|add_char
argument_list|(
name|defun_arg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|defun_arg
index|[
literal|0
index|]
operator|==
literal|'&'
condition|)
name|add_word
argument_list|(
name|defun_arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|defun_arg
index|[
literal|0
index|]
operator|==
name|COMMAND_PREFIX
condition|)
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|defun_arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|auto_var_p
condition|)
name|execute_string
argument_list|(
literal|"@var{%s}"
argument_list|,
name|defun_arg
argument_list|)
expr_stmt|;
else|else
name|add_word
argument_list|(
name|defun_arg
argument_list|)
expr_stmt|;
block|}
block|}
name|char
modifier|*
name|next_nonwhite_defun_arg
parameter_list|(
name|arg_pointer
parameter_list|)
name|char
modifier|*
modifier|*
modifier|*
name|arg_pointer
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|scan
init|=
operator|(
operator|*
name|arg_pointer
operator|)
decl_stmt|;
name|char
modifier|*
name|arg
init|=
operator|(
operator|*
name|scan
operator|++
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|arg
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|*
name|arg
operator|==
literal|' '
operator|)
condition|)
name|arg
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
name|scan
operator|-=
literal|1
expr_stmt|;
operator|*
name|arg_pointer
operator|=
name|scan
expr_stmt|;
return|return
operator|(
operator|(
name|arg
operator|==
literal|0
operator|)
condition|?
literal|""
else|:
name|arg
operator|)
return|;
block|}
comment|/* Make the defun type insertion.    TYPE says which insertion this is.    X_P says not to start a new insertion if non-zero. */
name|void
name|defun_internal
parameter_list|(
name|type
parameter_list|,
name|x_p
parameter_list|)
name|enum
name|insertion_type
name|type
decl_stmt|;
name|int
name|x_p
decl_stmt|;
block|{
name|enum
name|insertion_type
name|base_type
decl_stmt|;
name|char
modifier|*
modifier|*
name|defun_args
decl_stmt|,
modifier|*
modifier|*
name|scan_args
decl_stmt|;
name|char
modifier|*
name|category
decl_stmt|,
modifier|*
name|defined_name
decl_stmt|,
modifier|*
name|type_name
decl_stmt|,
modifier|*
name|type_name2
decl_stmt|;
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|defun_args
operator|=
operator|(
name|args_from_string
argument_list|(
name|line
argument_list|)
operator|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|scan_args
operator|=
name|defun_args
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|defun
case|:
name|category
operator|=
literal|"Function"
expr_stmt|;
name|base_type
operator|=
name|deffn
expr_stmt|;
break|break;
case|case
name|defmac
case|:
name|category
operator|=
literal|"Macro"
expr_stmt|;
name|base_type
operator|=
name|deffn
expr_stmt|;
break|break;
case|case
name|defspec
case|:
name|category
operator|=
literal|"Special Form"
expr_stmt|;
name|base_type
operator|=
name|deffn
expr_stmt|;
break|break;
case|case
name|defvar
case|:
name|category
operator|=
literal|"Variable"
expr_stmt|;
name|base_type
operator|=
name|defvr
expr_stmt|;
break|break;
case|case
name|defopt
case|:
name|category
operator|=
literal|"User Option"
expr_stmt|;
name|base_type
operator|=
name|defvr
expr_stmt|;
break|break;
case|case
name|deftypefun
case|:
name|category
operator|=
literal|"Function"
expr_stmt|;
name|base_type
operator|=
name|deftypefn
expr_stmt|;
break|break;
case|case
name|deftypevar
case|:
name|category
operator|=
literal|"Variable"
expr_stmt|;
name|base_type
operator|=
name|deftypevr
expr_stmt|;
break|break;
case|case
name|defivar
case|:
name|category
operator|=
literal|"Instance Variable"
expr_stmt|;
name|base_type
operator|=
name|defcv
expr_stmt|;
break|break;
case|case
name|defmethod
case|:
name|category
operator|=
literal|"Method"
expr_stmt|;
name|base_type
operator|=
name|defop
expr_stmt|;
break|break;
case|case
name|deftypemethod
case|:
name|category
operator|=
literal|"Method"
expr_stmt|;
name|base_type
operator|=
name|deftypemethod
expr_stmt|;
break|break;
default|default:
name|category
operator|=
name|next_nonwhite_defun_arg
argument_list|(
operator|&
name|scan_args
argument_list|)
expr_stmt|;
name|base_type
operator|=
name|type
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|base_type
operator|==
name|deftypefn
operator|)
operator|||
operator|(
name|base_type
operator|==
name|deftypevr
operator|)
operator|||
operator|(
name|base_type
operator|==
name|defcv
operator|)
operator|||
operator|(
name|base_type
operator|==
name|defop
operator|)
operator|||
operator|(
name|base_type
operator|==
name|deftypemethod
operator|)
condition|)
name|type_name
operator|=
name|next_nonwhite_defun_arg
argument_list|(
operator|&
name|scan_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_type
operator|==
name|deftypemethod
condition|)
name|type_name2
operator|=
name|next_nonwhite_defun_arg
argument_list|(
operator|&
name|scan_args
argument_list|)
expr_stmt|;
name|defined_name
operator|=
name|next_nonwhite_defun_arg
argument_list|(
operator|&
name|scan_args
argument_list|)
expr_stmt|;
comment|/* This hack exists solely for the purposes of formatting the texinfo      manual.  I couldn't think of a better way.  The token might be      a simple @@ followed immediately by more text.  If this is the case,      then the next defun arg is part of this one, and we should concatenate      them. */
if|if
condition|(
operator|*
name|scan_args
operator|&&
operator|*
operator|*
name|scan_args
operator|&&
operator|!
name|whitespace
argument_list|(
operator|*
operator|*
name|scan_args
argument_list|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|defined_name
argument_list|,
literal|"@@"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|char
modifier|*
name|tem
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|3
operator|+
name|strlen
argument_list|(
name|scan_args
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|tem
argument_list|,
literal|"@@%s"
argument_list|,
name|scan_args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scan_args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|scan_args
index|[
literal|0
index|]
operator|=
name|tem
expr_stmt|;
name|scan_args
operator|++
expr_stmt|;
name|defined_name
operator|=
name|tem
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|x_p
condition|)
name|begin_insertion
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Write the definition header line.      This should start at the normal indentation.  */
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
name|start_paragraph
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|deffn
case|:
case|case
name|defvr
case|:
case|case
name|deftp
case|:
name|execute_string
argument_list|(
literal|" -- %s: %s"
argument_list|,
name|category
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftypefn
case|:
case|case
name|deftypevr
case|:
name|execute_string
argument_list|(
literal|" -- %s: %s %s"
argument_list|,
name|category
argument_list|,
name|type_name
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|defcv
case|:
name|execute_string
argument_list|(
literal|" -- %s of %s: %s"
argument_list|,
name|category
argument_list|,
name|type_name
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|defop
case|:
name|execute_string
argument_list|(
literal|" -- %s on %s: %s"
argument_list|,
name|category
argument_list|,
name|type_name
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftypemethod
case|:
name|execute_string
argument_list|(
literal|" -- %s on %s: %s %s"
argument_list|,
name|category
argument_list|,
name|type_name
argument_list|,
name|type_name2
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
block|}
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
comment|/* Now process the function arguments, if any.      If these carry onto the next line, they should be indented by two      increments to distinguish them from the body of the definition,      which is indented by one increment.  */
name|current_indent
operator|+=
name|default_indentation_increment
expr_stmt|;
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|deffn
case|:
case|case
name|defop
case|:
name|process_defun_args
argument_list|(
name|scan_args
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftp
case|:
case|case
name|deftypefn
case|:
case|case
name|deftypemethod
case|:
name|process_defun_args
argument_list|(
name|scan_args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
name|close_single_paragraph
argument_list|()
expr_stmt|;
comment|/* Make an entry in the appropriate index. */
switch|switch
condition|(
name|base_type
condition|)
block|{
case|case
name|deffn
case|:
case|case
name|deftypefn
case|:
name|execute_string
argument_list|(
literal|"@findex %s\n"
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|defvr
case|:
case|case
name|deftypevr
case|:
case|case
name|defcv
case|:
name|execute_string
argument_list|(
literal|"@vindex %s\n"
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|defop
case|:
case|case
name|deftypemethod
case|:
name|execute_string
argument_list|(
literal|"@findex %s on %s\n"
argument_list|,
name|defined_name
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|deftp
case|:
name|execute_string
argument_list|(
literal|"@tindex %s\n"
argument_list|,
name|defined_name
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Deallocate the token list. */
name|scan_args
operator|=
name|defun_args
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|arg
init|=
operator|(
operator|*
name|scan_args
operator|++
operator|)
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
break|break;
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|defun_args
argument_list|)
expr_stmt|;
block|}
comment|/* Add an entry for a function, macro, special form, variable, or option.    If the name of the calling command ends in `x', then this is an extra    entry included in the body of an insertion of the same type. */
name|cm_defun
argument_list|()
block|{
name|int
name|x_p
decl_stmt|;
name|enum
name|insertion_type
name|type
decl_stmt|;
name|char
modifier|*
name|temp
init|=
name|savestring
argument_list|(
name|command
argument_list|)
decl_stmt|;
name|x_p
operator|=
operator|(
name|command
index|[
name|strlen
argument_list|(
name|command
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'x'
operator|)
expr_stmt|;
if|if
condition|(
name|x_p
condition|)
name|temp
index|[
name|strlen
argument_list|(
name|temp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|type
operator|=
name|find_type_from_name
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* If we are adding to an already existing insertion, then make sure      that we are already in an insertion of type TYPE. */
if|if
condition|(
name|x_p
operator|&&
operator|(
operator|!
name|insertion_level
operator|||
name|insertion_stack
operator|->
name|insertion
operator|!=
name|type
operator|)
condition|)
block|{
name|line_error
argument_list|(
literal|"Must be in a `%s' insertion in order to use `%s'x"
argument_list|,
name|command
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|defun_internal
argument_list|(
name|type
argument_list|,
name|x_p
argument_list|)
expr_stmt|;
block|}
comment|/* End existing insertion block. */
name|cm_end
argument_list|()
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|enum
name|insertion_type
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|insertion_level
condition|)
block|{
name|line_error
argument_list|(
literal|"Unmatched `@%s'"
argument_list|,
name|command
argument_list|)
expr_stmt|;
return|return;
block|}
name|get_rest_of_line
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|temp
argument_list|)
operator|==
literal|0
condition|)
name|line_error
argument_list|(
literal|"`@%s' needs something after it"
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|type
operator|=
name|find_type_from_name
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|bad_type
condition|)
block|{
name|line_error
argument_list|(
literal|"Bad argument to `%s', `%s', using `%s'"
argument_list|,
name|command
argument_list|,
name|temp
argument_list|,
name|insertion_type_pname
argument_list|(
name|current_insertion_type
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|end_insertion
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
comment|/* **************************************************************** */
comment|/*								    */
comment|/*			Other Random Commands		   	    */
comment|/*								    */
comment|/* **************************************************************** */
comment|/* This says to inhibit the indentation of the next paragraph, but    not of following paragraphs.  */
name|cm_noindent
argument_list|()
block|{
if|if
condition|(
operator|!
name|inhibit_paragraph_indentation
condition|)
name|inhibit_paragraph_indentation
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* I don't know exactly what to do with this.  Should I allow    someone to switch filenames in the middle of output?  Since the    file could be partially written, this doesn't seem to make sense.    Another option: ignore it, since they don't *really* want to    switch files.  Finally, complain, or at least warn. */
name|cm_setfilename
argument_list|()
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|filename
argument_list|)
expr_stmt|;
comment|/* warning ("`@%s %s' encountered and ignored", command, filename); */
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
name|cm_ignore_line
argument_list|()
block|{
name|discard_until
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* @br can be immediately followed by `{}', so we have to read those here.    It should simply close the paragraph. */
name|cm_br
argument_list|()
block|{
if|if
condition|(
name|looking_at
argument_list|(
literal|"{}"
argument_list|)
condition|)
name|input_text_offset
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|'\n'
condition|)
block|{
name|input_text_offset
operator|++
expr_stmt|;
name|line_number
operator|++
expr_stmt|;
block|}
name|close_paragraph
argument_list|()
expr_stmt|;
block|}
comment|/* Insert the number of blank lines passed as argument. */
name|cm_sp
argument_list|()
block|{
name|int
name|lines
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|line
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|lines
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|line_error
argument_list|(
literal|"%csp requires a positive numeric argument"
argument_list|,
name|COMMAND_PREFIX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lines
operator|<
literal|0
condition|)
name|lines
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lines
operator|--
condition|)
name|add_char
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
comment|/* Start a new line with just this text on it.    Then center the line of text.    This always ends the current paragraph. */
name|cm_center
argument_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|start
decl_stmt|,
name|length
decl_stmt|;
name|int
name|fudge_factor
init|=
literal|1
decl_stmt|;
name|unsigned
name|char
modifier|*
name|line
decl_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|indented_fill
operator|=
literal|0
expr_stmt|;
name|cm_noindent
argument_list|()
expr_stmt|;
name|start
operator|=
name|output_paragraph_offset
expr_stmt|;
name|inhibit_output_flushing
argument_list|()
expr_stmt|;
name|get_rest_of_line
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|line
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|uninhibit_output_flushing
argument_list|()
expr_stmt|;
name|i
operator|=
name|output_paragraph_offset
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|>
operator|(
name|start
operator|-
literal|1
operator|)
operator|&&
name|output_paragraph
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
name|i
operator|--
expr_stmt|;
name|output_paragraph_offset
operator|=
operator|++
name|i
expr_stmt|;
name|length
operator|=
name|output_paragraph_offset
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|length
operator|<
operator|(
name|fill_column
operator|-
name|fudge_factor
operator|)
condition|)
block|{
name|line
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|length
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|line
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|output_paragraph
operator|+
name|start
operator|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|fill_column
operator|-
name|fudge_factor
operator|-
name|length
operator|)
operator|/
literal|2
expr_stmt|;
name|output_paragraph_offset
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
name|insert
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
name|insert
argument_list|(
name|line
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|insert
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Show what an expression returns. */
name|cm_result
argument_list|(
argument|arg
argument_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
literal|"=>"
argument_list|)
expr_stmt|;
block|}
comment|/* What an expression expands to. */
name|cm_expansion
argument_list|(
argument|arg
argument_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
literal|"==>"
argument_list|)
expr_stmt|;
block|}
comment|/* Indicates two expressions are equivalent. */
name|cm_equiv
argument_list|(
argument|arg
argument_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
literal|"=="
argument_list|)
expr_stmt|;
block|}
comment|/* What an expression may print. */
name|cm_print
argument_list|(
argument|arg
argument_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
literal|"-|"
argument_list|)
expr_stmt|;
block|}
comment|/* An error signaled. */
name|cm_error
argument_list|(
argument|arg
argument_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
literal|"error-->"
argument_list|)
expr_stmt|;
block|}
comment|/* The location of point in an example of a buffer. */
name|cm_point
argument_list|(
argument|arg
argument_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|arg
operator|==
name|END
condition|)
name|add_word
argument_list|(
literal|"-!-"
argument_list|)
expr_stmt|;
block|}
comment|/* Start a new line with just this text on it.    The text is outdented one level if possible. */
name|cm_exdent
argument_list|()
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|i
init|=
name|current_indent
decl_stmt|;
if|if
condition|(
name|current_indent
condition|)
name|current_indent
operator|-=
name|default_indentation_increment
expr_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|current_indent
operator|=
name|i
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|close_single_paragraph
argument_list|()
expr_stmt|;
block|}
name|cm_include
argument_list|()
block|{
name|cm_infoinclude
argument_list|()
expr_stmt|;
block|}
comment|/* Remember this file, and move onto the next. */
name|cm_infoinclude
argument_list|()
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|filename
argument_list|)
expr_stmt|;
name|pushfile
argument_list|()
expr_stmt|;
comment|/* In verbose mode we print info about including another file. */
if|if
condition|(
name|verbose_mode
condition|)
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|FSTACK
modifier|*
name|stack
init|=
name|filestack
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|stack
operator|=
name|filestack
init|;
name|stack
condition|;
name|stack
operator|=
name|stack
operator|->
name|next
operator|,
name|i
operator|++
control|)
empty_stmt|;
name|i
operator|*=
literal|2
expr_stmt|;
name|printf
argument_list|(
literal|"%*s"
argument_list|,
name|i
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c%s %s\n"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|find_and_load
argument_list|(
name|filename
argument_list|)
condition|)
block|{
specifier|extern
specifier|const
name|char
modifier|*
specifier|const
name|sys_errlist
index|[]
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|,
name|sys_nerr
decl_stmt|;
name|popfile
argument_list|()
expr_stmt|;
comment|/* Cannot "@include foo", in line 5 of "/wh/bar". */
name|line_error
argument_list|(
literal|"`%c%s %s': %s"
argument_list|,
name|COMMAND_PREFIX
argument_list|,
name|command
argument_list|,
name|filename
argument_list|,
operator|(
operator|(
name|errno
operator|<
name|sys_nerr
operator|)
condition|?
name|sys_errlist
index|[
name|errno
index|]
else|:
literal|"Unknown file system error"
operator|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
comment|/* The other side of a malformed expression. */
name|misplaced_brace
argument_list|()
block|{
name|line_error
argument_list|(
literal|"Misplaced `}'"
argument_list|)
expr_stmt|;
block|}
comment|/* Don't let the filling algorithm insert extra whitespace here. */
name|cm_force_abbreviated_whitespace
argument_list|()
block|{ }
comment|/* Do not let this character signify the end of a sentence, though    if it was seen without the command prefix it normally would.  We    do this by turning on the 8th bit of the character. */
name|cm_ignore_sentence_ender
argument_list|()
block|{
name|add_char
argument_list|(
name|META
argument_list|(
operator|(
operator|*
name|command
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Signals end of processing.  Easy to make this happen. */
name|cm_bye
argument_list|()
block|{
name|input_text_offset
operator|=
name|size_of_input_text
expr_stmt|;
block|}
name|cm_asis
argument_list|()
block|{ }
name|cm_math
argument_list|()
block|{ }
comment|/* **************************************************************** */
comment|/*								    */
comment|/*			Indexing Stuff				    */
comment|/*								    */
comment|/* **************************************************************** */
comment|/* An index element... */
typedef|typedef
struct|struct
name|index_elt
block|{
name|struct
name|index_elt
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|entry
decl_stmt|;
comment|/* The index entry itself. */
name|char
modifier|*
name|node
decl_stmt|;
comment|/* The node from whence it came. */
name|int
name|code
decl_stmt|;
comment|/* Non-zero means add `@code{...}' when 				   printing this element. */
name|int
name|defining_line
decl_stmt|;
comment|/* Line number where this entry was written. */
block|}
name|INDEX_ELT
typedef|;
comment|/* A list of short-names for each index, and the index to that index in our    index array, the_indices.  In addition, for each index, it is remembered    whether that index is a code index or not.  Code indices have @code{}    inserted around the first word when they are printed with printindex. */
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|index
decl_stmt|;
name|int
name|code
decl_stmt|;
block|}
name|INDEX_ALIST
typedef|;
name|INDEX_ALIST
modifier|*
modifier|*
name|name_index_alist
init|=
operator|(
name|INDEX_ALIST
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* An array of pointers.  Each one is for a different index.  The    "synindex" command changes which array slot is pointed to by a    given "index". */
name|INDEX_ELT
modifier|*
modifier|*
name|the_indices
init|=
operator|(
name|INDEX_ELT
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* The number of defined indices. */
name|int
name|defined_indices
init|=
literal|0
decl_stmt|;
comment|/* We predefine these. */
define|#
directive|define
name|program_index
value|0
define|#
directive|define
name|function_index
value|1
define|#
directive|define
name|concept_index
value|2
define|#
directive|define
name|variable_index
value|3
define|#
directive|define
name|datatype_index
value|4
define|#
directive|define
name|key_index
value|5
name|init_indices
argument_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* Create the default data structures. */
comment|/* Initialize data space. */
if|if
condition|(
operator|!
name|the_indices
condition|)
block|{
name|the_indices
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|defined_indices
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ELT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|the_indices
index|[
name|defined_indices
index|]
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
expr_stmt|;
name|name_index_alist
operator|=
operator|(
name|INDEX_ALIST
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
name|defined_indices
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ALIST
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|name_index_alist
index|[
name|defined_indices
index|]
operator|=
operator|(
name|INDEX_ALIST
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* If there were existing indices, get rid of them now. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|defined_indices
condition|;
name|i
operator|++
control|)
name|undefindex
argument_list|(
name|name_index_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Add the default indices. */
name|defindex
argument_list|(
literal|"pg"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|defindex
argument_list|(
literal|"fn"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* "fn" is a code index.  */
name|defindex
argument_list|(
literal|"cp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|defindex
argument_list|(
literal|"vr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|defindex
argument_list|(
literal|"tp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|defindex
argument_list|(
literal|"ky"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Find which element in the known list of indices has this name.    Returns -1 if NAME isn't found. */
name|int
name|find_index_offset
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|defined_indices
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|name_index_alist
index|[
name|i
index|]
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|name_index_alist
index|[
name|i
index|]
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|name_index_alist
index|[
name|i
index|]
operator|->
name|index
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Return a pointer to the entry of (name . index) for this name.    Return NULL if the index doesn't exist. */
name|INDEX_ALIST
modifier|*
name|find_index
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|offset
init|=
name|find_index_offset
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|>
operator|-
literal|1
condition|)
return|return
operator|(
name|name_index_alist
index|[
name|offset
index|]
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|INDEX_ALIST
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
comment|/* Given an index name, return the offset in the_indices of this index,    or -1 if there is no such index. */
name|translate_index
argument_list|(
argument|name
argument_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|INDEX_ALIST
modifier|*
name|which
init|=
name|find_index
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|which
condition|)
return|return
operator|(
name|which
operator|->
name|index
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Return the index list which belongs to NAME. */
name|INDEX_ELT
modifier|*
name|index_list
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|which
init|=
name|translate_index
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|which
operator|<
literal|0
condition|)
return|return
operator|(
operator|(
name|INDEX_ELT
operator|*
operator|)
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|the_indices
index|[
name|which
index|]
operator|)
return|;
block|}
comment|/* Please release me, let me go... */
name|free_index
argument_list|(
argument|index
argument_list|)
name|INDEX_ELT
modifier|*
name|index
decl_stmt|;
block|{
name|INDEX_ELT
modifier|*
name|temp
decl_stmt|;
while|while
condition|(
operator|(
name|temp
operator|=
name|index
operator|)
operator|!=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
condition|)
block|{
name|free
argument_list|(
name|temp
operator|->
name|entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|node
argument_list|)
expr_stmt|;
name|index
operator|=
name|index
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Flush an index by name. */
name|undefindex
argument_list|(
argument|name
argument_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|which
init|=
name|find_index_offset
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|which
operator|<
literal|0
condition|)
return|return
operator|(
name|which
operator|)
return|;
name|i
operator|=
name|name_index_alist
index|[
name|which
index|]
operator|->
name|index
expr_stmt|;
name|free_index
argument_list|(
name|the_indices
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|the_indices
index|[
name|i
index|]
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
expr_stmt|;
name|free
argument_list|(
name|name_index_alist
index|[
name|which
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name_index_alist
index|[
name|which
index|]
argument_list|)
expr_stmt|;
name|name_index_alist
index|[
name|which
index|]
operator|=
operator|(
name|INDEX_ALIST
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* Define an index known as NAME.  We assign the slot number.    CODE if non-zero says to make this a code index. */
name|defindex
argument_list|(
argument|name
argument_list|,
argument|code
argument_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|slot
decl_stmt|;
comment|/* If it already exists, flush it. */
name|undefindex
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Try to find an empty slot. */
name|slot
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|defined_indices
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|name_index_alist
index|[
name|i
index|]
condition|)
block|{
name|slot
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|slot
operator|<
literal|0
condition|)
block|{
comment|/* No such luck.  Make space for another index. */
name|slot
operator|=
name|defined_indices
expr_stmt|;
name|defined_indices
operator|++
expr_stmt|;
name|name_index_alist
operator|=
operator|(
name|INDEX_ALIST
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name_index_alist
argument_list|,
operator|(
literal|1
operator|+
name|defined_indices
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ALIST
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|the_indices
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|the_indices
argument_list|,
operator|(
literal|1
operator|+
name|defined_indices
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ELT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We have a slot.  Start assigning. */
name|name_index_alist
index|[
name|slot
index|]
operator|=
operator|(
name|INDEX_ALIST
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|INDEX_ALIST
argument_list|)
argument_list|)
expr_stmt|;
name|name_index_alist
index|[
name|slot
index|]
operator|->
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name_index_alist
index|[
name|slot
index|]
operator|->
name|index
operator|=
name|slot
expr_stmt|;
name|name_index_alist
index|[
name|slot
index|]
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|the_indices
index|[
name|slot
index|]
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
comment|/* Add the arguments to the current index command to the index NAME. */
name|index_add_arg
argument_list|(
argument|name
argument_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|which
decl_stmt|;
name|char
modifier|*
name|index_entry
decl_stmt|;
name|INDEX_ALIST
modifier|*
name|tem
decl_stmt|;
name|tem
operator|=
name|find_index
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|which
operator|=
name|tem
condition|?
name|tem
operator|->
name|index
else|:
operator|-
literal|1
expr_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|index_entry
argument_list|)
expr_stmt|;
name|ignore_blank_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|which
operator|<
literal|0
condition|)
block|{
name|line_error
argument_list|(
literal|"Unknown index reference `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|index_entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|INDEX_ELT
modifier|*
name|new
init|=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|INDEX_ELT
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|next
operator|=
name|the_indices
index|[
name|which
index|]
expr_stmt|;
name|new
operator|->
name|entry
operator|=
name|index_entry
expr_stmt|;
name|new
operator|->
name|node
operator|=
name|current_node
expr_stmt|;
name|new
operator|->
name|code
operator|=
name|tem
operator|->
name|code
expr_stmt|;
name|new
operator|->
name|defining_line
operator|=
name|line_number
operator|-
literal|1
expr_stmt|;
name|the_indices
index|[
name|which
index|]
operator|=
name|new
expr_stmt|;
block|}
block|}
define|#
directive|define
name|INDEX_COMMAND_SUFFIX
value|"index"
comment|/* The function which user defined index commands call. */
name|gen_index
argument_list|()
block|{
name|char
modifier|*
name|name
init|=
name|savestring
argument_list|(
name|command
argument_list|)
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|>=
name|strlen
argument_list|(
literal|"index"
argument_list|)
condition|)
name|name
index|[
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
name|strlen
argument_list|(
literal|"index"
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|index_add_arg
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Define a new index command.  Arg is name of index. */
name|cm_defindex
argument_list|()
block|{
name|gen_defindex
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|cm_defcodeindex
argument_list|()
block|{
name|gen_defindex
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|gen_defindex
argument_list|(
argument|code
argument_list|)
name|int
name|code
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_index
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|line_error
argument_list|(
literal|"Index `%s' already exists"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|char
modifier|*
name|temp
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
literal|"index"
argument_list|)
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%sindex"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|define_user_command
argument_list|(
name|temp
argument_list|,
name|gen_index
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|defindex
argument_list|(
name|name
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Append LIST2 to LIST1.  Return the head of the list. */
name|INDEX_ELT
modifier|*
name|index_append
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|)
name|INDEX_ELT
modifier|*
name|head
decl_stmt|,
decl|*
name|tail
decl_stmt|;
block|{
specifier|register
name|INDEX_ELT
modifier|*
name|t_head
init|=
name|head
decl_stmt|;
if|if
condition|(
operator|!
name|t_head
condition|)
return|return
operator|(
name|tail
operator|)
return|;
while|while
condition|(
name|t_head
operator|->
name|next
condition|)
name|t_head
operator|=
name|t_head
operator|->
name|next
expr_stmt|;
name|t_head
operator|->
name|next
operator|=
name|tail
expr_stmt|;
return|return
operator|(
name|head
operator|)
return|;
block|}
comment|/* Expects 2 args, on the same line.  Both are index abbreviations.    Make the first one be a synonym for the second one, i.e. make the    first one have the same index as the second one. */
name|cm_synindex
argument_list|()
block|{
name|int
name|redirector
decl_stmt|,
name|redirectee
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|skip_whitespace
argument_list|()
expr_stmt|;
name|get_until_in_line
argument_list|(
literal|" "
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|redirectee
operator|=
name|find_index_offset
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|skip_whitespace
argument_list|()
expr_stmt|;
name|free_and_clear
argument_list|(
operator|&
name|temp
argument_list|)
expr_stmt|;
name|get_until_in_line
argument_list|(
literal|" "
argument_list|,
operator|&
name|temp
argument_list|)
expr_stmt|;
name|redirector
operator|=
name|find_index_offset
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|redirector
operator|<
literal|0
operator|||
name|redirectee
operator|<
literal|0
condition|)
block|{
name|line_error
argument_list|(
literal|"Unknown index reference"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* I think that we should let the user make indices synonymous to          each other without any lossage of info.  This means that one can          say @synindex cp dt anywhere in the file, and things that used to          be in cp will go into dt. */
name|INDEX_ELT
modifier|*
name|i1
init|=
name|the_indices
index|[
name|redirectee
index|]
decl_stmt|,
modifier|*
name|i2
init|=
name|the_indices
index|[
name|redirector
index|]
decl_stmt|;
if|if
condition|(
name|i1
operator|||
name|i2
condition|)
block|{
if|if
condition|(
name|i1
condition|)
name|the_indices
index|[
name|redirectee
index|]
operator|=
name|index_append
argument_list|(
name|i1
argument_list|,
name|i2
argument_list|)
expr_stmt|;
else|else
name|the_indices
index|[
name|redirectee
index|]
operator|=
name|index_append
argument_list|(
name|i2
argument_list|,
name|i1
argument_list|)
expr_stmt|;
block|}
name|name_index_alist
index|[
name|redirectee
index|]
operator|->
name|index
operator|=
name|name_index_alist
index|[
name|redirector
index|]
operator|->
name|index
expr_stmt|;
block|}
block|}
name|cm_pindex
argument_list|()
comment|/* Pinhead index. */
block|{
name|index_add_arg
argument_list|(
literal|"pg"
argument_list|)
expr_stmt|;
block|}
name|cm_vindex
argument_list|()
comment|/* Variable index. */
block|{
name|index_add_arg
argument_list|(
literal|"vr"
argument_list|)
expr_stmt|;
block|}
name|cm_kindex
argument_list|()
comment|/* Key index. */
block|{
name|index_add_arg
argument_list|(
literal|"ky"
argument_list|)
expr_stmt|;
block|}
name|cm_cindex
argument_list|()
comment|/* Concept index. */
block|{
name|index_add_arg
argument_list|(
literal|"cp"
argument_list|)
expr_stmt|;
block|}
name|cm_findex
argument_list|()
comment|/* Function index. */
block|{
name|index_add_arg
argument_list|(
literal|"fn"
argument_list|)
expr_stmt|;
block|}
name|cm_tindex
argument_list|()
comment|/* Data Type index. */
block|{
name|index_add_arg
argument_list|(
literal|"tp"
argument_list|)
expr_stmt|;
block|}
comment|/* Sorting the index. */
name|index_element_compare
argument_list|(
argument|element1
argument_list|,
argument|element2
argument_list|)
name|INDEX_ELT
modifier|*
modifier|*
name|element1
decl_stmt|,
modifier|*
modifier|*
name|element2
decl_stmt|;
block|{
comment|/* This needs to ignore leading non-text characters. */
return|return
operator|(
name|stricmp
argument_list|(
operator|(
operator|*
name|element1
operator|)
operator|->
name|entry
argument_list|,
operator|(
operator|*
name|element2
operator|)
operator|->
name|entry
argument_list|)
operator|)
return|;
block|}
comment|/* Sort the index passed in INDEX, returning an array of    pointers to elements.  The array is terminated with a NULL    pointer.  We call qsort because it's supposed to be fast.    I think this looks bad. */
name|INDEX_ELT
modifier|*
modifier|*
name|sort_index
parameter_list|(
name|index
parameter_list|)
name|INDEX_ELT
modifier|*
name|index
decl_stmt|;
block|{
name|INDEX_ELT
modifier|*
name|temp
init|=
name|index
decl_stmt|;
name|INDEX_ELT
modifier|*
modifier|*
name|array
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|temp
operator|!=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
comment|/* We have the length.  Make an array. */
name|array
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|INDEX_ELT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|temp
operator|=
name|index
expr_stmt|;
while|while
condition|(
name|temp
operator|!=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
condition|)
block|{
name|array
index|[
name|count
operator|++
index|]
operator|=
name|temp
expr_stmt|;
name|temp
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
name|array
index|[
name|count
index|]
operator|=
operator|(
name|INDEX_ELT
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* terminate the array. */
comment|/* Sort the array. */
name|qsort
argument_list|(
name|array
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|INDEX_ELT
operator|*
argument_list|)
argument_list|,
name|index_element_compare
argument_list|)
expr_stmt|;
return|return
operator|(
name|array
operator|)
return|;
block|}
comment|/* Non-zero means that we are in the middle of printing an index. */
name|int
name|printing_index
init|=
literal|0
decl_stmt|;
comment|/* Takes one arg, a short name of an index to print.    Outputs a menu of the sorted elements of the index. */
name|cm_printindex
argument_list|()
block|{
name|int
name|item
decl_stmt|;
name|INDEX_ELT
modifier|*
name|index
decl_stmt|;
name|INDEX_ELT
modifier|*
modifier|*
name|array
decl_stmt|;
name|char
modifier|*
name|index_name
decl_stmt|;
name|int
name|old_inhibitions
init|=
name|inhibit_paragraph_indentation
decl_stmt|;
name|int
name|previous_filling_enabled_value
init|=
name|filling_enabled
decl_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|index_name
argument_list|)
expr_stmt|;
name|index
operator|=
name|index_list
argument_list|(
name|index_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|index
operator|==
operator|-
literal|1
condition|)
block|{
name|line_error
argument_list|(
literal|"Unknown index name `%s'"
argument_list|,
name|index_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|index_name
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|free
argument_list|(
name|index_name
argument_list|)
expr_stmt|;
name|array
operator|=
name|sort_index
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|filling_enabled
operator|=
literal|0
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
literal|1
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
name|add_word
argument_list|(
literal|"* Menu:\n\n"
argument_list|)
expr_stmt|;
name|printing_index
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|item
operator|=
literal|0
init|;
operator|(
name|index
operator|=
name|array
index|[
name|item
index|]
operator|)
condition|;
name|item
operator|++
control|)
block|{
name|int
name|real_line_number
init|=
name|line_number
decl_stmt|;
comment|/* Let errors generated while making the index entry point back 	 at the line which contains the entry. */
name|line_number
operator|=
name|index
operator|->
name|defining_line
expr_stmt|;
comment|/* If this particular entry should be printed as a "code" index, 	 then wrap the entry with "@code{...}". */
if|if
condition|(
name|index
operator|->
name|code
condition|)
name|execute_string
argument_list|(
literal|"* @code{%s}: "
argument_list|,
name|index
operator|->
name|entry
argument_list|)
expr_stmt|;
else|else
name|execute_string
argument_list|(
literal|"* %s: "
argument_list|,
name|index
operator|->
name|entry
argument_list|)
expr_stmt|;
comment|/* Pad the front of the destination nodename so that 	 the output looks nice. */
if|if
condition|(
name|fill_column
operator|>
literal|40
operator|&&
name|output_column
operator|<
literal|40
condition|)
name|indent
argument_list|(
literal|40
operator|-
name|output_column
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s.\n"
argument_list|,
name|index
operator|->
name|node
argument_list|)
expr_stmt|;
name|line_number
operator|=
name|real_line_number
expr_stmt|;
name|flush_output
argument_list|()
expr_stmt|;
block|}
name|printing_index
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|close_single_paragraph
argument_list|()
expr_stmt|;
name|filling_enabled
operator|=
name|previous_filling_enabled_value
expr_stmt|;
name|inhibit_paragraph_indentation
operator|=
name|old_inhibitions
expr_stmt|;
block|}
comment|/* **************************************************************** */
comment|/*								    */
comment|/*		    Making User Defined Commands		    */
comment|/*								    */
comment|/* **************************************************************** */
name|define_user_command
argument_list|(
argument|name
argument_list|,
argument|proc
argument_list|,
argument|needs_braces_p
argument_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|FUNCTION
modifier|*
name|proc
decl_stmt|;
name|int
name|needs_braces_p
decl_stmt|;
block|{
name|int
name|slot
init|=
name|user_command_array_len
decl_stmt|;
name|user_command_array_len
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|user_command_array
condition|)
name|user_command_array
operator|=
operator|(
name|COMMAND
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|*
sizeof|sizeof
argument_list|(
name|COMMAND
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|user_command_array
operator|=
operator|(
name|COMMAND
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|user_command_array
argument_list|,
operator|(
literal|1
operator|+
name|user_command_array_len
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|COMMAND
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|user_command_array
index|[
name|slot
index|]
operator|=
operator|(
name|COMMAND
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|COMMAND
argument_list|)
argument_list|)
expr_stmt|;
name|user_command_array
index|[
name|slot
index|]
operator|->
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|user_command_array
index|[
name|slot
index|]
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|user_command_array
index|[
name|slot
index|]
operator|->
name|argument_in_braces
operator|=
name|needs_braces_p
expr_stmt|;
block|}
comment|/* Make ALIAS run the named FUNCTION.  Copies properties from FUNCTION. */
name|define_alias
argument_list|(
argument|alias
argument_list|,
argument|function
argument_list|)
name|char
modifier|*
name|alias
decl_stmt|,
modifier|*
name|function
decl_stmt|;
block|{ }
comment|/* Set the paragraph indentation variable to the value specified in STRING.    Values can be:    `asis': Don't change existing indentation.    `none': Remove existing indentation.       NUM: Indent NUM spaces at the starts of paragraphs.            Note that if NUM is zero, we assume `none'.     Returns 0 if successful, or non-zero if STRING isn't one of the above. */
name|int
name|set_paragraph_indent
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"asis"
argument_list|)
operator|==
literal|0
condition|)
name|paragraph_start_indent
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|string
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
name|paragraph_start_indent
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|string
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|paragraph_start_indent
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
block|{
if|if
condition|(
name|paragraph_start_indent
operator|==
literal|0
condition|)
name|paragraph_start_indent
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cm_paragraphindent
argument_list|()
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_paragraph_indent
argument_list|(
name|arg
argument_list|)
operator|!=
literal|0
condition|)
name|line_error
argument_list|(
literal|"Bad argument to @paragraphindent"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/* Some support for footnotes. */
comment|/* Footnotes are a new construct in Info.  We don't know the best method    of implementing them for sure, so we present two possiblities.     SeparateNode: 	Make them look like followed references, with the reference 	destinations in a makeinfo manufactured node or,     EndNode: 	Make them appear at the bottom of the node that they originally 	appeared in. */
define|#
directive|define
name|SeparateNode
value|0
define|#
directive|define
name|EndNode
value|1
name|int
name|footnote_style
init|=
name|EndNode
decl_stmt|;
name|int
name|first_footnote_this_node
init|=
literal|1
decl_stmt|;
name|int
name|footnote_count
init|=
literal|0
decl_stmt|;
comment|/* Set the footnote style based on he style identifier in STRING. */
name|int
name|set_footnote_style
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|stricmp
argument_list|(
name|string
argument_list|,
literal|"separate"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|stricmp
argument_list|(
name|string
argument_list|,
literal|"MN"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|footnote_style
operator|=
name|SeparateNode
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|stricmp
argument_list|(
name|string
argument_list|,
literal|"end"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|stricmp
argument_list|(
name|string
argument_list|,
literal|"EN"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|footnote_style
operator|=
name|EndNode
expr_stmt|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cm_footnotestyle
argument_list|()
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_footnote_style
argument_list|(
name|arg
argument_list|)
operator|!=
literal|0
condition|)
name|line_error
argument_list|(
literal|"Bad argument to @footnotestyle"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
typedef|typedef
struct|struct
name|fn
block|{
name|struct
name|fn
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|marker
decl_stmt|;
name|char
modifier|*
name|note
decl_stmt|;
block|}
name|FN
typedef|;
name|FN
modifier|*
name|pending_notes
init|=
operator|(
name|FN
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* A method for remembering footnotes.  Note that this list gets output    at the end of the current node. */
name|remember_note
argument_list|(
argument|marker
argument_list|,
argument|note
argument_list|)
name|char
modifier|*
name|marker
decl_stmt|,
modifier|*
name|note
decl_stmt|;
block|{
name|FN
modifier|*
name|temp
init|=
operator|(
name|FN
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FN
argument_list|)
argument_list|)
decl_stmt|;
name|temp
operator|->
name|marker
operator|=
name|savestring
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|temp
operator|->
name|note
operator|=
name|savestring
argument_list|(
name|note
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|pending_notes
expr_stmt|;
name|pending_notes
operator|=
name|temp
expr_stmt|;
name|footnote_count
operator|++
expr_stmt|;
block|}
comment|/* How to get rid of existing footnotes. */
name|free_pending_notes
argument_list|()
block|{
name|FN
modifier|*
name|temp
decl_stmt|;
while|while
condition|(
operator|(
name|temp
operator|=
name|pending_notes
operator|)
operator|!=
operator|(
name|FN
operator|*
operator|)
name|NULL
condition|)
block|{
name|free
argument_list|(
name|temp
operator|->
name|marker
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
operator|->
name|note
argument_list|)
expr_stmt|;
name|pending_notes
operator|=
name|pending_notes
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|first_footnote_this_node
operator|=
literal|1
expr_stmt|;
name|footnote_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* What to do when you see a @footnote construct. */
comment|/* Handle a "footnote".     footnote *{this is a footnote}     where "*" is the marker character for this note. */
name|cm_footnote
argument_list|()
block|{
name|char
modifier|*
name|marker
decl_stmt|;
name|char
modifier|*
name|note
decl_stmt|;
name|get_until
argument_list|(
literal|"{"
argument_list|,
operator|&
name|marker
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
name|marker
argument_list|)
expr_stmt|;
comment|/* Read the argument in braces. */
if|if
condition|(
name|curchar
argument_list|()
operator|!=
literal|'{'
condition|)
block|{
name|line_error
argument_list|(
literal|"`@%s' expected more than just `%s'.  It needs something in `{...}'"
argument_list|,
name|command
argument_list|,
name|marker
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|marker
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|int
name|braces
init|=
literal|1
decl_stmt|;
name|int
name|temp
init|=
operator|++
name|input_text_offset
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
name|braces
condition|)
block|{
if|if
condition|(
name|temp
operator|==
name|size_of_input_text
condition|)
block|{
name|line_error
argument_list|(
literal|"No closing brace for footnote `%s'"
argument_list|,
name|marker
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|input_text
index|[
name|temp
index|]
operator|==
literal|'{'
condition|)
name|braces
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|input_text
index|[
name|temp
index|]
operator|==
literal|'}'
condition|)
name|braces
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|input_text
index|[
name|temp
index|]
operator|==
literal|'\n'
condition|)
name|line_number
operator|++
expr_stmt|;
name|temp
operator|++
expr_stmt|;
block|}
name|len
operator|=
operator|(
name|temp
operator|-
name|input_text_offset
operator|)
operator|-
literal|1
expr_stmt|;
name|note
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|note
argument_list|,
operator|&
name|input_text
index|[
name|input_text_offset
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|note
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|input_text_offset
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|current_node
operator|||
operator|!
operator|*
name|current_node
condition|)
block|{
name|line_error
argument_list|(
literal|"Footnote defined without parent node"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|note
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|*
name|marker
condition|)
block|{
name|free
argument_list|(
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|number_footnotes
condition|)
block|{
name|marker
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|marker
argument_list|,
literal|"%d"
argument_list|,
name|current_footnote_number
argument_list|)
expr_stmt|;
name|current_footnote_number
operator|++
expr_stmt|;
block|}
else|else
name|marker
operator|=
name|savestring
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
block|}
name|remember_note
argument_list|(
name|marker
argument_list|,
name|note
argument_list|)
expr_stmt|;
comment|/* Your method should at least insert MARKER. */
switch|switch
condition|(
name|footnote_style
condition|)
block|{
case|case
name|SeparateNode
case|:
name|add_word_args
argument_list|(
literal|"(%s)"
argument_list|,
name|marker
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_footnote_this_node
condition|)
block|{
name|char
modifier|*
name|temp_string
decl_stmt|;
name|temp_string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|strlen
argument_list|(
name|current_node
argument_list|)
operator|)
operator|+
operator|(
name|strlen
argument_list|(
literal|"-Footnotes"
argument_list|)
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|add_word_args
argument_list|(
literal|" (*note %s-Footnotes::)"
argument_list|,
name|current_node
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp_string
argument_list|,
name|current_node
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp_string
argument_list|,
literal|"-Footnotes"
argument_list|)
expr_stmt|;
name|remember_node_reference
argument_list|(
name|temp_string
argument_list|,
name|line_number
argument_list|,
name|followed_reference
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_string
argument_list|)
expr_stmt|;
name|first_footnote_this_node
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|EndNode
case|:
name|add_word_args
argument_list|(
literal|"(%s)"
argument_list|,
name|marker
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|free
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|note
argument_list|)
expr_stmt|;
block|}
comment|/* Non-zero means that we are currently in the process of outputting    footnotes. */
name|int
name|already_outputting_pending_notes
init|=
literal|0
decl_stmt|;
comment|/* Output the footnotes.  We are at the end of the current node. */
name|output_pending_notes
argument_list|()
block|{
name|FN
modifier|*
name|footnote
init|=
name|pending_notes
decl_stmt|;
if|if
condition|(
operator|!
name|pending_notes
condition|)
return|return;
switch|switch
condition|(
name|footnote_style
condition|)
block|{
case|case
name|SeparateNode
case|:
block|{
name|char
modifier|*
name|old_current_node
init|=
name|current_node
decl_stmt|;
name|char
modifier|*
name|old_command
init|=
name|savestring
argument_list|(
name|command
argument_list|)
decl_stmt|;
name|already_outputting_pending_notes
operator|++
expr_stmt|;
name|execute_string
argument_list|(
literal|"@node %s-Footnotes,,,%s\n"
argument_list|,
name|current_node
argument_list|,
name|current_node
argument_list|)
expr_stmt|;
name|already_outputting_pending_notes
operator|--
expr_stmt|;
name|current_node
operator|=
name|old_current_node
expr_stmt|;
name|free
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|command
operator|=
name|old_command
expr_stmt|;
block|}
break|break;
case|case
name|EndNode
case|:
name|close_paragraph
argument_list|()
expr_stmt|;
name|in_fixed_width_font
operator|++
expr_stmt|;
name|execute_string
argument_list|(
literal|"---------- Footnotes ----------\n\n"
argument_list|)
expr_stmt|;
name|in_fixed_width_font
operator|--
expr_stmt|;
break|break;
block|}
comment|/* Handle the footnotes in reverse order. */
block|{
name|FN
modifier|*
modifier|*
name|array
init|=
operator|(
name|FN
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|footnote_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|FN
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|array
index|[
name|footnote_count
index|]
operator|=
operator|(
name|FN
operator|*
operator|)
name|NULL
expr_stmt|;
while|while
condition|(
operator|--
name|footnote_count
operator|>
operator|-
literal|1
condition|)
block|{
name|array
index|[
name|footnote_count
index|]
operator|=
name|footnote
expr_stmt|;
name|footnote
operator|=
name|footnote
operator|->
name|next
expr_stmt|;
block|}
name|filling_enabled
operator|=
literal|1
expr_stmt|;
name|indented_fill
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|footnote
operator|=
name|array
index|[
operator|++
name|footnote_count
index|]
condition|)
block|{
switch|switch
condition|(
name|footnote_style
condition|)
block|{
case|case
name|SeparateNode
case|:
case|case
name|EndNode
case|:
name|execute_string
argument_list|(
literal|"(%s)  %s"
argument_list|,
name|footnote
operator|->
name|marker
argument_list|,
name|footnote
operator|->
name|note
argument_list|)
expr_stmt|;
name|close_paragraph
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|close_paragraph
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|array
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* **************************************************************** */
comment|/*                                                                  */
comment|/*              User definable Macros (text substitution)	    */
comment|/*                                                                  */
comment|/* **************************************************************** */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MACROS
argument_list|)
comment|/* Array of macros and definitions. */
name|MACRO_DEF
modifier|*
modifier|*
name|macro_list
init|=
operator|(
name|MACRO_DEF
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|macro_list_len
init|=
literal|0
decl_stmt|;
comment|/* Number of elements. */
name|int
name|macro_list_size
init|=
literal|0
decl_stmt|;
comment|/* Number of slots in total. */
comment|/* Return the macro definition of NAME or NULL if NAME is not defined. */
name|MACRO_DEF
modifier|*
name|find_macro
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|MACRO_DEF
modifier|*
name|def
decl_stmt|;
name|def
operator|=
operator|(
name|MACRO_DEF
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|macro_list
operator|&&
operator|(
name|def
operator|=
name|macro_list
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|def
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
return|return
operator|(
name|def
operator|)
return|;
block|}
comment|/* Add the macro NAME with DEFINITION to macro_list.  FILENAME is    the name of the file where this definition can be found, and    LINENO is the line number within that file.  If a macro already    exists with NAME, then a warning is produced, and that previous    definition is overwritten. */
name|void
name|add_macro
parameter_list|(
name|name
parameter_list|,
name|definition
parameter_list|,
name|filename
parameter_list|,
name|lineno
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|definition
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|lineno
decl_stmt|;
block|{
specifier|register
name|MACRO_DEF
modifier|*
name|def
decl_stmt|;
name|def
operator|=
name|find_macro
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|def
condition|)
block|{
if|if
condition|(
name|macro_list_len
operator|+
literal|2
operator|>=
name|macro_list_size
condition|)
name|macro_list
operator|=
operator|(
name|MACRO_DEF
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|macro_list
argument_list|,
operator|(
operator|(
name|macro_list_size
operator|+=
literal|10
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|MACRO_DEF
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|macro_list
index|[
name|macro_list_len
index|]
operator|=
operator|(
name|MACRO_DEF
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|MACRO_DEF
argument_list|)
argument_list|)
expr_stmt|;
name|macro_list
index|[
name|macro_list_len
operator|+
literal|1
index|]
operator|=
operator|(
name|MACRO_DEF
operator|*
operator|)
name|NULL
expr_stmt|;
name|def
operator|=
name|macro_list
index|[
name|macro_list_len
index|]
expr_stmt|;
name|macro_list_len
operator|+=
literal|1
expr_stmt|;
name|def
operator|->
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|temp_filename
init|=
name|input_filename
decl_stmt|;
name|int
name|temp_line
init|=
name|line_number
decl_stmt|;
name|warning
argument_list|(
literal|"The macro `%s' is previously defined."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|def
operator|->
name|filename
expr_stmt|;
name|line_number
operator|=
name|def
operator|->
name|lineno
expr_stmt|;
name|warning
argument_list|(
literal|"Here is the previous definition of `%s'."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|input_filename
operator|=
name|temp_filename
expr_stmt|;
name|line_number
operator|=
name|temp_line
expr_stmt|;
name|free
argument_list|(
name|def
operator|->
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def
operator|->
name|definition
argument_list|)
expr_stmt|;
block|}
name|def
operator|->
name|filename
operator|=
name|savestring
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|def
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
name|def
operator|->
name|definition
operator|=
name|savestring
argument_list|(
name|definition
argument_list|)
expr_stmt|;
block|}
comment|/* Delete the macro with name NAME.  The macro is deleted from the list,    but it is also returned.  If there was no macro defined, NULL is    returned. */
name|MACRO_DEF
modifier|*
name|delete_macro
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|MACRO_DEF
modifier|*
name|def
decl_stmt|;
name|def
operator|=
operator|(
name|MACRO_DEF
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|macro_list
operator|&&
operator|(
name|def
operator|=
name|macro_list
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|def
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|macro_list
operator|+
name|i
argument_list|,
name|macro_list
operator|+
name|i
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|macro_list_len
operator|+
literal|1
operator|)
operator|-
name|i
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|MACRO_DEF
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|def
operator|)
return|;
block|}
comment|/* Execute the macro passed in DEF, a pointer to a MACRO_DEF. */
name|void
name|execute_macro
parameter_list|(
name|def
parameter_list|)
name|MACRO_DEF
modifier|*
name|def
decl_stmt|;
block|{
if|if
condition|(
name|def
operator|!=
operator|(
name|MACRO_DEF
operator|*
operator|)
name|NULL
condition|)
block|{
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|string
decl_stmt|;
name|get_until
argument_list|(
literal|"\n"
argument_list|,
operator|&
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|curchar
argument_list|()
operator|==
literal|'\n'
condition|)
comment|/* as opposed to the end of the file... */
block|{
name|line_number
operator|++
expr_stmt|;
name|input_text_offset
operator|++
expr_stmt|;
block|}
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|def
operator|->
name|definition
argument_list|)
operator|+
name|strlen
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|string
argument_list|,
name|def
operator|->
name|definition
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|execute_string
argument_list|(
literal|"%s\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
block|}
name|int
name|cm_macro
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|name
decl_stmt|,
modifier|*
name|expansion
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
name|line
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|line
index|[
name|i
index|]
operator|&&
operator|!
name|whitespace
argument_list|(
name|line
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|line
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|name
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|whitespace
argument_list|(
name|line
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
name|add_macro
argument_list|(
name|name
argument_list|,
name|line
operator|+
name|i
argument_list|,
name|input_filename
argument_list|,
name|line_number
operator|-
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|int
name|cm_unmacro
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|MACRO_DEF
modifier|*
name|def
decl_stmt|;
name|get_rest_of_line
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|canon_white
argument_list|(
name|line
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|line
index|[
name|i
index|]
operator|&&
operator|!
name|whitespace
argument_list|(
name|line
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|line
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|name
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|def
operator|=
name|delete_macro
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
condition|)
block|{
name|free
argument_list|(
name|def
operator|->
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def
operator|->
name|definition
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|def
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HAVE_MACROS */
comment|/* **************************************************************** */
comment|/*                                                                  */
comment|/*                  Looking For Include Files                       */
comment|/*                                                                  */
comment|/* **************************************************************** */
comment|/* Given a string containing units of information separated by colons,    return the next one pointed to by INDEX, or NULL if there are no more.    Advance INDEX to the character after the colon. */
name|char
modifier|*
name|extract_colon_unit
parameter_list|(
name|string
parameter_list|,
name|index
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
modifier|*
name|index
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|start
decl_stmt|;
name|i
operator|=
operator|*
name|index
expr_stmt|;
if|if
condition|(
operator|!
name|string
operator|||
operator|(
name|i
operator|>=
name|strlen
argument_list|(
name|string
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
comment|/* Each call to this routine leaves the index pointing at a colon if      there is more to the path.  If I is> 0, then increment past the      `:'.  If I is 0, then the path has a leading colon.  Trailing colons      are handled OK by the `else' part of the if statement; an empty      string is returned in that case. */
if|if
condition|(
name|i
operator|&&
name|string
index|[
name|i
index|]
operator|==
literal|':'
condition|)
name|i
operator|++
expr_stmt|;
name|start
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|string
index|[
name|i
index|]
operator|&&
name|string
index|[
name|i
index|]
operator|!=
literal|':'
condition|)
name|i
operator|++
expr_stmt|;
operator|*
name|index
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|start
condition|)
block|{
if|if
condition|(
name|string
index|[
name|i
index|]
condition|)
operator|(
operator|*
name|index
operator|)
operator|++
expr_stmt|;
comment|/* Return "" in the case of a trailing `:'. */
return|return
operator|(
name|savestring
argument_list|(
literal|""
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|char
modifier|*
name|value
decl_stmt|;
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|+
operator|(
name|i
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|value
argument_list|,
operator|&
name|string
index|[
name|start
index|]
argument_list|,
operator|(
name|i
operator|-
name|start
operator|)
argument_list|)
expr_stmt|;
name|value
index|[
name|i
operator|-
name|start
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
block|}
comment|/* Return the full pathname for FILENAME by searching along PATH.    When found, return the stat () info for FILENAME in FINFO.    If PATH is NULL, only the current directory is searched.    If the file could not be found, return a NULL pointer. */
name|char
modifier|*
name|get_file_info_in_path
parameter_list|(
name|filename
parameter_list|,
name|path
parameter_list|,
name|finfo
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|,
decl|*
name|path
decl_stmt|;
name|struct
name|stat
modifier|*
name|finfo
decl_stmt|;
block|{
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|result
decl_stmt|,
name|index
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|path
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|path
operator|=
literal|"."
expr_stmt|;
comment|/* Handle absolute pathnames. "./foo", "/foo", "../foo". */
if|if
condition|(
operator|*
name|filename
operator|==
literal|'/'
operator|||
operator|(
operator|*
name|filename
operator|==
literal|'.'
operator|&&
operator|(
name|filename
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
operator|(
name|filename
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|filename
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
name|finfo
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|savestring
argument_list|(
name|filename
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
while|while
condition|(
name|dir
operator|=
name|extract_colon_unit
argument_list|(
name|path
argument_list|,
operator|&
name|index
argument_list|)
condition|)
block|{
name|char
modifier|*
name|fullpath
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|dir
condition|)
block|{
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|dir
operator|=
name|savestring
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
name|fullpath
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|+
name|strlen
argument_list|(
name|dir
argument_list|)
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fullpath
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|result
operator|=
name|stat
argument_list|(
name|fullpath
argument_list|,
name|finfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
return|return
operator|(
name|fullpath
operator|)
return|;
else|else
name|free
argument_list|(
name|fullpath
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_block

end_unit

