begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Getopt for GNU.    NOTE: getopt is now part of the C library, so if you don't know what    "Keep this file name-space clean" means, talk to roland@gnu.ai.mit.edu    before changing it!     Copyright (C) 1987, 88, 89, 90, 91, 92, 1993    	Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any    later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|emacs
argument_list|)
operator|||
name|defined
argument_list|(
name|CONFIG_BROKETS
argument_list|)
end_if

begin_comment
comment|/* We use<config.h> instead of "config.h" so that a compilation    using -I. -I$srcdir will use ./config.h rather than $srcdir/config.h    (which it would do because it found this file in $srcdir).  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__STDC__
end_ifndef

begin_comment
comment|/* This is a separate conditional since some stdc systems    reject `defined (const)'.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|const
end_ifndef

begin_define
define|#
directive|define
name|const
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This tells Alpha OSF/1 not to define a getopt prototype in<stdio.h>.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_NO_PROTO
end_ifndef

begin_define
define|#
directive|define
name|_NO_PROTO
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* Comment out all this code if we are using the GNU C Library, and are not    actually compiling the library itself.  This code is part of the GNU C    Library, but also included in many other GNU distributions.  Compiling    and linking in this code is a waste when using the GNU C library    (especially if it is a shared library).  Rather than having every GNU    program understand `configure --with-gnu-libc' and omit the object files,    it is simpler to just do this in the source for each such file.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_LIBC
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|__GNU_LIBRARY__
argument_list|)
end_if

begin_comment
comment|/* This needs to come after some library #include    to get __GNU_LIBRARY__ defined.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNU_LIBRARY__
end_ifdef

begin_comment
comment|/* Don't include stdlib.h for non-GNU C libraries because some of them    contain conflicting prototypes for getopt.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GNU C library.  */
end_comment

begin_comment
comment|/* If GETOPT_COMPAT is defined, `+' as well as `--' can introduce a    long-named option.  Because this is not POSIX.2 compliant, it is    being phased out.  */
end_comment

begin_comment
comment|/* #define GETOPT_COMPAT */
end_comment

begin_comment
comment|/* This version of `getopt' appears to the caller like standard Unix `getopt'    but it behaves differently for the user, since it allows the user    to intersperse the options with the other arguments.     As `getopt' works, it permutes the elements of ARGV so that,    when it is done, all the options precede everything else.  Thus    all application programs are extended to handle flexible argument order.     Setting the environment variable POSIXLY_CORRECT disables permutation.    Then the behavior is completely standard.     GNU application programs can use a third alternative mode in which    they can distinguish the relative order of options and other arguments.  */
end_comment

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_comment
comment|/* For communication from `getopt' to the caller.    When `getopt' finds an option that takes an argument,    the argument value is returned here.    Also, when `ordering' is RETURN_IN_ORDER,    each non-option ARGV-element is returned here.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|optarg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index in ARGV of the next element to be scanned.    This is used for communication to and from the caller    and for communication between successive calls to `getopt'.     On entry to `getopt', zero means this is the first call; initialize.     When `getopt' returns EOF, this is the index of the first of the    non-option elements that the caller should itself scan.     Otherwise, `optind' communicates from one call to the next    how much of ARGV has been scanned so far.  */
end_comment

begin_comment
comment|/* XXX 1003.2 says this must be 1 before any call.  */
end_comment

begin_decl_stmt
name|int
name|optind
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The next char to be scanned in the option-element    in which the last option character we returned was found.    This allows us to pick up the scan where we left off.     If this is zero, or a null string, it means resume the scan    by advancing to the next ARGV-element.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|nextchar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Callers store zero here to inhibit the error message    for unrecognized options.  */
end_comment

begin_decl_stmt
name|int
name|opterr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to an option character which was unrecognized.    This must be initialized on some systems to avoid linking in the    system's own getopt implementation.  */
end_comment

begin_decl_stmt
name|int
name|optopt
init|=
literal|'?'
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Describe how to deal with options that follow non-option ARGV-elements.     If the caller did not specify anything,    the default is REQUIRE_ORDER if the environment variable    POSIXLY_CORRECT is defined, PERMUTE otherwise.     REQUIRE_ORDER means don't recognize them as options;    stop option processing when the first non-option is seen.    This is what Unix does.    This mode of operation is selected by either setting the environment    variable POSIXLY_CORRECT, or using `+' as the first character    of the list of option characters.     PERMUTE is the default.  We permute the contents of ARGV as we scan,    so that eventually all the non-options are at the end.  This allows options    to be given in any order, even with programs that were not written to    expect this.     RETURN_IN_ORDER is an option available to programs that were written    to expect options and other ARGV-elements in any order and that care about    the ordering of the two.  We describe each non-option ARGV-element    as if it were the argument of an option with character code 1.    Using `-' as the first character of the list of option characters    selects this mode of operation.     The special argument `--' forces an end of option-scanning regardless    of the value of `ordering'.  In the case of RETURN_IN_ORDER, only    `--' can cause `getopt' to return EOF with `optind' != ARGC.  */
end_comment

begin_enum
specifier|static
enum|enum
block|{
name|REQUIRE_ORDER
block|,
name|PERMUTE
block|,
name|RETURN_IN_ORDER
block|}
name|ordering
enum|;
end_enum

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|__GNU_LIBRARY__
end_ifdef

begin_comment
comment|/* We want to avoid inclusion of string.h with non-GNU libraries    because there are many ways it can cause trouble.    On some systems, it contains special magic macros that don't work    in GCC.  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|my_index
value|strchr
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Avoid depending on library functions or files    whose names are inconsistent.  */
end_comment

begin_function_decl
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|char
modifier|*
name|my_index
parameter_list|(
name|str
parameter_list|,
name|chr
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|chr
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|str
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
name|chr
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|str
return|;
name|str
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If using GCC, we can safely declare strlen this way.    If not using GCC, it is ok not to declare it.    (Supposedly there are some machines where it might get a warning,    but changing this conditional to __STDC__ is too risky.)  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|IN_GCC
end_ifdef

begin_include
include|#
directive|include
file|"gstddef.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|size_t
name|strlen
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GNU C library.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Handle permutation of arguments.  */
end_comment

begin_comment
comment|/* Describe the part of ARGV that contains non-options that have    been skipped.  `first_nonopt' is the index in ARGV of the first of them;    `last_nonopt' is the index after the last of them.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|first_nonopt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_nonopt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exchange two adjacent subsequences of ARGV.    One subsequence is elements [first_nonopt,last_nonopt)    which contains all the non-options that have been skipped so far.    The other is elements [last_nonopt,optind), which contains all    the options processed since those non-options were skipped.     `first_nonopt' and `last_nonopt' are relocated so that they describe    the new indices of the non-options in ARGV after they are moved.  */
end_comment

begin_function
specifier|static
name|void
name|exchange
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|bottom
init|=
name|first_nonopt
decl_stmt|;
name|int
name|middle
init|=
name|last_nonopt
decl_stmt|;
name|int
name|top
init|=
name|optind
decl_stmt|;
name|char
modifier|*
name|tem
decl_stmt|;
comment|/* Exchange the shorter segment with the far end of the longer segment.      That puts the shorter segment into the right place.      It leaves the longer segment in the right place overall,      but it consists of two parts that need to be swapped next.  */
while|while
condition|(
name|top
operator|>
name|middle
operator|&&
name|middle
operator|>
name|bottom
condition|)
block|{
if|if
condition|(
name|top
operator|-
name|middle
operator|>
name|middle
operator|-
name|bottom
condition|)
block|{
comment|/* Bottom segment is the short one.  */
name|int
name|len
init|=
name|middle
operator|-
name|bottom
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Swap it with the top part of the top segment.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|tem
operator|=
name|argv
index|[
name|bottom
operator|+
name|i
index|]
expr_stmt|;
name|argv
index|[
name|bottom
operator|+
name|i
index|]
operator|=
name|argv
index|[
name|top
operator|-
operator|(
name|middle
operator|-
name|bottom
operator|)
operator|+
name|i
index|]
expr_stmt|;
name|argv
index|[
name|top
operator|-
operator|(
name|middle
operator|-
name|bottom
operator|)
operator|+
name|i
index|]
operator|=
name|tem
expr_stmt|;
block|}
comment|/* Exclude the moved bottom segment from further swapping.  */
name|top
operator|-=
name|len
expr_stmt|;
block|}
else|else
block|{
comment|/* Top segment is the short one.  */
name|int
name|len
init|=
name|top
operator|-
name|middle
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Swap it with the bottom part of the bottom segment.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|tem
operator|=
name|argv
index|[
name|bottom
operator|+
name|i
index|]
expr_stmt|;
name|argv
index|[
name|bottom
operator|+
name|i
index|]
operator|=
name|argv
index|[
name|middle
operator|+
name|i
index|]
expr_stmt|;
name|argv
index|[
name|middle
operator|+
name|i
index|]
operator|=
name|tem
expr_stmt|;
block|}
comment|/* Exclude the moved top segment from further swapping.  */
name|bottom
operator|+=
name|len
expr_stmt|;
block|}
block|}
comment|/* Update records for the slots the non-options now occupy.  */
name|first_nonopt
operator|+=
operator|(
name|optind
operator|-
name|last_nonopt
operator|)
expr_stmt|;
name|last_nonopt
operator|=
name|optind
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan elements of ARGV (whose length is ARGC) for option characters    given in OPTSTRING.     If an element of ARGV starts with '-', and is not exactly "-" or "--",    then it is an option element.  The characters of this element    (aside from the initial '-') are option characters.  If `getopt'    is called repeatedly, it returns successively each of the option characters    from each of the option elements.     If `getopt' finds another option character, it returns that character,    updating `optind' and `nextchar' so that the next call to `getopt' can    resume the scan with the following option character or ARGV-element.     If there are no more option characters, `getopt' returns `EOF'.    Then `optind' is the index in ARGV of the first ARGV-element    that is not an option.  (The ARGV-elements have been permuted    so that those that are not options now come last.)     OPTSTRING is a string containing the legitimate option characters.    If an option character is seen that is not listed in OPTSTRING,    return '?' after printing an error message.  If you set `opterr' to    zero, the error message is suppressed but we still return '?'.     If a char in OPTSTRING is followed by a colon, that means it wants an arg,    so the following text in the same ARGV-element, or the text of the following    ARGV-element, is returned in `optarg'.  Two colons mean an option that    wants an optional arg; if there is text in the current ARGV-element,    it is returned in `optarg', otherwise `optarg' is set to zero.     If OPTSTRING starts with `-' or `+', it requests different methods of    handling the non-option ARGV-elements.    See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.     Long-named options begin with `--' instead of `-'.    Their names may be abbreviated as long as the abbreviation is unique    or is an exact match for some defined option.  If they have an    argument, it follows the option name in the same ARGV-element, separated    from the option name by a `=', or else the in next ARGV-element.    When `getopt' finds a long-named option, it returns 0 if that option's    `flag' field is nonzero, the value of the option's `val' field    if the `flag' field is zero.     The elements of ARGV aren't really const, because we permute them.    But we pretend they're const in the prototype to be compatible    with other systems.     LONGOPTS is a vector of `struct option' terminated by an    element containing a name which is zero.     LONGIND returns the index in LONGOPT of the long-named option found.    It is only valid when a long-named option has been found by the most    recent call.     If LONG_ONLY is nonzero, '-' as well as '--' can introduce    long-named options.  */
end_comment

begin_function
name|int
name|_getopt_internal
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|optstring
parameter_list|,
name|longopts
parameter_list|,
name|longind
parameter_list|,
name|long_only
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|optstring
decl_stmt|;
specifier|const
name|struct
name|option
modifier|*
name|longopts
decl_stmt|;
name|int
modifier|*
name|longind
decl_stmt|;
name|int
name|long_only
decl_stmt|;
block|{
name|int
name|option_index
decl_stmt|;
name|optarg
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the internal data when the first call is made.      Start processing options with ARGV-element 1 (since ARGV-element 0      is the program name); the sequence of previously skipped      non-option ARGV-elements is empty.  */
if|if
condition|(
name|optind
operator|==
literal|0
condition|)
block|{
name|first_nonopt
operator|=
name|last_nonopt
operator|=
name|optind
operator|=
literal|1
expr_stmt|;
name|nextchar
operator|=
name|NULL
expr_stmt|;
comment|/* Determine how to handle the ordering of options and nonoptions.  */
if|if
condition|(
name|optstring
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|ordering
operator|=
name|RETURN_IN_ORDER
expr_stmt|;
operator|++
name|optstring
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optstring
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
name|ordering
operator|=
name|REQUIRE_ORDER
expr_stmt|;
operator|++
name|optstring
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|getenv
argument_list|(
literal|"POSIXLY_CORRECT"
argument_list|)
operator|!=
name|NULL
condition|)
name|ordering
operator|=
name|REQUIRE_ORDER
expr_stmt|;
else|else
name|ordering
operator|=
name|PERMUTE
expr_stmt|;
block|}
if|if
condition|(
name|nextchar
operator|==
name|NULL
operator|||
operator|*
name|nextchar
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|ordering
operator|==
name|PERMUTE
condition|)
block|{
comment|/* If we have just processed some options following some non-options, 	     exchange them so that the options come first.  */
if|if
condition|(
name|first_nonopt
operator|!=
name|last_nonopt
operator|&&
name|last_nonopt
operator|!=
name|optind
condition|)
name|exchange
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|last_nonopt
operator|!=
name|optind
condition|)
name|first_nonopt
operator|=
name|optind
expr_stmt|;
comment|/* Now skip any additional non-options 	     and extend the range of non-options previously skipped.  */
while|while
condition|(
name|optind
operator|<
name|argc
operator|&&
operator|(
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|argv
index|[
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
ifdef|#
directive|ifdef
name|GETOPT_COMPAT
operator|&&
operator|(
name|longopts
operator|==
name|NULL
operator|||
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|!=
literal|'+'
operator|||
name|argv
index|[
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
endif|#
directive|endif
comment|/* GETOPT_COMPAT */
condition|)
name|optind
operator|++
expr_stmt|;
name|last_nonopt
operator|=
name|optind
expr_stmt|;
block|}
comment|/* Special ARGV-element `--' means premature end of options. 	 Skip it like a null option, 	 then exchange with previous non-options as if it were an option, 	 then skip everything else like a non-option.  */
if|if
condition|(
name|optind
operator|!=
name|argc
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"--"
argument_list|)
condition|)
block|{
name|optind
operator|++
expr_stmt|;
if|if
condition|(
name|first_nonopt
operator|!=
name|last_nonopt
operator|&&
name|last_nonopt
operator|!=
name|optind
condition|)
name|exchange
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|first_nonopt
operator|==
name|last_nonopt
condition|)
name|first_nonopt
operator|=
name|optind
expr_stmt|;
name|last_nonopt
operator|=
name|argc
expr_stmt|;
name|optind
operator|=
name|argc
expr_stmt|;
block|}
comment|/* If we have done all the ARGV-elements, stop the scan 	 and back over any non-options that we skipped and permuted.  */
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
comment|/* Set the next-arg-index to point at the non-options 	     that we previously skipped, so the caller will digest them.  */
if|if
condition|(
name|first_nonopt
operator|!=
name|last_nonopt
condition|)
name|optind
operator|=
name|first_nonopt
expr_stmt|;
return|return
name|EOF
return|;
block|}
comment|/* If we have come to a non-option and did not permute it, 	 either stop the scan or describe it to the caller and pass it by.  */
if|if
condition|(
operator|(
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|argv
index|[
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
ifdef|#
directive|ifdef
name|GETOPT_COMPAT
operator|&&
operator|(
name|longopts
operator|==
name|NULL
operator|||
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|!=
literal|'+'
operator|||
name|argv
index|[
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
endif|#
directive|endif
comment|/* GETOPT_COMPAT */
condition|)
block|{
if|if
condition|(
name|ordering
operator|==
name|REQUIRE_ORDER
condition|)
return|return
name|EOF
return|;
name|optarg
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* We have found another option-ARGV-element. 	 Start decoding its characters.  */
name|nextchar
operator|=
operator|(
name|argv
index|[
name|optind
index|]
operator|+
literal|1
operator|+
operator|(
name|longopts
operator|!=
name|NULL
operator|&&
name|argv
index|[
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|'-'
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|longopts
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
operator|(
name|argv
index|[
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|'-'
operator|||
name|long_only
operator|)
operator|)
ifdef|#
directive|ifdef
name|GETOPT_COMPAT
operator|||
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
endif|#
directive|endif
comment|/* GETOPT_COMPAT */
operator|)
condition|)
block|{
specifier|const
name|struct
name|option
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|nextchar
decl_stmt|;
name|int
name|exact
init|=
literal|0
decl_stmt|;
name|int
name|ambig
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|option
modifier|*
name|pfound
init|=
name|NULL
decl_stmt|;
name|int
name|indfound
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|'='
condition|)
name|s
operator|++
expr_stmt|;
comment|/* Test all options for either exact match or abbreviated matches.  */
for|for
control|(
name|p
operator|=
name|longopts
operator|,
name|option_index
operator|=
literal|0
init|;
name|p
operator|->
name|name
condition|;
name|p
operator|++
operator|,
name|option_index
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|nextchar
argument_list|,
name|s
operator|-
name|nextchar
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|-
name|nextchar
operator|==
name|strlen
argument_list|(
name|p
operator|->
name|name
argument_list|)
condition|)
block|{
comment|/* Exact match found.  */
name|pfound
operator|=
name|p
expr_stmt|;
name|indfound
operator|=
name|option_index
expr_stmt|;
name|exact
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|pfound
operator|==
name|NULL
condition|)
block|{
comment|/* First nonexact match found.  */
name|pfound
operator|=
name|p
expr_stmt|;
name|indfound
operator|=
name|option_index
expr_stmt|;
block|}
else|else
comment|/* Second nonexact match found.  */
name|ambig
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ambig
operator|&&
operator|!
name|exact
condition|)
block|{
if|if
condition|(
name|opterr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: option `%s' is ambiguous\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|nextchar
operator|+=
name|strlen
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
name|optind
operator|++
expr_stmt|;
return|return
literal|'?'
return|;
block|}
if|if
condition|(
name|pfound
operator|!=
name|NULL
condition|)
block|{
name|option_index
operator|=
name|indfound
expr_stmt|;
name|optind
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
comment|/* Don't test has_arg with>, because some C compilers don't 		 allow it to be used on enums.  */
if|if
condition|(
name|pfound
operator|->
name|has_arg
condition|)
name|optarg
operator|=
name|s
operator|+
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|opterr
condition|)
block|{
if|if
condition|(
name|argv
index|[
name|optind
operator|-
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
comment|/* --option */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: option `--%s' doesn't allow an argument\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|pfound
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
comment|/* +option or -option */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: option `%c%s' doesn't allow an argument\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|optind
operator|-
literal|1
index|]
index|[
literal|0
index|]
argument_list|,
name|pfound
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|nextchar
operator|+=
name|strlen
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
return|return
literal|'?'
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|pfound
operator|->
name|has_arg
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
name|optarg
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
name|opterr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: option `%s' requires an argument\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|optind
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|nextchar
operator|+=
name|strlen
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
return|return
name|optstring
index|[
literal|0
index|]
operator|==
literal|':'
condition|?
literal|':'
else|:
literal|'?'
return|;
block|}
block|}
name|nextchar
operator|+=
name|strlen
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|longind
operator|!=
name|NULL
condition|)
operator|*
name|longind
operator|=
name|option_index
expr_stmt|;
if|if
condition|(
name|pfound
operator|->
name|flag
condition|)
block|{
operator|*
operator|(
name|pfound
operator|->
name|flag
operator|)
operator|=
name|pfound
operator|->
name|val
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|pfound
operator|->
name|val
return|;
block|}
comment|/* Can't find it as a long option.  If this is not getopt_long_only, 	 or the option starts with '--' or is not a valid short 	 option, then it's an error. 	 Otherwise interpret it as a short option.  */
if|if
condition|(
operator|!
name|long_only
operator|||
name|argv
index|[
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|'-'
ifdef|#
directive|ifdef
name|GETOPT_COMPAT
operator|||
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
operator|==
literal|'+'
endif|#
directive|endif
comment|/* GETOPT_COMPAT */
operator|||
name|my_index
argument_list|(
name|optstring
argument_list|,
operator|*
name|nextchar
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|opterr
condition|)
block|{
if|if
condition|(
name|argv
index|[
name|optind
index|]
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
comment|/* --option */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unrecognized option `--%s'\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|nextchar
argument_list|)
expr_stmt|;
else|else
comment|/* +option or -option */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unrecognized option `%c%s'\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
name|optind
index|]
index|[
literal|0
index|]
argument_list|,
name|nextchar
argument_list|)
expr_stmt|;
block|}
name|nextchar
operator|=
operator|(
name|char
operator|*
operator|)
literal|""
expr_stmt|;
name|optind
operator|++
expr_stmt|;
return|return
literal|'?'
return|;
block|}
block|}
comment|/* Look at and handle the next option-character.  */
block|{
name|char
name|c
init|=
operator|*
name|nextchar
operator|++
decl_stmt|;
name|char
modifier|*
name|temp
init|=
name|my_index
argument_list|(
name|optstring
argument_list|,
name|c
argument_list|)
decl_stmt|;
comment|/* Increment `optind' when we start to process its last character.  */
if|if
condition|(
operator|*
name|nextchar
operator|==
literal|'\0'
condition|)
operator|++
name|optind
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
operator|||
name|c
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|opterr
condition|)
block|{
if|#
directive|if
literal|0
block|if (c< 040 || c>= 0177) 	      fprintf (stderr, "%s: unrecognized option, character code 0%o\n", 		       argv[0], c); 	    else 	      fprintf (stderr, "%s: unrecognized option `-%c'\n", argv[0], c);
else|#
directive|else
comment|/* 1003.2 specifies the format of this message.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: illegal option -- %c\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|optopt
operator|=
name|c
expr_stmt|;
return|return
literal|'?'
return|;
block|}
if|if
condition|(
name|temp
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|temp
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* This is an option that accepts an argument optionally.  */
if|if
condition|(
operator|*
name|nextchar
operator|!=
literal|'\0'
condition|)
block|{
name|optarg
operator|=
name|nextchar
expr_stmt|;
name|optind
operator|++
expr_stmt|;
block|}
else|else
name|optarg
operator|=
literal|0
expr_stmt|;
name|nextchar
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* This is an option that requires an argument.  */
if|if
condition|(
operator|*
name|nextchar
operator|!=
literal|'\0'
condition|)
block|{
name|optarg
operator|=
name|nextchar
expr_stmt|;
comment|/* If we end this ARGV-element by taking the rest as an arg, 		   we must advance to the next element now.  */
name|optind
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
if|if
condition|(
name|opterr
condition|)
block|{
if|#
directive|if
literal|0
block|fprintf (stderr, "%s: option `-%c' requires an argument\n", 			     argv[0], c);
else|#
directive|else
comment|/* 1003.2 specifies the format of this message.  */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: option requires an argument -- %c\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|optopt
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|optstring
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
name|c
operator|=
literal|':'
expr_stmt|;
else|else
name|c
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
comment|/* We already incremented `optind' once; 		 increment it again when taking next ARGV-elt as argument.  */
name|optarg
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
name|nextchar
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|c
return|;
block|}
block|}
end_function

begin_function
name|int
name|getopt
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|optstring
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|argv
decl_stmt|;
specifier|const
name|char
modifier|*
name|optstring
decl_stmt|;
block|{
return|return
name|_getopt_internal
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|optstring
argument_list|,
operator|(
specifier|const
expr|struct
name|option
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _LIBC or not __GNU_LIBRARY__.  */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_comment
comment|/* Compile with -DTEST to make an executable for use in testing    the above definition of `getopt'.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|digit_optind
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|this_option_optind
init|=
name|optind
condition|?
name|optind
else|:
literal|1
decl_stmt|;
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"abc:d:0123456789"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|digit_optind
operator|!=
literal|0
operator|&&
name|digit_optind
operator|!=
name|this_option_optind
condition|)
name|printf
argument_list|(
literal|"digits occur in two different argv-elements.\n"
argument_list|)
expr_stmt|;
name|digit_optind
operator|=
name|this_option_optind
expr_stmt|;
name|printf
argument_list|(
literal|"option %c\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|printf
argument_list|(
literal|"option a\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|printf
argument_list|(
literal|"option b\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|printf
argument_list|(
literal|"option c with value `%s'\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"?? getopt returned character code 0%o ??\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|printf
argument_list|(
literal|"non-option ARGV-elements: "
argument_list|)
expr_stmt|;
while|while
condition|(
name|optind
operator|<
name|argc
condition|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST */
end_comment

end_unit

