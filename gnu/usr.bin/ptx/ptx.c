begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Permuted index for GNU, with keywords in their context.    Copyright (C) 1990, 1991, 1993 Free Software Foundation, Inc.    Francois Pinard<pinard@iro.umontreal.ca>, 1988.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|char
modifier|*
name|version_string
init|=
literal|"GNU ptx version 0.3"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
specifier|const
name|copyright
init|=
literal|"\ This program is free software; you can redistribute it and/or modify\n\ it under the terms of the GNU General Public License as published by\n\ the Free Software Foundation; either version 2, or (at your option)\n\ any later version.\n\ \n\ This program is distributed in the hope that it will be useful,\n\ but WITHOUT ANY WARRANTY; without even the implied warranty of\n\ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\ GNU General Public License for more details.\n\ \n\ You should have received a copy of the GNU General Public License\n\ along with this program; if not, write to the Free Software\n\ Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reallocation step when swallowing non regular files.  The value is not    the actual reallocation step, but its base two logarithm.  */
end_comment

begin_define
define|#
directive|define
name|SWALLOW_REALLOC_LOG
value|12
end_define

begin_comment
comment|/* Imported from "regex.c".  */
end_comment

begin_define
define|#
directive|define
name|Sword
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|STDC_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not STDC_HEADERS */
end_comment

begin_comment
comment|/* These definitions work, for all 256 characters.  */
end_comment

begin_define
define|#
directive|define
name|isspace
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t' || (c) == '\n')
end_define

begin_define
define|#
directive|define
name|isxdigit
parameter_list|(
name|c
parameter_list|)
define|\
value|(((unsigned char) (c)>= 'a'&& (unsigned char) (c)<= 'f')		\    || ((unsigned char) (c)>= 'A'&& (unsigned char) (c)<= 'F')	\    || ((unsigned char) (c)>= '0'&& (unsigned char) (c)<= '9'))
end_define

begin_define
define|#
directive|define
name|islower
parameter_list|(
name|c
parameter_list|)
value|((unsigned char) (c)>= 'a'&& (unsigned char) (c)<= 'z')
end_define

begin_define
define|#
directive|define
name|isupper
parameter_list|(
name|c
parameter_list|)
value|((unsigned char) (c)>= 'A'&& (unsigned char) (c)<= 'Z')
end_define

begin_define
define|#
directive|define
name|isalpha
parameter_list|(
name|c
parameter_list|)
value|(islower (c) || isupper (c))
end_define

begin_define
define|#
directive|define
name|toupper
parameter_list|(
name|c
parameter_list|)
value|(islower (c) ? (c) - 'a' + 'A' : (c))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not STDC_HEADERS */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|isascii
argument_list|)
operator|||
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|isascii
end_undef

begin_define
define|#
directive|define
name|isascii
parameter_list|(
name|c
parameter_list|)
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ISXDIGIT
parameter_list|(
name|c
parameter_list|)
value|(isascii (c)&& isxdigit (c))
end_define

begin_define
define|#
directive|define
name|ISODIGIT
parameter_list|(
name|c
parameter_list|)
value|((c)>= '0'&& (c)<= '7')
end_define

begin_define
define|#
directive|define
name|HEXTOBIN
parameter_list|(
name|c
parameter_list|)
value|((c)>='a'&&(c)<='f' ? (c)-'a'+10 : (c)>='A'&&(c)<='F' ? (c)-'A'+10 : (c)-'0')
end_define

begin_define
define|#
directive|define
name|OCTTOBIN
parameter_list|(
name|c
parameter_list|)
value|((c) - '0')
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|S_ISREG
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IFREG
argument_list|)
end_if

begin_define
define|#
directive|define
name|S_ISREG
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFREG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not HAVE_STRING_H */
end_comment

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_define
define|#
directive|define
name|strchr
value|index
end_define

begin_define
define|#
directive|define
name|strrchr
value|rindex
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HAVE_STRING_H */
end_comment

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|errno
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bumpalloc.h"
end_include

begin_include
include|#
directive|include
file|"diacrit.h"
end_include

begin_include
include|#
directive|include
file|"gnuregex.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__STDC__
end_ifndef

begin_function_decl
name|void
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|xrealloc
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|void
modifier|*
name|xmalloc
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|xrealloc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Global definitions.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of this program */
end_comment

begin_decl_stmt
specifier|static
name|int
name|show_help
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* display usage information and exit */
end_comment

begin_decl_stmt
specifier|static
name|int
name|show_version
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print the version and exit */
end_comment

begin_comment
comment|/* Program options.  */
end_comment

begin_enum
enum|enum
name|Format
block|{
name|DUMB_FORMAT
block|,
comment|/* output for a dumb terminal */
name|ROFF_FORMAT
block|,
comment|/* output for `troff' or `nroff' */
name|TEX_FORMAT
block|,
comment|/* output for `TeX' or `LaTeX' */
name|UNKNOWN_FORMAT
comment|/* output format still unknown */
block|}
enum|;
end_enum

begin_decl_stmt
name|int
name|gnu_extensions
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* trigger all GNU extensions */
end_comment

begin_decl_stmt
name|int
name|auto_reference
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* references are `file_name:line_number:' */
end_comment

begin_decl_stmt
name|int
name|input_reference
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* references at beginning of input lines */
end_comment

begin_decl_stmt
name|int
name|right_reference
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output references after right context  */
end_comment

begin_decl_stmt
name|int
name|line_width
init|=
literal|72
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output line width in characters */
end_comment

begin_decl_stmt
name|int
name|gap_size
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of spaces between output fields */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|truncation_string
init|=
literal|"/"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string used to mark line truncations */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|macro_name
init|=
literal|"xx"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* macro name for roff or TeX output */
end_comment

begin_decl_stmt
name|enum
name|Format
name|output_format
init|=
name|UNKNOWN_FORMAT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output format */
end_comment

begin_decl_stmt
name|int
name|ignore_case
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fold lower to upper case for sorting */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|context_regex_string
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* raw regex for end of context */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|word_regex_string
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* raw regex for a keyword */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|break_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of the `Break characters' file */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|only_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of the `Only words' file */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ignore_file
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of the `Ignore words' file */
end_comment

begin_comment
comment|/* A BLOCK delimit a region in memory of arbitrary size, like the copy of a    whole file.  A WORD is something smaller, its length should fit in a    short integer.  A WORD_TABLE may contain several WORDs.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|start
decl_stmt|;
comment|/* pointer to beginning of region */
name|char
modifier|*
name|end
decl_stmt|;
comment|/* pointer to end + 1 of region */
block|}
name|BLOCK
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|start
decl_stmt|;
comment|/* pointer to beginning of region */
name|short
name|size
decl_stmt|;
comment|/* length of the region */
block|}
name|WORD
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|WORD
modifier|*
name|start
decl_stmt|;
comment|/* array of WORDs */
name|size_t
name|length
decl_stmt|;
comment|/* number of entries */
block|}
name|WORD_TABLE
typedef|;
end_typedef

begin_comment
comment|/* Pattern description tables.  */
end_comment

begin_comment
comment|/* For each character, provide its folded equivalent.  */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|folded_chars
index|[
name|CHAR_SET_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each character, indicate if it is part of a word.  */
end_comment

begin_decl_stmt
name|char
name|syntax_table
index|[
name|CHAR_SET_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|re_syntax_table
init|=
name|syntax_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compiled regex for end of context.  */
end_comment

begin_decl_stmt
name|struct
name|re_pattern_buffer
modifier|*
name|context_regex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* End of context pattern register indices.  */
end_comment

begin_decl_stmt
name|struct
name|re_registers
name|context_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compiled regex for a keyword.  */
end_comment

begin_decl_stmt
name|struct
name|re_pattern_buffer
modifier|*
name|word_regex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Keyword pattern register indices.  */
end_comment

begin_decl_stmt
name|struct
name|re_registers
name|word_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A word characters fastmap is used only when no word regexp has been    provided.  A word is then made up of a sequence of one or more characters    allowed by the fastmap.  Contains !0 if character allowed in word.  Not    only this is faster in most cases, but it simplifies the implementation    of the Break files.  */
end_comment

begin_decl_stmt
name|char
name|word_fastmap
index|[
name|CHAR_SET_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum length of any word read.  */
end_comment

begin_decl_stmt
name|int
name|maximum_word_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum width of any reference used.  */
end_comment

begin_decl_stmt
name|int
name|reference_max_width
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ignore and Only word tables.  */
end_comment

begin_decl_stmt
name|WORD_TABLE
name|ignore_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of words to ignore */
end_comment

begin_decl_stmt
name|WORD_TABLE
name|only_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of words to select */
end_comment

begin_define
define|#
directive|define
name|ALLOC_NEW_WORD
parameter_list|(
name|table
parameter_list|)
define|\
value|BUMP_ALLOC ((table)->start, (table)->length, 8, WORD)
end_define

begin_comment
comment|/* Source text table, and scanning macros.  */
end_comment

begin_decl_stmt
name|int
name|number_input_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of text input files */
end_comment

begin_decl_stmt
name|int
name|total_line_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of lines seen so far */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
modifier|*
name|input_file_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of text input file names */
end_comment

begin_decl_stmt
name|int
modifier|*
name|file_line_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of `total_line_count' values at end */
end_comment

begin_decl_stmt
name|BLOCK
name|text_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file to study */
end_comment

begin_decl_stmt
name|char
modifier|*
name|text_buffer_maxend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* allocated end of text_buffer */
end_comment

begin_comment
comment|/* SKIP_NON_WHITE used only for getting or skipping the reference.  */
end_comment

begin_define
define|#
directive|define
name|SKIP_NON_WHITE
parameter_list|(
name|cursor
parameter_list|,
name|limit
parameter_list|)
define|\
value|while (cursor< limit&& !isspace(*cursor))				\     cursor++
end_define

begin_define
define|#
directive|define
name|SKIP_WHITE
parameter_list|(
name|cursor
parameter_list|,
name|limit
parameter_list|)
define|\
value|while (cursor< limit&& isspace(*cursor))				\     cursor++
end_define

begin_define
define|#
directive|define
name|SKIP_WHITE_BACKWARDS
parameter_list|(
name|cursor
parameter_list|,
name|start
parameter_list|)
define|\
value|while (cursor> start&& isspace(cursor[-1]))				\     cursor--
end_define

begin_define
define|#
directive|define
name|SKIP_SOMETHING
parameter_list|(
name|cursor
parameter_list|,
name|limit
parameter_list|)
define|\
value|do									\     if (word_regex_string)						\       {									\ 	int count;							\ 	count = re_match (word_regex, cursor, limit - cursor, 0, NULL);	\ 	cursor += count<= 0 ? 1 : count;				\       }									\     else if (word_fastmap[(unsigned char) *cursor])			\       while (cursor< limit&& word_fastmap[(unsigned char) *cursor])	\ 	cursor++;							\     else								\       cursor++;								\   while (0)
end_define

begin_comment
comment|/* Occurrences table.     The `keyword' pointer provides the central word, which is surrounded    by a left context and a right context.  The `keyword' and `length'    field allow full 8-bit characters keys, even including NULs.  At other    places in this program, the name `keyafter' refers to the keyword    followed by its right context.     The left context does not extend, towards the beginning of the file,    further than a distance given by the `left' value.  This value is    relative to the keyword beginning, it is usually negative.  This    insures that, except for white space, we will never have to backward    scan the source text, when it is time to generate the final output    lines.     The right context, indirectly attainable through the keyword end, does    not extend, towards the end of the file, further than a distance given    by the `right' value.  This value is relative to the keyword    beginning, it is usually positive.     When automatic references are used, the `reference' value is the    overall line number in all input files read so far, in this case, it    is of type (int).  When input references are used, the `reference'    value indicates the distance between the keyword beginning and the    start of the reference field, it is of type (DELTA) and usually    negative.  */
end_comment

begin_typedef
typedef|typedef
name|short
name|DELTA
typedef|;
end_typedef

begin_comment
comment|/* to hold displacement within one context */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|WORD
name|key
decl_stmt|;
comment|/* description of the keyword */
name|DELTA
name|left
decl_stmt|;
comment|/* distance to left context start */
name|DELTA
name|right
decl_stmt|;
comment|/* distance to right context end */
name|int
name|reference
decl_stmt|;
comment|/* reference descriptor */
block|}
name|OCCURS
typedef|;
end_typedef

begin_comment
comment|/* The various OCCURS tables are indexed by the language.  But the time    being, there is no such multiple language support.  */
end_comment

begin_decl_stmt
name|OCCURS
modifier|*
name|occurs_table
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* all words retained from the read text */
end_comment

begin_decl_stmt
name|size_t
name|number_of_occurs
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of used slots in occurs_table */
end_comment

begin_define
define|#
directive|define
name|ALLOC_NEW_OCCURS
parameter_list|(
name|language
parameter_list|)
define|\
value|BUMP_ALLOC (occurs_table[language], number_of_occurs[language], 9, OCCURS)
end_define

begin_comment
comment|/* Communication among output routines.  */
end_comment

begin_comment
comment|/* Indicate if special output processing is requested for each character.  */
end_comment

begin_decl_stmt
name|char
name|edited_flag
index|[
name|CHAR_SET_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|half_line_width
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* half of line width, reference excluded */
end_comment

begin_decl_stmt
name|int
name|before_max_width
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum width of before field */
end_comment

begin_decl_stmt
name|int
name|keyafter_max_width
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum width of keyword-and-after field */
end_comment

begin_decl_stmt
name|int
name|truncation_string_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of string used to flag truncation */
end_comment

begin_comment
comment|/* When context is limited by lines, wraparound may happen on final output:    the `head' pointer gives access to some supplementary left context which    will be seen at the end of the output line, the `tail' pointer gives    access to some supplementary right context which will be seen at the    beginning of the output line. */
end_comment

begin_decl_stmt
name|BLOCK
name|tail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tail field */
end_comment

begin_decl_stmt
name|int
name|tail_truncation
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag truncation after the tail field */
end_comment

begin_decl_stmt
name|BLOCK
name|before
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* before field */
end_comment

begin_decl_stmt
name|int
name|before_truncation
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag truncation before the before field */
end_comment

begin_decl_stmt
name|BLOCK
name|keyafter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keyword-and-after field */
end_comment

begin_decl_stmt
name|int
name|keyafter_truncation
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag truncation after the keyafter field */
end_comment

begin_decl_stmt
name|BLOCK
name|head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* head field */
end_comment

begin_decl_stmt
name|int
name|head_truncation
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag truncation before the head field */
end_comment

begin_decl_stmt
name|BLOCK
name|reference
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reference field for input reference mode */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Miscellaneous routines.  */
end_comment

begin_comment
comment|/*------------------------------------------------------. | Duplicate string STRING, while evaluating \-escapes.  | `------------------------------------------------------*/
end_comment

begin_comment
comment|/* Loosely adapted from GNU shellutils printf.c code.  */
end_comment

begin_function
name|char
modifier|*
name|copy_unescaped_string
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|char
modifier|*
name|result
decl_stmt|;
comment|/* allocated result */
name|char
modifier|*
name|cursor
decl_stmt|;
comment|/* cursor in result */
name|int
name|value
decl_stmt|;
comment|/* value of \nnn escape */
name|int
name|length
decl_stmt|;
comment|/* length of \nnn escape */
name|result
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|result
expr_stmt|;
while|while
condition|(
operator|*
name|string
condition|)
if|if
condition|(
operator|*
name|string
operator|==
literal|'\\'
condition|)
block|{
name|string
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|string
condition|)
block|{
case|case
literal|'x'
case|:
comment|/* \xhhh escape, 3 chars maximum */
name|value
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|length
operator|=
literal|0
operator|,
name|string
operator|++
init|;
name|length
operator|<
literal|3
operator|&&
name|ISXDIGIT
argument_list|(
operator|*
name|string
argument_list|)
condition|;
name|length
operator|++
operator|,
name|string
operator|++
control|)
name|value
operator|=
name|value
operator|*
literal|16
operator|+
name|HEXTOBIN
argument_list|(
operator|*
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
operator|*
name|cursor
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|cursor
operator|++
operator|=
literal|'x'
expr_stmt|;
block|}
else|else
operator|*
name|cursor
operator|++
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
comment|/* \0ooo escape, 3 chars maximum */
name|value
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|length
operator|=
literal|0
operator|,
name|string
operator|++
init|;
name|length
operator|<
literal|3
operator|&&
name|ISODIGIT
argument_list|(
operator|*
name|string
argument_list|)
condition|;
name|length
operator|++
operator|,
name|string
operator|++
control|)
name|value
operator|=
name|value
operator|*
literal|8
operator|+
name|OCTTOBIN
argument_list|(
operator|*
name|string
argument_list|)
expr_stmt|;
operator|*
name|cursor
operator|++
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* alert */
if|#
directive|if
name|__STDC__
operator|*
name|cursor
operator|++
operator|=
literal|'\a'
expr_stmt|;
else|#
directive|else
operator|*
name|cursor
operator|++
operator|=
literal|7
expr_stmt|;
endif|#
directive|endif
name|string
operator|++
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* backspace */
operator|*
name|cursor
operator|++
operator|=
literal|'\b'
expr_stmt|;
name|string
operator|++
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* cancel the rest of the output */
while|while
condition|(
operator|*
name|string
condition|)
name|string
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* form feed */
operator|*
name|cursor
operator|++
operator|=
literal|'\f'
expr_stmt|;
name|string
operator|++
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* new line */
operator|*
name|cursor
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|string
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* carriage return */
operator|*
name|cursor
operator|++
operator|=
literal|'\r'
expr_stmt|;
name|string
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* horizontal tab */
operator|*
name|cursor
operator|++
operator|=
literal|'\t'
expr_stmt|;
name|string
operator|++
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* vertical tab */
if|#
directive|if
name|__STDC__
operator|*
name|cursor
operator|++
operator|=
literal|'\v'
expr_stmt|;
else|#
directive|else
operator|*
name|cursor
operator|++
operator|=
literal|11
expr_stmt|;
endif|#
directive|endif
name|string
operator|++
expr_stmt|;
break|break;
default|default:
operator|*
name|cursor
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|cursor
operator|++
operator|=
operator|*
name|string
operator|++
expr_stmt|;
break|break;
block|}
block|}
else|else
operator|*
name|cursor
operator|++
operator|=
operator|*
name|string
operator|++
expr_stmt|;
operator|*
name|cursor
operator|=
literal|'\0'
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*-------------------------------------------------------------------. | Compile the regex represented by STRING, diagnose and abort if any | | error.  Returns the compiled regex structure.			     | `-------------------------------------------------------------------*/
end_comment

begin_function
name|struct
name|re_pattern_buffer
modifier|*
name|alloc_and_compile_regex
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|struct
name|re_pattern_buffer
modifier|*
name|pattern
decl_stmt|;
comment|/* newly allocated structure */
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
comment|/* error message returned by regex.c */
name|pattern
operator|=
operator|(
expr|struct
name|re_pattern_buffer
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|re_pattern_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pattern
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|re_pattern_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|pattern
operator|->
name|buffer
operator|=
name|NULL
expr_stmt|;
name|pattern
operator|->
name|allocated
operator|=
literal|0
expr_stmt|;
name|pattern
operator|->
name|translate
operator|=
name|ignore_case
condition|?
operator|(
name|char
operator|*
operator|)
name|folded_chars
else|:
name|NULL
expr_stmt|;
name|pattern
operator|->
name|fastmap
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|CHAR_SET_SIZE
argument_list|)
expr_stmt|;
name|message
operator|=
name|re_compile_pattern
argument_list|(
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%s (for regexp `%s')"
argument_list|,
name|message
argument_list|,
name|string
argument_list|)
expr_stmt|;
comment|/* The fastmap should be compiled before `re_match'.  The following      call is not mandatory, because `re_search' is always called sooner,      and it compiles the fastmap if this has not been done yet.  */
name|re_compile_fastmap
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
comment|/* Do not waste extra allocated space.  */
if|if
condition|(
name|pattern
operator|->
name|allocated
operator|>
name|pattern
operator|->
name|used
condition|)
block|{
name|pattern
operator|->
name|buffer
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|pattern
operator|->
name|buffer
argument_list|,
name|pattern
operator|->
name|used
argument_list|)
expr_stmt|;
name|pattern
operator|->
name|allocated
operator|=
name|pattern
operator|->
name|used
expr_stmt|;
block|}
return|return
name|pattern
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------. | This will initialize various tables for pattern match and compiles some | | regexps.								  | `------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|initialize_regex
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|character
decl_stmt|;
comment|/* character value */
comment|/* Initialize the regex syntax table.  */
for|for
control|(
name|character
operator|=
literal|0
init|;
name|character
operator|<
name|CHAR_SET_SIZE
condition|;
name|character
operator|++
control|)
name|syntax_table
index|[
name|character
index|]
operator|=
name|isalpha
argument_list|(
name|character
argument_list|)
condition|?
name|Sword
else|:
literal|0
expr_stmt|;
comment|/* Initialize the case folding table.  */
if|if
condition|(
name|ignore_case
condition|)
for|for
control|(
name|character
operator|=
literal|0
init|;
name|character
operator|<
name|CHAR_SET_SIZE
condition|;
name|character
operator|++
control|)
name|folded_chars
index|[
name|character
index|]
operator|=
name|toupper
argument_list|(
name|character
argument_list|)
expr_stmt|;
comment|/* Unless the user already provided a description of the end of line or      end of sentence sequence, select an end of line sequence to compile.      If the user provided an empty definition, thus disabling end of line      or sentence feature, make it NULL to speed up tests.  If GNU      extensions are enabled, use end of sentence like in GNU emacs.  If      disabled, use end of lines.  */
if|if
condition|(
name|context_regex_string
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|context_regex_string
condition|)
name|context_regex_string
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gnu_extensions
operator|&&
operator|!
name|input_reference
condition|)
name|context_regex_string
operator|=
literal|"[.?!][]\"')}]*\\($\\|\t\\|  \\)[ \t\n]*"
expr_stmt|;
else|else
name|context_regex_string
operator|=
literal|"\n"
expr_stmt|;
if|if
condition|(
name|context_regex_string
condition|)
name|context_regex
operator|=
name|alloc_and_compile_regex
argument_list|(
name|context_regex_string
argument_list|)
expr_stmt|;
comment|/* If the user has already provided a non-empty regexp to describe      words, compile it.  Else, unless this has already been done through      a user provided Break character file, construct a fastmap of      characters that may appear in a word.  If GNU extensions enabled,      include only letters of the underlying character set.  If disabled,      include almost everything, even punctuations; stop only on white      space.  */
if|if
condition|(
name|word_regex_string
operator|&&
operator|*
name|word_regex_string
condition|)
name|word_regex
operator|=
name|alloc_and_compile_regex
argument_list|(
name|word_regex_string
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|break_file
condition|)
if|if
condition|(
name|gnu_extensions
condition|)
block|{
comment|/* Simulate \w+.  */
for|for
control|(
name|character
operator|=
literal|0
init|;
name|character
operator|<
name|CHAR_SET_SIZE
condition|;
name|character
operator|++
control|)
name|word_fastmap
index|[
name|character
index|]
operator|=
name|isalpha
argument_list|(
name|character
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Simulate [^ \t\n]+.  */
name|memset
argument_list|(
name|word_fastmap
argument_list|,
literal|1
argument_list|,
name|CHAR_SET_SIZE
argument_list|)
expr_stmt|;
name|word_fastmap
index|[
literal|' '
index|]
operator|=
literal|0
expr_stmt|;
name|word_fastmap
index|[
literal|'\t'
index|]
operator|=
literal|0
expr_stmt|;
name|word_fastmap
index|[
literal|'\n'
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------. | This routine will attempt to swallow a whole file name FILE_NAME into a | | contiguous region of memory and return a description of it into BLOCK.  | | Standard input is assumed whenever FILE_NAME is NULL, empty or "-".	  | | 									  | | Previously, in some cases, white space compression was attempted while  | | inputting text.  This was defeating some regexps like default end of	  | | sentence, which checks for two consecutive spaces.  If white space	  | | compression is ever reinstated, it should be in output routines.	  | `------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|swallow_file_in_memory
parameter_list|(
specifier|const
name|char
modifier|*
name|file_name
parameter_list|,
name|BLOCK
modifier|*
name|block
parameter_list|)
block|{
name|int
name|file_handle
decl_stmt|;
comment|/* file descriptor number */
name|struct
name|stat
name|stat_block
decl_stmt|;
comment|/* stat block for file */
name|int
name|allocated_length
decl_stmt|;
comment|/* allocated length of memory buffer */
name|int
name|used_length
decl_stmt|;
comment|/* used length in memory buffer */
name|int
name|read_length
decl_stmt|;
comment|/* number of character gotten on last read */
comment|/* As special cases, a file name which is NULL or "-" indicates standard      input, which is already opened.  In all other cases, open the file from      its name.  */
if|if
condition|(
operator|!
name|file_name
operator|||
operator|!
operator|*
name|file_name
operator|||
name|strcmp
argument_list|(
name|file_name
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|file_handle
operator|=
name|fileno
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|file_handle
operator|=
name|open
argument_list|(
name|file_name
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
comment|/* If the file is a plain, regular file, allocate the memory buffer all at      once and swallow the file in one blow.  In other cases, read the file      repeatedly in smaller chunks until we have it all, reallocating memory      once in a while, as we go.  */
if|if
condition|(
name|fstat
argument_list|(
name|file_handle
argument_list|,
operator|&
name|stat_block
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|stat_block
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|block
operator|->
name|start
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|int
operator|)
name|stat_block
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|file_handle
argument_list|,
name|block
operator|->
name|start
argument_list|,
operator|(
name|int
operator|)
name|stat_block
operator|.
name|st_size
argument_list|)
operator|!=
name|stat_block
operator|.
name|st_size
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|block
operator|->
name|end
operator|=
name|block
operator|->
name|start
operator|+
name|stat_block
operator|.
name|st_size
expr_stmt|;
block|}
else|else
block|{
name|block
operator|->
name|start
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|1
operator|<<
name|SWALLOW_REALLOC_LOG
argument_list|)
expr_stmt|;
name|used_length
operator|=
literal|0
expr_stmt|;
name|allocated_length
operator|=
operator|(
literal|1
operator|<<
name|SWALLOW_REALLOC_LOG
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|read_length
operator|=
name|read
argument_list|(
name|file_handle
argument_list|,
name|block
operator|->
name|start
operator|+
name|used_length
argument_list|,
name|allocated_length
operator|-
name|used_length
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|used_length
operator|+=
name|read_length
expr_stmt|;
if|if
condition|(
name|used_length
operator|==
name|allocated_length
condition|)
block|{
name|allocated_length
operator|+=
operator|(
literal|1
operator|<<
name|SWALLOW_REALLOC_LOG
operator|)
expr_stmt|;
name|block
operator|->
name|start
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|block
operator|->
name|start
argument_list|,
name|allocated_length
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|read_length
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|block
operator|->
name|end
operator|=
name|block
operator|->
name|start
operator|+
name|used_length
expr_stmt|;
block|}
comment|/* Close the file, but only if it was not the standard input.  */
if|if
condition|(
name|file_handle
operator|!=
name|fileno
argument_list|(
name|stdin
argument_list|)
condition|)
name|close
argument_list|(
name|file_handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Sort and search routines.  */
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------. | Compare two words, FIRST and SECOND, and return 0 if they are identical.  | | Return less than 0 if the first word goes before the second; return	    | | greater than 0 if the first word goes after the second.		    | | 									    | | If a word is indeed a prefix of the other, the shorter should go first.   | `--------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|compare_words
parameter_list|(
specifier|const
name|void
modifier|*
name|void_first
parameter_list|,
specifier|const
name|void
modifier|*
name|void_second
parameter_list|)
block|{
define|#
directive|define
name|first
value|((WORD *) void_first)
define|#
directive|define
name|second
value|((WORD *) void_second)
name|int
name|length
decl_stmt|;
comment|/* minimum of two lengths */
name|int
name|counter
decl_stmt|;
comment|/* cursor in words */
name|int
name|value
decl_stmt|;
comment|/* value of comparison */
name|length
operator|=
name|first
operator|->
name|size
operator|<
name|second
operator|->
name|size
condition|?
name|first
operator|->
name|size
else|:
name|second
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|ignore_case
condition|)
block|{
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|length
condition|;
name|counter
operator|++
control|)
block|{
name|value
operator|=
operator|(
name|folded_chars
index|[
call|(
name|unsigned
name|char
call|)
argument_list|(
name|first
operator|->
name|start
index|[
name|counter
index|]
argument_list|)
index|]
operator|-
name|folded_chars
index|[
call|(
name|unsigned
name|char
call|)
argument_list|(
name|second
operator|->
name|start
index|[
name|counter
index|]
argument_list|)
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
block|}
block|}
else|else
block|{
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|length
condition|;
name|counter
operator|++
control|)
block|{
name|value
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|)
name|first
operator|->
name|start
index|[
name|counter
index|]
operator|-
operator|(
name|unsigned
name|char
operator|)
name|second
operator|->
name|start
index|[
name|counter
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
return|return
name|value
return|;
block|}
block|}
return|return
name|first
operator|->
name|size
operator|-
name|second
operator|->
name|size
return|;
undef|#
directive|undef
name|first
undef|#
directive|undef
name|second
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------. | Decides which of two OCCURS, FIRST or SECOND, should lexicographically | | go first.  In case of a tie, preserve the original order through a	 | | pointer comparison.							 | `-----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|compare_occurs
parameter_list|(
specifier|const
name|void
modifier|*
name|void_first
parameter_list|,
specifier|const
name|void
modifier|*
name|void_second
parameter_list|)
block|{
define|#
directive|define
name|first
value|((OCCURS *) void_first)
define|#
directive|define
name|second
value|((OCCURS *) void_second)
name|int
name|value
decl_stmt|;
name|value
operator|=
name|compare_words
argument_list|(
operator|&
name|first
operator|->
name|key
argument_list|,
operator|&
name|second
operator|->
name|key
argument_list|)
expr_stmt|;
return|return
name|value
operator|==
literal|0
condition|?
name|first
operator|->
name|key
operator|.
name|start
operator|-
name|second
operator|->
name|key
operator|.
name|start
else|:
name|value
return|;
undef|#
directive|undef
name|first
undef|#
directive|undef
name|second
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------. | Return !0 if WORD appears in TABLE.  Uses a binary search.  | `------------------------------------------------------------*/
end_comment

begin_function
name|int
name|search_table
parameter_list|(
name|WORD
modifier|*
name|word
parameter_list|,
name|WORD_TABLE
modifier|*
name|table
parameter_list|)
block|{
name|int
name|lowest
decl_stmt|;
comment|/* current lowest possible index */
name|int
name|highest
decl_stmt|;
comment|/* current highest possible index */
name|int
name|middle
decl_stmt|;
comment|/* current middle index */
name|int
name|value
decl_stmt|;
comment|/* value from last comparison */
name|lowest
operator|=
literal|0
expr_stmt|;
name|highest
operator|=
name|table
operator|->
name|length
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|lowest
operator|<=
name|highest
condition|)
block|{
name|middle
operator|=
operator|(
name|lowest
operator|+
name|highest
operator|)
operator|/
literal|2
expr_stmt|;
name|value
operator|=
name|compare_words
argument_list|(
name|word
argument_list|,
name|table
operator|->
name|start
operator|+
name|middle
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
condition|)
name|highest
operator|=
name|middle
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|>
literal|0
condition|)
name|lowest
operator|=
name|middle
operator|+
literal|1
expr_stmt|;
else|else
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------. | Sort the whole occurs table in memory.  Presumably, `qsort' does not | | take intermediate copies or table elements, so the sort will be      | | stabilized throughout the comparison routine.			       | `---------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|sort_found_occurs
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Only one language for the time being.  */
name|qsort
argument_list|(
name|occurs_table
index|[
literal|0
index|]
argument_list|,
name|number_of_occurs
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|OCCURS
argument_list|)
argument_list|,
name|compare_occurs
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parameter files reading routines.  */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------. | Read a file named FILE_NAME, containing a set of break characters.    | | Build a content to the array word_fastmap in which all characters are | | allowed except those found in the file.  Characters may be repeated.  | `----------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|digest_break_file
parameter_list|(
specifier|const
name|char
modifier|*
name|file_name
parameter_list|)
block|{
name|BLOCK
name|file_contents
decl_stmt|;
comment|/* to receive a copy of the file */
name|char
modifier|*
name|cursor
decl_stmt|;
comment|/* cursor in file copy */
name|swallow_file_in_memory
argument_list|(
name|file_name
argument_list|,
operator|&
name|file_contents
argument_list|)
expr_stmt|;
comment|/* Make the fastmap and record the file contents in it.  */
name|memset
argument_list|(
name|word_fastmap
argument_list|,
literal|1
argument_list|,
name|CHAR_SET_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|cursor
operator|=
name|file_contents
operator|.
name|start
init|;
name|cursor
operator|<
name|file_contents
operator|.
name|end
condition|;
name|cursor
operator|++
control|)
name|word_fastmap
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cursor
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|gnu_extensions
condition|)
block|{
comment|/* If GNU extensions are enabled, the only way to avoid newline as 	 a break character is to write all the break characters in the 	 file with no newline at all, not even at the end of the file. 	 If disabled, spaces, tabs and newlines are always considered as 	 break characters even if not included in the break file.  */
name|word_fastmap
index|[
literal|' '
index|]
operator|=
literal|0
expr_stmt|;
name|word_fastmap
index|[
literal|'\t'
index|]
operator|=
literal|0
expr_stmt|;
name|word_fastmap
index|[
literal|'\n'
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Return the space of the file, which is no more required.  */
name|free
argument_list|(
name|file_contents
operator|.
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------. | Read a file named FILE_NAME, containing one word per line, then	 | | construct in TABLE a table of WORD descriptors for them.  The routine	 | | swallows the whole file in memory; this is at the expense of space	 | | needed for newlines, which are useless; however, the reading is fast.	 | `-----------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|digest_word_file
parameter_list|(
specifier|const
name|char
modifier|*
name|file_name
parameter_list|,
name|WORD_TABLE
modifier|*
name|table
parameter_list|)
block|{
name|BLOCK
name|file_contents
decl_stmt|;
comment|/* to receive a copy of the file */
name|char
modifier|*
name|cursor
decl_stmt|;
comment|/* cursor in file copy */
name|char
modifier|*
name|word_start
decl_stmt|;
comment|/* start of the current word */
name|swallow_file_in_memory
argument_list|(
name|file_name
argument_list|,
operator|&
name|file_contents
argument_list|)
expr_stmt|;
name|table
operator|->
name|start
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|length
operator|=
literal|0
expr_stmt|;
comment|/* Read the whole file.  */
name|cursor
operator|=
name|file_contents
operator|.
name|start
expr_stmt|;
while|while
condition|(
name|cursor
operator|<
name|file_contents
operator|.
name|end
condition|)
block|{
comment|/* Read one line, and save the word in contains.  */
name|word_start
operator|=
name|cursor
expr_stmt|;
while|while
condition|(
name|cursor
operator|<
name|file_contents
operator|.
name|end
operator|&&
operator|*
name|cursor
operator|!=
literal|'\n'
condition|)
name|cursor
operator|++
expr_stmt|;
comment|/* Record the word in table if it is not empty.  */
if|if
condition|(
name|cursor
operator|>
name|word_start
condition|)
block|{
name|ALLOC_NEW_WORD
argument_list|(
name|table
argument_list|)
expr_stmt|;
name|table
operator|->
name|start
index|[
name|table
operator|->
name|length
index|]
operator|.
name|start
operator|=
name|word_start
expr_stmt|;
name|table
operator|->
name|start
index|[
name|table
operator|->
name|length
index|]
operator|.
name|size
operator|=
name|cursor
operator|-
name|word_start
expr_stmt|;
name|table
operator|->
name|length
operator|++
expr_stmt|;
block|}
comment|/* This test allows for an incomplete line at end of file.  */
if|if
condition|(
name|cursor
operator|<
name|file_contents
operator|.
name|end
condition|)
name|cursor
operator|++
expr_stmt|;
block|}
comment|/* Finally, sort all the words read.  */
name|qsort
argument_list|(
name|table
operator|->
name|start
argument_list|,
name|table
operator|->
name|length
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
name|WORD
argument_list|)
argument_list|,
name|compare_words
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Keyword recognition and selection.  */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------. | For each keyword in the source text, constructs an OCCURS structure.  | `----------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|find_occurs_in_text
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|cursor
decl_stmt|;
comment|/* for scanning the source text */
name|char
modifier|*
name|scan
decl_stmt|;
comment|/* for scanning the source text also */
name|char
modifier|*
name|line_start
decl_stmt|;
comment|/* start of the current input line */
name|char
modifier|*
name|line_scan
decl_stmt|;
comment|/* newlines scanned until this point */
name|int
name|reference_length
decl_stmt|;
comment|/* length of reference in input mode */
name|WORD
name|possible_key
decl_stmt|;
comment|/* possible key, to ease searches */
name|OCCURS
modifier|*
name|occurs_cursor
decl_stmt|;
comment|/* current OCCURS under construction */
name|char
modifier|*
name|context_start
decl_stmt|;
comment|/* start of left context */
name|char
modifier|*
name|context_end
decl_stmt|;
comment|/* end of right context */
name|char
modifier|*
name|word_start
decl_stmt|;
comment|/* start of word */
name|char
modifier|*
name|word_end
decl_stmt|;
comment|/* end of word */
name|char
modifier|*
name|next_context_start
decl_stmt|;
comment|/* next start of left context */
comment|/* reference_length is always used within `if (input_reference)'.      However, GNU C diagnoses that it may be used uninitialized.  The      following assignment is merely to shut it up.  */
name|reference_length
operator|=
literal|0
expr_stmt|;
comment|/* Tracking where lines start is helpful for reference processing.  In      auto reference mode, this allows counting lines.  In input reference      mode, this permits finding the beginning of the references.       The first line begins with the file, skip immediately this very first      reference in input reference mode, to help further rejection any word      found inside it.  Also, unconditionally assigning these variable has      the happy effect of shutting up lint.  */
name|line_start
operator|=
name|text_buffer
operator|.
name|start
expr_stmt|;
name|line_scan
operator|=
name|line_start
expr_stmt|;
if|if
condition|(
name|input_reference
condition|)
block|{
name|SKIP_NON_WHITE
argument_list|(
name|line_scan
argument_list|,
name|text_buffer
operator|.
name|end
argument_list|)
expr_stmt|;
name|reference_length
operator|=
name|line_scan
operator|-
name|line_start
expr_stmt|;
name|SKIP_WHITE
argument_list|(
name|line_scan
argument_list|,
name|text_buffer
operator|.
name|end
argument_list|)
expr_stmt|;
block|}
comment|/* Process the whole buffer, one line or one sentence at a time.  */
for|for
control|(
name|cursor
operator|=
name|text_buffer
operator|.
name|start
init|;
name|cursor
operator|<
name|text_buffer
operator|.
name|end
condition|;
name|cursor
operator|=
name|next_context_start
control|)
block|{
comment|/* `context_start' gets initialized before the processing of each 	 line, or once for the whole buffer if no end of line or sentence 	 sequence separator.  */
name|context_start
operator|=
name|cursor
expr_stmt|;
comment|/* If a end of line or end of sentence sequence is defined and 	 non-empty, `next_context_start' will be recomputed to be the end of 	 each line or sentence, before each one is processed.  If no such 	 sequence, then `next_context_start' is set at the end of the whole 	 buffer, which is then considered to be a single line or sentence. 	 This test also accounts for the case of an incomplete line or 	 sentence at the end of the buffer.  */
if|if
condition|(
name|context_regex_string
operator|&&
operator|(
name|re_search
argument_list|(
name|context_regex
argument_list|,
name|cursor
argument_list|,
name|text_buffer
operator|.
name|end
operator|-
name|cursor
argument_list|,
literal|0
argument_list|,
name|text_buffer
operator|.
name|end
operator|-
name|cursor
argument_list|,
operator|&
name|context_regs
argument_list|)
operator|>=
literal|0
operator|)
condition|)
name|next_context_start
operator|=
name|cursor
operator|+
name|context_regs
operator|.
name|end
index|[
literal|0
index|]
expr_stmt|;
else|else
name|next_context_start
operator|=
name|text_buffer
operator|.
name|end
expr_stmt|;
comment|/* Include the separator into the right context, but not any suffix 	 white space in this separator; this insures it will be seen in 	 output and will not take more space than necessary.  */
name|context_end
operator|=
name|next_context_start
expr_stmt|;
name|SKIP_WHITE_BACKWARDS
argument_list|(
name|context_end
argument_list|,
name|context_start
argument_list|)
expr_stmt|;
comment|/* Read and process a single input line or sentence, one word at a 	 time.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|word_regex
condition|)
comment|/* If a word regexp has been compiled, use it to skip at the 	       beginning of the next word.  If there is no such word, exit 	       the loop.  */
block|{
if|if
condition|(
name|re_search
argument_list|(
name|word_regex
argument_list|,
name|cursor
argument_list|,
name|context_end
operator|-
name|cursor
argument_list|,
literal|0
argument_list|,
name|context_end
operator|-
name|cursor
argument_list|,
operator|&
name|word_regs
argument_list|)
operator|<
literal|0
condition|)
break|break;
name|word_start
operator|=
name|cursor
operator|+
name|word_regs
operator|.
name|start
index|[
literal|0
index|]
expr_stmt|;
name|word_end
operator|=
name|cursor
operator|+
name|word_regs
operator|.
name|end
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
comment|/* Avoid re_search and use the fastmap to skip to the 	       beginning of the next word.  If there is no more word in 	       the buffer, exit the loop.  */
block|{
name|scan
operator|=
name|cursor
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|context_end
operator|&&
operator|!
name|word_fastmap
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|scan
index|]
condition|)
name|scan
operator|++
expr_stmt|;
if|if
condition|(
name|scan
operator|==
name|context_end
condition|)
break|break;
name|word_start
operator|=
name|scan
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|context_end
operator|&&
name|word_fastmap
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|scan
index|]
condition|)
name|scan
operator|++
expr_stmt|;
name|word_end
operator|=
name|scan
expr_stmt|;
block|}
comment|/* Skip right to the beginning of the found word.  */
name|cursor
operator|=
name|word_start
expr_stmt|;
comment|/* Skip any zero length word.  Just advance a single position, 	     then go fetch the next word.  */
if|if
condition|(
name|word_end
operator|==
name|word_start
condition|)
block|{
name|cursor
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* This is a genuine, non empty word, so save it as a possible 	     key.  Then skip over it.  Also, maintain the maximum length of 	     all words read so far.  It is mandatory to take the maximum 	     length of all words in the file, without considering if they 	     are actually kept or rejected, because backward jumps at output 	     generation time may fall in *any* word.  */
name|possible_key
operator|.
name|start
operator|=
name|cursor
expr_stmt|;
name|possible_key
operator|.
name|size
operator|=
name|word_end
operator|-
name|word_start
expr_stmt|;
name|cursor
operator|+=
name|possible_key
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|possible_key
operator|.
name|size
operator|>
name|maximum_word_length
condition|)
name|maximum_word_length
operator|=
name|possible_key
operator|.
name|size
expr_stmt|;
comment|/* In input reference mode, update `line_start' from its previous 	     value.  Count the lines just in case auto reference mode is 	     also selected. If it happens that the word just matched is 	     indeed part of a reference; just ignore it.  */
if|if
condition|(
name|input_reference
condition|)
block|{
while|while
condition|(
name|line_scan
operator|<
name|possible_key
operator|.
name|start
condition|)
if|if
condition|(
operator|*
name|line_scan
operator|==
literal|'\n'
condition|)
block|{
name|total_line_count
operator|++
expr_stmt|;
name|line_scan
operator|++
expr_stmt|;
name|line_start
operator|=
name|line_scan
expr_stmt|;
name|SKIP_NON_WHITE
argument_list|(
name|line_scan
argument_list|,
name|text_buffer
operator|.
name|end
argument_list|)
expr_stmt|;
name|reference_length
operator|=
name|line_scan
operator|-
name|line_start
expr_stmt|;
block|}
else|else
name|line_scan
operator|++
expr_stmt|;
if|if
condition|(
name|line_scan
operator|>
name|possible_key
operator|.
name|start
condition|)
continue|continue;
block|}
comment|/* Ignore the word if an `Ignore words' table exists and if it is 	     part of it.  Also ignore the word if an `Only words' table and 	     if it is *not* part of it.  	     It is allowed that both tables be used at once, even if this 	     may look strange for now.  Just ignore a word that would appear 	     in both.  If regexps are eventually implemented for these 	     tables, the Ignore table could then reject words that would 	     have been previously accepted by the Only table.  */
if|if
condition|(
name|ignore_file
operator|&&
name|search_table
argument_list|(
operator|&
name|possible_key
argument_list|,
operator|&
name|ignore_table
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|only_file
operator|&&
operator|!
name|search_table
argument_list|(
operator|&
name|possible_key
argument_list|,
operator|&
name|only_table
argument_list|)
condition|)
continue|continue;
comment|/* A non-empty word has been found.  First of all, insure 	     proper allocation of the next OCCURS, and make a pointer to 	     where it will be constructed.  */
name|ALLOC_NEW_OCCURS
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|occurs_cursor
operator|=
name|occurs_table
index|[
literal|0
index|]
operator|+
name|number_of_occurs
index|[
literal|0
index|]
expr_stmt|;
comment|/* Define the refence field, if any.  */
if|if
condition|(
name|auto_reference
condition|)
block|{
comment|/* While auto referencing, update `line_start' from its 		 previous value, counting lines as we go.  If input 		 referencing at the same time, `line_start' has been 		 advanced earlier, and the following loop is never really 		 executed.  */
while|while
condition|(
name|line_scan
operator|<
name|possible_key
operator|.
name|start
condition|)
if|if
condition|(
operator|*
name|line_scan
operator|==
literal|'\n'
condition|)
block|{
name|total_line_count
operator|++
expr_stmt|;
name|line_scan
operator|++
expr_stmt|;
name|line_start
operator|=
name|line_scan
expr_stmt|;
name|SKIP_NON_WHITE
argument_list|(
name|line_scan
argument_list|,
name|text_buffer
operator|.
name|end
argument_list|)
expr_stmt|;
block|}
else|else
name|line_scan
operator|++
expr_stmt|;
name|occurs_cursor
operator|->
name|reference
operator|=
name|total_line_count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|input_reference
condition|)
block|{
comment|/* If only input referencing, `line_start' has been computed 		 earlier to detect the case the word matched would be part 		 of the reference.  The reference position is simply the 		 value of `line_start'.  */
name|occurs_cursor
operator|->
name|reference
operator|=
call|(
name|DELTA
call|)
argument_list|(
name|line_start
operator|-
name|possible_key
operator|.
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|reference_length
operator|>
name|reference_max_width
condition|)
name|reference_max_width
operator|=
name|reference_length
expr_stmt|;
block|}
comment|/* Exclude the reference from the context in simple cases.  */
if|if
condition|(
name|input_reference
operator|&&
name|line_start
operator|==
name|context_start
condition|)
block|{
name|SKIP_NON_WHITE
argument_list|(
name|context_start
argument_list|,
name|context_end
argument_list|)
expr_stmt|;
name|SKIP_WHITE
argument_list|(
name|context_start
argument_list|,
name|context_end
argument_list|)
expr_stmt|;
block|}
comment|/* Completes the OCCURS structure.  */
name|occurs_cursor
operator|->
name|key
operator|=
name|possible_key
expr_stmt|;
name|occurs_cursor
operator|->
name|left
operator|=
name|context_start
operator|-
name|possible_key
operator|.
name|start
expr_stmt|;
name|occurs_cursor
operator|->
name|right
operator|=
name|context_end
operator|-
name|possible_key
operator|.
name|start
expr_stmt|;
name|number_of_occurs
index|[
literal|0
index|]
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Formatting and actual output - service routines.  */
end_comment

begin_comment
comment|/*-----------------------------------------. | Prints some NUMBER of spaces on stdout.  | `-----------------------------------------*/
end_comment

begin_function
name|void
name|print_spaces
parameter_list|(
name|int
name|number
parameter_list|)
block|{
name|int
name|counter
decl_stmt|;
for|for
control|(
name|counter
operator|=
name|number
init|;
name|counter
operator|>
literal|0
condition|;
name|counter
operator|--
control|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-------------------------------------. | Prints the field provided by FIELD.  | `-------------------------------------*/
end_comment

begin_function
name|void
name|print_field
parameter_list|(
name|BLOCK
name|field
parameter_list|)
block|{
name|char
modifier|*
name|cursor
decl_stmt|;
comment|/* Cursor in field to print */
name|int
name|character
decl_stmt|;
comment|/* Current character */
name|int
name|base
decl_stmt|;
comment|/* Base character, without diacritic */
name|int
name|diacritic
decl_stmt|;
comment|/* Diacritic code for the character */
comment|/* Whitespace is not really compressed.  Instead, each white space      character (tab, vt, ht etc.) is printed as one single space.  */
for|for
control|(
name|cursor
operator|=
name|field
operator|.
name|start
init|;
name|cursor
operator|<
name|field
operator|.
name|end
condition|;
name|cursor
operator|++
control|)
block|{
name|character
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cursor
expr_stmt|;
if|if
condition|(
name|edited_flag
index|[
name|character
index|]
condition|)
block|{
comment|/* First check if this is a diacriticized character.  	     This works only for TeX.  I do not know how diacriticized 	     letters work with `roff'.  Please someone explain it to me!  */
name|diacritic
operator|=
name|todiac
argument_list|(
name|character
argument_list|)
expr_stmt|;
if|if
condition|(
name|diacritic
operator|!=
literal|0
operator|&&
name|output_format
operator|==
name|TEX_FORMAT
condition|)
block|{
name|base
operator|=
name|tobase
argument_list|(
name|character
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|diacritic
condition|)
block|{
case|case
literal|1
case|:
comment|/* Latin diphthongs */
switch|switch
condition|(
name|base
condition|)
block|{
case|case
literal|'o'
case|:
name|printf
argument_list|(
literal|"\\oe{}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|printf
argument_list|(
literal|"\\OE{}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|printf
argument_list|(
literal|"\\ae{}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|printf
argument_list|(
literal|"\\AE{}"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* Acute accent */
name|printf
argument_list|(
literal|"\\'%s%c"
argument_list|,
operator|(
name|base
operator|==
literal|'i'
condition|?
literal|"\\"
else|:
literal|""
operator|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* Grave accent */
name|printf
argument_list|(
literal|"\\`%s%c"
argument_list|,
operator|(
name|base
operator|==
literal|'i'
condition|?
literal|"\\"
else|:
literal|""
operator|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* Circumflex accent */
name|printf
argument_list|(
literal|"\\^%s%c"
argument_list|,
operator|(
name|base
operator|==
literal|'i'
condition|?
literal|"\\"
else|:
literal|""
operator|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* Diaeresis */
name|printf
argument_list|(
literal|"\\\"%s%c"
argument_list|,
operator|(
name|base
operator|==
literal|'i'
condition|?
literal|"\\"
else|:
literal|""
operator|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* Tilde accent */
name|printf
argument_list|(
literal|"\\~%s%c"
argument_list|,
operator|(
name|base
operator|==
literal|'i'
condition|?
literal|"\\"
else|:
literal|""
operator|)
argument_list|,
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* Cedilla */
name|printf
argument_list|(
literal|"\\c{%c}"
argument_list|,
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* Small circle beneath */
switch|switch
condition|(
name|base
condition|)
block|{
case|case
literal|'a'
case|:
name|printf
argument_list|(
literal|"\\aa{}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|printf
argument_list|(
literal|"\\AA{}"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|9
case|:
comment|/* Strike through */
switch|switch
condition|(
name|base
condition|)
block|{
case|case
literal|'o'
case|:
name|printf
argument_list|(
literal|"\\o{}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|printf
argument_list|(
literal|"\\O{}"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
comment|/* This is not a diacritic character, so handle cases which are 	       really specific to `roff' or TeX.  All white space processing 	       is done as the default case of this switch.  */
switch|switch
condition|(
name|character
condition|)
block|{
case|case
literal|'"'
case|:
comment|/* In roff output format, double any quote.  */
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
case|case
literal|'%'
case|:
case|case
literal|'&'
case|:
case|case
literal|'#'
case|:
case|case
literal|'_'
case|:
comment|/* In TeX output format, precede these with a backslash.  */
name|putchar
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|character
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
case|case
literal|'}'
case|:
comment|/* In TeX output format, precede these with a backslash and 		   force mathematical mode.  */
name|printf
argument_list|(
literal|"$\\%c$"
argument_list|,
name|character
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* In TeX output mode, request production of a backslash.  */
name|printf
argument_list|(
literal|"\\backslash{}"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Any other flagged character produces a single space.  */
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|putchar
argument_list|(
operator|*
name|cursor
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Formatting and actual output - planning routines.  */
end_comment

begin_comment
comment|/*--------------------------------------------------------------------. | From information collected from command line options and input file | | readings, compute and fix some output parameter values.	      | `--------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|fix_output_parameters
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|file_index
decl_stmt|;
comment|/* index in text input file arrays */
name|int
name|line_ordinal
decl_stmt|;
comment|/* line ordinal value for reference */
name|char
name|ordinal_string
index|[
literal|12
index|]
decl_stmt|;
comment|/* edited line ordinal for reference */
name|int
name|reference_width
decl_stmt|;
comment|/* width for the whole reference */
name|int
name|character
decl_stmt|;
comment|/* character ordinal */
specifier|const
name|char
modifier|*
name|cursor
decl_stmt|;
comment|/* cursor in some constant strings */
comment|/* In auto reference mode, the maximum width of this field is      precomputed and subtracted from the overall line width.  Add one for      the column which separate the file name from the line number.  */
if|if
condition|(
name|auto_reference
condition|)
block|{
name|reference_max_width
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|file_index
operator|=
literal|0
init|;
name|file_index
operator|<
name|number_input_files
condition|;
name|file_index
operator|++
control|)
block|{
name|line_ordinal
operator|=
name|file_line_count
index|[
name|file_index
index|]
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|file_index
operator|>
literal|0
condition|)
name|line_ordinal
operator|-=
name|file_line_count
index|[
name|file_index
operator|-
literal|1
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|ordinal_string
argument_list|,
literal|"%d"
argument_list|,
name|line_ordinal
argument_list|)
expr_stmt|;
name|reference_width
operator|=
name|strlen
argument_list|(
name|ordinal_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_file_name
index|[
name|file_index
index|]
condition|)
name|reference_width
operator|+=
name|strlen
argument_list|(
name|input_file_name
index|[
name|file_index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reference_width
operator|>
name|reference_max_width
condition|)
name|reference_max_width
operator|=
name|reference_width
expr_stmt|;
block|}
name|reference_max_width
operator|++
expr_stmt|;
name|reference
operator|.
name|start
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|reference_max_width
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If the reference appears to the left of the output line, reserve some      space for it right away, including one gap size.  */
if|if
condition|(
operator|(
name|auto_reference
operator|||
name|input_reference
operator|)
operator|&&
operator|!
name|right_reference
condition|)
name|line_width
operator|-=
name|reference_max_width
operator|+
name|gap_size
expr_stmt|;
comment|/* The output lines, minimally, will contain from left to right a left      context, a gap, and a keyword followed by the right context with no      special intervening gap.  Half of the line width is dedicated to the      left context and the gap, the other half is dedicated to the keyword      and the right context; these values are computed once and for all here.      There also are tail and head wrap around fields, used when the keyword      is near the beginning or the end of the line, or when some long word      cannot fit in, but leave place from wrapped around shorter words.  The      maximum width of these fields are recomputed separately for each line,      on a case by case basis.  It is worth noting that it cannot happen that      both the tail and head fields are used at once.  */
name|half_line_width
operator|=
name|line_width
operator|/
literal|2
expr_stmt|;
name|before_max_width
operator|=
name|half_line_width
operator|-
name|gap_size
expr_stmt|;
name|keyafter_max_width
operator|=
name|half_line_width
expr_stmt|;
comment|/* If truncation_string is the empty string, make it NULL to speed up      tests.  In this case, truncation_string_length will never get used, so      there is no need to set it.  */
if|if
condition|(
name|truncation_string
operator|&&
operator|*
name|truncation_string
condition|)
name|truncation_string_length
operator|=
name|strlen
argument_list|(
name|truncation_string
argument_list|)
expr_stmt|;
else|else
name|truncation_string
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|gnu_extensions
condition|)
block|{
comment|/* When flagging truncation at the left of the keyword, the 	 truncation mark goes at the beginning of the before field, 	 unless there is a head field, in which case the mark goes at the 	 left of the head field.  When flagging truncation at the right 	 of the keyword, the mark goes at the end of the keyafter field, 	 unless there is a tail field, in which case the mark goes at the 	 end of the tail field.  Only eight combination cases could arise 	 for truncation marks:  	 . None. 	 . One beginning the before field. 	 . One beginning the head field. 	 . One ending the keyafter field. 	 . One ending the tail field. 	 . One beginning the before field, another ending the keyafter field. 	 . One ending the tail field, another beginning the before field. 	 . One ending the keyafter field, another beginning the head field.  	 So, there is at most two truncation marks, which could appear both 	 on the left side of the center of the output line, both on the 	 right side, or one on either side.  */
name|before_max_width
operator|-=
literal|2
operator|*
name|truncation_string_length
expr_stmt|;
name|keyafter_max_width
operator|-=
literal|2
operator|*
name|truncation_string_length
expr_stmt|;
block|}
else|else
block|{
comment|/* I never figured out exactly how UNIX' ptx plans the output width 	 of its various fields.  If GNU extensions are disabled, do not 	 try computing the field widths correctly; instead, use the 	 following formula, which does not completely imitate UNIX' ptx, 	 but almost.  */
name|keyafter_max_width
operator|-=
literal|2
operator|*
name|truncation_string_length
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Compute which characters need special output processing.  Initialize      by flagging any white space character.  Some systems do not consider      form feed as a space character, but we do.  */
for|for
control|(
name|character
operator|=
literal|0
init|;
name|character
operator|<
name|CHAR_SET_SIZE
condition|;
name|character
operator|++
control|)
name|edited_flag
index|[
name|character
index|]
operator|=
name|isspace
argument_list|(
name|character
argument_list|)
expr_stmt|;
name|edited_flag
index|[
literal|'\f'
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Complete the special character flagging according to selected output      format.  */
switch|switch
condition|(
name|output_format
condition|)
block|{
case|case
name|UNKNOWN_FORMAT
case|:
comment|/* Should never happen.  */
case|case
name|DUMB_FORMAT
case|:
break|break;
case|case
name|ROFF_FORMAT
case|:
comment|/* `Quote' characters should be doubled.  */
name|edited_flag
index|[
literal|'"'
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TEX_FORMAT
case|:
comment|/* Various characters need special processing.  */
for|for
control|(
name|cursor
operator|=
literal|"$%&#_{}\\"
init|;
operator|*
name|cursor
condition|;
name|cursor
operator|++
control|)
name|edited_flag
index|[
operator|*
name|cursor
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Any character with 8th bit set will print to a single space, unless 	 it is diacriticized.  */
for|for
control|(
name|character
operator|=
literal|0200
init|;
name|character
operator|<
name|CHAR_SET_SIZE
condition|;
name|character
operator|++
control|)
name|edited_flag
index|[
name|character
index|]
operator|=
name|todiac
argument_list|(
name|character
argument_list|)
operator|!=
literal|0
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------. | Compute the position and length of all the output fields, given a | | pointer to some OCCURS.					    | `------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|define_all_fields
parameter_list|(
name|OCCURS
modifier|*
name|occurs
parameter_list|)
block|{
name|int
name|tail_max_width
decl_stmt|;
comment|/* allowable width of tail field */
name|int
name|head_max_width
decl_stmt|;
comment|/* allowable width of head field */
name|char
modifier|*
name|cursor
decl_stmt|;
comment|/* running cursor in source text */
name|char
modifier|*
name|left_context_start
decl_stmt|;
comment|/* start of left context */
name|char
modifier|*
name|right_context_end
decl_stmt|;
comment|/* end of right context */
name|char
modifier|*
name|left_field_start
decl_stmt|;
comment|/* conservative start for `head'/`before' */
name|int
name|file_index
decl_stmt|;
comment|/* index in text input file arrays */
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
comment|/* file name for reference */
name|int
name|line_ordinal
decl_stmt|;
comment|/* line ordinal for reference */
comment|/* Define `keyafter', start of left context and end of right context.      `keyafter' starts at the saved position for keyword and extend to the      right from the end of the keyword, eating separators or full words, but      not beyond maximum allowed width for `keyafter' field or limit for the      right context.  Suffix spaces will be removed afterwards.  */
name|keyafter
operator|.
name|start
operator|=
name|occurs
operator|->
name|key
operator|.
name|start
expr_stmt|;
name|keyafter
operator|.
name|end
operator|=
name|keyafter
operator|.
name|start
operator|+
name|occurs
operator|->
name|key
operator|.
name|size
expr_stmt|;
name|left_context_start
operator|=
name|keyafter
operator|.
name|start
operator|+
name|occurs
operator|->
name|left
expr_stmt|;
name|right_context_end
operator|=
name|keyafter
operator|.
name|start
operator|+
name|occurs
operator|->
name|right
expr_stmt|;
name|cursor
operator|=
name|keyafter
operator|.
name|end
expr_stmt|;
while|while
condition|(
name|cursor
operator|<
name|right_context_end
operator|&&
name|cursor
operator|<=
name|keyafter
operator|.
name|start
operator|+
name|keyafter_max_width
condition|)
block|{
name|keyafter
operator|.
name|end
operator|=
name|cursor
expr_stmt|;
name|SKIP_SOMETHING
argument_list|(
name|cursor
argument_list|,
name|right_context_end
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cursor
operator|<=
name|keyafter
operator|.
name|start
operator|+
name|keyafter_max_width
condition|)
name|keyafter
operator|.
name|end
operator|=
name|cursor
expr_stmt|;
name|keyafter_truncation
operator|=
name|truncation_string
operator|&&
name|keyafter
operator|.
name|end
operator|<
name|right_context_end
expr_stmt|;
name|SKIP_WHITE_BACKWARDS
argument_list|(
name|keyafter
operator|.
name|end
argument_list|,
name|keyafter
operator|.
name|start
argument_list|)
expr_stmt|;
comment|/* When the left context is wide, it might take some time to catch up from      the left context boundary to the beginning of the `head' or `before'      fields.  So, in this case, to speed the catchup, we jump back from the      keyword, using some secure distance, possibly falling in the middle of      a word.  A secure backward jump would be at least half the maximum      width of a line, plus the size of the longest word met in the whole      input.  We conclude this backward jump by a skip forward of at least      one word.  In this manner, we should not inadvertently accept only part      of a word.  From the reached point, when it will be time to fix the      beginning of `head' or `before' fields, we will skip forward words or      delimiters until we get sufficiently near.  */
if|if
condition|(
operator|-
name|occurs
operator|->
name|left
operator|>
name|half_line_width
operator|+
name|maximum_word_length
condition|)
block|{
name|left_field_start
operator|=
name|keyafter
operator|.
name|start
operator|-
operator|(
name|half_line_width
operator|+
name|maximum_word_length
operator|)
expr_stmt|;
name|SKIP_SOMETHING
argument_list|(
name|left_field_start
argument_list|,
name|keyafter
operator|.
name|start
argument_list|)
expr_stmt|;
block|}
else|else
name|left_field_start
operator|=
name|keyafter
operator|.
name|start
operator|+
name|occurs
operator|->
name|left
expr_stmt|;
comment|/* `before' certainly ends at the keyword, but not including separating      spaces.  It starts after than the saved value for the left context, by      advancing it until it falls inside the maximum allowed width for the      before field.  There will be no prefix spaces either.  `before' only      advances by skipping single separators or whole words. */
name|before
operator|.
name|start
operator|=
name|left_field_start
expr_stmt|;
name|before
operator|.
name|end
operator|=
name|keyafter
operator|.
name|start
expr_stmt|;
name|SKIP_WHITE_BACKWARDS
argument_list|(
name|before
operator|.
name|end
argument_list|,
name|before
operator|.
name|start
argument_list|)
expr_stmt|;
while|while
condition|(
name|before
operator|.
name|start
operator|+
name|before_max_width
operator|<
name|before
operator|.
name|end
condition|)
name|SKIP_SOMETHING
argument_list|(
name|before
operator|.
name|start
argument_list|,
name|before
operator|.
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|truncation_string
condition|)
block|{
name|cursor
operator|=
name|before
operator|.
name|start
expr_stmt|;
name|SKIP_WHITE_BACKWARDS
argument_list|(
name|cursor
argument_list|,
name|text_buffer
operator|.
name|start
argument_list|)
expr_stmt|;
name|before_truncation
operator|=
name|cursor
operator|>
name|left_context_start
expr_stmt|;
block|}
else|else
name|before_truncation
operator|=
literal|0
expr_stmt|;
name|SKIP_WHITE
argument_list|(
name|before
operator|.
name|start
argument_list|,
name|text_buffer
operator|.
name|end
argument_list|)
expr_stmt|;
comment|/* The tail could not take more columns than what has been left in the      left context field, and a gap is mandatory.  It starts after the      right context, and does not contain prefixed spaces.  It ends at      the end of line, the end of buffer or when the tail field is full,      whichever comes first.  It cannot contain only part of a word, and      has no suffixed spaces.  */
name|tail_max_width
operator|=
name|before_max_width
operator|-
operator|(
name|before
operator|.
name|end
operator|-
name|before
operator|.
name|start
operator|)
operator|-
name|gap_size
expr_stmt|;
if|if
condition|(
name|tail_max_width
operator|>
literal|0
condition|)
block|{
name|tail
operator|.
name|start
operator|=
name|keyafter
operator|.
name|end
expr_stmt|;
name|SKIP_WHITE
argument_list|(
name|tail
operator|.
name|start
argument_list|,
name|text_buffer
operator|.
name|end
argument_list|)
expr_stmt|;
name|tail
operator|.
name|end
operator|=
name|tail
operator|.
name|start
expr_stmt|;
name|cursor
operator|=
name|tail
operator|.
name|end
expr_stmt|;
while|while
condition|(
name|cursor
operator|<
name|right_context_end
operator|&&
name|cursor
operator|<
name|tail
operator|.
name|start
operator|+
name|tail_max_width
condition|)
block|{
name|tail
operator|.
name|end
operator|=
name|cursor
expr_stmt|;
name|SKIP_SOMETHING
argument_list|(
name|cursor
argument_list|,
name|right_context_end
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cursor
operator|<
name|tail
operator|.
name|start
operator|+
name|tail_max_width
condition|)
name|tail
operator|.
name|end
operator|=
name|cursor
expr_stmt|;
if|if
condition|(
name|tail
operator|.
name|end
operator|>
name|tail
operator|.
name|start
condition|)
block|{
name|keyafter_truncation
operator|=
literal|0
expr_stmt|;
name|tail_truncation
operator|=
name|truncation_string
operator|&&
name|tail
operator|.
name|end
operator|<
name|right_context_end
expr_stmt|;
block|}
else|else
name|tail_truncation
operator|=
literal|0
expr_stmt|;
name|SKIP_WHITE_BACKWARDS
argument_list|(
name|tail
operator|.
name|end
argument_list|,
name|tail
operator|.
name|start
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No place left for a tail field.  */
name|tail
operator|.
name|start
operator|=
name|NULL
expr_stmt|;
name|tail
operator|.
name|end
operator|=
name|NULL
expr_stmt|;
name|tail_truncation
operator|=
literal|0
expr_stmt|;
block|}
comment|/* `head' could not take more columns than what has been left in the right      context field, and a gap is mandatory.  It ends before the left      context, and does not contain suffixed spaces.  Its pointer is advanced      until the head field has shrunk to its allowed width.  It cannot      contain only part of a word, and has no suffixed spaces.  */
name|head_max_width
operator|=
name|keyafter_max_width
operator|-
operator|(
name|keyafter
operator|.
name|end
operator|-
name|keyafter
operator|.
name|start
operator|)
operator|-
name|gap_size
expr_stmt|;
if|if
condition|(
name|head_max_width
operator|>
literal|0
condition|)
block|{
name|head
operator|.
name|end
operator|=
name|before
operator|.
name|start
expr_stmt|;
name|SKIP_WHITE_BACKWARDS
argument_list|(
name|head
operator|.
name|end
argument_list|,
name|text_buffer
operator|.
name|start
argument_list|)
expr_stmt|;
name|head
operator|.
name|start
operator|=
name|left_field_start
expr_stmt|;
while|while
condition|(
name|head
operator|.
name|start
operator|+
name|head_max_width
operator|<
name|head
operator|.
name|end
condition|)
name|SKIP_SOMETHING
argument_list|(
name|head
operator|.
name|start
argument_list|,
name|head
operator|.
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|.
name|end
operator|>
name|head
operator|.
name|start
condition|)
block|{
name|before_truncation
operator|=
literal|0
expr_stmt|;
name|head_truncation
operator|=
operator|(
name|truncation_string
operator|&&
name|head
operator|.
name|start
operator|>
name|left_context_start
operator|)
expr_stmt|;
block|}
else|else
name|head_truncation
operator|=
literal|0
expr_stmt|;
name|SKIP_WHITE
argument_list|(
name|head
operator|.
name|start
argument_list|,
name|head
operator|.
name|end
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No place left for a head field.  */
name|head
operator|.
name|start
operator|=
name|NULL
expr_stmt|;
name|head
operator|.
name|end
operator|=
name|NULL
expr_stmt|;
name|head_truncation
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|auto_reference
condition|)
block|{
comment|/* Construct the reference text in preallocated space from the file 	 name and the line number.  Find out in which file the reference 	 occurred.  Standard input yields an empty file name.  Insure line 	 numbers are one based, even if they are computed zero based.  */
name|file_index
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|file_line_count
index|[
name|file_index
index|]
operator|<
name|occurs
operator|->
name|reference
condition|)
name|file_index
operator|++
expr_stmt|;
name|file_name
operator|=
name|input_file_name
index|[
name|file_index
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|file_name
condition|)
name|file_name
operator|=
literal|""
expr_stmt|;
name|line_ordinal
operator|=
name|occurs
operator|->
name|reference
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|file_index
operator|>
literal|0
condition|)
name|line_ordinal
operator|-=
name|file_line_count
index|[
name|file_index
operator|-
literal|1
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|reference
operator|.
name|start
argument_list|,
literal|"%s:%d"
argument_list|,
name|file_name
argument_list|,
name|line_ordinal
argument_list|)
expr_stmt|;
name|reference
operator|.
name|end
operator|=
name|reference
operator|.
name|start
operator|+
name|strlen
argument_list|(
name|reference
operator|.
name|start
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|input_reference
condition|)
block|{
comment|/* Reference starts at saved position for reference and extends right 	 until some white space is met.  */
name|reference
operator|.
name|start
operator|=
name|keyafter
operator|.
name|start
operator|+
operator|(
name|DELTA
operator|)
name|occurs
operator|->
name|reference
expr_stmt|;
name|reference
operator|.
name|end
operator|=
name|reference
operator|.
name|start
expr_stmt|;
name|SKIP_NON_WHITE
argument_list|(
name|reference
operator|.
name|end
argument_list|,
name|right_context_end
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Formatting and actual output - control routines.  */
end_comment

begin_comment
comment|/*----------------------------------------------------------------------. | Output the current output fields as one line for `troff' or `nroff'.  | `----------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|output_one_roff_line
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Output the `tail' field.  */
name|printf
argument_list|(
literal|".%s \""
argument_list|,
name|macro_name
argument_list|)
expr_stmt|;
name|print_field
argument_list|(
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail_truncation
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|truncation_string
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
comment|/* Output the `before' field.  */
name|printf
argument_list|(
literal|" \""
argument_list|)
expr_stmt|;
if|if
condition|(
name|before_truncation
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|truncation_string
argument_list|)
expr_stmt|;
name|print_field
argument_list|(
name|before
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
comment|/* Output the `keyafter' field.  */
name|printf
argument_list|(
literal|" \""
argument_list|)
expr_stmt|;
name|print_field
argument_list|(
name|keyafter
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyafter_truncation
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|truncation_string
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
comment|/* Output the `head' field.  */
name|printf
argument_list|(
literal|" \""
argument_list|)
expr_stmt|;
if|if
condition|(
name|head_truncation
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|truncation_string
argument_list|)
expr_stmt|;
name|print_field
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
comment|/* Conditionally output the `reference' field.  */
if|if
condition|(
name|auto_reference
operator|||
name|input_reference
condition|)
block|{
name|printf
argument_list|(
literal|" \""
argument_list|)
expr_stmt|;
name|print_field
argument_list|(
name|reference
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------. | Output the current output fields as one line for `TeX'.  | `---------------------------------------------------------*/
end_comment

begin_function
name|void
name|output_one_tex_line
parameter_list|(
name|void
parameter_list|)
block|{
name|BLOCK
name|key
decl_stmt|;
comment|/* key field, isolated */
name|BLOCK
name|after
decl_stmt|;
comment|/* after field, isolated */
name|char
modifier|*
name|cursor
decl_stmt|;
comment|/* running cursor in source text */
name|printf
argument_list|(
literal|"\\%s "
argument_list|,
name|macro_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|print_field
argument_list|(
name|tail
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}{"
argument_list|)
expr_stmt|;
name|print_field
argument_list|(
name|before
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}{"
argument_list|)
expr_stmt|;
name|key
operator|.
name|start
operator|=
name|keyafter
operator|.
name|start
expr_stmt|;
name|after
operator|.
name|end
operator|=
name|keyafter
operator|.
name|end
expr_stmt|;
name|cursor
operator|=
name|keyafter
operator|.
name|start
expr_stmt|;
name|SKIP_SOMETHING
argument_list|(
name|cursor
argument_list|,
name|keyafter
operator|.
name|end
argument_list|)
expr_stmt|;
name|key
operator|.
name|end
operator|=
name|cursor
expr_stmt|;
name|after
operator|.
name|start
operator|=
name|cursor
expr_stmt|;
name|print_field
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}{"
argument_list|)
expr_stmt|;
name|print_field
argument_list|(
name|after
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}{"
argument_list|)
expr_stmt|;
name|print_field
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
if|if
condition|(
name|auto_reference
operator|||
name|input_reference
condition|)
block|{
name|printf
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|print_field
argument_list|(
name|reference
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-------------------------------------------------------------------. | Output the current output fields as one line for a dumb terminal.  | `-------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|output_one_dumb_line
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|right_reference
condition|)
if|if
condition|(
name|auto_reference
condition|)
block|{
comment|/* Output the `reference' field, in such a way that GNU emacs            next-error will handle it.  The ending colon is taken from the            gap which follows.  */
name|print_field
argument_list|(
name|reference
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|print_spaces
argument_list|(
name|reference_max_width
operator|+
name|gap_size
operator|-
operator|(
name|reference
operator|.
name|end
operator|-
name|reference
operator|.
name|start
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Output the `reference' field and its following gap.  */
name|print_field
argument_list|(
name|reference
argument_list|)
expr_stmt|;
name|print_spaces
argument_list|(
name|reference_max_width
operator|+
name|gap_size
operator|-
operator|(
name|reference
operator|.
name|end
operator|-
name|reference
operator|.
name|start
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tail
operator|.
name|start
operator|<
name|tail
operator|.
name|end
condition|)
block|{
comment|/* Output the `tail' field.  */
name|print_field
argument_list|(
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail_truncation
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|truncation_string
argument_list|)
expr_stmt|;
name|print_spaces
argument_list|(
name|half_line_width
operator|-
name|gap_size
operator|-
operator|(
name|before
operator|.
name|end
operator|-
name|before
operator|.
name|start
operator|)
operator|-
operator|(
name|before_truncation
condition|?
name|truncation_string_length
else|:
literal|0
operator|)
operator|-
operator|(
name|tail
operator|.
name|end
operator|-
name|tail
operator|.
name|start
operator|)
operator|-
operator|(
name|tail_truncation
condition|?
name|truncation_string_length
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|print_spaces
argument_list|(
name|half_line_width
operator|-
name|gap_size
operator|-
operator|(
name|before
operator|.
name|end
operator|-
name|before
operator|.
name|start
operator|)
operator|-
operator|(
name|before_truncation
condition|?
name|truncation_string_length
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* Output the `before' field.  */
if|if
condition|(
name|before_truncation
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|truncation_string
argument_list|)
expr_stmt|;
name|print_field
argument_list|(
name|before
argument_list|)
expr_stmt|;
name|print_spaces
argument_list|(
name|gap_size
argument_list|)
expr_stmt|;
comment|/* Output the `keyafter' field.  */
name|print_field
argument_list|(
name|keyafter
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyafter_truncation
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|truncation_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|.
name|start
operator|<
name|head
operator|.
name|end
condition|)
block|{
comment|/* Output the `head' field.  */
name|print_spaces
argument_list|(
name|half_line_width
operator|-
operator|(
name|keyafter
operator|.
name|end
operator|-
name|keyafter
operator|.
name|start
operator|)
operator|-
operator|(
name|keyafter_truncation
condition|?
name|truncation_string_length
else|:
literal|0
operator|)
operator|-
operator|(
name|head
operator|.
name|end
operator|-
name|head
operator|.
name|start
operator|)
operator|-
operator|(
name|head_truncation
condition|?
name|truncation_string_length
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|head_truncation
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|truncation_string
argument_list|)
expr_stmt|;
name|print_field
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|auto_reference
operator|||
name|input_reference
operator|)
operator|&&
name|right_reference
condition|)
name|print_spaces
argument_list|(
name|half_line_width
operator|-
operator|(
name|keyafter
operator|.
name|end
operator|-
name|keyafter
operator|.
name|start
operator|)
operator|-
operator|(
name|keyafter_truncation
condition|?
name|truncation_string_length
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|auto_reference
operator|||
name|input_reference
operator|)
operator|&&
name|right_reference
condition|)
block|{
comment|/* Output the `reference' field.  */
name|print_spaces
argument_list|(
name|gap_size
argument_list|)
expr_stmt|;
name|print_field
argument_list|(
name|reference
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------. | Scan the whole occurs table and, for each entry, output one line in the | | appropriate format.							  | `------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|generate_all_output
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|occurs_index
decl_stmt|;
comment|/* index of keyword entry being processed */
name|OCCURS
modifier|*
name|occurs_cursor
decl_stmt|;
comment|/* current keyword entry being processed */
comment|/* The following assignments are useful to provide default values in case      line contexts or references are not used, in which case these variables      would never be computed.  */
name|tail
operator|.
name|start
operator|=
name|NULL
expr_stmt|;
name|tail
operator|.
name|end
operator|=
name|NULL
expr_stmt|;
name|tail_truncation
operator|=
literal|0
expr_stmt|;
name|head
operator|.
name|start
operator|=
name|NULL
expr_stmt|;
name|head
operator|.
name|end
operator|=
name|NULL
expr_stmt|;
name|head_truncation
operator|=
literal|0
expr_stmt|;
comment|/* Loop over all keyword occurrences.  */
name|occurs_cursor
operator|=
name|occurs_table
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|occurs_index
operator|=
literal|0
init|;
name|occurs_index
operator|<
name|number_of_occurs
index|[
literal|0
index|]
condition|;
name|occurs_index
operator|++
control|)
block|{
comment|/* Compute the exact size of every field and whenever truncation flags 	 are present or not.  */
name|define_all_fields
argument_list|(
name|occurs_cursor
argument_list|)
expr_stmt|;
comment|/* Produce one output line according to selected format.  */
switch|switch
condition|(
name|output_format
condition|)
block|{
case|case
name|UNKNOWN_FORMAT
case|:
comment|/* Should never happen.  */
case|case
name|DUMB_FORMAT
case|:
name|output_one_dumb_line
argument_list|()
expr_stmt|;
break|break;
case|case
name|ROFF_FORMAT
case|:
name|output_one_roff_line
argument_list|()
expr_stmt|;
break|break;
case|case
name|TEX_FORMAT
case|:
name|output_one_tex_line
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* Advance the cursor into the occurs table.  */
name|occurs_cursor
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Option decoding and main program.  */
end_comment

begin_comment
comment|/*------------------------------------------------------. | Print program identification and options, then exit.  | `------------------------------------------------------*/
end_comment

begin_function
name|void
name|usage
parameter_list|(
name|int
name|status
parameter_list|)
block|{
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Try `%s --help' for more information.\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"\ Usage: %s [OPTION]... [INPUT]...   (without -G)\n\   or:  %s -G [OPTION]... [INPUT [OUTPUT]]\n"
argument_list|,
name|program_name
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ \n\   -A, --auto-reference           output automatically generated references\n\   -C, --copyright                display Copyright and copying conditions\n\   -G, --traditional              behave more like System V `ptx'\n\   -F, --flag-truncation=STRING   use STRING for flagging line truncations\n\   -M, --macro-name=STRING        macro name to use instead of `xx'\n\   -O, --format=roff              generate output as roff directives\n\   -R, --right-side-refs          put references at right, not counted in -w\n\   -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\n\   -T, --format=tex               generate output as TeX directives\n\   -W, --word-regexp=REGEXP       use REGEXP to match each keyword\n\   -b, --break-file=FILE          word break characters in this FILE\n\   -f, --ignore-case              fold lower case to upper case for sorting\n\   -g, --gap-size=NUMBER          gap size in columns between output fields\n\   -i, --ignore-file=FILE         read ignore word list from FILE\n\   -o, --only-file=FILE           read only word list from this FILE\n\   -r, --references               first field of each line is a reference\n\   -t, --typeset-mode               - not implemented -\n\   -w, --width=NUMBER             output width in columns, reference excluded\n\       --help                     display this help and exit\n\       --version                  output version information and exit\n\ \n\ With no FILE or if FILE is -, read Standard Input.  `-F /' by default.\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------. | Main program.  Decode ARGC arguments passed through the ARGV array of | | strings, then launch execution.				        | `----------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* Long options equivalences.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"auto-reference"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'A'
block|}
block|,
block|{
literal|"break-file"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'b'
block|}
block|,
block|{
literal|"copyright"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'C'
block|}
block|,
block|{
literal|"flag-truncation"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'F'
block|}
block|,
block|{
literal|"ignore-case"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
block|{
literal|"gap-size"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'g'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
operator|&
name|show_help
block|,
literal|1
block|}
block|,
block|{
literal|"ignore-file"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'i'
block|}
block|,
block|{
literal|"macro-name"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'M'
block|}
block|,
block|{
literal|"only-file"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'o'
block|}
block|,
block|{
literal|"references"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'r'
block|}
block|,
block|{
literal|"right-side-refs"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'R'
block|}
block|,
block|{
literal|"format"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|10
block|}
block|,
block|{
literal|"sentence-regexp"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'S'
block|}
block|,
block|{
literal|"traditional"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'G'
block|}
block|,
block|{
literal|"typeset-mode"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'t'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
operator|&
name|show_version
block|,
literal|1
block|}
block|,
block|{
literal|"width"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'w'
block|}
block|,
block|{
literal|"word-regexp"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'W'
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|format_args
index|[]
init|=
block|{
literal|"roff"
block|,
literal|"tex"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|)
block|{
name|int
name|optchar
decl_stmt|;
comment|/* argument character */
specifier|extern
name|int
name|optind
decl_stmt|;
comment|/* index of argument */
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
comment|/* value or argument */
name|int
name|file_index
decl_stmt|;
comment|/* index in text input file arrays */
ifdef|#
directive|ifdef
name|HAVE_MCHECK
comment|/* Use GNU malloc checking.  It has proven to be useful!  */
name|mcheck
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_MCHECK */
ifdef|#
directive|ifdef
name|STDC_HEADERS
ifdef|#
directive|ifdef
name|HAVE_SETCHRCLASS
name|setchrclass
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* Decode program options.  */
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|optchar
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ACF:GM:ORS:TW:b:i:fg:o:trw:"
argument_list|,
name|long_options
argument_list|,
name|NULL
argument_list|)
operator|)
operator|,
name|optchar
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|optchar
condition|)
block|{
default|default:
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
break|break;
case|case
literal|'C'
case|:
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|copyright
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'G'
case|:
name|gnu_extensions
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|break_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|ignore_case
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|gap_size
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|ignore_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|only_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|input_reference
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* A decouvrir...  */
break|break;
case|case
literal|'w'
case|:
name|line_width
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|auto_reference
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|truncation_string
operator|=
name|copy_unescaped_string
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|macro_name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|output_format
operator|=
name|ROFF_FORMAT
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|right_reference
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|context_regex_string
operator|=
name|copy_unescaped_string
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|output_format
operator|=
name|TEX_FORMAT
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|word_regex_string
operator|=
name|copy_unescaped_string
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
switch|switch
condition|(
name|argmatch
argument_list|(
name|optarg
argument_list|,
name|format_args
argument_list|)
condition|)
block|{
default|default:
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
name|output_format
operator|=
name|ROFF_FORMAT
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|output_format
operator|=
name|TEX_FORMAT
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Process trivial options.  */
if|if
condition|(
name|show_help
condition|)
name|usage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_version
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Change the default Ignore file if one is defined.  */
ifdef|#
directive|ifdef
name|DEFAULT_IGNORE_FILE
if|if
condition|(
operator|!
name|ignore_file
condition|)
name|ignore_file
operator|=
name|DEFAULT_IGNORE_FILE
expr_stmt|;
endif|#
directive|endif
comment|/* Process remaining arguments.  If GNU extensions are enabled, process      all arguments as input parameters.  If disabled, accept at most two      arguments, the second of which is an output parameter.  */
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
comment|/* No more argument simply means: read standard input.  */
name|input_file_name
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|file_line_count
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|number_input_files
operator|=
literal|1
expr_stmt|;
name|input_file_name
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gnu_extensions
condition|)
block|{
name|number_input_files
operator|=
name|argc
operator|-
name|optind
expr_stmt|;
name|input_file_name
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|number_input_files
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|file_line_count
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|number_input_files
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|file_index
operator|=
literal|0
init|;
name|file_index
operator|<
name|number_input_files
condition|;
name|file_index
operator|++
control|)
block|{
name|input_file_name
index|[
name|file_index
index|]
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|argv
index|[
name|optind
index|]
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|input_file_name
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
else|else
name|input_file_name
index|[
literal|0
index|]
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
name|optind
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* There is one necessary input file.  */
name|number_input_files
operator|=
literal|1
expr_stmt|;
name|input_file_name
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|file_line_count
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|argv
index|[
name|optind
index|]
operator|||
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|input_file_name
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
else|else
name|input_file_name
index|[
literal|0
index|]
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
name|optind
operator|++
expr_stmt|;
comment|/* Redirect standard output, only if requested.  */
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fopen
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"w"
argument_list|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|optind
operator|++
expr_stmt|;
block|}
comment|/* Diagnose any other argument as an error.  */
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
name|usage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If the output format has not been explicitly selected, choose dumb      terminal format if GNU extensions are enabled, else `roff' format.  */
if|if
condition|(
name|output_format
operator|==
name|UNKNOWN_FORMAT
condition|)
name|output_format
operator|=
name|gnu_extensions
condition|?
name|DUMB_FORMAT
else|:
name|ROFF_FORMAT
expr_stmt|;
comment|/* Initialize the main tables.  */
name|initialize_regex
argument_list|()
expr_stmt|;
comment|/* Read `Break character' file, if any.  */
if|if
condition|(
name|break_file
condition|)
name|digest_break_file
argument_list|(
name|break_file
argument_list|)
expr_stmt|;
comment|/* Read `Ignore words' file and `Only words' files, if any.  If any of      these files is empty, reset the name of the file to NULL, to avoid      unnecessary calls to search_table. */
if|if
condition|(
name|ignore_file
condition|)
block|{
name|digest_word_file
argument_list|(
name|ignore_file
argument_list|,
operator|&
name|ignore_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignore_table
operator|.
name|length
operator|==
literal|0
condition|)
name|ignore_file
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|only_file
condition|)
block|{
name|digest_word_file
argument_list|(
name|only_file
argument_list|,
operator|&
name|only_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|only_table
operator|.
name|length
operator|==
literal|0
condition|)
name|only_file
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Prepare to study all the input files.  */
name|number_of_occurs
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|total_line_count
operator|=
literal|0
expr_stmt|;
name|maximum_word_length
operator|=
literal|0
expr_stmt|;
name|reference_max_width
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|file_index
operator|=
literal|0
init|;
name|file_index
operator|<
name|number_input_files
condition|;
name|file_index
operator|++
control|)
block|{
comment|/* Read the file in core, than study it.  */
name|swallow_file_in_memory
argument_list|(
name|input_file_name
index|[
name|file_index
index|]
argument_list|,
operator|&
name|text_buffer
argument_list|)
expr_stmt|;
name|find_occurs_in_text
argument_list|()
expr_stmt|;
comment|/* Maintain for each file how many lines has been read so far when its 	 end is reached.  Incrementing the count first is a simple kludge to 	 handle a possible incomplete line at end of file.  */
name|total_line_count
operator|++
expr_stmt|;
name|file_line_count
index|[
name|file_index
index|]
operator|=
name|total_line_count
expr_stmt|;
block|}
comment|/* Do the output process phase.  */
name|sort_found_occurs
argument_list|()
expr_stmt|;
name|fix_output_parameters
argument_list|()
expr_stmt|;
name|generate_all_output
argument_list|()
expr_stmt|;
comment|/* All done.  */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

