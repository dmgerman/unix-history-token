begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* grep.c - main driver file for grep.    Copyright 1992, 1997-1999, 2000 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* Written July 1992 by Mike Haertel.  */
end_comment

begin_comment
comment|/* Builtin decompression 1997 by Wolfram Schneider<wosch@FreeBSD.org>.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MMAP
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETRLIMIT
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|HAVE_WCTYPE_H
operator|&&
name|defined
name|HAVE_WCHAR_H
operator|&&
name|defined
name|HAVE_MBRTOWC
end_if

begin_comment
comment|/* We can handle multibyte string.  */
end_comment

begin_define
define|#
directive|define
name|MBS_SUPPORT
end_define

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<wctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"getpagesize.h"
end_include

begin_include
include|#
directive|include
file|"grep.h"
end_include

begin_include
include|#
directive|include
file|"savedir.h"
end_include

begin_include
include|#
directive|include
file|"xstrtol.h"
end_include

begin_include
include|#
directive|include
file|"xalloc.h"
end_include

begin_include
include|#
directive|include
file|"error.h"
end_include

begin_include
include|#
directive|include
file|"exclude.h"
end_include

begin_include
include|#
directive|include
file|"closeout.h"
end_include

begin_undef
undef|#
directive|undef
name|MAX
end_undef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)> (B) ? (A) : (B))
end_define

begin_struct
struct|struct
name|stats
block|{
name|struct
name|stats
specifier|const
modifier|*
name|parent
decl_stmt|;
name|struct
name|stat
name|stat
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* base of chain of stat buffers, used to detect directory loops */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|stats
name|stats_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if non-zero, display usage information and exit */
end_comment

begin_decl_stmt
specifier|static
name|int
name|show_help
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, print the version on standard output and exit.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|show_version
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, suppress diagnostics for nonexistent or unreadable files.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|suppress_errors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, use mmap if possible.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mmap_option
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If zero, output nulls after filenames.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|filename_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, use grep_color marker.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|color_option
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, show only the part of a line matching the expression. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|only_matching
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The color string used.  The user can overwrite it using the environment    variable GREP_COLOR.  The default is to print red.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|grep_color
init|=
literal|"01;31"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|exclude
modifier|*
name|excluded_patterns
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|exclude
modifier|*
name|included_patterns
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Short options.  */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
name|short_options
index|[]
init|=
literal|"0123456789A:B:C:D:EFGHIJPUVX:abcd:e:f:hiKLlm:noqRrsuvwxyZz"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-boolean long options that have no corresponding short equivalents.  */
end_comment

begin_enum
enum|enum
block|{
name|BINARY_FILES_OPTION
init|=
name|CHAR_MAX
operator|+
literal|1
block|,
name|COLOR_OPTION
block|,
name|INCLUDE_OPTION
block|,
name|EXCLUDE_OPTION
block|,
name|EXCLUDE_FROM_OPTION
block|,
name|LINE_BUFFERED_OPTION
block|,
name|LABEL_OPTION
block|}
enum|;
end_enum

begin_comment
comment|/* Long options equivalences. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|option
specifier|const
name|long_options
index|[]
init|=
block|{
block|{
literal|"after-context"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'A'
block|}
block|,
block|{
literal|"basic-regexp"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'G'
block|}
block|,
block|{
literal|"before-context"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'B'
block|}
block|,
block|{
literal|"binary-files"
block|,
name|required_argument
block|,
name|NULL
block|,
name|BINARY_FILES_OPTION
block|}
block|,
block|{
literal|"byte-offset"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'b'
block|}
block|,
block|{
literal|"context"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'C'
block|}
block|,
block|{
literal|"color"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|COLOR_OPTION
block|}
block|,
block|{
literal|"colour"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|COLOR_OPTION
block|}
block|,
block|{
literal|"count"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
block|{
literal|"devices"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'D'
block|}
block|,
block|{
literal|"directories"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"extended-regexp"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'E'
block|}
block|,
block|{
literal|"exclude"
block|,
name|required_argument
block|,
name|NULL
block|,
name|EXCLUDE_OPTION
block|}
block|,
block|{
literal|"exclude-from"
block|,
name|required_argument
block|,
name|NULL
block|,
name|EXCLUDE_FROM_OPTION
block|}
block|,
block|{
literal|"file"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
block|{
literal|"files-with-matches"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
block|{
literal|"files-without-match"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'L'
block|}
block|,
block|{
literal|"fixed-regexp"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'F'
block|}
block|,
block|{
literal|"fixed-strings"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'F'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
operator|&
name|show_help
block|,
literal|1
block|}
block|,
block|{
literal|"include"
block|,
name|required_argument
block|,
name|NULL
block|,
name|INCLUDE_OPTION
block|}
block|,
block|{
literal|"ignore-case"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'i'
block|}
block|,
block|{
literal|"label"
block|,
name|required_argument
block|,
name|NULL
block|,
name|LABEL_OPTION
block|}
block|,
block|{
literal|"line-buffered"
block|,
name|no_argument
block|,
name|NULL
block|,
name|LINE_BUFFERED_OPTION
block|}
block|,
block|{
literal|"line-number"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
block|{
literal|"line-regexp"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'x'
block|}
block|,
block|{
literal|"max-count"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'m'
block|}
block|,
block|{
literal|"mmap"
block|,
name|no_argument
block|,
operator|&
name|mmap_option
block|,
literal|1
block|}
block|,
block|{
literal|"no-filename"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"no-messages"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"bz2decompress"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'J'
block|}
block|,
if|#
directive|if
name|HAVE_LIBZ
operator|>
literal|0
block|{
literal|"decompress"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'Z'
block|}
block|,
block|{
literal|"null"
block|,
name|no_argument
block|,
operator|&
name|filename_mask
block|,
literal|0
block|}
block|,
else|#
directive|else
block|{
literal|"null"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'Z'
block|}
block|,
endif|#
directive|endif
block|{
literal|"null-data"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'z'
block|}
block|,
block|{
literal|"only-matching"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'o'
block|}
block|,
block|{
literal|"perl-regexp"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'P'
block|}
block|,
block|{
literal|"quiet"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'q'
block|}
block|,
block|{
literal|"recursive"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'r'
block|}
block|,
block|{
literal|"recursive"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'R'
block|}
block|,
block|{
literal|"regexp"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'e'
block|}
block|,
block|{
literal|"invert-match"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
literal|"silent"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'q'
block|}
block|,
block|{
literal|"text"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'a'
block|}
block|,
block|{
literal|"binary"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'U'
block|}
block|,
block|{
literal|"unix-byte-offsets"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'u'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
literal|"with-filename"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'H'
block|}
block|,
block|{
literal|"word-regexp"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'w'
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define flags declared in grep.h. */
end_comment

begin_decl_stmt
name|int
name|match_icase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|match_words
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|match_lines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|eolbyte
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For error messages. */
end_comment

begin_comment
comment|/* The name the program was run with, stripped of any leading path. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|errseen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to handle directories.  */
end_comment

begin_enum
specifier|static
enum|enum
block|{
name|READ_DIRECTORIES
block|,
name|RECURSE_DIRECTORIES
block|,
name|SKIP_DIRECTORIES
block|}
name|directories
init|=
name|READ_DIRECTORIES
enum|;
end_enum

begin_comment
comment|/* How to handle devices. */
end_comment

begin_enum
specifier|static
enum|enum
block|{
name|READ_DEVICES
block|,
name|SKIP_DEVICES
block|}
name|devices
init|=
name|READ_DEVICES
enum|;
end_enum

begin_decl_stmt
specifier|static
name|int
name|grepdir
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
expr|struct
name|stats
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_DOS_FILE_CONTENTS
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|undossify_input
name|PARAMS
argument_list|(
operator|(
specifier|register
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Functions we'll use to search. */
end_comment

begin_expr_stmt
specifier|static
name|void
argument_list|(
argument|*compile
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|size_t
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|size_t
argument_list|(
argument|*execute
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|size_t
operator|,
name|size_t
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Like error, but suppress the diagnostic if requested.  */
end_comment

begin_function
specifier|static
name|void
name|suppressible_error
parameter_list|(
name|char
specifier|const
modifier|*
name|mesg
parameter_list|,
name|int
name|errnum
parameter_list|)
block|{
if|if
condition|(
operator|!
name|suppress_errors
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errnum
argument_list|,
literal|"%s"
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
name|errseen
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert STR to a positive integer, storing the result in *OUT.    STR must be a valid context length argument; report an error if it    isn't.  */
end_comment

begin_function
specifier|static
name|void
name|context_length_arg
parameter_list|(
name|char
specifier|const
modifier|*
name|str
parameter_list|,
name|int
modifier|*
name|out
parameter_list|)
block|{
name|uintmax_t
name|value
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|xstrtoumax
argument_list|(
name|str
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
operator|&
name|value
argument_list|,
literal|""
argument_list|)
operator|==
name|LONGINT_OK
operator|&&
literal|0
operator|<=
operator|(
operator|*
name|out
operator|=
name|value
operator|)
operator|&&
operator|*
name|out
operator|==
name|value
operator|)
condition|)
block|{
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|str
argument_list|,
name|_
argument_list|(
literal|"invalid context length argument"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Hairy buffering mechanism for grep.  The intent is to keep    all reads aligned on a page boundary and multiples of the    page size, unless a read yields a partial page.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Base of buffer. */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|bufalloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocated buffer size, counting slop. */
end_comment

begin_define
define|#
directive|define
name|INITIAL_BUFSIZE
value|32768
end_define

begin_comment
comment|/* Initial buffer size, not counting slop. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bufdesc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File descriptor. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bufbeg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Beginning of user-visible stuff. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buflim
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Limit of user-visible stuff. */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|pagesize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* alignment of memory pages */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|bufoffset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read offset; defined on regular files.  */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|after_last_match
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer after last matching line that 				   would have been output if we were 				   outputting characters. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MMAP
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|bufmapped
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if buffer is memory-mapped.  */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|initial_bufoffset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initial value of bufoffset. */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|bufmapped
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<bzlib.h>
end_include

begin_decl_stmt
specifier|static
name|BZFILE
modifier|*
name|bzbufdesc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* libbz2 file handle. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|BZflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* uncompress before searching. */
end_comment

begin_if
if|#
directive|if
name|HAVE_LIBZ
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_decl_stmt
specifier|static
name|gzFile
name|gzbufdesc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* zlib file descriptor. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Zflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* uncompress before searching. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return VAL aligned to the next multiple of ALIGNMENT.  VAL can be    an integer or a pointer.  Both args must be free of side effects.  */
end_comment

begin_define
define|#
directive|define
name|ALIGN_TO
parameter_list|(
name|val
parameter_list|,
name|alignment
parameter_list|)
define|\
value|((size_t) (val) % (alignment) == 0 \    ? (val) \    : (val) + ((alignment) - (size_t) (val) % (alignment)))
end_define

begin_comment
comment|/* Reset the buffer for a new file, returning zero if we should skip it.    Initialize on the first time through. */
end_comment

begin_function
specifier|static
name|int
name|reset
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
specifier|const
modifier|*
name|file
parameter_list|,
name|struct
name|stats
modifier|*
name|stats
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pagesize
condition|)
block|{
name|pagesize
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
if|if
condition|(
name|pagesize
operator|==
literal|0
operator|||
literal|2
operator|*
name|pagesize
operator|+
literal|1
operator|<=
name|pagesize
condition|)
name|abort
argument_list|()
expr_stmt|;
name|bufalloc
operator|=
name|ALIGN_TO
argument_list|(
name|INITIAL_BUFSIZE
argument_list|,
name|pagesize
argument_list|)
operator|+
name|pagesize
operator|+
literal|1
expr_stmt|;
name|buffer
operator|=
name|xmalloc
argument_list|(
name|bufalloc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BZflag
condition|)
block|{
name|bzbufdesc
operator|=
name|BZ2_bzdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bzbufdesc
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|HAVE_LIBZ
operator|>
literal|0
if|if
condition|(
name|Zflag
condition|)
block|{
name|gzbufdesc
operator|=
name|gzdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gzbufdesc
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|bufbeg
operator|=
name|buflim
operator|=
name|ALIGN_TO
argument_list|(
name|buffer
operator|+
literal|1
argument_list|,
name|pagesize
argument_list|)
expr_stmt|;
name|bufbeg
index|[
operator|-
literal|1
index|]
operator|=
name|eolbyte
expr_stmt|;
name|bufdesc
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|stats
operator|->
name|stat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"fstat"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|directories
operator|==
name|SKIP_DIRECTORIES
operator|&&
name|S_ISDIR
argument_list|(
name|stats
operator|->
name|stat
operator|.
name|st_mode
argument_list|)
condition|)
return|return
literal|0
return|;
ifndef|#
directive|ifndef
name|DJGPP
if|if
condition|(
name|devices
operator|==
name|SKIP_DEVICES
operator|&&
operator|(
name|S_ISCHR
argument_list|(
name|stats
operator|->
name|stat
operator|.
name|st_mode
argument_list|)
operator|||
name|S_ISBLK
argument_list|(
name|stats
operator|->
name|stat
operator|.
name|st_mode
argument_list|)
operator|||
name|S_ISSOCK
argument_list|(
name|stats
operator|->
name|stat
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|devices
operator|==
name|SKIP_DEVICES
operator|&&
operator|(
name|S_ISCHR
argument_list|(
name|stats
operator|->
name|stat
operator|.
name|st_mode
argument_list|)
operator|||
name|S_ISBLK
argument_list|(
name|stats
operator|->
name|stat
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
endif|#
directive|endif
return|return
literal|0
return|;
if|if
condition|(
name|BZflag
operator|||
if|#
directive|if
name|HAVE_LIBZ
operator|>
literal|0
name|Zflag
operator|||
endif|#
directive|endif
name|S_ISREG
argument_list|(
name|stats
operator|->
name|stat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|file
condition|)
name|bufoffset
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|bufoffset
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufoffset
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"lseek"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MMAP
argument_list|)
name|initial_bufoffset
operator|=
name|bufoffset
expr_stmt|;
name|bufmapped
operator|=
name|mmap_option
operator|&&
name|bufoffset
operator|%
name|pagesize
operator|==
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MMAP
argument_list|)
name|bufmapped
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Read new stuff into the buffer, saving the specified    amount of old stuff.  When we're done, 'bufbeg' points    to the beginning of the buffer contents, and 'buflim'    points just after the end.  Return zero if there's an error.  */
end_comment

begin_function
specifier|static
name|int
name|fillbuf
parameter_list|(
name|size_t
name|save
parameter_list|,
name|struct
name|stats
specifier|const
modifier|*
name|stats
parameter_list|)
block|{
name|size_t
name|fillsize
init|=
literal|0
decl_stmt|;
name|int
name|cc
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|readbuf
decl_stmt|;
name|size_t
name|readsize
decl_stmt|;
comment|/* Offset from start of buffer to start of old stuff      that we want to save.  */
name|size_t
name|saved_offset
init|=
name|buflim
operator|-
name|save
operator|-
name|buffer
decl_stmt|;
if|if
condition|(
name|pagesize
operator|<=
name|buffer
operator|+
name|bufalloc
operator|-
name|buflim
condition|)
block|{
name|readbuf
operator|=
name|buflim
expr_stmt|;
name|bufbeg
operator|=
name|buflim
operator|-
name|save
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|minsize
init|=
name|save
operator|+
name|pagesize
decl_stmt|;
name|size_t
name|newsize
decl_stmt|;
name|size_t
name|newalloc
decl_stmt|;
name|char
modifier|*
name|newbuf
decl_stmt|;
comment|/* Grow newsize until it is at least as great as minsize.  */
for|for
control|(
name|newsize
operator|=
name|bufalloc
operator|-
name|pagesize
operator|-
literal|1
init|;
name|newsize
operator|<
name|minsize
condition|;
name|newsize
operator|*=
literal|2
control|)
if|if
condition|(
name|newsize
operator|*
literal|2
operator|<
name|newsize
operator|||
name|newsize
operator|*
literal|2
operator|+
name|pagesize
operator|+
literal|1
operator|<
name|newsize
operator|*
literal|2
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
comment|/* Try not to allocate more memory than the file size indicates, 	 as that might cause unnecessary memory exhaustion if the file 	 is large.  However, do not use the original file size as a 	 heuristic if we've already read past the file end, as most 	 likely the file is growing.  */
if|if
condition|(
name|S_ISREG
argument_list|(
name|stats
operator|->
name|stat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|off_t
name|to_be_read
init|=
name|stats
operator|->
name|stat
operator|.
name|st_size
operator|-
name|bufoffset
decl_stmt|;
name|off_t
name|maxsize_off
init|=
name|save
operator|+
name|to_be_read
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|to_be_read
operator|&&
name|to_be_read
operator|<=
name|maxsize_off
operator|&&
name|maxsize_off
operator|==
operator|(
name|size_t
operator|)
name|maxsize_off
operator|&&
name|minsize
operator|<=
operator|(
name|size_t
operator|)
name|maxsize_off
operator|&&
operator|(
name|size_t
operator|)
name|maxsize_off
operator|<
name|newsize
condition|)
name|newsize
operator|=
name|maxsize_off
expr_stmt|;
block|}
comment|/* Add enough room so that the buffer is aligned and has room 	 for byte sentinels fore and aft.  */
name|newalloc
operator|=
name|newsize
operator|+
name|pagesize
operator|+
literal|1
expr_stmt|;
name|newbuf
operator|=
name|bufalloc
operator|<
name|newalloc
condition|?
name|xmalloc
argument_list|(
name|bufalloc
operator|=
name|newalloc
argument_list|)
else|:
name|buffer
expr_stmt|;
name|readbuf
operator|=
name|ALIGN_TO
argument_list|(
name|newbuf
operator|+
literal|1
operator|+
name|save
argument_list|,
name|pagesize
argument_list|)
expr_stmt|;
name|bufbeg
operator|=
name|readbuf
operator|-
name|save
expr_stmt|;
name|memmove
argument_list|(
name|bufbeg
argument_list|,
name|buffer
operator|+
name|saved_offset
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|bufbeg
index|[
operator|-
literal|1
index|]
operator|=
name|eolbyte
expr_stmt|;
if|if
condition|(
name|newbuf
operator|!=
name|buffer
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|newbuf
expr_stmt|;
block|}
block|}
name|readsize
operator|=
name|buffer
operator|+
name|bufalloc
operator|-
name|readbuf
expr_stmt|;
name|readsize
operator|-=
name|readsize
operator|%
name|pagesize
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MMAP
argument_list|)
if|if
condition|(
name|bufmapped
condition|)
block|{
name|size_t
name|mmapsize
init|=
name|readsize
decl_stmt|;
comment|/* Don't mmap past the end of the file; some hosts don't allow this. 	 Use `read' on the last page.  */
if|if
condition|(
name|stats
operator|->
name|stat
operator|.
name|st_size
operator|-
name|bufoffset
operator|<
name|mmapsize
condition|)
block|{
name|mmapsize
operator|=
name|stats
operator|->
name|stat
operator|.
name|st_size
operator|-
name|bufoffset
expr_stmt|;
name|mmapsize
operator|-=
name|mmapsize
operator|%
name|pagesize
expr_stmt|;
block|}
if|if
condition|(
name|mmapsize
operator|&&
operator|(
name|mmap
argument_list|(
operator|(
name|caddr_t
operator|)
name|readbuf
argument_list|,
name|mmapsize
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_FIXED
argument_list|,
name|bufdesc
argument_list|,
name|bufoffset
argument_list|)
operator|!=
operator|(
name|caddr_t
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* Do not bother to use madvise with MADV_SEQUENTIAL or 	     MADV_WILLNEED on the mmapped memory.  One might think it 	     would help, but it slows us down about 30% on SunOS 4.1.  */
name|fillsize
operator|=
name|mmapsize
expr_stmt|;
block|}
else|else
block|{
comment|/* Stop using mmap on this file.  Synchronize the file 	     offset.  Do not warn about mmap failures.  On some hosts 	     (e.g. Solaris 2.5) mmap can fail merely because some 	     other process has an advisory read lock on the file. 	     There's no point alarming the user about this misfeature.  */
name|bufmapped
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bufoffset
operator|!=
name|initial_bufoffset
operator|&&
name|lseek
argument_list|(
name|bufdesc
argument_list|,
name|bufoffset
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"lseek"
argument_list|)
expr_stmt|;
name|cc
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/*HAVE_MMAP*/
if|if
condition|(
operator|!
name|fillsize
condition|)
block|{
name|ssize_t
name|bytesread
decl_stmt|;
do|do
if|if
condition|(
name|BZflag
operator|&&
name|bzbufdesc
condition|)
block|{
name|int
name|bzerr
decl_stmt|;
name|bytesread
operator|=
name|BZ2_bzRead
argument_list|(
operator|&
name|bzerr
argument_list|,
name|bzbufdesc
argument_list|,
name|readbuf
argument_list|,
name|readsize
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bzerr
condition|)
block|{
case|case
name|BZ_OK
case|:
case|case
name|BZ_STREAM_END
case|:
comment|/* ok */
break|break;
case|case
name|BZ_DATA_ERROR_MAGIC
case|:
name|BZ2_bzReadClose
argument_list|(
operator|&
name|bzerr
argument_list|,
name|bzbufdesc
argument_list|)
expr_stmt|;
name|bzbufdesc
operator|=
name|NULL
expr_stmt|;
name|lseek
argument_list|(
name|bufdesc
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bytesread
operator|=
name|read
argument_list|(
name|bufdesc
argument_list|,
name|readbuf
argument_list|,
name|readsize
argument_list|)
expr_stmt|;
break|break;
default|default:
name|bytesread
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|#
directive|if
name|HAVE_LIBZ
operator|>
literal|0
if|if
condition|(
name|Zflag
condition|)
name|bytesread
operator|=
name|gzread
argument_list|(
name|gzbufdesc
argument_list|,
name|readbuf
argument_list|,
name|readsize
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|bytesread
operator|=
name|read
argument_list|(
name|bufdesc
argument_list|,
name|readbuf
argument_list|,
name|readsize
argument_list|)
expr_stmt|;
do|while
condition|(
name|bytesread
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|bytesread
operator|<
literal|0
condition|)
name|cc
operator|=
literal|0
expr_stmt|;
else|else
name|fillsize
operator|=
name|bytesread
expr_stmt|;
block|}
name|bufoffset
operator|+=
name|fillsize
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_DOS_FILE_CONTENTS
argument_list|)
if|if
condition|(
name|fillsize
condition|)
name|fillsize
operator|=
name|undossify_input
argument_list|(
name|readbuf
argument_list|,
name|fillsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buflim
operator|=
name|readbuf
operator|+
name|fillsize
expr_stmt|;
return|return
name|cc
return|;
block|}
end_function

begin_comment
comment|/* Flags controlling the style of output. */
end_comment

begin_enum
specifier|static
enum|enum
block|{
name|BINARY_BINARY_FILES
block|,
name|TEXT_BINARY_FILES
block|,
name|WITHOUT_MATCH_BINARY_FILES
block|}
name|binary_files
enum|;
end_enum

begin_comment
comment|/* How to handle binary files.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|filename_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If zero, output nulls after filenames.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|out_quiet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Suppress all normal output. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|out_invert
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print nonmatching stuff. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|out_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print filenames. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|out_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print line numbers. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|out_byte
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print byte offsets. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|out_before
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lines of leading context. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|out_after
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lines of trailing context. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|count_matches
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count matching lines.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|list_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List matching files.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_filenames
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Suppress file names.  */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|max_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stop after outputting this many 				   lines from an input file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|line_buffered
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, use line buffering, i.e. 				   fflush everyline out.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|label
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fake filename for stdin */
end_comment

begin_comment
comment|/* Internal variables to keep track of byte count, context, etc. */
end_comment

begin_decl_stmt
specifier|static
name|uintmax_t
name|totalcc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total character count before bufbeg. */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|lastnl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer after last newline counted. */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|lastout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer after last character output; 				   NULL if no character has been output 				   or if it's conceptually before bufbeg. */
end_comment

begin_decl_stmt
specifier|static
name|uintmax_t
name|totalnl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total newline count before lastnl. */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|outleft
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of lines to be output.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pending lines of output. 				   Always kept 0 if out_quiet is true.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|done_on_match
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stop scanning file on first match.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exit_on_match
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Exit on first match.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_DOS_FILE_CONTENTS
argument_list|)
end_if

begin_include
include|#
directive|include
file|"dosbuf.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Add two numbers that count input bytes or lines, and report an    error if the addition overflows.  */
end_comment

begin_function
specifier|static
name|uintmax_t
name|add_count
parameter_list|(
name|uintmax_t
name|a
parameter_list|,
name|uintmax_t
name|b
parameter_list|)
block|{
name|uintmax_t
name|sum
init|=
name|a
operator|+
name|b
decl_stmt|;
if|if
condition|(
name|sum
operator|<
name|a
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"input is too large to count"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sum
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nlscan
parameter_list|(
name|char
specifier|const
modifier|*
name|lim
parameter_list|)
block|{
name|size_t
name|newlines
init|=
literal|0
decl_stmt|;
name|char
specifier|const
modifier|*
name|beg
decl_stmt|;
for|for
control|(
name|beg
operator|=
name|lastnl
init|;
name|beg
operator|!=
name|lim
condition|;
name|beg
operator|=
name|memchr
argument_list|(
name|beg
argument_list|,
name|eolbyte
argument_list|,
name|lim
operator|-
name|beg
argument_list|)
operator|,
name|beg
operator|++
control|)
name|newlines
operator|++
expr_stmt|;
name|totalnl
operator|=
name|add_count
argument_list|(
name|totalnl
argument_list|,
name|newlines
argument_list|)
expr_stmt|;
name|lastnl
operator|=
name|lim
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a byte offset, followed by a character separator.  */
end_comment

begin_function
specifier|static
name|void
name|print_offset_sep
parameter_list|(
name|uintmax_t
name|pos
parameter_list|,
name|char
name|sep
parameter_list|)
block|{
comment|/* Do not rely on printf to print pos, since uintmax_t may be longer      than long, and long long is not portable.  */
name|char
name|buf
index|[
sizeof|sizeof
name|pos
operator|*
name|CHAR_BIT
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
operator|+
sizeof|sizeof
name|buf
operator|-
literal|1
decl_stmt|;
operator|*
name|p
operator|=
name|sep
expr_stmt|;
do|do
operator|*
operator|--
name|p
operator|=
literal|'0'
operator|+
name|pos
operator|%
literal|10
expr_stmt|;
do|while
condition|(
operator|(
name|pos
operator|/=
literal|10
operator|)
operator|!=
literal|0
condition|)
do|;
name|fwrite
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|buf
operator|+
sizeof|sizeof
name|buf
operator|-
name|p
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|prline
parameter_list|(
name|char
specifier|const
modifier|*
name|beg
parameter_list|,
name|char
specifier|const
modifier|*
name|lim
parameter_list|,
name|int
name|sep
parameter_list|)
block|{
if|if
condition|(
name|out_file
condition|)
name|printf
argument_list|(
literal|"%s%c"
argument_list|,
name|filename
argument_list|,
name|sep
operator|&
name|filename_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_line
condition|)
block|{
name|nlscan
argument_list|(
name|beg
argument_list|)
expr_stmt|;
name|totalnl
operator|=
name|add_count
argument_list|(
name|totalnl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|print_offset_sep
argument_list|(
name|totalnl
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|lastnl
operator|=
name|lim
expr_stmt|;
block|}
if|if
condition|(
name|out_byte
condition|)
block|{
name|uintmax_t
name|pos
init|=
name|add_count
argument_list|(
name|totalcc
argument_list|,
name|beg
operator|-
name|bufbeg
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_DOS_FILE_CONTENTS
argument_list|)
name|pos
operator|=
name|dossified_pos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|print_offset_sep
argument_list|(
name|pos
argument_list|,
name|sep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|only_matching
condition|)
block|{
name|size_t
name|match_size
decl_stmt|;
name|size_t
name|match_offset
decl_stmt|;
while|while
condition|(
operator|(
name|match_offset
operator|=
call|(
modifier|*
name|execute
call|)
argument_list|(
name|beg
argument_list|,
name|lim
operator|-
name|beg
argument_list|,
operator|&
name|match_size
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
block|{
name|char
specifier|const
modifier|*
name|b
init|=
name|beg
operator|+
name|match_offset
decl_stmt|;
if|if
condition|(
name|b
operator|==
name|lim
condition|)
break|break;
if|if
condition|(
name|match_size
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|color_option
condition|)
name|printf
argument_list|(
literal|"\33[%sm"
argument_list|,
name|grep_color
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|match_size
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|color_option
condition|)
name|fputs
argument_list|(
literal|"\33[00m"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|beg
operator|=
name|b
operator|+
name|match_size
expr_stmt|;
block|}
name|lastout
operator|=
name|lim
expr_stmt|;
if|if
condition|(
name|line_buffered
condition|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|color_option
condition|)
block|{
name|size_t
name|match_size
decl_stmt|;
name|size_t
name|match_offset
decl_stmt|;
while|while
condition|(
name|lim
operator|-
name|beg
operator|&&
operator|(
name|match_offset
operator|=
call|(
modifier|*
name|execute
call|)
argument_list|(
name|beg
argument_list|,
name|lim
operator|-
name|beg
argument_list|,
operator|&
name|match_size
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
block|{
name|char
specifier|const
modifier|*
name|b
init|=
name|beg
operator|+
name|match_offset
decl_stmt|;
comment|/* Avoid matching the empty line at the end of the buffer. */
if|if
condition|(
name|b
operator|==
name|lim
condition|)
break|break;
comment|/* Avoid hanging on grep --color "" foo */
if|if
condition|(
name|match_size
operator|==
literal|0
condition|)
break|break;
name|fwrite
argument_list|(
name|beg
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|match_offset
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\33[%sm"
argument_list|,
name|grep_color
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|match_size
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\33[00m"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|beg
operator|=
name|b
operator|+
name|match_size
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"\33[K"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|fwrite
argument_list|(
name|beg
argument_list|,
literal|1
argument_list|,
name|lim
operator|-
name|beg
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"writing output"
argument_list|)
argument_list|)
expr_stmt|;
name|lastout
operator|=
name|lim
expr_stmt|;
if|if
condition|(
name|line_buffered
condition|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print pending lines of trailing context prior to LIM. Trailing context ends    at the next matching line when OUTLEFT is 0.  */
end_comment

begin_function
specifier|static
name|void
name|prpending
parameter_list|(
name|char
specifier|const
modifier|*
name|lim
parameter_list|)
block|{
if|if
condition|(
operator|!
name|lastout
condition|)
name|lastout
operator|=
name|bufbeg
expr_stmt|;
while|while
condition|(
name|pending
operator|>
literal|0
operator|&&
name|lastout
operator|<
name|lim
condition|)
block|{
name|char
specifier|const
modifier|*
name|nl
init|=
name|memchr
argument_list|(
name|lastout
argument_list|,
name|eolbyte
argument_list|,
name|lim
operator|-
name|lastout
argument_list|)
decl_stmt|;
name|size_t
name|match_size
decl_stmt|;
operator|--
name|pending
expr_stmt|;
if|if
condition|(
name|outleft
operator|||
operator|(
operator|(
call|(
modifier|*
name|execute
call|)
argument_list|(
name|lastout
argument_list|,
name|nl
operator|-
name|lastout
argument_list|,
operator|&
name|match_size
argument_list|,
literal|0
argument_list|)
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|)
operator|==
operator|!
name|out_invert
operator|)
condition|)
name|prline
argument_list|(
name|lastout
argument_list|,
name|nl
operator|+
literal|1
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
else|else
name|pending
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the lines between BEG and LIM.  Deal with context crap.    If NLINESP is non-null, store a count of lines between BEG and LIM.  */
end_comment

begin_function
specifier|static
name|void
name|prtext
parameter_list|(
name|char
specifier|const
modifier|*
name|beg
parameter_list|,
name|char
specifier|const
modifier|*
name|lim
parameter_list|,
name|int
modifier|*
name|nlinesp
parameter_list|)
block|{
specifier|static
name|int
name|used
decl_stmt|;
comment|/* avoid printing "--" before any output */
name|char
specifier|const
modifier|*
name|bp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
name|eol
init|=
name|eolbyte
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|out_quiet
operator|&&
name|pending
operator|>
literal|0
condition|)
name|prpending
argument_list|(
name|beg
argument_list|)
expr_stmt|;
name|p
operator|=
name|beg
expr_stmt|;
if|if
condition|(
operator|!
name|out_quiet
condition|)
block|{
comment|/* Deal with leading context crap. */
name|bp
operator|=
name|lastout
condition|?
name|lastout
else|:
name|bufbeg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|out_before
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|p
operator|>
name|bp
condition|)
do|do
operator|--
name|p
expr_stmt|;
do|while
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|!=
name|eol
condition|)
do|;
comment|/* We only print the "--" separator if our output is 	 discontiguous from the last output in the file. */
if|if
condition|(
operator|(
name|out_before
operator|||
name|out_after
operator|)
operator|&&
name|used
operator|&&
name|p
operator|!=
name|lastout
condition|)
name|puts
argument_list|(
literal|"--"
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|beg
condition|)
block|{
name|char
specifier|const
modifier|*
name|nl
init|=
name|memchr
argument_list|(
name|p
argument_list|,
name|eol
argument_list|,
name|beg
operator|-
name|p
argument_list|)
decl_stmt|;
name|nl
operator|++
expr_stmt|;
name|prline
argument_list|(
name|p
argument_list|,
name|nl
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
name|p
operator|=
name|nl
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nlinesp
condition|)
block|{
comment|/* Caller wants a line count. */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|p
operator|<
name|lim
operator|&&
name|n
operator|<
name|outleft
condition|;
name|n
operator|++
control|)
block|{
name|char
specifier|const
modifier|*
name|nl
init|=
name|memchr
argument_list|(
name|p
argument_list|,
name|eol
argument_list|,
name|lim
operator|-
name|p
argument_list|)
decl_stmt|;
name|nl
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|out_quiet
condition|)
name|prline
argument_list|(
name|p
argument_list|,
name|nl
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|p
operator|=
name|nl
expr_stmt|;
block|}
operator|*
name|nlinesp
operator|=
name|n
expr_stmt|;
comment|/* relying on it that this function is never called when outleft = 0.  */
name|after_last_match
operator|=
name|bufoffset
operator|-
operator|(
name|buflim
operator|-
name|p
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|out_quiet
condition|)
name|prline
argument_list|(
name|beg
argument_list|,
name|lim
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|pending
operator|=
name|out_quiet
condition|?
literal|0
else|:
name|out_after
expr_stmt|;
name|used
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan the specified portion of the buffer, matching lines (or    between matching lines if OUT_INVERT is true).  Return a count of    lines printed. */
end_comment

begin_function
specifier|static
name|int
name|grepbuf
parameter_list|(
name|char
specifier|const
modifier|*
name|beg
parameter_list|,
name|char
specifier|const
modifier|*
name|lim
parameter_list|)
block|{
name|int
name|nlines
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
name|size_t
name|match_offset
decl_stmt|;
name|size_t
name|match_size
decl_stmt|;
name|nlines
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|beg
expr_stmt|;
while|while
condition|(
operator|(
name|match_offset
operator|=
call|(
modifier|*
name|execute
call|)
argument_list|(
name|p
argument_list|,
name|lim
operator|-
name|p
argument_list|,
operator|&
name|match_size
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
block|{
name|char
specifier|const
modifier|*
name|b
init|=
name|p
operator|+
name|match_offset
decl_stmt|;
name|char
specifier|const
modifier|*
name|endp
init|=
name|b
operator|+
name|match_size
decl_stmt|;
comment|/* Avoid matching the empty line at the end of the buffer. */
if|if
condition|(
name|b
operator|==
name|lim
condition|)
break|break;
if|if
condition|(
operator|!
name|out_invert
condition|)
block|{
name|prtext
argument_list|(
name|b
argument_list|,
name|endp
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|nlines
operator|++
expr_stmt|;
name|outleft
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|outleft
operator|||
name|done_on_match
condition|)
block|{
if|if
condition|(
name|exit_on_match
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|after_last_match
operator|=
name|bufoffset
operator|-
operator|(
name|buflim
operator|-
name|endp
operator|)
expr_stmt|;
return|return
name|nlines
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|<
name|b
condition|)
block|{
name|prtext
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|nlines
operator|+=
name|n
expr_stmt|;
name|outleft
operator|-=
name|n
expr_stmt|;
if|if
condition|(
operator|!
name|outleft
condition|)
return|return
name|nlines
return|;
block|}
name|p
operator|=
name|endp
expr_stmt|;
block|}
if|if
condition|(
name|out_invert
operator|&&
name|p
operator|<
name|lim
condition|)
block|{
name|prtext
argument_list|(
name|p
argument_list|,
name|lim
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|nlines
operator|+=
name|n
expr_stmt|;
name|outleft
operator|-=
name|n
expr_stmt|;
block|}
return|return
name|nlines
return|;
block|}
end_function

begin_comment
comment|/* Search a given file.  Normally, return a count of lines printed;    but if the file is a directory and we search it recursively, then    return -2 if there was a match, and -1 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|grep
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
specifier|const
modifier|*
name|file
parameter_list|,
name|struct
name|stats
modifier|*
name|stats
parameter_list|)
block|{
name|int
name|nlines
decl_stmt|,
name|i
decl_stmt|;
name|int
name|not_text
decl_stmt|;
name|size_t
name|residue
decl_stmt|,
name|save
decl_stmt|;
name|char
name|oldc
decl_stmt|;
name|char
modifier|*
name|beg
decl_stmt|;
name|char
modifier|*
name|lim
decl_stmt|;
name|char
name|eol
init|=
name|eolbyte
decl_stmt|;
if|if
condition|(
operator|!
name|reset
argument_list|(
name|fd
argument_list|,
name|file
argument_list|,
name|stats
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|file
operator|&&
name|directories
operator|==
name|RECURSE_DIRECTORIES
operator|&&
name|S_ISDIR
argument_list|(
name|stats
operator|->
name|stat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* Close fd now, so that we don't open a lot of file descriptors 	 when we recurse deeply.  */
if|if
condition|(
name|BZflag
operator|&&
name|bzbufdesc
condition|)
name|BZ2_bzclose
argument_list|(
name|bzbufdesc
argument_list|)
expr_stmt|;
elseif|else
if|#
directive|if
name|HAVE_LIBZ
operator|>
literal|0
if|if
condition|(
name|Zflag
condition|)
name|gzclose
argument_list|(
name|gzbufdesc
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
name|grepdir
argument_list|(
name|file
argument_list|,
name|stats
argument_list|)
operator|-
literal|2
return|;
block|}
name|totalcc
operator|=
literal|0
expr_stmt|;
name|lastout
operator|=
literal|0
expr_stmt|;
name|totalnl
operator|=
literal|0
expr_stmt|;
name|outleft
operator|=
name|max_count
expr_stmt|;
name|after_last_match
operator|=
literal|0
expr_stmt|;
name|pending
operator|=
literal|0
expr_stmt|;
name|nlines
operator|=
literal|0
expr_stmt|;
name|residue
operator|=
literal|0
expr_stmt|;
name|save
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|fillbuf
argument_list|(
name|save
argument_list|,
name|stats
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|is_EISDIR
argument_list|(
name|errno
argument_list|,
name|file
argument_list|)
condition|)
name|suppressible_error
argument_list|(
name|filename
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|not_text
operator|=
operator|(
operator|(
operator|(
name|binary_files
operator|==
name|BINARY_BINARY_FILES
operator|&&
operator|!
name|out_quiet
operator|)
operator|||
name|binary_files
operator|==
name|WITHOUT_MATCH_BINARY_FILES
operator|)
operator|&&
name|memchr
argument_list|(
name|bufbeg
argument_list|,
name|eol
condition|?
literal|'\0'
else|:
literal|'\200'
argument_list|,
name|buflim
operator|-
name|bufbeg
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|not_text
operator|&&
name|binary_files
operator|==
name|WITHOUT_MATCH_BINARY_FILES
condition|)
return|return
literal|0
return|;
name|done_on_match
operator|+=
name|not_text
expr_stmt|;
name|out_quiet
operator|+=
name|not_text
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|lastnl
operator|=
name|bufbeg
expr_stmt|;
if|if
condition|(
name|lastout
condition|)
name|lastout
operator|=
name|bufbeg
expr_stmt|;
name|beg
operator|=
name|bufbeg
operator|+
name|save
expr_stmt|;
comment|/* no more data to scan (eof) except for maybe a residue -> break */
if|if
condition|(
name|beg
operator|==
name|buflim
condition|)
break|break;
comment|/* Determine new residue (the length of an incomplete line at the end of          the buffer, 0 means there is no incomplete last line).  */
name|oldc
operator|=
name|beg
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|beg
index|[
operator|-
literal|1
index|]
operator|=
name|eol
expr_stmt|;
for|for
control|(
name|lim
operator|=
name|buflim
init|;
name|lim
index|[
operator|-
literal|1
index|]
operator|!=
name|eol
condition|;
name|lim
operator|--
control|)
continue|continue;
name|beg
index|[
operator|-
literal|1
index|]
operator|=
name|oldc
expr_stmt|;
if|if
condition|(
name|lim
operator|==
name|beg
condition|)
name|lim
operator|=
name|beg
operator|-
name|residue
expr_stmt|;
name|beg
operator|-=
name|residue
expr_stmt|;
name|residue
operator|=
name|buflim
operator|-
name|lim
expr_stmt|;
if|if
condition|(
name|beg
operator|<
name|lim
condition|)
block|{
if|if
condition|(
name|outleft
condition|)
name|nlines
operator|+=
name|grepbuf
argument_list|(
name|beg
argument_list|,
name|lim
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending
condition|)
name|prpending
argument_list|(
name|lim
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|outleft
operator|&&
operator|!
name|pending
operator|)
operator|||
operator|(
name|nlines
operator|&&
name|done_on_match
operator|&&
operator|!
name|out_invert
operator|)
condition|)
goto|goto
name|finish_grep
goto|;
block|}
comment|/* The last OUT_BEFORE lines at the end of the buffer will be needed as 	 leading context if there is a matching line at the begin of the 	 next data. Make beg point to their begin.  */
name|i
operator|=
literal|0
expr_stmt|;
name|beg
operator|=
name|lim
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|out_before
operator|&&
name|beg
operator|>
name|bufbeg
operator|&&
name|beg
operator|!=
name|lastout
condition|)
block|{
operator|++
name|i
expr_stmt|;
do|do
operator|--
name|beg
expr_stmt|;
do|while
condition|(
name|beg
index|[
operator|-
literal|1
index|]
operator|!=
name|eol
condition|)
do|;
block|}
comment|/* detect if leading context is discontinuous from last printed line.  */
if|if
condition|(
name|beg
operator|!=
name|lastout
condition|)
name|lastout
operator|=
literal|0
expr_stmt|;
comment|/* Handle some details and read more data to scan.  */
name|save
operator|=
name|residue
operator|+
name|lim
operator|-
name|beg
expr_stmt|;
if|if
condition|(
name|out_byte
condition|)
name|totalcc
operator|=
name|add_count
argument_list|(
name|totalcc
argument_list|,
name|buflim
operator|-
name|bufbeg
operator|-
name|save
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_line
condition|)
name|nlscan
argument_list|(
name|beg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fillbuf
argument_list|(
name|save
argument_list|,
name|stats
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|is_EISDIR
argument_list|(
name|errno
argument_list|,
name|file
argument_list|)
condition|)
name|suppressible_error
argument_list|(
name|filename
argument_list|,
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|finish_grep
goto|;
block|}
block|}
if|if
condition|(
name|residue
condition|)
block|{
operator|*
name|buflim
operator|++
operator|=
name|eol
expr_stmt|;
if|if
condition|(
name|outleft
condition|)
name|nlines
operator|+=
name|grepbuf
argument_list|(
name|bufbeg
operator|+
name|save
operator|-
name|residue
argument_list|,
name|buflim
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending
condition|)
name|prpending
argument_list|(
name|buflim
argument_list|)
expr_stmt|;
block|}
name|finish_grep
label|:
name|done_on_match
operator|-=
name|not_text
expr_stmt|;
name|out_quiet
operator|-=
name|not_text
expr_stmt|;
if|if
condition|(
operator|(
name|not_text
operator|&
operator|~
name|out_quiet
operator|)
operator|&&
name|nlines
operator|!=
literal|0
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"Binary file %s matches\n"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
name|nlines
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|grepfile
parameter_list|(
name|char
specifier|const
modifier|*
name|file
parameter_list|,
name|struct
name|stats
modifier|*
name|stats
parameter_list|)
block|{
name|int
name|desc
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
block|{
name|desc
operator|=
literal|0
expr_stmt|;
name|filename
operator|=
name|label
condition|?
name|label
else|:
name|_
argument_list|(
literal|"(standard input)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|desc
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|is_EISDIR
argument_list|(
name|e
argument_list|,
name|file
argument_list|)
operator|&&
name|directories
operator|==
name|RECURSE_DIRECTORIES
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|stats
operator|->
name|stat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
name|grepdir
argument_list|(
name|file
argument_list|,
name|stats
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|suppress_errors
condition|)
block|{
if|if
condition|(
name|directories
operator|==
name|SKIP_DIRECTORIES
condition|)
switch|switch
condition|(
name|e
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|EISDIR
argument_list|)
case|case
name|EISDIR
case|:
return|return
literal|1
return|;
endif|#
directive|endif
case|case
name|EACCES
case|:
comment|/* When skipping directories, don't worry about 		       directories that can't be opened.  */
if|if
condition|(
name|isdir
argument_list|(
name|file
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
block|}
block|}
name|suppressible_error
argument_list|(
name|file
argument_list|,
name|e
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|filename
operator|=
name|file
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SET_BINARY
argument_list|)
comment|/* Set input to binary mode.  Pipes are simulated with files      on DOS, so this includes the case of "foo | grep bar".  */
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|desc
argument_list|)
condition|)
name|SET_BINARY
argument_list|(
name|desc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|count
operator|=
name|grep
argument_list|(
name|desc
argument_list|,
name|file
argument_list|,
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|status
operator|=
name|count
operator|+
literal|2
expr_stmt|;
else|else
block|{
if|if
condition|(
name|count_matches
condition|)
block|{
if|if
condition|(
name|out_file
condition|)
name|printf
argument_list|(
literal|"%s%c"
argument_list|,
name|filename
argument_list|,
literal|':'
operator|&
name|filename_mask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
operator|!
name|count
expr_stmt|;
if|if
condition|(
name|list_files
operator|==
literal|1
operator|-
literal|2
operator|*
name|status
condition|)
name|printf
argument_list|(
literal|"%s%c"
argument_list|,
name|filename
argument_list|,
literal|'\n'
operator|&
name|filename_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|BZflag
operator|&&
name|bzbufdesc
condition|)
name|BZ2_bzclose
argument_list|(
name|bzbufdesc
argument_list|)
expr_stmt|;
elseif|else
if|#
directive|if
name|HAVE_LIBZ
operator|>
literal|0
if|if
condition|(
name|Zflag
condition|)
name|gzclose
argument_list|(
name|gzbufdesc
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|!
name|file
condition|)
block|{
name|off_t
name|required_offset
init|=
name|outleft
condition|?
name|bufoffset
else|:
name|after_last_match
decl_stmt|;
if|if
condition|(
operator|(
name|bufmapped
operator|||
name|required_offset
operator|!=
name|bufoffset
operator|)
operator|&&
name|lseek
argument_list|(
name|desc
argument_list|,
name|required_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
operator|&&
name|S_ISREG
argument_list|(
name|stats
operator|->
name|stat
operator|.
name|st_mode
argument_list|)
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
while|while
condition|(
name|close
argument_list|(
name|desc
argument_list|)
operator|!=
literal|0
condition|)
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|grepdir
parameter_list|(
name|char
specifier|const
modifier|*
name|dir
parameter_list|,
name|struct
name|stats
specifier|const
modifier|*
name|stats
parameter_list|)
block|{
name|int
name|status
init|=
literal|1
decl_stmt|;
name|struct
name|stats
specifier|const
modifier|*
name|ancestor
decl_stmt|;
name|char
modifier|*
name|name_space
decl_stmt|;
comment|/* Mingw32 does not support st_ino.  No known working hosts use zero      for st_ino, so assume that the Mingw32 bug applies if it's zero.  */
if|if
condition|(
name|stats
operator|->
name|stat
operator|.
name|st_ino
condition|)
for|for
control|(
name|ancestor
operator|=
name|stats
init|;
operator|(
name|ancestor
operator|=
name|ancestor
operator|->
name|parent
operator|)
operator|!=
literal|0
condition|;
control|)
if|if
condition|(
name|ancestor
operator|->
name|stat
operator|.
name|st_ino
operator|==
name|stats
operator|->
name|stat
operator|.
name|st_ino
operator|&&
name|ancestor
operator|->
name|stat
operator|.
name|st_dev
operator|==
name|stats
operator|->
name|stat
operator|.
name|st_dev
condition|)
block|{
if|if
condition|(
operator|!
name|suppress_errors
condition|)
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"warning: %s: %s"
argument_list|)
argument_list|,
name|dir
argument_list|,
name|_
argument_list|(
literal|"recursive directory loop"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|name_space
operator|=
name|savedir
argument_list|(
name|dir
argument_list|,
name|stats
operator|->
name|stat
operator|.
name|st_size
argument_list|,
name|included_patterns
argument_list|,
name|excluded_patterns
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name_space
condition|)
block|{
if|if
condition|(
name|errno
condition|)
name|suppressible_error
argument_list|(
name|dir
argument_list|,
name|errno
argument_list|)
expr_stmt|;
else|else
name|xalloc_die
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|dirlen
init|=
name|strlen
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|int
name|needs_slash
init|=
operator|!
operator|(
name|dirlen
operator|==
name|FILESYSTEM_PREFIX_LEN
argument_list|(
name|dir
argument_list|)
operator|||
name|IS_SLASH
argument_list|(
name|dir
index|[
name|dirlen
operator|-
literal|1
index|]
argument_list|)
operator|)
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|NULL
decl_stmt|;
name|char
specifier|const
modifier|*
name|namep
init|=
name|name_space
decl_stmt|;
name|struct
name|stats
name|child
decl_stmt|;
name|child
operator|.
name|parent
operator|=
name|stats
expr_stmt|;
name|out_file
operator|+=
operator|!
name|no_filenames
expr_stmt|;
while|while
condition|(
operator|*
name|namep
condition|)
block|{
name|size_t
name|namelen
init|=
name|strlen
argument_list|(
name|namep
argument_list|)
decl_stmt|;
name|file
operator|=
name|xrealloc
argument_list|(
name|file
argument_list|,
name|dirlen
operator|+
literal|1
operator|+
name|namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|file
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|file
index|[
name|dirlen
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|file
operator|+
name|dirlen
operator|+
name|needs_slash
argument_list|,
name|namep
argument_list|)
expr_stmt|;
name|namep
operator|+=
name|namelen
operator|+
literal|1
expr_stmt|;
name|status
operator|&=
name|grepfile
argument_list|(
name|file
argument_list|,
operator|&
name|child
argument_list|)
expr_stmt|;
block|}
name|out_file
operator|-=
operator|!
name|no_filenames
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name_space
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|int
name|status
parameter_list|)
block|{
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Usage: %s [OPTION]... PATTERN [FILE]...\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Try `%s --help' for more information.\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Usage: %s [OPTION]... PATTERN [FILE] ...\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ Search for PATTERN in each FILE or standard input.\n\ Example: %s -i 'hello world' menu.h main.c\n\ \n\ Regexp selection and interpretation:\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\   -E, --extended-regexp     PATTERN is an extended regular expression\n\   -F, --fixed-strings       PATTERN is a set of newline-separated strings\n\   -G, --basic-regexp        PATTERN is a basic regular expression\n\   -P, --perl-regexp         PATTERN is a Perl regular expression\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\   -e, --regexp=PATTERN      use PATTERN as a regular expression\n\   -f, --file=FILE           obtain PATTERN from FILE\n\   -i, --ignore-case         ignore case distinctions\n\   -w, --word-regexp         force PATTERN to match only whole words\n\   -x, --line-regexp         force PATTERN to match only whole lines\n\   -z, --null-data           a data line ends in 0 byte, not newline\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ \n\ Miscellaneous:\n\   -s, --no-messages         suppress error messages\n\   -v, --invert-match        select non-matching lines\n\   -V, --version             print version information and exit\n\       --help                display this help and exit\n\   -J, --bz2decompress       decompress bzip2'ed input before searching\n\   -Z, --decompress          decompress input before searching (HAVE_LIBZ=1)\n\       --mmap                use memory-mapped input if possible\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ \n\ Output control:\n\   -m, --max-count=NUM       stop after NUM matches\n\   -b, --byte-offset         print the byte offset with output lines\n\   -n, --line-number         print line number with output lines\n\       --line-buffered       flush output on every line\n\   -H, --with-filename       print the filename for each match\n\   -h, --no-filename         suppress the prefixing filename on output\n\       --label=LABEL         print LABEL as filename for standard input\n\   -o, --only-matching       show only the part of a line matching PATTERN\n\   -q, --quiet, --silent     suppress all normal output\n\       --binary-files=TYPE   assume that binary files are TYPE\n\                             TYPE is 'binary', 'text', or 'without-match'\n\   -a, --text                equivalent to --binary-files=text\n\   -I                        equivalent to --binary-files=without-match\n\   -d, --directories=ACTION  how to handle directories\n\                             ACTION is 'read', 'recurse', or 'skip'\n\   -D, --devices=ACTION      how to handle devices, FIFOs and sockets\n\                             ACTION is 'read' or 'skip'\n\   -R, -r, --recursive       equivalent to --directories=recurse\n\       --include=PATTERN     files that match PATTERN will be examined\n\       --exclude=PATTERN     files that match PATTERN will be skipped.\n\       --exclude-from=FILE   files that match PATTERN in FILE will be skipped.\n\   -L, --files-without-match only print FILE names containing no match\n\   -l, --files-with-matches  only print FILE names containing matches\n\   -c, --count               only print a count of matching lines per FILE\n\       --null                print 0 byte after FILE name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ \n\ Context control:\n\   -B, --before-context=NUM  print NUM lines of leading context\n\   -A, --after-context=NUM   print NUM lines of trailing context\n\   -C, --context=NUM         print NUM lines of output context\n\   -NUM                      same as --context=NUM\n\       --color[=WHEN],\n\       --colour[=WHEN]       use markers to distinguish the matching string\n\                             WHEN may be `always', `never' or `auto'.\n\   -U, --binary              do not strip CR characters at EOL (MSDOS)\n\   -u, --unix-byte-offsets   report offsets as if CRs were not there (MSDOS)\n\ \n\ `egrep' means `grep -E'.  `fgrep' means `grep -F'.\n\ With no FILE, or when FILE is -, read standard input.  If less than\n\ two FILEs given, assume -h.  Exit status is 0 if match, 1 if no match,\n\ and 2 if trouble.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nReport bugs to<bug-gnu-utils@gnu.org>.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the matcher to M, reporting any conflicts.  */
end_comment

begin_function
specifier|static
name|void
name|setmatcher
parameter_list|(
name|char
specifier|const
modifier|*
name|m
parameter_list|)
block|{
if|if
condition|(
name|matcher
operator|&&
name|strcmp
argument_list|(
name|matcher
argument_list|,
name|m
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"conflicting matchers specified"
argument_list|)
argument_list|)
expr_stmt|;
name|matcher
operator|=
name|m
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Go through the matchers vector and look for the specified matcher.    If we find it, install it in compile and execute, and return 1.  */
end_comment

begin_function
specifier|static
name|int
name|install_matcher
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETRLIMIT
argument_list|)
name|struct
name|rlimit
name|rlim
decl_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|matchers
index|[
name|i
index|]
operator|.
name|compile
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|matchers
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|compile
operator|=
name|matchers
index|[
name|i
index|]
operator|.
name|compile
expr_stmt|;
name|execute
operator|=
name|matchers
index|[
name|i
index|]
operator|.
name|execute
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETRLIMIT
argument_list|)
operator|&&
name|defined
argument_list|(
name|RLIMIT_STACK
argument_list|)
comment|/* I think every platform needs to do this, so that regex.c 	   doesn't oveflow the stack.  The default value of 	   `re_max_failures' is too large for some platforms: it needs 	   more than 3MB-large stack.  	   The test for HAVE_SETRLIMIT should go into `configure'.  */
if|if
condition|(
operator|!
name|getrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
condition|)
block|{
name|long
name|newlim
decl_stmt|;
specifier|extern
name|long
name|int
name|re_max_failures
decl_stmt|;
comment|/* from regex.c */
comment|/* Approximate the amount regex.c needs, plus some more.  */
name|newlim
operator|=
name|re_max_failures
operator|*
literal|2
operator|*
literal|20
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlim
operator|>
name|rlim
operator|.
name|rlim_max
condition|)
block|{
name|newlim
operator|=
name|rlim
operator|.
name|rlim_max
expr_stmt|;
name|re_max_failures
operator|=
name|newlim
operator|/
operator|(
literal|2
operator|*
literal|20
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|rlim
operator|.
name|rlim_cur
operator|<
name|newlim
condition|)
block|{
name|rlim
operator|.
name|rlim_cur
operator|=
name|newlim
expr_stmt|;
name|setrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find the white-space-separated options specified by OPTIONS, and    using BUF to store copies of these options, set ARGV[0], ARGV[1],    etc. to the option copies.  Return the number N of options found.    Do not set ARGV[N] to NULL.  If ARGV is NULL, do not store ARGV[0]    etc.  Backslash can be used to escape whitespace (and backslashes).  */
end_comment

begin_function
specifier|static
name|int
name|prepend_args
parameter_list|(
name|char
specifier|const
modifier|*
name|options
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|o
init|=
name|options
decl_stmt|;
name|char
modifier|*
name|b
init|=
name|buf
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|o
argument_list|)
condition|)
name|o
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|o
condition|)
return|return
name|n
return|;
if|if
condition|(
name|argv
condition|)
name|argv
index|[
name|n
index|]
operator|=
name|b
expr_stmt|;
name|n
operator|++
expr_stmt|;
do|do
if|if
condition|(
operator|(
operator|*
name|b
operator|++
operator|=
operator|*
name|o
operator|++
operator|)
operator|==
literal|'\\'
operator|&&
operator|*
name|o
condition|)
name|b
index|[
operator|-
literal|1
index|]
operator|=
operator|*
name|o
operator|++
expr_stmt|;
do|while
condition|(
operator|*
name|o
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|o
argument_list|)
condition|)
do|;
operator|*
name|b
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Prepend the whitespace-separated options in OPTIONS to the argument    vector of a main program with argument count *PARGC and argument    vector *PARGV.  */
end_comment

begin_function
specifier|static
name|void
name|prepend_default_options
parameter_list|(
name|char
specifier|const
modifier|*
name|options
parameter_list|,
name|int
modifier|*
name|pargc
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|pargv
parameter_list|)
block|{
if|if
condition|(
name|options
condition|)
block|{
name|char
modifier|*
name|buf
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|options
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|prepended
init|=
name|prepend_args
argument_list|(
name|options
argument_list|,
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
decl_stmt|;
name|int
name|argc
init|=
operator|*
name|pargc
decl_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|argv
init|=
operator|*
name|pargv
decl_stmt|;
name|char
modifier|*
modifier|*
name|pp
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|prepended
operator|+
name|argc
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|pp
argument_list|)
decl_stmt|;
operator|*
name|pargc
operator|=
name|prepended
operator|+
name|argc
expr_stmt|;
operator|*
name|pargv
operator|=
name|pp
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|pp
operator|+=
name|prepend_args
argument_list|(
name|options
argument_list|,
name|buf
argument_list|,
name|pp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|pp
operator|++
operator|=
operator|*
name|argv
operator|++
operator|)
condition|)
continue|continue;
block|}
block|}
end_function

begin_comment
comment|/* Get the next non-digit option from ARGC and ARGV.    Return -1 if there are no more options.    Process any digit options that were encountered on the way,    and store the resulting integer into *DEFAULT_CONTEXT.  */
end_comment

begin_function
specifier|static
name|int
name|get_nondigit_option
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
name|int
modifier|*
name|default_context
parameter_list|)
block|{
name|int
name|opt
decl_stmt|;
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|uintmax_t
argument_list|)
operator|*
name|CHAR_BIT
operator|+
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
comment|/* Set buf[0] to anything but '0', for the leading-zero test below.  */
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|opt
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|short_options
argument_list|,
name|long_options
argument_list|,
name|NULL
argument_list|)
operator|,
literal|'0'
operator|<=
name|opt
operator|&&
name|opt
operator|<=
literal|'9'
condition|)
block|{
comment|/* Suppress trivial leading zeros, to avoid incorrect 	 diagnostic on strings like 00000000000.  */
name|p
operator|-=
name|buf
index|[
literal|0
index|]
operator|==
literal|'0'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|opt
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|buf
operator|+
sizeof|sizeof
name|buf
operator|-
literal|4
condition|)
block|{
comment|/* Too many digits.  Append "..." to make context_length_arg 	     complain about "X...", where X contains the digits seen 	     so far.  */
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|p
operator|!=
name|buf
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|context_length_arg
argument_list|(
name|buf
argument_list|,
name|default_context
argument_list|)
expr_stmt|;
block|}
return|return
name|opt
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|keys
decl_stmt|;
name|size_t
name|cc
decl_stmt|,
name|keycc
decl_stmt|,
name|oldcc
decl_stmt|,
name|keyalloc
decl_stmt|;
name|int
name|with_filenames
decl_stmt|;
name|int
name|opt
decl_stmt|,
name|status
decl_stmt|;
name|int
name|default_context
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
name|initialize_main
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|program_name
operator|&&
name|strrchr
argument_list|(
name|program_name
argument_list|,
literal|'/'
argument_list|)
condition|)
name|program_name
operator|=
name|strrchr
argument_list|(
name|program_name
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|program_name
index|[
literal|0
index|]
operator|==
literal|'b'
operator|&&
name|program_name
index|[
literal|1
index|]
operator|==
literal|'z'
condition|)
block|{
name|BZflag
operator|=
literal|1
expr_stmt|;
name|program_name
operator|+=
literal|2
expr_stmt|;
block|}
if|#
directive|if
name|HAVE_LIBZ
operator|>
literal|0
elseif|else
if|if
condition|(
name|program_name
index|[
literal|0
index|]
operator|==
literal|'z'
condition|)
block|{
name|Zflag
operator|=
literal|1
expr_stmt|;
operator|++
name|program_name
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
comment|/* DOS and MS-Windows use backslashes as directory separators, and usually      have an .exe suffix.  They also have case-insensitive filesystems.  */
if|if
condition|(
name|program_name
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|program_name
decl_stmt|;
name|char
modifier|*
name|bslash
init|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'\\'
argument_list|)
decl_stmt|;
if|if
condition|(
name|bslash
operator|&&
name|bslash
operator|>=
name|program_name
condition|)
comment|/* for mixed forward/backslash case */
name|program_name
operator|=
name|bslash
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|program_name
operator|==
name|argv
index|[
literal|0
index|]
operator|&&
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|&&
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
comment|/* "c:progname" */
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
operator|+
literal|2
expr_stmt|;
comment|/* Collapse the letter-case, so `strcmp' could be used hence.  */
for|for
control|(
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'Z'
condition|)
operator|*
name|p
operator|+=
literal|'a'
operator|-
literal|'A'
expr_stmt|;
comment|/* Remove the .exe extension, if any.  */
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|program_name
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|&&
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".exe"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
name|keys
operator|=
name|NULL
expr_stmt|;
name|keycc
operator|=
literal|0
expr_stmt|;
name|with_filenames
operator|=
literal|0
expr_stmt|;
name|eolbyte
operator|=
literal|'\n'
expr_stmt|;
name|filename_mask
operator|=
operator|~
literal|0
expr_stmt|;
name|max_count
operator|=
name|TYPE_MAXIMUM
argument_list|(
name|off_t
argument_list|)
expr_stmt|;
comment|/* The value -1 means to use DEFAULT_CONTEXT. */
name|out_after
operator|=
name|out_before
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Default before/after context: chaged by -C/-NUM options */
name|default_context
operator|=
literal|0
expr_stmt|;
comment|/* Changed by -o option */
name|only_matching
operator|=
literal|0
expr_stmt|;
comment|/* Internationalization. */
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ENABLE_NLS
argument_list|)
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|atexit
argument_list|(
name|close_stdout
argument_list|)
expr_stmt|;
name|prepend_default_options
argument_list|(
name|getenv
argument_list|(
literal|"GREP_OPTIONS"
argument_list|)
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|get_nondigit_option
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|default_context
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'A'
case|:
name|context_length_arg
argument_list|(
name|optarg
argument_list|,
operator|&
name|out_after
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|context_length_arg
argument_list|(
name|optarg
argument_list|,
operator|&
name|out_before
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* Set output match context, but let any explicit leading or 	   trailing amount specified with -A or -B stand. */
name|context_length_arg
argument_list|(
name|optarg
argument_list|,
operator|&
name|default_context
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"read"
argument_list|)
operator|==
literal|0
condition|)
name|devices
operator|=
name|READ_DEVICES
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"skip"
argument_list|)
operator|==
literal|0
condition|)
name|devices
operator|=
name|SKIP_DEVICES
expr_stmt|;
else|else
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"unknown devices method"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|setmatcher
argument_list|(
literal|"egrep"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|setmatcher
argument_list|(
literal|"fgrep"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|setmatcher
argument_list|(
literal|"perl"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|setmatcher
argument_list|(
literal|"grep"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|with_filenames
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|binary_files
operator|=
name|WITHOUT_MATCH_BINARY_FILES
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
if|if
condition|(
name|Zflag
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Cannot mix -Z and -J.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|BZflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
if|#
directive|if
name|defined
argument_list|(
name|HAVE_DOS_FILE_CONTENTS
argument_list|)
name|dos_use_file_type
operator|=
name|DOS_BINARY
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'u'
case|:
if|#
directive|if
name|defined
argument_list|(
name|HAVE_DOS_FILE_CONTENTS
argument_list|)
name|dos_report_unix_offset
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'V'
case|:
name|show_version
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|setmatcher
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|binary_files
operator|=
name|TEXT_BINARY_FILES
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|out_byte
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|count_matches
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"read"
argument_list|)
operator|==
literal|0
condition|)
name|directories
operator|=
name|READ_DIRECTORIES
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"skip"
argument_list|)
operator|==
literal|0
condition|)
name|directories
operator|=
name|SKIP_DIRECTORIES
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"recurse"
argument_list|)
operator|==
literal|0
condition|)
name|directories
operator|=
name|RECURSE_DIRECTORIES
expr_stmt|;
else|else
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"unknown directories method"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|cc
operator|=
name|strlen
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|keys
operator|=
name|xrealloc
argument_list|(
name|keys
argument_list|,
name|keycc
operator|+
name|cc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|keys
index|[
name|keycc
index|]
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|keycc
operator|+=
name|cc
expr_stmt|;
name|keys
index|[
name|keycc
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fp
operator|=
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
condition|?
name|fopen
argument_list|(
name|optarg
argument_list|,
literal|"r"
argument_list|)
else|:
name|stdin
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
for|for
control|(
name|keyalloc
operator|=
literal|1
init|;
name|keyalloc
operator|<=
name|keycc
operator|+
literal|1
condition|;
name|keyalloc
operator|*=
literal|2
control|)
empty_stmt|;
name|keys
operator|=
name|xrealloc
argument_list|(
name|keys
argument_list|,
name|keyalloc
argument_list|)
expr_stmt|;
name|oldcc
operator|=
name|keycc
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
operator|&&
operator|(
name|cc
operator|=
name|fread
argument_list|(
name|keys
operator|+
name|keycc
argument_list|,
literal|1
argument_list|,
name|keyalloc
operator|-
literal|1
operator|-
name|keycc
argument_list|,
name|fp
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|keycc
operator|+=
name|cc
expr_stmt|;
if|if
condition|(
name|keycc
operator|==
name|keyalloc
operator|-
literal|1
condition|)
name|keys
operator|=
name|xrealloc
argument_list|(
name|keys
argument_list|,
name|keyalloc
operator|*=
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Append final newline if file ended in non-newline. */
if|if
condition|(
name|oldcc
operator|!=
name|keycc
operator|&&
name|keys
index|[
name|keycc
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|keys
index|[
name|keycc
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|no_filenames
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'y'
case|:
comment|/* For old-timers . . . */
name|match_icase
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Like -l, except list files that don't contain matches. 	   Inspired by the same option in Hume's gre. */
name|list_files
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|list_files
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
block|{
name|uintmax_t
name|value
decl_stmt|;
switch|switch
condition|(
name|xstrtoumax
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
operator|&
name|value
argument_list|,
literal|""
argument_list|)
condition|)
block|{
case|case
name|LONGINT_OK
case|:
name|max_count
operator|=
name|value
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|max_count
operator|&&
name|max_count
operator|==
name|value
condition|)
break|break;
comment|/* Fall through.  */
case|case
name|LONGINT_OVERFLOW
case|:
name|max_count
operator|=
name|TYPE_MAXIMUM
argument_list|(
name|off_t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"invalid max count"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'n'
case|:
name|out_line
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|only_matching
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|exit_on_match
operator|=
literal|1
expr_stmt|;
name|close_stdout_set_status
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
case|case
literal|'r'
case|:
name|directories
operator|=
name|RECURSE_DIRECTORIES
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|suppress_errors
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|out_invert
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|match_words
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|match_lines
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
if|#
directive|if
name|HAVE_LIBZ
operator|>
literal|0
if|if
condition|(
name|BZflag
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Cannot mix -J and -Z.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|Zflag
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|filename_mask
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'z'
case|:
name|eolbyte
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|BINARY_FILES_OPTION
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"binary"
argument_list|)
operator|==
literal|0
condition|)
name|binary_files
operator|=
name|BINARY_BINARY_FILES
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"text"
argument_list|)
operator|==
literal|0
condition|)
name|binary_files
operator|=
name|TEXT_BINARY_FILES
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"without-match"
argument_list|)
operator|==
literal|0
condition|)
name|binary_files
operator|=
name|WITHOUT_MATCH_BINARY_FILES
expr_stmt|;
else|else
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"unknown binary-files type"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COLOR_OPTION
case|:
if|if
condition|(
name|optarg
condition|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"always"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"yes"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"force"
argument_list|)
condition|)
name|color_option
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"never"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"no"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"none"
argument_list|)
condition|)
name|color_option
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"auto"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"tty"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"if-tty"
argument_list|)
condition|)
name|color_option
operator|=
literal|2
expr_stmt|;
else|else
name|show_help
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|color_option
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|color_option
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|isatty
argument_list|(
name|STDOUT_FILENO
argument_list|)
operator|&&
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|,
literal|"dumb"
argument_list|)
condition|)
name|color_option
operator|=
literal|1
expr_stmt|;
else|else
name|color_option
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|EXCLUDE_OPTION
case|:
if|if
condition|(
operator|!
name|excluded_patterns
condition|)
name|excluded_patterns
operator|=
name|new_exclude
argument_list|()
expr_stmt|;
name|add_exclude
argument_list|(
name|excluded_patterns
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXCLUDE_FROM_OPTION
case|:
if|if
condition|(
operator|!
name|excluded_patterns
condition|)
name|excluded_patterns
operator|=
name|new_exclude
argument_list|()
expr_stmt|;
if|if
condition|(
name|add_exclude_file
argument_list|(
name|add_exclude
argument_list|,
name|excluded_patterns
argument_list|,
name|optarg
argument_list|,
literal|'\n'
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|INCLUDE_OPTION
case|:
if|if
condition|(
operator|!
name|included_patterns
condition|)
name|included_patterns
operator|=
name|new_exclude
argument_list|()
expr_stmt|;
name|add_exclude
argument_list|(
name|included_patterns
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINE_BUFFERED_OPTION
case|:
name|line_buffered
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|LABEL_OPTION
case|:
name|label
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* long options */
break|break;
default|default:
name|usage
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* POSIX.2 says that -q overrides -l, which in turn overrides the      other output options.  */
if|if
condition|(
name|exit_on_match
condition|)
name|list_files
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|exit_on_match
operator||
name|list_files
condition|)
block|{
name|count_matches
operator|=
literal|0
expr_stmt|;
name|done_on_match
operator|=
literal|1
expr_stmt|;
block|}
name|out_quiet
operator|=
name|count_matches
operator||
name|done_on_match
expr_stmt|;
if|if
condition|(
name|out_after
operator|<
literal|0
condition|)
name|out_after
operator|=
name|default_context
expr_stmt|;
if|if
condition|(
name|out_before
operator|<
literal|0
condition|)
name|out_before
operator|=
name|default_context
expr_stmt|;
if|if
condition|(
name|color_option
condition|)
block|{
name|char
modifier|*
name|userval
init|=
name|getenv
argument_list|(
literal|"GREP_COLOR"
argument_list|)
decl_stmt|;
if|if
condition|(
name|userval
operator|!=
name|NULL
operator|&&
operator|*
name|userval
operator|!=
literal|'\0'
condition|)
name|grep_color
operator|=
name|userval
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|matcher
condition|)
name|matcher
operator|=
name|program_name
expr_stmt|;
if|if
condition|(
name|show_version
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"%s (GNU grep) %s\n"
argument_list|)
argument_list|,
name|matcher
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ Copyright 1988, 1992-1999, 2000, 2001 Free Software Foundation, Inc.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ This is free software; see the source for copying conditions. There is NO\n\ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|show_help
condition|)
name|usage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|keys
condition|)
block|{
if|if
condition|(
name|keycc
operator|==
literal|0
condition|)
block|{
comment|/* No keys were specified (e.g. -f /dev/null).  Match nothing.  */
name|out_invert
operator|^=
literal|1
expr_stmt|;
name|match_lines
operator|=
name|match_words
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* Strip trailing newline. */
operator|--
name|keycc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|keys
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
name|keycc
operator|=
name|strlen
argument_list|(
name|keys
argument_list|)
expr_stmt|;
block|}
else|else
name|usage
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|install_matcher
argument_list|(
name|matcher
argument_list|)
operator|&&
operator|!
name|install_matcher
argument_list|(
literal|"default"
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|!=
literal|1
operator|&&
name|match_icase
condition|)
block|{
name|wchar_t
name|wc
decl_stmt|;
name|mbstate_t
name|cur_state
decl_stmt|,
name|prev_state
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
init|=
name|strlen
argument_list|(
name|keys
argument_list|)
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cur_state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|len
condition|;
control|)
block|{
name|size_t
name|mbclen
decl_stmt|;
name|mbclen
operator|=
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|keys
operator|+
name|i
argument_list|,
name|len
operator|-
name|i
argument_list|,
operator|&
name|cur_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbclen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|||
name|mbclen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|2
operator|||
name|mbclen
operator|==
literal|0
condition|)
block|{
comment|/* An invalid sequence, or a truncated multibyte character. 		 We treat it as a singlebyte character.  */
name|mbclen
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|iswupper
argument_list|(
operator|(
name|wint_t
operator|)
name|wc
argument_list|)
condition|)
block|{
name|wc
operator|=
name|towlower
argument_list|(
operator|(
name|wint_t
operator|)
name|wc
argument_list|)
expr_stmt|;
name|wcrtomb
argument_list|(
name|keys
operator|+
name|i
argument_list|,
name|wc
argument_list|,
operator|&
name|cur_state
argument_list|)
expr_stmt|;
block|}
block|}
name|i
operator|+=
name|mbclen
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* MBS_SUPPORT */
call|(
modifier|*
name|compile
call|)
argument_list|(
name|keys
argument_list|,
name|keycc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|argc
operator|-
name|optind
operator|>
literal|1
operator|&&
operator|!
name|no_filenames
operator|)
operator|||
name|with_filenames
condition|)
name|out_file
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SET_BINARY
comment|/* Output is set to binary mode because we shouldn't convert      NL to CR-LF pairs, especially when grepping binary files.  */
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|1
argument_list|)
condition|)
name|SET_BINARY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|max_count
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|status
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|char
modifier|*
name|file
init|=
name|argv
index|[
name|optind
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|included_patterns
operator|||
name|excluded_patterns
operator|)
operator|&&
operator|!
name|isdir
argument_list|(
name|file
argument_list|)
condition|)
block|{
if|if
condition|(
name|included_patterns
operator|&&
operator|!
name|excluded_filename
argument_list|(
name|included_patterns
argument_list|,
name|file
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|excluded_patterns
operator|&&
name|excluded_filename
argument_list|(
name|excluded_patterns
argument_list|,
name|file
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
block|}
name|status
operator|&=
name|grepfile
argument_list|(
name|strcmp
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|?
operator|(
name|char
operator|*
operator|)
name|NULL
else|:
name|file
argument_list|,
operator|&
name|stats_base
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|optind
operator|<
name|argc
condition|)
do|;
block|}
else|else
name|status
operator|=
name|grepfile
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|stats_base
argument_list|)
expr_stmt|;
comment|/* We register via atexit() to test stdout.  */
name|exit
argument_list|(
name|errseen
condition|?
literal|2
else|:
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* vim:set shiftwidth=2: */
end_comment

end_unit

