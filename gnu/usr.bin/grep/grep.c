begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* grep.c - main driver file for grep.    Copyright (C) 1992, 1997, 1998, 1999 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* Written July 1992 by Mike Haertel.  */
end_comment

begin_comment
comment|/* Builtin decompression 1997 by Wolfram Schneider<wosch@FreeBSD.org>.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MMAP
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETRLIMIT
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"getpagesize.h"
end_include

begin_include
include|#
directive|include
file|"grep.h"
end_include

begin_include
include|#
directive|include
file|"savedir.h"
end_include

begin_undef
undef|#
directive|undef
name|MAX
end_undef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)> (B) ? (A) : (B))
end_define

begin_struct
struct|struct
name|stats
block|{
name|struct
name|stats
modifier|*
name|parent
decl_stmt|;
name|struct
name|stat
name|stat
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* base of chain of stat buffers, used to detect directory loops */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|stats
name|stats_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if non-zero, display usage information and exit */
end_comment

begin_decl_stmt
specifier|static
name|int
name|show_help
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, print the version on standard output and exit.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|show_version
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, use mmap if possible.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mmap_option
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If zero, output nulls after filenames.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|filename_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Short options.  */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
name|short_options
index|[]
init|=
literal|"0123456789A:B:C::EFGHIRUVX:abcd:e:f:hiLlnqrsuvwxyZz"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-boolean long options that have no corresponding short equivalents.  */
end_comment

begin_enum
enum|enum
block|{
name|BINARY_FILES_OPTION
init|=
name|CHAR_MAX
operator|+
literal|1
block|}
enum|;
end_enum

begin_comment
comment|/* Long options equivalences. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"after-context"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'A'
block|}
block|,
block|{
literal|"basic-regexp"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'G'
block|}
block|,
block|{
literal|"before-context"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'B'
block|}
block|,
block|{
literal|"binary-files"
block|,
name|required_argument
block|,
name|NULL
block|,
name|BINARY_FILES_OPTION
block|}
block|,
block|{
literal|"byte-offset"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'b'
block|}
block|,
block|{
literal|"context"
block|,
name|optional_argument
block|,
name|NULL
block|,
literal|'C'
block|}
block|,
block|{
literal|"count"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
block|{
literal|"directories"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"extended-regexp"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'E'
block|}
block|,
block|{
literal|"file"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
block|{
literal|"files-with-matches"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
block|{
literal|"files-without-match"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'L'
block|}
block|,
block|{
literal|"fixed-regexp"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'F'
block|}
block|,
block|{
literal|"fixed-strings"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'F'
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
operator|&
name|show_help
block|,
literal|1
block|}
block|,
block|{
literal|"ignore-case"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'i'
block|}
block|,
block|{
literal|"line-number"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
block|{
literal|"line-regexp"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'x'
block|}
block|,
block|{
literal|"mmap"
block|,
name|no_argument
block|,
operator|&
name|mmap_option
block|,
literal|1
block|}
block|,
block|{
literal|"no-filename"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"no-messages"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
if|#
directive|if
name|HAVE_LIBZ
operator|>
literal|0
block|{
literal|"decompress"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'Z'
block|}
block|,
block|{
literal|"null"
block|,
name|no_argument
block|,
operator|&
name|filename_mask
block|,
literal|0
block|}
block|,
else|#
directive|else
block|{
literal|"null"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'Z'
block|}
block|,
endif|#
directive|endif
block|{
literal|"null-data"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'z'
block|}
block|,
block|{
literal|"quiet"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'q'
block|}
block|,
block|{
literal|"recursive"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'r'
block|}
block|,
block|{
literal|"regexp"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'e'
block|}
block|,
block|{
literal|"invert-match"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
literal|"silent"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'q'
block|}
block|,
block|{
literal|"text"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'a'
block|}
block|,
block|{
literal|"binary"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'U'
block|}
block|,
block|{
literal|"unix-byte-offsets"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'u'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
literal|"with-filename"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'H'
block|}
block|,
block|{
literal|"word-regexp"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'w'
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define flags declared in grep.h. */
end_comment

begin_decl_stmt
name|char
specifier|const
modifier|*
name|matcher
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|match_icase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|match_words
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|match_lines
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|eolbyte
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For error messages. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|errseen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How to handle directories.  */
end_comment

begin_enum
specifier|static
enum|enum
block|{
name|READ_DIRECTORIES
block|,
name|RECURSE_DIRECTORIES
block|,
name|SKIP_DIRECTORIES
block|}
name|directories
enum|;
end_enum

begin_decl_stmt
specifier|static
name|int
name|ck_atoi
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usage
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
name|__attribute__
argument_list|(
operator|(
name|noreturn
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|error
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setmatcher
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|install_matcher
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|prepend_args
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prepend_default_options
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|page_alloc
name|PARAMS
argument_list|(
operator|(
name|size_t
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reset
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
specifier|const
operator|*
operator|,
expr|struct
name|stats
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fillbuf
name|PARAMS
argument_list|(
operator|(
name|size_t
operator|,
expr|struct
name|stats
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|grepbuf
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prtext
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prpending
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prline
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_offset_sep
name|PARAMS
argument_list|(
operator|(
name|off_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nlscan
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|grep
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
specifier|const
operator|*
operator|,
expr|struct
name|stats
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|grepdir
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
expr|struct
name|stats
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|grepfile
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
expr|struct
name|stats
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|O_BINARY
end_if

begin_decl_stmt
specifier|static
specifier|inline
name|int
name|undossify_input
name|PARAMS
argument_list|(
operator|(
specifier|register
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Functions we'll use to search. */
end_comment

begin_expr_stmt
specifier|static
name|void
argument_list|(
argument|*compile
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|char
operator|*
operator|(
operator|*
name|execute
operator|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|size_t
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Print a message and possibly an error string.  Remember    that something awful happened. */
end_comment

begin_function
specifier|static
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
name|mesg
parameter_list|,
name|int
name|errnum
parameter_list|)
block|{
if|if
condition|(
name|errnum
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: %s\n"
argument_list|,
name|prog
argument_list|,
name|mesg
argument_list|,
name|strerror
argument_list|(
name|errnum
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|prog
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
name|errseen
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like error (), but die horribly after printing. */
end_comment

begin_function
name|void
name|fatal
parameter_list|(
specifier|const
name|char
modifier|*
name|mesg
parameter_list|,
name|int
name|errnum
parameter_list|)
block|{
name|error
argument_list|(
name|mesg
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Interface to handle errors and fix library lossage. */
end_comment

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|&&
operator|!
name|result
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"memory exhausted"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Interface to handle errors and fix some library lossage. */
end_comment

begin_function
name|char
modifier|*
name|xrealloc
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|char
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|ptr
condition|)
name|result
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|&&
operator|!
name|result
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"memory exhausted"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Convert STR to a positive integer, storing the result in *OUT.    If STR is not a valid integer, return -1 (otherwise 0). */
end_comment

begin_function
specifier|static
name|int
name|ck_atoi
parameter_list|(
name|char
specifier|const
modifier|*
name|str
parameter_list|,
name|int
modifier|*
name|out
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|str
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|<
literal|'0'
operator|||
operator|*
name|p
operator|>
literal|'9'
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|out
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Hairy buffering mechanism for grep.  The intent is to keep    all reads aligned on a page boundary and multiples of the    page size. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ubuffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Unaligned base of buffer. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Base of buffer. */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|bufsalloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocated size of buffer save region. */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|bufalloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total buffer size. */
end_comment

begin_define
define|#
directive|define
name|PREFERRED_SAVE_FACTOR
value|5
end_define

begin_comment
comment|/* Preferred value of bufalloc / bufsalloc.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bufdesc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File descriptor. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bufbeg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Beginning of user-visible stuff. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buflim
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Limit of user-visible stuff. */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|pagesize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* alignment of memory pages */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|bufoffset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read offset; defined on regular files.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MMAP
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|bufmapped
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if buffer is memory-mapped.  */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|initial_bufoffset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initial value of bufoffset. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_LIBZ
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_decl_stmt
specifier|static
name|gzFile
name|gzbufdesc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* zlib file descriptor. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Zflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* uncompress before searching. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return VAL aligned to the next multiple of ALIGNMENT.  VAL can be    an integer or a pointer.  Both args must be free of side effects.  */
end_comment

begin_define
define|#
directive|define
name|ALIGN_TO
parameter_list|(
name|val
parameter_list|,
name|alignment
parameter_list|)
define|\
value|((size_t) (val) % (alignment) == 0 \    ? (val) \    : (val) + ((alignment) - (size_t) (val) % (alignment)))
end_define

begin_comment
comment|/* Return the address of a page-aligned buffer of size SIZE,    reallocating it from *UP.  Set *UP to the newly allocated (but    possibly unaligned) buffer used to build the aligned buffer.  To    free the buffer, free (*UP).  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|page_alloc
parameter_list|(
name|size_t
name|size
parameter_list|,
name|char
modifier|*
modifier|*
name|up
parameter_list|)
block|{
name|size_t
name|asize
init|=
name|size
operator|+
name|pagesize
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|size
operator|<=
name|asize
condition|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|up
condition|?
name|realloc
argument_list|(
operator|*
name|up
argument_list|,
name|asize
argument_list|)
else|:
name|malloc
argument_list|(
name|asize
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
operator|*
name|up
operator|=
name|p
expr_stmt|;
return|return
name|ALIGN_TO
argument_list|(
name|p
argument_list|,
name|pagesize
argument_list|)
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Reset the buffer for a new file, returning zero if we should skip it.    Initialize on the first time through. */
end_comment

begin_function
specifier|static
name|int
name|reset
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
specifier|const
modifier|*
name|file
parameter_list|,
name|struct
name|stats
modifier|*
name|stats
parameter_list|)
block|{
if|if
condition|(
name|pagesize
condition|)
name|bufsalloc
operator|=
name|ALIGN_TO
argument_list|(
name|bufalloc
operator|/
name|PREFERRED_SAVE_FACTOR
argument_list|,
name|pagesize
argument_list|)
expr_stmt|;
else|else
block|{
name|size_t
name|ubufsalloc
decl_stmt|;
name|pagesize
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
if|if
condition|(
name|pagesize
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|BUFSALLOC
name|ubufsalloc
operator|=
name|MAX
argument_list|(
literal|8192
argument_list|,
name|pagesize
argument_list|)
expr_stmt|;
else|#
directive|else
name|ubufsalloc
operator|=
name|BUFSALLOC
expr_stmt|;
endif|#
directive|endif
name|bufsalloc
operator|=
name|ALIGN_TO
argument_list|(
name|ubufsalloc
argument_list|,
name|pagesize
argument_list|)
expr_stmt|;
name|bufalloc
operator|=
name|PREFERRED_SAVE_FACTOR
operator|*
name|bufsalloc
expr_stmt|;
comment|/* The 1 byte of overflow is a kludge for dfaexec(), which 	 inserts a sentinel newline at the end of the buffer 	 being searched.  There's gotta be a better way... */
if|if
condition|(
name|bufsalloc
operator|<
name|ubufsalloc
operator|||
name|bufalloc
operator|/
name|PREFERRED_SAVE_FACTOR
operator|!=
name|bufsalloc
operator|||
name|bufalloc
operator|+
literal|1
operator|<
name|bufalloc
operator|||
operator|!
operator|(
name|buffer
operator|=
name|page_alloc
argument_list|(
name|bufalloc
operator|+
literal|1
argument_list|,
operator|&
name|ubuffer
argument_list|)
operator|)
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"memory exhausted"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|HAVE_LIBZ
operator|>
literal|0
if|if
condition|(
name|Zflag
condition|)
block|{
name|gzbufdesc
operator|=
name|gzdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gzbufdesc
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"memory exhausted"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|buflim
operator|=
name|buffer
expr_stmt|;
name|bufdesc
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|stats
operator|->
name|stat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"fstat"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|directories
operator|==
name|SKIP_DIRECTORIES
operator|&&
name|S_ISDIR
argument_list|(
name|stats
operator|->
name|stat
operator|.
name|st_mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
if|#
directive|if
name|HAVE_LIBZ
operator|>
literal|0
name|Zflag
operator|||
endif|#
directive|endif
name|S_ISREG
argument_list|(
name|stats
operator|->
name|stat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|file
condition|)
name|bufoffset
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|bufoffset
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufoffset
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"lseek"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|HAVE_MMAP
name|initial_bufoffset
operator|=
name|bufoffset
expr_stmt|;
name|bufmapped
operator|=
name|mmap_option
operator|&&
name|bufoffset
operator|%
name|pagesize
operator|==
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_MMAP
name|bufmapped
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Read new stuff into the buffer, saving the specified    amount of old stuff.  When we're done, 'bufbeg' points    to the beginning of the buffer contents, and 'buflim'    points just after the end.  Return zero if there's an error.  */
end_comment

begin_function
specifier|static
name|int
name|fillbuf
parameter_list|(
name|size_t
name|save
parameter_list|,
name|struct
name|stats
modifier|*
name|stats
parameter_list|)
block|{
name|size_t
name|fillsize
init|=
literal|0
decl_stmt|;
name|int
name|cc
init|=
literal|1
decl_stmt|;
name|size_t
name|readsize
decl_stmt|;
comment|/* Offset from start of unaligned buffer to start of old stuff      that we want to save.  */
name|size_t
name|saved_offset
init|=
name|buflim
operator|-
name|ubuffer
operator|-
name|save
decl_stmt|;
if|if
condition|(
name|bufsalloc
operator|<
name|save
condition|)
block|{
name|size_t
name|aligned_save
init|=
name|ALIGN_TO
argument_list|(
name|save
argument_list|,
name|pagesize
argument_list|)
decl_stmt|;
name|size_t
name|maxalloc
init|=
operator|(
name|size_t
operator|)
operator|-
literal|1
decl_stmt|;
name|size_t
name|newalloc
decl_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|stats
operator|->
name|stat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* Calculate an upper bound on how much memory we should allocate. 	     We can't use ALIGN_TO here, since off_t might be longer than 	     size_t.  Watch out for arithmetic overflow.  */
name|off_t
name|to_be_read
init|=
name|stats
operator|->
name|stat
operator|.
name|st_size
operator|-
name|bufoffset
decl_stmt|;
name|size_t
name|slop
init|=
name|to_be_read
operator|%
name|pagesize
decl_stmt|;
name|off_t
name|aligned_to_be_read
init|=
name|to_be_read
operator|+
operator|(
name|slop
condition|?
name|pagesize
operator|-
name|slop
else|:
literal|0
operator|)
decl_stmt|;
name|off_t
name|maxalloc_off
init|=
name|aligned_save
operator|+
name|aligned_to_be_read
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|maxalloc_off
operator|&&
name|maxalloc_off
operator|==
operator|(
name|size_t
operator|)
name|maxalloc_off
condition|)
name|maxalloc
operator|=
name|maxalloc_off
expr_stmt|;
block|}
comment|/* Grow bufsalloc until it is at least as great as `save'; but 	 if there is an overflow, just grow it to the next page boundary.  */
while|while
condition|(
name|bufsalloc
operator|<
name|save
condition|)
if|if
condition|(
name|bufsalloc
operator|<
name|bufsalloc
operator|*
literal|2
condition|)
name|bufsalloc
operator|*=
literal|2
expr_stmt|;
else|else
block|{
name|bufsalloc
operator|=
name|aligned_save
expr_stmt|;
break|break;
block|}
comment|/* Grow the buffer size to be PREFERRED_SAVE_FACTOR times 	 bufsalloc....  */
name|newalloc
operator|=
name|PREFERRED_SAVE_FACTOR
operator|*
name|bufsalloc
expr_stmt|;
if|if
condition|(
name|maxalloc
operator|<
name|newalloc
condition|)
block|{
comment|/* ... except don't grow it more than a pagesize past the 	     file size, as that might cause unnecessary memory 	     exhaustion if the file is large.  */
name|newalloc
operator|=
name|maxalloc
expr_stmt|;
name|bufsalloc
operator|=
name|aligned_save
expr_stmt|;
block|}
comment|/* Check that the above calculations made progress, which might          not occur if there is arithmetic overflow.  If there's no 	 progress, or if the new buffer size is larger than the old 	 and buffer reallocation fails, report memory exhaustion.  */
if|if
condition|(
name|bufsalloc
operator|<
name|save
operator|||
name|newalloc
operator|<
name|save
operator|||
operator|(
name|newalloc
operator|==
name|save
operator|&&
name|newalloc
operator|!=
name|maxalloc
operator|)
operator|||
operator|(
name|bufalloc
operator|<
name|newalloc
operator|&&
operator|!
operator|(
name|buffer
operator|=
name|page_alloc
argument_list|(
operator|(
name|bufalloc
operator|=
name|newalloc
operator|)
operator|+
literal|1
argument_list|,
operator|&
name|ubuffer
argument_list|)
operator|)
operator|)
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"memory exhausted"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bufbeg
operator|=
name|buffer
operator|+
name|bufsalloc
operator|-
name|save
expr_stmt|;
name|memmove
argument_list|(
name|bufbeg
argument_list|,
name|ubuffer
operator|+
name|saved_offset
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|readsize
operator|=
name|bufalloc
operator|-
name|bufsalloc
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MMAP
argument_list|)
if|if
condition|(
name|bufmapped
condition|)
block|{
name|size_t
name|mmapsize
init|=
name|readsize
decl_stmt|;
comment|/* Don't mmap past the end of the file; some hosts don't allow this. 	 Use `read' on the last page.  */
if|if
condition|(
name|stats
operator|->
name|stat
operator|.
name|st_size
operator|-
name|bufoffset
operator|<
name|mmapsize
condition|)
block|{
name|mmapsize
operator|=
name|stats
operator|->
name|stat
operator|.
name|st_size
operator|-
name|bufoffset
expr_stmt|;
name|mmapsize
operator|-=
name|mmapsize
operator|%
name|pagesize
expr_stmt|;
block|}
if|if
condition|(
name|mmapsize
operator|&&
operator|(
name|mmap
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|buffer
operator|+
name|bufsalloc
argument_list|)
argument_list|,
name|mmapsize
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_FIXED
argument_list|,
name|bufdesc
argument_list|,
name|bufoffset
argument_list|)
operator|!=
operator|(
name|caddr_t
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* Do not bother to use madvise with MADV_SEQUENTIAL or 	     MADV_WILLNEED on the mmapped memory.  One might think it 	     would help, but it slows us down about 30% on SunOS 4.1.  */
name|fillsize
operator|=
name|mmapsize
expr_stmt|;
block|}
else|else
block|{
comment|/* Stop using mmap on this file.  Synchronize the file 	     offset.  Do not warn about mmap failures.  On some hosts 	     (e.g. Solaris 2.5) mmap can fail merely because some 	     other process has an advisory read lock on the file. 	     There's no point alarming the user about this misfeature.  */
name|bufmapped
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bufoffset
operator|!=
name|initial_bufoffset
operator|&&
name|lseek
argument_list|(
name|bufdesc
argument_list|,
name|bufoffset
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"lseek"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|cc
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/*HAVE_MMAP*/
if|if
condition|(
operator|!
name|fillsize
condition|)
block|{
name|ssize_t
name|bytesread
decl_stmt|;
do|do
if|#
directive|if
name|HAVE_LIBZ
operator|>
literal|0
if|if
condition|(
name|Zflag
condition|)
name|bytesread
operator|=
name|gzread
argument_list|(
name|gzbufdesc
argument_list|,
name|buffer
operator|+
name|bufsalloc
argument_list|,
name|readsize
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|bytesread
operator|=
name|read
argument_list|(
name|bufdesc
argument_list|,
name|buffer
operator|+
name|bufsalloc
argument_list|,
name|readsize
argument_list|)
expr_stmt|;
do|while
condition|(
name|bytesread
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|bytesread
operator|<
literal|0
condition|)
name|cc
operator|=
literal|0
expr_stmt|;
else|else
name|fillsize
operator|=
name|bytesread
expr_stmt|;
block|}
name|bufoffset
operator|+=
name|fillsize
expr_stmt|;
if|#
directive|if
name|O_BINARY
if|if
condition|(
name|fillsize
condition|)
name|fillsize
operator|=
name|undossify_input
argument_list|(
name|buffer
operator|+
name|bufsalloc
argument_list|,
name|fillsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buflim
operator|=
name|buffer
operator|+
name|bufsalloc
operator|+
name|fillsize
expr_stmt|;
return|return
name|cc
return|;
block|}
end_function

begin_comment
comment|/* Flags controlling the style of output. */
end_comment

begin_enum
specifier|static
enum|enum
block|{
name|BINARY_BINARY_FILES
block|,
name|TEXT_BINARY_FILES
block|,
name|WITHOUT_MATCH_BINARY_FILES
block|}
name|binary_files
enum|;
end_enum

begin_comment
comment|/* How to handle binary files.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|out_quiet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Suppress all normal output. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|out_invert
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print nonmatching stuff. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|out_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print filenames. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|out_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print line numbers. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|out_byte
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print byte offsets. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|out_before
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lines of leading context. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|out_after
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lines of trailing context. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|count_matches
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count matching lines.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|list_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List matching files.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_filenames
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Suppress file names.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|suppress_errors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Suppress diagnostics.  */
end_comment

begin_comment
comment|/* Internal variables to keep track of byte count, context, etc. */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|totalcc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total character count before bufbeg. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lastnl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer after last newline counted. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lastout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer after last character output; 				   NULL if no character has been output 				   or if it's conceptually before bufbeg. */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|totalnl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total newline count before lastnl. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pending lines of output. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|done_on_match
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stop scanning file on first match */
end_comment

begin_if
if|#
directive|if
name|O_BINARY
end_if

begin_include
include|#
directive|include
file|"dosbuf.c"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|nlscan
parameter_list|(
name|char
modifier|*
name|lim
parameter_list|)
block|{
name|char
modifier|*
name|beg
decl_stmt|;
for|for
control|(
name|beg
operator|=
name|lastnl
init|;
operator|(
name|beg
operator|=
name|memchr
argument_list|(
name|beg
argument_list|,
name|eolbyte
argument_list|,
name|lim
operator|-
name|beg
argument_list|)
operator|)
condition|;
name|beg
operator|++
control|)
name|totalnl
operator|++
expr_stmt|;
name|lastnl
operator|=
name|lim
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_offset_sep
parameter_list|(
name|off_t
name|pos
parameter_list|,
name|int
name|sep
parameter_list|)
block|{
comment|/* Do not rely on printf to print pos, since off_t may be longer than long,      and long long is not portable.  */
name|char
name|buf
index|[
sizeof|sizeof
name|pos
operator|*
name|CHAR_BIT
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
operator|+
sizeof|sizeof
name|buf
operator|-
literal|1
decl_stmt|;
operator|*
name|p
operator|=
name|sep
expr_stmt|;
do|do
operator|*
operator|--
name|p
operator|=
literal|'0'
operator|+
name|pos
operator|%
literal|10
expr_stmt|;
do|while
condition|(
operator|(
name|pos
operator|/=
literal|10
operator|)
operator|!=
literal|0
condition|)
do|;
name|fwrite
argument_list|(
name|p
argument_list|,
literal|1
argument_list|,
name|buf
operator|+
sizeof|sizeof
name|buf
operator|-
name|p
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|prline
parameter_list|(
name|char
modifier|*
name|beg
parameter_list|,
name|char
modifier|*
name|lim
parameter_list|,
name|int
name|sep
parameter_list|)
block|{
if|if
condition|(
name|out_file
condition|)
name|printf
argument_list|(
literal|"%s%c"
argument_list|,
name|filename
argument_list|,
name|sep
operator|&
name|filename_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_line
condition|)
block|{
name|nlscan
argument_list|(
name|beg
argument_list|)
expr_stmt|;
name|print_offset_sep
argument_list|(
operator|++
name|totalnl
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|lastnl
operator|=
name|lim
expr_stmt|;
block|}
if|if
condition|(
name|out_byte
condition|)
block|{
name|off_t
name|pos
init|=
name|totalcc
operator|+
operator|(
name|beg
operator|-
name|bufbeg
operator|)
decl_stmt|;
if|#
directive|if
name|O_BINARY
name|pos
operator|=
name|dossified_pos
argument_list|(
name|pos
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|print_offset_sep
argument_list|(
name|pos
argument_list|,
name|sep
argument_list|)
expr_stmt|;
block|}
name|fwrite
argument_list|(
name|beg
argument_list|,
literal|1
argument_list|,
name|lim
operator|-
name|beg
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"writing output"
argument_list|)
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|lastout
operator|=
name|lim
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print pending lines of trailing context prior to LIM. */
end_comment

begin_function
specifier|static
name|void
name|prpending
parameter_list|(
name|char
modifier|*
name|lim
parameter_list|)
block|{
name|char
modifier|*
name|nl
decl_stmt|;
if|if
condition|(
operator|!
name|lastout
condition|)
name|lastout
operator|=
name|bufbeg
expr_stmt|;
while|while
condition|(
name|pending
operator|>
literal|0
operator|&&
name|lastout
operator|<
name|lim
condition|)
block|{
operator|--
name|pending
expr_stmt|;
if|if
condition|(
operator|(
name|nl
operator|=
name|memchr
argument_list|(
name|lastout
argument_list|,
name|eolbyte
argument_list|,
name|lim
operator|-
name|lastout
argument_list|)
operator|)
operator|!=
literal|0
condition|)
operator|++
name|nl
expr_stmt|;
else|else
name|nl
operator|=
name|lim
expr_stmt|;
name|prline
argument_list|(
name|lastout
argument_list|,
name|nl
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the lines between BEG and LIM.  Deal with context crap.    If NLINESP is non-null, store a count of lines between BEG and LIM. */
end_comment

begin_function
specifier|static
name|void
name|prtext
parameter_list|(
name|char
modifier|*
name|beg
parameter_list|,
name|char
modifier|*
name|lim
parameter_list|,
name|int
modifier|*
name|nlinesp
parameter_list|)
block|{
specifier|static
name|int
name|used
decl_stmt|;
comment|/* avoid printing "--" before any output */
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|nl
decl_stmt|;
name|char
name|eol
init|=
name|eolbyte
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|out_quiet
operator|&&
name|pending
operator|>
literal|0
condition|)
name|prpending
argument_list|(
name|beg
argument_list|)
expr_stmt|;
name|p
operator|=
name|beg
expr_stmt|;
if|if
condition|(
operator|!
name|out_quiet
condition|)
block|{
comment|/* Deal with leading context crap. */
name|bp
operator|=
name|lastout
condition|?
name|lastout
else|:
name|bufbeg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|out_before
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|p
operator|>
name|bp
condition|)
do|do
operator|--
name|p
expr_stmt|;
do|while
condition|(
name|p
operator|>
name|bp
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
name|eol
condition|)
do|;
comment|/* We only print the "--" separator if our output is 	 discontiguous from the last output in the file. */
if|if
condition|(
operator|(
name|out_before
operator|||
name|out_after
operator|)
operator|&&
name|used
operator|&&
name|p
operator|!=
name|lastout
condition|)
name|puts
argument_list|(
literal|"--"
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|beg
condition|)
block|{
name|nl
operator|=
name|memchr
argument_list|(
name|p
argument_list|,
name|eol
argument_list|,
name|beg
operator|-
name|p
argument_list|)
expr_stmt|;
name|prline
argument_list|(
name|p
argument_list|,
name|nl
operator|+
literal|1
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
name|p
operator|=
name|nl
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nlinesp
condition|)
block|{
comment|/* Caller wants a line count. */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|p
operator|<
name|lim
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
operator|(
name|nl
operator|=
name|memchr
argument_list|(
name|p
argument_list|,
name|eol
argument_list|,
name|lim
operator|-
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
operator|++
name|nl
expr_stmt|;
else|else
name|nl
operator|=
name|lim
expr_stmt|;
if|if
condition|(
operator|!
name|out_quiet
condition|)
name|prline
argument_list|(
name|p
argument_list|,
name|nl
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|p
operator|=
name|nl
expr_stmt|;
block|}
operator|*
name|nlinesp
operator|=
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|out_quiet
condition|)
name|prline
argument_list|(
name|beg
argument_list|,
name|lim
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|pending
operator|=
name|out_quiet
condition|?
literal|0
else|:
name|out_after
expr_stmt|;
name|used
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan the specified portion of the buffer, matching lines (or    between matching lines if OUT_INVERT is true).  Return a count of    lines printed. */
end_comment

begin_function
specifier|static
name|int
name|grepbuf
parameter_list|(
name|char
modifier|*
name|beg
parameter_list|,
name|char
modifier|*
name|lim
parameter_list|)
block|{
name|int
name|nlines
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
name|char
name|eol
init|=
name|eolbyte
decl_stmt|;
name|nlines
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|beg
expr_stmt|;
while|while
condition|(
operator|(
name|b
operator|=
call|(
modifier|*
name|execute
call|)
argument_list|(
name|p
argument_list|,
name|lim
operator|-
name|p
argument_list|,
operator|&
name|endp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Avoid matching the empty line at the end of the buffer. */
if|if
condition|(
name|b
operator|==
name|lim
operator|&&
operator|(
operator|(
name|b
operator|>
name|beg
operator|&&
name|b
index|[
operator|-
literal|1
index|]
operator|==
name|eol
operator|)
operator|||
name|b
operator|==
name|beg
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|out_invert
condition|)
block|{
name|prtext
argument_list|(
name|b
argument_list|,
name|endp
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|nlines
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|done_on_match
condition|)
return|return
name|nlines
return|;
block|}
elseif|else
if|if
condition|(
name|p
operator|<
name|b
condition|)
block|{
name|prtext
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|nlines
operator|+=
name|n
expr_stmt|;
block|}
name|p
operator|=
name|endp
expr_stmt|;
block|}
if|if
condition|(
name|out_invert
operator|&&
name|p
operator|<
name|lim
condition|)
block|{
name|prtext
argument_list|(
name|p
argument_list|,
name|lim
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|nlines
operator|+=
name|n
expr_stmt|;
block|}
return|return
name|nlines
return|;
block|}
end_function

begin_comment
comment|/* Search a given file.  Normally, return a count of lines printed;    but if the file is a directory and we search it recursively, then    return -2 if there was a match, and -1 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|grep
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
specifier|const
modifier|*
name|file
parameter_list|,
name|struct
name|stats
modifier|*
name|stats
parameter_list|)
block|{
name|int
name|nlines
decl_stmt|,
name|i
decl_stmt|;
name|int
name|not_text
decl_stmt|;
name|size_t
name|residue
decl_stmt|,
name|save
decl_stmt|;
name|char
modifier|*
name|beg
decl_stmt|,
modifier|*
name|lim
decl_stmt|;
name|char
name|eol
init|=
name|eolbyte
decl_stmt|;
if|if
condition|(
operator|!
name|reset
argument_list|(
name|fd
argument_list|,
name|file
argument_list|,
name|stats
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|file
operator|&&
name|directories
operator|==
name|RECURSE_DIRECTORIES
operator|&&
name|S_ISDIR
argument_list|(
name|stats
operator|->
name|stat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* Close fd now, so that we don't open a lot of file descriptors 	 when we recurse deeply.  */
if|#
directive|if
name|HAVE_LIBZ
operator|>
literal|0
if|if
condition|(
name|Zflag
condition|)
name|gzclose
argument_list|(
name|gzbufdesc
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
name|file
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
name|grepdir
argument_list|(
name|file
argument_list|,
name|stats
argument_list|)
operator|-
literal|2
return|;
block|}
name|totalcc
operator|=
literal|0
expr_stmt|;
name|lastout
operator|=
literal|0
expr_stmt|;
name|totalnl
operator|=
literal|0
expr_stmt|;
name|pending
operator|=
literal|0
expr_stmt|;
name|nlines
operator|=
literal|0
expr_stmt|;
name|residue
operator|=
literal|0
expr_stmt|;
name|save
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|fillbuf
argument_list|(
name|save
argument_list|,
name|stats
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|is_EISDIR
argument_list|(
name|errno
argument_list|,
name|file
argument_list|)
operator|&&
name|suppress_errors
operator|)
condition|)
name|error
argument_list|(
name|filename
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|not_text
operator|=
operator|(
operator|(
operator|(
name|binary_files
operator|==
name|BINARY_BINARY_FILES
operator|&&
operator|!
name|out_quiet
operator|)
operator|||
name|binary_files
operator|==
name|WITHOUT_MATCH_BINARY_FILES
operator|)
operator|&&
name|memchr
argument_list|(
name|bufbeg
argument_list|,
name|eol
condition|?
literal|'\0'
else|:
literal|'\200'
argument_list|,
name|buflim
operator|-
name|bufbeg
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|not_text
operator|&&
name|binary_files
operator|==
name|WITHOUT_MATCH_BINARY_FILES
condition|)
return|return
literal|0
return|;
name|done_on_match
operator|+=
name|not_text
expr_stmt|;
name|out_quiet
operator|+=
name|not_text
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|lastnl
operator|=
name|bufbeg
expr_stmt|;
if|if
condition|(
name|lastout
condition|)
name|lastout
operator|=
name|bufbeg
expr_stmt|;
if|if
condition|(
name|buflim
operator|-
name|bufbeg
operator|==
name|save
condition|)
break|break;
name|beg
operator|=
name|bufbeg
operator|+
name|save
operator|-
name|residue
expr_stmt|;
for|for
control|(
name|lim
operator|=
name|buflim
init|;
name|lim
operator|>
name|beg
operator|&&
name|lim
index|[
operator|-
literal|1
index|]
operator|!=
name|eol
condition|;
operator|--
name|lim
control|)
empty_stmt|;
name|residue
operator|=
name|buflim
operator|-
name|lim
expr_stmt|;
if|if
condition|(
name|beg
operator|<
name|lim
condition|)
block|{
name|nlines
operator|+=
name|grepbuf
argument_list|(
name|beg
argument_list|,
name|lim
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending
condition|)
name|prpending
argument_list|(
name|lim
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlines
operator|&&
name|done_on_match
operator|&&
operator|!
name|out_invert
condition|)
goto|goto
name|finish_grep
goto|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|beg
operator|=
name|lim
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|out_before
operator|&&
name|beg
operator|>
name|bufbeg
operator|&&
name|beg
operator|!=
name|lastout
condition|)
block|{
operator|++
name|i
expr_stmt|;
do|do
operator|--
name|beg
expr_stmt|;
do|while
condition|(
name|beg
operator|>
name|bufbeg
operator|&&
name|beg
index|[
operator|-
literal|1
index|]
operator|!=
name|eol
condition|)
do|;
block|}
if|if
condition|(
name|beg
operator|!=
name|lastout
condition|)
name|lastout
operator|=
literal|0
expr_stmt|;
name|save
operator|=
name|residue
operator|+
name|lim
operator|-
name|beg
expr_stmt|;
name|totalcc
operator|+=
name|buflim
operator|-
name|bufbeg
operator|-
name|save
expr_stmt|;
if|if
condition|(
name|out_line
condition|)
name|nlscan
argument_list|(
name|beg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fillbuf
argument_list|(
name|save
argument_list|,
name|stats
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|is_EISDIR
argument_list|(
name|errno
argument_list|,
name|file
argument_list|)
operator|&&
name|suppress_errors
operator|)
condition|)
name|error
argument_list|(
name|filename
argument_list|,
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|finish_grep
goto|;
block|}
block|}
if|if
condition|(
name|residue
condition|)
block|{
operator|*
name|buflim
operator|++
operator|=
name|eol
expr_stmt|;
name|nlines
operator|+=
name|grepbuf
argument_list|(
name|bufbeg
operator|+
name|save
operator|-
name|residue
argument_list|,
name|buflim
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending
condition|)
name|prpending
argument_list|(
name|buflim
argument_list|)
expr_stmt|;
block|}
name|finish_grep
label|:
name|done_on_match
operator|-=
name|not_text
expr_stmt|;
name|out_quiet
operator|-=
name|not_text
expr_stmt|;
if|if
condition|(
operator|(
name|not_text
operator|&
operator|~
name|out_quiet
operator|)
operator|&&
name|nlines
operator|!=
literal|0
condition|)
name|printf
argument_list|(
name|_
argument_list|(
literal|"Binary file %s matches\n"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
name|nlines
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|grepfile
parameter_list|(
name|char
specifier|const
modifier|*
name|file
parameter_list|,
name|struct
name|stats
modifier|*
name|stats
parameter_list|)
block|{
name|int
name|desc
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
block|{
name|desc
operator|=
literal|0
expr_stmt|;
name|filename
operator|=
name|_
argument_list|(
literal|"(standard input)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|desc
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|is_EISDIR
argument_list|(
name|e
argument_list|,
name|file
argument_list|)
operator|&&
name|directories
operator|==
name|RECURSE_DIRECTORIES
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|stats
operator|->
name|stat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
name|file
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
name|grepdir
argument_list|(
name|file
argument_list|,
name|stats
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|suppress_errors
condition|)
block|{
if|if
condition|(
name|directories
operator|==
name|SKIP_DIRECTORIES
condition|)
switch|switch
condition|(
name|e
condition|)
block|{
ifdef|#
directive|ifdef
name|EISDIR
case|case
name|EISDIR
case|:
return|return
literal|1
return|;
endif|#
directive|endif
case|case
name|EACCES
case|:
comment|/* When skipping directories, don't worry about 		       directories that can't be opened.  */
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|stats
operator|->
name|stat
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|stats
operator|->
name|stat
operator|.
name|st_mode
argument_list|)
condition|)
return|return
literal|1
return|;
break|break;
block|}
name|error
argument_list|(
name|file
argument_list|,
name|e
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
name|filename
operator|=
name|file
expr_stmt|;
block|}
if|#
directive|if
name|O_BINARY
comment|/* Set input to binary mode.  Pipes are simulated with files      on DOS, so this includes the case of "foo | grep bar".  */
if|if
condition|(
operator|!
name|isatty
argument_list|(
name|desc
argument_list|)
condition|)
name|SET_BINARY
argument_list|(
name|desc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|count
operator|=
name|grep
argument_list|(
name|desc
argument_list|,
name|file
argument_list|,
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|status
operator|=
name|count
operator|+
literal|2
expr_stmt|;
else|else
block|{
if|if
condition|(
name|count_matches
condition|)
block|{
if|if
condition|(
name|out_file
condition|)
name|printf
argument_list|(
literal|"%s%c"
argument_list|,
name|filename
argument_list|,
literal|':'
operator|&
name|filename_mask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
operator|!
name|count
expr_stmt|;
if|if
condition|(
name|list_files
operator|==
literal|1
operator|-
literal|2
operator|*
name|status
condition|)
name|printf
argument_list|(
literal|"%s%c"
argument_list|,
name|filename
argument_list|,
literal|'\n'
operator|&
name|filename_mask
argument_list|)
expr_stmt|;
if|#
directive|if
name|HAVE_LIBZ
operator|>
literal|0
if|if
condition|(
name|Zflag
condition|)
name|gzclose
argument_list|(
name|gzbufdesc
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|file
condition|)
while|while
condition|(
name|close
argument_list|(
name|desc
argument_list|)
operator|!=
literal|0
condition|)
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|error
argument_list|(
name|file
argument_list|,
name|errno
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|grepdir
parameter_list|(
name|char
specifier|const
modifier|*
name|dir
parameter_list|,
name|struct
name|stats
modifier|*
name|stats
parameter_list|)
block|{
name|int
name|status
init|=
literal|1
decl_stmt|;
name|struct
name|stats
modifier|*
name|ancestor
decl_stmt|;
name|char
modifier|*
name|name_space
decl_stmt|;
for|for
control|(
name|ancestor
operator|=
name|stats
init|;
operator|(
name|ancestor
operator|=
name|ancestor
operator|->
name|parent
operator|)
operator|!=
literal|0
condition|;
control|)
if|if
condition|(
name|ancestor
operator|->
name|stat
operator|.
name|st_ino
operator|==
name|stats
operator|->
name|stat
operator|.
name|st_ino
operator|&&
name|ancestor
operator|->
name|stat
operator|.
name|st_dev
operator|==
name|stats
operator|->
name|stat
operator|.
name|st_dev
condition|)
block|{
if|if
condition|(
operator|!
name|suppress_errors
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: warning: %s: %s\n"
argument_list|)
argument_list|,
name|prog
argument_list|,
name|dir
argument_list|,
name|_
argument_list|(
literal|"recursive directory loop"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|name_space
operator|=
name|savedir
argument_list|(
name|dir
argument_list|,
operator|(
name|unsigned
operator|)
name|stats
operator|->
name|stat
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name_space
condition|)
block|{
if|if
condition|(
name|errno
condition|)
block|{
if|if
condition|(
operator|!
name|suppress_errors
condition|)
name|error
argument_list|(
name|dir
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
name|_
argument_list|(
literal|"Memory exhausted"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|dirlen
init|=
name|strlen
argument_list|(
name|dir
argument_list|)
decl_stmt|;
name|int
name|needs_slash
init|=
operator|!
operator|(
name|dirlen
operator|==
name|FILESYSTEM_PREFIX_LEN
argument_list|(
name|dir
argument_list|)
operator|||
name|IS_SLASH
argument_list|(
name|dir
index|[
name|dirlen
operator|-
literal|1
index|]
argument_list|)
operator|)
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|namep
init|=
name|name_space
decl_stmt|;
name|struct
name|stats
name|child
decl_stmt|;
name|child
operator|.
name|parent
operator|=
name|stats
expr_stmt|;
name|out_file
operator|+=
operator|!
name|no_filenames
expr_stmt|;
while|while
condition|(
operator|*
name|namep
condition|)
block|{
name|size_t
name|namelen
init|=
name|strlen
argument_list|(
name|namep
argument_list|)
decl_stmt|;
name|file
operator|=
name|xrealloc
argument_list|(
name|file
argument_list|,
name|dirlen
operator|+
literal|1
operator|+
name|namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|file
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|file
index|[
name|dirlen
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|file
operator|+
name|dirlen
operator|+
name|needs_slash
argument_list|,
name|namep
argument_list|)
expr_stmt|;
name|namep
operator|+=
name|namelen
operator|+
literal|1
expr_stmt|;
name|status
operator|&=
name|grepfile
argument_list|(
name|file
argument_list|,
operator|&
name|child
argument_list|)
expr_stmt|;
block|}
name|out_file
operator|-=
operator|!
name|no_filenames
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name_space
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|int
name|status
parameter_list|)
block|{
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Usage: %s [OPTION]... PATTERN [FILE]...\n"
argument_list|)
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Try `%s --help' for more information.\n"
argument_list|)
argument_list|,
name|prog
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"Usage: %s [OPTION]... PATTERN [FILE] ...\n"
argument_list|)
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ Search for PATTERN in each FILE or standard input.\n\ Example: %s -i 'hello world' menu.h main.c\n\ \n\ Regexp selection and interpretation:\n"
argument_list|)
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\   -E, --extended-regexp     PATTERN is an extended regular expression\n\   -F, --fixed-strings       PATTERN is a set of newline-separated strings\n\   -G, --basic-regexp        PATTERN is a basic regular expression\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\   -e, --regexp=PATTERN      use PATTERN as a regular expression\n\   -f, --file=FILE           obtain PATTERN from FILE\n\   -i, --ignore-case         ignore case distinctions\n\   -w, --word-regexp         force PATTERN to match only whole words\n\   -x, --line-regexp         force PATTERN to match only whole lines\n\   -z, --null-data           a data line ends in 0 byte, not newline\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ \n\ Miscellaneous:\n\   -s, --no-messages         suppress error messages\n\   -v, --invert-match        select non-matching lines\n\   -V, --version             print version information and exit\n\       --help                display this help and exit\n\   -Z, --decompress          decompress input before searching (HAVE_LIBZ=1)\n\       --mmap                use memory-mapped input if possible\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ \n\ Output control:\n\   -b, --byte-offset         print the byte offset with output lines\n\   -n, --line-number         print line number with output lines\n\   -H, --with-filename       print the filename for each match\n\   -h, --no-filename         suppress the prefixing filename on output\n\   -q, --quiet, --silent     suppress all normal output\n\       --binary-files=TYPE   assume that binary files are TYPE\n\                             TYPE is 'binary', 'text', or 'without-match'.\n\   -a, --text                equivalent to --binary-files=text\n\   -I                        equivalent to --binary-files=without-match\n\   -d, --directories=ACTION  how to handle directories\n\                             ACTION is 'read', 'recurse', or 'skip'.\n\   -r, --recursive           equivalent to --directories=recurse.\n\   -L, --files-without-match only print FILE names containing no match\n\   -l, --files-with-matches  only print FILE names containing matches\n\   -c, --count               only print a count of matching lines per FILE\n\       --null                print 0 byte after FILE name\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ \n\ Context control:\n\   -B, --before-context=NUM  print NUM lines of leading context\n\   -A, --after-context=NUM   print NUM lines of trailing context\n\   -C, --context[=NUM]       print NUM (default 2) lines of output context\n\                             unless overridden by -A or -B\n\   -NUM                      same as --context=NUM\n\   -U, --binary              do not strip CR characters at EOL (MSDOS)\n\   -u, --unix-byte-offsets   report offsets as if CRs were not there (MSDOS)\n\ \n\ `egrep' means `grep -E'.  `fgrep' means `grep -F'.\n\ With no FILE, or when FILE is -, read standard input.  If less than\n\ two FILEs given, assume -h.  Exit status is 0 if match, 1 if no match,\n\ and 2 if trouble.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\nReport bugs to<bug-gnu-utils@gnu.org>.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the matcher to M, reporting any conflicts.  */
end_comment

begin_function
specifier|static
name|void
name|setmatcher
parameter_list|(
name|char
specifier|const
modifier|*
name|m
parameter_list|)
block|{
if|if
condition|(
name|matcher
operator|&&
name|strcmp
argument_list|(
name|matcher
argument_list|,
name|m
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"conflicting matchers specified"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|matcher
operator|=
name|m
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Go through the matchers vector and look for the specified matcher.    If we find it, install it in compile and execute, and return 1.  */
end_comment

begin_function
specifier|static
name|int
name|install_matcher
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SETRLIMIT
name|struct
name|rlimit
name|rlim
decl_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|matchers
index|[
name|i
index|]
operator|.
name|name
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|matchers
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|compile
operator|=
name|matchers
index|[
name|i
index|]
operator|.
name|compile
expr_stmt|;
name|execute
operator|=
name|matchers
index|[
name|i
index|]
operator|.
name|execute
expr_stmt|;
if|#
directive|if
name|HAVE_SETRLIMIT
operator|&&
name|defined
argument_list|(
name|RLIMIT_STACK
argument_list|)
comment|/* I think every platform needs to do this, so that regex.c 	   doesn't oveflow the stack.  The default value of 	   `re_max_failures' is too large for some platforms: it needs 	   more than 3MB-large stack.  	   The test for HAVE_SETRLIMIT should go into `configure'.  */
if|if
condition|(
operator|!
name|getrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
condition|)
block|{
name|long
name|newlim
decl_stmt|;
specifier|extern
name|long
name|int
name|re_max_failures
decl_stmt|;
comment|/* from regex.c */
comment|/* Approximate the amount regex.c needs, plus some more.  */
name|newlim
operator|=
name|re_max_failures
operator|*
literal|2
operator|*
literal|20
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlim
operator|>
name|rlim
operator|.
name|rlim_max
condition|)
block|{
name|newlim
operator|=
name|rlim
operator|.
name|rlim_max
expr_stmt|;
name|re_max_failures
operator|=
name|newlim
operator|/
operator|(
literal|2
operator|*
literal|20
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|rlim
operator|.
name|rlim_cur
operator|<
name|newlim
condition|)
name|rlim
operator|.
name|rlim_cur
operator|=
name|newlim
expr_stmt|;
name|setrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find the white-space-separated options specified by OPTIONS, and    using BUF to store copies of these options, set ARGV[0], ARGV[1],    etc. to the option copies.  Return the number N of options found.    Do not set ARGV[N] to NULL.  If ARGV is NULL, do not store ARGV[0]    etc.  Backslash can be used to escape whitespace (and backslashes).  */
end_comment

begin_function
specifier|static
name|int
name|prepend_args
parameter_list|(
name|char
specifier|const
modifier|*
name|options
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|o
init|=
name|options
decl_stmt|;
name|char
modifier|*
name|b
init|=
name|buf
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|o
argument_list|)
condition|)
name|o
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|o
condition|)
return|return
name|n
return|;
if|if
condition|(
name|argv
condition|)
name|argv
index|[
name|n
index|]
operator|=
name|b
expr_stmt|;
name|n
operator|++
expr_stmt|;
do|do
if|if
condition|(
operator|(
operator|*
name|b
operator|++
operator|=
operator|*
name|o
operator|++
operator|)
operator|==
literal|'\\'
operator|&&
operator|*
name|o
condition|)
name|b
index|[
operator|-
literal|1
index|]
operator|=
operator|*
name|o
operator|++
expr_stmt|;
do|while
condition|(
operator|*
name|o
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|o
argument_list|)
condition|)
do|;
operator|*
name|b
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Prepend the whitespace-separated options in OPTIONS to the argument    vector of a main program with argument count *PARGC and argument    vector *PARGV.  */
end_comment

begin_function
specifier|static
name|void
name|prepend_default_options
parameter_list|(
name|char
specifier|const
modifier|*
name|options
parameter_list|,
name|int
modifier|*
name|pargc
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|pargv
parameter_list|)
block|{
if|if
condition|(
name|options
condition|)
block|{
name|char
modifier|*
name|buf
init|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|options
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|prepended
init|=
name|prepend_args
argument_list|(
name|options
argument_list|,
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
decl_stmt|;
name|int
name|argc
init|=
operator|*
name|pargc
decl_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|argv
init|=
operator|*
name|pargv
decl_stmt|;
name|char
modifier|*
modifier|*
name|pp
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|prepended
operator|+
name|argc
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|pp
argument_list|)
decl_stmt|;
operator|*
name|pargc
operator|=
name|prepended
operator|+
name|argc
expr_stmt|;
operator|*
name|pargv
operator|=
name|pp
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|pp
operator|+=
name|prepend_args
argument_list|(
name|options
argument_list|,
name|buf
argument_list|,
name|pp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|pp
operator|++
operator|=
operator|*
name|argv
operator|++
operator|)
condition|)
continue|continue;
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|keys
decl_stmt|;
name|size_t
name|keycc
decl_stmt|,
name|oldcc
decl_stmt|,
name|keyalloc
decl_stmt|;
name|int
name|with_filenames
decl_stmt|;
name|int
name|opt
decl_stmt|,
name|cc
decl_stmt|,
name|status
decl_stmt|;
name|int
name|default_context
decl_stmt|;
name|unsigned
name|digit_args_val
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
name|initialize_main
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|prog
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|prog
operator|&&
name|strrchr
argument_list|(
name|prog
argument_list|,
literal|'/'
argument_list|)
condition|)
name|prog
operator|=
name|strrchr
argument_list|(
name|prog
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
if|#
directive|if
name|HAVE_LIBZ
operator|>
literal|0
if|if
condition|(
name|prog
index|[
literal|0
index|]
operator|==
literal|'z'
condition|)
block|{
name|Zflag
operator|=
literal|1
expr_stmt|;
operator|++
name|prog
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
operator|||
name|defined
argument_list|(
name|_WIN32
argument_list|)
comment|/* DOS and MS-Windows use backslashes as directory separators, and usually      have an .exe suffix.  They also have case-insensitive filesystems.  */
if|if
condition|(
name|prog
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|prog
decl_stmt|;
name|char
modifier|*
name|bslash
init|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'\\'
argument_list|)
decl_stmt|;
if|if
condition|(
name|bslash
operator|&&
name|bslash
operator|>=
name|prog
condition|)
comment|/* for mixed forward/backslash case */
name|prog
operator|=
name|bslash
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|prog
operator|==
name|argv
index|[
literal|0
index|]
operator|&&
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|&&
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
comment|/* "c:progname" */
name|prog
operator|=
name|argv
index|[
literal|0
index|]
operator|+
literal|2
expr_stmt|;
comment|/* Collapse the letter-case, so `strcmp' could be used hence.  */
for|for
control|(
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'Z'
condition|)
operator|*
name|p
operator|+=
literal|'a'
operator|-
literal|'A'
expr_stmt|;
comment|/* Remove the .exe extension, if any.  */
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|prog
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|&&
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".exe"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
name|keys
operator|=
name|NULL
expr_stmt|;
name|keycc
operator|=
literal|0
expr_stmt|;
name|with_filenames
operator|=
literal|0
expr_stmt|;
name|eolbyte
operator|=
literal|'\n'
expr_stmt|;
name|filename_mask
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* The value -1 means to use DEFAULT_CONTEXT. */
name|out_after
operator|=
name|out_before
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Default before/after context: chaged by -C/-NUM options */
name|default_context
operator|=
literal|0
expr_stmt|;
comment|/* Accumulated value of individual digits in a -NUM option */
name|digit_args_val
operator|=
literal|0
expr_stmt|;
comment|/* Internationalization. */
if|#
directive|if
name|HAVE_SETLOCALE
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|ENABLE_NLS
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|prepend_default_options
argument_list|(
name|getenv
argument_list|(
literal|"GREP_OPTIONS"
argument_list|)
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|short_options
argument_list|,
name|long_options
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|digit_args_val
operator|=
literal|10
operator|*
name|digit_args_val
operator|+
name|opt
operator|-
literal|'0'
expr_stmt|;
name|default_context
operator|=
name|digit_args_val
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
if|if
condition|(
name|optarg
condition|)
block|{
if|if
condition|(
name|ck_atoi
argument_list|(
name|optarg
argument_list|,
operator|&
name|out_after
argument_list|)
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"invalid context length argument"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'B'
case|:
if|if
condition|(
name|optarg
condition|)
block|{
if|if
condition|(
name|ck_atoi
argument_list|(
name|optarg
argument_list|,
operator|&
name|out_before
argument_list|)
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"invalid context length argument"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
comment|/* Set output match context, but let any explicit leading or 	   trailing amount specified with -A or -B stand. */
if|if
condition|(
name|optarg
condition|)
block|{
if|if
condition|(
name|ck_atoi
argument_list|(
name|optarg
argument_list|,
operator|&
name|default_context
argument_list|)
condition|)
name|fatal
argument_list|(
name|_
argument_list|(
literal|"invalid context length argument"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|default_context
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|setmatcher
argument_list|(
literal|"egrep"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|setmatcher
argument_list|(
literal|"fgrep"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|setmatcher
argument_list|(
literal|"grep"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|with_filenames
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|binary_files
operator|=
name|WITHOUT_MATCH_BINARY_FILES
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
if|#
directive|if
name|O_BINARY
name|dos_use_file_type
operator|=
name|DOS_BINARY
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'u'
case|:
if|#
directive|if
name|O_BINARY
name|dos_report_unix_offset
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'V'
case|:
name|show_version
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|setmatcher
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|binary_files
operator|=
name|TEXT_BINARY_FILES
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|out_byte
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|out_quiet
operator|=
literal|1
expr_stmt|;
name|count_matches
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"read"
argument_list|)
operator|==
literal|0
condition|)
name|directories
operator|=
name|READ_DIRECTORIES
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"skip"
argument_list|)
operator|==
literal|0
condition|)
name|directories
operator|=
name|SKIP_DIRECTORIES
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"recurse"
argument_list|)
operator|==
literal|0
condition|)
name|directories
operator|=
name|RECURSE_DIRECTORIES
expr_stmt|;
else|else
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unknown directories method"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|cc
operator|=
name|strlen
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|keys
operator|=
name|xrealloc
argument_list|(
name|keys
argument_list|,
name|keycc
operator|+
name|cc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|keys
index|[
name|keycc
index|]
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|keycc
operator|+=
name|cc
expr_stmt|;
name|keys
index|[
name|keycc
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fp
operator|=
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
condition|?
name|fopen
argument_list|(
name|optarg
argument_list|,
literal|"r"
argument_list|)
else|:
name|stdin
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
name|fatal
argument_list|(
name|optarg
argument_list|,
name|errno
argument_list|)
expr_stmt|;
for|for
control|(
name|keyalloc
operator|=
literal|1
init|;
name|keyalloc
operator|<=
name|keycc
operator|+
literal|1
condition|;
name|keyalloc
operator|*=
literal|2
control|)
empty_stmt|;
name|keys
operator|=
name|xrealloc
argument_list|(
name|keys
argument_list|,
name|keyalloc
argument_list|)
expr_stmt|;
name|oldcc
operator|=
name|keycc
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
operator|&&
operator|(
name|cc
operator|=
name|fread
argument_list|(
name|keys
operator|+
name|keycc
argument_list|,
literal|1
argument_list|,
name|keyalloc
operator|-
literal|1
operator|-
name|keycc
argument_list|,
name|fp
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|keycc
operator|+=
name|cc
expr_stmt|;
if|if
condition|(
name|keycc
operator|==
name|keyalloc
operator|-
literal|1
condition|)
name|keys
operator|=
name|xrealloc
argument_list|(
name|keys
argument_list|,
name|keyalloc
operator|*=
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Append final newline if file ended in non-newline. */
if|if
condition|(
name|oldcc
operator|!=
name|keycc
operator|&&
name|keys
index|[
name|keycc
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|keys
index|[
name|keycc
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|no_filenames
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'y'
case|:
comment|/* For old-timers . . . */
name|match_icase
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Like -l, except list files that don't contain matches. 	   Inspired by the same option in Hume's gre. */
name|out_quiet
operator|=
literal|1
expr_stmt|;
name|list_files
operator|=
operator|-
literal|1
expr_stmt|;
name|done_on_match
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|out_quiet
operator|=
literal|1
expr_stmt|;
name|list_files
operator|=
literal|1
expr_stmt|;
name|done_on_match
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|out_line
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|done_on_match
operator|=
literal|1
expr_stmt|;
name|out_quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
case|case
literal|'r'
case|:
name|directories
operator|=
name|RECURSE_DIRECTORIES
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|suppress_errors
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|out_invert
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|match_words
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|match_lines
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
if|#
directive|if
name|HAVE_LIBZ
operator|>
literal|0
name|Zflag
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|filename_mask
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'z'
case|:
name|eolbyte
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|BINARY_FILES_OPTION
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"binary"
argument_list|)
operator|==
literal|0
condition|)
name|binary_files
operator|=
name|BINARY_BINARY_FILES
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"text"
argument_list|)
operator|==
literal|0
condition|)
name|binary_files
operator|=
name|TEXT_BINARY_FILES
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"without-match"
argument_list|)
operator|==
literal|0
condition|)
name|binary_files
operator|=
name|WITHOUT_MATCH_BINARY_FILES
expr_stmt|;
else|else
name|fatal
argument_list|(
name|_
argument_list|(
literal|"unknown binary-files type"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* long options */
break|break;
default|default:
name|usage
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|out_after
operator|<
literal|0
condition|)
name|out_after
operator|=
name|default_context
expr_stmt|;
if|if
condition|(
name|out_before
operator|<
literal|0
condition|)
name|out_before
operator|=
name|default_context
expr_stmt|;
if|if
condition|(
operator|!
name|matcher
condition|)
name|matcher
operator|=
name|prog
expr_stmt|;
if|if
condition|(
name|show_version
condition|)
block|{
name|printf
argument_list|(
name|_
argument_list|(
literal|"%s (GNU grep) %s\n"
argument_list|)
argument_list|,
name|matcher
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ Copyright (C) 1988, 1992-1998, 1999 Free Software Foundation, Inc.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|_
argument_list|(
literal|"\ This is free software; see the source for copying conditions. There is NO\n\ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|show_help
condition|)
name|usage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|keys
condition|)
block|{
if|if
condition|(
name|keycc
operator|==
literal|0
condition|)
comment|/* No keys were specified (e.g. -f /dev/null).  Match nothing.  */
name|out_invert
operator|^=
literal|1
expr_stmt|;
else|else
comment|/* Strip trailing newline. */
operator|--
name|keycc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|keys
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
name|keycc
operator|=
name|strlen
argument_list|(
name|keys
argument_list|)
expr_stmt|;
block|}
else|else
name|usage
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|install_matcher
argument_list|(
name|matcher
argument_list|)
operator|&&
operator|!
name|install_matcher
argument_list|(
literal|"default"
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
call|(
modifier|*
name|compile
call|)
argument_list|(
name|keys
argument_list|,
name|keycc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|argc
operator|-
name|optind
operator|>
literal|1
operator|&&
operator|!
name|no_filenames
operator|)
operator|||
name|with_filenames
condition|)
name|out_file
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|O_BINARY
comment|/* Output is set to binary mode because we shouldn't convert      NL to CR-LF pairs, especially when grepping binary files.  */
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|1
argument_list|)
condition|)
name|SET_BINARY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|status
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|char
modifier|*
name|file
init|=
name|argv
index|[
name|optind
index|]
decl_stmt|;
name|status
operator|&=
name|grepfile
argument_list|(
name|strcmp
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|?
operator|(
name|char
operator|*
operator|)
name|NULL
else|:
name|file
argument_list|,
operator|&
name|stats_base
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|optind
operator|<
name|argc
condition|)
do|;
block|}
else|else
name|status
operator|=
name|grepfile
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|stats_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|stdout
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"writing output"
argument_list|)
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|errseen
condition|?
literal|2
else|:
name|status
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

