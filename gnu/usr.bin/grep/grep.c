begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* grep.c - main driver file for grep.    Copyright (C) 1992 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     Written July 1992 by Mike Haertel.  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|errno
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|STDC_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_STRING_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_MEMORY_H
end_ifdef

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function_decl
specifier|extern
name|void
modifier|*
name|memchr
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|char
modifier|*
name|memchr
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|strrchr
value|rindex
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_define
define|#
directive|define
name|STDIN_FILENO
value|0
end_define

begin_decl_stmt
specifier|extern
name|int
name|open
argument_list|()
decl_stmt|,
name|read
argument_list|()
decl_stmt|,
name|close
argument_list|()
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"getpagesize.h"
end_include

begin_include
include|#
directive|include
file|"grep.h"
end_include

begin_undef
undef|#
directive|undef
name|MAX
end_undef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)> (B) ? (A) : (B))
end_define

begin_comment
comment|/* Provide missing ANSI features if necessary. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRERROR
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|strerror
parameter_list|(
name|E
parameter_list|)
value|((E)< sys_nerr ? sys_errlist[(E)] : "bogus error number")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_MEMCHR
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|VOID
value|void
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VOID
value|char
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|VOID
modifier|*
name|memchr
parameter_list|(
name|vp
parameter_list|,
name|c
parameter_list|,
name|n
parameter_list|)
name|VOID
modifier|*
name|vp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|size_t
name|n
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|vp
init|;
name|n
operator|--
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
name|c
condition|)
return|return
operator|(
name|VOID
operator|*
operator|)
name|p
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* traverse a file hierarchy library */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FTS
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fts.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* don't search in binary files */
end_comment

begin_decl_stmt
name|int
name|aflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define flags declared in grep.h. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|matcher
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|match_icase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|match_words
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|match_lines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions we'll use to search. */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|compile
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
function_decl|(
modifier|*
name|execute
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* For error messages. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|errseen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print a message and possibly an error string.  Remember    that something awful happened. */
end_comment

begin_function
specifier|static
name|void
name|error
parameter_list|(
name|mesg
parameter_list|,
name|errnum
parameter_list|)
ifdef|#
directive|ifdef
name|__STDC__
specifier|const
endif|#
directive|endif
name|char
modifier|*
name|mesg
decl_stmt|;
name|int
name|errnum
decl_stmt|;
block|{
if|if
condition|(
name|errnum
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: %s\n"
argument_list|,
name|prog
argument_list|,
name|mesg
argument_list|,
name|strerror
argument_list|(
name|errnum
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|prog
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
name|errseen
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like error(), but die horribly after printing. */
end_comment

begin_function
name|void
name|fatal
parameter_list|(
name|mesg
parameter_list|,
name|errnum
parameter_list|)
ifdef|#
directive|ifdef
name|__STDC__
specifier|const
endif|#
directive|endif
name|char
modifier|*
name|mesg
decl_stmt|;
name|int
name|errnum
decl_stmt|;
block|{
name|error
argument_list|(
name|mesg
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Interface to handle errors and fix library lossage. */
end_comment

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|&&
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"memory exhausted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Interface to handle errors and fix some library lossage. */
end_comment

begin_function
name|char
modifier|*
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|ptr
condition|)
name|result
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|&&
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"memory exhausted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_VALLOC
argument_list|)
end_if

begin_define
define|#
directive|define
name|valloc
value|malloc
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function_decl
specifier|extern
name|void
modifier|*
name|valloc
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|char
modifier|*
name|valloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Hairy buffering mechanism for grep.  The intent is to keep    all reads aligned on a page boundary and multiples of the    page size. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Base of buffer. */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|bufsalloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocated size of buffer save region. */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|bufalloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total buffer size. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bufdesc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File descriptor. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bufbeg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Beginning of user-visible stuff. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buflim
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Limit of user-visible stuff. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_WORKING_MMAP
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|bufmapped
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True for ordinary files. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|stat
name|bufstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From fstat(). */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|bufoffset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What read() normally remembers. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Reset the buffer for a new file.  Initialize    on the first time through. */
end_comment

begin_function
name|void
name|reset
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
specifier|static
name|int
name|initialized
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|initialized
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|BUFSALLOC
name|bufsalloc
operator|=
name|MAX
argument_list|(
literal|8192
argument_list|,
name|getpagesize
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|bufsalloc
operator|=
name|BUFSALLOC
expr_stmt|;
endif|#
directive|endif
name|bufalloc
operator|=
literal|5
operator|*
name|bufsalloc
expr_stmt|;
comment|/* The 1 byte of overflow is a kludge for dfaexec(), which 	 inserts a sentinel newline at the end of the buffer 	 being searched.  There's gotta be a better way... */
name|buffer
operator|=
name|valloc
argument_list|(
name|bufalloc
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
name|fatal
argument_list|(
literal|"memory exhausted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bufbeg
operator|=
name|buffer
expr_stmt|;
name|buflim
operator|=
name|buffer
expr_stmt|;
block|}
name|bufdesc
operator|=
name|fd
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_WORKING_MMAP
argument_list|)
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|bufstat
argument_list|)
operator|<
literal|0
operator|||
operator|!
name|S_ISREG
argument_list|(
name|bufstat
operator|.
name|st_mode
argument_list|)
condition|)
name|bufmapped
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|bufmapped
operator|=
literal|1
expr_stmt|;
name|bufoffset
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Read new stuff into the buffer, saving the specified    amount of old stuff.  When we're done, 'bufbeg' points    to the beginning of the buffer contents, and 'buflim'    points just after the end.  Return count of new stuff. */
end_comment

begin_function
specifier|static
name|int
name|fillbuf
parameter_list|(
name|save
parameter_list|)
name|size_t
name|save
decl_stmt|;
block|{
name|char
modifier|*
name|nbuffer
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|int
name|cc
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_WORKING_MMAP
argument_list|)
name|caddr_t
name|maddr
decl_stmt|;
endif|#
directive|endif
specifier|static
name|int
name|pagesize
decl_stmt|;
if|if
condition|(
name|pagesize
operator|==
literal|0
operator|&&
operator|(
name|pagesize
operator|=
name|getpagesize
argument_list|()
operator|)
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|save
operator|>
name|bufsalloc
condition|)
block|{
while|while
condition|(
name|save
operator|>
name|bufsalloc
condition|)
name|bufsalloc
operator|*=
literal|2
expr_stmt|;
name|bufalloc
operator|=
literal|5
operator|*
name|bufsalloc
expr_stmt|;
name|nbuffer
operator|=
name|valloc
argument_list|(
name|bufalloc
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nbuffer
condition|)
name|fatal
argument_list|(
literal|"memory exhausted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|nbuffer
operator|=
name|buffer
expr_stmt|;
name|sp
operator|=
name|buflim
operator|-
name|save
expr_stmt|;
name|dp
operator|=
name|nbuffer
operator|+
name|bufsalloc
operator|-
name|save
expr_stmt|;
name|bufbeg
operator|=
name|dp
expr_stmt|;
while|while
condition|(
name|save
operator|--
condition|)
operator|*
name|dp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* We may have allocated a new, larger buffer.  Since      there is no portable vfree(), we just have to forget      about the old one.  Sorry. */
name|buffer
operator|=
name|nbuffer
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_WORKING_MMAP
argument_list|)
if|if
condition|(
name|bufmapped
operator|&&
name|bufoffset
operator|%
name|pagesize
operator|==
literal|0
operator|&&
name|bufstat
operator|.
name|st_size
operator|-
name|bufoffset
operator|>=
name|bufalloc
operator|-
name|bufsalloc
condition|)
block|{
name|maddr
operator|=
name|buffer
operator|+
name|bufsalloc
expr_stmt|;
name|maddr
operator|=
name|mmap
argument_list|(
name|maddr
argument_list|,
name|bufalloc
operator|-
name|bufsalloc
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_FIXED
argument_list|,
name|bufdesc
argument_list|,
name|bufoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|maddr
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: warning: %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|tryread
goto|;
block|}
if|#
directive|if
literal|0
comment|/* You might thing this (or MADV_WILLNEED) would help, 	 but it doesn't, at least not on a Sun running 4.1. 	 In fact, it actually slows us down about 30%! */
block|madvise(maddr, bufalloc - bufsalloc, MADV_SEQUENTIAL);
endif|#
directive|endif
name|cc
operator|=
name|bufalloc
operator|-
name|bufsalloc
expr_stmt|;
name|bufoffset
operator|+=
name|cc
expr_stmt|;
block|}
else|else
block|{
name|tryread
label|:
comment|/* We come here when we're not going to use mmap() any more. 	 Note that we need to synchronize the file offset the 	 first time through. */
if|if
condition|(
name|bufmapped
condition|)
block|{
name|bufmapped
operator|=
literal|0
expr_stmt|;
name|lseek
argument_list|(
name|bufdesc
argument_list|,
name|bufoffset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|cc
operator|=
name|read
argument_list|(
name|bufdesc
argument_list|,
name|buffer
operator|+
name|bufsalloc
argument_list|,
name|bufalloc
operator|-
name|bufsalloc
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|cc
operator|=
name|read
argument_list|(
name|bufdesc
argument_list|,
name|buffer
operator|+
name|bufsalloc
argument_list|,
name|bufalloc
operator|-
name|bufsalloc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cc
operator|>
literal|0
condition|)
name|buflim
operator|=
name|buffer
operator|+
name|bufsalloc
operator|+
name|cc
expr_stmt|;
else|else
name|buflim
operator|=
name|buffer
operator|+
name|bufsalloc
expr_stmt|;
return|return
name|cc
return|;
block|}
end_function

begin_comment
comment|/* Flags controlling the style of output. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|out_quiet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Suppress all normal output. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|out_invert
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print nonmatching stuff. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|out_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print filenames. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|out_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print line numbers. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|out_byte
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print byte offsets. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|out_before
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lines of leading context. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|out_after
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lines of trailing context. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|count_matches
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print a count of matching lines */
end_comment

begin_comment
comment|/* Internal variables to keep track of byte count, context, etc. */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|totalcc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total character count before bufbeg. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lastnl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer after last newline counted. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lastout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer after last character output; 				   NULL if no character has been output 				   or if it's conceptually before bufbeg. */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|totalnl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total newline count before lastnl. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pending lines of output. */
end_comment

begin_function
specifier|static
name|void
name|nlscan
parameter_list|(
name|lim
parameter_list|)
name|char
modifier|*
name|lim
decl_stmt|;
block|{
name|char
modifier|*
name|beg
decl_stmt|;
for|for
control|(
name|beg
operator|=
name|lastnl
init|;
name|beg
operator|<
name|lim
condition|;
operator|++
name|beg
control|)
if|if
condition|(
operator|*
name|beg
operator|==
literal|'\n'
condition|)
operator|++
name|totalnl
expr_stmt|;
name|lastnl
operator|=
name|beg
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|prline
parameter_list|(
name|beg
parameter_list|,
name|lim
parameter_list|,
name|sep
parameter_list|)
name|char
modifier|*
name|beg
decl_stmt|;
name|char
modifier|*
name|lim
decl_stmt|;
name|char
name|sep
decl_stmt|;
block|{
if|if
condition|(
name|out_file
condition|)
name|printf
argument_list|(
literal|"%s%c"
argument_list|,
name|filename
argument_list|,
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_line
condition|)
block|{
name|nlscan
argument_list|(
name|beg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d%c"
argument_list|,
operator|++
name|totalnl
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|lastnl
operator|=
name|lim
expr_stmt|;
block|}
if|if
condition|(
name|out_byte
condition|)
name|printf
argument_list|(
literal|"%lu%c"
argument_list|,
name|totalcc
operator|+
operator|(
name|beg
operator|-
name|bufbeg
operator|)
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|beg
argument_list|,
literal|1
argument_list|,
name|lim
operator|-
name|beg
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|error
argument_list|(
literal|"writing output"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|lastout
operator|=
name|lim
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print pending lines of trailing context prior to LIM. */
end_comment

begin_function
specifier|static
name|void
name|prpending
parameter_list|(
name|lim
parameter_list|)
name|char
modifier|*
name|lim
decl_stmt|;
block|{
name|char
modifier|*
name|nl
decl_stmt|;
if|if
condition|(
operator|!
name|lastout
condition|)
name|lastout
operator|=
name|bufbeg
expr_stmt|;
while|while
condition|(
name|pending
operator|>
literal|0
operator|&&
name|lastout
operator|<
name|lim
condition|)
block|{
operator|--
name|pending
expr_stmt|;
if|if
condition|(
operator|(
name|nl
operator|=
name|memchr
argument_list|(
name|lastout
argument_list|,
literal|'\n'
argument_list|,
name|lim
operator|-
name|lastout
argument_list|)
operator|)
operator|!=
literal|0
condition|)
operator|++
name|nl
expr_stmt|;
else|else
name|nl
operator|=
name|lim
expr_stmt|;
name|prline
argument_list|(
name|lastout
argument_list|,
name|nl
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the lines between BEG and LIM.  Deal with context crap.    If NLINESP is non-null, store a count of lines between BEG and LIM. */
end_comment

begin_function
specifier|static
name|void
name|prtext
parameter_list|(
name|beg
parameter_list|,
name|lim
parameter_list|,
name|nlinesp
parameter_list|)
name|char
modifier|*
name|beg
decl_stmt|;
name|char
modifier|*
name|lim
decl_stmt|;
name|int
modifier|*
name|nlinesp
decl_stmt|;
block|{
specifier|static
name|int
name|used
decl_stmt|;
comment|/* avoid printing "--" before any output */
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|nl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|out_quiet
operator|&&
name|pending
operator|>
literal|0
condition|)
name|prpending
argument_list|(
name|beg
argument_list|)
expr_stmt|;
name|p
operator|=
name|beg
expr_stmt|;
if|if
condition|(
operator|!
name|out_quiet
condition|)
block|{
comment|/* Deal with leading context crap. */
name|bp
operator|=
name|lastout
condition|?
name|lastout
else|:
name|bufbeg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|out_before
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|p
operator|>
name|bp
condition|)
do|do
operator|--
name|p
expr_stmt|;
do|while
condition|(
name|p
operator|>
name|bp
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
do|;
comment|/* We only print the "--" separator if our output is 	 discontiguous from the last output in the file. */
if|if
condition|(
operator|(
name|out_before
operator|||
name|out_after
operator|)
operator|&&
name|used
operator|&&
name|p
operator|!=
name|lastout
condition|)
name|puts
argument_list|(
literal|"--"
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|beg
condition|)
block|{
name|nl
operator|=
name|memchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|,
name|beg
operator|-
name|p
argument_list|)
expr_stmt|;
name|prline
argument_list|(
name|p
argument_list|,
name|nl
operator|+
literal|1
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
name|p
operator|=
name|nl
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nlinesp
condition|)
block|{
comment|/* Caller wants a line count. */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|p
operator|<
name|lim
condition|;
operator|++
name|n
control|)
block|{
if|if
condition|(
operator|(
name|nl
operator|=
name|memchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|,
name|lim
operator|-
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
operator|++
name|nl
expr_stmt|;
else|else
name|nl
operator|=
name|lim
expr_stmt|;
if|if
condition|(
operator|!
name|out_quiet
condition|)
name|prline
argument_list|(
name|p
argument_list|,
name|nl
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|p
operator|=
name|nl
expr_stmt|;
block|}
operator|*
name|nlinesp
operator|=
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|out_quiet
condition|)
name|prline
argument_list|(
name|beg
argument_list|,
name|lim
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|pending
operator|=
name|out_after
expr_stmt|;
name|used
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan the specified portion of the buffer, matching lines (or    between matching lines if OUT_INVERT is true).  Return a count of    lines printed. */
end_comment

begin_function
specifier|static
name|int
name|grepbuf
parameter_list|(
name|beg
parameter_list|,
name|lim
parameter_list|)
name|char
modifier|*
name|beg
decl_stmt|;
name|char
modifier|*
name|lim
decl_stmt|;
block|{
name|int
name|nlines
decl_stmt|,
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
name|nlines
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|beg
expr_stmt|;
while|while
condition|(
operator|(
name|b
operator|=
call|(
modifier|*
name|execute
call|)
argument_list|(
name|p
argument_list|,
name|lim
operator|-
name|p
argument_list|,
operator|&
name|endp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Avoid matching the empty line at the end of the buffer. */
if|if
condition|(
name|b
operator|==
name|lim
operator|&&
operator|(
operator|(
name|b
operator|>
name|beg
operator|&&
name|b
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
operator|||
name|b
operator|==
name|beg
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|out_invert
condition|)
block|{
name|prtext
argument_list|(
name|b
argument_list|,
name|endp
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|nlines
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|<
name|b
condition|)
block|{
name|prtext
argument_list|(
name|p
argument_list|,
name|b
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|nlines
operator|+=
name|n
expr_stmt|;
block|}
name|p
operator|=
name|endp
expr_stmt|;
block|}
if|if
condition|(
name|out_invert
operator|&&
name|p
operator|<
name|lim
condition|)
block|{
name|prtext
argument_list|(
name|p
argument_list|,
name|lim
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|nlines
operator|+=
name|n
expr_stmt|;
block|}
return|return
name|nlines
return|;
block|}
end_function

begin_comment
comment|/*  * try to guess if fd belong to a binary file   */
end_comment

begin_function
name|int
name|isBinaryFile
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
define|#
directive|define
name|BINARY_BUF_LEN
value|32
specifier|static
name|unsigned
name|char
name|buf
index|[
name|BINARY_BUF_LEN
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
comment|/* pipe, socket, fifo */
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|(
name|off_t
operator|)
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|n
operator|=
operator|(
name|int
operator|)
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|BINARY_BUF_LEN
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* look for non-printable chars */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|isprint
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|isspace
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* reset fd to begin of file */
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|(
name|off_t
operator|)
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search a given file.  Return a count of lines printed. */
end_comment

begin_function
specifier|static
name|int
name|grep
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|int
name|nlines
decl_stmt|,
name|i
decl_stmt|;
name|size_t
name|residue
decl_stmt|,
name|save
decl_stmt|;
name|char
modifier|*
name|beg
decl_stmt|,
modifier|*
name|lim
decl_stmt|;
comment|/* skip binary files */
if|if
condition|(
name|aflag
operator|&&
name|isBinaryFile
argument_list|(
name|fd
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|reset
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|totalcc
operator|=
literal|0
expr_stmt|;
name|lastout
operator|=
literal|0
expr_stmt|;
name|totalnl
operator|=
literal|0
expr_stmt|;
name|pending
operator|=
literal|0
expr_stmt|;
name|nlines
operator|=
literal|0
expr_stmt|;
name|residue
operator|=
literal|0
expr_stmt|;
name|save
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|fillbuf
argument_list|(
name|save
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
name|filename
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
name|nlines
return|;
block|}
name|lastnl
operator|=
name|bufbeg
expr_stmt|;
if|if
condition|(
name|lastout
condition|)
name|lastout
operator|=
name|bufbeg
expr_stmt|;
if|if
condition|(
name|buflim
operator|-
name|bufbeg
operator|==
name|save
condition|)
break|break;
name|beg
operator|=
name|bufbeg
operator|+
name|save
operator|-
name|residue
expr_stmt|;
for|for
control|(
name|lim
operator|=
name|buflim
init|;
name|lim
operator|>
name|beg
operator|&&
name|lim
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|;
operator|--
name|lim
control|)
empty_stmt|;
name|residue
operator|=
name|buflim
operator|-
name|lim
expr_stmt|;
if|if
condition|(
name|beg
operator|<
name|lim
condition|)
block|{
name|nlines
operator|+=
name|grepbuf
argument_list|(
name|beg
argument_list|,
name|lim
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending
condition|)
name|prpending
argument_list|(
name|lim
argument_list|)
expr_stmt|;
comment|/* optimization */
if|if
condition|(
name|nlines
operator|&&
name|out_quiet
operator|&&
operator|!
name|count_matches
condition|)
return|return
operator|(
name|nlines
operator|)
return|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|beg
operator|=
name|lim
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|out_before
operator|&&
name|beg
operator|>
name|bufbeg
operator|&&
name|beg
operator|!=
name|lastout
condition|)
block|{
operator|++
name|i
expr_stmt|;
do|do
operator|--
name|beg
expr_stmt|;
do|while
condition|(
name|beg
operator|>
name|bufbeg
operator|&&
name|beg
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
do|;
block|}
if|if
condition|(
name|beg
operator|!=
name|lastout
condition|)
name|lastout
operator|=
literal|0
expr_stmt|;
name|save
operator|=
name|residue
operator|+
name|lim
operator|-
name|beg
expr_stmt|;
name|totalcc
operator|+=
name|buflim
operator|-
name|bufbeg
operator|-
name|save
expr_stmt|;
if|if
condition|(
name|out_line
condition|)
name|nlscan
argument_list|(
name|beg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|residue
condition|)
block|{
name|nlines
operator|+=
name|grepbuf
argument_list|(
name|bufbeg
operator|+
name|save
operator|-
name|residue
argument_list|,
name|buflim
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending
condition|)
name|prpending
argument_list|(
name|buflim
argument_list|)
expr_stmt|;
block|}
return|return
name|nlines
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|version
index|[]
init|=
literal|"GNU grep version 2.0"
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FTS
end_ifdef

begin_define
define|#
directive|define
name|USAGE
define|\
value|"usage: %s [-[AB]<num>] [-HRPS] [-CEFGLVabchilnqsvwx]\n\             [-e<expr>] [-f file] [files ...]\n"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|USAGE
define|\
value|"usage: %s [-[AB]<num>] [-CEFGLVabchilnqsvwx]\n\             [-e<expr>] [-f file] [files ...]\n"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|USAGE
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Go through the matchers vector and look for the specified matcher.    If we find it, install it in compile and execute, and return 1.  */
end_comment

begin_function
name|int
name|setmatcher
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|matchers
index|[
name|i
index|]
operator|.
name|name
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|matchers
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|compile
operator|=
name|matchers
index|[
name|i
index|]
operator|.
name|compile
expr_stmt|;
name|execute
operator|=
name|matchers
index|[
name|i
index|]
operator|.
name|execute
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|keys
decl_stmt|;
name|size_t
name|keycc
decl_stmt|,
name|oldcc
decl_stmt|,
name|keyalloc
decl_stmt|;
name|int
name|keyfound
decl_stmt|,
name|no_filenames
decl_stmt|,
name|list_files
decl_stmt|,
name|suppress_errors
decl_stmt|;
name|int
name|opt
decl_stmt|,
name|cc
decl_stmt|,
name|desc
decl_stmt|,
name|count
decl_stmt|,
name|status
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FTS
name|int
name|Rflag
decl_stmt|,
name|Hflag
decl_stmt|,
name|Pflag
decl_stmt|,
name|Lflag
decl_stmt|;
name|FTS
modifier|*
name|ftsp
decl_stmt|;
name|FTSENT
modifier|*
name|ftsent
decl_stmt|;
name|int
name|fts_options
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__FreeBSD__
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|prog
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|prog
operator|&&
name|strrchr
argument_list|(
name|prog
argument_list|,
literal|'/'
argument_list|)
condition|)
name|prog
operator|=
name|strrchr
argument_list|(
name|prog
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|keys
operator|=
name|NULL
expr_stmt|;
name|keycc
operator|=
literal|0
expr_stmt|;
name|keyfound
operator|=
literal|0
expr_stmt|;
name|count_matches
operator|=
literal|0
expr_stmt|;
name|no_filenames
operator|=
literal|0
expr_stmt|;
name|list_files
operator|=
literal|0
expr_stmt|;
name|suppress_errors
operator|=
literal|0
expr_stmt|;
name|matcher
operator|=
name|NULL
expr_stmt|;
name|aflag
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FTS
name|Rflag
operator|=
name|Hflag
operator|=
name|Pflag
operator|=
name|Lflag
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
ifndef|#
directive|ifndef
name|HAVE_FTS
literal|"0123456789A:B:CEFGVX:abce:f:hiLlnqsvwxy"
else|#
directive|else
literal|"0123456789A:B:CEFGHLPRSVX:abce:f:hiLlnqsvwxy?"
endif|#
directive|endif
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|out_before
operator|=
literal|10
operator|*
name|out_before
operator|+
name|opt
operator|-
literal|'0'
expr_stmt|;
name|out_after
operator|=
literal|10
operator|*
name|out_after
operator|+
name|opt
operator|-
literal|'0'
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|out_after
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_after
operator|<
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|out_before
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_before
operator|<
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|out_before
operator|=
name|out_after
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
if|if
condition|(
name|matcher
operator|&&
name|strcmp
argument_list|(
name|matcher
argument_list|,
literal|"egrep"
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"you may specify only one of -E, -F, or -G"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|matcher
operator|=
literal|"posix-egrep"
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
name|matcher
operator|&&
name|strcmp
argument_list|(
name|matcher
argument_list|,
literal|"fgrep"
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"you may specify only one of -E, -F, or -G"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
empty_stmt|;
name|matcher
operator|=
literal|"fgrep"
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
if|if
condition|(
name|matcher
operator|&&
name|strcmp
argument_list|(
name|matcher
argument_list|,
literal|"grep"
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"you may specify only one of -E, -F, or -G"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|matcher
operator|=
literal|"grep"
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
if|if
condition|(
name|matcher
condition|)
name|fatal
argument_list|(
literal|"matcher already specified"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|matcher
operator|=
name|optarg
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_FTS
comment|/* symbolic links on the command line are followed */
case|case
literal|'H'
case|:
name|Hflag
operator|=
literal|1
expr_stmt|;
name|Lflag
operator|=
name|Pflag
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* no symbolic links are followed */
case|case
literal|'P'
case|:
name|Pflag
operator|=
literal|1
expr_stmt|;
name|Hflag
operator|=
name|Lflag
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* traverse file hierarchies */
case|case
literal|'R'
case|:
name|Rflag
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* all symbolic links are followed */
case|case
literal|'S'
case|:
name|Lflag
operator|=
literal|1
expr_stmt|;
name|Hflag
operator|=
name|Pflag
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'a'
case|:
name|aflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|out_byte
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|out_quiet
operator|=
literal|1
expr_stmt|;
name|count_matches
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|cc
operator|=
name|strlen
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|keys
operator|=
name|xrealloc
argument_list|(
name|keys
argument_list|,
name|keycc
operator|+
name|cc
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyfound
condition|)
name|keys
index|[
name|keycc
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|keys
index|[
name|keycc
index|]
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|keycc
operator|+=
name|cc
expr_stmt|;
name|keyfound
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fp
operator|=
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
condition|?
name|fopen
argument_list|(
name|optarg
argument_list|,
literal|"r"
argument_list|)
else|:
name|stdin
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
name|fatal
argument_list|(
name|optarg
argument_list|,
name|errno
argument_list|)
expr_stmt|;
for|for
control|(
name|keyalloc
operator|=
literal|1
init|;
name|keyalloc
operator|<=
name|keycc
condition|;
name|keyalloc
operator|*=
literal|2
control|)
empty_stmt|;
name|keys
operator|=
name|xrealloc
argument_list|(
name|keys
argument_list|,
name|keyalloc
argument_list|)
expr_stmt|;
name|oldcc
operator|=
name|keycc
expr_stmt|;
if|if
condition|(
name|keyfound
condition|)
name|keys
index|[
name|keycc
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
operator|&&
operator|(
name|cc
operator|=
name|fread
argument_list|(
name|keys
operator|+
name|keycc
argument_list|,
literal|1
argument_list|,
name|keyalloc
operator|-
name|keycc
argument_list|,
name|fp
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|keycc
operator|+=
name|cc
expr_stmt|;
if|if
condition|(
name|keycc
operator|==
name|keyalloc
condition|)
name|keys
operator|=
name|xrealloc
argument_list|(
name|keys
argument_list|,
name|keyalloc
operator|*=
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Nuke the final newline to avoid matching a null string. */
if|if
condition|(
name|keycc
operator|-
name|oldcc
operator|>
literal|0
operator|&&
name|keys
index|[
name|keycc
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
operator|--
name|keycc
expr_stmt|;
name|keyfound
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|no_filenames
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'y'
case|:
comment|/* For old-timers . . . */
name|match_icase
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Like -l, except list files that don't contain matches. 	   Inspired by the same option in Hume's gre. */
name|out_quiet
operator|=
literal|1
expr_stmt|;
name|list_files
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|out_quiet
operator|=
literal|1
expr_stmt|;
name|list_files
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|out_line
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|out_quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|suppress_errors
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|out_invert
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|match_words
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|match_lines
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|keyfound
condition|)
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|keys
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
name|keycc
operator|=
name|strlen
argument_list|(
name|keys
argument_list|)
expr_stmt|;
block|}
else|else
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|matcher
condition|)
name|matcher
operator|=
name|prog
expr_stmt|;
if|if
condition|(
operator|!
name|setmatcher
argument_list|(
name|matcher
argument_list|)
operator|&&
operator|!
name|setmatcher
argument_list|(
literal|"default"
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
call|(
modifier|*
name|compile
call|)
argument_list|(
name|keys
argument_list|,
name|keycc
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HAVE_FTS
if|if
condition|(
name|argc
operator|-
name|optind
operator|>
literal|1
operator|&&
operator|!
name|no_filenames
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|argc
operator|-
name|optind
operator|>
literal|1
operator|||
name|Rflag
operator|)
operator|&&
operator|!
name|no_filenames
condition|)
endif|#
directive|endif
name|out_file
operator|=
literal|1
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|HAVE_FTS
if|if
condition|(
name|Rflag
condition|)
block|{
name|fts_options
operator|=
name|FTS_PHYSICAL
operator||
name|FTS_NOCHDIR
expr_stmt|;
if|if
condition|(
name|Hflag
condition|)
name|fts_options
operator||=
name|FTS_COMFOLLOW
expr_stmt|;
if|if
condition|(
name|Lflag
condition|)
block|{
name|fts_options
operator||=
name|FTS_LOGICAL
expr_stmt|;
name|fts_options
operator|&=
operator|~
name|FTS_PHYSICAL
expr_stmt|;
block|}
if|if
condition|(
name|Pflag
condition|)
block|{
name|fts_options
operator|&=
operator|~
name|FTS_LOGICAL
operator|&
operator|~
name|FTS_COMFOLLOW
expr_stmt|;
name|fts_options
operator||=
name|FTS_PHYSICAL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Rflag
operator|&&
name|optind
operator|<
name|argc
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* replace "-" with "/dev/stdin" */
for|for
control|(
name|i
operator|=
name|optind
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
operator|*
operator|(
name|argv
operator|+
name|i
operator|)
operator|=
literal|"/dev/stdin"
expr_stmt|;
if|if
condition|(
operator|(
name|ftsp
operator|=
name|fts_open
argument_list|(
name|argv
operator|+
name|optind
argument_list|,
name|fts_options
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|suppress_errors
condition|)
name|error
argument_list|(
literal|""
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|ftsent
operator|=
name|fts_read
argument_list|(
name|ftsp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|filename
operator|=
name|ftsent
operator|->
name|fts_accpath
expr_stmt|;
switch|switch
condition|(
name|ftsent
operator|->
name|fts_info
condition|)
block|{
comment|/* regular file */
case|case
name|FTS_F
case|:
break|break;
comment|/* directory */
case|case
name|FTS_D
case|:
case|case
name|FTS_DC
case|:
case|case
name|FTS_DP
case|:
continue|continue;
break|break;
comment|/* errors */
case|case
name|FTS_DNR
case|:
name|error
argument_list|(
name|filename
argument_list|,
name|errno
argument_list|)
expr_stmt|;
continue|continue;
break|break;
case|case
name|FTS_ERR
case|:
case|case
name|FTS_NS
case|:
name|error
argument_list|(
name|filename
argument_list|,
name|ftsent
operator|->
name|fts_errno
argument_list|)
expr_stmt|;
continue|continue;
break|break;
comment|/* dead symlink */
case|case
name|FTS_SLNONE
case|:
continue|continue;
break|break;
comment|/* symlink, don't skip */
case|case
name|FTS_SL
case|:
break|break;
default|default:
comment|/*  	  if (!suppress_errors) 	    fprintf(stderr, "%s: ignored\n", filename); 	  continue; break; 	  */
block|}
if|if
condition|(
operator|(
name|desc
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
name|filename
argument_list|,
name|errno
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|count
operator|=
name|grep
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|count_matches
condition|)
block|{
if|if
condition|(
name|out_file
condition|)
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
condition|)
block|{
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|list_files
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|list_files
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|!=
name|STDIN_FILENO
condition|)
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fts_close
argument_list|(
name|ftsp
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"fts_close"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
comment|/* ! Rflag */
block|}
elseif|else
endif|#
directive|endif
comment|/* HAVE_FTS */
comment|/* search in file names from arguments, not from stdin */
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
while|while
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|desc
operator|=
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"-"
argument_list|)
condition|?
name|open
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
name|O_RDONLY
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|suppress_errors
condition|)
name|error
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|filename
operator|=
name|desc
operator|==
literal|0
condition|?
literal|"(standard input)"
else|:
name|argv
index|[
name|optind
index|]
expr_stmt|;
name|count
operator|=
name|grep
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|count_matches
condition|)
block|{
if|if
condition|(
name|out_file
condition|)
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
condition|)
block|{
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|list_files
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|list_files
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|desc
operator|!=
literal|0
condition|)
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
operator|++
name|optind
expr_stmt|;
block|}
comment|/* read input from stdin */
else|else
block|{
name|filename
operator|=
literal|"(standard input)"
expr_stmt|;
name|count
operator|=
name|grep
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|count_matches
condition|)
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|list_files
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"(standard input)\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|list_files
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"(standard input)\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|errseen
condition|?
literal|2
else|:
name|status
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

