begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* grep - print lines matching an extended regular expression    Copyright (C) 1988 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Written June, 1988 by Mike Haertel    BMG speedups added July, 1988 by James A. Woods and Arthur David Olson  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|bcopy
end_ifndef

begin_define
define|#
directive|define
name|bcopy
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|n
parameter_list|)
value|memcpy((d),(s),(n))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|index
end_ifndef

begin_define
define|#
directive|define
name|index
value|strchr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|STDC_HEADERS
end_ifndef

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"dfa.h"
end_include

begin_include
include|#
directive|include
file|"regex.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_comment
comment|/* Used by -w */
end_comment

begin_define
define|#
directive|define
name|WCHAR
parameter_list|(
name|C
parameter_list|)
value|(ISALNUM(C) || (C) == '_')
end_define

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_comment
comment|/* Exit status codes. */
end_comment

begin_define
define|#
directive|define
name|MATCHES_FOUND
value|0
end_define

begin_comment
comment|/* Exit 0 if no errors and matches found. */
end_comment

begin_define
define|#
directive|define
name|NO_MATCHES_FOUND
value|1
end_define

begin_comment
comment|/* Exit 1 if no matches were found. */
end_comment

begin_define
define|#
directive|define
name|ERROR
value|2
end_define

begin_comment
comment|/* Exit 2 if some error occurred. */
end_comment

begin_comment
comment|/* Error is set true if something awful happened. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|error
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The program name for error messages. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We do all our own buffering by hand for efficiency. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The buffer itself, grown as needed. */
end_comment

begin_expr_stmt
specifier|static
name|bufbytes
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of bytes in the buffer. */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|bufalloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes allocated to the buffer. */
end_comment

begin_expr_stmt
specifier|static
name|bufprev
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of bytes that have been forgotten. 				   This is used to get byte offsets from the 				   beginning of the file. */
end_comment

begin_expr_stmt
specifier|static
name|bufread
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of bytes to get with each read(). */
end_comment

begin_function
specifier|static
name|void
name|initialize_buffer
parameter_list|()
block|{
name|bufread
operator|=
literal|8192
expr_stmt|;
name|bufalloc
operator|=
name|bufread
operator|+
name|bufread
operator|/
literal|2
expr_stmt|;
name|buffer
operator|=
name|malloc
argument_list|(
name|bufalloc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Memory exhausted (%s)\n"
argument_list|,
name|prog
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The current input file. */
end_comment

begin_expr_stmt
specifier|static
name|fd
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|eof
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Fill the buffer retaining the last n bytes at the beginning of the    newly filled buffer (for backward context).  Returns the number of new    bytes read from disk. */
end_comment

begin_function
specifier|static
name|int
name|fill_buffer_retaining
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* See if we need to grow the buffer. */
if|if
condition|(
name|bufalloc
operator|-
name|n
operator|<=
name|bufread
condition|)
block|{
while|while
condition|(
name|bufalloc
operator|-
name|n
operator|<=
name|bufread
condition|)
block|{
name|bufalloc
operator|*=
literal|2
expr_stmt|;
name|bufread
operator|*=
literal|2
expr_stmt|;
block|}
name|buffer
operator|=
name|realloc
argument_list|(
name|buffer
argument_list|,
name|bufalloc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Memory exhausted (%s)\n"
argument_list|,
name|prog
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
block|}
name|bufprev
operator|+=
name|bufbytes
operator|-
name|n
expr_stmt|;
comment|/* Shift stuff down. */
for|for
control|(
name|i
operator|=
name|n
operator|,
name|p
operator|=
name|buffer
operator|,
name|q
operator|=
name|p
operator|+
name|bufbytes
operator|-
name|n
init|;
name|i
operator|--
condition|;
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
name|bufbytes
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|eof
condition|)
return|return
literal|0
return|;
comment|/* Read in new stuff. */
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buffer
operator|+
name|bufbytes
argument_list|,
name|bufread
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: read on %s failed (%s)\n"
argument_list|,
name|prog
argument_list|,
name|filename
condition|?
name|filename
else|:
literal|"<stdin>"
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Kludge to pretend every nonempty file ends with a newline. */
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|bufbytes
operator|>
literal|0
operator|&&
name|buffer
index|[
name|bufbytes
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|eof
operator|=
name|i
operator|=
literal|1
expr_stmt|;
name|buffer
index|[
name|bufbytes
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
name|bufbytes
operator|+=
name|i
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Various flags set according to the argument switches. */
end_comment

begin_expr_stmt
specifier|static
name|trailing_context
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Lines of context to show after matches. */
end_comment

begin_expr_stmt
specifier|static
name|leading_context
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Lines of context to show before matches. */
end_comment

begin_expr_stmt
specifier|static
name|byte_count
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Precede output lines the byte count of the 				   first character on the line. */
end_comment

begin_expr_stmt
specifier|static
name|no_filenames
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Do not display filenames. */
end_comment

begin_expr_stmt
specifier|static
name|line_numbers
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Precede output lines with line numbers. */
end_comment

begin_expr_stmt
specifier|static
name|silent
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Produce no output at all.  This switch 				   is bogus, ever hear of /dev/null? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|whole_word
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Match only whole words.  Note that if 				   backreferences are used this depends on 				   the regex routines getting leftmost-longest 				   right, which they don't right now if | 				   is also used. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|whole_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Match only whole lines.  Backreference 				   caveat applies here too.  */
end_comment

begin_expr_stmt
specifier|static
name|nonmatching_lines
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Print lines that don't match the regexp. */
end_comment

begin_expr_stmt
specifier|static
name|bmgexec
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Invoke Boyer-Moore-Gosper routines */
end_comment

begin_comment
comment|/* The compiled regular expression lives here. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|regexp
name|reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The compiled regular expression for the backtracking matcher lives here. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|re_pattern_buffer
name|regex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer in the buffer after the last character printed. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|printed_limit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True when printed_limit has been artifically advanced without printing    anything. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|printed_limit_fake
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print a line at the given line number, returning the number of    characters actually printed.  Matching is true if the line is to    be considered a "matching line".  This is only meaningful if    surrounding context is turned on. */
end_comment

begin_function
specifier|static
name|int
name|print_line
parameter_list|(
name|p
parameter_list|,
name|number
parameter_list|,
name|matching
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|number
decl_stmt|;
name|int
name|matching
decl_stmt|;
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|silent
condition|)
block|{
do|do
operator|++
name|count
expr_stmt|;
do|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\n'
condition|)
do|;
name|printed_limit_fake
operator|=
literal|0
expr_stmt|;
name|printed_limit
operator|=
name|p
expr_stmt|;
return|return
name|count
return|;
block|}
if|if
condition|(
name|filename
operator|&&
operator|!
name|no_filenames
condition|)
name|printf
argument_list|(
literal|"%s%c"
argument_list|,
name|filename
argument_list|,
name|matching
condition|?
literal|':'
else|:
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte_count
condition|)
name|printf
argument_list|(
literal|"%d%c"
argument_list|,
name|p
operator|-
name|buffer
operator|+
name|bufprev
argument_list|,
name|matching
condition|?
literal|':'
else|:
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|line_numbers
condition|)
name|printf
argument_list|(
literal|"%d%c"
argument_list|,
name|number
argument_list|,
name|matching
condition|?
literal|':'
else|:
literal|'-'
argument_list|)
expr_stmt|;
do|do
block|{
operator|++
name|count
expr_stmt|;
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\n'
condition|)
do|;
name|printed_limit_fake
operator|=
literal|0
expr_stmt|;
name|printed_limit
operator|=
name|p
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* Print matching or nonmatching lines from the current file.  Returns a    count of matching or nonmatching lines. */
end_comment

begin_function
specifier|static
name|int
name|grep
parameter_list|()
block|{
name|int
name|retain
init|=
literal|0
decl_stmt|;
comment|/* Number of bytes to retain on next call 				   to fill_buffer_retaining(). */
name|char
modifier|*
name|search_limit
decl_stmt|;
comment|/* Pointer to the character after the last 				   newline in the buffer. */
name|char
name|saved_char
decl_stmt|;
comment|/* Character after the last newline. */
name|char
modifier|*
name|resume
decl_stmt|;
comment|/* Pointer to where to resume search. */
name|int
name|resume_index
init|=
literal|0
decl_stmt|;
comment|/* Count of characters to ignore after 				   refilling the buffer. */
name|int
name|line_count
init|=
literal|1
decl_stmt|;
comment|/* Line number. */
name|int
name|try_backref
decl_stmt|;
comment|/* Set to true if we need to verify the 				   match with a backtracking matcher. */
name|int
name|initial_line_count
decl_stmt|;
comment|/* Line count at beginning of last search. */
name|char
modifier|*
name|match
decl_stmt|;
comment|/* Pointer to the first character after the 				   string matching the regexp. */
name|int
name|match_count
init|=
literal|0
decl_stmt|;
comment|/* Count of matching lines. */
name|char
modifier|*
name|matching_line
decl_stmt|;
comment|/* Pointer to first character of the matching 				   line, or of the first line of context to 				   print if context is turned on. */
name|char
modifier|*
name|real_matching_line
decl_stmt|;
comment|/* Pointer to the first character of the 				   real matching line. */
name|char
modifier|*
name|next_line
decl_stmt|;
comment|/* Pointer to first character of the line 				   following the matching line. */
name|char
modifier|*
name|last_match_limit
decl_stmt|;
comment|/* Pointer after last matched line. */
name|int
name|pending_lines
init|=
literal|0
decl_stmt|;
comment|/* Lines of context left over from last match 				   that we have to print. */
specifier|static
name|first_match
operator|=
literal|1
expr_stmt|;
comment|/* True when nothing has been printed. */
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|char
modifier|*
name|execute
parameter_list|()
function_decl|;
name|printed_limit_fake
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fill_buffer_retaining
argument_list|(
name|retain
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Find the last newline in the buffer. */
name|search_limit
operator|=
name|buffer
operator|+
name|bufbytes
expr_stmt|;
while|while
condition|(
name|search_limit
operator|>
name|buffer
operator|&&
name|search_limit
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
operator|--
name|search_limit
expr_stmt|;
if|if
condition|(
name|search_limit
operator|==
name|buffer
condition|)
block|{
name|retain
operator|=
name|bufbytes
expr_stmt|;
continue|continue;
block|}
comment|/* Save the character after the last newline so regexecute can write 	 its own sentinel newline. */
name|saved_char
operator|=
operator|*
name|search_limit
expr_stmt|;
comment|/* Search the buffer for a match. */
name|printed_limit
operator|=
name|buffer
expr_stmt|;
name|resume
operator|=
name|buffer
operator|+
name|resume_index
expr_stmt|;
name|last_match_limit
operator|=
name|resume
expr_stmt|;
name|initial_line_count
operator|=
name|line_count
expr_stmt|;
comment|/* In retrospect, I have to say that the following code sucks. 	 For an example of how to do this right, see the fgrep 	 driver program that I wrote around a year later.  I'm 	 too lazy to retrofit that to egrep right now (the 	 pattern matchers have different needs).  */
while|while
condition|(
name|match
operator|=
name|execute
argument_list|(
operator|&
name|reg
argument_list|,
name|resume
argument_list|,
name|search_limit
argument_list|,
literal|0
argument_list|,
operator|&
name|line_count
argument_list|,
operator|&
name|try_backref
argument_list|)
condition|)
block|{
comment|/* Find the beginning of the matching line. */
name|matching_line
operator|=
name|match
expr_stmt|;
while|while
condition|(
name|matching_line
operator|>
name|resume
operator|&&
name|matching_line
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
operator|--
name|matching_line
expr_stmt|;
name|real_matching_line
operator|=
name|matching_line
expr_stmt|;
comment|/* Find the beginning of the next line. */
name|next_line
operator|=
name|match
expr_stmt|;
while|while
condition|(
name|next_line
operator|<
name|search_limit
operator|&&
operator|*
name|next_line
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
comment|/* If a potential backreference is indicated, try it out with 	     a backtracking matcher to make sure the line is a match. 	     This is hairy because we need to handle whole_line and 	     whole_word matches specially.  The method was stolen from 	     GNU fgrep.  */
if|if
condition|(
name|try_backref
condition|)
block|{
name|struct
name|re_registers
name|regs
decl_stmt|;
name|int
name|beg
decl_stmt|,
name|len
decl_stmt|,
name|maxlen
decl_stmt|,
name|ret
decl_stmt|;
name|beg
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|maxlen
operator|=
name|next_line
operator|-
name|matching_line
operator|-
literal|1
init|;
name|beg
operator|<=
name|maxlen
condition|;
operator|++
name|beg
control|)
block|{
comment|/* See if the matching line matches when backreferences 		     are considered... */
name|ret
operator|=
name|re_search
argument_list|(
operator|&
name|regex
argument_list|,
name|matching_line
argument_list|,
name|maxlen
argument_list|,
name|beg
argument_list|,
name|maxlen
operator|-
name|beg
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
goto|goto
name|fail
goto|;
name|beg
operator|=
name|ret
expr_stmt|;
name|len
operator|=
name|regs
operator|.
name|end
index|[
literal|0
index|]
operator|-
name|beg
expr_stmt|;
comment|/* Ok, now check if it subsumed the whole line if -x */
if|if
condition|(
name|whole_line
operator|&&
operator|(
name|beg
operator|!=
literal|0
operator|||
name|len
operator|!=
name|maxlen
operator|)
condition|)
goto|goto
name|fail
goto|;
comment|/* If -w then check if the match aligns with word 		     boundaries.  We have to do this iteratively, because 		     (a) The line may contain more than one occurence 		     of the pattern, and; 		     (b) Several alternatives in the pattern might 		     be valid at a given point, and we may need to 		     consider a shorter one in order to align with 		     word boundaries.  */
elseif|else
if|if
condition|(
name|whole_word
condition|)
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* If it's preceeded by a word constituent, then no go.  */
if|if
condition|(
name|beg
operator|>
literal|0
operator|&&
name|WCHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|matching_line
index|[
name|beg
operator|-
literal|1
index|]
argument_list|)
condition|)
break|break;
comment|/* If it's followed by a word constituent, look for 			   a shorter match.  */
elseif|else
if|if
condition|(
name|beg
operator|+
name|len
operator|<
name|maxlen
operator|&&
name|WCHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|matching_line
index|[
name|beg
operator|+
name|len
index|]
argument_list|)
condition|)
comment|/* This is sheer incest. */
name|len
operator|=
name|re_match_2
argument_list|(
operator|&
name|regex
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|matching_line
argument_list|,
name|maxlen
argument_list|,
name|beg
argument_list|,
operator|&
name|regs
argument_list|,
name|beg
operator|+
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
goto|goto
name|succeed
goto|;
block|}
else|else
goto|goto
name|succeed
goto|;
block|}
name|fail
label|:
name|resume
operator|=
name|next_line
expr_stmt|;
if|if
condition|(
name|resume
operator|==
name|search_limit
condition|)
break|break;
else|else
continue|continue;
block|}
name|succeed
label|:
comment|/* Print out the matching or nonmatching lines as necessary. */
if|if
condition|(
operator|!
name|nonmatching_lines
condition|)
block|{
comment|/* Not -v, so nothing hairy... */
operator|++
name|match_count
expr_stmt|;
comment|/* Print leftover trailing context from last time around.  */
while|while
condition|(
name|pending_lines
operator|&&
name|last_match_limit
operator|<
name|matching_line
condition|)
block|{
name|last_match_limit
operator|+=
name|print_line
argument_list|(
name|last_match_limit
argument_list|,
name|initial_line_count
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|pending_lines
expr_stmt|;
block|}
comment|/* Back up over leading context if necessary. */
for|for
control|(
name|i
operator|=
name|leading_context
init|;
name|i
operator|>
literal|0
operator|&&
name|matching_line
operator|>
name|printed_limit
condition|;
operator|--
name|i
control|)
block|{
while|while
condition|(
name|matching_line
operator|>
name|printed_limit
operator|&&
operator|(
operator|--
name|matching_line
operator|)
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
empty_stmt|;
operator|--
name|line_count
expr_stmt|;
block|}
comment|/* If context is enabled, we may have to print a separator. */
if|if
condition|(
operator|(
name|leading_context
operator|||
name|trailing_context
operator|)
operator|&&
operator|!
name|silent
operator|&&
operator|!
name|first_match
operator|&&
operator|(
name|printed_limit_fake
operator|||
name|matching_line
operator|>
name|printed_limit
operator|)
condition|)
name|printf
argument_list|(
literal|"----------\n"
argument_list|)
expr_stmt|;
name|first_match
operator|=
literal|0
expr_stmt|;
comment|/* Print the matching line and its leading context. */
while|while
condition|(
name|matching_line
operator|<
name|real_matching_line
condition|)
name|matching_line
operator|+=
name|print_line
argument_list|(
name|matching_line
argument_list|,
name|line_count
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|matching_line
operator|+=
name|print_line
argument_list|(
name|matching_line
argument_list|,
name|line_count
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If there's trailing context, leave some lines pending until 		 next time. */
name|pending_lines
operator|=
name|trailing_context
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|matching_line
operator|==
name|last_match_limit
condition|)
block|{
comment|/* In the -v case, this is where we deal with leftover 		 trailing context from last time... */
if|if
condition|(
name|pending_lines
operator|>
literal|0
condition|)
block|{
operator|--
name|pending_lines
expr_stmt|;
name|print_line
argument_list|(
name|matching_line
argument_list|,
name|line_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|++
name|line_count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|matching_line
operator|>
name|last_match_limit
condition|)
block|{
name|char
modifier|*
name|start
init|=
name|last_match_limit
decl_stmt|;
comment|/* Back up over leading context if necessary. */
for|for
control|(
name|i
operator|=
name|leading_context
init|;
name|start
operator|>
name|printed_limit
operator|&&
name|i
condition|;
operator|--
name|i
control|)
block|{
while|while
condition|(
name|start
operator|>
name|printed_limit
operator|&&
operator|(
operator|--
name|start
operator|)
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
empty_stmt|;
operator|--
name|initial_line_count
expr_stmt|;
block|}
comment|/* If context is enabled, we may have to print a separator. */
if|if
condition|(
operator|(
name|leading_context
operator|||
name|trailing_context
operator|)
operator|&&
operator|!
name|silent
operator|&&
operator|!
name|first_match
operator|&&
operator|(
name|printed_limit_fake
operator|||
name|start
operator|>
name|printed_limit
operator|)
condition|)
name|printf
argument_list|(
literal|"----------\n"
argument_list|)
expr_stmt|;
name|first_match
operator|=
literal|0
expr_stmt|;
comment|/* Print out the presumably matching leading context. */
while|while
condition|(
name|start
operator|<
name|last_match_limit
condition|)
name|start
operator|+=
name|print_line
argument_list|(
name|start
argument_list|,
name|initial_line_count
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Print out the nonmatching lines prior to the matching line. */
while|while
condition|(
name|start
operator|<
name|matching_line
condition|)
block|{
comment|/* This counts as a "matching line" in -v. */
operator|++
name|match_count
expr_stmt|;
name|start
operator|+=
name|print_line
argument_list|(
name|start
argument_list|,
name|initial_line_count
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Deal with trailing context.  In -v what this means is 		 we print the current (matching) line, marked as a non 		 matching line.  */
if|if
condition|(
name|trailing_context
condition|)
block|{
name|print_line
argument_list|(
name|matching_line
argument_list|,
name|line_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pending_lines
operator|=
name|trailing_context
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Count the current line. */
operator|++
name|line_count
expr_stmt|;
block|}
else|else
comment|/* Let us pray this never happens... */
name|abort
argument_list|()
expr_stmt|;
comment|/* Resume searching at the beginning of the next line. */
name|initial_line_count
operator|=
name|line_count
expr_stmt|;
name|resume
operator|=
name|next_line
expr_stmt|;
name|last_match_limit
operator|=
name|next_line
expr_stmt|;
if|if
condition|(
name|resume
operator|==
name|search_limit
condition|)
break|break;
block|}
comment|/* Restore the saved character. */
operator|*
name|search_limit
operator|=
name|saved_char
expr_stmt|;
if|if
condition|(
operator|!
name|nonmatching_lines
condition|)
block|{
while|while
condition|(
name|last_match_limit
operator|<
name|search_limit
operator|&&
name|pending_lines
condition|)
block|{
name|last_match_limit
operator|+=
name|print_line
argument_list|(
name|last_match_limit
argument_list|,
name|initial_line_count
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|pending_lines
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|search_limit
operator|>
name|last_match_limit
condition|)
block|{
name|char
modifier|*
name|start
init|=
name|last_match_limit
decl_stmt|;
comment|/* Back up over leading context if necessary. */
for|for
control|(
name|i
operator|=
name|leading_context
init|;
name|start
operator|>
name|printed_limit
operator|&&
name|i
condition|;
operator|--
name|i
control|)
block|{
while|while
condition|(
name|start
operator|>
name|printed_limit
operator|&&
operator|(
operator|--
name|start
operator|)
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
empty_stmt|;
operator|--
name|initial_line_count
expr_stmt|;
block|}
comment|/* If context is enabled, we may have to print a separator. */
if|if
condition|(
operator|(
name|leading_context
operator|||
name|trailing_context
operator|)
operator|&&
operator|!
name|silent
operator|&&
operator|!
name|first_match
operator|&&
operator|(
name|printed_limit_fake
operator|||
name|start
operator|>
name|printed_limit
operator|)
condition|)
name|printf
argument_list|(
literal|"----------\n"
argument_list|)
expr_stmt|;
name|first_match
operator|=
literal|0
expr_stmt|;
comment|/* Print out all the nonmatching lines up to the search limit. */
while|while
condition|(
name|start
operator|<
name|last_match_limit
condition|)
name|start
operator|+=
name|print_line
argument_list|(
name|start
argument_list|,
name|initial_line_count
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|start
operator|<
name|search_limit
condition|)
block|{
operator|++
name|match_count
expr_stmt|;
name|start
operator|+=
name|print_line
argument_list|(
name|start
argument_list|,
name|initial_line_count
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|pending_lines
operator|=
name|trailing_context
expr_stmt|;
name|resume_index
operator|=
literal|0
expr_stmt|;
name|retain
operator|=
name|bufbytes
operator|-
operator|(
name|search_limit
operator|-
name|buffer
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* Save the trailing end of the buffer for possible use as leading 	 context in the future. */
name|i
operator|=
name|leading_context
expr_stmt|;
name|tmp
operator|=
name|search_limit
expr_stmt|;
while|while
condition|(
name|tmp
operator|>
name|printed_limit
operator|&&
name|i
operator|--
condition|)
while|while
condition|(
name|tmp
operator|>
name|printed_limit
operator|&&
operator|(
operator|--
name|tmp
operator|)
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|resume_index
operator|=
name|search_limit
operator|-
name|tmp
expr_stmt|;
name|retain
operator|=
name|bufbytes
operator|-
operator|(
name|tmp
operator|-
name|buffer
operator|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|printed_limit
condition|)
name|printed_limit_fake
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|match_count
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|usage_and_die
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: %s [-CVbchilnsvwx] [-num] [-A num] [-B num] [-f file]\n\        [-e] expr [file...]\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|version
index|[]
init|=
literal|"GNU e?grep, version 1.6"
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|ignore_case
init|=
literal|0
decl_stmt|;
comment|/* Compile the regexp to ignore case. */
name|char
modifier|*
name|the_regexp
init|=
literal|0
decl_stmt|;
comment|/* The regular expression. */
name|int
name|regexp_len
decl_stmt|;
comment|/* Length of the regular expression. */
name|char
modifier|*
name|regexp_file
init|=
literal|0
decl_stmt|;
comment|/* File containing parallel regexps. */
name|int
name|count_lines
init|=
literal|0
decl_stmt|;
comment|/* Display only a count of matching lines. */
name|int
name|list_files
init|=
literal|0
decl_stmt|;
comment|/* Display only the names of matching files. */
name|int
name|line_count
init|=
literal|0
decl_stmt|;
comment|/* Count of matching lines for a file. */
name|int
name|matches_found
init|=
literal|0
decl_stmt|;
comment|/* True if matches were found. */
name|char
modifier|*
name|regex_errmesg
decl_stmt|;
comment|/* Error message from regex routines. */
name|char
name|translate
index|[
name|_NOTCHAR
index|]
decl_stmt|;
comment|/* Translate table for case conversion 				   (needed by the backtracking matcher). */
if|if
condition|(
name|prog
operator|=
name|index
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
condition|)
operator|++
name|prog
expr_stmt|;
else|else
name|prog
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|opterr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"0123456789A:B:CVbce:f:hilnsvwx"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'?'
case|:
name|usage_and_die
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|trailing_context
operator|=
literal|10
operator|*
name|trailing_context
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
name|leading_context
operator|=
literal|10
operator|*
name|leading_context
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
if|if
condition|(
operator|!
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|trailing_context
argument_list|)
operator|||
name|trailing_context
operator|<
literal|0
condition|)
name|usage_and_die
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
if|if
condition|(
operator|!
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|leading_context
argument_list|)
operator|||
name|leading_context
operator|<
literal|0
condition|)
name|usage_and_die
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|trailing_context
operator|=
name|leading_context
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|byte_count
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|count_lines
operator|=
literal|1
expr_stmt|;
name|silent
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* It doesn't make sense to mix -f and -e. */
if|if
condition|(
name|regexp_file
condition|)
name|usage_and_die
argument_list|()
expr_stmt|;
name|the_regexp
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* It doesn't make sense to mix -f and -e. */
if|if
condition|(
name|the_regexp
condition|)
name|usage_and_die
argument_list|()
expr_stmt|;
name|regexp_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|no_filenames
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|ignore_case
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|_NOTCHAR
condition|;
operator|++
name|c
control|)
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|translate
index|[
name|c
index|]
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
else|else
name|translate
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|regex
operator|.
name|translate
operator|=
name|translate
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|list_files
operator|=
literal|1
expr_stmt|;
name|silent
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|line_numbers
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|silent
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|nonmatching_lines
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|whole_word
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|whole_line
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* This can't happen. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: getopt(3) let one by!\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|usage_and_die
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* Set the syntax depending on whether we are EGREP or not. */
ifdef|#
directive|ifdef
name|EGREP
name|regsyntax
argument_list|(
name|RE_SYNTAX_EGREP
argument_list|,
name|ignore_case
argument_list|)
expr_stmt|;
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_EGREP
argument_list|)
expr_stmt|;
else|#
directive|else
name|regsyntax
argument_list|(
name|RE_SYNTAX_GREP
argument_list|,
name|ignore_case
argument_list|)
expr_stmt|;
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_GREP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Compile the regexp according to all the options. */
if|if
condition|(
name|regexp_file
condition|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|regexp_file
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
name|int
name|len
init|=
literal|256
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: %s\n"
argument_list|,
name|prog
argument_list|,
name|regexp_file
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
name|the_regexp
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|the_regexp
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|len
condition|)
name|the_regexp
operator|=
name|realloc
argument_list|(
name|the_regexp
argument_list|,
name|len
operator|*=
literal|2
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Nuke the concluding newline so we won't match the empty string. */
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|the_regexp
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
operator|--
name|i
expr_stmt|;
name|regexp_len
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|the_regexp
condition|)
block|{
if|if
condition|(
name|optind
operator|>=
name|argc
condition|)
name|usage_and_die
argument_list|()
expr_stmt|;
name|the_regexp
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
name|regexp_len
operator|=
name|strlen
argument_list|(
name|the_regexp
argument_list|)
expr_stmt|;
block|}
else|else
name|regexp_len
operator|=
name|strlen
argument_list|(
name|the_regexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|whole_word
operator|||
name|whole_line
condition|)
block|{
comment|/* In the whole-word case, we use the pattern: 	 (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$). 	 In the whole-line case, we use the pattern: 	 ^(userpattern)$. 	 BUG: Using [A-Za-z_] is locale-dependent!  */
name|char
modifier|*
name|n
init|=
name|malloc
argument_list|(
name|regexp_len
operator|+
literal|50
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|EGREP
if|if
condition|(
name|whole_word
condition|)
name|strcpy
argument_list|(
name|n
argument_list|,
literal|"(^|[^A-Za-z_])("
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|n
argument_list|,
literal|"^("
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Todo:  Make *sure* this is the right syntax.  Down with grep! */
if|if
condition|(
name|whole_word
condition|)
name|strcpy
argument_list|(
name|n
argument_list|,
literal|"\\(^\\|[^A-Za-z_]\\)\\("
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|n
argument_list|,
literal|"^\\("
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|strlen
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|the_regexp
argument_list|,
name|n
operator|+
name|i
argument_list|,
name|regexp_len
argument_list|)
expr_stmt|;
name|i
operator|+=
name|regexp_len
expr_stmt|;
ifdef|#
directive|ifdef
name|EGREP
if|if
condition|(
name|whole_word
condition|)
name|strcpy
argument_list|(
name|n
operator|+
name|i
argument_list|,
literal|")([^A-Za-z_]|$)"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|n
operator|+
name|i
argument_list|,
literal|")$"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|whole_word
condition|)
name|strcpy
argument_list|(
name|n
operator|+
name|i
argument_list|,
literal|"\\)\\([^A-Za-z_]\\|$\\)"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|n
operator|+
name|i
argument_list|,
literal|"\\)$"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|+=
name|strlen
argument_list|(
name|n
operator|+
name|i
argument_list|)
expr_stmt|;
name|regcompile
argument_list|(
name|n
argument_list|,
name|i
argument_list|,
operator|&
name|reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|regcompile
argument_list|(
name|the_regexp
argument_list|,
name|regexp_len
argument_list|,
operator|&
name|reg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|regex_errmesg
operator|=
name|re_compile_pattern
argument_list|(
name|the_regexp
argument_list|,
name|regexp_len
argument_list|,
operator|&
name|regex
argument_list|)
condition|)
name|regerror
argument_list|(
name|regex_errmesg
argument_list|)
expr_stmt|;
comment|/*     Find the longest metacharacter-free string which must occur in the     regexpr, before short-circuiting regexecute() with Boyer-Moore-Gosper.     (Conjecture:  The problem in general is NP-complete.)  If there is no     such string (like for many alternations), then default to full automaton     search.  regmust() code and heuristics [see dfa.c] courtesy     Arthur David Olson.     */
if|if
condition|(
name|line_numbers
operator|==
literal|0
operator|&&
name|nonmatching_lines
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|reg
operator|.
name|mustn
operator|==
literal|0
operator|||
name|reg
operator|.
name|mustn
operator|==
name|MUST_MAX
operator|||
name|index
argument_list|(
name|reg
operator|.
name|must
argument_list|,
literal|'\0'
argument_list|)
operator|!=
name|reg
operator|.
name|must
operator|+
name|reg
operator|.
name|mustn
condition|)
name|bmgexec
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|reg
operator|.
name|must
index|[
name|reg
operator|.
name|mustn
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"MUSTDEBUG"
argument_list|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"must have: \"%s\"\n"
argument_list|,
name|reg
operator|.
name|must
argument_list|)
expr_stmt|;
name|bmg_setup
argument_list|(
name|reg
operator|.
name|must
argument_list|,
name|ignore_case
argument_list|)
expr_stmt|;
name|bmgexec
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|argc
operator|-
name|optind
operator|<
literal|2
condition|)
name|no_filenames
operator|=
literal|1
expr_stmt|;
name|initialize_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|argc
operator|>
name|optind
condition|)
while|while
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|bufprev
operator|=
name|eof
operator|=
literal|0
expr_stmt|;
name|filename
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: %s\n"
argument_list|,
name|prog
argument_list|,
name|filename
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|line_count
operator|=
name|grep
argument_list|()
condition|)
name|matches_found
operator|=
literal|1
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|count_lines
condition|)
if|if
condition|(
operator|!
name|no_filenames
condition|)
name|printf
argument_list|(
literal|"%s:%d\n"
argument_list|,
name|filename
argument_list|,
name|line_count
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
name|line_count
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|list_files
operator|&&
name|line_count
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|line_count
operator|=
name|grep
argument_list|()
condition|)
name|matches_found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|count_lines
condition|)
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
name|line_count
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|list_files
operator|&&
name|line_count
condition|)
name|printf
argument_list|(
literal|"<stdin>\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
name|exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches_found
condition|)
name|exit
argument_list|(
name|MATCHES_FOUND
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|NO_MATCHES_FOUND
argument_list|)
expr_stmt|;
return|return
name|NO_MATCHES_FOUND
return|;
block|}
end_function

begin_comment
comment|/* Needed by the regexp routines.  This could be fancier, especially when    dealing with parallel regexps in files. */
end_comment

begin_function
name|void
name|regerror
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|prog
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*    bmg_setup() and bmg_search() adapted from:      Boyer/Moore/Gosper-assisted 'egrep' search, with delta0 table as in      original paper (CACM, October, 1977).  No delta1 or delta2.  According to      experiment (Horspool, Soft. Prac. Exp., 1982), delta2 is of minimal      practical value.  However, to improve for worst case input, integrating      the improved Galil strategies (Apostolico/Giancarlo, Siam. J. Comput.,      February 1986) deserves consideration.       James A. Woods				Copyleft (C) 1986, 1988      NASA Ames Research Center */
end_comment

begin_function
name|char
modifier|*
name|execute
parameter_list|(
name|r
parameter_list|,
name|begin
parameter_list|,
name|end
parameter_list|,
name|newline
parameter_list|,
name|count
parameter_list|,
name|try_backref
parameter_list|)
name|struct
name|regexp
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|begin
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|newline
decl_stmt|;
name|int
modifier|*
name|count
decl_stmt|;
name|int
modifier|*
name|try_backref
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|match
decl_stmt|;
name|char
modifier|*
name|start
init|=
name|begin
decl_stmt|;
name|char
name|save
decl_stmt|;
comment|/* regexecute() sentinel */
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|bmg_search
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
name|bmgexec
condition|)
comment|/* full automaton search */
return|return
operator|(
name|regexecute
argument_list|(
name|r
argument_list|,
name|begin
argument_list|,
name|end
argument_list|,
name|newline
argument_list|,
name|count
argument_list|,
name|try_backref
argument_list|)
operator|)
return|;
else|else
block|{
name|len
operator|=
name|end
operator|-
name|begin
expr_stmt|;
while|while
condition|(
operator|(
name|match
operator|=
name|bmg_search
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|start
argument_list|,
name|len
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|match
expr_stmt|;
comment|/* narrow search range to submatch line */
while|while
condition|(
name|p
operator|>
name|begin
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|--
expr_stmt|;
name|s
operator|=
name|match
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|end
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|save
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|match
operator|=
name|regexecute
argument_list|(
name|r
argument_list|,
name|p
argument_list|,
name|s
argument_list|,
name|newline
argument_list|,
name|count
argument_list|,
name|try_backref
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|save
expr_stmt|;
if|if
condition|(
name|match
operator|!=
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|match
operator|)
return|;
else|else
block|{
name|start
operator|=
name|s
expr_stmt|;
name|len
operator|=
name|end
operator|-
name|start
expr_stmt|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_decl_stmt
name|int
name|delta0
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|cmap
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (un)folded characters */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|pattern
index|[
literal|5000
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|patlen
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|bmg_search
parameter_list|(
name|buffer
parameter_list|,
name|buflen
parameter_list|)
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|buflen
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|k
decl_stmt|,
modifier|*
name|strend
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|buflim
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|patlen
operator|>
name|buflen
condition|)
return|return
name|NULL
return|;
name|buflim
operator|=
name|buffer
operator|+
name|buflen
expr_stmt|;
if|if
condition|(
name|buflen
operator|>
name|patlen
operator|*
literal|4
condition|)
name|strend
operator|=
name|buflim
operator|-
name|patlen
operator|*
literal|4
expr_stmt|;
else|else
name|strend
operator|=
name|buffer
expr_stmt|;
name|s
operator|=
name|buffer
expr_stmt|;
name|k
operator|=
name|buffer
operator|+
name|patlen
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* The dreaded inner loop, revisited. */
while|while
condition|(
name|k
operator|<
name|strend
operator|&&
operator|(
name|t
operator|=
name|delta0
index|[
operator|*
name|k
index|]
operator|)
condition|)
block|{
name|k
operator|+=
name|t
expr_stmt|;
name|k
operator|+=
name|delta0
index|[
operator|*
name|k
index|]
expr_stmt|;
name|k
operator|+=
name|delta0
index|[
operator|*
name|k
index|]
expr_stmt|;
block|}
while|while
condition|(
name|k
operator|<
name|buflim
operator|&&
name|delta0
index|[
operator|*
name|k
index|]
condition|)
operator|++
name|k
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|buflim
condition|)
break|break;
name|j
operator|=
name|patlen
operator|-
literal|1
expr_stmt|;
name|s
operator|=
name|k
expr_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
operator|&&
name|cmap
index|[
operator|*
operator|--
name|s
index|]
operator|==
name|pattern
index|[
name|j
index|]
condition|)
empty_stmt|;
comment|/*  	delta-less shortcut for literati, but  	short shrift for genetic engineers.       */
if|if
condition|(
name|j
operator|>=
literal|0
condition|)
name|k
operator|++
expr_stmt|;
else|else
comment|/* submatch */
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|k
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bmg_setup
parameter_list|(
name|pat
parameter_list|,
name|folded
parameter_list|)
comment|/* compute "boyer-moore" delta table */
name|char
modifier|*
name|pat
decl_stmt|;
name|int
name|folded
decl_stmt|;
block|{
comment|/* ... HAKMEM lives ... */
name|int
name|j
decl_stmt|;
name|patlen
operator|=
name|strlen
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|folded
condition|)
comment|/* fold case while saving pattern */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|patlen
condition|;
name|j
operator|++
control|)
name|pattern
index|[
name|j
index|]
operator|=
operator|(
name|isupper
argument_list|(
operator|(
name|int
operator|)
name|pat
index|[
name|j
index|]
argument_list|)
condition|?
operator|(
name|char
operator|)
name|tolower
argument_list|(
operator|(
name|int
operator|)
name|pat
index|[
name|j
index|]
argument_list|)
else|:
name|pat
index|[
name|j
index|]
operator|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|pat
argument_list|,
name|pattern
argument_list|,
name|patlen
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|256
condition|;
name|j
operator|++
control|)
block|{
name|delta0
index|[
name|j
index|]
operator|=
name|patlen
expr_stmt|;
name|cmap
index|[
name|j
index|]
operator|=
operator|(
name|char
operator|)
name|j
expr_stmt|;
comment|/* could be done at compile time */
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|patlen
operator|-
literal|1
condition|;
name|j
operator|++
control|)
name|delta0
index|[
name|pattern
index|[
name|j
index|]
index|]
operator|=
name|patlen
operator|-
name|j
operator|-
literal|1
expr_stmt|;
name|delta0
index|[
name|pattern
index|[
name|patlen
operator|-
literal|1
index|]
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|folded
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|patlen
operator|-
literal|1
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|islower
argument_list|(
operator|(
name|int
operator|)
name|pattern
index|[
name|j
index|]
argument_list|)
condition|)
name|delta0
index|[
name|toupper
argument_list|(
operator|(
name|int
operator|)
name|pattern
index|[
name|j
index|]
argument_list|)
index|]
operator|=
name|patlen
operator|-
name|j
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
operator|(
name|int
operator|)
name|pattern
index|[
name|patlen
operator|-
literal|1
index|]
argument_list|)
condition|)
name|delta0
index|[
name|toupper
argument_list|(
operator|(
name|int
operator|)
name|pattern
index|[
name|patlen
operator|-
literal|1
index|]
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|'A'
init|;
name|j
operator|<=
literal|'Z'
condition|;
name|j
operator|++
control|)
name|cmap
index|[
name|j
index|]
operator|=
operator|(
name|char
operator|)
name|tolower
argument_list|(
operator|(
name|int
operator|)
name|j
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

