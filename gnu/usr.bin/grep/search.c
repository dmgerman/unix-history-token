begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* search.c - searching subroutines using dfa, kwset and regex for grep.    Copyright (C) 1992, 1998 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* Written August 1992 by Mike Haertel. */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"grep.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<gnuregex.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"regex.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"dfa.h"
end_include

begin_include
include|#
directive|include
file|"kwset.h"
end_include

begin_define
define|#
directive|define
name|NCHAR
value|(UCHAR_MAX + 1)
end_define

begin_decl_stmt
specifier|static
name|void
name|Gcompile
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|Ecompile
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|EGexecute
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|size_t
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|Fcompile
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|Fexecute
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|size_t
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|kwsinit
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Here is the matchers vector for the main program. */
end_comment

begin_decl_stmt
name|struct
name|matcher
name|matchers
index|[]
init|=
block|{
block|{
literal|"default"
block|,
name|Gcompile
block|,
name|EGexecute
block|}
block|,
block|{
literal|"grep"
block|,
name|Gcompile
block|,
name|EGexecute
block|}
block|,
block|{
literal|"egrep"
block|,
name|Ecompile
block|,
name|EGexecute
block|}
block|,
block|{
literal|"awk"
block|,
name|Ecompile
block|,
name|EGexecute
block|}
block|,
block|{
literal|"fgrep"
block|,
name|Fcompile
block|,
name|Fexecute
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For -w, we also consider _ to be word constituent.  */
end_comment

begin_define
define|#
directive|define
name|WCHAR
parameter_list|(
name|C
parameter_list|)
value|(ISALNUM(C) || (C) == '_')
end_define

begin_comment
comment|/* DFA compiled regexp. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dfa
name|dfa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Regex compiled regexp. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|re_pattern_buffer
name|regexbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* KWset compiled pattern.  For Ecompile and Gcompile, we compile    a list of strings, at least one of which is known to occur in    any string matching the regexp. */
end_comment

begin_decl_stmt
specifier|static
name|kwset_t
name|kwset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last compiled fixed string known to exactly match the regexp.    If kwsexec() returns< lastexact, then we don't need to    call the regexp matcher at all. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lastexact
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|dfaerror
parameter_list|(
name|char
specifier|const
modifier|*
name|mesg
parameter_list|)
block|{
name|fatal
argument_list|(
name|mesg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kwsinit
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|trans
index|[
name|NCHAR
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|match_icase
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAR
condition|;
operator|++
name|i
control|)
name|trans
index|[
name|i
index|]
operator|=
name|TOLOWER
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|kwset
operator|=
name|kwsalloc
argument_list|(
name|match_icase
condition|?
name|trans
else|:
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
operator|)
condition|)
name|fatal
argument_list|(
literal|"memory exhausted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If the DFA turns out to have some set of fixed strings one of    which must occur in the match, then we build a kwset matcher    to find those strings, and thus quickly filter out impossible    matches. */
end_comment

begin_function
specifier|static
name|void
name|kwsmusts
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dfamust
modifier|*
name|dm
decl_stmt|;
name|char
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|dfa
operator|.
name|musts
condition|)
block|{
name|kwsinit
argument_list|()
expr_stmt|;
comment|/* First, we compile in the substrings known to be exact 	 matches.  The kwset matcher will return the index 	 of the matching string that it chooses. */
for|for
control|(
name|dm
operator|=
name|dfa
operator|.
name|musts
init|;
name|dm
condition|;
name|dm
operator|=
name|dm
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|dm
operator|->
name|exact
condition|)
continue|continue;
operator|++
name|lastexact
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|kwsincr
argument_list|(
name|kwset
argument_list|,
name|dm
operator|->
name|must
argument_list|,
name|strlen
argument_list|(
name|dm
operator|->
name|must
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|err
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Now, we compile the substrings that will require 	 the use of the regexp matcher.  */
for|for
control|(
name|dm
operator|=
name|dfa
operator|.
name|musts
init|;
name|dm
condition|;
name|dm
operator|=
name|dm
operator|->
name|next
control|)
block|{
if|if
condition|(
name|dm
operator|->
name|exact
condition|)
continue|continue;
if|if
condition|(
operator|(
name|err
operator|=
name|kwsincr
argument_list|(
name|kwset
argument_list|,
name|dm
operator|->
name|must
argument_list|,
name|strlen
argument_list|(
name|dm
operator|->
name|must
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|err
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|kwsprep
argument_list|(
name|kwset
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|err
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|Gcompile
parameter_list|(
name|char
modifier|*
name|pattern
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_GREP
operator||
name|RE_HAT_LISTS_NOT_NEWLINE
argument_list|)
expr_stmt|;
name|dfasyntax
argument_list|(
name|RE_SYNTAX_GREP
operator||
name|RE_HAT_LISTS_NOT_NEWLINE
argument_list|,
name|match_icase
argument_list|,
name|eolbyte
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|re_compile_pattern
argument_list|(
name|pattern
argument_list|,
name|size
argument_list|,
operator|&
name|regexbuf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|err
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* In the match_words and match_lines cases, we use a different pattern      for the DFA matcher that will quickly throw out cases that won't work.      Then if DFA succeeds we do some hairy stuff using the regex matcher      to decide whether the match should really count. */
if|if
condition|(
name|match_words
operator|||
name|match_lines
condition|)
block|{
comment|/* In the whole-word case, we use the pattern: 	 (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$). 	 In the whole-line case, we use the pattern: 	 ^(userpattern)$. 	 BUG: Using [A-Za-z_] is locale-dependent! 	 So will use [:alnum:] */
name|char
modifier|*
name|n
init|=
name|malloc
argument_list|(
name|size
operator|+
literal|50
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|strcpy
argument_list|(
name|n
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_lines
condition|)
name|strcpy
argument_list|(
name|n
argument_list|,
literal|"^\\("
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_words
condition|)
name|strcpy
argument_list|(
name|n
argument_list|,
literal|"\\(^\\|[^[:alnum:]_]\\)\\("
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|n
operator|+
name|i
argument_list|,
name|pattern
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|i
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|match_words
condition|)
name|strcpy
argument_list|(
name|n
operator|+
name|i
argument_list|,
literal|"\\)\\([^[:alnum:]_]\\|$\\)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_lines
condition|)
name|strcpy
argument_list|(
name|n
operator|+
name|i
argument_list|,
literal|"\\)$"
argument_list|)
expr_stmt|;
name|i
operator|+=
name|strlen
argument_list|(
name|n
operator|+
name|i
argument_list|)
expr_stmt|;
name|dfacomp
argument_list|(
name|n
argument_list|,
name|i
argument_list|,
operator|&
name|dfa
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|dfacomp
argument_list|(
name|pattern
argument_list|,
name|size
argument_list|,
operator|&
name|dfa
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kwsmusts
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Ecompile
parameter_list|(
name|char
modifier|*
name|pattern
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|matcher
argument_list|,
literal|"awk"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_AWK
argument_list|)
expr_stmt|;
name|dfasyntax
argument_list|(
name|RE_SYNTAX_AWK
argument_list|,
name|match_icase
argument_list|,
name|eolbyte
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_POSIX_EGREP
argument_list|)
expr_stmt|;
name|dfasyntax
argument_list|(
name|RE_SYNTAX_POSIX_EGREP
argument_list|,
name|match_icase
argument_list|,
name|eolbyte
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|re_compile_pattern
argument_list|(
name|pattern
argument_list|,
name|size
argument_list|,
operator|&
name|regexbuf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|err
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* In the match_words and match_lines cases, we use a different pattern      for the DFA matcher that will quickly throw out cases that won't work.      Then if DFA succeeds we do some hairy stuff using the regex matcher      to decide whether the match should really count. */
if|if
condition|(
name|match_words
operator|||
name|match_lines
condition|)
block|{
comment|/* In the whole-word case, we use the pattern: 	 (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$). 	 In the whole-line case, we use the pattern: 	 ^(userpattern)$. 	 BUG: Using [A-Za-z_] is locale-dependent! 	 so will use the char class */
name|char
modifier|*
name|n
init|=
name|malloc
argument_list|(
name|size
operator|+
literal|50
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|strcpy
argument_list|(
name|n
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_lines
condition|)
name|strcpy
argument_list|(
name|n
argument_list|,
literal|"^("
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_words
condition|)
name|strcpy
argument_list|(
name|n
argument_list|,
literal|"(^|[^[:alnum:]_])("
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|n
operator|+
name|i
argument_list|,
name|pattern
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|i
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|match_words
condition|)
name|strcpy
argument_list|(
name|n
operator|+
name|i
argument_list|,
literal|")([^[:alnum:]_]|$)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_lines
condition|)
name|strcpy
argument_list|(
name|n
operator|+
name|i
argument_list|,
literal|")$"
argument_list|)
expr_stmt|;
name|i
operator|+=
name|strlen
argument_list|(
name|n
operator|+
name|i
argument_list|)
expr_stmt|;
name|dfacomp
argument_list|(
name|n
argument_list|,
name|i
argument_list|,
operator|&
name|dfa
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|dfacomp
argument_list|(
name|pattern
argument_list|,
name|size
argument_list|,
operator|&
name|dfa
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kwsmusts
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|EGexecute
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|char
modifier|*
modifier|*
name|endp
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|buflim
decl_stmt|,
modifier|*
name|beg
decl_stmt|,
modifier|*
name|end
decl_stmt|,
name|save
decl_stmt|;
name|char
name|eol
init|=
name|eolbyte
decl_stmt|;
name|int
name|backref
decl_stmt|,
name|start
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|kwsmatch
name|kwsm
decl_stmt|;
specifier|static
name|struct
name|re_registers
name|regs
decl_stmt|;
comment|/* This is static on account of a BRAIN-DEAD 				    Q@#%!# library interface in regex.c.  */
name|buflim
operator|=
name|buf
operator|+
name|size
expr_stmt|;
for|for
control|(
name|beg
operator|=
name|end
operator|=
name|buf
init|;
name|end
operator|<
name|buflim
condition|;
name|beg
operator|=
name|end
operator|+
literal|1
control|)
block|{
if|if
condition|(
name|kwset
condition|)
block|{
comment|/* Find a possible match using the KWset matcher. */
name|beg
operator|=
name|kwsexec
argument_list|(
name|kwset
argument_list|,
name|beg
argument_list|,
name|buflim
operator|-
name|beg
argument_list|,
operator|&
name|kwsm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|beg
condition|)
goto|goto
name|failure
goto|;
comment|/* Narrow down to the line containing the candidate, and 	     run it through DFA. */
name|end
operator|=
name|memchr
argument_list|(
name|beg
argument_list|,
name|eol
argument_list|,
name|buflim
operator|-
name|beg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|end
condition|)
name|end
operator|=
name|buflim
expr_stmt|;
while|while
condition|(
name|beg
operator|>
name|buf
operator|&&
name|beg
index|[
operator|-
literal|1
index|]
operator|!=
name|eol
condition|)
operator|--
name|beg
expr_stmt|;
name|save
operator|=
operator|*
name|end
expr_stmt|;
if|if
condition|(
name|kwsm
operator|.
name|index
operator|<
name|lastexact
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
operator|!
name|dfaexec
argument_list|(
operator|&
name|dfa
argument_list|,
name|beg
argument_list|,
name|end
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|backref
argument_list|)
condition|)
block|{
operator|*
name|end
operator|=
name|save
expr_stmt|;
continue|continue;
block|}
operator|*
name|end
operator|=
name|save
expr_stmt|;
comment|/* Successful, no backreferences encountered. */
if|if
condition|(
operator|!
name|backref
condition|)
goto|goto
name|success
goto|;
block|}
else|else
block|{
comment|/* No good fixed strings; start with DFA. */
name|save
operator|=
operator|*
name|buflim
expr_stmt|;
name|beg
operator|=
name|dfaexec
argument_list|(
operator|&
name|dfa
argument_list|,
name|beg
argument_list|,
name|buflim
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|backref
argument_list|)
expr_stmt|;
operator|*
name|buflim
operator|=
name|save
expr_stmt|;
if|if
condition|(
operator|!
name|beg
condition|)
goto|goto
name|failure
goto|;
comment|/* Narrow down to the line we've found. */
name|end
operator|=
name|memchr
argument_list|(
name|beg
argument_list|,
name|eol
argument_list|,
name|buflim
operator|-
name|beg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|end
condition|)
name|end
operator|=
name|buflim
expr_stmt|;
while|while
condition|(
name|beg
operator|>
name|buf
operator|&&
name|beg
index|[
operator|-
literal|1
index|]
operator|!=
name|eol
condition|)
operator|--
name|beg
expr_stmt|;
comment|/* Successful, no backreferences encountered! */
if|if
condition|(
operator|!
name|backref
condition|)
goto|goto
name|success
goto|;
block|}
comment|/* If we've made it to this point, this means DFA has seen 	 a probable match, and we need to run it through Regex. */
name|regexbuf
operator|.
name|not_eol
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|start
operator|=
name|re_search
argument_list|(
operator|&
name|regexbuf
argument_list|,
name|beg
argument_list|,
name|end
operator|-
name|beg
argument_list|,
literal|0
argument_list|,
name|end
operator|-
name|beg
argument_list|,
operator|&
name|regs
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|len
operator|=
name|regs
operator|.
name|end
index|[
literal|0
index|]
operator|-
name|start
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|match_lines
operator|&&
operator|!
name|match_words
operator|)
operator|||
operator|(
name|match_lines
operator|&&
name|len
operator|==
name|end
operator|-
name|beg
operator|)
condition|)
goto|goto
name|success
goto|;
comment|/* If -w, check if the match aligns with word boundaries. 	     We do this iteratively because: 	     (a) the line may contain more than one occurence of the pattern, and 	     (b) Several alternatives in the pattern might be valid at a given 	     point, and we may need to consider a shorter one to find a word 	     boundary. */
if|if
condition|(
name|match_words
condition|)
while|while
condition|(
name|start
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|start
operator|==
literal|0
operator|||
operator|!
name|WCHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|beg
index|[
name|start
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|len
operator|==
name|end
operator|-
name|beg
operator|||
operator|!
name|WCHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|beg
index|[
name|start
operator|+
name|len
index|]
argument_list|)
operator|)
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* Try a shorter length anchored at the same place. */
operator|--
name|len
expr_stmt|;
name|regexbuf
operator|.
name|not_eol
operator|=
literal|1
expr_stmt|;
name|len
operator|=
name|re_match
argument_list|(
operator|&
name|regexbuf
argument_list|,
name|beg
argument_list|,
name|start
operator|+
name|len
argument_list|,
name|start
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
comment|/* Try looking further on. */
if|if
condition|(
name|start
operator|==
name|end
operator|-
name|beg
condition|)
break|break;
operator|++
name|start
expr_stmt|;
name|regexbuf
operator|.
name|not_eol
operator|=
literal|0
expr_stmt|;
name|start
operator|=
name|re_search
argument_list|(
operator|&
name|regexbuf
argument_list|,
name|beg
argument_list|,
name|end
operator|-
name|beg
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|beg
operator|-
name|start
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
name|len
operator|=
name|regs
operator|.
name|end
index|[
literal|0
index|]
operator|-
name|start
expr_stmt|;
block|}
block|}
block|}
block|}
name|failure
label|:
return|return
literal|0
return|;
name|success
label|:
operator|*
name|endp
operator|=
name|end
operator|<
name|buflim
condition|?
name|end
operator|+
literal|1
else|:
name|end
expr_stmt|;
return|return
name|beg
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|Fcompile
parameter_list|(
name|char
modifier|*
name|pattern
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|char
modifier|*
name|beg
decl_stmt|,
modifier|*
name|lim
decl_stmt|,
modifier|*
name|err
decl_stmt|;
name|kwsinit
argument_list|()
expr_stmt|;
name|beg
operator|=
name|pattern
expr_stmt|;
do|do
block|{
for|for
control|(
name|lim
operator|=
name|beg
init|;
name|lim
operator|<
name|pattern
operator|+
name|size
operator|&&
operator|*
name|lim
operator|!=
literal|'\n'
condition|;
operator|++
name|lim
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|kwsincr
argument_list|(
name|kwset
argument_list|,
name|beg
argument_list|,
name|lim
operator|-
name|beg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|err
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lim
operator|<
name|pattern
operator|+
name|size
condition|)
operator|++
name|lim
expr_stmt|;
name|beg
operator|=
name|lim
expr_stmt|;
block|}
do|while
condition|(
name|beg
operator|<
name|pattern
operator|+
name|size
condition|)
do|;
if|if
condition|(
operator|(
name|err
operator|=
name|kwsprep
argument_list|(
name|kwset
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
name|err
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|Fexecute
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|char
modifier|*
modifier|*
name|endp
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|beg
decl_stmt|,
modifier|*
name|try
decl_stmt|,
modifier|*
name|end
decl_stmt|;
specifier|register
name|size_t
name|len
decl_stmt|;
name|char
name|eol
init|=
name|eolbyte
decl_stmt|;
name|struct
name|kwsmatch
name|kwsmatch
decl_stmt|;
for|for
control|(
name|beg
operator|=
name|buf
init|;
name|beg
operator|<=
name|buf
operator|+
name|size
condition|;
operator|++
name|beg
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|beg
operator|=
name|kwsexec
argument_list|(
name|kwset
argument_list|,
name|beg
argument_list|,
name|buf
operator|+
name|size
operator|-
name|beg
argument_list|,
operator|&
name|kwsmatch
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|kwsmatch
operator|.
name|size
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|match_lines
condition|)
block|{
if|if
condition|(
name|beg
operator|>
name|buf
operator|&&
name|beg
index|[
operator|-
literal|1
index|]
operator|!=
name|eol
condition|)
continue|continue;
if|if
condition|(
name|beg
operator|+
name|len
operator|<
name|buf
operator|+
name|size
operator|&&
name|beg
index|[
name|len
index|]
operator|!=
name|eol
condition|)
continue|continue;
goto|goto
name|success
goto|;
block|}
elseif|else
if|if
condition|(
name|match_words
condition|)
for|for
control|(
name|try
operator|=
name|beg
init|;
name|len
operator|&&
name|try
condition|;
control|)
block|{
if|if
condition|(
name|try
operator|>
name|buf
operator|&&
name|WCHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|try
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|try
operator|+
name|len
operator|<
name|buf
operator|+
name|size
operator|&&
name|WCHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|try
index|[
name|len
index|]
argument_list|)
condition|)
block|{
name|try
operator|=
name|kwsexec
argument_list|(
name|kwset
argument_list|,
name|beg
argument_list|,
operator|--
name|len
argument_list|,
operator|&
name|kwsmatch
argument_list|)
expr_stmt|;
name|len
operator|=
name|kwsmatch
operator|.
name|size
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
goto|goto
name|success
goto|;
block|}
else|else
goto|goto
name|success
goto|;
block|}
return|return
literal|0
return|;
name|success
label|:
if|if
condition|(
operator|(
name|end
operator|=
name|memchr
argument_list|(
name|beg
operator|+
name|len
argument_list|,
name|eol
argument_list|,
operator|(
name|buf
operator|+
name|size
operator|)
operator|-
operator|(
name|beg
operator|+
name|len
operator|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
operator|++
name|end
expr_stmt|;
else|else
name|end
operator|=
name|buf
operator|+
name|size
expr_stmt|;
operator|*
name|endp
operator|=
name|end
expr_stmt|;
while|while
condition|(
name|beg
operator|>
name|buf
operator|&&
name|beg
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
operator|--
name|beg
expr_stmt|;
return|return
name|beg
return|;
block|}
end_function

end_unit

