begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* search.c - searching subroutines using dfa, kwset and regex for grep.    Copyright 1992, 1998, 2000 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* Written August 1992 by Mike Haertel. */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
name|HAVE_WCTYPE_H
operator|&&
name|defined
name|HAVE_WCHAR_H
operator|&&
name|defined
name|HAVE_MBRTOWC
end_if

begin_comment
comment|/* We can handle multibyte string.  */
end_comment

begin_define
define|#
directive|define
name|MBS_SUPPORT
end_define

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<wctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"grep.h"
end_include

begin_include
include|#
directive|include
file|"regex.h"
end_include

begin_include
include|#
directive|include
file|"dfa.h"
end_include

begin_include
include|#
directive|include
file|"kwset.h"
end_include

begin_include
include|#
directive|include
file|"error.h"
end_include

begin_include
include|#
directive|include
file|"xalloc.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBPCRE
end_ifdef

begin_include
include|#
directive|include
file|<pcre.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NCHAR
value|(UCHAR_MAX + 1)
end_define

begin_comment
comment|/* For -w, we also consider _ to be word constituent.  */
end_comment

begin_define
define|#
directive|define
name|WCHAR
parameter_list|(
name|C
parameter_list|)
value|(ISALNUM(C) || (C) == '_')
end_define

begin_comment
comment|/* DFA compiled regexp. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dfa
name|dfa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The Regex compiled patterns.  */
end_comment

begin_struct
specifier|static
struct|struct
name|patterns
block|{
comment|/* Regex compiled regexp. */
name|struct
name|re_pattern_buffer
name|regexbuf
decl_stmt|;
name|struct
name|re_registers
name|regs
decl_stmt|;
comment|/* This is here on account of a BRAIN-DEAD 			       Q@#%!# library interface in regex.c.  */
block|}
name|patterns0
struct|;
end_struct

begin_decl_stmt
name|struct
name|patterns
modifier|*
name|patterns
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|pcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* KWset compiled pattern.  For Ecompile and Gcompile, we compile    a list of strings, at least one of which is known to occur in    any string matching the regexp. */
end_comment

begin_decl_stmt
specifier|static
name|kwset_t
name|kwset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of compiled fixed strings known to exactly match the regexp.    If kwsexec returns< kwset_exact_matches, then we don't need to    call the regexp matcher at all. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|kwset_exact_matches
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MBS_SUPPORT
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|check_multibyte_string
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
name|buf
operator|,
name|size_t
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|kwsinit
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|kwsmusts
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|Gcompile
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|Ecompile
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|EGexecute
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|size_t
operator|,
name|size_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|Fcompile
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|Fexecute
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|size_t
operator|,
name|size_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|Pcompile
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|Pexecute
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|size_t
operator|,
name|size_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|dfaerror
parameter_list|(
name|char
specifier|const
modifier|*
name|mesg
parameter_list|)
block|{
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kwsinit
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|trans
index|[
name|NCHAR
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|match_icase
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAR
condition|;
operator|++
name|i
control|)
name|trans
index|[
name|i
index|]
operator|=
name|TOLOWER
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|kwset
operator|=
name|kwsalloc
argument_list|(
name|match_icase
condition|?
name|trans
else|:
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If the DFA turns out to have some set of fixed strings one of    which must occur in the match, then we build a kwset matcher    to find those strings, and thus quickly filter out impossible    matches. */
end_comment

begin_function
specifier|static
name|void
name|kwsmusts
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dfamust
specifier|const
modifier|*
name|dm
decl_stmt|;
name|char
specifier|const
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|dfa
operator|.
name|musts
condition|)
block|{
name|kwsinit
argument_list|()
expr_stmt|;
comment|/* First, we compile in the substrings known to be exact 	 matches.  The kwset matcher will return the index 	 of the matching string that it chooses. */
for|for
control|(
name|dm
operator|=
name|dfa
operator|.
name|musts
init|;
name|dm
condition|;
name|dm
operator|=
name|dm
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|dm
operator|->
name|exact
condition|)
continue|continue;
operator|++
name|kwset_exact_matches
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|kwsincr
argument_list|(
name|kwset
argument_list|,
name|dm
operator|->
name|must
argument_list|,
name|strlen
argument_list|(
name|dm
operator|->
name|must
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
comment|/* Now, we compile the substrings that will require 	 the use of the regexp matcher.  */
for|for
control|(
name|dm
operator|=
name|dfa
operator|.
name|musts
init|;
name|dm
condition|;
name|dm
operator|=
name|dm
operator|->
name|next
control|)
block|{
if|if
condition|(
name|dm
operator|->
name|exact
condition|)
continue|continue;
if|if
condition|(
operator|(
name|err
operator|=
name|kwsincr
argument_list|(
name|kwset
argument_list|,
name|dm
operator|->
name|must
argument_list|,
name|strlen
argument_list|(
name|dm
operator|->
name|must
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|kwsprep
argument_list|(
name|kwset
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MBS_SUPPORT
end_ifdef

begin_comment
comment|/* This function allocate the array which correspond to "buf".    Then this check multibyte string and mark on the positions which    are not singlebyte character nor the first byte of a multibyte    character.  Caller must free the array.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|check_multibyte_string
parameter_list|(
name|char
specifier|const
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|char
modifier|*
name|mb_properties
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|mbstate_t
name|cur_state
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cur_state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|mb_properties
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
control|)
block|{
name|size_t
name|mbclen
decl_stmt|;
name|mbclen
operator|=
name|mbrlen
argument_list|(
name|buf
operator|+
name|i
argument_list|,
name|size
operator|-
name|i
argument_list|,
operator|&
name|cur_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbclen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|||
name|mbclen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|2
operator|||
name|mbclen
operator|==
literal|0
condition|)
block|{
comment|/* An invalid sequence, or a truncated multibyte character. 	     We treat it as a singlebyte character.  */
name|mbclen
operator|=
literal|1
expr_stmt|;
block|}
name|mb_properties
index|[
name|i
index|]
operator|=
name|mbclen
expr_stmt|;
name|i
operator|+=
name|mbclen
expr_stmt|;
block|}
return|return
name|mb_properties
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|Gcompile
parameter_list|(
name|char
specifier|const
modifier|*
name|pattern
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|char
specifier|const
modifier|*
name|sep
decl_stmt|;
name|size_t
name|total
init|=
name|size
decl_stmt|;
name|char
specifier|const
modifier|*
name|motif
init|=
name|pattern
decl_stmt|;
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_GREP
operator||
name|RE_HAT_LISTS_NOT_NEWLINE
argument_list|)
expr_stmt|;
name|dfasyntax
argument_list|(
name|RE_SYNTAX_GREP
operator||
name|RE_HAT_LISTS_NOT_NEWLINE
argument_list|,
name|match_icase
argument_list|,
name|eolbyte
argument_list|)
expr_stmt|;
comment|/* For GNU regex compiler we have to pass the patterns separately to detect      errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"      GNU regex should have raise a syntax error.  The same for backref, where      the backref should have been local to each pattern.  */
do|do
block|{
name|size_t
name|len
decl_stmt|;
name|sep
operator|=
name|memchr
argument_list|(
name|motif
argument_list|,
literal|'\n'
argument_list|,
name|total
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
condition|)
block|{
name|len
operator|=
name|sep
operator|-
name|motif
expr_stmt|;
name|sep
operator|++
expr_stmt|;
name|total
operator|-=
operator|(
name|len
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|total
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
block|}
name|patterns
operator|=
name|realloc
argument_list|(
name|patterns
argument_list|,
operator|(
name|pcount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|patterns
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|patterns
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
name|patterns
index|[
name|pcount
index|]
operator|=
name|patterns0
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|re_compile_pattern
argument_list|(
name|motif
argument_list|,
name|len
argument_list|,
operator|&
operator|(
name|patterns
index|[
name|pcount
index|]
operator|.
name|regexbuf
operator|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|pcount
operator|++
expr_stmt|;
name|motif
operator|=
name|sep
expr_stmt|;
block|}
do|while
condition|(
name|sep
operator|&&
name|total
operator|!=
literal|0
condition|)
do|;
comment|/* In the match_words and match_lines cases, we use a different pattern      for the DFA matcher that will quickly throw out cases that won't work.      Then if DFA succeeds we do some hairy stuff using the regex matcher      to decide whether the match should really count. */
if|if
condition|(
name|match_words
operator|||
name|match_lines
condition|)
block|{
comment|/* In the whole-word case, we use the pattern: 	 \(^\|[^[:alnum:]_]\)\(userpattern\)\([^[:alnum:]_]|$\). 	 In the whole-line case, we use the pattern: 	 ^\(userpattern\)$.  */
specifier|static
name|char
specifier|const
name|line_beg
index|[]
init|=
literal|"^\\("
decl_stmt|;
specifier|static
name|char
specifier|const
name|line_end
index|[]
init|=
literal|"\\)$"
decl_stmt|;
specifier|static
name|char
specifier|const
name|word_beg
index|[]
init|=
literal|"\\(^\\|[^[:alnum:]_]\\)\\("
decl_stmt|;
specifier|static
name|char
specifier|const
name|word_end
index|[]
init|=
literal|"\\)\\([^[:alnum:]_]\\|$\\)"
decl_stmt|;
name|char
modifier|*
name|n
init|=
name|malloc
argument_list|(
sizeof|sizeof
name|word_beg
operator|-
literal|1
operator|+
name|size
operator|+
sizeof|sizeof
name|word_end
argument_list|)
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|strcpy
argument_list|(
name|n
argument_list|,
name|match_lines
condition|?
name|line_beg
else|:
name|word_beg
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|n
operator|+
name|i
argument_list|,
name|pattern
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|i
operator|+=
name|size
expr_stmt|;
name|strcpy
argument_list|(
name|n
operator|+
name|i
argument_list|,
name|match_lines
condition|?
name|line_end
else|:
name|word_end
argument_list|)
expr_stmt|;
name|i
operator|+=
name|strlen
argument_list|(
name|n
operator|+
name|i
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|n
expr_stmt|;
name|size
operator|=
name|i
expr_stmt|;
block|}
name|dfacomp
argument_list|(
name|pattern
argument_list|,
name|size
argument_list|,
operator|&
name|dfa
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kwsmusts
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Ecompile
parameter_list|(
name|char
specifier|const
modifier|*
name|pattern
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|sep
decl_stmt|;
name|size_t
name|total
init|=
name|size
decl_stmt|;
name|char
specifier|const
modifier|*
name|motif
init|=
name|pattern
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|matcher
argument_list|,
literal|"awk"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_AWK
argument_list|)
expr_stmt|;
name|dfasyntax
argument_list|(
name|RE_SYNTAX_AWK
argument_list|,
name|match_icase
argument_list|,
name|eolbyte
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_POSIX_EGREP
argument_list|)
expr_stmt|;
name|dfasyntax
argument_list|(
name|RE_SYNTAX_POSIX_EGREP
argument_list|,
name|match_icase
argument_list|,
name|eolbyte
argument_list|)
expr_stmt|;
block|}
comment|/* For GNU regex compiler we have to pass the patterns separately to detect      errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"      GNU regex should have raise a syntax error.  The same for backref, where      the backref should have been local to each pattern.  */
do|do
block|{
name|size_t
name|len
decl_stmt|;
name|sep
operator|=
name|memchr
argument_list|(
name|motif
argument_list|,
literal|'\n'
argument_list|,
name|total
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
condition|)
block|{
name|len
operator|=
name|sep
operator|-
name|motif
expr_stmt|;
name|sep
operator|++
expr_stmt|;
name|total
operator|-=
operator|(
name|len
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|total
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
block|}
name|patterns
operator|=
name|realloc
argument_list|(
name|patterns
argument_list|,
operator|(
name|pcount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|patterns
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|patterns
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
name|patterns
index|[
name|pcount
index|]
operator|=
name|patterns0
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|re_compile_pattern
argument_list|(
name|motif
argument_list|,
name|len
argument_list|,
operator|&
operator|(
name|patterns
index|[
name|pcount
index|]
operator|.
name|regexbuf
operator|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|pcount
operator|++
expr_stmt|;
name|motif
operator|=
name|sep
expr_stmt|;
block|}
do|while
condition|(
name|sep
operator|&&
name|total
operator|!=
literal|0
condition|)
do|;
comment|/* In the match_words and match_lines cases, we use a different pattern      for the DFA matcher that will quickly throw out cases that won't work.      Then if DFA succeeds we do some hairy stuff using the regex matcher      to decide whether the match should really count. */
if|if
condition|(
name|match_words
operator|||
name|match_lines
condition|)
block|{
comment|/* In the whole-word case, we use the pattern: 	 (^|[^[:alnum:]_])(userpattern)([^[:alnum:]_]|$). 	 In the whole-line case, we use the pattern: 	 ^(userpattern)$.  */
specifier|static
name|char
specifier|const
name|line_beg
index|[]
init|=
literal|"^("
decl_stmt|;
specifier|static
name|char
specifier|const
name|line_end
index|[]
init|=
literal|")$"
decl_stmt|;
specifier|static
name|char
specifier|const
name|word_beg
index|[]
init|=
literal|"(^|[^[:alnum:]_])("
decl_stmt|;
specifier|static
name|char
specifier|const
name|word_end
index|[]
init|=
literal|")([^[:alnum:]_]|$)"
decl_stmt|;
name|char
modifier|*
name|n
init|=
name|malloc
argument_list|(
sizeof|sizeof
name|word_beg
operator|-
literal|1
operator|+
name|size
operator|+
sizeof|sizeof
name|word_end
argument_list|)
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|strcpy
argument_list|(
name|n
argument_list|,
name|match_lines
condition|?
name|line_beg
else|:
name|word_beg
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|n
operator|+
name|i
argument_list|,
name|pattern
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|i
operator|+=
name|size
expr_stmt|;
name|strcpy
argument_list|(
name|n
operator|+
name|i
argument_list|,
name|match_lines
condition|?
name|line_end
else|:
name|word_end
argument_list|)
expr_stmt|;
name|i
operator|+=
name|strlen
argument_list|(
name|n
operator|+
name|i
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|n
expr_stmt|;
name|size
operator|=
name|i
expr_stmt|;
block|}
name|dfacomp
argument_list|(
name|pattern
argument_list|,
name|size
argument_list|,
operator|&
name|dfa
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kwsmusts
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|EGexecute
parameter_list|(
name|char
specifier|const
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
modifier|*
name|match_size
parameter_list|,
name|int
name|exact
parameter_list|)
block|{
specifier|register
name|char
specifier|const
modifier|*
name|buflim
decl_stmt|,
modifier|*
name|beg
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|char
name|eol
init|=
name|eolbyte
decl_stmt|;
name|int
name|backref
decl_stmt|,
name|start
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|kwsmatch
name|kwsm
decl_stmt|;
name|size_t
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
name|char
modifier|*
name|mb_properties
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* MBS_SUPPORT */
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|kwset
condition|)
name|mb_properties
operator|=
name|check_multibyte_string
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MBS_SUPPORT */
name|buflim
operator|=
name|buf
operator|+
name|size
expr_stmt|;
for|for
control|(
name|beg
operator|=
name|end
operator|=
name|buf
init|;
name|end
operator|<
name|buflim
condition|;
name|beg
operator|=
name|end
control|)
block|{
if|if
condition|(
operator|!
name|exact
condition|)
block|{
if|if
condition|(
name|kwset
condition|)
block|{
comment|/* Find a possible match using the KWset matcher. */
name|size_t
name|offset
init|=
name|kwsexec
argument_list|(
name|kwset
argument_list|,
name|beg
argument_list|,
name|buflim
operator|-
name|beg
argument_list|,
operator|&
name|kwsm
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
goto|goto
name|failure
goto|;
name|beg
operator|+=
name|offset
expr_stmt|;
comment|/* Narrow down to the line containing the candidate, and 		 run it through DFA. */
name|end
operator|=
name|memchr
argument_list|(
name|beg
argument_list|,
name|eol
argument_list|,
name|buflim
operator|-
name|beg
argument_list|)
expr_stmt|;
name|end
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|mb_properties
index|[
name|beg
operator|-
name|buf
index|]
operator|==
literal|0
condition|)
continue|continue;
endif|#
directive|endif
while|while
condition|(
name|beg
operator|>
name|buf
operator|&&
name|beg
index|[
operator|-
literal|1
index|]
operator|!=
name|eol
condition|)
operator|--
name|beg
expr_stmt|;
if|if
condition|(
name|kwsm
operator|.
name|index
operator|<
name|kwset_exact_matches
condition|)
goto|goto
name|success_in_beg_and_end
goto|;
if|if
condition|(
name|dfaexec
argument_list|(
operator|&
name|dfa
argument_list|,
name|beg
argument_list|,
name|end
operator|-
name|beg
argument_list|,
operator|&
name|backref
argument_list|)
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
continue|continue;
block|}
else|else
block|{
comment|/* No good fixed strings; start with DFA. */
name|size_t
name|offset
init|=
name|dfaexec
argument_list|(
operator|&
name|dfa
argument_list|,
name|beg
argument_list|,
name|buflim
operator|-
name|beg
argument_list|,
operator|&
name|backref
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
break|break;
comment|/* Narrow down to the line we've found. */
name|beg
operator|+=
name|offset
expr_stmt|;
name|end
operator|=
name|memchr
argument_list|(
name|beg
argument_list|,
name|eol
argument_list|,
name|buflim
operator|-
name|beg
argument_list|)
expr_stmt|;
name|end
operator|++
expr_stmt|;
while|while
condition|(
name|beg
operator|>
name|buf
operator|&&
name|beg
index|[
operator|-
literal|1
index|]
operator|!=
name|eol
condition|)
operator|--
name|beg
expr_stmt|;
block|}
comment|/* Successful, no backreferences encountered! */
if|if
condition|(
operator|!
name|backref
condition|)
goto|goto
name|success_in_beg_and_end
goto|;
block|}
else|else
name|end
operator|=
name|beg
operator|+
name|size
expr_stmt|;
comment|/* If we've made it to this point, this means DFA has seen 	 a probable match, and we need to run it through Regex. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcount
condition|;
name|i
operator|++
control|)
block|{
name|patterns
index|[
name|i
index|]
operator|.
name|regexbuf
operator|.
name|not_eol
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
operator|(
name|start
operator|=
name|re_search
argument_list|(
operator|&
operator|(
name|patterns
index|[
name|i
index|]
operator|.
name|regexbuf
operator|)
argument_list|,
name|beg
argument_list|,
name|end
operator|-
name|beg
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|end
operator|-
name|beg
operator|-
literal|1
argument_list|,
operator|&
operator|(
name|patterns
index|[
name|i
index|]
operator|.
name|regs
operator|)
argument_list|)
operator|)
condition|)
block|{
name|len
operator|=
name|patterns
index|[
name|i
index|]
operator|.
name|regs
operator|.
name|end
index|[
literal|0
index|]
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|exact
operator|&&
operator|!
name|match_words
condition|)
goto|goto
name|success_in_start_and_len
goto|;
if|if
condition|(
operator|(
operator|!
name|match_lines
operator|&&
operator|!
name|match_words
operator|)
operator|||
operator|(
name|match_lines
operator|&&
name|len
operator|==
name|end
operator|-
name|beg
operator|-
literal|1
operator|)
condition|)
goto|goto
name|success_in_beg_and_end
goto|;
comment|/* If -w, check if the match aligns with word boundaries. 		 We do this iteratively because: 		 (a) the line may contain more than one occurence of the 		 pattern, and 		 (b) Several alternatives in the pattern might be valid at a 		 given point, and we may need to consider a shorter one to 		 find a word boundary.  */
if|if
condition|(
name|match_words
condition|)
while|while
condition|(
name|start
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|start
operator|==
literal|0
operator|||
operator|!
name|WCHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|beg
index|[
name|start
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|len
operator|==
name|end
operator|-
name|beg
operator|-
literal|1
operator|||
operator|!
name|WCHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|beg
index|[
name|start
operator|+
name|len
index|]
argument_list|)
operator|)
condition|)
goto|goto
name|success_in_start_and_len
goto|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* Try a shorter length anchored at the same place. */
operator|--
name|len
expr_stmt|;
name|patterns
index|[
name|i
index|]
operator|.
name|regexbuf
operator|.
name|not_eol
operator|=
literal|1
expr_stmt|;
name|len
operator|=
name|re_match
argument_list|(
operator|&
operator|(
name|patterns
index|[
name|i
index|]
operator|.
name|regexbuf
operator|)
argument_list|,
name|beg
argument_list|,
name|start
operator|+
name|len
argument_list|,
name|start
argument_list|,
operator|&
operator|(
name|patterns
index|[
name|i
index|]
operator|.
name|regs
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
comment|/* Try looking further on. */
if|if
condition|(
name|start
operator|==
name|end
operator|-
name|beg
operator|-
literal|1
condition|)
break|break;
operator|++
name|start
expr_stmt|;
name|patterns
index|[
name|i
index|]
operator|.
name|regexbuf
operator|.
name|not_eol
operator|=
literal|0
expr_stmt|;
name|start
operator|=
name|re_search
argument_list|(
operator|&
operator|(
name|patterns
index|[
name|i
index|]
operator|.
name|regexbuf
operator|)
argument_list|,
name|beg
argument_list|,
name|end
operator|-
name|beg
operator|-
literal|1
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|beg
operator|-
literal|1
operator|-
name|start
argument_list|,
operator|&
operator|(
name|patterns
index|[
name|i
index|]
operator|.
name|regs
operator|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|patterns
index|[
name|i
index|]
operator|.
name|regs
operator|.
name|end
index|[
literal|0
index|]
operator|-
name|start
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* for Regex patterns.  */
block|}
comment|/* for (beg = end ..) */
name|failure
label|:
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|mb_properties
condition|)
name|free
argument_list|(
name|mb_properties
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MBS_SUPPORT */
return|return
operator|(
name|size_t
operator|)
operator|-
literal|1
return|;
name|success_in_beg_and_end
label|:
name|len
operator|=
name|end
operator|-
name|beg
expr_stmt|;
name|start
operator|=
name|beg
operator|-
name|buf
expr_stmt|;
comment|/* FALLTHROUGH */
name|success_in_start_and_len
label|:
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|mb_properties
condition|)
name|free
argument_list|(
name|mb_properties
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MBS_SUPPORT */
operator|*
name|match_size
operator|=
name|len
expr_stmt|;
return|return
name|start
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|Fcompile
parameter_list|(
name|char
specifier|const
modifier|*
name|pattern
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|beg
decl_stmt|,
modifier|*
name|lim
decl_stmt|,
modifier|*
name|err
decl_stmt|;
name|kwsinit
argument_list|()
expr_stmt|;
name|beg
operator|=
name|pattern
expr_stmt|;
do|do
block|{
for|for
control|(
name|lim
operator|=
name|beg
init|;
name|lim
operator|<
name|pattern
operator|+
name|size
operator|&&
operator|*
name|lim
operator|!=
literal|'\n'
condition|;
operator|++
name|lim
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|kwsincr
argument_list|(
name|kwset
argument_list|,
name|beg
argument_list|,
name|lim
operator|-
name|beg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|lim
operator|<
name|pattern
operator|+
name|size
condition|)
operator|++
name|lim
expr_stmt|;
name|beg
operator|=
name|lim
expr_stmt|;
block|}
do|while
condition|(
name|beg
operator|<
name|pattern
operator|+
name|size
condition|)
do|;
if|if
condition|(
operator|(
name|err
operator|=
name|kwsprep
argument_list|(
name|kwset
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|Fexecute
parameter_list|(
name|char
specifier|const
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
modifier|*
name|match_size
parameter_list|,
name|int
name|exact
parameter_list|)
block|{
specifier|register
name|char
specifier|const
modifier|*
name|beg
decl_stmt|,
modifier|*
name|try
decl_stmt|,
modifier|*
name|end
decl_stmt|;
specifier|register
name|size_t
name|len
decl_stmt|;
name|char
name|eol
init|=
name|eolbyte
decl_stmt|;
name|struct
name|kwsmatch
name|kwsmatch
decl_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
name|char
modifier|*
name|mb_properties
decl_stmt|;
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
condition|)
name|mb_properties
operator|=
name|check_multibyte_string
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MBS_SUPPORT */
for|for
control|(
name|beg
operator|=
name|buf
init|;
name|beg
operator|<=
name|buf
operator|+
name|size
condition|;
operator|++
name|beg
control|)
block|{
name|size_t
name|offset
init|=
name|kwsexec
argument_list|(
name|kwset
argument_list|,
name|beg
argument_list|,
name|buf
operator|+
name|size
operator|-
name|beg
argument_list|,
operator|&
name|kwsmatch
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
goto|goto
name|failure
goto|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|mb_properties
index|[
name|offset
operator|+
name|beg
operator|-
name|buf
index|]
operator|==
literal|0
condition|)
continue|continue;
comment|/* It is a part of multibyte character.  */
endif|#
directive|endif
comment|/* MBS_SUPPORT */
name|beg
operator|+=
name|offset
expr_stmt|;
name|len
operator|=
name|kwsmatch
operator|.
name|size
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|exact
operator|&&
operator|!
name|match_words
condition|)
goto|goto
name|success_in_beg_and_len
goto|;
if|if
condition|(
name|match_lines
condition|)
block|{
if|if
condition|(
name|beg
operator|>
name|buf
operator|&&
name|beg
index|[
operator|-
literal|1
index|]
operator|!=
name|eol
condition|)
continue|continue;
if|if
condition|(
name|beg
operator|+
name|len
operator|<
name|buf
operator|+
name|size
operator|&&
name|beg
index|[
name|len
index|]
operator|!=
name|eol
condition|)
continue|continue;
goto|goto
name|success
goto|;
block|}
elseif|else
if|if
condition|(
name|match_words
condition|)
block|{
while|while
condition|(
name|offset
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|offset
operator|==
literal|0
operator|||
operator|!
name|WCHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|beg
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|len
operator|==
name|end
operator|-
name|beg
operator|-
literal|1
operator|||
operator|!
name|WCHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|beg
index|[
name|len
index|]
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|exact
condition|)
comment|/* Returns the whole line now we know there's a word match. */
goto|goto
name|success
goto|;
else|else
comment|/* Returns just this word match. */
goto|goto
name|success_in_beg_and_len
goto|;
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* Try a shorter length anchored at the same place. */
operator|--
name|len
expr_stmt|;
name|offset
operator|=
name|kwsexec
argument_list|(
name|kwset
argument_list|,
name|beg
argument_list|,
name|len
argument_list|,
operator|&
name|kwsmatch
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
comment|/* Try a different anchor. */
block|}
name|beg
operator|+=
name|offset
expr_stmt|;
name|len
operator|=
name|kwsmatch
operator|.
name|size
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
block|}
else|else
goto|goto
name|success
goto|;
block|}
name|failure
label|:
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
condition|)
name|free
argument_list|(
name|mb_properties
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MBS_SUPPORT */
return|return
operator|-
literal|1
return|;
name|success
label|:
name|end
operator|=
name|memchr
argument_list|(
name|beg
operator|+
name|len
argument_list|,
name|eol
argument_list|,
operator|(
name|buf
operator|+
name|size
operator|)
operator|-
operator|(
name|beg
operator|+
name|len
operator|)
argument_list|)
expr_stmt|;
name|end
operator|++
expr_stmt|;
while|while
condition|(
name|buf
operator|<
name|beg
operator|&&
name|beg
index|[
operator|-
literal|1
index|]
operator|!=
name|eol
condition|)
operator|--
name|beg
expr_stmt|;
name|len
operator|=
name|end
operator|-
name|beg
expr_stmt|;
comment|/* FALLTHROUGH */
name|success_in_beg_and_len
label|:
operator|*
name|match_size
operator|=
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
condition|)
name|free
argument_list|(
name|mb_properties
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MBS_SUPPORT */
return|return
name|beg
operator|-
name|buf
return|;
block|}
end_function

begin_if
if|#
directive|if
name|HAVE_LIBPCRE
end_if

begin_comment
comment|/* Compiled internal form of a Perl regular expression.  */
end_comment

begin_decl_stmt
specifier|static
name|pcre
modifier|*
name|cre
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Additional information about the pattern.  */
end_comment

begin_decl_stmt
specifier|static
name|pcre_extra
modifier|*
name|extra
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|Pcompile
parameter_list|(
name|char
specifier|const
modifier|*
name|pattern
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|#
directive|if
operator|!
name|HAVE_LIBPCRE
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"The -P option is not supported"
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|e
decl_stmt|;
name|char
specifier|const
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|re
init|=
name|xmalloc
argument_list|(
literal|4
operator|*
name|size
operator|+
literal|7
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
name|PCRE_MULTILINE
operator||
operator|(
name|match_icase
condition|?
name|PCRE_CASELESS
else|:
literal|0
operator|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|patlim
init|=
name|pattern
operator|+
name|size
decl_stmt|;
name|char
modifier|*
name|n
init|=
name|re
decl_stmt|;
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
name|char
specifier|const
modifier|*
name|pnul
decl_stmt|;
comment|/* FIXME: Remove this restriction.  */
if|if
condition|(
name|eolbyte
operator|!=
literal|'\n'
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"The -P and -z options cannot be combined"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|n
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|match_lines
condition|)
name|strcpy
argument_list|(
name|n
argument_list|,
literal|"^("
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_words
condition|)
name|strcpy
argument_list|(
name|n
argument_list|,
literal|"\\b("
argument_list|)
expr_stmt|;
name|n
operator|+=
name|strlen
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* The PCRE interface doesn't allow NUL bytes in the pattern, so      replace each NUL byte in the pattern with the four characters      "\000", removing a preceding backslash if there are an odd      number of backslashes before the NUL.       FIXME: This method does not work with some multibyte character      encodings, notably Shift-JIS, where a multibyte character can end      in a backslash byte.  */
for|for
control|(
name|p
operator|=
name|pattern
init|;
operator|(
name|pnul
operator|=
name|memchr
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|,
name|patlim
operator|-
name|p
argument_list|)
operator|)
condition|;
name|p
operator|=
name|pnul
operator|+
literal|1
control|)
block|{
name|memcpy
argument_list|(
name|n
argument_list|,
name|p
argument_list|,
name|pnul
operator|-
name|p
argument_list|)
expr_stmt|;
name|n
operator|+=
name|pnul
operator|-
name|p
expr_stmt|;
for|for
control|(
name|p
operator|=
name|pnul
init|;
name|pattern
operator|<
name|p
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|;
name|p
operator|--
control|)
continue|continue;
name|n
operator|-=
operator|(
name|pnul
operator|-
name|p
operator|)
operator|&
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|n
argument_list|,
literal|"\\000"
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|4
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|n
argument_list|,
name|p
argument_list|,
name|patlim
operator|-
name|p
argument_list|)
expr_stmt|;
name|n
operator|+=
name|patlim
operator|-
name|p
expr_stmt|;
operator|*
name|n
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|match_words
condition|)
name|strcpy
argument_list|(
name|n
argument_list|,
literal|")\\b"
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_lines
condition|)
name|strcpy
argument_list|(
name|n
argument_list|,
literal|")$"
argument_list|)
expr_stmt|;
name|cre
operator|=
name|pcre_compile
argument_list|(
name|re
argument_list|,
name|flags
argument_list|,
operator|&
name|ep
argument_list|,
operator|&
name|e
argument_list|,
name|pcre_maketables
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cre
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|extra
operator|=
name|pcre_study
argument_list|(
name|cre
argument_list|,
literal|0
argument_list|,
operator|&
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|re
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|size_t
name|Pexecute
parameter_list|(
name|char
specifier|const
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
modifier|*
name|match_size
parameter_list|,
name|int
name|exact
parameter_list|)
block|{
if|#
directive|if
operator|!
name|HAVE_LIBPCRE
name|abort
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
else|#
directive|else
comment|/* This array must have at least two elements; everything after that      is just for performance improvement in pcre_exec.  */
name|int
name|sub
index|[
literal|300
index|]
decl_stmt|;
name|int
name|e
init|=
name|pcre_exec
argument_list|(
name|cre
argument_list|,
name|extra
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sub
argument_list|,
sizeof|sizeof
name|sub
operator|/
sizeof|sizeof
expr|*
name|sub
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|<=
literal|0
condition|)
block|{
switch|switch
condition|(
name|e
condition|)
block|{
case|case
name|PCRE_ERROR_NOMATCH
case|:
return|return
operator|-
literal|1
return|;
case|case
name|PCRE_ERROR_NOMEMORY
case|:
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Narrow down to the line we've found.  */
name|char
specifier|const
modifier|*
name|beg
init|=
name|buf
operator|+
name|sub
index|[
literal|0
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
name|end
init|=
name|buf
operator|+
name|sub
index|[
literal|1
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
name|buflim
init|=
name|buf
operator|+
name|size
decl_stmt|;
name|char
name|eol
init|=
name|eolbyte
decl_stmt|;
if|if
condition|(
operator|!
name|exact
condition|)
block|{
name|end
operator|=
name|memchr
argument_list|(
name|end
argument_list|,
name|eol
argument_list|,
name|buflim
operator|-
name|end
argument_list|)
expr_stmt|;
name|end
operator|++
expr_stmt|;
while|while
condition|(
name|buf
operator|<
name|beg
operator|&&
name|beg
index|[
operator|-
literal|1
index|]
operator|!=
name|eol
condition|)
operator|--
name|beg
expr_stmt|;
block|}
operator|*
name|match_size
operator|=
name|end
operator|-
name|beg
expr_stmt|;
return|return
name|beg
operator|-
name|buf
return|;
block|}
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
name|struct
name|matcher
specifier|const
name|matchers
index|[]
init|=
block|{
block|{
literal|"default"
block|,
name|Gcompile
block|,
name|EGexecute
block|}
block|,
block|{
literal|"grep"
block|,
name|Gcompile
block|,
name|EGexecute
block|}
block|,
block|{
literal|"egrep"
block|,
name|Ecompile
block|,
name|EGexecute
block|}
block|,
block|{
literal|"awk"
block|,
name|Ecompile
block|,
name|EGexecute
block|}
block|,
block|{
literal|"fgrep"
block|,
name|Fcompile
block|,
name|Fexecute
block|}
block|,
block|{
literal|"perl"
block|,
name|Pcompile
block|,
name|Pexecute
block|}
block|,
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

end_unit

