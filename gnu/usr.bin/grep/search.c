begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* search.c - searching subroutines using dfa, kwset and regex for grep.    Copyright 1992, 1998, 2000 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* Written August 1992 by Mike Haertel. */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_GNU_SOURCE
end_ifndef

begin_define
define|#
directive|define
name|_GNU_SOURCE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
name|HAVE_WCTYPE_H
operator|&&
name|defined
name|HAVE_WCHAR_H
operator|&&
name|defined
name|HAVE_MBRTOWC
end_if

begin_comment
comment|/* We can handle multibyte string.  */
end_comment

begin_define
define|#
directive|define
name|MBS_SUPPORT
end_define

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<wctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"grep.h"
end_include

begin_include
include|#
directive|include
file|"regex.h"
end_include

begin_include
include|#
directive|include
file|"dfa.h"
end_include

begin_include
include|#
directive|include
file|"kwset.h"
end_include

begin_include
include|#
directive|include
file|"error.h"
end_include

begin_include
include|#
directive|include
file|"xalloc.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBPCRE
end_ifdef

begin_include
include|#
directive|include
file|<pcre.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LANGINFO_CODESET
end_ifdef

begin_include
include|#
directive|include
file|<langinfo.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NCHAR
value|(UCHAR_MAX + 1)
end_define

begin_comment
comment|/* For -w, we also consider _ to be word constituent.  */
end_comment

begin_define
define|#
directive|define
name|WCHAR
parameter_list|(
name|C
parameter_list|)
value|(ISALNUM(C) || (C) == '_')
end_define

begin_comment
comment|/* DFA compiled regexp. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dfa
name|dfa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The Regex compiled patterns.  */
end_comment

begin_struct
specifier|static
struct|struct
name|patterns
block|{
comment|/* Regex compiled regexp. */
name|struct
name|re_pattern_buffer
name|regexbuf
decl_stmt|;
name|struct
name|re_registers
name|regs
decl_stmt|;
comment|/* This is here on account of a BRAIN-DEAD 			       Q@#%!# library interface in regex.c.  */
block|}
name|patterns0
struct|;
end_struct

begin_decl_stmt
name|struct
name|patterns
modifier|*
name|patterns
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|pcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* KWset compiled pattern.  For Ecompile and Gcompile, we compile    a list of strings, at least one of which is known to occur in    any string matching the regexp. */
end_comment

begin_decl_stmt
specifier|static
name|kwset_t
name|kwset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of compiled fixed strings known to exactly match the regexp.    If kwsexec returns< kwset_exact_matches, then we don't need to    call the regexp matcher at all. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|kwset_exact_matches
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* UTF-8 encoding allows some optimizations that we can't otherwise    assume in a multibyte encoding. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|using_utf8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|kwsinit
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|kwsmusts
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|Gcompile
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|Ecompile
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|EGexecute
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|size_t
operator|,
name|size_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|Fcompile
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|Fexecute
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|size_t
operator|,
name|size_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|Pcompile
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|Pexecute
name|PARAMS
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|size_t
operator|,
name|size_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|check_utf8
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HAVE_LANGINFO_CODESET
if|if
condition|(
name|strcmp
argument_list|(
name|nl_langinfo
argument_list|(
name|CODESET
argument_list|)
argument_list|,
literal|"UTF-8"
argument_list|)
operator|==
literal|0
condition|)
name|using_utf8
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|dfaerror
parameter_list|(
name|char
specifier|const
modifier|*
name|mesg
parameter_list|)
block|{
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kwsinit
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|trans
index|[
name|NCHAR
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|match_icase
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAR
condition|;
operator|++
name|i
control|)
name|trans
index|[
name|i
index|]
operator|=
name|TOLOWER
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|kwset
operator|=
name|kwsalloc
argument_list|(
name|match_icase
condition|?
name|trans
else|:
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If the DFA turns out to have some set of fixed strings one of    which must occur in the match, then we build a kwset matcher    to find those strings, and thus quickly filter out impossible    matches. */
end_comment

begin_function
specifier|static
name|void
name|kwsmusts
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dfamust
specifier|const
modifier|*
name|dm
decl_stmt|;
name|char
specifier|const
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|dfa
operator|.
name|musts
condition|)
block|{
name|kwsinit
argument_list|()
expr_stmt|;
comment|/* First, we compile in the substrings known to be exact 	 matches.  The kwset matcher will return the index 	 of the matching string that it chooses. */
for|for
control|(
name|dm
operator|=
name|dfa
operator|.
name|musts
init|;
name|dm
condition|;
name|dm
operator|=
name|dm
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|dm
operator|->
name|exact
condition|)
continue|continue;
operator|++
name|kwset_exact_matches
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|kwsincr
argument_list|(
name|kwset
argument_list|,
name|dm
operator|->
name|must
argument_list|,
name|strlen
argument_list|(
name|dm
operator|->
name|must
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
comment|/* Now, we compile the substrings that will require 	 the use of the regexp matcher.  */
for|for
control|(
name|dm
operator|=
name|dfa
operator|.
name|musts
init|;
name|dm
condition|;
name|dm
operator|=
name|dm
operator|->
name|next
control|)
block|{
if|if
condition|(
name|dm
operator|->
name|exact
condition|)
continue|continue;
if|if
condition|(
operator|(
name|err
operator|=
name|kwsincr
argument_list|(
name|kwset
argument_list|,
name|dm
operator|->
name|must
argument_list|,
name|strlen
argument_list|(
name|dm
operator|->
name|must
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|kwsprep
argument_list|(
name|kwset
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|Gcompile
parameter_list|(
name|char
specifier|const
modifier|*
name|pattern
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|char
specifier|const
modifier|*
name|sep
decl_stmt|;
name|size_t
name|total
init|=
name|size
decl_stmt|;
name|char
specifier|const
modifier|*
name|motif
init|=
name|pattern
decl_stmt|;
name|check_utf8
argument_list|()
expr_stmt|;
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_GREP
operator||
name|RE_HAT_LISTS_NOT_NEWLINE
operator||
operator|(
name|match_icase
condition|?
name|RE_ICASE
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|dfasyntax
argument_list|(
name|RE_SYNTAX_GREP
operator||
name|RE_HAT_LISTS_NOT_NEWLINE
argument_list|,
name|match_icase
argument_list|,
name|eolbyte
argument_list|)
expr_stmt|;
comment|/* For GNU regex compiler we have to pass the patterns separately to detect      errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"      GNU regex should have raise a syntax error.  The same for backref, where      the backref should have been local to each pattern.  */
do|do
block|{
name|size_t
name|len
decl_stmt|;
name|sep
operator|=
name|memchr
argument_list|(
name|motif
argument_list|,
literal|'\n'
argument_list|,
name|total
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
condition|)
block|{
name|len
operator|=
name|sep
operator|-
name|motif
expr_stmt|;
name|sep
operator|++
expr_stmt|;
name|total
operator|-=
operator|(
name|len
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|total
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
block|}
name|patterns
operator|=
name|realloc
argument_list|(
name|patterns
argument_list|,
operator|(
name|pcount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|patterns
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|patterns
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
name|patterns
index|[
name|pcount
index|]
operator|=
name|patterns0
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|re_compile_pattern
argument_list|(
name|motif
argument_list|,
name|len
argument_list|,
operator|&
operator|(
name|patterns
index|[
name|pcount
index|]
operator|.
name|regexbuf
operator|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|pcount
operator|++
expr_stmt|;
name|motif
operator|=
name|sep
expr_stmt|;
block|}
do|while
condition|(
name|sep
operator|&&
name|total
operator|!=
literal|0
condition|)
do|;
comment|/* In the match_words and match_lines cases, we use a different pattern      for the DFA matcher that will quickly throw out cases that won't work.      Then if DFA succeeds we do some hairy stuff using the regex matcher      to decide whether the match should really count. */
if|if
condition|(
name|match_words
operator|||
name|match_lines
condition|)
block|{
comment|/* In the whole-word case, we use the pattern: 	 \(^\|[^[:alnum:]_]\)\(userpattern\)\([^[:alnum:]_]|$\). 	 In the whole-line case, we use the pattern: 	 ^\(userpattern\)$.  */
specifier|static
name|char
specifier|const
name|line_beg
index|[]
init|=
literal|"^\\("
decl_stmt|;
specifier|static
name|char
specifier|const
name|line_end
index|[]
init|=
literal|"\\)$"
decl_stmt|;
specifier|static
name|char
specifier|const
name|word_beg
index|[]
init|=
literal|"\\(^\\|[^[:alnum:]_]\\)\\("
decl_stmt|;
specifier|static
name|char
specifier|const
name|word_end
index|[]
init|=
literal|"\\)\\([^[:alnum:]_]\\|$\\)"
decl_stmt|;
name|char
modifier|*
name|n
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
name|word_beg
operator|-
literal|1
operator|+
name|size
operator|+
sizeof|sizeof
name|word_end
argument_list|)
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|strcpy
argument_list|(
name|n
argument_list|,
name|match_lines
condition|?
name|line_beg
else|:
name|word_beg
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|n
operator|+
name|i
argument_list|,
name|pattern
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|i
operator|+=
name|size
expr_stmt|;
name|strcpy
argument_list|(
name|n
operator|+
name|i
argument_list|,
name|match_lines
condition|?
name|line_end
else|:
name|word_end
argument_list|)
expr_stmt|;
name|i
operator|+=
name|strlen
argument_list|(
name|n
operator|+
name|i
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|n
expr_stmt|;
name|size
operator|=
name|i
expr_stmt|;
block|}
name|dfacomp
argument_list|(
name|pattern
argument_list|,
name|size
argument_list|,
operator|&
name|dfa
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kwsmusts
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Ecompile
parameter_list|(
name|char
specifier|const
modifier|*
name|pattern
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|sep
decl_stmt|;
name|size_t
name|total
init|=
name|size
decl_stmt|;
name|char
specifier|const
modifier|*
name|motif
init|=
name|pattern
decl_stmt|;
name|check_utf8
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|matcher
argument_list|,
literal|"awk"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_AWK
operator||
operator|(
name|match_icase
condition|?
name|RE_ICASE
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|dfasyntax
argument_list|(
name|RE_SYNTAX_AWK
argument_list|,
name|match_icase
argument_list|,
name|eolbyte
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_POSIX_EGREP
operator||
operator|(
name|match_icase
condition|?
name|RE_ICASE
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|dfasyntax
argument_list|(
name|RE_SYNTAX_POSIX_EGREP
argument_list|,
name|match_icase
argument_list|,
name|eolbyte
argument_list|)
expr_stmt|;
block|}
comment|/* For GNU regex compiler we have to pass the patterns separately to detect      errors like "[\nallo\n]\n".  The patterns here are "[", "allo" and "]"      GNU regex should have raise a syntax error.  The same for backref, where      the backref should have been local to each pattern.  */
do|do
block|{
name|size_t
name|len
decl_stmt|;
name|sep
operator|=
name|memchr
argument_list|(
name|motif
argument_list|,
literal|'\n'
argument_list|,
name|total
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
condition|)
block|{
name|len
operator|=
name|sep
operator|-
name|motif
expr_stmt|;
name|sep
operator|++
expr_stmt|;
name|total
operator|-=
operator|(
name|len
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|total
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
block|}
name|patterns
operator|=
name|realloc
argument_list|(
name|patterns
argument_list|,
operator|(
name|pcount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|patterns
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|patterns
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
name|_
argument_list|(
literal|"memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
name|patterns
index|[
name|pcount
index|]
operator|=
name|patterns0
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|re_compile_pattern
argument_list|(
name|motif
argument_list|,
name|len
argument_list|,
operator|&
operator|(
name|patterns
index|[
name|pcount
index|]
operator|.
name|regexbuf
operator|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|pcount
operator|++
expr_stmt|;
name|motif
operator|=
name|sep
expr_stmt|;
block|}
do|while
condition|(
name|sep
operator|&&
name|total
operator|!=
literal|0
condition|)
do|;
comment|/* In the match_words and match_lines cases, we use a different pattern      for the DFA matcher that will quickly throw out cases that won't work.      Then if DFA succeeds we do some hairy stuff using the regex matcher      to decide whether the match should really count. */
if|if
condition|(
name|match_words
operator|||
name|match_lines
condition|)
block|{
comment|/* In the whole-word case, we use the pattern: 	 (^|[^[:alnum:]_])(userpattern)([^[:alnum:]_]|$). 	 In the whole-line case, we use the pattern: 	 ^(userpattern)$.  */
specifier|static
name|char
specifier|const
name|line_beg
index|[]
init|=
literal|"^("
decl_stmt|;
specifier|static
name|char
specifier|const
name|line_end
index|[]
init|=
literal|")$"
decl_stmt|;
specifier|static
name|char
specifier|const
name|word_beg
index|[]
init|=
literal|"(^|[^[:alnum:]_])("
decl_stmt|;
specifier|static
name|char
specifier|const
name|word_end
index|[]
init|=
literal|")([^[:alnum:]_]|$)"
decl_stmt|;
name|char
modifier|*
name|n
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
name|word_beg
operator|-
literal|1
operator|+
name|size
operator|+
sizeof|sizeof
name|word_end
argument_list|)
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|strcpy
argument_list|(
name|n
argument_list|,
name|match_lines
condition|?
name|line_beg
else|:
name|word_beg
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|n
operator|+
name|i
argument_list|,
name|pattern
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|i
operator|+=
name|size
expr_stmt|;
name|strcpy
argument_list|(
name|n
operator|+
name|i
argument_list|,
name|match_lines
condition|?
name|line_end
else|:
name|word_end
argument_list|)
expr_stmt|;
name|i
operator|+=
name|strlen
argument_list|(
name|n
operator|+
name|i
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|n
expr_stmt|;
name|size
operator|=
name|i
expr_stmt|;
block|}
name|dfacomp
argument_list|(
name|pattern
argument_list|,
name|size
argument_list|,
operator|&
name|dfa
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kwsmusts
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|EGexecute
parameter_list|(
name|char
specifier|const
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
modifier|*
name|match_size
parameter_list|,
name|int
name|exact
parameter_list|)
block|{
specifier|register
name|char
specifier|const
modifier|*
name|buflim
decl_stmt|,
modifier|*
name|beg
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|char
name|eol
init|=
name|eolbyte
decl_stmt|;
name|int
name|backref
decl_stmt|,
name|start
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|kwsmatch
name|kwsm
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|ret_val
decl_stmt|;
specifier|static
name|int
name|use_dfa
decl_stmt|;
specifier|static
name|int
name|use_dfa_checked
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
specifier|const
name|char
modifier|*
name|last_char
init|=
name|NULL
decl_stmt|;
name|int
name|mb_cur_max
init|=
name|MB_CUR_MAX
decl_stmt|;
name|mbstate_t
name|mbs
decl_stmt|;
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MBS_SUPPORT */
if|if
condition|(
operator|!
name|use_dfa_checked
condition|)
block|{
name|char
modifier|*
name|grep_use_dfa
init|=
name|getenv
argument_list|(
literal|"GREP_USE_DFA"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|grep_use_dfa
condition|)
block|{
ifdef|#
directive|ifdef
name|MBS_SUPPORT
comment|/* Turn off DFA when processing multibyte input. */
name|use_dfa
operator|=
operator|(
name|MB_CUR_MAX
operator|==
literal|1
operator|)
expr_stmt|;
else|#
directive|else
name|use_dfa
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* MBS_SUPPORT */
block|}
else|else
block|{
name|use_dfa
operator|=
name|atoi
argument_list|(
name|grep_use_dfa
argument_list|)
expr_stmt|;
block|}
name|use_dfa_checked
operator|=
literal|1
expr_stmt|;
block|}
name|buflim
operator|=
name|buf
operator|+
name|size
expr_stmt|;
for|for
control|(
name|beg
operator|=
name|end
operator|=
name|buf
init|;
name|end
operator|<
name|buflim
condition|;
name|beg
operator|=
name|end
control|)
block|{
if|if
condition|(
operator|!
name|exact
condition|)
block|{
if|if
condition|(
name|kwset
condition|)
block|{
comment|/* Find a possible match using the KWset matcher. */
ifdef|#
directive|ifdef
name|MBS_SUPPORT
name|size_t
name|bytes_left
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* MBS_SUPPORT */
name|size_t
name|offset
decl_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
comment|/* kwsexec doesn't work with match_icase and multibyte input. */
if|if
condition|(
name|match_icase
operator|&&
name|mb_cur_max
operator|>
literal|1
condition|)
comment|/* Avoid kwset */
name|offset
operator|=
literal|0
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* MBS_SUPPORT */
name|offset
operator|=
name|kwsexec
argument_list|(
name|kwset
argument_list|,
name|beg
argument_list|,
name|buflim
operator|-
name|beg
argument_list|,
operator|&
name|kwsm
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
goto|goto
name|failure
goto|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|mb_cur_max
operator|>
literal|1
operator|&&
operator|!
name|using_utf8
condition|)
block|{
name|bytes_left
operator|=
name|offset
expr_stmt|;
while|while
condition|(
name|bytes_left
condition|)
block|{
name|size_t
name|mlen
init|=
name|mbrlen
argument_list|(
name|beg
argument_list|,
name|bytes_left
argument_list|,
operator|&
name|mbs
argument_list|)
decl_stmt|;
name|last_char
operator|=
name|beg
expr_stmt|;
if|if
condition|(
name|mlen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|||
name|mlen
operator|==
literal|0
condition|)
block|{
comment|/* Incomplete character: treat as single-byte. */
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
name|beg
operator|++
expr_stmt|;
name|bytes_left
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|mlen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|2
condition|)
comment|/* Offset points inside multibyte character: 			 * no good. */
break|break;
name|beg
operator|+=
name|mlen
expr_stmt|;
name|bytes_left
operator|-=
name|mlen
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* MBS_SUPPORT */
name|beg
operator|+=
name|offset
expr_stmt|;
comment|/* Narrow down to the line containing the candidate, and 		 run it through DFA. */
name|end
operator|=
name|memchr
argument_list|(
name|beg
argument_list|,
name|eol
argument_list|,
name|buflim
operator|-
name|beg
argument_list|)
expr_stmt|;
name|end
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|mb_cur_max
operator|>
literal|1
operator|&&
name|bytes_left
condition|)
continue|continue;
endif|#
directive|endif
comment|/* MBS_SUPPORT */
while|while
condition|(
name|beg
operator|>
name|buf
operator|&&
name|beg
index|[
operator|-
literal|1
index|]
operator|!=
name|eol
condition|)
operator|--
name|beg
expr_stmt|;
if|if
condition|(
ifdef|#
directive|ifdef
name|MBS_SUPPORT
operator|!
operator|(
name|match_icase
operator|&&
name|mb_cur_max
operator|>
literal|1
operator|)
operator|&&
endif|#
directive|endif
comment|/* MBS_SUPPORT */
operator|(
name|kwsm
operator|.
name|index
operator|<
name|kwset_exact_matches
operator|)
condition|)
goto|goto
name|success_in_beg_and_end
goto|;
if|if
condition|(
name|use_dfa
operator|&&
name|dfaexec
argument_list|(
operator|&
name|dfa
argument_list|,
name|beg
argument_list|,
name|end
operator|-
name|beg
argument_list|,
operator|&
name|backref
argument_list|)
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
continue|continue;
block|}
else|else
block|{
comment|/* No good fixed strings; start with DFA. */
ifdef|#
directive|ifdef
name|MBS_SUPPORT
name|size_t
name|bytes_left
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* MBS_SUPPORT */
name|size_t
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|use_dfa
condition|)
name|offset
operator|=
name|dfaexec
argument_list|(
operator|&
name|dfa
argument_list|,
name|beg
argument_list|,
name|buflim
operator|-
name|beg
argument_list|,
operator|&
name|backref
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
break|break;
comment|/* Narrow down to the line we've found. */
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|mb_cur_max
operator|>
literal|1
operator|&&
operator|!
name|using_utf8
condition|)
block|{
name|bytes_left
operator|=
name|offset
expr_stmt|;
while|while
condition|(
name|bytes_left
condition|)
block|{
name|size_t
name|mlen
init|=
name|mbrlen
argument_list|(
name|beg
argument_list|,
name|bytes_left
argument_list|,
operator|&
name|mbs
argument_list|)
decl_stmt|;
name|last_char
operator|=
name|beg
expr_stmt|;
if|if
condition|(
name|mlen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|||
name|mlen
operator|==
literal|0
condition|)
block|{
comment|/* Incomplete character: treat as single-byte. */
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
name|beg
operator|++
expr_stmt|;
name|bytes_left
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|mlen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|2
condition|)
comment|/* Offset points inside multibyte character: 			 * no good. */
break|break;
name|beg
operator|+=
name|mlen
expr_stmt|;
name|bytes_left
operator|-=
name|mlen
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* MBS_SUPPORT */
name|beg
operator|+=
name|offset
expr_stmt|;
name|end
operator|=
name|memchr
argument_list|(
name|beg
argument_list|,
name|eol
argument_list|,
name|buflim
operator|-
name|beg
argument_list|)
expr_stmt|;
name|end
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|mb_cur_max
operator|>
literal|1
operator|&&
name|bytes_left
condition|)
continue|continue;
endif|#
directive|endif
comment|/* MBS_SUPPORT */
while|while
condition|(
name|beg
operator|>
name|buf
operator|&&
name|beg
index|[
operator|-
literal|1
index|]
operator|!=
name|eol
condition|)
operator|--
name|beg
expr_stmt|;
block|}
comment|/* Successful, no backreferences encountered! */
if|if
condition|(
name|use_dfa
operator|&&
operator|!
name|backref
condition|)
goto|goto
name|success_in_beg_and_end
goto|;
block|}
else|else
name|end
operator|=
name|beg
operator|+
name|size
expr_stmt|;
comment|/* If we've made it to this point, this means DFA has seen 	 a probable match, and we need to run it through Regex. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcount
condition|;
name|i
operator|++
control|)
block|{
name|patterns
index|[
name|i
index|]
operator|.
name|regexbuf
operator|.
name|not_eol
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
operator|(
name|start
operator|=
name|re_search
argument_list|(
operator|&
operator|(
name|patterns
index|[
name|i
index|]
operator|.
name|regexbuf
operator|)
argument_list|,
name|beg
argument_list|,
name|end
operator|-
name|beg
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|end
operator|-
name|beg
operator|-
literal|1
argument_list|,
operator|&
operator|(
name|patterns
index|[
name|i
index|]
operator|.
name|regs
operator|)
argument_list|)
operator|)
condition|)
block|{
name|len
operator|=
name|patterns
index|[
name|i
index|]
operator|.
name|regs
operator|.
name|end
index|[
literal|0
index|]
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|exact
operator|&&
operator|!
name|match_words
condition|)
goto|goto
name|success_in_start_and_len
goto|;
if|if
condition|(
operator|(
operator|!
name|match_lines
operator|&&
operator|!
name|match_words
operator|)
operator|||
operator|(
name|match_lines
operator|&&
name|len
operator|==
name|end
operator|-
name|beg
operator|-
literal|1
operator|)
condition|)
goto|goto
name|success_in_beg_and_end
goto|;
comment|/* If -w, check if the match aligns with word boundaries. 		 We do this iteratively because: 		 (a) the line may contain more than one occurence of the 		 pattern, and 		 (b) Several alternatives in the pattern might be valid at a 		 given point, and we may need to consider a shorter one to 		 find a word boundary.  */
if|if
condition|(
name|match_words
condition|)
while|while
condition|(
name|start
operator|>=
literal|0
condition|)
block|{
name|int
name|lword_match
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|start
operator|==
literal|0
condition|)
name|lword_match
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|assert
argument_list|(
name|start
operator|>
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|mb_cur_max
operator|>
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|mr
decl_stmt|;
name|wchar_t
name|pwc
decl_stmt|;
comment|/* Locate the start of the multibyte character 			       before the match position (== beg + start).  */
if|if
condition|(
name|using_utf8
condition|)
block|{
comment|/* UTF-8 is a special case: scan backwards 				   until we find a 7-bit character or a 				   lead byte.  */
name|s
operator|=
name|beg
operator|+
name|start
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|s
operator|>
name|buf
operator|&&
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
operator|>=
literal|0x80
operator|&&
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
operator|<=
literal|0xbf
condition|)
operator|--
name|s
expr_stmt|;
block|}
else|else
block|{
comment|/* Scan forwards to find the start of the 				   last complete character before the 				   match position.  */
name|size_t
name|bytes_left
init|=
name|start
operator|-
literal|1
decl_stmt|;
name|s
operator|=
name|beg
expr_stmt|;
while|while
condition|(
name|bytes_left
operator|>
literal|0
condition|)
block|{
name|mr
operator|=
name|mbrlen
argument_list|(
name|s
argument_list|,
name|bytes_left
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mr
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|||
name|mr
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|mbs
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|bytes_left
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|mr
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|2
condition|)
block|{
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|mbs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|s
operator|+=
name|mr
expr_stmt|;
name|bytes_left
operator|-=
name|mr
expr_stmt|;
block|}
block|}
name|mr
operator|=
name|mbrtowc
argument_list|(
operator|&
name|pwc
argument_list|,
name|s
argument_list|,
name|beg
operator|+
name|start
operator|-
name|s
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mr
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|2
operator|||
name|mr
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|||
name|mr
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
name|lword_match
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|iswalnum
argument_list|(
name|pwc
argument_list|)
operator|||
name|pwc
operator|==
literal|L'
expr|_'
operator|)
operator|&&
name|mr
operator|==
name|beg
operator|+
name|start
operator|-
name|s
condition|)
name|lword_match
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* MBS_SUPPORT */
if|if
condition|(
operator|!
name|WCHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|beg
index|[
name|start
operator|-
literal|1
index|]
argument_list|)
condition|)
name|lword_match
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|lword_match
condition|)
block|{
name|int
name|rword_match
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|start
operator|+
name|len
operator|==
name|end
operator|-
name|beg
operator|-
literal|1
condition|)
name|rword_match
operator|=
literal|1
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|mb_cur_max
operator|>
literal|1
condition|)
block|{
name|wchar_t
name|nwc
decl_stmt|;
name|int
name|mr
decl_stmt|;
name|mr
operator|=
name|mbtowc
argument_list|(
operator|&
name|nwc
argument_list|,
name|beg
operator|+
name|start
operator|+
name|len
argument_list|,
name|end
operator|-
name|beg
operator|-
name|start
operator|-
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mr
operator|<=
literal|0
condition|)
block|{
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
name|rword_match
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|iswalnum
argument_list|(
name|nwc
argument_list|)
operator|&&
name|nwc
operator|!=
literal|L'
expr|_'
condition|)
name|rword_match
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* MBS_SUPPORT */
if|if
condition|(
operator|!
name|WCHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|beg
index|[
name|start
operator|+
name|len
index|]
argument_list|)
condition|)
name|rword_match
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rword_match
condition|)
block|{
if|if
condition|(
operator|!
name|exact
condition|)
comment|/* Returns the whole line. */
goto|goto
name|success_in_beg_and_end
goto|;
else|else
comment|/* Returns just this word match. */
goto|goto
name|success_in_start_and_len
goto|;
block|}
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* Try a shorter length anchored at the same place. */
operator|--
name|len
expr_stmt|;
name|patterns
index|[
name|i
index|]
operator|.
name|regexbuf
operator|.
name|not_eol
operator|=
literal|1
expr_stmt|;
name|len
operator|=
name|re_match
argument_list|(
operator|&
operator|(
name|patterns
index|[
name|i
index|]
operator|.
name|regexbuf
operator|)
argument_list|,
name|beg
argument_list|,
name|start
operator|+
name|len
argument_list|,
name|start
argument_list|,
operator|&
operator|(
name|patterns
index|[
name|i
index|]
operator|.
name|regs
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
comment|/* Try looking further on. */
if|if
condition|(
name|start
operator|==
name|end
operator|-
name|beg
operator|-
literal|1
condition|)
break|break;
operator|++
name|start
expr_stmt|;
name|patterns
index|[
name|i
index|]
operator|.
name|regexbuf
operator|.
name|not_eol
operator|=
literal|0
expr_stmt|;
name|start
operator|=
name|re_search
argument_list|(
operator|&
operator|(
name|patterns
index|[
name|i
index|]
operator|.
name|regexbuf
operator|)
argument_list|,
name|beg
argument_list|,
name|end
operator|-
name|beg
operator|-
literal|1
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|beg
operator|-
literal|1
operator|-
name|start
argument_list|,
operator|&
operator|(
name|patterns
index|[
name|i
index|]
operator|.
name|regs
operator|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|patterns
index|[
name|i
index|]
operator|.
name|regs
operator|.
name|end
index|[
literal|0
index|]
operator|-
name|start
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* for Regex patterns.  */
block|}
comment|/* for (beg = end ..) */
name|failure
label|:
return|return
operator|(
name|size_t
operator|)
operator|-
literal|1
return|;
name|success_in_beg_and_end
label|:
name|len
operator|=
name|end
operator|-
name|beg
expr_stmt|;
name|start
operator|=
name|beg
operator|-
name|buf
expr_stmt|;
comment|/* FALLTHROUGH */
name|success_in_start_and_len
label|:
operator|*
name|match_size
operator|=
name|len
expr_stmt|;
return|return
name|start
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MBS_SUPPORT
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|f_i_multibyte
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether we're using the new -Fi MB method */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|wchar_t
modifier|*
modifier|*
name|patterns
decl_stmt|;
name|size_t
name|count
decl_stmt|,
name|maxlen
decl_stmt|;
name|unsigned
name|char
modifier|*
name|match
decl_stmt|;
block|}
name|Fimb
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|Fcompile
parameter_list|(
name|char
specifier|const
modifier|*
name|pattern
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|int
name|mb_cur_max
init|=
name|MB_CUR_MAX
decl_stmt|;
name|char
specifier|const
modifier|*
name|beg
decl_stmt|,
modifier|*
name|lim
decl_stmt|,
modifier|*
name|err
decl_stmt|;
name|check_utf8
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
comment|/* Support -F -i for UTF-8 input. */
if|if
condition|(
name|match_icase
operator|&&
name|mb_cur_max
operator|>
literal|1
condition|)
block|{
name|mbstate_t
name|mbs
decl_stmt|;
name|wchar_t
modifier|*
name|wcpattern
init|=
name|xmalloc
argument_list|(
operator|(
name|size
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|patternend
init|=
name|pattern
decl_stmt|;
name|size_t
name|wcsize
decl_stmt|;
name|kwset_t
name|fimb_kwset
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|starts
init|=
name|NULL
decl_stmt|;
name|wchar_t
modifier|*
name|wcbeg
decl_stmt|,
modifier|*
name|wclim
decl_stmt|;
name|size_t
name|allocated
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|mbs
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__GNU_LIBRARY__
name|wcsize
operator|=
name|mbsnrtowcs
argument_list|(
name|wcpattern
argument_list|,
operator|&
name|patternend
argument_list|,
name|size
argument_list|,
name|size
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|patternend
operator|!=
name|pattern
operator|+
name|size
condition|)
name|wcsize
operator|=
operator|(
name|size_t
operator|)
operator|-
literal|1
expr_stmt|;
else|#
directive|else
block|{
name|char
modifier|*
name|patterncopy
init|=
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|patterncopy
argument_list|,
name|pattern
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|patterncopy
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
name|patternend
operator|=
name|patterncopy
expr_stmt|;
name|wcsize
operator|=
name|mbsrtowcs
argument_list|(
name|wcpattern
argument_list|,
operator|&
name|patternend
argument_list|,
name|size
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|patternend
operator|!=
name|patterncopy
operator|+
name|size
condition|)
name|wcsize
operator|=
operator|(
name|size_t
operator|)
operator|-
literal|1
expr_stmt|;
name|free
argument_list|(
name|patterncopy
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|wcsize
operator|+
literal|2
operator|<=
literal|2
condition|)
block|{
name|fimb_fail
label|:
name|free
argument_list|(
name|wcpattern
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|starts
argument_list|)
expr_stmt|;
if|if
condition|(
name|fimb_kwset
condition|)
name|kwsfree
argument_list|(
name|fimb_kwset
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|Fimb
operator|.
name|patterns
argument_list|)
expr_stmt|;
name|Fimb
operator|.
name|patterns
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|fimb_kwset
operator|=
name|kwsalloc
argument_list|(
name|NULL
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
name|starts
operator|=
name|xmalloc
argument_list|(
name|mb_cur_max
operator|*
literal|3
argument_list|)
expr_stmt|;
name|wcbeg
operator|=
name|wcpattern
expr_stmt|;
do|do
block|{
name|int
name|i
decl_stmt|;
name|size_t
name|wclen
decl_stmt|;
if|if
condition|(
name|Fimb
operator|.
name|count
operator|>=
name|allocated
condition|)
block|{
if|if
condition|(
name|allocated
operator|==
literal|0
condition|)
name|allocated
operator|=
literal|128
expr_stmt|;
else|else
name|allocated
operator|*=
literal|2
expr_stmt|;
name|Fimb
operator|.
name|patterns
operator|=
name|xrealloc
argument_list|(
name|Fimb
operator|.
name|patterns
argument_list|,
sizeof|sizeof
argument_list|(
name|wchar_t
operator|*
argument_list|)
operator|*
name|allocated
argument_list|)
expr_stmt|;
block|}
name|Fimb
operator|.
name|patterns
index|[
name|Fimb
operator|.
name|count
operator|++
index|]
operator|=
name|wcbeg
expr_stmt|;
for|for
control|(
name|wclim
operator|=
name|wcbeg
init|;
name|wclim
operator|<
name|wcpattern
operator|+
name|wcsize
operator|&&
operator|*
name|wclim
operator|!=
literal|L'
expr|\n'
condition|;
operator|++
name|wclim
control|)
operator|*
name|wclim
operator|=
name|towlower
argument_list|(
operator|*
name|wclim
argument_list|)
expr_stmt|;
operator|*
name|wclim
operator|=
literal|L'
expr|\0'
expr_stmt|;
name|wclen
operator|=
name|wclim
operator|-
name|wcbeg
expr_stmt|;
if|if
condition|(
name|wclen
operator|>
name|Fimb
operator|.
name|maxlen
condition|)
name|Fimb
operator|.
name|maxlen
operator|=
name|wclen
expr_stmt|;
if|if
condition|(
name|wclen
operator|>
literal|3
condition|)
name|wclen
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|wclen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|kwsincr
argument_list|(
name|fimb_kwset
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|wclen
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|p
init|=
name|starts
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|wclen
condition|;
operator|++
name|j
control|)
block|{
name|wchar_t
name|wc
init|=
name|wcbeg
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|i
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
condition|)
block|{
name|wc
operator|=
name|towupper
argument_list|(
name|wc
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc
operator|==
name|wcbeg
index|[
name|j
index|]
condition|)
continue|continue;
block|}
name|k
operator|=
name|wctomb
argument_list|(
name|p
argument_list|,
name|wc
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<=
literal|0
condition|)
goto|goto
name|fimb_fail
goto|;
name|p
operator|+=
name|k
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|kwsincr
argument_list|(
name|fimb_kwset
argument_list|,
name|starts
argument_list|,
name|p
operator|-
name|starts
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wclim
operator|<
name|wcpattern
operator|+
name|wcsize
condition|)
operator|++
name|wclim
expr_stmt|;
name|wcbeg
operator|=
name|wclim
expr_stmt|;
block|}
do|while
condition|(
name|wcbeg
operator|<
name|wcpattern
operator|+
name|wcsize
condition|)
do|;
name|f_i_multibyte
operator|=
literal|1
expr_stmt|;
name|kwset
operator|=
name|fimb_kwset
expr_stmt|;
name|free
argument_list|(
name|starts
argument_list|)
expr_stmt|;
name|Fimb
operator|.
name|match
operator|=
name|xmalloc
argument_list|(
name|Fimb
operator|.
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|kwsprep
argument_list|(
name|kwset
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* MBS_SUPPORT */
name|kwsinit
argument_list|()
expr_stmt|;
name|beg
operator|=
name|pattern
expr_stmt|;
do|do
block|{
for|for
control|(
name|lim
operator|=
name|beg
init|;
name|lim
operator|<
name|pattern
operator|+
name|size
operator|&&
operator|*
name|lim
operator|!=
literal|'\n'
condition|;
operator|++
name|lim
control|)
empty_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|kwsincr
argument_list|(
name|kwset
argument_list|,
name|beg
argument_list|,
name|lim
operator|-
name|beg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|lim
operator|<
name|pattern
operator|+
name|size
condition|)
operator|++
name|lim
expr_stmt|;
name|beg
operator|=
name|lim
expr_stmt|;
block|}
do|while
condition|(
name|beg
operator|<
name|pattern
operator|+
name|size
condition|)
do|;
if|if
condition|(
operator|(
name|err
operator|=
name|kwsprep
argument_list|(
name|kwset
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MBS_SUPPORT
end_ifdef

begin_function
specifier|static
name|int
name|Fimbexec
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
modifier|*
name|plen
parameter_list|,
name|int
name|exact
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|,
name|letter
decl_stmt|,
name|i
decl_stmt|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|mbstate_t
name|mbs
decl_stmt|;
name|wchar_t
name|wc
decl_stmt|;
name|int
name|patterns_left
decl_stmt|;
name|assert
argument_list|(
name|match_icase
operator|&&
name|f_i_multibyte
operator|==
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|MB_CUR_MAX
operator|>
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|mbs
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|Fimb
operator|.
name|match
argument_list|,
literal|'\1'
argument_list|,
name|Fimb
operator|.
name|count
argument_list|)
expr_stmt|;
name|letter
operator|=
name|len
operator|=
literal|0
expr_stmt|;
name|patterns_left
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|patterns_left
operator|&&
name|len
operator|<=
name|size
condition|)
block|{
name|size_t
name|c
decl_stmt|;
name|patterns_left
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|size
condition|)
block|{
name|c
operator|=
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|buf
operator|+
name|len
argument_list|,
name|size
operator|-
name|len
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|+
literal|2
operator|<=
literal|2
condition|)
return|return
name|ret
return|;
name|wc
operator|=
name|towlower
argument_list|(
name|wc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
literal|1
expr_stmt|;
name|wc
operator|=
literal|L'
expr|\0'
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Fimb
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|Fimb
operator|.
name|match
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|Fimb
operator|.
name|patterns
index|[
name|i
index|]
index|[
name|letter
index|]
operator|==
literal|L'
expr|\0'
condition|)
block|{
comment|/* Found a match. */
operator|*
name|plen
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|exact
operator|&&
operator|!
name|match_words
condition|)
return|return
literal|0
return|;
else|else
block|{
comment|/* For -w or exact look for longest match.  */
name|ret
operator|=
literal|0
expr_stmt|;
name|Fimb
operator|.
name|match
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|Fimb
operator|.
name|patterns
index|[
name|i
index|]
index|[
name|letter
index|]
operator|==
name|wc
condition|)
name|patterns_left
operator|=
literal|1
expr_stmt|;
else|else
name|Fimb
operator|.
name|match
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
name|len
operator|+=
name|c
expr_stmt|;
name|letter
operator|++
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MBS_SUPPORT */
end_comment

begin_function
specifier|static
name|size_t
name|Fexecute
parameter_list|(
name|char
specifier|const
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
modifier|*
name|match_size
parameter_list|,
name|int
name|exact
parameter_list|)
block|{
specifier|register
name|char
specifier|const
modifier|*
name|beg
decl_stmt|,
modifier|*
name|try
decl_stmt|,
modifier|*
name|end
decl_stmt|;
specifier|register
name|size_t
name|len
decl_stmt|;
name|char
name|eol
init|=
name|eolbyte
decl_stmt|;
name|struct
name|kwsmatch
name|kwsmatch
decl_stmt|;
name|size_t
name|ret_val
decl_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
name|int
name|mb_cur_max
init|=
name|MB_CUR_MAX
decl_stmt|;
name|mbstate_t
name|mbs
decl_stmt|;
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|last_char
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
comment|/* MBS_SUPPORT */
for|for
control|(
name|beg
operator|=
name|buf
init|;
name|beg
operator|<=
name|buf
operator|+
name|size
condition|;
operator|++
name|beg
control|)
block|{
name|size_t
name|offset
decl_stmt|;
name|offset
operator|=
name|kwsexec
argument_list|(
name|kwset
argument_list|,
name|beg
argument_list|,
name|buf
operator|+
name|size
operator|-
name|beg
argument_list|,
operator|&
name|kwsmatch
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
goto|goto
name|failure
goto|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|mb_cur_max
operator|>
literal|1
operator|&&
operator|!
name|using_utf8
condition|)
block|{
name|size_t
name|bytes_left
init|=
name|offset
decl_stmt|;
while|while
condition|(
name|bytes_left
condition|)
block|{
name|size_t
name|mlen
init|=
name|mbrlen
argument_list|(
name|beg
argument_list|,
name|bytes_left
argument_list|,
operator|&
name|mbs
argument_list|)
decl_stmt|;
name|last_char
operator|=
name|beg
expr_stmt|;
if|if
condition|(
name|mlen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|||
name|mlen
operator|==
literal|0
condition|)
block|{
comment|/* Incomplete character: treat as single-byte. */
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
name|beg
operator|++
expr_stmt|;
name|bytes_left
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|mlen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|2
condition|)
comment|/* Offset points inside multibyte character: no good. */
break|break;
name|beg
operator|+=
name|mlen
expr_stmt|;
name|bytes_left
operator|-=
name|mlen
expr_stmt|;
block|}
if|if
condition|(
name|bytes_left
condition|)
continue|continue;
block|}
else|else
endif|#
directive|endif
comment|/* MBS_SUPPORT */
name|beg
operator|+=
name|offset
expr_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
comment|/* For f_i_multibyte, the string at beg now matches first 3 chars of 	 one of the search strings (less if there are shorter search strings). 	 See if this is a real match.  */
if|if
condition|(
name|f_i_multibyte
operator|&&
name|Fimbexec
argument_list|(
name|beg
argument_list|,
name|buf
operator|+
name|size
operator|-
name|beg
argument_list|,
operator|&
name|kwsmatch
operator|.
name|size
index|[
literal|0
index|]
argument_list|,
name|exact
argument_list|)
condition|)
goto|goto
name|next_char
goto|;
endif|#
directive|endif
comment|/* MBS_SUPPORT */
name|len
operator|=
name|kwsmatch
operator|.
name|size
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|exact
operator|&&
operator|!
name|match_words
condition|)
goto|goto
name|success_in_beg_and_len
goto|;
if|if
condition|(
name|match_lines
condition|)
block|{
if|if
condition|(
name|beg
operator|>
name|buf
operator|&&
name|beg
index|[
operator|-
literal|1
index|]
operator|!=
name|eol
condition|)
goto|goto
name|next_char
goto|;
if|if
condition|(
name|beg
operator|+
name|len
operator|<
name|buf
operator|+
name|size
operator|&&
name|beg
index|[
name|len
index|]
operator|!=
name|eol
condition|)
goto|goto
name|next_char
goto|;
goto|goto
name|success
goto|;
block|}
elseif|else
if|if
condition|(
name|match_words
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|word_match
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|beg
operator|>
name|buf
condition|)
block|{
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|mb_cur_max
operator|>
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|mr
decl_stmt|;
name|wchar_t
name|pwc
decl_stmt|;
if|if
condition|(
name|using_utf8
condition|)
block|{
name|s
operator|=
name|beg
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|s
operator|>
name|buf
operator|&&
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
operator|>=
literal|0x80
operator|&&
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
operator|<=
literal|0xbf
condition|)
operator|--
name|s
expr_stmt|;
block|}
else|else
name|s
operator|=
name|last_char
expr_stmt|;
name|mr
operator|=
name|mbtowc
argument_list|(
operator|&
name|pwc
argument_list|,
name|s
argument_list|,
name|beg
operator|-
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|mr
operator|<=
literal|0
condition|)
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|iswalnum
argument_list|(
name|pwc
argument_list|)
operator|||
name|pwc
operator|==
literal|L'
expr|_'
operator|)
operator|&&
name|mr
operator|==
call|(
name|int
call|)
argument_list|(
name|beg
operator|-
name|s
argument_list|)
condition|)
goto|goto
name|next_char
goto|;
block|}
elseif|else
endif|#
directive|endif
comment|/* MBS_SUPPORT */
if|if
condition|(
name|WCHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|beg
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
goto|goto
name|next_char
goto|;
block|}
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|mb_cur_max
operator|>
literal|1
condition|)
block|{
name|wchar_t
name|nwc
decl_stmt|;
name|int
name|mr
decl_stmt|;
name|mr
operator|=
name|mbtowc
argument_list|(
operator|&
name|nwc
argument_list|,
name|beg
operator|+
name|len
argument_list|,
name|buf
operator|+
name|size
operator|-
name|beg
operator|-
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|mr
operator|<=
literal|0
condition|)
block|{
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
name|word_match
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|iswalnum
argument_list|(
name|nwc
argument_list|)
operator|&&
name|nwc
operator|!=
literal|L'
expr|_'
condition|)
name|word_match
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* MBS_SUPPORT */
if|if
condition|(
name|beg
operator|+
name|len
operator|>=
name|buf
operator|+
name|size
operator|||
operator|!
name|WCHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|beg
index|[
name|len
index|]
argument_list|)
condition|)
name|word_match
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|word_match
condition|)
block|{
if|if
condition|(
operator|!
name|exact
condition|)
comment|/* Returns the whole line now we know there's a word match. */
goto|goto
name|success
goto|;
else|else
comment|/* Returns just this word match. */
goto|goto
name|success_in_beg_and_len
goto|;
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* Try a shorter length anchored at the same place. */
operator|--
name|len
expr_stmt|;
name|offset
operator|=
name|kwsexec
argument_list|(
name|kwset
argument_list|,
name|beg
argument_list|,
name|len
argument_list|,
operator|&
name|kwsmatch
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
condition|)
goto|goto
name|next_char
goto|;
comment|/* Try a different anchor. */
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|mb_cur_max
operator|>
literal|1
operator|&&
operator|!
name|using_utf8
condition|)
block|{
name|size_t
name|bytes_left
init|=
name|offset
decl_stmt|;
while|while
condition|(
name|bytes_left
condition|)
block|{
name|size_t
name|mlen
init|=
name|mbrlen
argument_list|(
name|beg
argument_list|,
name|bytes_left
argument_list|,
operator|&
name|mbs
argument_list|)
decl_stmt|;
name|last_char
operator|=
name|beg
expr_stmt|;
if|if
condition|(
name|mlen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|||
name|mlen
operator|==
literal|0
condition|)
block|{
comment|/* Incomplete character: treat as single-byte. */
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
name|beg
operator|++
expr_stmt|;
name|bytes_left
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|mlen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|2
condition|)
block|{
comment|/* Offset points inside multibyte character: 			       * no good. */
break|break;
block|}
name|beg
operator|+=
name|mlen
expr_stmt|;
name|bytes_left
operator|-=
name|mlen
expr_stmt|;
block|}
if|if
condition|(
name|bytes_left
condition|)
block|{
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|next_char
goto|;
comment|/* Try a different anchor. */
block|}
block|}
else|else
endif|#
directive|endif
comment|/* MBS_SUPPORT */
name|beg
operator|+=
name|offset
expr_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
comment|/* The string at beg now matches first 3 chars of one of 		     the search strings (less if there are shorter search 		     strings).  See if this is a real match.  */
if|if
condition|(
name|f_i_multibyte
operator|&&
name|Fimbexec
argument_list|(
name|beg
argument_list|,
name|len
operator|-
name|offset
argument_list|,
operator|&
name|kwsmatch
operator|.
name|size
index|[
literal|0
index|]
argument_list|,
name|exact
argument_list|)
condition|)
goto|goto
name|next_char
goto|;
endif|#
directive|endif
comment|/* MBS_SUPPORT */
name|len
operator|=
name|kwsmatch
operator|.
name|size
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
block|}
else|else
goto|goto
name|success
goto|;
name|next_char
label|:
empty_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
comment|/* Advance to next character.  For MB_CUR_MAX == 1 case this is handled 	 by ++beg above.  */
if|if
condition|(
name|mb_cur_max
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|using_utf8
condition|)
block|{
name|unsigned
name|char
name|c
init|=
operator|*
name|beg
decl_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0xc2
condition|)
block|{
if|if
condition|(
name|c
operator|<
literal|0xe0
condition|)
operator|++
name|beg
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|0xf0
condition|)
name|beg
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|0xf8
condition|)
name|beg
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|0xfc
condition|)
name|beg
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
literal|0xfe
condition|)
name|beg
operator|+=
literal|5
expr_stmt|;
block|}
block|}
else|else
block|{
name|size_t
name|l
init|=
name|mbrlen
argument_list|(
name|beg
argument_list|,
name|buf
operator|+
name|size
operator|-
name|beg
argument_list|,
operator|&
name|mbs
argument_list|)
decl_stmt|;
name|last_char
operator|=
name|beg
expr_stmt|;
if|if
condition|(
name|l
operator|+
literal|2
operator|>=
literal|2
condition|)
name|beg
operator|+=
name|l
operator|-
literal|1
expr_stmt|;
else|else
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* MBS_SUPPORT */
block|}
name|failure
label|:
return|return
operator|-
literal|1
return|;
name|success
label|:
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|mb_cur_max
operator|>
literal|1
operator|&&
operator|!
name|using_utf8
condition|)
block|{
name|end
operator|=
name|beg
operator|+
name|len
expr_stmt|;
while|while
condition|(
name|end
operator|<
name|buf
operator|+
name|size
condition|)
block|{
name|size_t
name|mlen
init|=
name|mbrlen
argument_list|(
name|end
argument_list|,
name|buf
operator|+
name|size
operator|-
name|end
argument_list|,
operator|&
name|mbs
argument_list|)
decl_stmt|;
if|if
condition|(
name|mlen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|||
name|mlen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|2
operator|||
name|mlen
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
name|mlen
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mlen
operator|==
literal|1
operator|&&
operator|*
name|end
operator|==
name|eol
condition|)
break|break;
name|end
operator|+=
name|mlen
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* MBS_SUPPORT */
name|end
operator|=
name|memchr
argument_list|(
name|beg
operator|+
name|len
argument_list|,
name|eol
argument_list|,
operator|(
name|buf
operator|+
name|size
operator|)
operator|-
operator|(
name|beg
operator|+
name|len
operator|)
argument_list|)
expr_stmt|;
name|end
operator|++
expr_stmt|;
while|while
condition|(
name|buf
operator|<
name|beg
operator|&&
name|beg
index|[
operator|-
literal|1
index|]
operator|!=
name|eol
condition|)
operator|--
name|beg
expr_stmt|;
name|len
operator|=
name|end
operator|-
name|beg
expr_stmt|;
comment|/* FALLTHROUGH */
name|success_in_beg_and_len
label|:
operator|*
name|match_size
operator|=
name|len
expr_stmt|;
return|return
name|beg
operator|-
name|buf
return|;
block|}
end_function

begin_if
if|#
directive|if
name|HAVE_LIBPCRE
end_if

begin_comment
comment|/* Compiled internal form of a Perl regular expression.  */
end_comment

begin_decl_stmt
specifier|static
name|pcre
modifier|*
name|cre
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Additional information about the pattern.  */
end_comment

begin_decl_stmt
specifier|static
name|pcre_extra
modifier|*
name|extra
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|Pcompile
parameter_list|(
name|char
specifier|const
modifier|*
name|pattern
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|#
directive|if
operator|!
name|HAVE_LIBPCRE
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"The -P option is not supported"
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|e
decl_stmt|;
name|char
specifier|const
modifier|*
name|ep
decl_stmt|;
name|char
modifier|*
name|re
init|=
name|xmalloc
argument_list|(
literal|4
operator|*
name|size
operator|+
literal|7
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
name|PCRE_MULTILINE
operator||
operator|(
name|match_icase
condition|?
name|PCRE_CASELESS
else|:
literal|0
operator|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|patlim
init|=
name|pattern
operator|+
name|size
decl_stmt|;
name|char
modifier|*
name|n
init|=
name|re
decl_stmt|;
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
name|char
specifier|const
modifier|*
name|pnul
decl_stmt|;
comment|/* FIXME: Remove this restriction.  */
if|if
condition|(
name|eolbyte
operator|!=
literal|'\n'
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"The -P and -z options cannot be combined"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|n
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|match_lines
condition|)
name|strcpy
argument_list|(
name|n
argument_list|,
literal|"^("
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_words
condition|)
name|strcpy
argument_list|(
name|n
argument_list|,
literal|"\\b("
argument_list|)
expr_stmt|;
name|n
operator|+=
name|strlen
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* The PCRE interface doesn't allow NUL bytes in the pattern, so      replace each NUL byte in the pattern with the four characters      "\000", removing a preceding backslash if there are an odd      number of backslashes before the NUL.       FIXME: This method does not work with some multibyte character      encodings, notably Shift-JIS, where a multibyte character can end      in a backslash byte.  */
for|for
control|(
name|p
operator|=
name|pattern
init|;
operator|(
name|pnul
operator|=
name|memchr
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|,
name|patlim
operator|-
name|p
argument_list|)
operator|)
condition|;
name|p
operator|=
name|pnul
operator|+
literal|1
control|)
block|{
name|memcpy
argument_list|(
name|n
argument_list|,
name|p
argument_list|,
name|pnul
operator|-
name|p
argument_list|)
expr_stmt|;
name|n
operator|+=
name|pnul
operator|-
name|p
expr_stmt|;
for|for
control|(
name|p
operator|=
name|pnul
init|;
name|pattern
operator|<
name|p
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|;
name|p
operator|--
control|)
continue|continue;
name|n
operator|-=
operator|(
name|pnul
operator|-
name|p
operator|)
operator|&
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|n
argument_list|,
literal|"\\000"
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|4
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|n
argument_list|,
name|p
argument_list|,
name|patlim
operator|-
name|p
argument_list|)
expr_stmt|;
name|n
operator|+=
name|patlim
operator|-
name|p
expr_stmt|;
operator|*
name|n
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|match_words
condition|)
name|strcpy
argument_list|(
name|n
argument_list|,
literal|")\\b"
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_lines
condition|)
name|strcpy
argument_list|(
name|n
argument_list|,
literal|")$"
argument_list|)
expr_stmt|;
name|cre
operator|=
name|pcre_compile
argument_list|(
name|re
argument_list|,
name|flags
argument_list|,
operator|&
name|ep
argument_list|,
operator|&
name|e
argument_list|,
name|pcre_maketables
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cre
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|extra
operator|=
name|pcre_study
argument_list|(
name|cre
argument_list|,
literal|0
argument_list|,
operator|&
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|re
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|size_t
name|Pexecute
parameter_list|(
name|char
specifier|const
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
modifier|*
name|match_size
parameter_list|,
name|int
name|exact
parameter_list|)
block|{
if|#
directive|if
operator|!
name|HAVE_LIBPCRE
name|abort
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
else|#
directive|else
comment|/* This array must have at least two elements; everything after that      is just for performance improvement in pcre_exec.  */
name|int
name|sub
index|[
literal|300
index|]
decl_stmt|;
name|int
name|e
init|=
name|pcre_exec
argument_list|(
name|cre
argument_list|,
name|extra
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sub
argument_list|,
sizeof|sizeof
name|sub
operator|/
sizeof|sizeof
expr|*
name|sub
argument_list|)
decl_stmt|;
if|if
condition|(
name|e
operator|<=
literal|0
condition|)
block|{
switch|switch
condition|(
name|e
condition|)
block|{
case|case
name|PCRE_ERROR_NOMATCH
case|:
return|return
operator|-
literal|1
return|;
case|case
name|PCRE_ERROR_NOMEMORY
case|:
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Narrow down to the line we've found.  */
name|char
specifier|const
modifier|*
name|beg
init|=
name|buf
operator|+
name|sub
index|[
literal|0
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
name|end
init|=
name|buf
operator|+
name|sub
index|[
literal|1
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
name|buflim
init|=
name|buf
operator|+
name|size
decl_stmt|;
name|char
name|eol
init|=
name|eolbyte
decl_stmt|;
if|if
condition|(
operator|!
name|exact
condition|)
block|{
name|end
operator|=
name|memchr
argument_list|(
name|end
argument_list|,
name|eol
argument_list|,
name|buflim
operator|-
name|end
argument_list|)
expr_stmt|;
name|end
operator|++
expr_stmt|;
while|while
condition|(
name|buf
operator|<
name|beg
operator|&&
name|beg
index|[
operator|-
literal|1
index|]
operator|!=
name|eol
condition|)
operator|--
name|beg
expr_stmt|;
block|}
operator|*
name|match_size
operator|=
name|end
operator|-
name|beg
expr_stmt|;
return|return
name|beg
operator|-
name|buf
return|;
block|}
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
name|struct
name|matcher
specifier|const
name|matchers
index|[]
init|=
block|{
block|{
literal|"default"
block|,
name|Gcompile
block|,
name|EGexecute
block|}
block|,
block|{
literal|"grep"
block|,
name|Gcompile
block|,
name|EGexecute
block|}
block|,
block|{
literal|"egrep"
block|,
name|Ecompile
block|,
name|EGexecute
block|}
block|,
block|{
literal|"awk"
block|,
name|Ecompile
block|,
name|EGexecute
block|}
block|,
block|{
literal|"fgrep"
block|,
name|Fcompile
block|,
name|Fexecute
block|}
block|,
block|{
literal|"perl"
block|,
name|Pcompile
block|,
name|Pexecute
block|}
block|,
block|{
literal|""
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

end_unit

