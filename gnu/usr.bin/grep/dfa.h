begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dfa.h - declarations for GNU deterministic regexp compiler    Copyright (C) 1988, 1998 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA */
end_comment

begin_comment
comment|/* Written June, 1988 by Mike Haertel */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* FIXME:    2.  We should not export so much of the DFA internals.    In addition to clobbering modularity, we eat up valuable    name space. */
end_comment

begin_undef
undef|#
directive|undef
name|PARAMS
end_undef

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|_PTR_T
end_ifndef

begin_define
define|#
directive|define
name|_PTR_T
end_define

begin_typedef
typedef|typedef
name|void
modifier|*
name|ptr_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PARAMS
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|_PTR_T
end_ifndef

begin_define
define|#
directive|define
name|_PTR_T
end_define

begin_typedef
typedef|typedef
name|char
modifier|*
name|ptr_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PARAMS
parameter_list|(
name|x
parameter_list|)
value|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bits in an unsigned char. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CHARBITS
end_ifndef

begin_define
define|#
directive|define
name|CHARBITS
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* First integer value that is greater than any character code. */
end_comment

begin_define
define|#
directive|define
name|NOTCHAR
value|(1<< CHARBITS)
end_define

begin_comment
comment|/* INTBITS need not be exact, just a lower bound. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INTBITS
end_ifndef

begin_define
define|#
directive|define
name|INTBITS
value|(CHARBITS * sizeof (int))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of ints required to hold a bit for every character. */
end_comment

begin_define
define|#
directive|define
name|CHARCLASS_INTS
value|((NOTCHAR + INTBITS - 1) / INTBITS)
end_define

begin_comment
comment|/* Sets of unsigned characters are stored as bit vectors in arrays of ints. */
end_comment

begin_typedef
typedef|typedef
name|int
name|charclass
index|[
name|CHARCLASS_INTS
index|]
typedef|;
end_typedef

begin_comment
comment|/* The regexp is parsed into an array of tokens in postfix form.  Some tokens    are operators and others are terminal symbols.  Most (but not all) of these    codes are returned by the lexical analyzer. */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|END
init|=
operator|-
literal|1
block|,
comment|/* END is a terminal symbol that matches the 				   end of input; any value of END or less in 				   the parse tree is such a symbol.  Accepting 				   states of the DFA are those that would have 				   a transition on END. */
comment|/* Ordinary character values are terminal symbols that match themselves. */
name|EMPTY
init|=
name|NOTCHAR
block|,
comment|/* EMPTY is a terminal symbol that matches 				   the empty string. */
name|BACKREF
block|,
comment|/* BACKREF is generated by \<digit>; it 				   it not completely handled.  If the scanner 				   detects a transition on backref, it returns 				   a kind of "semi-success" indicating that 				   the match will have to be verified with 				   a backtracking matcher. */
name|BEGLINE
block|,
comment|/* BEGLINE is a terminal symbol that matches 				   the empty string if it is at the beginning 				   of a line. */
name|ENDLINE
block|,
comment|/* ENDLINE is a terminal symbol that matches 				   the empty string if it is at the end of 				   a line. */
name|BEGWORD
block|,
comment|/* BEGWORD is a terminal symbol that matches 				   the empty string if it is at the beginning 				   of a word. */
name|ENDWORD
block|,
comment|/* ENDWORD is a terminal symbol that matches 				   the empty string if it is at the end of 				   a word. */
name|LIMWORD
block|,
comment|/* LIMWORD is a terminal symbol that matches 				   the empty string if it is at the beginning 				   or the end of a word. */
name|NOTLIMWORD
block|,
comment|/* NOTLIMWORD is a terminal symbol that 				   matches the empty string if it is not at 				   the beginning or end of a word. */
name|QMARK
block|,
comment|/* QMARK is an operator of one argument that 				   matches zero or one occurences of its 				   argument. */
name|STAR
block|,
comment|/* STAR is an operator of one argument that 				   matches the Kleene closure (zero or more 				   occurrences) of its argument. */
name|PLUS
block|,
comment|/* PLUS is an operator of one argument that 				   matches the positive closure (one or more 				   occurrences) of its argument. */
name|REPMN
block|,
comment|/* REPMN is a lexical token corresponding 				   to the {m,n} construct.  REPMN never 				   appears in the compiled token vector. */
name|CAT
block|,
comment|/* CAT is an operator of two arguments that 				   matches the concatenation of its 				   arguments.  CAT is never returned by the 				   lexical analyzer. */
name|OR
block|,
comment|/* OR is an operator of two arguments that 				   matches either of its arguments. */
name|ORTOP
block|,
comment|/* OR at the toplevel in the parse tree. 				   This is used for a boyer-moore heuristic. */
name|LPAREN
block|,
comment|/* LPAREN never appears in the parse tree, 				   it is only a lexeme. */
name|RPAREN
block|,
comment|/* RPAREN never appears in the parse tree. */
name|CSET
comment|/* CSET and (and any value greater) is a 				   terminal symbol that matches any of a 				   class of characters. */
block|}
name|token
typedef|;
end_typedef

begin_comment
comment|/* Sets are stored in an array in the compiled dfa; the index of the    array corresponding to a given set token is given by SET_INDEX(t). */
end_comment

begin_define
define|#
directive|define
name|SET_INDEX
parameter_list|(
name|t
parameter_list|)
value|((t) - CSET)
end_define

begin_comment
comment|/* Sometimes characters can only be matched depending on the surrounding    context.  Such context decisions depend on what the previous character    was, and the value of the current (lookahead) character.  Context    dependent constraints are encoded as 8 bit integers.  Each bit that    is set indicates that the constraint succeeds in the corresponding    context.     bit 7 - previous and current are newlines    bit 6 - previous was newline, current isn't    bit 5 - previous wasn't newline, current is    bit 4 - neither previous nor current is a newline    bit 3 - previous and current are word-constituents    bit 2 - previous was word-constituent, current isn't    bit 1 - previous wasn't word-constituent, current is    bit 0 - neither previous nor current is word-constituent     Word-constituent characters are those that satisfy isalnum().     The macro SUCCEEDS_IN_CONTEXT determines whether a a given constraint    succeeds in a particular context.  Prevn is true if the previous character    was a newline, currn is true if the lookahead character is a newline.    Prevl and currl similarly depend upon whether the previous and current    characters are word-constituent letters. */
end_comment

begin_define
define|#
directive|define
name|MATCHES_NEWLINE_CONTEXT
parameter_list|(
name|constraint
parameter_list|,
name|prevn
parameter_list|,
name|currn
parameter_list|)
define|\
value|((constraint)& 1<< (((prevn) ? 2 : 0) + ((currn) ? 1 : 0) + 4))
end_define

begin_define
define|#
directive|define
name|MATCHES_LETTER_CONTEXT
parameter_list|(
name|constraint
parameter_list|,
name|prevl
parameter_list|,
name|currl
parameter_list|)
define|\
value|((constraint)& 1<< (((prevl) ? 2 : 0) + ((currl) ? 1 : 0)))
end_define

begin_define
define|#
directive|define
name|SUCCEEDS_IN_CONTEXT
parameter_list|(
name|constraint
parameter_list|,
name|prevn
parameter_list|,
name|currn
parameter_list|,
name|prevl
parameter_list|,
name|currl
parameter_list|)
define|\
value|(MATCHES_NEWLINE_CONTEXT(constraint, prevn, currn)		     \&& MATCHES_LETTER_CONTEXT(constraint, prevl, currl))
end_define

begin_comment
comment|/* The following macros give information about what a constraint depends on. */
end_comment

begin_define
define|#
directive|define
name|PREV_NEWLINE_DEPENDENT
parameter_list|(
name|constraint
parameter_list|)
define|\
value|(((constraint)& 0xc0)>> 2 != ((constraint)& 0x30))
end_define

begin_define
define|#
directive|define
name|PREV_LETTER_DEPENDENT
parameter_list|(
name|constraint
parameter_list|)
define|\
value|(((constraint)& 0x0c)>> 2 != ((constraint)& 0x03))
end_define

begin_comment
comment|/* Tokens that match the empty string subject to some constraint actually    work by applying that constraint to determine what may follow them,    taking into account what has gone before.  The following values are    the constraints corresponding to the special tokens previously defined. */
end_comment

begin_define
define|#
directive|define
name|NO_CONSTRAINT
value|0xff
end_define

begin_define
define|#
directive|define
name|BEGLINE_CONSTRAINT
value|0xcf
end_define

begin_define
define|#
directive|define
name|ENDLINE_CONSTRAINT
value|0xaf
end_define

begin_define
define|#
directive|define
name|BEGWORD_CONSTRAINT
value|0xf2
end_define

begin_define
define|#
directive|define
name|ENDWORD_CONSTRAINT
value|0xf4
end_define

begin_define
define|#
directive|define
name|LIMWORD_CONSTRAINT
value|0xf6
end_define

begin_define
define|#
directive|define
name|NOTLIMWORD_CONSTRAINT
value|0xf9
end_define

begin_comment
comment|/* States of the recognizer correspond to sets of positions in the parse    tree, together with the constraints under which they may be matched.    So a position is encoded as an index into the parse tree together with    a constraint. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|index
decl_stmt|;
comment|/* Index into the parse array. */
name|unsigned
name|constraint
decl_stmt|;
comment|/* Constraint for matching this position. */
block|}
name|position
typedef|;
end_typedef

begin_comment
comment|/* Sets of positions are stored as arrays. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|position
modifier|*
name|elems
decl_stmt|;
comment|/* Elements of this position set. */
name|int
name|nelem
decl_stmt|;
comment|/* Number of elements in this set. */
block|}
name|position_set
typedef|;
end_typedef

begin_comment
comment|/* A state of the dfa consists of a set of positions, some flags,    and the token value of the lowest-numbered position of the state that    contains an END token. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|hash
decl_stmt|;
comment|/* Hash of the positions of this state. */
name|position_set
name|elems
decl_stmt|;
comment|/* Positions this state could match. */
name|char
name|newline
decl_stmt|;
comment|/* True if previous state matched newline. */
name|char
name|letter
decl_stmt|;
comment|/* True if previous state matched a letter. */
name|char
name|backref
decl_stmt|;
comment|/* True if this state matches a \<digit>. */
name|unsigned
name|char
name|constraint
decl_stmt|;
comment|/* Constraint for this state to accept. */
name|int
name|first_end
decl_stmt|;
comment|/* Token value of the first END in elems. */
block|}
name|dfa_state
typedef|;
end_typedef

begin_comment
comment|/* Element of a list of strings, at least one of which is known to    appear in any R.E. matching the DFA. */
end_comment

begin_struct
struct|struct
name|dfamust
block|{
name|int
name|exact
decl_stmt|;
name|char
modifier|*
name|must
decl_stmt|;
name|struct
name|dfamust
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A compiled regular expression. */
end_comment

begin_struct
struct|struct
name|dfa
block|{
comment|/* Stuff built by the scanner. */
name|charclass
modifier|*
name|charclasses
decl_stmt|;
comment|/* Array of character sets for CSET tokens. */
name|int
name|cindex
decl_stmt|;
comment|/* Index for adding new charclasses. */
name|int
name|calloc
decl_stmt|;
comment|/* Number of charclasses currently allocated. */
comment|/* Stuff built by the parser. */
name|token
modifier|*
name|tokens
decl_stmt|;
comment|/* Postfix parse array. */
name|int
name|tindex
decl_stmt|;
comment|/* Index for adding new tokens. */
name|int
name|talloc
decl_stmt|;
comment|/* Number of tokens currently allocated. */
name|int
name|depth
decl_stmt|;
comment|/* Depth required of an evaluation stack 				   used for depth-first traversal of the 				   parse tree. */
name|int
name|nleaves
decl_stmt|;
comment|/* Number of leaves on the parse tree. */
name|int
name|nregexps
decl_stmt|;
comment|/* Count of parallel regexps being built 				   with dfaparse(). */
comment|/* Stuff owned by the state builder. */
name|dfa_state
modifier|*
name|states
decl_stmt|;
comment|/* States of the dfa. */
name|int
name|sindex
decl_stmt|;
comment|/* Index for adding new states. */
name|int
name|salloc
decl_stmt|;
comment|/* Number of states currently allocated. */
comment|/* Stuff built by the structure analyzer. */
name|position_set
modifier|*
name|follows
decl_stmt|;
comment|/* Array of follow sets, indexed by position 				   index.  The follow of a position is the set 				   of positions containing characters that 				   could conceivably follow a character 				   matching the given position in a string 				   matching the regexp.  Allocated to the 				   maximum possible position index. */
name|int
name|searchflag
decl_stmt|;
comment|/* True if we are supposed to build a searching 				   as opposed to an exact matcher.  A searching 				   matcher finds the first and shortest string 				   matching a regexp anywhere in the buffer, 				   whereas an exact matcher finds the longest 				   string matching, but anchored to the 				   beginning of the buffer. */
comment|/* Stuff owned by the executor. */
name|int
name|tralloc
decl_stmt|;
comment|/* Number of transition tables that have 				   slots so far. */
name|int
name|trcount
decl_stmt|;
comment|/* Number of transition tables that have 				   actually been built. */
name|int
modifier|*
modifier|*
name|trans
decl_stmt|;
comment|/* Transition tables for states that can 				   never accept.  If the transitions for a 				   state have not yet been computed, or the 				   state could possibly accept, its entry in 				   this table is NULL. */
name|int
modifier|*
modifier|*
name|realtrans
decl_stmt|;
comment|/* Trans always points to realtrans + 1; this 				   is so trans[-1] can contain NULL. */
name|int
modifier|*
modifier|*
name|fails
decl_stmt|;
comment|/* Transition tables after failing to accept 				   on a state that potentially could do so. */
name|int
modifier|*
name|success
decl_stmt|;
comment|/* Table of acceptance conditions used in 				   dfaexec and computed in build_state. */
name|int
modifier|*
name|newlines
decl_stmt|;
comment|/* Transitions on newlines.  The entry for a 				   newline in any transition table is always 				   -1 so we can count lines without wasting 				   too many cycles.  The transition for a 				   newline is stored separately and handled 				   as a special case.  Newline is also used 				   as a sentinel at the end of the buffer. */
name|struct
name|dfamust
modifier|*
name|musts
decl_stmt|;
comment|/* List of strings, at least one of which 				   is known to appear in any r.e. matching 				   the dfa. */
block|}
struct|;
end_struct

begin_comment
comment|/* Some macros for user access to dfa internals. */
end_comment

begin_comment
comment|/* ACCEPTING returns true if s could possibly be an accepting state of r. */
end_comment

begin_define
define|#
directive|define
name|ACCEPTING
parameter_list|(
name|s
parameter_list|,
name|r
parameter_list|)
value|((r).states[s].constraint)
end_define

begin_comment
comment|/* ACCEPTS_IN_CONTEXT returns true if the given state accepts in the    specified context. */
end_comment

begin_define
define|#
directive|define
name|ACCEPTS_IN_CONTEXT
parameter_list|(
name|prevn
parameter_list|,
name|currn
parameter_list|,
name|prevl
parameter_list|,
name|currl
parameter_list|,
name|state
parameter_list|,
name|dfa
parameter_list|)
define|\
value|SUCCEEDS_IN_CONTEXT((dfa).states[state].constraint,		   \ 		       prevn, currn, prevl, currl)
end_define

begin_comment
comment|/* FIRST_MATCHING_REGEXP returns the index number of the first of parallel    regexps that a given state could accept.  Parallel regexps are numbered    starting at 1. */
end_comment

begin_define
define|#
directive|define
name|FIRST_MATCHING_REGEXP
parameter_list|(
name|state
parameter_list|,
name|dfa
parameter_list|)
value|(-(dfa).states[state].first_end)
end_define

begin_comment
comment|/* Entry points. */
end_comment

begin_comment
comment|/* dfasyntax() takes three arguments; the first sets the syntax bits described    earlier in this file, the second sets the case-folding flag, and the    third specifies the line terminator. */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|dfasyntax
name|PARAMS
argument_list|(
operator|(
name|reg_syntax_t
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compile the given string of the given length into the given struct dfa.    Final argument is a flag specifying whether to build a searching or an    exact matcher. */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|dfacomp
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|size_t
operator|,
expr|struct
name|dfa
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Execute the given struct dfa on the buffer of characters.  The    first char * points to the beginning, and the second points to the    first character after the end of the buffer, which must be a writable    place so a sentinel end-of-buffer marker can be stored there.  The    second-to-last argument is a flag telling whether to allow newlines to    be part of a string matching the regexp.  The next-to-last argument,    if non-NULL, points to a place to increment every time we see a    newline.  The final argument, if non-NULL, points to a flag that will    be set if further examination by a backtracking matcher is needed in    order to verify backreferencing; otherwise the flag will be cleared.    Returns NULL if no match is found, or a pointer to the first    character after the first& shortest matching string in the buffer. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|dfaexec
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dfa
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Free the storage held by the components of a struct dfa. */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|dfafree
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dfa
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Entry points for people who know what they're doing. */
end_comment

begin_comment
comment|/* Initialize the components of a struct dfa. */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|dfainit
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dfa
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Incrementally parse a string of given length into a struct dfa. */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|dfaparse
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|size_t
operator|,
expr|struct
name|dfa
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Analyze a parsed regexp; second argument tells whether to build a searching    or an exact matcher. */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|dfaanalyze
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dfa
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute, for each possible character, the transitions out of a given    state, storing them in an array of integers. */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|dfastate
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|dfa
operator|*
operator|,
name|int
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Error handling. */
end_comment

begin_comment
comment|/* dfaerror() is called by the regexp routines whenever an error occurs.  It    takes a single argument, a NUL-terminated string describing the error.    The default dfaerror() prints the error message to stderr and exits.    The user can provide a different dfafree() if so desired. */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|dfaerror
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

end_unit

