begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* quotearg.c - quote arguments for output    Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Written by Paul Eggert<eggert@twinsun.com> */
end_comment

begin_if
if|#
directive|if
name|HAVE_CONFIG_H
end_if

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_STDDEF_H
end_if

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* For the definition of size_t on windows w/MSVC.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<quotearg.h>
end_include

begin_include
include|#
directive|include
file|<xalloc.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_if
if|#
directive|if
name|ENABLE_NLS
end_if

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_define
define|#
directive|define
name|_
parameter_list|(
name|text
parameter_list|)
value|gettext (text)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_
parameter_list|(
name|text
parameter_list|)
value|text
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|N_
parameter_list|(
name|text
parameter_list|)
value|text
end_define

begin_if
if|#
directive|if
name|HAVE_LIMITS_H
end_if

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_BIT
end_ifndef

begin_define
define|#
directive|define
name|CHAR_BIT
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UCHAR_MAX
end_ifndef

begin_define
define|#
directive|define
name|UCHAR_MAX
value|((unsigned char) -1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_C_BACKSLASH_A
end_if

begin_define
define|#
directive|define
name|ALERT_CHAR
value|'\a'
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ALERT_CHAR
value|'\7'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_STDLIB_H
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_STRING_H
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_WCHAR_H
end_if

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|HAVE_MBRTOWC
end_if

begin_comment
comment|/* Disable multibyte processing entirely.  Since MB_CUR_MAX is 1, the    other macros are defined only for documentation and to satisfy C    syntax.  */
end_comment

begin_undef
undef|#
directive|undef
name|MB_CUR_MAX
end_undef

begin_define
define|#
directive|define
name|MB_CUR_MAX
value|1
end_define

begin_define
define|#
directive|define
name|mbrtowc
parameter_list|(
name|pwc
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|,
name|ps
parameter_list|)
value|((*(pwc) = *(s)) != 0)
end_define

begin_define
define|#
directive|define
name|mbsinit
parameter_list|(
name|ps
parameter_list|)
value|1
end_define

begin_define
define|#
directive|define
name|iswprint
parameter_list|(
name|wc
parameter_list|)
value|ISPRINT ((unsigned char) (wc))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|iswprint
end_ifndef

begin_if
if|#
directive|if
name|HAVE_WCTYPE_H
end_if

begin_include
include|#
directive|include
file|<wctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
name|iswprint
operator|&&
operator|!
name|HAVE_ISWPRINT
end_if

begin_define
define|#
directive|define
name|iswprint
parameter_list|(
name|wc
parameter_list|)
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|INT_BITS
value|(sizeof (int) * CHAR_BIT)
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
operator|||
operator|(
operator|!
name|defined
argument_list|(
name|isascii
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_ISASCII
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|IN_CTYPE_DOMAIN
parameter_list|(
name|c
parameter_list|)
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IN_CTYPE_DOMAIN
parameter_list|(
name|c
parameter_list|)
value|isascii(c)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Undefine to protect against the definition in wctype.h of solaris2.6.   */
end_comment

begin_undef
undef|#
directive|undef
name|ISPRINT
end_undef

begin_define
define|#
directive|define
name|ISPRINT
parameter_list|(
name|c
parameter_list|)
value|(IN_CTYPE_DOMAIN (c)&& isprint (c))
end_define

begin_struct
struct|struct
name|quoting_options
block|{
comment|/* Basic quoting style.  */
name|enum
name|quoting_style
name|style
decl_stmt|;
comment|/* Quote the characters indicated by this bit vector even if the      quoting style would not normally require them to be quoted.  */
name|int
name|quote_these_too
index|[
operator|(
name|UCHAR_MAX
operator|/
name|INT_BITS
operator|)
operator|+
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Names of quoting styles.  */
end_comment

begin_decl_stmt
name|char
specifier|const
modifier|*
specifier|const
name|quoting_style_args
index|[]
init|=
block|{
literal|"literal"
block|,
literal|"shell"
block|,
literal|"shell-always"
block|,
literal|"c"
block|,
literal|"escape"
block|,
literal|"locale"
block|,
literal|"clocale"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Correspondences to quoting style names.  */
end_comment

begin_decl_stmt
name|enum
name|quoting_style
specifier|const
name|quoting_style_vals
index|[]
init|=
block|{
name|literal_quoting_style
block|,
name|shell_quoting_style
block|,
name|shell_always_quoting_style
block|,
name|c_quoting_style
block|,
name|escape_quoting_style
block|,
name|locale_quoting_style
block|,
name|clocale_quoting_style
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The default quoting options.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|quoting_options
name|default_quoting_options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate a new set of quoting options, with contents initially identical    to O if O is not null, or to the default if O is null.    It is the caller's responsibility to free the result.  */
end_comment

begin_function
name|struct
name|quoting_options
modifier|*
name|clone_quoting_options
parameter_list|(
name|struct
name|quoting_options
modifier|*
name|o
parameter_list|)
block|{
name|struct
name|quoting_options
modifier|*
name|p
init|=
operator|(
expr|struct
name|quoting_options
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|quoting_options
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|p
operator|=
operator|*
operator|(
name|o
condition|?
name|o
else|:
operator|&
name|default_quoting_options
operator|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Get the value of O's quoting style.  If O is null, use the default.  */
end_comment

begin_function
name|enum
name|quoting_style
name|get_quoting_style
parameter_list|(
name|struct
name|quoting_options
modifier|*
name|o
parameter_list|)
block|{
return|return
operator|(
name|o
condition|?
name|o
else|:
operator|&
name|default_quoting_options
operator|)
operator|->
name|style
return|;
block|}
end_function

begin_comment
comment|/* In O (or in the default if O is null),    set the value of the quoting style to S.  */
end_comment

begin_function
name|void
name|set_quoting_style
parameter_list|(
name|struct
name|quoting_options
modifier|*
name|o
parameter_list|,
name|enum
name|quoting_style
name|s
parameter_list|)
block|{
operator|(
name|o
condition|?
name|o
else|:
operator|&
name|default_quoting_options
operator|)
operator|->
name|style
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_comment
comment|/* In O (or in the default if O is null),    set the value of the quoting options for character C to I.    Return the old value.  Currently, the only values defined for I are    0 (the default) and 1 (which means to quote the character even if    it would not otherwise be quoted).  */
end_comment

begin_function
name|int
name|set_char_quoting
parameter_list|(
name|struct
name|quoting_options
modifier|*
name|o
parameter_list|,
name|char
name|c
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|unsigned
name|char
name|uc
init|=
name|c
decl_stmt|;
name|int
modifier|*
name|p
init|=
operator|(
name|o
condition|?
name|o
else|:
operator|&
name|default_quoting_options
operator|)
operator|->
name|quote_these_too
operator|+
name|uc
operator|/
name|INT_BITS
decl_stmt|;
name|int
name|shift
init|=
name|uc
operator|%
name|INT_BITS
decl_stmt|;
name|int
name|r
init|=
operator|(
operator|*
name|p
operator|>>
name|shift
operator|)
operator|&
literal|1
decl_stmt|;
operator|*
name|p
operator|^=
operator|(
operator|(
name|i
operator|&
literal|1
operator|)
operator|^
name|r
operator|)
operator|<<
name|shift
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* MSGID approximates a quotation mark.  Return its translation if it    has one; otherwise, return either it or "\"", depending on S.  */
end_comment

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|gettext_quote
parameter_list|(
name|char
specifier|const
modifier|*
name|msgid
parameter_list|,
name|enum
name|quoting_style
name|s
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|translation
init|=
name|_
argument_list|(
name|msgid
argument_list|)
decl_stmt|;
if|if
condition|(
name|translation
operator|==
name|msgid
operator|&&
name|s
operator|==
name|clocale_quoting_style
condition|)
name|translation
operator|=
literal|"\""
expr_stmt|;
return|return
name|translation
return|;
block|}
end_function

begin_comment
comment|/* Place into buffer BUFFER (of size BUFFERSIZE) a quoted version of    argument ARG (of size ARGSIZE), using QUOTING_STYLE and the    non-quoting-style part of O to control quoting.    Terminate the output with a null character, and return the written    size of the output, not counting the terminating null.    If BUFFERSIZE is too small to store the output string, return the    value that would have been returned had BUFFERSIZE been large enough.    If ARGSIZE is -1, use the string length of the argument for ARGSIZE.     This function acts like quotearg_buffer (BUFFER, BUFFERSIZE, ARG,    ARGSIZE, O), except it uses QUOTING_STYLE instead of the quoting    style specified by O, and O may not be null.  */
end_comment

begin_function
specifier|static
name|size_t
name|quotearg_buffer_restyled
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|buffersize
parameter_list|,
name|char
specifier|const
modifier|*
name|arg
parameter_list|,
name|size_t
name|argsize
parameter_list|,
name|enum
name|quoting_style
name|quoting_style
parameter_list|,
name|struct
name|quoting_options
specifier|const
modifier|*
name|o
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|char
specifier|const
modifier|*
name|quote_string
init|=
literal|0
decl_stmt|;
name|size_t
name|quote_string_len
init|=
literal|0
decl_stmt|;
name|int
name|backslash_escapes
init|=
literal|0
decl_stmt|;
name|int
name|unibyte_locale
init|=
name|MB_CUR_MAX
operator|==
literal|1
decl_stmt|;
define|#
directive|define
name|STORE
parameter_list|(
name|c
parameter_list|)
define|\
value|do \       { \ 	if (len< buffersize) \ 	  buffer[len] = (c); \ 	len++; \       } \     while (0)
switch|switch
condition|(
name|quoting_style
condition|)
block|{
case|case
name|c_quoting_style
case|:
name|STORE
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|backslash_escapes
operator|=
literal|1
expr_stmt|;
name|quote_string
operator|=
literal|"\""
expr_stmt|;
name|quote_string_len
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|escape_quoting_style
case|:
name|backslash_escapes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|locale_quoting_style
case|:
case|case
name|clocale_quoting_style
case|:
block|{
comment|/* Get translations for open and closing quotation marks.  	   The message catalog should translate "`" to a left 	   quotation mark suitable for the locale, and similarly for 	   "'".  If the catalog has no translation, 	   locale_quoting_style quotes `like this', and 	   clocale_quoting_style quotes "like this".  	   For example, an American English Unicode locale should 	   translate "`" to U+201C (LEFT DOUBLE QUOTATION MARK), and 	   should translate "'" to U+201D (RIGHT DOUBLE QUOTATION 	   MARK).  A British English Unicode locale should instead 	   translate these to U+2018 (LEFT SINGLE QUOTATION MARK) and 	   U+2019 (RIGHT SINGLE QUOTATION MARK), respectively.  */
name|char
specifier|const
modifier|*
name|left
init|=
name|gettext_quote
argument_list|(
name|N_
argument_list|(
literal|"`"
argument_list|)
argument_list|,
name|quoting_style
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|right
init|=
name|gettext_quote
argument_list|(
name|N_
argument_list|(
literal|"'"
argument_list|)
argument_list|,
name|quoting_style
argument_list|)
decl_stmt|;
for|for
control|(
name|quote_string
operator|=
name|left
init|;
operator|*
name|quote_string
condition|;
name|quote_string
operator|++
control|)
name|STORE
argument_list|(
operator|*
name|quote_string
argument_list|)
expr_stmt|;
name|backslash_escapes
operator|=
literal|1
expr_stmt|;
name|quote_string
operator|=
name|right
expr_stmt|;
name|quote_string_len
operator|=
name|strlen
argument_list|(
name|quote_string
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|shell_always_quoting_style
case|:
name|STORE
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|quote_string
operator|=
literal|"'"
expr_stmt|;
name|quote_string_len
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
operator|(
name|argsize
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|?
name|arg
index|[
name|i
index|]
operator|==
literal|'\0'
else|:
name|i
operator|==
name|argsize
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|c
decl_stmt|;
name|unsigned
name|char
name|esc
decl_stmt|;
if|if
condition|(
name|backslash_escapes
operator|&&
name|quote_string_len
operator|&&
name|i
operator|+
name|quote_string_len
operator|<=
name|argsize
operator|&&
name|memcmp
argument_list|(
name|arg
operator|+
name|i
argument_list|,
name|quote_string
argument_list|,
name|quote_string_len
argument_list|)
operator|==
literal|0
condition|)
name|STORE
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|c
operator|=
name|arg
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'?'
case|:
switch|switch
condition|(
name|quoting_style
condition|)
block|{
case|case
name|shell_quoting_style
case|:
goto|goto
name|use_shell_always_quoting_style
goto|;
case|case
name|c_quoting_style
case|:
if|if
condition|(
name|i
operator|+
literal|2
operator|<
name|argsize
operator|&&
name|arg
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'?'
condition|)
switch|switch
condition|(
name|arg
index|[
name|i
operator|+
literal|2
index|]
condition|)
block|{
case|case
literal|'!'
case|:
case|case
literal|'\''
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'-'
case|:
case|case
literal|'/'
case|:
case|case
literal|'<'
case|:
case|case
literal|'='
case|:
case|case
literal|'>'
case|:
comment|/* Escape the second '?' in what would otherwise be 		       a trigraph.  */
name|i
operator|+=
literal|2
expr_stmt|;
name|c
operator|=
name|arg
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|STORE
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
name|STORE
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|STORE
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|ALERT_CHAR
case|:
name|esc
operator|=
literal|'a'
expr_stmt|;
goto|goto
name|c_escape
goto|;
case|case
literal|'\b'
case|:
name|esc
operator|=
literal|'b'
expr_stmt|;
goto|goto
name|c_escape
goto|;
case|case
literal|'\f'
case|:
name|esc
operator|=
literal|'f'
expr_stmt|;
goto|goto
name|c_escape
goto|;
case|case
literal|'\n'
case|:
name|esc
operator|=
literal|'n'
expr_stmt|;
goto|goto
name|c_and_shell_escape
goto|;
case|case
literal|'\r'
case|:
name|esc
operator|=
literal|'r'
expr_stmt|;
goto|goto
name|c_and_shell_escape
goto|;
case|case
literal|'\t'
case|:
name|esc
operator|=
literal|'t'
expr_stmt|;
goto|goto
name|c_and_shell_escape
goto|;
case|case
literal|'\v'
case|:
name|esc
operator|=
literal|'v'
expr_stmt|;
goto|goto
name|c_escape
goto|;
case|case
literal|'\\'
case|:
name|esc
operator|=
name|c
expr_stmt|;
goto|goto
name|c_and_shell_escape
goto|;
name|c_and_shell_escape
label|:
if|if
condition|(
name|quoting_style
operator|==
name|shell_quoting_style
condition|)
goto|goto
name|use_shell_always_quoting_style
goto|;
name|c_escape
label|:
if|if
condition|(
name|backslash_escapes
condition|)
block|{
name|c
operator|=
name|esc
expr_stmt|;
goto|goto
name|store_escape
goto|;
block|}
break|break;
case|case
literal|'#'
case|:
case|case
literal|'~'
case|:
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
break|break;
comment|/* Fall through.  */
case|case
literal|' '
case|:
case|case
literal|'!'
case|:
comment|/* special in bash */
case|case
literal|'"'
case|:
case|case
literal|'$'
case|:
case|case
literal|'&'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'*'
case|:
case|case
literal|';'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'['
case|:
case|case
literal|'^'
case|:
comment|/* special in old /bin/sh, e.g. SunOS 4.1.4 */
case|case
literal|'`'
case|:
case|case
literal|'|'
case|:
comment|/* A shell special character.  In theory, '$' and '`' could 	     be the first bytes of multibyte characters, which means 	     we should check them with mbrtowc, but in practice this 	     doesn't happen so it's not worth worrying about.  */
if|if
condition|(
name|quoting_style
operator|==
name|shell_quoting_style
condition|)
goto|goto
name|use_shell_always_quoting_style
goto|;
break|break;
case|case
literal|'\''
case|:
switch|switch
condition|(
name|quoting_style
condition|)
block|{
case|case
name|shell_quoting_style
case|:
goto|goto
name|use_shell_always_quoting_style
goto|;
case|case
name|shell_always_quoting_style
case|:
name|STORE
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
name|STORE
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|STORE
argument_list|(
literal|'\''
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
literal|'%'
case|:
case|case
literal|'+'
case|:
case|case
literal|','
case|:
case|case
literal|'-'
case|:
case|case
literal|'.'
case|:
case|case
literal|'/'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|':'
case|:
case|case
literal|'='
case|:
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
case|case
literal|']'
case|:
case|case
literal|'_'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'{'
case|:
case|case
literal|'}'
case|:
comment|/* These characters don't cause problems, no matter what the 	     quoting style is.  They cannot start multibyte sequences.  */
break|break;
default|default:
comment|/* If we have a multibyte sequence, copy it until we reach 	     its end, find an error, or come back to the initial shift 	     state.  For C-like styles, if the sequence has 	     unprintable characters, escape the whole sequence, since 	     we can't easily escape single characters within it.  */
block|{
comment|/* Length of multibyte sequence found so far.  */
name|size_t
name|m
decl_stmt|;
name|int
name|printable
decl_stmt|;
if|if
condition|(
name|unibyte_locale
condition|)
block|{
name|m
operator|=
literal|1
expr_stmt|;
name|printable
operator|=
name|ISPRINT
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mbstate_t
name|mbstate
decl_stmt|;
name|memset
argument_list|(
operator|&
name|mbstate
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|mbstate
argument_list|)
expr_stmt|;
name|m
operator|=
literal|0
expr_stmt|;
name|printable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|argsize
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
name|argsize
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
do|do
block|{
name|wchar_t
name|w
decl_stmt|;
name|size_t
name|bytes
init|=
name|mbrtowc
argument_list|(
operator|&
name|w
argument_list|,
operator|&
name|arg
index|[
name|i
operator|+
name|m
index|]
argument_list|,
name|argsize
operator|-
operator|(
name|i
operator|+
name|m
operator|)
argument_list|,
operator|&
name|mbstate
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|bytes
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
block|{
name|printable
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|2
condition|)
block|{
name|printable
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|+
name|m
operator|<
name|argsize
operator|&&
name|arg
index|[
name|i
operator|+
name|m
index|]
condition|)
name|m
operator|++
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|iswprint
argument_list|(
name|w
argument_list|)
condition|)
name|printable
operator|=
literal|0
expr_stmt|;
name|m
operator|+=
name|bytes
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|mbsinit
argument_list|(
operator|&
name|mbstate
argument_list|)
condition|)
do|;
block|}
if|if
condition|(
literal|1
operator|<
name|m
operator|||
operator|(
name|backslash_escapes
operator|&&
operator|!
name|printable
operator|)
condition|)
block|{
comment|/* Output a multibyte sequence, or an escaped 		   unprintable unibyte character.  */
name|size_t
name|ilim
init|=
name|i
operator|+
name|m
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|backslash_escapes
operator|&&
operator|!
name|printable
condition|)
block|{
name|STORE
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|STORE
argument_list|(
literal|'0'
operator|+
operator|(
name|c
operator|>>
literal|6
operator|)
argument_list|)
expr_stmt|;
name|STORE
argument_list|(
literal|'0'
operator|+
operator|(
operator|(
name|c
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'0'
operator|+
operator|(
name|c
operator|&
literal|7
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|ilim
operator|<=
name|i
operator|+
literal|1
condition|)
break|break;
name|STORE
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|arg
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
goto|goto
name|store_c
goto|;
block|}
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|backslash_escapes
operator|&&
name|o
operator|->
name|quote_these_too
index|[
name|c
operator|/
name|INT_BITS
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|%
name|INT_BITS
operator|)
operator|)
operator|)
condition|)
goto|goto
name|store_c
goto|;
name|store_escape
label|:
name|STORE
argument_list|(
literal|'\\'
argument_list|)
expr_stmt|;
name|store_c
label|:
name|STORE
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|quote_string
condition|)
for|for
control|(
init|;
operator|*
name|quote_string
condition|;
name|quote_string
operator|++
control|)
name|STORE
argument_list|(
operator|*
name|quote_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|buffersize
condition|)
name|buffer
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|len
return|;
name|use_shell_always_quoting_style
label|:
return|return
name|quotearg_buffer_restyled
argument_list|(
name|buffer
argument_list|,
name|buffersize
argument_list|,
name|arg
argument_list|,
name|argsize
argument_list|,
name|shell_always_quoting_style
argument_list|,
name|o
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Place into buffer BUFFER (of size BUFFERSIZE) a quoted version of    argument ARG (of size ARGSIZE), using O to control quoting.    If O is null, use the default.    Terminate the output with a null character, and return the written    size of the output, not counting the terminating null.    If BUFFERSIZE is too small to store the output string, return the    value that would have been returned had BUFFERSIZE been large enough.    If ARGSIZE is -1, use the string length of the argument for ARGSIZE.  */
end_comment

begin_function
name|size_t
name|quotearg_buffer
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|buffersize
parameter_list|,
name|char
specifier|const
modifier|*
name|arg
parameter_list|,
name|size_t
name|argsize
parameter_list|,
name|struct
name|quoting_options
specifier|const
modifier|*
name|o
parameter_list|)
block|{
name|struct
name|quoting_options
specifier|const
modifier|*
name|p
init|=
name|o
condition|?
name|o
else|:
operator|&
name|default_quoting_options
decl_stmt|;
return|return
name|quotearg_buffer_restyled
argument_list|(
name|buffer
argument_list|,
name|buffersize
argument_list|,
name|arg
argument_list|,
name|argsize
argument_list|,
name|p
operator|->
name|style
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Use storage slot N to return a quoted version of the string ARG.    OPTIONS specifies the quoting options.    The returned value points to static storage that can be    reused by the next call to this function with the same value of N.    N must be nonnegative.  N is deliberately declared with type "int"    to allow for future extensions (using negative values).  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|quotearg_n_options
parameter_list|(
name|int
name|n
parameter_list|,
name|char
specifier|const
modifier|*
name|arg
parameter_list|,
name|struct
name|quoting_options
specifier|const
modifier|*
name|options
parameter_list|)
block|{
comment|/* Preallocate a slot 0 buffer, so that the caller can always quote      one small component of a "memory exhausted" message in slot 0.  */
specifier|static
name|char
name|slot0
index|[
literal|256
index|]
decl_stmt|;
specifier|static
name|unsigned
name|int
name|nslots
init|=
literal|1
decl_stmt|;
struct|struct
name|slotvec
block|{
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
block|}
struct|;
specifier|static
name|struct
name|slotvec
name|slotvec0
init|=
block|{
sizeof|sizeof
name|slot0
block|,
name|slot0
block|}
decl_stmt|;
specifier|static
name|struct
name|slotvec
modifier|*
name|slotvec
init|=
operator|&
name|slotvec0
decl_stmt|;
if|if
condition|(
name|nslots
operator|<=
name|n
condition|)
block|{
name|int
name|n1
init|=
name|n
operator|+
literal|1
decl_stmt|;
name|size_t
name|s
init|=
name|n1
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|slotvec
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
literal|0
operator|<
name|n1
operator|&&
name|n1
operator|==
name|s
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|slotvec
argument_list|)
operator|)
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|slotvec
operator|==
operator|&
name|slotvec0
condition|)
block|{
name|slotvec
operator|=
operator|(
expr|struct
name|slotvec
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|slotvec
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|slotvec
operator|=
name|slotvec0
expr_stmt|;
block|}
name|slotvec
operator|=
operator|(
expr|struct
name|slotvec
operator|*
operator|)
name|xrealloc
argument_list|(
name|slotvec
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|slotvec
operator|+
name|nslots
argument_list|,
literal|0
argument_list|,
operator|(
name|n1
operator|-
name|nslots
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|slotvec
argument_list|)
argument_list|)
expr_stmt|;
name|nslots
operator|=
name|n
expr_stmt|;
block|}
block|{
name|size_t
name|size
init|=
name|slotvec
index|[
name|n
index|]
operator|.
name|size
decl_stmt|;
name|char
modifier|*
name|val
init|=
name|slotvec
index|[
name|n
index|]
operator|.
name|val
decl_stmt|;
name|size_t
name|qsize
init|=
name|quotearg_buffer
argument_list|(
name|val
argument_list|,
name|size
argument_list|,
name|arg
argument_list|,
operator|(
name|size_t
operator|)
operator|-
literal|1
argument_list|,
name|options
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|<=
name|qsize
condition|)
block|{
name|slotvec
index|[
name|n
index|]
operator|.
name|size
operator|=
name|size
operator|=
name|qsize
operator|+
literal|1
expr_stmt|;
name|slotvec
index|[
name|n
index|]
operator|.
name|val
operator|=
name|val
operator|=
name|xrealloc
argument_list|(
name|val
operator|==
name|slot0
condition|?
literal|0
else|:
name|val
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|quotearg_buffer
argument_list|(
name|val
argument_list|,
name|size
argument_list|,
name|arg
argument_list|,
operator|(
name|size_t
operator|)
operator|-
literal|1
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|quotearg_n
parameter_list|(
name|unsigned
name|int
name|n
parameter_list|,
name|char
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|quotearg_n_options
argument_list|(
name|n
argument_list|,
name|arg
argument_list|,
operator|&
name|default_quoting_options
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|quotearg
parameter_list|(
name|char
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|quotearg_n
argument_list|(
literal|0
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|quotearg_n_style
parameter_list|(
name|unsigned
name|int
name|n
parameter_list|,
name|enum
name|quoting_style
name|s
parameter_list|,
name|char
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|quoting_options
name|o
decl_stmt|;
name|o
operator|.
name|style
operator|=
name|s
expr_stmt|;
name|memset
argument_list|(
name|o
operator|.
name|quote_these_too
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|o
operator|.
name|quote_these_too
argument_list|)
expr_stmt|;
return|return
name|quotearg_n_options
argument_list|(
name|n
argument_list|,
name|arg
argument_list|,
operator|&
name|o
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|quotearg_style
parameter_list|(
name|enum
name|quoting_style
name|s
parameter_list|,
name|char
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|quotearg_n_style
argument_list|(
literal|0
argument_list|,
name|s
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|quotearg_char
parameter_list|(
name|char
specifier|const
modifier|*
name|arg
parameter_list|,
name|char
name|ch
parameter_list|)
block|{
name|struct
name|quoting_options
name|options
decl_stmt|;
name|options
operator|=
name|default_quoting_options
expr_stmt|;
name|set_char_quoting
argument_list|(
operator|&
name|options
argument_list|,
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|quotearg_n_options
argument_list|(
literal|0
argument_list|,
name|arg
argument_list|,
operator|&
name|options
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|quotearg_colon
parameter_list|(
name|char
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|quotearg_char
argument_list|(
name|arg
argument_list|,
literal|':'
argument_list|)
return|;
block|}
end_function

end_unit

