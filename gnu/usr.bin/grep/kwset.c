begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* kwset.c - search for any of a set of keywords.    Copyright (C) 1989, 1998 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_comment
comment|/* Written August 1989 by Mike Haertel.    The author may be reached (Email) at the address mike@ai.mit.edu,    or (US mail) as Mike Haertel c/o Free Software Foundation. */
end_comment

begin_comment
comment|/* The algorithm implemented by these routines bears a startling resemblence    to one discovered by Beate Commentz-Walter, although it is not identical.    See "A String Matching Algorithm Fast on the Average," Technical Report,    IBM-Germany, Scientific Center Heidelberg, Tiergartenstrasse 15, D-6900    Heidelberg, Germany.  See also Aho, A.V., and M. Corasick, "Efficient    String Matching:  An Aid to Bibliographic Search," CACM June 1975,    Vol. 18, No. 6, which describes the failure function used below. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"kwset.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|GREP
end_ifdef

begin_function_decl
specifier|extern
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_undef
undef|#
directive|undef
name|malloc
end_undef

begin_define
define|#
directive|define
name|malloc
value|xmalloc
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NCHAR
value|(UCHAR_MAX + 1)
end_define

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|malloc
end_define

begin_define
define|#
directive|define
name|obstack_chunk_free
value|free
end_define

begin_comment
comment|/* Balanced tree of edges and labels leaving a given trie node. */
end_comment

begin_struct
struct|struct
name|tree
block|{
name|struct
name|tree
modifier|*
name|llink
decl_stmt|;
comment|/* Left link; MUST be first field. */
name|struct
name|tree
modifier|*
name|rlink
decl_stmt|;
comment|/* Right link (to larger labels). */
name|struct
name|trie
modifier|*
name|trie
decl_stmt|;
comment|/* Trie node pointed to by this edge. */
name|unsigned
name|char
name|label
decl_stmt|;
comment|/* Label on this edge. */
name|char
name|balance
decl_stmt|;
comment|/* Difference in depths of subtrees. */
block|}
struct|;
end_struct

begin_comment
comment|/* Node of a trie representing a set of reversed keywords. */
end_comment

begin_struct
struct|struct
name|trie
block|{
name|unsigned
name|int
name|accepting
decl_stmt|;
comment|/* Word index of accepted word, or zero. */
name|struct
name|tree
modifier|*
name|links
decl_stmt|;
comment|/* Tree of edges leaving this node. */
name|struct
name|trie
modifier|*
name|parent
decl_stmt|;
comment|/* Parent of this node. */
name|struct
name|trie
modifier|*
name|next
decl_stmt|;
comment|/* List of all trie nodes in level order. */
name|struct
name|trie
modifier|*
name|fail
decl_stmt|;
comment|/* Aho-Corasick failure function. */
name|int
name|depth
decl_stmt|;
comment|/* Depth of this node from the root. */
name|int
name|shift
decl_stmt|;
comment|/* Shift function for search failures. */
name|int
name|maxshift
decl_stmt|;
comment|/* Max shift of self and descendents. */
block|}
struct|;
end_struct

begin_comment
comment|/* Structure returned opaquely to the caller, containing everything. */
end_comment

begin_struct
struct|struct
name|kwset
block|{
name|struct
name|obstack
name|obstack
decl_stmt|;
comment|/* Obstack for node allocation. */
name|int
name|words
decl_stmt|;
comment|/* Number of words in the trie. */
name|struct
name|trie
modifier|*
name|trie
decl_stmt|;
comment|/* The trie itself. */
name|int
name|mind
decl_stmt|;
comment|/* Minimum depth of an accepting node. */
name|int
name|maxd
decl_stmt|;
comment|/* Maximum depth of any node. */
name|unsigned
name|char
name|delta
index|[
name|NCHAR
index|]
decl_stmt|;
comment|/* Delta table for rapid search. */
name|struct
name|trie
modifier|*
name|next
index|[
name|NCHAR
index|]
decl_stmt|;
comment|/* Table of children of the root. */
name|char
modifier|*
name|target
decl_stmt|;
comment|/* Target string if there's only one. */
name|int
name|mind2
decl_stmt|;
comment|/* Used in Boyer-Moore search for one string. */
name|char
modifier|*
name|trans
decl_stmt|;
comment|/* Character translation table. */
block|}
struct|;
end_struct

begin_comment
comment|/* prototypes */
end_comment

begin_decl_stmt
specifier|static
name|void
name|enqueue
name|PARAMS
argument_list|(
operator|(
expr|struct
name|tree
operator|*
operator|,
expr|struct
name|trie
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|treefails
name|PARAMS
argument_list|(
operator|(
specifier|register
expr|struct
name|tree
operator|*
operator|,
expr|struct
name|trie
operator|*
operator|,
expr|struct
name|trie
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|treedelta
name|PARAMS
argument_list|(
operator|(
specifier|register
expr|struct
name|tree
operator|*
operator|,
specifier|register
name|unsigned
name|int
operator|,
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hasevery
name|PARAMS
argument_list|(
operator|(
specifier|register
expr|struct
name|tree
operator|*
operator|,
specifier|register
expr|struct
name|tree
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|treenext
name|PARAMS
argument_list|(
operator|(
expr|struct
name|tree
operator|*
operator|,
expr|struct
name|trie
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bmexec
name|PARAMS
argument_list|(
operator|(
name|kwset_t
operator|,
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cwexec
name|PARAMS
argument_list|(
operator|(
name|kwset_t
operator|,
name|char
operator|*
operator|,
name|size_t
operator|,
expr|struct
name|kwsmatch
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate and initialize a keyword set object, returning an opaque    pointer to it.  Return NULL if memory is not available. */
end_comment

begin_function
name|kwset_t
name|kwsalloc
parameter_list|(
name|trans
parameter_list|)
name|char
modifier|*
name|trans
decl_stmt|;
block|{
name|struct
name|kwset
modifier|*
name|kwset
decl_stmt|;
name|kwset
operator|=
operator|(
expr|struct
name|kwset
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|kwset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kwset
condition|)
return|return
literal|0
return|;
name|obstack_init
argument_list|(
operator|&
name|kwset
operator|->
name|obstack
argument_list|)
expr_stmt|;
name|kwset
operator|->
name|words
operator|=
literal|0
expr_stmt|;
name|kwset
operator|->
name|trie
operator|=
operator|(
expr|struct
name|trie
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|kwset
operator|->
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|trie
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kwset
operator|->
name|trie
condition|)
block|{
name|kwsfree
argument_list|(
operator|(
name|kwset_t
operator|)
name|kwset
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|kwset
operator|->
name|trie
operator|->
name|accepting
operator|=
literal|0
expr_stmt|;
name|kwset
operator|->
name|trie
operator|->
name|links
operator|=
literal|0
expr_stmt|;
name|kwset
operator|->
name|trie
operator|->
name|parent
operator|=
literal|0
expr_stmt|;
name|kwset
operator|->
name|trie
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|kwset
operator|->
name|trie
operator|->
name|fail
operator|=
literal|0
expr_stmt|;
name|kwset
operator|->
name|trie
operator|->
name|depth
operator|=
literal|0
expr_stmt|;
name|kwset
operator|->
name|trie
operator|->
name|shift
operator|=
literal|0
expr_stmt|;
name|kwset
operator|->
name|mind
operator|=
name|INT_MAX
expr_stmt|;
name|kwset
operator|->
name|maxd
operator|=
operator|-
literal|1
expr_stmt|;
name|kwset
operator|->
name|target
operator|=
literal|0
expr_stmt|;
name|kwset
operator|->
name|trans
operator|=
name|trans
expr_stmt|;
return|return
operator|(
name|kwset_t
operator|)
name|kwset
return|;
block|}
end_function

begin_comment
comment|/* Add the given string to the contents of the keyword set.  Return NULL    for success, an error message otherwise. */
end_comment

begin_function
name|char
modifier|*
name|kwsincr
parameter_list|(
name|kws
parameter_list|,
name|text
parameter_list|,
name|len
parameter_list|)
name|kwset_t
name|kws
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|struct
name|kwset
modifier|*
name|kwset
decl_stmt|;
specifier|register
name|struct
name|trie
modifier|*
name|trie
decl_stmt|;
specifier|register
name|unsigned
name|char
name|label
decl_stmt|;
specifier|register
name|struct
name|tree
modifier|*
name|link
decl_stmt|;
specifier|register
name|int
name|depth
decl_stmt|;
name|struct
name|tree
modifier|*
name|links
index|[
literal|12
index|]
decl_stmt|;
enum|enum
block|{
name|L
block|,
name|R
block|}
name|dirs
index|[
literal|12
index|]
enum|;
name|struct
name|tree
modifier|*
name|t
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|l
decl_stmt|,
modifier|*
name|rl
decl_stmt|,
modifier|*
name|lr
decl_stmt|;
name|kwset
operator|=
operator|(
expr|struct
name|kwset
operator|*
operator|)
name|kws
expr_stmt|;
name|trie
operator|=
name|kwset
operator|->
name|trie
expr_stmt|;
name|text
operator|+=
name|len
expr_stmt|;
comment|/* Descend the trie (built of reversed keywords) character-by-character,      installing new nodes when necessary. */
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|label
operator|=
name|kwset
operator|->
name|trans
condition|?
name|kwset
operator|->
name|trans
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|--
name|text
index|]
else|:
operator|*
operator|--
name|text
expr_stmt|;
comment|/* Descend the tree of outgoing links for this trie node, 	 looking for the current character and keeping track 	 of the path followed. */
name|link
operator|=
name|trie
operator|->
name|links
expr_stmt|;
name|links
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|tree
operator|*
operator|)
operator|&
name|trie
operator|->
name|links
expr_stmt|;
name|dirs
index|[
literal|0
index|]
operator|=
name|L
expr_stmt|;
name|depth
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|link
operator|&&
name|label
operator|!=
name|link
operator|->
name|label
condition|)
block|{
name|links
index|[
name|depth
index|]
operator|=
name|link
expr_stmt|;
if|if
condition|(
name|label
operator|<
name|link
operator|->
name|label
condition|)
name|dirs
index|[
name|depth
operator|++
index|]
operator|=
name|L
operator|,
name|link
operator|=
name|link
operator|->
name|llink
expr_stmt|;
else|else
name|dirs
index|[
name|depth
operator|++
index|]
operator|=
name|R
operator|,
name|link
operator|=
name|link
operator|->
name|rlink
expr_stmt|;
block|}
comment|/* The current character doesn't have an outgoing link at 	 this trie node, so build a new trie node and install 	 a link in the current trie node's tree. */
if|if
condition|(
operator|!
name|link
condition|)
block|{
name|link
operator|=
operator|(
expr|struct
name|tree
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|kwset
operator|->
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|link
condition|)
return|return
name|_
argument_list|(
literal|"memory exhausted"
argument_list|)
return|;
name|link
operator|->
name|llink
operator|=
literal|0
expr_stmt|;
name|link
operator|->
name|rlink
operator|=
literal|0
expr_stmt|;
name|link
operator|->
name|trie
operator|=
operator|(
expr|struct
name|trie
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|kwset
operator|->
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|trie
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|link
operator|->
name|trie
condition|)
return|return
name|_
argument_list|(
literal|"memory exhausted"
argument_list|)
return|;
name|link
operator|->
name|trie
operator|->
name|accepting
operator|=
literal|0
expr_stmt|;
name|link
operator|->
name|trie
operator|->
name|links
operator|=
literal|0
expr_stmt|;
name|link
operator|->
name|trie
operator|->
name|parent
operator|=
name|trie
expr_stmt|;
name|link
operator|->
name|trie
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|link
operator|->
name|trie
operator|->
name|fail
operator|=
literal|0
expr_stmt|;
name|link
operator|->
name|trie
operator|->
name|depth
operator|=
name|trie
operator|->
name|depth
operator|+
literal|1
expr_stmt|;
name|link
operator|->
name|trie
operator|->
name|shift
operator|=
literal|0
expr_stmt|;
name|link
operator|->
name|label
operator|=
name|label
expr_stmt|;
name|link
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
comment|/* Install the new tree node in its parent. */
if|if
condition|(
name|dirs
index|[
operator|--
name|depth
index|]
operator|==
name|L
condition|)
name|links
index|[
name|depth
index|]
operator|->
name|llink
operator|=
name|link
expr_stmt|;
else|else
name|links
index|[
name|depth
index|]
operator|->
name|rlink
operator|=
name|link
expr_stmt|;
comment|/* Back up the tree fixing the balance flags. */
while|while
condition|(
name|depth
operator|&&
operator|!
name|links
index|[
name|depth
index|]
operator|->
name|balance
condition|)
block|{
if|if
condition|(
name|dirs
index|[
name|depth
index|]
operator|==
name|L
condition|)
operator|--
name|links
index|[
name|depth
index|]
operator|->
name|balance
expr_stmt|;
else|else
operator|++
name|links
index|[
name|depth
index|]
operator|->
name|balance
expr_stmt|;
operator|--
name|depth
expr_stmt|;
block|}
comment|/* Rebalance the tree by pointer rotations if necessary. */
if|if
condition|(
name|depth
operator|&&
operator|(
operator|(
name|dirs
index|[
name|depth
index|]
operator|==
name|L
operator|&&
operator|--
name|links
index|[
name|depth
index|]
operator|->
name|balance
operator|)
operator|||
operator|(
name|dirs
index|[
name|depth
index|]
operator|==
name|R
operator|&&
operator|++
name|links
index|[
name|depth
index|]
operator|->
name|balance
operator|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|links
index|[
name|depth
index|]
operator|->
name|balance
condition|)
block|{
case|case
operator|(
name|char
operator|)
operator|-
literal|2
case|:
switch|switch
condition|(
name|dirs
index|[
name|depth
operator|+
literal|1
index|]
condition|)
block|{
case|case
name|L
case|:
name|r
operator|=
name|links
index|[
name|depth
index|]
operator|,
name|t
operator|=
name|r
operator|->
name|llink
operator|,
name|rl
operator|=
name|t
operator|->
name|rlink
expr_stmt|;
name|t
operator|->
name|rlink
operator|=
name|r
operator|,
name|r
operator|->
name|llink
operator|=
name|rl
expr_stmt|;
name|t
operator|->
name|balance
operator|=
name|r
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|R
case|:
name|r
operator|=
name|links
index|[
name|depth
index|]
operator|,
name|l
operator|=
name|r
operator|->
name|llink
operator|,
name|t
operator|=
name|l
operator|->
name|rlink
expr_stmt|;
name|rl
operator|=
name|t
operator|->
name|rlink
operator|,
name|lr
operator|=
name|t
operator|->
name|llink
expr_stmt|;
name|t
operator|->
name|llink
operator|=
name|l
operator|,
name|l
operator|->
name|rlink
operator|=
name|lr
operator|,
name|t
operator|->
name|rlink
operator|=
name|r
operator|,
name|r
operator|->
name|llink
operator|=
name|rl
expr_stmt|;
name|l
operator|->
name|balance
operator|=
name|t
operator|->
name|balance
operator|!=
literal|1
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
name|r
operator|->
name|balance
operator|=
name|t
operator|->
name|balance
operator|!=
operator|(
name|char
operator|)
operator|-
literal|1
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|t
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
switch|switch
condition|(
name|dirs
index|[
name|depth
operator|+
literal|1
index|]
condition|)
block|{
case|case
name|R
case|:
name|l
operator|=
name|links
index|[
name|depth
index|]
operator|,
name|t
operator|=
name|l
operator|->
name|rlink
operator|,
name|lr
operator|=
name|t
operator|->
name|llink
expr_stmt|;
name|t
operator|->
name|llink
operator|=
name|l
operator|,
name|l
operator|->
name|rlink
operator|=
name|lr
expr_stmt|;
name|t
operator|->
name|balance
operator|=
name|l
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|L
case|:
name|l
operator|=
name|links
index|[
name|depth
index|]
operator|,
name|r
operator|=
name|l
operator|->
name|rlink
operator|,
name|t
operator|=
name|r
operator|->
name|llink
expr_stmt|;
name|lr
operator|=
name|t
operator|->
name|llink
operator|,
name|rl
operator|=
name|t
operator|->
name|rlink
expr_stmt|;
name|t
operator|->
name|llink
operator|=
name|l
operator|,
name|l
operator|->
name|rlink
operator|=
name|lr
operator|,
name|t
operator|->
name|rlink
operator|=
name|r
operator|,
name|r
operator|->
name|llink
operator|=
name|rl
expr_stmt|;
name|l
operator|->
name|balance
operator|=
name|t
operator|->
name|balance
operator|!=
literal|1
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
name|r
operator|->
name|balance
operator|=
name|t
operator|->
name|balance
operator|!=
operator|(
name|char
operator|)
operator|-
literal|1
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|t
operator|->
name|balance
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dirs
index|[
name|depth
operator|-
literal|1
index|]
operator|==
name|L
condition|)
name|links
index|[
name|depth
operator|-
literal|1
index|]
operator|->
name|llink
operator|=
name|t
expr_stmt|;
else|else
name|links
index|[
name|depth
operator|-
literal|1
index|]
operator|->
name|rlink
operator|=
name|t
expr_stmt|;
block|}
block|}
name|trie
operator|=
name|link
operator|->
name|trie
expr_stmt|;
block|}
comment|/* Mark the node we finally reached as accepting, encoding the      index number of this word in the keyword set so far. */
if|if
condition|(
operator|!
name|trie
operator|->
name|accepting
condition|)
name|trie
operator|->
name|accepting
operator|=
literal|1
operator|+
literal|2
operator|*
name|kwset
operator|->
name|words
expr_stmt|;
operator|++
name|kwset
operator|->
name|words
expr_stmt|;
comment|/* Keep track of the longest and shortest string of the keyword set. */
if|if
condition|(
name|trie
operator|->
name|depth
operator|<
name|kwset
operator|->
name|mind
condition|)
name|kwset
operator|->
name|mind
operator|=
name|trie
operator|->
name|depth
expr_stmt|;
if|if
condition|(
name|trie
operator|->
name|depth
operator|>
name|kwset
operator|->
name|maxd
condition|)
name|kwset
operator|->
name|maxd
operator|=
name|trie
operator|->
name|depth
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Enqueue the trie nodes referenced from the given tree in the    given queue. */
end_comment

begin_function
specifier|static
name|void
name|enqueue
parameter_list|(
name|tree
parameter_list|,
name|last
parameter_list|)
name|struct
name|tree
modifier|*
name|tree
decl_stmt|;
name|struct
name|trie
modifier|*
modifier|*
name|last
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|tree
condition|)
return|return;
name|enqueue
argument_list|(
name|tree
operator|->
name|llink
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|enqueue
argument_list|(
name|tree
operator|->
name|rlink
argument_list|,
name|last
argument_list|)
expr_stmt|;
operator|(
operator|*
name|last
operator|)
operator|=
operator|(
operator|*
name|last
operator|)
operator|->
name|next
operator|=
name|tree
operator|->
name|trie
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the Aho-Corasick failure function for the trie nodes referenced    from the given tree, given the failure function for their parent as    well as a last resort failure node. */
end_comment

begin_function
specifier|static
name|void
name|treefails
parameter_list|(
name|tree
parameter_list|,
name|fail
parameter_list|,
name|recourse
parameter_list|)
specifier|register
name|struct
name|tree
modifier|*
name|tree
decl_stmt|;
name|struct
name|trie
modifier|*
name|fail
decl_stmt|;
name|struct
name|trie
modifier|*
name|recourse
decl_stmt|;
block|{
specifier|register
name|struct
name|tree
modifier|*
name|link
decl_stmt|;
if|if
condition|(
operator|!
name|tree
condition|)
return|return;
name|treefails
argument_list|(
name|tree
operator|->
name|llink
argument_list|,
name|fail
argument_list|,
name|recourse
argument_list|)
expr_stmt|;
name|treefails
argument_list|(
name|tree
operator|->
name|rlink
argument_list|,
name|fail
argument_list|,
name|recourse
argument_list|)
expr_stmt|;
comment|/* Find, in the chain of fails going back to the root, the first      node that has a descendent on the current label. */
while|while
condition|(
name|fail
condition|)
block|{
name|link
operator|=
name|fail
operator|->
name|links
expr_stmt|;
while|while
condition|(
name|link
operator|&&
name|tree
operator|->
name|label
operator|!=
name|link
operator|->
name|label
condition|)
if|if
condition|(
name|tree
operator|->
name|label
operator|<
name|link
operator|->
name|label
condition|)
name|link
operator|=
name|link
operator|->
name|llink
expr_stmt|;
else|else
name|link
operator|=
name|link
operator|->
name|rlink
expr_stmt|;
if|if
condition|(
name|link
condition|)
block|{
name|tree
operator|->
name|trie
operator|->
name|fail
operator|=
name|link
operator|->
name|trie
expr_stmt|;
return|return;
block|}
name|fail
operator|=
name|fail
operator|->
name|fail
expr_stmt|;
block|}
name|tree
operator|->
name|trie
operator|->
name|fail
operator|=
name|recourse
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set delta entries for the links of the given tree such that    the preexisting delta value is larger than the current depth. */
end_comment

begin_function
specifier|static
name|void
name|treedelta
parameter_list|(
name|tree
parameter_list|,
name|depth
parameter_list|,
name|delta
parameter_list|)
specifier|register
name|struct
name|tree
modifier|*
name|tree
decl_stmt|;
specifier|register
name|unsigned
name|int
name|depth
decl_stmt|;
name|unsigned
name|char
name|delta
index|[]
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|tree
condition|)
return|return;
name|treedelta
argument_list|(
name|tree
operator|->
name|llink
argument_list|,
name|depth
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|treedelta
argument_list|(
name|tree
operator|->
name|rlink
argument_list|,
name|depth
argument_list|,
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|<
name|delta
index|[
name|tree
operator|->
name|label
index|]
condition|)
name|delta
index|[
name|tree
operator|->
name|label
index|]
operator|=
name|depth
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if A has every label in B. */
end_comment

begin_function
specifier|static
name|int
name|hasevery
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
specifier|register
name|struct
name|tree
modifier|*
name|a
decl_stmt|;
specifier|register
name|struct
name|tree
modifier|*
name|b
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|b
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|hasevery
argument_list|(
name|a
argument_list|,
name|b
operator|->
name|llink
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|hasevery
argument_list|(
name|a
argument_list|,
name|b
operator|->
name|rlink
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|a
operator|&&
name|b
operator|->
name|label
operator|!=
name|a
operator|->
name|label
condition|)
if|if
condition|(
name|b
operator|->
name|label
operator|<
name|a
operator|->
name|label
condition|)
name|a
operator|=
name|a
operator|->
name|llink
expr_stmt|;
else|else
name|a
operator|=
name|a
operator|->
name|rlink
expr_stmt|;
return|return
operator|!
operator|!
name|a
return|;
block|}
end_function

begin_comment
comment|/* Compute a vector, indexed by character code, of the trie nodes    referenced from the given tree. */
end_comment

begin_function
specifier|static
name|void
name|treenext
parameter_list|(
name|tree
parameter_list|,
name|next
parameter_list|)
name|struct
name|tree
modifier|*
name|tree
decl_stmt|;
name|struct
name|trie
modifier|*
name|next
index|[]
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|tree
condition|)
return|return;
name|treenext
argument_list|(
name|tree
operator|->
name|llink
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|treenext
argument_list|(
name|tree
operator|->
name|rlink
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|next
index|[
name|tree
operator|->
name|label
index|]
operator|=
name|tree
operator|->
name|trie
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute the shift for each trie node, as well as the delta    table and next cache for the given keyword set. */
end_comment

begin_function
name|char
modifier|*
name|kwsprep
parameter_list|(
name|kws
parameter_list|)
name|kwset_t
name|kws
decl_stmt|;
block|{
specifier|register
name|struct
name|kwset
modifier|*
name|kwset
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|trie
modifier|*
name|curr
decl_stmt|,
modifier|*
name|fail
decl_stmt|;
specifier|register
name|char
modifier|*
name|trans
decl_stmt|;
name|unsigned
name|char
name|delta
index|[
name|NCHAR
index|]
decl_stmt|;
name|struct
name|trie
modifier|*
name|last
decl_stmt|,
modifier|*
name|next
index|[
name|NCHAR
index|]
decl_stmt|;
name|kwset
operator|=
operator|(
expr|struct
name|kwset
operator|*
operator|)
name|kws
expr_stmt|;
comment|/* Initial values for the delta table; will be changed later.  The      delta entry for a given character is the smallest depth of any      node at which an outgoing edge is labeled by that character. */
if|if
condition|(
name|kwset
operator|->
name|mind
operator|<
literal|256
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAR
condition|;
operator|++
name|i
control|)
name|delta
index|[
name|i
index|]
operator|=
name|kwset
operator|->
name|mind
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAR
condition|;
operator|++
name|i
control|)
name|delta
index|[
name|i
index|]
operator|=
literal|255
expr_stmt|;
comment|/* Check if we can use the simple boyer-moore algorithm, instead      of the hairy commentz-walter algorithm. */
if|if
condition|(
name|kwset
operator|->
name|words
operator|==
literal|1
operator|&&
name|kwset
operator|->
name|trans
operator|==
literal|0
condition|)
block|{
comment|/* Looking for just one string.  Extract it from the trie. */
name|kwset
operator|->
name|target
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|kwset
operator|->
name|obstack
argument_list|,
name|kwset
operator|->
name|mind
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|kwset
operator|->
name|mind
operator|-
literal|1
operator|,
name|curr
operator|=
name|kwset
operator|->
name|trie
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|kwset
operator|->
name|target
index|[
name|i
index|]
operator|=
name|curr
operator|->
name|links
operator|->
name|label
expr_stmt|;
name|curr
operator|=
name|curr
operator|->
name|links
operator|->
name|trie
expr_stmt|;
block|}
comment|/* Build the Boyer Moore delta.  Boy that's easy compared to CW. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|kwset
operator|->
name|mind
condition|;
operator|++
name|i
control|)
name|delta
index|[
operator|(
name|unsigned
name|char
operator|)
name|kwset
operator|->
name|target
index|[
name|i
index|]
index|]
operator|=
name|kwset
operator|->
name|mind
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|kwset
operator|->
name|mind2
operator|=
name|kwset
operator|->
name|mind
expr_stmt|;
comment|/* Find the minimal delta2 shift that we might make after 	 a backwards match has failed. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|kwset
operator|->
name|mind
operator|-
literal|1
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|kwset
operator|->
name|target
index|[
name|i
index|]
operator|==
name|kwset
operator|->
name|target
index|[
name|kwset
operator|->
name|mind
operator|-
literal|1
index|]
condition|)
name|kwset
operator|->
name|mind2
operator|=
name|kwset
operator|->
name|mind
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Traverse the nodes of the trie in level order, simultaneously 	 computing the delta table, failure function, and shift function. */
for|for
control|(
name|curr
operator|=
name|last
operator|=
name|kwset
operator|->
name|trie
init|;
name|curr
condition|;
name|curr
operator|=
name|curr
operator|->
name|next
control|)
block|{
comment|/* Enqueue the immediate descendents in the level order queue. */
name|enqueue
argument_list|(
name|curr
operator|->
name|links
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
name|curr
operator|->
name|shift
operator|=
name|kwset
operator|->
name|mind
expr_stmt|;
name|curr
operator|->
name|maxshift
operator|=
name|kwset
operator|->
name|mind
expr_stmt|;
comment|/* Update the delta table for the descendents of this node. */
name|treedelta
argument_list|(
name|curr
operator|->
name|links
argument_list|,
name|curr
operator|->
name|depth
argument_list|,
name|delta
argument_list|)
expr_stmt|;
comment|/* Compute the failure function for the decendents of this node. */
name|treefails
argument_list|(
name|curr
operator|->
name|links
argument_list|,
name|curr
operator|->
name|fail
argument_list|,
name|kwset
operator|->
name|trie
argument_list|)
expr_stmt|;
comment|/* Update the shifts at each node in the current node's chain 	     of fails back to the root. */
for|for
control|(
name|fail
operator|=
name|curr
operator|->
name|fail
init|;
name|fail
condition|;
name|fail
operator|=
name|fail
operator|->
name|fail
control|)
block|{
comment|/* If the current node has some outgoing edge that the fail 		 doesn't, then the shift at the fail should be no larger 		 than the difference of their depths. */
if|if
condition|(
operator|!
name|hasevery
argument_list|(
name|fail
operator|->
name|links
argument_list|,
name|curr
operator|->
name|links
argument_list|)
condition|)
if|if
condition|(
name|curr
operator|->
name|depth
operator|-
name|fail
operator|->
name|depth
operator|<
name|fail
operator|->
name|shift
condition|)
name|fail
operator|->
name|shift
operator|=
name|curr
operator|->
name|depth
operator|-
name|fail
operator|->
name|depth
expr_stmt|;
comment|/* If the current node is accepting then the shift at the 		 fail and its descendents should be no larger than the 		 difference of their depths. */
if|if
condition|(
name|curr
operator|->
name|accepting
operator|&&
name|fail
operator|->
name|maxshift
operator|>
name|curr
operator|->
name|depth
operator|-
name|fail
operator|->
name|depth
condition|)
name|fail
operator|->
name|maxshift
operator|=
name|curr
operator|->
name|depth
operator|-
name|fail
operator|->
name|depth
expr_stmt|;
block|}
block|}
comment|/* Traverse the trie in level order again, fixing up all nodes whose 	 shift exceeds their inherited maxshift. */
for|for
control|(
name|curr
operator|=
name|kwset
operator|->
name|trie
operator|->
name|next
init|;
name|curr
condition|;
name|curr
operator|=
name|curr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|curr
operator|->
name|maxshift
operator|>
name|curr
operator|->
name|parent
operator|->
name|maxshift
condition|)
name|curr
operator|->
name|maxshift
operator|=
name|curr
operator|->
name|parent
operator|->
name|maxshift
expr_stmt|;
if|if
condition|(
name|curr
operator|->
name|shift
operator|>
name|curr
operator|->
name|maxshift
condition|)
name|curr
operator|->
name|shift
operator|=
name|curr
operator|->
name|maxshift
expr_stmt|;
block|}
comment|/* Create a vector, indexed by character code, of the outgoing links 	 from the root node. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAR
condition|;
operator|++
name|i
control|)
name|next
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|treenext
argument_list|(
name|kwset
operator|->
name|trie
operator|->
name|links
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|trans
operator|=
name|kwset
operator|->
name|trans
operator|)
operator|!=
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAR
condition|;
operator|++
name|i
control|)
name|kwset
operator|->
name|next
index|[
name|i
index|]
operator|=
name|next
index|[
operator|(
name|unsigned
name|char
operator|)
name|trans
index|[
name|i
index|]
index|]
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAR
condition|;
operator|++
name|i
control|)
name|kwset
operator|->
name|next
index|[
name|i
index|]
operator|=
name|next
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* Fix things up for any translation table. */
if|if
condition|(
operator|(
name|trans
operator|=
name|kwset
operator|->
name|trans
operator|)
operator|!=
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAR
condition|;
operator|++
name|i
control|)
name|kwset
operator|->
name|delta
index|[
name|i
index|]
operator|=
name|delta
index|[
operator|(
name|unsigned
name|char
operator|)
name|trans
index|[
name|i
index|]
index|]
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAR
condition|;
operator|++
name|i
control|)
name|kwset
operator|->
name|delta
index|[
name|i
index|]
operator|=
name|delta
index|[
name|i
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|U
parameter_list|(
name|C
parameter_list|)
value|((unsigned char) (C))
end_define

begin_comment
comment|/* Fast boyer-moore search. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|bmexec
parameter_list|(
name|kws
parameter_list|,
name|text
parameter_list|,
name|size
parameter_list|)
name|kwset_t
name|kws
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|struct
name|kwset
modifier|*
name|kwset
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|d1
decl_stmt|;
specifier|register
name|char
modifier|*
name|ep
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|d
decl_stmt|,
name|gc
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|,
name|md2
decl_stmt|;
name|kwset
operator|=
operator|(
expr|struct
name|kwset
operator|*
operator|)
name|kws
expr_stmt|;
name|len
operator|=
name|kwset
operator|->
name|mind
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|text
return|;
if|if
condition|(
name|len
operator|>
name|size
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
return|return
name|memchr
argument_list|(
name|text
argument_list|,
name|kwset
operator|->
name|target
index|[
literal|0
index|]
argument_list|,
name|size
argument_list|)
return|;
name|d1
operator|=
name|kwset
operator|->
name|delta
expr_stmt|;
name|sp
operator|=
name|kwset
operator|->
name|target
operator|+
name|len
expr_stmt|;
name|gc
operator|=
name|U
argument_list|(
name|sp
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|md2
operator|=
name|kwset
operator|->
name|mind2
expr_stmt|;
name|tp
operator|=
name|text
operator|+
name|len
expr_stmt|;
comment|/* Significance of 12: 1 (initial offset) + 10 (skip loop) + 1 (md2). */
if|if
condition|(
name|size
operator|>
literal|12
operator|*
name|len
condition|)
comment|/* 11 is not a bug, the initial offset happens only once. */
for|for
control|(
name|ep
operator|=
name|text
operator|+
name|size
operator|-
literal|11
operator|*
name|len
init|;
condition|;
control|)
block|{
while|while
condition|(
name|tp
operator|<=
name|ep
condition|)
block|{
name|d
operator|=
name|d1
index|[
name|U
argument_list|(
name|tp
index|[
operator|-
literal|1
index|]
argument_list|)
index|]
operator|,
name|tp
operator|+=
name|d
expr_stmt|;
name|d
operator|=
name|d1
index|[
name|U
argument_list|(
name|tp
index|[
operator|-
literal|1
index|]
argument_list|)
index|]
operator|,
name|tp
operator|+=
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
name|d
operator|=
name|d1
index|[
name|U
argument_list|(
name|tp
index|[
operator|-
literal|1
index|]
argument_list|)
index|]
operator|,
name|tp
operator|+=
name|d
expr_stmt|;
name|d
operator|=
name|d1
index|[
name|U
argument_list|(
name|tp
index|[
operator|-
literal|1
index|]
argument_list|)
index|]
operator|,
name|tp
operator|+=
name|d
expr_stmt|;
name|d
operator|=
name|d1
index|[
name|U
argument_list|(
name|tp
index|[
operator|-
literal|1
index|]
argument_list|)
index|]
operator|,
name|tp
operator|+=
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
name|d
operator|=
name|d1
index|[
name|U
argument_list|(
name|tp
index|[
operator|-
literal|1
index|]
argument_list|)
index|]
operator|,
name|tp
operator|+=
name|d
expr_stmt|;
name|d
operator|=
name|d1
index|[
name|U
argument_list|(
name|tp
index|[
operator|-
literal|1
index|]
argument_list|)
index|]
operator|,
name|tp
operator|+=
name|d
expr_stmt|;
name|d
operator|=
name|d1
index|[
name|U
argument_list|(
name|tp
index|[
operator|-
literal|1
index|]
argument_list|)
index|]
operator|,
name|tp
operator|+=
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
name|d
operator|=
name|d1
index|[
name|U
argument_list|(
name|tp
index|[
operator|-
literal|1
index|]
argument_list|)
index|]
operator|,
name|tp
operator|+=
name|d
expr_stmt|;
name|d
operator|=
name|d1
index|[
name|U
argument_list|(
name|tp
index|[
operator|-
literal|1
index|]
argument_list|)
index|]
operator|,
name|tp
operator|+=
name|d
expr_stmt|;
block|}
break|break;
name|found
label|:
if|if
condition|(
name|U
argument_list|(
name|tp
index|[
operator|-
literal|2
index|]
argument_list|)
operator|==
name|gc
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<=
name|len
operator|&&
name|U
argument_list|(
name|tp
index|[
operator|-
name|i
index|]
argument_list|)
operator|==
name|U
argument_list|(
name|sp
index|[
operator|-
name|i
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|>
name|len
condition|)
return|return
name|tp
operator|-
name|len
return|;
block|}
name|tp
operator|+=
name|md2
expr_stmt|;
block|}
comment|/* Now we have only a few characters left to search.  We      carefully avoid ever producing an out-of-bounds pointer. */
name|ep
operator|=
name|text
operator|+
name|size
expr_stmt|;
name|d
operator|=
name|d1
index|[
name|U
argument_list|(
name|tp
index|[
operator|-
literal|1
index|]
argument_list|)
index|]
expr_stmt|;
while|while
condition|(
name|d
operator|<=
name|ep
operator|-
name|tp
condition|)
block|{
name|d
operator|=
name|d1
index|[
name|U
argument_list|(
operator|(
name|tp
operator|+=
name|d
operator|)
index|[
operator|-
literal|1
index|]
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|U
argument_list|(
name|tp
index|[
operator|-
literal|2
index|]
argument_list|)
operator|==
name|gc
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<=
name|len
operator|&&
name|U
argument_list|(
name|tp
index|[
operator|-
name|i
index|]
argument_list|)
operator|==
name|U
argument_list|(
name|sp
index|[
operator|-
name|i
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|>
name|len
condition|)
return|return
name|tp
operator|-
name|len
return|;
block|}
name|d
operator|=
name|md2
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Hairy multiple string search. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|cwexec
parameter_list|(
name|kws
parameter_list|,
name|text
parameter_list|,
name|len
parameter_list|,
name|kwsmatch
parameter_list|)
name|kwset_t
name|kws
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|kwsmatch
modifier|*
name|kwsmatch
decl_stmt|;
block|{
name|struct
name|kwset
modifier|*
name|kwset
decl_stmt|;
name|struct
name|trie
modifier|*
modifier|*
name|next
decl_stmt|,
modifier|*
name|trie
decl_stmt|,
modifier|*
name|accept
decl_stmt|;
name|char
modifier|*
name|beg
decl_stmt|,
modifier|*
name|lim
decl_stmt|,
modifier|*
name|mch
decl_stmt|,
modifier|*
name|lmch
decl_stmt|;
specifier|register
name|unsigned
name|char
name|c
decl_stmt|,
modifier|*
name|delta
decl_stmt|;
specifier|register
name|int
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|end
decl_stmt|,
modifier|*
name|qlim
decl_stmt|;
specifier|register
name|struct
name|tree
modifier|*
name|tree
decl_stmt|;
specifier|register
name|char
modifier|*
name|trans
decl_stmt|;
ifdef|#
directive|ifdef
name|lint
name|accept
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize register copies and look for easy ways out. */
name|kwset
operator|=
operator|(
expr|struct
name|kwset
operator|*
operator|)
name|kws
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|kwset
operator|->
name|mind
condition|)
return|return
literal|0
return|;
name|next
operator|=
name|kwset
operator|->
name|next
expr_stmt|;
name|delta
operator|=
name|kwset
operator|->
name|delta
expr_stmt|;
name|trans
operator|=
name|kwset
operator|->
name|trans
expr_stmt|;
name|lim
operator|=
name|text
operator|+
name|len
expr_stmt|;
name|end
operator|=
name|text
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|kwset
operator|->
name|mind
operator|)
operator|!=
literal|0
condition|)
name|mch
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|mch
operator|=
name|text
operator|,
name|accept
operator|=
name|kwset
operator|->
name|trie
expr_stmt|;
goto|goto
name|match
goto|;
block|}
if|if
condition|(
name|len
operator|>=
literal|4
operator|*
name|kwset
operator|->
name|mind
condition|)
name|qlim
operator|=
name|lim
operator|-
literal|4
operator|*
name|kwset
operator|->
name|mind
expr_stmt|;
else|else
name|qlim
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lim
operator|-
name|end
operator|>=
name|d
condition|)
block|{
if|if
condition|(
name|qlim
operator|&&
name|end
operator|<=
name|qlim
condition|)
block|{
name|end
operator|+=
name|d
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|d
operator|=
name|delta
index|[
name|c
operator|=
operator|*
name|end
index|]
operator|)
operator|&&
name|end
operator|<
name|qlim
condition|)
block|{
name|end
operator|+=
name|d
expr_stmt|;
name|end
operator|+=
name|delta
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|end
index|]
expr_stmt|;
name|end
operator|+=
name|delta
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|end
index|]
expr_stmt|;
block|}
operator|++
name|end
expr_stmt|;
block|}
else|else
name|d
operator|=
name|delta
index|[
name|c
operator|=
operator|(
name|end
operator|+=
name|d
operator|)
index|[
operator|-
literal|1
index|]
index|]
expr_stmt|;
if|if
condition|(
name|d
condition|)
continue|continue;
name|beg
operator|=
name|end
operator|-
literal|1
expr_stmt|;
name|trie
operator|=
name|next
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|trie
operator|->
name|accepting
condition|)
block|{
name|mch
operator|=
name|beg
expr_stmt|;
name|accept
operator|=
name|trie
expr_stmt|;
block|}
name|d
operator|=
name|trie
operator|->
name|shift
expr_stmt|;
while|while
condition|(
name|beg
operator|>
name|text
condition|)
block|{
name|c
operator|=
name|trans
condition|?
name|trans
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|--
name|beg
index|]
else|:
operator|*
operator|--
name|beg
expr_stmt|;
name|tree
operator|=
name|trie
operator|->
name|links
expr_stmt|;
while|while
condition|(
name|tree
operator|&&
name|c
operator|!=
name|tree
operator|->
name|label
condition|)
if|if
condition|(
name|c
operator|<
name|tree
operator|->
name|label
condition|)
name|tree
operator|=
name|tree
operator|->
name|llink
expr_stmt|;
else|else
name|tree
operator|=
name|tree
operator|->
name|rlink
expr_stmt|;
if|if
condition|(
name|tree
condition|)
block|{
name|trie
operator|=
name|tree
operator|->
name|trie
expr_stmt|;
if|if
condition|(
name|trie
operator|->
name|accepting
condition|)
block|{
name|mch
operator|=
name|beg
expr_stmt|;
name|accept
operator|=
name|trie
expr_stmt|;
block|}
block|}
else|else
break|break;
name|d
operator|=
name|trie
operator|->
name|shift
expr_stmt|;
block|}
if|if
condition|(
name|mch
condition|)
goto|goto
name|match
goto|;
block|}
return|return
literal|0
return|;
name|match
label|:
comment|/* Given a known match, find the longest possible match anchored      at or before its starting point.  This is nearly a verbatim      copy of the preceding main search loops. */
if|if
condition|(
name|lim
operator|-
name|mch
operator|>
name|kwset
operator|->
name|maxd
condition|)
name|lim
operator|=
name|mch
operator|+
name|kwset
operator|->
name|maxd
expr_stmt|;
name|lmch
operator|=
literal|0
expr_stmt|;
name|d
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|lim
operator|-
name|end
operator|>=
name|d
condition|)
block|{
if|if
condition|(
operator|(
name|d
operator|=
name|delta
index|[
name|c
operator|=
operator|(
name|end
operator|+=
name|d
operator|)
index|[
operator|-
literal|1
index|]
index|]
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|beg
operator|=
name|end
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|trie
operator|=
name|next
index|[
name|c
index|]
operator|)
condition|)
block|{
name|d
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|trie
operator|->
name|accepting
operator|&&
name|beg
operator|<=
name|mch
condition|)
block|{
name|lmch
operator|=
name|beg
expr_stmt|;
name|accept
operator|=
name|trie
expr_stmt|;
block|}
name|d
operator|=
name|trie
operator|->
name|shift
expr_stmt|;
while|while
condition|(
name|beg
operator|>
name|text
condition|)
block|{
name|c
operator|=
name|trans
condition|?
name|trans
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|--
name|beg
index|]
else|:
operator|*
operator|--
name|beg
expr_stmt|;
name|tree
operator|=
name|trie
operator|->
name|links
expr_stmt|;
while|while
condition|(
name|tree
operator|&&
name|c
operator|!=
name|tree
operator|->
name|label
condition|)
if|if
condition|(
name|c
operator|<
name|tree
operator|->
name|label
condition|)
name|tree
operator|=
name|tree
operator|->
name|llink
expr_stmt|;
else|else
name|tree
operator|=
name|tree
operator|->
name|rlink
expr_stmt|;
if|if
condition|(
name|tree
condition|)
block|{
name|trie
operator|=
name|tree
operator|->
name|trie
expr_stmt|;
if|if
condition|(
name|trie
operator|->
name|accepting
operator|&&
name|beg
operator|<=
name|mch
condition|)
block|{
name|lmch
operator|=
name|beg
expr_stmt|;
name|accept
operator|=
name|trie
expr_stmt|;
block|}
block|}
else|else
break|break;
name|d
operator|=
name|trie
operator|->
name|shift
expr_stmt|;
block|}
if|if
condition|(
name|lmch
condition|)
block|{
name|mch
operator|=
name|lmch
expr_stmt|;
goto|goto
name|match
goto|;
block|}
if|if
condition|(
operator|!
name|d
condition|)
name|d
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|kwsmatch
condition|)
block|{
name|kwsmatch
operator|->
name|index
operator|=
name|accept
operator|->
name|accepting
operator|/
literal|2
expr_stmt|;
name|kwsmatch
operator|->
name|beg
index|[
literal|0
index|]
operator|=
name|mch
expr_stmt|;
name|kwsmatch
operator|->
name|size
index|[
literal|0
index|]
operator|=
name|accept
operator|->
name|depth
expr_stmt|;
block|}
return|return
name|mch
return|;
block|}
end_function

begin_comment
comment|/* Search through the given text for a match of any member of the    given keyword set.  Return a pointer to the first character of    the matching substring, or NULL if no match is found.  If FOUNDLEN    is non-NULL store in the referenced location the length of the    matching substring.  Similarly, if FOUNDIDX is non-NULL, store    in the referenced location the index number of the particular    keyword matched. */
end_comment

begin_function
name|char
modifier|*
name|kwsexec
parameter_list|(
name|kws
parameter_list|,
name|text
parameter_list|,
name|size
parameter_list|,
name|kwsmatch
parameter_list|)
name|kwset_t
name|kws
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|struct
name|kwsmatch
modifier|*
name|kwsmatch
decl_stmt|;
block|{
name|struct
name|kwset
modifier|*
name|kwset
decl_stmt|;
name|char
modifier|*
name|ret
decl_stmt|;
name|kwset
operator|=
operator|(
expr|struct
name|kwset
operator|*
operator|)
name|kws
expr_stmt|;
if|if
condition|(
name|kwset
operator|->
name|words
operator|==
literal|1
operator|&&
name|kwset
operator|->
name|trans
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|bmexec
argument_list|(
name|kws
argument_list|,
name|text
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|kwsmatch
operator|!=
literal|0
operator|&&
name|ret
operator|!=
literal|0
condition|)
block|{
name|kwsmatch
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|kwsmatch
operator|->
name|beg
index|[
literal|0
index|]
operator|=
name|ret
expr_stmt|;
name|kwsmatch
operator|->
name|size
index|[
literal|0
index|]
operator|=
name|kwset
operator|->
name|mind
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
else|else
return|return
name|cwexec
argument_list|(
name|kws
argument_list|,
name|text
argument_list|,
name|size
argument_list|,
name|kwsmatch
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Free the components of the given keyword set. */
end_comment

begin_function
name|void
name|kwsfree
parameter_list|(
name|kws
parameter_list|)
name|kwset_t
name|kws
decl_stmt|;
block|{
name|struct
name|kwset
modifier|*
name|kwset
decl_stmt|;
name|kwset
operator|=
operator|(
expr|struct
name|kwset
operator|*
operator|)
name|kws
expr_stmt|;
name|obstack_free
argument_list|(
operator|&
name|kwset
operator|->
name|obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|kws
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

