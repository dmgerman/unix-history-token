begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* obstack.c - subroutines used implicitly by object stack macros    Copyright (C) 1988-1994,96,97,98,99 Free Software Foundation, Inc.     This file is part of the GNU C Library.  Its master source is NOT part of    the C library, however.  The master source lives in /gd/gnu/lib.     The GNU C Library is free software; you can redistribute it and/or    modify it under the terms of the GNU Library General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     The GNU C Library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Library General Public License for more details.     You should have received a copy of the GNU Library General Public    License along with the GNU C Library; see the file COPYING.LIB.  If not,    write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* NOTE BEFORE MODIFYING THIS FILE: This version number must be    incremented whenever callers compiled using an old obstack.h can no    longer properly call the functions in this obstack.c.  */
end_comment

begin_define
define|#
directive|define
name|OBSTACK_INTERFACE_VERSION
value|1
end_define

begin_comment
comment|/* Comment out all this code if we are using the GNU C Library, and are not    actually compiling the library itself, and the installed library    supports the same library interface we do.  This code is part of the GNU    C Library, but also included in many other GNU distributions.  Compiling    and linking in this code is a waste when using the GNU C library    (especially if it is a shared library).  Rather than having every GNU    program understand `configure --with-gnu-libc' and omit the object    files, it is simpler to just do this in the source for each such file.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* Random thing to get __GNU_LIBRARY__.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_LIBC
argument_list|)
operator|&&
name|defined
argument_list|(
name|__GNU_LIBRARY__
argument_list|)
operator|&&
name|__GNU_LIBRARY__
operator|>
literal|1
end_if

begin_include
include|#
directive|include
file|<gnu-versions.h>
end_include

begin_if
if|#
directive|if
name|_GNU_OBSTACK_INTERFACE_VERSION
operator|==
name|OBSTACK_INTERFACE_VERSION
end_if

begin_define
define|#
directive|define
name|ELIDE_CODE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ELIDE_CODE
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|&&
name|__STDC__
end_if

begin_define
define|#
directive|define
name|POINTER
value|void *
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|POINTER
value|char *
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Determine default alignment.  */
end_comment

begin_struct
struct|struct
name|fooalign
block|{
name|char
name|x
decl_stmt|;
name|double
name|d
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DEFAULT_ALIGNMENT
define|\
value|((PTR_INT_TYPE) ((char *)&((struct fooalign *) 0)->d - (char *) 0))
end_define

begin_comment
comment|/* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.    But in fact it might be less smart and round addresses to as much as    DEFAULT_ROUNDING.  So we prepare for it to do that.  */
end_comment

begin_union
union|union
name|fooround
block|{
name|long
name|x
decl_stmt|;
name|double
name|d
decl_stmt|;
block|}
union|;
end_union

begin_define
define|#
directive|define
name|DEFAULT_ROUNDING
value|(sizeof (union fooround))
end_define

begin_comment
comment|/* When we copy a long block of data, this is the unit to do it with.    On some machines, copying successive ints does not work;    in such a case, redefine COPYING_UNIT to `long' (if that works)    or `char' as a last resort.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|COPYING_UNIT
end_ifndef

begin_define
define|#
directive|define
name|COPYING_UNIT
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The functions allocating more room by calling `obstack_chunk_alloc'    jump to the handler pointed to by `obstack_alloc_failed_handler'.    This can be set to a user defined function which should either    abort gracefully or use longjump - but shouldn't return.  This    variable by default points to the internal function    `print_and_abort'.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|&&
name|__STDC__
end_if

begin_function_decl
specifier|static
name|void
name|print_and_abort
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|obstack_alloc_failed_handler
function_decl|)
parameter_list|(
name|void
parameter_list|)
init|=
name|print_and_abort
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|print_and_abort
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|obstack_alloc_failed_handler
function_decl|)
parameter_list|()
init|=
name|print_and_abort
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Exit value used when `print_and_abort' is used.  */
end_comment

begin_if
if|#
directive|if
name|defined
name|__GNU_LIBRARY__
operator|||
name|defined
name|HAVE_STDLIB_H
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EXIT_FAILURE
end_ifndef

begin_define
define|#
directive|define
name|EXIT_FAILURE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|obstack_exit_failure
init|=
name|EXIT_FAILURE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The non-GNU-C macros copy the obstack into this global variable    to avoid multiple evaluation.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define a macro that either calls functions with the traditional malloc/free    calling interface, or calls functions with the mmalloc/mfree interface    (that adds an extra first argument), based on the state of use_extra_arg.    For free, do not use ?:, since some compilers, like the MIPS compilers,    do not allow (expr) ? void : void.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|&&
name|__STDC__
end_if

begin_define
define|#
directive|define
name|CALL_CHUNKFUN
parameter_list|(
name|h
parameter_list|,
name|size
parameter_list|)
define|\
value|(((h) -> use_extra_arg) \    ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \    : (*(struct _obstack_chunk *(*) (long)) (h)->chunkfun) ((size)))
end_define

begin_define
define|#
directive|define
name|CALL_FREEFUN
parameter_list|(
name|h
parameter_list|,
name|old_chunk
parameter_list|)
define|\
value|do { \     if ((h) -> use_extra_arg) \       (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \     else \       (*(void (*) (void *)) (h)->freefun) ((old_chunk)); \   } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CALL_CHUNKFUN
parameter_list|(
name|h
parameter_list|,
name|size
parameter_list|)
define|\
value|(((h) -> use_extra_arg) \    ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \    : (*(struct _obstack_chunk *(*) ()) (h)->chunkfun) ((size)))
end_define

begin_define
define|#
directive|define
name|CALL_FREEFUN
parameter_list|(
name|h
parameter_list|,
name|old_chunk
parameter_list|)
define|\
value|do { \     if ((h) -> use_extra_arg) \       (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \     else \       (*(void (*) ()) (h)->freefun) ((old_chunk)); \   } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).    Objects start on multiples of ALIGNMENT (0 means use default).    CHUNKFUN is the function to use to allocate chunks,    and FREEFUN the function to free them.     Return nonzero if successful, calls obstack_alloc_failed_handler if    allocation fails.  */
end_comment

begin_decl_stmt
name|int
name|_obstack_begin
argument_list|(
name|h
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|,
name|chunkfun
argument_list|,
name|freefun
argument_list|)
decl|struct
name|obstack
modifier|*
name|h
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|alignment
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|&&
name|__STDC__
end_if

begin_function_decl
name|POINTER
function_decl|(
modifier|*
name|chunkfun
function_decl|)
parameter_list|(
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|freefun
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|POINTER
function_decl|(
modifier|*
name|chunkfun
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|freefun
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|chunk
decl_stmt|;
comment|/* points to new chunk */
if|if
condition|(
name|alignment
operator|==
literal|0
condition|)
name|alignment
operator|=
operator|(
name|int
operator|)
name|DEFAULT_ALIGNMENT
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
comment|/* Default size is what GNU malloc can fit in a 4096-byte block.  */
block|{
comment|/* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc. 	 Use the values for range checking, because if range checking is off, 	 the extra bytes won't be missed terribly, but if range checking is on 	 and we used a larger request, a whole extra 4096 bytes would be 	 allocated.  	 These number are irrelevant to the new GNU malloc.  I suspect it is 	 less sensitive to the size of the request.  */
name|int
name|extra
init|=
operator|(
operator|(
operator|(
operator|(
literal|12
operator|+
name|DEFAULT_ROUNDING
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|DEFAULT_ROUNDING
operator|-
literal|1
operator|)
operator|)
operator|+
literal|4
operator|+
name|DEFAULT_ROUNDING
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|DEFAULT_ROUNDING
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
name|size
operator|=
literal|4096
operator|-
name|extra
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|&&
name|__STDC__
name|h
operator|->
name|chunkfun
operator|=
operator|(
expr|struct
name|_obstack_chunk
operator|*
call|(
modifier|*
call|)
argument_list|(
name|void
operator|*
argument_list|,
name|long
argument_list|)
operator|)
name|chunkfun
expr_stmt|;
name|h
operator|->
name|freefun
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
expr|struct
name|_obstack_chunk
operator|*
argument_list|)
operator|)
name|freefun
expr_stmt|;
else|#
directive|else
name|h
operator|->
name|chunkfun
operator|=
operator|(
expr|struct
name|_obstack_chunk
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|chunkfun
expr_stmt|;
name|h
operator|->
name|freefun
operator|=
name|freefun
expr_stmt|;
endif|#
directive|endif
name|h
operator|->
name|chunk_size
operator|=
name|size
expr_stmt|;
name|h
operator|->
name|alignment_mask
operator|=
name|alignment
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|use_extra_arg
operator|=
literal|0
expr_stmt|;
name|chunk
operator|=
name|h
operator|->
name|chunk
operator|=
name|CALL_CHUNKFUN
argument_list|(
name|h
argument_list|,
name|h
operator|->
name|chunk_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chunk
condition|)
call|(
modifier|*
name|obstack_alloc_failed_handler
call|)
argument_list|()
expr_stmt|;
name|h
operator|->
name|next_free
operator|=
name|h
operator|->
name|object_base
operator|=
name|chunk
operator|->
name|contents
expr_stmt|;
name|h
operator|->
name|chunk_limit
operator|=
name|chunk
operator|->
name|limit
operator|=
operator|(
name|char
operator|*
operator|)
name|chunk
operator|+
name|h
operator|->
name|chunk_size
expr_stmt|;
name|chunk
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
comment|/* The initial chunk now contains no empty object.  */
name|h
operator|->
name|maybe_empty_object
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|alloc_failed
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_decl_stmt
name|int
name|_obstack_begin_1
argument_list|(
name|h
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|,
name|chunkfun
argument_list|,
name|freefun
argument_list|,
name|arg
argument_list|)
decl|struct
name|obstack
modifier|*
name|h
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|alignment
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|&&
name|__STDC__
end_if

begin_function_decl
name|POINTER
function_decl|(
modifier|*
name|chunkfun
function_decl|)
parameter_list|(
name|POINTER
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|freefun
function_decl|)
parameter_list|(
name|POINTER
parameter_list|,
name|POINTER
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|POINTER
function_decl|(
modifier|*
name|chunkfun
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|freefun
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|POINTER
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|chunk
decl_stmt|;
comment|/* points to new chunk */
if|if
condition|(
name|alignment
operator|==
literal|0
condition|)
name|alignment
operator|=
operator|(
name|int
operator|)
name|DEFAULT_ALIGNMENT
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
comment|/* Default size is what GNU malloc can fit in a 4096-byte block.  */
block|{
comment|/* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc. 	 Use the values for range checking, because if range checking is off, 	 the extra bytes won't be missed terribly, but if range checking is on 	 and we used a larger request, a whole extra 4096 bytes would be 	 allocated.  	 These number are irrelevant to the new GNU malloc.  I suspect it is 	 less sensitive to the size of the request.  */
name|int
name|extra
init|=
operator|(
operator|(
operator|(
operator|(
literal|12
operator|+
name|DEFAULT_ROUNDING
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|DEFAULT_ROUNDING
operator|-
literal|1
operator|)
operator|)
operator|+
literal|4
operator|+
name|DEFAULT_ROUNDING
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|DEFAULT_ROUNDING
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
name|size
operator|=
literal|4096
operator|-
name|extra
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|&&
name|__STDC__
name|h
operator|->
name|chunkfun
operator|=
operator|(
expr|struct
name|_obstack_chunk
operator|*
call|(
modifier|*
call|)
argument_list|(
name|void
operator|*
argument_list|,
name|long
argument_list|)
operator|)
name|chunkfun
expr_stmt|;
name|h
operator|->
name|freefun
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
expr|struct
name|_obstack_chunk
operator|*
argument_list|)
operator|)
name|freefun
expr_stmt|;
else|#
directive|else
name|h
operator|->
name|chunkfun
operator|=
operator|(
expr|struct
name|_obstack_chunk
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|chunkfun
expr_stmt|;
name|h
operator|->
name|freefun
operator|=
name|freefun
expr_stmt|;
endif|#
directive|endif
name|h
operator|->
name|chunk_size
operator|=
name|size
expr_stmt|;
name|h
operator|->
name|alignment_mask
operator|=
name|alignment
operator|-
literal|1
expr_stmt|;
name|h
operator|->
name|extra_arg
operator|=
name|arg
expr_stmt|;
name|h
operator|->
name|use_extra_arg
operator|=
literal|1
expr_stmt|;
name|chunk
operator|=
name|h
operator|->
name|chunk
operator|=
name|CALL_CHUNKFUN
argument_list|(
name|h
argument_list|,
name|h
operator|->
name|chunk_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chunk
condition|)
call|(
modifier|*
name|obstack_alloc_failed_handler
call|)
argument_list|()
expr_stmt|;
name|h
operator|->
name|next_free
operator|=
name|h
operator|->
name|object_base
operator|=
name|chunk
operator|->
name|contents
expr_stmt|;
name|h
operator|->
name|chunk_limit
operator|=
name|chunk
operator|->
name|limit
operator|=
operator|(
name|char
operator|*
operator|)
name|chunk
operator|+
name|h
operator|->
name|chunk_size
expr_stmt|;
name|chunk
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
comment|/* The initial chunk now contains no empty object.  */
name|h
operator|->
name|maybe_empty_object
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|alloc_failed
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/* Allocate a new current chunk for the obstack *H    on the assumption that LENGTH bytes need to be added    to the current object, or a new object of length LENGTH allocated.    Copies any partial object from the end of the old chunk    to the beginning of the new one.  */
end_comment

begin_function
name|void
name|_obstack_newchunk
parameter_list|(
name|h
parameter_list|,
name|length
parameter_list|)
name|struct
name|obstack
modifier|*
name|h
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|old_chunk
init|=
name|h
operator|->
name|chunk
decl_stmt|;
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|new_chunk
decl_stmt|;
specifier|register
name|long
name|new_size
decl_stmt|;
specifier|register
name|long
name|obj_size
init|=
name|h
operator|->
name|next_free
operator|-
name|h
operator|->
name|object_base
decl_stmt|;
specifier|register
name|long
name|i
decl_stmt|;
name|long
name|already
decl_stmt|;
comment|/* Compute size for new chunk.  */
name|new_size
operator|=
operator|(
name|obj_size
operator|+
name|length
operator|)
operator|+
operator|(
name|obj_size
operator|>>
literal|3
operator|)
operator|+
literal|100
expr_stmt|;
if|if
condition|(
name|new_size
operator|<
name|h
operator|->
name|chunk_size
condition|)
name|new_size
operator|=
name|h
operator|->
name|chunk_size
expr_stmt|;
comment|/* Allocate and initialize the new chunk.  */
name|new_chunk
operator|=
name|CALL_CHUNKFUN
argument_list|(
name|h
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_chunk
condition|)
call|(
modifier|*
name|obstack_alloc_failed_handler
call|)
argument_list|()
expr_stmt|;
name|h
operator|->
name|chunk
operator|=
name|new_chunk
expr_stmt|;
name|new_chunk
operator|->
name|prev
operator|=
name|old_chunk
expr_stmt|;
name|new_chunk
operator|->
name|limit
operator|=
name|h
operator|->
name|chunk_limit
operator|=
operator|(
name|char
operator|*
operator|)
name|new_chunk
operator|+
name|new_size
expr_stmt|;
comment|/* Move the existing object to the new chunk.      Word at a time is fast and is safe if the object      is sufficiently aligned.  */
if|if
condition|(
name|h
operator|->
name|alignment_mask
operator|+
literal|1
operator|>=
name|DEFAULT_ALIGNMENT
condition|)
block|{
for|for
control|(
name|i
operator|=
name|obj_size
operator|/
sizeof|sizeof
argument_list|(
name|COPYING_UNIT
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
operator|(
operator|(
name|COPYING_UNIT
operator|*
operator|)
name|new_chunk
operator|->
name|contents
operator|)
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|COPYING_UNIT
operator|*
operator|)
name|h
operator|->
name|object_base
operator|)
index|[
name|i
index|]
expr_stmt|;
comment|/* We used to copy the odd few remaining bytes as one extra COPYING_UNIT, 	 but that can cross a page boundary on a machine 	 which does not do strict alignment for COPYING_UNITS.  */
name|already
operator|=
name|obj_size
operator|/
sizeof|sizeof
argument_list|(
name|COPYING_UNIT
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|COPYING_UNIT
argument_list|)
expr_stmt|;
block|}
else|else
name|already
operator|=
literal|0
expr_stmt|;
comment|/* Copy remaining bytes one by one.  */
for|for
control|(
name|i
operator|=
name|already
init|;
name|i
operator|<
name|obj_size
condition|;
name|i
operator|++
control|)
name|new_chunk
operator|->
name|contents
index|[
name|i
index|]
operator|=
name|h
operator|->
name|object_base
index|[
name|i
index|]
expr_stmt|;
comment|/* If the object just copied was the only data in OLD_CHUNK,      free that chunk and remove it from the chain.      But not if that chunk might contain an empty object.  */
if|if
condition|(
name|h
operator|->
name|object_base
operator|==
name|old_chunk
operator|->
name|contents
operator|&&
operator|!
name|h
operator|->
name|maybe_empty_object
condition|)
block|{
name|new_chunk
operator|->
name|prev
operator|=
name|old_chunk
operator|->
name|prev
expr_stmt|;
name|CALL_FREEFUN
argument_list|(
name|h
argument_list|,
name|old_chunk
argument_list|)
expr_stmt|;
block|}
name|h
operator|->
name|object_base
operator|=
name|new_chunk
operator|->
name|contents
expr_stmt|;
name|h
operator|->
name|next_free
operator|=
name|h
operator|->
name|object_base
operator|+
name|obj_size
expr_stmt|;
comment|/* The new chunk certainly contains no empty object yet.  */
name|h
operator|->
name|maybe_empty_object
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if object OBJ has been allocated from obstack H.    This is here for debugging.    If you use it in a program, you are probably losing.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|&&
name|__STDC__
end_if

begin_comment
comment|/* Suppress -Wmissing-prototypes warning.  We don't want to declare this in    obstack.h because it is just for debugging.  */
end_comment

begin_function_decl
name|int
name|_obstack_allocated_p
parameter_list|(
name|struct
name|obstack
modifier|*
name|h
parameter_list|,
name|POINTER
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|_obstack_allocated_p
parameter_list|(
name|h
parameter_list|,
name|obj
parameter_list|)
name|struct
name|obstack
modifier|*
name|h
decl_stmt|;
name|POINTER
name|obj
decl_stmt|;
block|{
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|lp
decl_stmt|;
comment|/* below addr of any objects in this chunk */
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|plp
decl_stmt|;
comment|/* point to previous chunk if any */
name|lp
operator|=
operator|(
name|h
operator|)
operator|->
name|chunk
expr_stmt|;
comment|/* We use>= rather than> since the object cannot be exactly at      the beginning of the chunk but might be an empty object exactly      at the end of an adjacent chunk.  */
while|while
condition|(
name|lp
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|POINTER
operator|)
name|lp
operator|>=
name|obj
operator|||
call|(
name|POINTER
call|)
argument_list|(
name|lp
argument_list|)
operator|->
name|limit
operator|<
name|obj
operator|)
condition|)
block|{
name|plp
operator|=
name|lp
operator|->
name|prev
expr_stmt|;
name|lp
operator|=
name|plp
expr_stmt|;
block|}
return|return
name|lp
operator|!=
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Free objects in obstack H, including OBJ and everything allocate    more recently than OBJ.  If OBJ is zero, free everything in H.  */
end_comment

begin_undef
undef|#
directive|undef
name|obstack_free
end_undef

begin_comment
comment|/* This function has two names with identical definitions.    This is the first one, called from non-ANSI code.  */
end_comment

begin_function
name|void
name|_obstack_free
parameter_list|(
name|h
parameter_list|,
name|obj
parameter_list|)
name|struct
name|obstack
modifier|*
name|h
decl_stmt|;
name|POINTER
name|obj
decl_stmt|;
block|{
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|lp
decl_stmt|;
comment|/* below addr of any objects in this chunk */
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|plp
decl_stmt|;
comment|/* point to previous chunk if any */
name|lp
operator|=
name|h
operator|->
name|chunk
expr_stmt|;
comment|/* We use>= because there cannot be an object at the beginning of a chunk.      But there can be an empty object at that address      at the end of another chunk.  */
while|while
condition|(
name|lp
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|POINTER
operator|)
name|lp
operator|>=
name|obj
operator|||
call|(
name|POINTER
call|)
argument_list|(
name|lp
argument_list|)
operator|->
name|limit
operator|<
name|obj
operator|)
condition|)
block|{
name|plp
operator|=
name|lp
operator|->
name|prev
expr_stmt|;
name|CALL_FREEFUN
argument_list|(
name|h
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|lp
operator|=
name|plp
expr_stmt|;
comment|/* If we switch chunks, we can't tell whether the new current 	 chunk contains an empty object, so assume that it may.  */
name|h
operator|->
name|maybe_empty_object
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|lp
condition|)
block|{
name|h
operator|->
name|object_base
operator|=
name|h
operator|->
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|obj
operator|)
expr_stmt|;
name|h
operator|->
name|chunk_limit
operator|=
name|lp
operator|->
name|limit
expr_stmt|;
name|h
operator|->
name|chunk
operator|=
name|lp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|!=
literal|0
condition|)
comment|/* obj is not in any of the chunks! */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is used from ANSI code.  */
end_comment

begin_function
name|void
name|obstack_free
parameter_list|(
name|h
parameter_list|,
name|obj
parameter_list|)
name|struct
name|obstack
modifier|*
name|h
decl_stmt|;
name|POINTER
name|obj
decl_stmt|;
block|{
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|lp
decl_stmt|;
comment|/* below addr of any objects in this chunk */
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|plp
decl_stmt|;
comment|/* point to previous chunk if any */
name|lp
operator|=
name|h
operator|->
name|chunk
expr_stmt|;
comment|/* We use>= because there cannot be an object at the beginning of a chunk.      But there can be an empty object at that address      at the end of another chunk.  */
while|while
condition|(
name|lp
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|POINTER
operator|)
name|lp
operator|>=
name|obj
operator|||
call|(
name|POINTER
call|)
argument_list|(
name|lp
argument_list|)
operator|->
name|limit
operator|<
name|obj
operator|)
condition|)
block|{
name|plp
operator|=
name|lp
operator|->
name|prev
expr_stmt|;
name|CALL_FREEFUN
argument_list|(
name|h
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|lp
operator|=
name|plp
expr_stmt|;
comment|/* If we switch chunks, we can't tell whether the new current 	 chunk contains an empty object, so assume that it may.  */
name|h
operator|->
name|maybe_empty_object
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|lp
condition|)
block|{
name|h
operator|->
name|object_base
operator|=
name|h
operator|->
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|obj
operator|)
expr_stmt|;
name|h
operator|->
name|chunk_limit
operator|=
name|lp
operator|->
name|limit
expr_stmt|;
name|h
operator|->
name|chunk
operator|=
name|lp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|!=
literal|0
condition|)
comment|/* obj is not in any of the chunks! */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|_obstack_memory_used
parameter_list|(
name|h
parameter_list|)
name|struct
name|obstack
modifier|*
name|h
decl_stmt|;
block|{
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|nbytes
init|=
literal|0
decl_stmt|;
for|for
control|(
name|lp
operator|=
name|h
operator|->
name|chunk
init|;
name|lp
operator|!=
literal|0
condition|;
name|lp
operator|=
name|lp
operator|->
name|prev
control|)
block|{
name|nbytes
operator|+=
name|lp
operator|->
name|limit
operator|-
operator|(
name|char
operator|*
operator|)
name|lp
expr_stmt|;
block|}
return|return
name|nbytes
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Define the error handler.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBINTL_H
end_ifdef

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_
end_ifndef

begin_define
define|#
directive|define
name|_
parameter_list|(
name|Str
parameter_list|)
value|gettext (Str)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_
parameter_list|(
name|Str
parameter_list|)
value|(Str)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_LIBIO
end_if

begin_include
include|#
directive|include
file|<libio/iolibio.h>
end_include

begin_define
define|#
directive|define
name|fputs
parameter_list|(
name|s
parameter_list|,
name|f
parameter_list|)
value|_IO_fputs (s, f)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|print_and_abort
parameter_list|()
block|{
name|fputs
argument_list|(
name|_
argument_list|(
literal|"memory exhausted"
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|obstack_exit_failure
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* These are now turned off because the applications do not use it    and it uses bcopy via obstack_grow, which causes trouble on sysV.  */
end_comment

begin_comment
comment|/* Now define the functional versions of the obstack macros.    Define them to simply use the corresponding macros to do the job.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|&&
name|__STDC__
end_if

begin_comment
comment|/* These function definitions do not work with non-ANSI preprocessors;    they won't pass through the macro names in parentheses.  */
end_comment

begin_comment
comment|/* The function names appear in parentheses in order to prevent    the macro-definitions of the names from being expanded there.  */
end_comment

begin_endif
unit|POINTER (obstack_base) (obstack)      struct obstack *obstack; {   return obstack_base (obstack); }  POINTER (obstack_next_free) (obstack)      struct obstack *obstack; {   return obstack_next_free (obstack); }  int (obstack_object_size) (obstack)      struct obstack *obstack; {   return obstack_object_size (obstack); }  int (obstack_room) (obstack)      struct obstack *obstack; {   return obstack_room (obstack); }  int (obstack_make_room) (obstack, length)      struct obstack *obstack;      int length; {   return obstack_make_room (obstack, length); }  void (obstack_grow) (obstack, pointer, length)      struct obstack *obstack;      POINTER pointer;      int length; {   obstack_grow (obstack, pointer, length); }  void (obstack_grow0) (obstack, pointer, length)      struct obstack *obstack;      POINTER pointer;      int length; {   obstack_grow0 (obstack, pointer, length); }  void (obstack_1grow) (obstack, character)      struct obstack *obstack;      int character; {   obstack_1grow (obstack, character); }  void (obstack_blank) (obstack, length)      struct obstack *obstack;      int length; {   obstack_blank (obstack, length); }  void (obstack_1grow_fast) (obstack, character)      struct obstack *obstack;      int character; {   obstack_1grow_fast (obstack, character); }  void (obstack_blank_fast) (obstack, length)      struct obstack *obstack;      int length; {   obstack_blank_fast (obstack, length); }  POINTER (obstack_finish) (obstack)      struct obstack *obstack; {   return obstack_finish (obstack); }  POINTER (obstack_alloc) (obstack, length)      struct obstack *obstack;      int length; {   return obstack_alloc (obstack, length); }  POINTER (obstack_copy) (obstack, pointer, length)      struct obstack *obstack;      POINTER pointer;      int length; {   return obstack_copy (obstack, pointer, length); }  POINTER (obstack_copy0) (obstack, pointer, length)      struct obstack *obstack;      POINTER pointer;      int length; {   return obstack_copy0 (obstack, pointer, length); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STDC__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !ELIDE_CODE */
end_comment

end_unit

