begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dfa.c - determinisitic extended regexp routines for GNU    Copyright (C) 1988 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Written June, 1988 by Mike Haertel    Modified July, 1988 by Arthur David Olson to assist BMG speedups  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|index
end_ifndef

begin_define
define|#
directive|define
name|index
value|strchr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"dfa.h"
end_include

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_typedef
typedef|typedef
name|void
modifier|*
name|ptr_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|char
modifier|*
name|ptr_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|regmust
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|ptr_t
name|xcalloc
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|)
name|int
name|n
decl_stmt|;
name|size_t
name|s
decl_stmt|;
block|{
name|ptr_t
name|r
init|=
name|calloc
argument_list|(
name|n
argument_list|,
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|regerror
argument_list|(
literal|"Memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|ptr_t
comment|/* Not static, so alloca.o can use it.  */
name|xmalloc
parameter_list|(
name|n
parameter_list|)
name|size_t
name|n
decl_stmt|;
block|{
name|ptr_t
name|r
init|=
name|malloc
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|n
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|regerror
argument_list|(
literal|"Memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|ptr_t
name|xrealloc
parameter_list|(
name|p
parameter_list|,
name|n
parameter_list|)
name|ptr_t
name|p
decl_stmt|;
name|size_t
name|n
decl_stmt|;
block|{
name|ptr_t
name|r
init|=
name|realloc
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|n
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|regerror
argument_list|(
literal|"Memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CALLOC
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|,
name|n
parameter_list|)
value|((p) = (t *) xcalloc((n), sizeof (t)))
end_define

begin_define
define|#
directive|define
name|MALLOC
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|,
name|n
parameter_list|)
value|((p) = (t *) xmalloc((n) * sizeof (t)))
end_define

begin_define
define|#
directive|define
name|REALLOC
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|,
name|n
parameter_list|)
value|((p) = (t *) xrealloc((ptr_t) (p), (n) * sizeof (t)))
end_define

begin_comment
comment|/* Reallocate an array of type t if nalloc is too small for index. */
end_comment

begin_define
define|#
directive|define
name|REALLOC_IF_NECESSARY
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|,
name|nalloc
parameter_list|,
name|index
parameter_list|)
define|\
value|if ((index)>= (nalloc))			  \     {						  \       while ((index)>= (nalloc))		  \ 	(nalloc) *= 2;				  \       REALLOC(p, t, nalloc);			  \     }
end_define

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function
specifier|static
name|void
name|prtok
parameter_list|(
name|t
parameter_list|)
name|_token
name|t
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"END"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|<
name|_NOTCHAR
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c"
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|_EMPTY
case|:
name|s
operator|=
literal|"EMPTY"
expr_stmt|;
break|break;
case|case
name|_BACKREF
case|:
name|s
operator|=
literal|"BACKREF"
expr_stmt|;
break|break;
case|case
name|_BEGLINE
case|:
name|s
operator|=
literal|"BEGLINE"
expr_stmt|;
break|break;
case|case
name|_ALLBEGLINE
case|:
name|s
operator|=
literal|"ALLBEGLINE"
expr_stmt|;
break|break;
case|case
name|_ENDLINE
case|:
name|s
operator|=
literal|"ENDLINE"
expr_stmt|;
break|break;
case|case
name|_ALLENDLINE
case|:
name|s
operator|=
literal|"ALLENDLINE"
expr_stmt|;
break|break;
case|case
name|_BEGWORD
case|:
name|s
operator|=
literal|"BEGWORD"
expr_stmt|;
break|break;
case|case
name|_ENDWORD
case|:
name|s
operator|=
literal|"ENDWORD"
expr_stmt|;
break|break;
case|case
name|_LIMWORD
case|:
name|s
operator|=
literal|"LIMWORD"
expr_stmt|;
break|break;
case|case
name|_NOTLIMWORD
case|:
name|s
operator|=
literal|"NOTLIMWORD"
expr_stmt|;
break|break;
case|case
name|_QMARK
case|:
name|s
operator|=
literal|"QMARK"
expr_stmt|;
break|break;
case|case
name|_STAR
case|:
name|s
operator|=
literal|"STAR"
expr_stmt|;
break|break;
case|case
name|_PLUS
case|:
name|s
operator|=
literal|"PLUS"
expr_stmt|;
break|break;
case|case
name|_CAT
case|:
name|s
operator|=
literal|"CAT"
expr_stmt|;
break|break;
case|case
name|_OR
case|:
name|s
operator|=
literal|"OR"
expr_stmt|;
break|break;
case|case
name|_LPAREN
case|:
name|s
operator|=
literal|"LPAREN"
expr_stmt|;
break|break;
case|case
name|_RPAREN
case|:
name|s
operator|=
literal|"RPAREN"
expr_stmt|;
break|break;
default|default:
name|s
operator|=
literal|"SET"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/* Stuff pertaining to charsets. */
end_comment

begin_function
specifier|static
name|int
name|tstbit
parameter_list|(
name|b
parameter_list|,
name|c
parameter_list|)
name|int
name|b
decl_stmt|;
name|_charset
name|c
decl_stmt|;
block|{
return|return
name|c
index|[
name|b
operator|/
name|INTBITS
index|]
operator|&
literal|1
operator|<<
name|b
operator|%
name|INTBITS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|setbit
parameter_list|(
name|b
parameter_list|,
name|c
parameter_list|)
name|int
name|b
decl_stmt|;
name|_charset
name|c
decl_stmt|;
block|{
name|c
index|[
name|b
operator|/
name|INTBITS
index|]
operator||=
literal|1
operator|<<
name|b
operator|%
name|INTBITS
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clrbit
parameter_list|(
name|b
parameter_list|,
name|c
parameter_list|)
name|int
name|b
decl_stmt|;
name|_charset
name|c
decl_stmt|;
block|{
name|c
index|[
name|b
operator|/
name|INTBITS
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|b
operator|%
name|INTBITS
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|copyset
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
specifier|const
name|_charset
name|src
decl_stmt|;
name|_charset
name|dst
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_CHARSET_INTS
condition|;
operator|++
name|i
control|)
name|dst
index|[
name|i
index|]
operator|=
name|src
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zeroset
parameter_list|(
name|s
parameter_list|)
name|_charset
name|s
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_CHARSET_INTS
condition|;
operator|++
name|i
control|)
name|s
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|notset
parameter_list|(
name|s
parameter_list|)
name|_charset
name|s
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_CHARSET_INTS
condition|;
operator|++
name|i
control|)
name|s
index|[
name|i
index|]
operator|=
operator|~
name|s
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|equal
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
specifier|const
name|_charset
name|s1
decl_stmt|;
specifier|const
name|_charset
name|s2
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_CHARSET_INTS
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|s1
index|[
name|i
index|]
operator|!=
name|s2
index|[
name|i
index|]
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* A pointer to the current regexp is kept here during parsing. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|regexp
modifier|*
name|reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Find the index of charset s in reg->charsets, or allocate a new charset. */
end_comment

begin_function
specifier|static
name|int
name|charset_index
parameter_list|(
name|s
parameter_list|)
specifier|const
name|_charset
name|s
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reg
operator|->
name|cindex
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|equal
argument_list|(
name|s
argument_list|,
name|reg
operator|->
name|charsets
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|i
return|;
name|REALLOC_IF_NECESSARY
argument_list|(
name|reg
operator|->
name|charsets
argument_list|,
name|_charset
argument_list|,
name|reg
operator|->
name|calloc
argument_list|,
name|reg
operator|->
name|cindex
argument_list|)
expr_stmt|;
operator|++
name|reg
operator|->
name|cindex
expr_stmt|;
name|copyset
argument_list|(
name|s
argument_list|,
name|reg
operator|->
name|charsets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Syntax bits controlling the behavior of the lexical analyzer. */
end_comment

begin_expr_stmt
specifier|static
name|syntax_bits
operator|,
name|syntax_bits_set
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Flag for case-folding letters into sets. */
end_comment

begin_expr_stmt
specifier|static
name|case_fold
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Entry point to set syntax options. */
end_comment

begin_function
name|void
name|regsyntax
parameter_list|(
name|bits
parameter_list|,
name|fold
parameter_list|)
name|int
name|bits
decl_stmt|;
name|int
name|fold
decl_stmt|;
block|{
name|syntax_bits_set
operator|=
literal|1
expr_stmt|;
name|syntax_bits
operator|=
name|bits
expr_stmt|;
name|case_fold
operator|=
name|fold
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lexical analyzer. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|lexstart
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to beginning of input string. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|lexptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to next input character. */
end_comment

begin_expr_stmt
specifier|static
name|lexleft
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Number of characters remaining. */
end_comment

begin_expr_stmt
specifier|static
name|caret_allowed
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* True if backward context allows ^ 				   (meaningful only if RE_CONTEXT_INDEP_OPS 				   is turned off). */
end_comment

begin_expr_stmt
specifier|static
name|closure_allowed
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* True if backward context allows closures 				   (meaningful only if RE_CONTEXT_INDEP_OPS 				   is turned off). */
end_comment

begin_comment
comment|/* Note that characters become unsigned here. */
end_comment

begin_define
define|#
directive|define
name|FETCH
parameter_list|(
name|c
parameter_list|,
name|eoferr
parameter_list|)
define|\
value|{			   	      \     if (! lexleft)	   	      \       if (eoferr)	   	      \ 	regerror(eoferr);  	      \       else		   	      \ 	return _END;	   	      \     (c) = (unsigned char) *lexptr++;  \     --lexleft;		   	      \   }
end_define

begin_function
specifier|static
name|_token
name|lex
parameter_list|()
block|{
name|_token
name|c
decl_stmt|,
name|c2
decl_stmt|;
name|int
name|invert
decl_stmt|;
name|_charset
name|cset
decl_stmt|;
name|FETCH
argument_list|(
name|c
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'^'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
operator|&&
operator|(
operator|!
name|caret_allowed
operator|||
operator|(
name|syntax_bits
operator|&
name|RE_TIGHT_VBAR
operator|)
operator|&&
name|lexptr
operator|-
literal|1
operator|!=
name|lexstart
operator|)
condition|)
goto|goto
name|normal_char
goto|;
name|caret_allowed
operator|=
literal|0
expr_stmt|;
return|return
name|syntax_bits
operator|&
name|RE_TIGHT_VBAR
condition|?
name|_ALLBEGLINE
else|:
name|_BEGLINE
return|;
case|case
literal|'$'
case|:
if|if
condition|(
name|syntax_bits
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|||
operator|!
name|lexleft
operator|||
operator|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_TIGHT_VBAR
operator|)
operator|&&
operator|(
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_PARENS
condition|?
name|lexleft
operator|>
literal|0
operator|&&
operator|*
name|lexptr
operator|==
literal|')'
else|:
name|lexleft
operator|>
literal|1
operator|&&
operator|*
name|lexptr
operator|==
literal|'\\'
operator|&&
name|lexptr
index|[
literal|1
index|]
operator|==
literal|')'
operator|)
operator|||
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_VBAR
condition|?
name|lexleft
operator|>
literal|0
operator|&&
operator|*
name|lexptr
operator|==
literal|'|'
else|:
name|lexleft
operator|>
literal|1
operator|&&
operator|*
name|lexptr
operator|==
literal|'\\'
operator|&&
name|lexptr
index|[
literal|1
index|]
operator|==
literal|'|'
operator|)
operator|)
operator|)
condition|)
return|return
name|syntax_bits
operator|&
name|RE_TIGHT_VBAR
condition|?
name|_ALLENDLINE
else|:
name|_ENDLINE
return|;
goto|goto
name|normal_char
goto|;
case|case
literal|'\\'
case|:
name|FETCH
argument_list|(
name|c
argument_list|,
literal|"Unfinished \\ quote"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|caret_allowed
operator|=
literal|0
expr_stmt|;
name|closure_allowed
operator|=
literal|1
expr_stmt|;
return|return
name|_BACKREF
return|;
case|case
literal|'<'
case|:
name|caret_allowed
operator|=
literal|0
expr_stmt|;
return|return
name|_BEGWORD
return|;
case|case
literal|'>'
case|:
name|caret_allowed
operator|=
literal|0
expr_stmt|;
return|return
name|_ENDWORD
return|;
case|case
literal|'b'
case|:
name|caret_allowed
operator|=
literal|0
expr_stmt|;
return|return
name|_LIMWORD
return|;
case|case
literal|'B'
case|:
name|caret_allowed
operator|=
literal|0
expr_stmt|;
return|return
name|_NOTLIMWORD
return|;
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
name|zeroset
argument_list|(
name|cset
argument_list|)
expr_stmt|;
for|for
control|(
name|c2
operator|=
literal|0
init|;
name|c2
operator|<
name|_NOTCHAR
condition|;
operator|++
name|c2
control|)
if|if
condition|(
name|ISALNUM
argument_list|(
name|c2
argument_list|)
condition|)
name|setbit
argument_list|(
name|c2
argument_list|,
name|cset
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'W'
condition|)
name|notset
argument_list|(
name|cset
argument_list|)
expr_stmt|;
name|caret_allowed
operator|=
literal|0
expr_stmt|;
name|closure_allowed
operator|=
literal|1
expr_stmt|;
return|return
name|_SET
operator|+
name|charset_index
argument_list|(
name|cset
argument_list|)
return|;
case|case
literal|'?'
case|:
if|if
condition|(
name|syntax_bits
operator|&
name|RE_BK_PLUS_QM
condition|)
goto|goto
name|qmark
goto|;
goto|goto
name|normal_char
goto|;
case|case
literal|'+'
case|:
if|if
condition|(
name|syntax_bits
operator|&
name|RE_BK_PLUS_QM
condition|)
goto|goto
name|plus
goto|;
goto|goto
name|normal_char
goto|;
case|case
literal|'|'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_VBAR
operator|)
condition|)
goto|goto
name|or
goto|;
goto|goto
name|normal_char
goto|;
case|case
literal|'('
case|:
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_PARENS
operator|)
condition|)
goto|goto
name|lparen
goto|;
goto|goto
name|normal_char
goto|;
case|case
literal|')'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_PARENS
operator|)
condition|)
goto|goto
name|rparen
goto|;
goto|goto
name|normal_char
goto|;
default|default:
goto|goto
name|normal_char
goto|;
block|}
case|case
literal|'?'
case|:
if|if
condition|(
name|syntax_bits
operator|&
name|RE_BK_PLUS_QM
condition|)
goto|goto
name|normal_char
goto|;
name|qmark
label|:
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
operator|&&
operator|!
name|closure_allowed
condition|)
goto|goto
name|normal_char
goto|;
return|return
name|_QMARK
return|;
case|case
literal|'*'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
operator|&&
operator|!
name|closure_allowed
condition|)
goto|goto
name|normal_char
goto|;
return|return
name|_STAR
return|;
case|case
literal|'+'
case|:
if|if
condition|(
name|syntax_bits
operator|&
name|RE_BK_PLUS_QM
condition|)
goto|goto
name|normal_char
goto|;
name|plus
label|:
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
operator|&&
operator|!
name|closure_allowed
condition|)
goto|goto
name|normal_char
goto|;
return|return
name|_PLUS
return|;
case|case
literal|'|'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_VBAR
operator|)
condition|)
goto|goto
name|normal_char
goto|;
name|or
label|:
name|caret_allowed
operator|=
literal|1
expr_stmt|;
name|closure_allowed
operator|=
literal|0
expr_stmt|;
return|return
name|_OR
return|;
case|case
literal|'\n'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NEWLINE_OR
operator|)
condition|)
goto|goto
name|normal_char
goto|;
goto|goto
name|or
goto|;
case|case
literal|'('
case|:
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_PARENS
operator|)
condition|)
goto|goto
name|normal_char
goto|;
name|lparen
label|:
name|caret_allowed
operator|=
literal|1
expr_stmt|;
name|closure_allowed
operator|=
literal|0
expr_stmt|;
return|return
name|_LPAREN
return|;
case|case
literal|')'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_PARENS
operator|)
condition|)
goto|goto
name|normal_char
goto|;
name|rparen
label|:
name|caret_allowed
operator|=
literal|0
expr_stmt|;
name|closure_allowed
operator|=
literal|1
expr_stmt|;
return|return
name|_RPAREN
return|;
case|case
literal|'.'
case|:
name|zeroset
argument_list|(
name|cset
argument_list|)
expr_stmt|;
name|notset
argument_list|(
name|cset
argument_list|)
expr_stmt|;
name|clrbit
argument_list|(
literal|'\n'
argument_list|,
name|cset
argument_list|)
expr_stmt|;
name|caret_allowed
operator|=
literal|0
expr_stmt|;
name|closure_allowed
operator|=
literal|1
expr_stmt|;
return|return
name|_SET
operator|+
name|charset_index
argument_list|(
name|cset
argument_list|)
return|;
case|case
literal|'['
case|:
name|zeroset
argument_list|(
name|cset
argument_list|)
expr_stmt|;
name|FETCH
argument_list|(
name|c
argument_list|,
literal|"Unbalanced ["
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'^'
condition|)
block|{
name|FETCH
argument_list|(
name|c
argument_list|,
literal|"Unbalanced ["
argument_list|)
expr_stmt|;
name|invert
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|invert
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|FETCH
argument_list|(
name|c2
argument_list|,
literal|"Unbalanced ["
argument_list|)
expr_stmt|;
if|if
condition|(
name|c2
operator|==
literal|'-'
condition|)
block|{
name|FETCH
argument_list|(
name|c2
argument_list|,
literal|"Unbalanced ["
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|<=
name|c2
condition|)
block|{
name|setbit
argument_list|(
name|c
argument_list|,
name|cset
argument_list|)
expr_stmt|;
if|if
condition|(
name|case_fold
condition|)
if|if
condition|(
name|ISUPPER
argument_list|(
name|c
argument_list|)
condition|)
name|setbit
argument_list|(
name|tolower
argument_list|(
name|c
argument_list|)
argument_list|,
name|cset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISLOWER
argument_list|(
name|c
argument_list|)
condition|)
name|setbit
argument_list|(
name|toupper
argument_list|(
name|c
argument_list|)
argument_list|,
name|cset
argument_list|)
expr_stmt|;
operator|++
name|c
expr_stmt|;
block|}
name|FETCH
argument_list|(
name|c
argument_list|,
literal|"Unbalanced ["
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setbit
argument_list|(
name|c
argument_list|,
name|cset
argument_list|)
expr_stmt|;
if|if
condition|(
name|case_fold
condition|)
if|if
condition|(
name|ISUPPER
argument_list|(
name|c
argument_list|)
condition|)
name|setbit
argument_list|(
name|tolower
argument_list|(
name|c
argument_list|)
argument_list|,
name|cset
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISLOWER
argument_list|(
name|c
argument_list|)
condition|)
name|setbit
argument_list|(
name|toupper
argument_list|(
name|c
argument_list|)
argument_list|,
name|cset
argument_list|)
expr_stmt|;
name|c
operator|=
name|c2
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|!=
literal|']'
condition|)
do|;
if|if
condition|(
name|invert
condition|)
name|notset
argument_list|(
name|cset
argument_list|)
expr_stmt|;
name|caret_allowed
operator|=
literal|0
expr_stmt|;
name|closure_allowed
operator|=
literal|1
expr_stmt|;
return|return
name|_SET
operator|+
name|charset_index
argument_list|(
name|cset
argument_list|)
return|;
default|default:
name|normal_char
label|:
name|caret_allowed
operator|=
literal|0
expr_stmt|;
name|closure_allowed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|case_fold
operator|&&
name|ISALPHA
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|zeroset
argument_list|(
name|cset
argument_list|)
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|c
argument_list|,
name|cset
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|toupper
argument_list|(
name|c
argument_list|)
argument_list|,
name|cset
argument_list|)
expr_stmt|;
return|return
name|_SET
operator|+
name|charset_index
argument_list|(
name|cset
argument_list|)
return|;
block|}
return|return
name|c
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Recursive descent parser for regular expressions. */
end_comment

begin_decl_stmt
specifier|static
name|_token
name|tok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lookahead token. */
end_comment

begin_expr_stmt
specifier|static
name|depth
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Current depth of a hypothetical stack 				   holding deferred productions.  This is 				   used to determine the depth that will be 				   required of the real stack later on in 				   reganalyze(). */
end_comment

begin_comment
comment|/* Add the given token to the parse tree, maintaining the depth count and    updating the maximum depth if necessary. */
end_comment

begin_function
specifier|static
name|void
name|addtok
parameter_list|(
name|t
parameter_list|)
name|_token
name|t
decl_stmt|;
block|{
name|REALLOC_IF_NECESSARY
argument_list|(
name|reg
operator|->
name|tokens
argument_list|,
name|_token
argument_list|,
name|reg
operator|->
name|talloc
argument_list|,
name|reg
operator|->
name|tindex
argument_list|)
expr_stmt|;
name|reg
operator|->
name|tokens
index|[
name|reg
operator|->
name|tindex
operator|++
index|]
operator|=
name|t
expr_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|_QMARK
case|:
case|case
name|_STAR
case|:
case|case
name|_PLUS
case|:
break|break;
case|case
name|_CAT
case|:
case|case
name|_OR
case|:
operator|--
name|depth
expr_stmt|;
break|break;
default|default:
operator|++
name|reg
operator|->
name|nleaves
expr_stmt|;
case|case
name|_EMPTY
case|:
operator|++
name|depth
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|depth
operator|>
name|reg
operator|->
name|depth
condition|)
name|reg
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The grammar understood by the parser is as follows.     start:      regexp      _ALLBEGLINE regexp      regexp _ALLENDLINE      _ALLBEGLINE regexp _ALLENDLINE     regexp:      regexp _OR branch      branch     branch:      branch closure      closure     closure:      closure _QMARK      closure _STAR      closure _PLUS      atom     atom:<normal character>      _SET      _BACKREF      _BEGLINE      _ENDLINE      _BEGWORD      _ENDWORD      _LIMWORD      _NOTLIMWORD<empty>     The parser builds a parse tree in postfix form in an array of tokens. */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function_decl
specifier|static
name|void
name|regexp
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|regexp
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|atom
parameter_list|()
block|{
if|if
condition|(
name|tok
operator|>=
literal|0
operator|&&
name|tok
operator|<
name|_NOTCHAR
operator|||
name|tok
operator|>=
name|_SET
operator|||
name|tok
operator|==
name|_BACKREF
operator|||
name|tok
operator|==
name|_BEGLINE
operator|||
name|tok
operator|==
name|_ENDLINE
operator|||
name|tok
operator|==
name|_BEGWORD
operator|||
name|tok
operator|==
name|_ENDWORD
operator|||
name|tok
operator|==
name|_LIMWORD
operator|||
name|tok
operator|==
name|_NOTLIMWORD
condition|)
block|{
name|addtok
argument_list|(
name|tok
argument_list|)
expr_stmt|;
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|_LPAREN
condition|)
block|{
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
name|regexp
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|_RPAREN
condition|)
name|regerror
argument_list|(
literal|"Unbalanced ("
argument_list|)
expr_stmt|;
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
block|}
else|else
name|addtok
argument_list|(
name|_EMPTY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|closure
parameter_list|()
block|{
name|atom
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|_QMARK
operator|||
name|tok
operator|==
name|_STAR
operator|||
name|tok
operator|==
name|_PLUS
condition|)
block|{
name|addtok
argument_list|(
name|tok
argument_list|)
expr_stmt|;
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|branch
parameter_list|()
block|{
name|closure
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|!=
name|_RPAREN
operator|&&
name|tok
operator|!=
name|_OR
operator|&&
name|tok
operator|!=
name|_ALLENDLINE
operator|&&
name|tok
operator|>=
literal|0
condition|)
block|{
name|closure
argument_list|()
expr_stmt|;
name|addtok
argument_list|(
name|_CAT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|regexp
parameter_list|()
block|{
name|branch
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|_OR
condition|)
block|{
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
name|branch
argument_list|()
expr_stmt|;
name|addtok
argument_list|(
name|_OR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Main entry point for the parser.  S is a string to be parsed, len is the    length of the string, so s can include NUL characters.  R is a pointer to    the struct regexp to parse into. */
end_comment

begin_function
name|void
name|regparse
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|,
name|r
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|regexp
modifier|*
name|r
decl_stmt|;
block|{
name|reg
operator|=
name|r
expr_stmt|;
name|lexstart
operator|=
name|lexptr
operator|=
name|s
expr_stmt|;
name|lexleft
operator|=
name|len
expr_stmt|;
name|caret_allowed
operator|=
literal|1
expr_stmt|;
name|closure_allowed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|syntax_bits_set
condition|)
name|regerror
argument_list|(
literal|"No syntax specified"
argument_list|)
expr_stmt|;
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
name|depth
operator|=
name|r
operator|->
name|depth
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|_ALLBEGLINE
condition|)
block|{
name|addtok
argument_list|(
name|_BEGLINE
argument_list|)
expr_stmt|;
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
name|regexp
argument_list|()
expr_stmt|;
name|addtok
argument_list|(
name|_CAT
argument_list|)
expr_stmt|;
block|}
else|else
name|regexp
argument_list|()
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|_ALLENDLINE
condition|)
block|{
name|addtok
argument_list|(
name|_ENDLINE
argument_list|)
expr_stmt|;
name|addtok
argument_list|(
name|_CAT
argument_list|)
expr_stmt|;
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tok
operator|!=
name|_END
condition|)
name|regerror
argument_list|(
literal|"Unbalanced )"
argument_list|)
expr_stmt|;
name|addtok
argument_list|(
name|_END
operator|-
name|r
operator|->
name|nregexps
argument_list|)
expr_stmt|;
name|addtok
argument_list|(
name|_CAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|nregexps
condition|)
name|addtok
argument_list|(
name|_OR
argument_list|)
expr_stmt|;
operator|++
name|r
operator|->
name|nregexps
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Some primitives for operating on sets of positions. */
end_comment

begin_comment
comment|/* Copy one set to another; the destination must be large enough. */
end_comment

begin_function
specifier|static
name|void
name|copy
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
specifier|const
name|_position_set
modifier|*
name|src
decl_stmt|;
name|_position_set
modifier|*
name|dst
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|src
operator|->
name|nelem
condition|;
operator|++
name|i
control|)
name|dst
operator|->
name|elems
index|[
name|i
index|]
operator|=
name|src
operator|->
name|elems
index|[
name|i
index|]
expr_stmt|;
name|dst
operator|->
name|nelem
operator|=
name|src
operator|->
name|nelem
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert a position in a set.  Position sets are maintained in sorted    order according to index.  If position already exists in the set with    the same index then their constraints are logically or'd together.    S->elems must point to an array large enough to hold the resulting set. */
end_comment

begin_function
specifier|static
name|void
name|insert
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
name|_position
name|p
decl_stmt|;
name|_position_set
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|_position
name|t1
decl_stmt|,
name|t2
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|nelem
operator|&&
name|p
operator|.
name|index
operator|<
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
condition|;
operator|++
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|<
name|s
operator|->
name|nelem
operator|&&
name|p
operator|.
name|index
operator|==
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
condition|)
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|constraint
operator||=
name|p
operator|.
name|constraint
expr_stmt|;
else|else
block|{
name|t1
operator|=
name|p
expr_stmt|;
operator|++
name|s
operator|->
name|nelem
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|s
operator|->
name|nelem
condition|)
block|{
name|t2
operator|=
name|s
operator|->
name|elems
index|[
name|i
index|]
expr_stmt|;
name|s
operator|->
name|elems
index|[
name|i
operator|++
index|]
operator|=
name|t1
expr_stmt|;
name|t1
operator|=
name|t2
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Merge two sets of positions into a third.  The result is exactly as if    the positions of both sets were inserted into an initially empty set. */
end_comment

begin_function
specifier|static
name|void
name|merge
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|m
parameter_list|)
name|_position_set
modifier|*
name|s1
decl_stmt|;
name|_position_set
modifier|*
name|s2
decl_stmt|;
name|_position_set
modifier|*
name|m
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|m
operator|->
name|nelem
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|s1
operator|->
name|nelem
operator|&&
name|j
operator|<
name|s2
operator|->
name|nelem
condition|)
if|if
condition|(
name|s1
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
operator|>
name|s2
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|index
condition|)
name|m
operator|->
name|elems
index|[
name|m
operator|->
name|nelem
operator|++
index|]
operator|=
name|s1
operator|->
name|elems
index|[
name|i
operator|++
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|s1
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
operator|<
name|s2
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|index
condition|)
name|m
operator|->
name|elems
index|[
name|m
operator|->
name|nelem
operator|++
index|]
operator|=
name|s2
operator|->
name|elems
index|[
name|j
operator|++
index|]
expr_stmt|;
else|else
block|{
name|m
operator|->
name|elems
index|[
name|m
operator|->
name|nelem
index|]
operator|=
name|s1
operator|->
name|elems
index|[
name|i
operator|++
index|]
expr_stmt|;
name|m
operator|->
name|elems
index|[
name|m
operator|->
name|nelem
operator|++
index|]
operator|.
name|constraint
operator||=
name|s2
operator|->
name|elems
index|[
name|j
operator|++
index|]
operator|.
name|constraint
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
name|s1
operator|->
name|nelem
condition|)
name|m
operator|->
name|elems
index|[
name|m
operator|->
name|nelem
operator|++
index|]
operator|=
name|s1
operator|->
name|elems
index|[
name|i
operator|++
index|]
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|s2
operator|->
name|nelem
condition|)
name|m
operator|->
name|elems
index|[
name|m
operator|->
name|nelem
operator|++
index|]
operator|=
name|s2
operator|->
name|elems
index|[
name|j
operator|++
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete a position from a set. */
end_comment

begin_function
specifier|static
name|void
name|delete
parameter_list|(
name|p
parameter_list|,
name|s
parameter_list|)
name|_position
name|p
decl_stmt|;
name|_position_set
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|nelem
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|p
operator|.
name|index
operator|==
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|s
operator|->
name|nelem
condition|)
for|for
control|(
operator|--
name|s
operator|->
name|nelem
init|;
name|i
operator|<
name|s
operator|->
name|nelem
condition|;
operator|++
name|i
control|)
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|=
name|s
operator|->
name|elems
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the index of the state corresponding to the given position set with    the given preceding context, or create a new state if there is no such    state.  Newline and letter tell whether we got here on a newline or    letter, respectively. */
end_comment

begin_function
specifier|static
name|int
name|state_index
parameter_list|(
name|r
parameter_list|,
name|s
parameter_list|,
name|newline
parameter_list|,
name|letter
parameter_list|)
name|struct
name|regexp
modifier|*
name|r
decl_stmt|;
name|_position_set
modifier|*
name|s
decl_stmt|;
name|int
name|newline
decl_stmt|;
name|int
name|letter
decl_stmt|;
block|{
name|int
name|hash
init|=
literal|0
decl_stmt|;
name|int
name|constraint
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|newline
operator|=
name|newline
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|letter
operator|=
name|letter
condition|?
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|nelem
condition|;
operator|++
name|i
control|)
name|hash
operator|^=
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
operator|+
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|constraint
expr_stmt|;
comment|/* Try to find a state that exactly matches the proposed one. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
operator|->
name|sindex
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|hash
operator|!=
name|r
operator|->
name|states
index|[
name|i
index|]
operator|.
name|hash
operator|||
name|s
operator|->
name|nelem
operator|!=
name|r
operator|->
name|states
index|[
name|i
index|]
operator|.
name|elems
operator|.
name|nelem
operator|||
name|newline
operator|!=
name|r
operator|->
name|states
index|[
name|i
index|]
operator|.
name|newline
operator|||
name|letter
operator|!=
name|r
operator|->
name|states
index|[
name|i
index|]
operator|.
name|letter
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|s
operator|->
name|nelem
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|s
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|constraint
operator|!=
name|r
operator|->
name|states
index|[
name|i
index|]
operator|.
name|elems
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|constraint
operator|||
name|s
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|index
operator|!=
name|r
operator|->
name|states
index|[
name|i
index|]
operator|.
name|elems
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|index
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|s
operator|->
name|nelem
condition|)
return|return
name|i
return|;
block|}
comment|/* We'll have to create a new state. */
name|REALLOC_IF_NECESSARY
argument_list|(
name|r
operator|->
name|states
argument_list|,
name|_dfa_state
argument_list|,
name|r
operator|->
name|salloc
argument_list|,
name|r
operator|->
name|sindex
argument_list|)
expr_stmt|;
name|r
operator|->
name|states
index|[
name|i
index|]
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
name|MALLOC
argument_list|(
name|r
operator|->
name|states
index|[
name|i
index|]
operator|.
name|elems
operator|.
name|elems
argument_list|,
name|_position
argument_list|,
name|s
operator|->
name|nelem
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|s
argument_list|,
operator|&
name|r
operator|->
name|states
index|[
name|i
index|]
operator|.
name|elems
argument_list|)
expr_stmt|;
name|r
operator|->
name|states
index|[
name|i
index|]
operator|.
name|newline
operator|=
name|newline
expr_stmt|;
name|r
operator|->
name|states
index|[
name|i
index|]
operator|.
name|letter
operator|=
name|letter
expr_stmt|;
name|r
operator|->
name|states
index|[
name|i
index|]
operator|.
name|backref
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|states
index|[
name|i
index|]
operator|.
name|constraint
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|states
index|[
name|i
index|]
operator|.
name|first_end
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|s
operator|->
name|nelem
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|r
operator|->
name|tokens
index|[
name|s
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|index
index|]
operator|<
literal|0
condition|)
block|{
name|constraint
operator|=
name|s
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|constraint
expr_stmt|;
if|if
condition|(
name|_SUCCEEDS_IN_CONTEXT
argument_list|(
name|constraint
argument_list|,
name|newline
argument_list|,
literal|0
argument_list|,
name|letter
argument_list|,
literal|0
argument_list|)
operator|||
name|_SUCCEEDS_IN_CONTEXT
argument_list|(
name|constraint
argument_list|,
name|newline
argument_list|,
literal|0
argument_list|,
name|letter
argument_list|,
literal|1
argument_list|)
operator|||
name|_SUCCEEDS_IN_CONTEXT
argument_list|(
name|constraint
argument_list|,
name|newline
argument_list|,
literal|1
argument_list|,
name|letter
argument_list|,
literal|0
argument_list|)
operator|||
name|_SUCCEEDS_IN_CONTEXT
argument_list|(
name|constraint
argument_list|,
name|newline
argument_list|,
literal|1
argument_list|,
name|letter
argument_list|,
literal|1
argument_list|)
condition|)
name|r
operator|->
name|states
index|[
name|i
index|]
operator|.
name|constraint
operator||=
name|constraint
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|->
name|states
index|[
name|i
index|]
operator|.
name|first_end
condition|)
name|r
operator|->
name|states
index|[
name|i
index|]
operator|.
name|first_end
operator|=
name|r
operator|->
name|tokens
index|[
name|s
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|index
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|tokens
index|[
name|s
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|index
index|]
operator|==
name|_BACKREF
condition|)
block|{
name|r
operator|->
name|states
index|[
name|i
index|]
operator|.
name|constraint
operator|=
name|_NO_CONSTRAINT
expr_stmt|;
name|r
operator|->
name|states
index|[
name|i
index|]
operator|.
name|backref
operator|=
literal|1
expr_stmt|;
block|}
operator|++
name|r
operator|->
name|sindex
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find the epsilon closure of a set of positions.  If any position of the set    contains a symbol that matches the empty string in some context, replace    that position with the elements of its follow labeled with an appropriate    constraint.  Repeat exhaustively until no funny positions are left.    S->elems must be large enough to hold the result. */
end_comment

begin_function
name|void
name|epsclosure
parameter_list|(
name|s
parameter_list|,
name|r
parameter_list|)
name|_position_set
modifier|*
name|s
decl_stmt|;
name|struct
name|regexp
modifier|*
name|r
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
modifier|*
name|visited
decl_stmt|;
name|_position
name|p
decl_stmt|,
name|old
decl_stmt|;
name|MALLOC
argument_list|(
name|visited
argument_list|,
name|int
argument_list|,
name|r
operator|->
name|tindex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
name|visited
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|nelem
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|r
operator|->
name|tokens
index|[
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
index|]
operator|>=
name|_NOTCHAR
operator|&&
name|r
operator|->
name|tokens
index|[
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
index|]
operator|!=
name|_BACKREF
operator|&&
name|r
operator|->
name|tokens
index|[
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
index|]
operator|<
name|_SET
condition|)
block|{
name|old
operator|=
name|s
operator|->
name|elems
index|[
name|i
index|]
expr_stmt|;
name|p
operator|.
name|constraint
operator|=
name|old
operator|.
name|constraint
expr_stmt|;
name|delete
argument_list|(
name|s
operator|->
name|elems
index|[
name|i
index|]
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|visited
index|[
name|old
operator|.
name|index
index|]
condition|)
block|{
operator|--
name|i
expr_stmt|;
continue|continue;
block|}
name|visited
index|[
name|old
operator|.
name|index
index|]
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|r
operator|->
name|tokens
index|[
name|old
operator|.
name|index
index|]
condition|)
block|{
case|case
name|_BEGLINE
case|:
name|p
operator|.
name|constraint
operator|&=
name|_BEGLINE_CONSTRAINT
expr_stmt|;
break|break;
case|case
name|_ENDLINE
case|:
name|p
operator|.
name|constraint
operator|&=
name|_ENDLINE_CONSTRAINT
expr_stmt|;
break|break;
case|case
name|_BEGWORD
case|:
name|p
operator|.
name|constraint
operator|&=
name|_BEGWORD_CONSTRAINT
expr_stmt|;
break|break;
case|case
name|_ENDWORD
case|:
name|p
operator|.
name|constraint
operator|&=
name|_ENDWORD_CONSTRAINT
expr_stmt|;
break|break;
case|case
name|_LIMWORD
case|:
name|p
operator|.
name|constraint
operator|&=
name|_LIMWORD_CONSTRAINT
expr_stmt|;
break|break;
case|case
name|_NOTLIMWORD
case|:
name|p
operator|.
name|constraint
operator|&=
name|_NOTLIMWORD_CONSTRAINT
expr_stmt|;
break|break;
default|default:
break|break;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|r
operator|->
name|follows
index|[
name|old
operator|.
name|index
index|]
operator|.
name|nelem
condition|;
operator|++
name|j
control|)
block|{
name|p
operator|.
name|index
operator|=
name|r
operator|->
name|follows
index|[
name|old
operator|.
name|index
index|]
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|index
expr_stmt|;
name|insert
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* Force rescan to start at the beginning. */
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform bottom-up analysis on the parse tree, computing various functions.    Note that at this point, we're pretending constructs like \< are real    characters rather than constraints on what can follow them.     Nullable:  A node is nullable if it is at the root of a regexp that can    match the empty string.    *  _EMPTY leaves are nullable.    * No other leaf is nullable.    * A _QMARK or _STAR node is nullable.    * A _PLUS node is nullable if its argument is nullable.    * A _CAT node is nullable if both its arguments are nullable.    * An _OR node is nullable if either argument is nullable.     Firstpos:  The firstpos of a node is the set of positions (nonempty leaves)    that could correspond to the first character of a string matching the    regexp rooted at the given node.    * _EMPTY leaves have empty firstpos.    * The firstpos of a nonempty leaf is that leaf itself.    * The firstpos of a _QMARK, _STAR, or _PLUS node is the firstpos of its      argument.    * The firstpos of a _CAT node is the firstpos of the left argument, union      the firstpos of the right if the left argument is nullable.    * The firstpos of an _OR node is the union of firstpos of each argument.     Lastpos:  The lastpos of a node is the set of positions that could    correspond to the last character of a string matching the regexp at    the given node.    * _EMPTY leaves have empty lastpos.    * The lastpos of a nonempty leaf is that leaf itself.    * The lastpos of a _QMARK, _STAR, or _PLUS node is the lastpos of its      argument.    * The lastpos of a _CAT node is the lastpos of its right argument, union      the lastpos of the left if the right argument is nullable.    * The lastpos of an _OR node is the union of the lastpos of each argument.     Follow:  The follow of a position is the set of positions that could    correspond to the character following a character matching the node in    a string matching the regexp.  At this point we consider special symbols    that match the empty string in some context to be just normal characters.    Later, if we find that a special symbol is in a follow set, we will    replace it with the elements of its follow, labeled with an appropriate    constraint.    * Every node in the firstpos of the argument of a _STAR or _PLUS node is in      the follow of every node in the lastpos.    * Every node in the firstpos of the second argument of a _CAT node is in      the follow of every node in the lastpos of the first argument.     Because of the postfix representation of the parse tree, the depth-first    analysis is conveniently done by a linear scan with the aid of a stack.    Sets are stored as arrays of the elements, obeying a stack-like allocation    scheme; the number of elements in each set deeper in the stack can be    used to determine the address of a particular set's array. */
end_comment

begin_function
name|void
name|reganalyze
parameter_list|(
name|r
parameter_list|,
name|searchflag
parameter_list|)
name|struct
name|regexp
modifier|*
name|r
decl_stmt|;
name|int
name|searchflag
decl_stmt|;
block|{
name|int
modifier|*
name|nullable
decl_stmt|;
comment|/* Nullable stack. */
name|int
modifier|*
name|nfirstpos
decl_stmt|;
comment|/* Element count stack for firstpos sets. */
name|_position
modifier|*
name|firstpos
decl_stmt|;
comment|/* Array where firstpos elements are stored. */
name|int
modifier|*
name|nlastpos
decl_stmt|;
comment|/* Element count stack for lastpos sets. */
name|_position
modifier|*
name|lastpos
decl_stmt|;
comment|/* Array where lastpos elements are stored. */
name|int
modifier|*
name|nalloc
decl_stmt|;
comment|/* Sizes of arrays allocated to follow sets. */
name|_position_set
name|tmp
decl_stmt|;
comment|/* Temporary set for merging sets. */
name|_position_set
name|merged
decl_stmt|;
comment|/* Result of merging sets. */
name|int
name|wants_newline
decl_stmt|;
comment|/* True if some position wants newline info. */
name|int
modifier|*
name|o_nullable
decl_stmt|;
name|int
modifier|*
name|o_nfirst
decl_stmt|,
modifier|*
name|o_nlast
decl_stmt|;
name|_position
modifier|*
name|o_firstpos
decl_stmt|,
modifier|*
name|o_lastpos
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|_position
modifier|*
name|pos
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"reganalyze:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|r
operator|->
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|r
operator|->
name|searchflag
operator|=
name|searchflag
expr_stmt|;
name|MALLOC
argument_list|(
name|nullable
argument_list|,
name|int
argument_list|,
name|r
operator|->
name|depth
argument_list|)
expr_stmt|;
name|o_nullable
operator|=
name|nullable
expr_stmt|;
name|MALLOC
argument_list|(
name|nfirstpos
argument_list|,
name|int
argument_list|,
name|r
operator|->
name|depth
argument_list|)
expr_stmt|;
name|o_nfirst
operator|=
name|nfirstpos
expr_stmt|;
name|MALLOC
argument_list|(
name|firstpos
argument_list|,
name|_position
argument_list|,
name|r
operator|->
name|nleaves
argument_list|)
expr_stmt|;
name|o_firstpos
operator|=
name|firstpos
operator|,
name|firstpos
operator|+=
name|r
operator|->
name|nleaves
expr_stmt|;
name|MALLOC
argument_list|(
name|nlastpos
argument_list|,
name|int
argument_list|,
name|r
operator|->
name|depth
argument_list|)
expr_stmt|;
name|o_nlast
operator|=
name|nlastpos
expr_stmt|;
name|MALLOC
argument_list|(
name|lastpos
argument_list|,
name|_position
argument_list|,
name|r
operator|->
name|nleaves
argument_list|)
expr_stmt|;
name|o_lastpos
operator|=
name|lastpos
operator|,
name|lastpos
operator|+=
name|r
operator|->
name|nleaves
expr_stmt|;
name|MALLOC
argument_list|(
name|nalloc
argument_list|,
name|int
argument_list|,
name|r
operator|->
name|tindex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
name|nalloc
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|MALLOC
argument_list|(
name|merged
operator|.
name|elems
argument_list|,
name|_position
argument_list|,
name|r
operator|->
name|nleaves
argument_list|)
expr_stmt|;
name|CALLOC
argument_list|(
name|r
operator|->
name|follows
argument_list|,
name|_position_set
argument_list|,
name|r
operator|->
name|tindex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
ifdef|#
directive|ifdef
name|DEBUG
block|{
comment|/* Nonsyntactic #ifdef goo... */
endif|#
directive|endif
switch|switch
condition|(
name|r
operator|->
name|tokens
index|[
name|i
index|]
condition|)
block|{
case|case
name|_EMPTY
case|:
comment|/* The empty set is nullable. */
operator|*
name|nullable
operator|++
operator|=
literal|1
expr_stmt|;
comment|/* The firstpos and lastpos of the empty leaf are both empty. */
operator|*
name|nfirstpos
operator|++
operator|=
operator|*
name|nlastpos
operator|++
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|_STAR
case|:
case|case
name|_PLUS
case|:
comment|/* Every element in the firstpos of the argument is in the follow 	   of every element in the lastpos. */
name|tmp
operator|.
name|nelem
operator|=
name|nfirstpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|tmp
operator|.
name|elems
operator|=
name|firstpos
expr_stmt|;
name|pos
operator|=
name|lastpos
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nlastpos
index|[
operator|-
literal|1
index|]
condition|;
operator|++
name|j
control|)
block|{
name|merge
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|r
operator|->
name|follows
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|,
operator|&
name|merged
argument_list|)
expr_stmt|;
name|REALLOC_IF_NECESSARY
argument_list|(
name|r
operator|->
name|follows
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
operator|.
name|elems
argument_list|,
name|_position
argument_list|,
name|nalloc
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|,
name|merged
operator|.
name|nelem
operator|-
literal|1
argument_list|)
expr_stmt|;
name|copy
argument_list|(
operator|&
name|merged
argument_list|,
operator|&
name|r
operator|->
name|follows
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|)
expr_stmt|;
block|}
case|case
name|_QMARK
case|:
comment|/* A _QMARK or _STAR node is automatically nullable. */
if|if
condition|(
name|r
operator|->
name|tokens
index|[
name|i
index|]
operator|!=
name|_PLUS
condition|)
name|nullable
index|[
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|_CAT
case|:
comment|/* Every element in the firstpos of the second argument is in the 	   follow of every element in the lastpos of the first argument. */
name|tmp
operator|.
name|nelem
operator|=
name|nfirstpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|tmp
operator|.
name|elems
operator|=
name|firstpos
expr_stmt|;
name|pos
operator|=
name|lastpos
operator|+
name|nlastpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nlastpos
index|[
operator|-
literal|2
index|]
condition|;
operator|++
name|j
control|)
block|{
name|merge
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|r
operator|->
name|follows
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|,
operator|&
name|merged
argument_list|)
expr_stmt|;
name|REALLOC_IF_NECESSARY
argument_list|(
name|r
operator|->
name|follows
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
operator|.
name|elems
argument_list|,
name|_position
argument_list|,
name|nalloc
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|,
name|merged
operator|.
name|nelem
operator|-
literal|1
argument_list|)
expr_stmt|;
name|copy
argument_list|(
operator|&
name|merged
argument_list|,
operator|&
name|r
operator|->
name|follows
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* The firstpos of a _CAT node is the firstpos of the first argument, 	   union that of the second argument if the first is nullable. */
if|if
condition|(
name|nullable
index|[
operator|-
literal|2
index|]
condition|)
name|nfirstpos
index|[
operator|-
literal|2
index|]
operator|+=
name|nfirstpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|firstpos
operator|+=
name|nfirstpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
operator|--
name|nfirstpos
expr_stmt|;
comment|/* The lastpos of a _CAT node is the lastpos of the second argument, 	   union that of the first argument if the second is nullable. */
if|if
condition|(
name|nullable
index|[
operator|-
literal|1
index|]
condition|)
name|nlastpos
index|[
operator|-
literal|2
index|]
operator|+=
name|nlastpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
else|else
block|{
name|pos
operator|=
name|lastpos
operator|+
name|nlastpos
index|[
operator|-
literal|2
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|nlastpos
index|[
operator|-
literal|1
index|]
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
name|pos
index|[
name|j
index|]
operator|=
name|lastpos
index|[
name|j
index|]
expr_stmt|;
name|lastpos
operator|+=
name|nlastpos
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|nlastpos
index|[
operator|-
literal|2
index|]
operator|=
name|nlastpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
operator|--
name|nlastpos
expr_stmt|;
comment|/* A _CAT node is nullable if both arguments are nullable. */
name|nullable
index|[
operator|-
literal|2
index|]
operator|=
name|nullable
index|[
operator|-
literal|1
index|]
operator|&&
name|nullable
index|[
operator|-
literal|2
index|]
expr_stmt|;
operator|--
name|nullable
expr_stmt|;
break|break;
case|case
name|_OR
case|:
comment|/* The firstpos is the union of the firstpos of each argument. */
name|nfirstpos
index|[
operator|-
literal|2
index|]
operator|+=
name|nfirstpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
operator|--
name|nfirstpos
expr_stmt|;
comment|/* The lastpos is the union of the lastpos of each argument. */
name|nlastpos
index|[
operator|-
literal|2
index|]
operator|+=
name|nlastpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
operator|--
name|nlastpos
expr_stmt|;
comment|/* An _OR node is nullable if either argument is nullable. */
name|nullable
index|[
operator|-
literal|2
index|]
operator|=
name|nullable
index|[
operator|-
literal|1
index|]
operator|||
name|nullable
index|[
operator|-
literal|2
index|]
expr_stmt|;
operator|--
name|nullable
expr_stmt|;
break|break;
default|default:
comment|/* Anything else is a nonempty position.  (Note that special 	   constructs like \< are treated as nonempty strings here; 	   an "epsilon closure" effectively makes them nullable later. 	   Backreferences have to get a real position so we can detect 	   transitions on them later.  But they are nullable. */
operator|*
name|nullable
operator|++
operator|=
name|r
operator|->
name|tokens
index|[
name|i
index|]
operator|==
name|_BACKREF
expr_stmt|;
comment|/* This position is in its own firstpos and lastpos. */
operator|*
name|nfirstpos
operator|++
operator|=
operator|*
name|nlastpos
operator|++
operator|=
literal|1
expr_stmt|;
operator|--
name|firstpos
operator|,
operator|--
name|lastpos
expr_stmt|;
name|firstpos
operator|->
name|index
operator|=
name|lastpos
operator|->
name|index
operator|=
name|i
expr_stmt|;
name|firstpos
operator|->
name|constraint
operator|=
name|lastpos
operator|->
name|constraint
operator|=
name|_NO_CONSTRAINT
expr_stmt|;
comment|/* Allocate the follow set for this position. */
name|nalloc
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|MALLOC
argument_list|(
name|r
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|elems
argument_list|,
name|_position
argument_list|,
name|nalloc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
comment|/* ... balance the above nonsyntactic #ifdef goo... */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"node %d:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|r
operator|->
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|nullable
index|[
operator|-
literal|1
index|]
condition|?
literal|" nullable: yes\n"
else|:
literal|" nullable: no\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" firstpos:"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|nfirstpos
index|[
operator|-
literal|1
index|]
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d:"
argument_list|,
name|firstpos
index|[
name|j
index|]
operator|.
name|index
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|r
operator|->
name|tokens
index|[
name|firstpos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n lastpos:"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|nlastpos
index|[
operator|-
literal|1
index|]
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d:"
argument_list|,
name|lastpos
index|[
name|j
index|]
operator|.
name|index
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|r
operator|->
name|tokens
index|[
name|lastpos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* For each follow set that is the follow set of a real position, replace      it with its epsilon closure. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|r
operator|->
name|tokens
index|[
name|i
index|]
operator|<
name|_NOTCHAR
operator|||
name|r
operator|->
name|tokens
index|[
name|i
index|]
operator|==
name|_BACKREF
operator|||
name|r
operator|->
name|tokens
index|[
name|i
index|]
operator|>=
name|_SET
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"follows(%d:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|r
operator|->
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"):"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|r
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|nelem
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d:"
argument_list|,
name|r
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|index
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|r
operator|->
name|tokens
index|[
name|r
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|copy
argument_list|(
operator|&
name|r
operator|->
name|follows
index|[
name|i
index|]
argument_list|,
operator|&
name|merged
argument_list|)
expr_stmt|;
name|epsclosure
argument_list|(
operator|&
name|merged
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|nelem
operator|<
name|merged
operator|.
name|nelem
condition|)
name|REALLOC
argument_list|(
name|r
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|elems
argument_list|,
name|_position
argument_list|,
name|merged
operator|.
name|nelem
argument_list|)
expr_stmt|;
name|copy
argument_list|(
operator|&
name|merged
argument_list|,
operator|&
name|r
operator|->
name|follows
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Get the epsilon closure of the firstpos of the regexp.  The result will      be the set of positions of state 0. */
name|merged
operator|.
name|nelem
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfirstpos
index|[
operator|-
literal|1
index|]
condition|;
operator|++
name|i
control|)
name|insert
argument_list|(
name|firstpos
index|[
name|i
index|]
argument_list|,
operator|&
name|merged
argument_list|)
expr_stmt|;
name|epsclosure
argument_list|(
operator|&
name|merged
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|/* Check if any of the positions of state 0 will want newline context. */
name|wants_newline
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|merged
operator|.
name|nelem
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|_PREV_NEWLINE_DEPENDENT
argument_list|(
name|merged
operator|.
name|elems
index|[
name|i
index|]
operator|.
name|constraint
argument_list|)
condition|)
name|wants_newline
operator|=
literal|1
expr_stmt|;
comment|/* Build the initial state. */
name|r
operator|->
name|salloc
operator|=
literal|1
expr_stmt|;
name|r
operator|->
name|sindex
operator|=
literal|0
expr_stmt|;
name|MALLOC
argument_list|(
name|r
operator|->
name|states
argument_list|,
name|_dfa_state
argument_list|,
name|r
operator|->
name|salloc
argument_list|)
expr_stmt|;
name|state_index
argument_list|(
name|r
argument_list|,
operator|&
name|merged
argument_list|,
name|wants_newline
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|o_nullable
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|o_nfirst
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|o_firstpos
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|o_nlast
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|o_lastpos
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nalloc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|merged
operator|.
name|elems
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find, for each character, the transition out of state s of r, and store    it in the appropriate slot of trans.     We divide the positions of s into groups (positions can appear in more    than one group).  Each group is labeled with a set of characters that    every position in the group matches (taking into account, if necessary,    preceding context information of s).  For each group, find the union    of the its elements' follows.  This set is the set of positions of the    new state.  For each character in the group's label, set the transition    on this character to be to a state corresponding to the set's positions,    and its associated backward context information, if necessary.     If we are building a searching matcher, we include the positions of state    0 in every state.     The collection of groups is constructed by building an equivalence-class    partition of the positions of s.     For each position, find the set of characters C that it matches.  Eliminate    any characters from C that fail on grounds of backward context.     Search through the groups, looking for a group whose label L has nonempty    intersection with C.  If L - C is nonempty, create a new group labeled    L - C and having the same positions as the current group, and set L to    the intersection of L and C.  Insert the position in this group, set    C = C - L, and resume scanning.     If after comparing with every group there are characters remaining in C,    create a new group labeled with the characters of C and insert this    position in that group. */
end_comment

begin_function
name|void
name|regstate
parameter_list|(
name|s
parameter_list|,
name|r
parameter_list|,
name|trans
parameter_list|)
name|int
name|s
decl_stmt|;
name|struct
name|regexp
modifier|*
name|r
decl_stmt|;
name|int
name|trans
index|[]
decl_stmt|;
block|{
name|_position_set
name|grps
index|[
name|_NOTCHAR
index|]
decl_stmt|;
comment|/* As many as will ever be needed. */
name|_charset
name|labels
index|[
name|_NOTCHAR
index|]
decl_stmt|;
comment|/* Labels corresponding to the groups. */
name|int
name|ngrps
init|=
literal|0
decl_stmt|;
comment|/* Number of groups actually used. */
name|_position
name|pos
decl_stmt|;
comment|/* Current position being considered. */
name|_charset
name|matches
decl_stmt|;
comment|/* Set of matching characters. */
name|int
name|matchesf
decl_stmt|;
comment|/* True if matches is nonempty. */
name|_charset
name|intersect
decl_stmt|;
comment|/* Intersection with some label set. */
name|int
name|intersectf
decl_stmt|;
comment|/* True if intersect is nonempty. */
name|_charset
name|leftovers
decl_stmt|;
comment|/* Stuff in the label that didn't match. */
name|int
name|leftoversf
decl_stmt|;
comment|/* True if leftovers is nonempty. */
specifier|static
name|_charset
name|letters
decl_stmt|;
comment|/* Set of characters considered letters. */
specifier|static
name|_charset
name|newline
decl_stmt|;
comment|/* Set of characters that aren't newline. */
name|_position_set
name|follows
decl_stmt|;
comment|/* Union of the follows of some group. */
name|_position_set
name|tmp
decl_stmt|;
comment|/* Temporary space for merging sets. */
name|int
name|state
decl_stmt|;
comment|/* New state. */
name|int
name|wants_newline
decl_stmt|;
comment|/* New state wants to know newline context. */
name|int
name|state_newline
decl_stmt|;
comment|/* New state on a newline transition. */
name|int
name|wants_letter
decl_stmt|;
comment|/* New state wants to know letter context. */
name|int
name|state_letter
decl_stmt|;
comment|/* New state on a letter transition. */
specifier|static
name|initialized
expr_stmt|;
comment|/* Flag for static initialization. */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
comment|/* Initialize the set of letters, if necessary. */
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|initialized
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_NOTCHAR
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|ISALNUM
argument_list|(
name|i
argument_list|)
condition|)
name|setbit
argument_list|(
name|i
argument_list|,
name|letters
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
literal|'\n'
argument_list|,
name|newline
argument_list|)
expr_stmt|;
block|}
name|zeroset
argument_list|(
name|matches
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
operator|->
name|states
index|[
name|s
index|]
operator|.
name|elems
operator|.
name|nelem
condition|;
operator|++
name|i
control|)
block|{
name|pos
operator|=
name|r
operator|->
name|states
index|[
name|s
index|]
operator|.
name|elems
operator|.
name|elems
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
operator|>=
literal|0
operator|&&
name|r
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
operator|<
name|_NOTCHAR
condition|)
name|setbit
argument_list|(
name|r
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
argument_list|,
name|matches
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
operator|>=
name|_SET
condition|)
name|copyset
argument_list|(
name|r
operator|->
name|charsets
index|[
name|r
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
operator|-
name|_SET
index|]
argument_list|,
name|matches
argument_list|)
expr_stmt|;
else|else
continue|continue;
comment|/* Some characters may need to be eliminated from matches because 	 they fail in the current context. */
if|if
condition|(
name|pos
operator|.
name|constraint
operator|!=
literal|0xFF
condition|)
block|{
if|if
condition|(
operator|!
name|_MATCHES_NEWLINE_CONTEXT
argument_list|(
name|pos
operator|.
name|constraint
argument_list|,
name|r
operator|->
name|states
index|[
name|s
index|]
operator|.
name|newline
argument_list|,
literal|1
argument_list|)
condition|)
name|clrbit
argument_list|(
literal|'\n'
argument_list|,
name|matches
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_MATCHES_NEWLINE_CONTEXT
argument_list|(
name|pos
operator|.
name|constraint
argument_list|,
name|r
operator|->
name|states
index|[
name|s
index|]
operator|.
name|newline
argument_list|,
literal|0
argument_list|)
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|_CHARSET_INTS
condition|;
operator|++
name|j
control|)
name|matches
index|[
name|j
index|]
operator|&=
name|newline
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|_MATCHES_LETTER_CONTEXT
argument_list|(
name|pos
operator|.
name|constraint
argument_list|,
name|r
operator|->
name|states
index|[
name|s
index|]
operator|.
name|letter
argument_list|,
literal|1
argument_list|)
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|_CHARSET_INTS
condition|;
operator|++
name|j
control|)
name|matches
index|[
name|j
index|]
operator|&=
operator|~
name|letters
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|_MATCHES_LETTER_CONTEXT
argument_list|(
name|pos
operator|.
name|constraint
argument_list|,
name|r
operator|->
name|states
index|[
name|s
index|]
operator|.
name|letter
argument_list|,
literal|0
argument_list|)
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|_CHARSET_INTS
condition|;
operator|++
name|j
control|)
name|matches
index|[
name|j
index|]
operator|&=
name|letters
index|[
name|j
index|]
expr_stmt|;
comment|/* If there are no characters left, there's no point in going on. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|_CHARSET_INTS
operator|&&
operator|!
name|matches
index|[
name|j
index|]
condition|;
operator|++
name|j
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|==
name|_CHARSET_INTS
condition|)
continue|continue;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ngrps
condition|;
operator|++
name|j
control|)
block|{
comment|/* If matches contains a single character only, and the current 	     group's label doesn't contain that character, go on to the 	     next group. */
if|if
condition|(
name|r
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
operator|>=
literal|0
operator|&&
name|r
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
operator|<
name|_NOTCHAR
operator|&&
operator|!
name|tstbit
argument_list|(
name|r
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
argument_list|,
name|labels
index|[
name|j
index|]
argument_list|)
condition|)
continue|continue;
comment|/* Check if this group's label has a nonempty intersection with 	     matches. */
name|intersectf
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|_CHARSET_INTS
condition|;
operator|++
name|k
control|)
operator|(
name|intersect
index|[
name|k
index|]
operator|=
name|matches
index|[
name|k
index|]
operator|&
name|labels
index|[
name|j
index|]
index|[
name|k
index|]
operator|)
condition|?
name|intersectf
operator|=
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|intersectf
condition|)
continue|continue;
comment|/* It does; now find the set differences both ways. */
name|leftoversf
operator|=
name|matchesf
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|_CHARSET_INTS
condition|;
operator|++
name|k
control|)
block|{
comment|/* Even an optimizing compiler can't know this for sure. */
name|int
name|match
init|=
name|matches
index|[
name|k
index|]
decl_stmt|,
name|label
init|=
name|labels
index|[
name|j
index|]
index|[
name|k
index|]
decl_stmt|;
operator|(
name|leftovers
index|[
name|k
index|]
operator|=
operator|~
name|match
operator|&
name|label
operator|)
condition|?
name|leftoversf
operator|=
literal|1
else|:
literal|0
expr_stmt|;
operator|(
name|matches
index|[
name|k
index|]
operator|=
name|match
operator|&
operator|~
name|label
operator|)
condition|?
name|matchesf
operator|=
literal|1
else|:
literal|0
expr_stmt|;
block|}
comment|/* If there were leftovers, create a new group labeled with them. */
if|if
condition|(
name|leftoversf
condition|)
block|{
name|copyset
argument_list|(
name|leftovers
argument_list|,
name|labels
index|[
name|ngrps
index|]
argument_list|)
expr_stmt|;
name|copyset
argument_list|(
name|intersect
argument_list|,
name|labels
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|grps
index|[
name|ngrps
index|]
operator|.
name|elems
argument_list|,
name|_position
argument_list|,
name|r
operator|->
name|nleaves
argument_list|)
expr_stmt|;
name|copy
argument_list|(
operator|&
name|grps
index|[
name|j
index|]
argument_list|,
operator|&
name|grps
index|[
name|ngrps
index|]
argument_list|)
expr_stmt|;
operator|++
name|ngrps
expr_stmt|;
block|}
comment|/* Put the position in the current group.  Note that there is no 	     reason to call insert() here. */
name|grps
index|[
name|j
index|]
operator|.
name|elems
index|[
name|grps
index|[
name|j
index|]
operator|.
name|nelem
operator|++
index|]
operator|=
name|pos
expr_stmt|;
comment|/* If every character matching the current position has been 	     accounted for, we're done. */
if|if
condition|(
operator|!
name|matchesf
condition|)
break|break;
block|}
comment|/* If we've passed the last group, and there are still characters 	 unaccounted for, then we'll have to create a new group. */
if|if
condition|(
name|j
operator|==
name|ngrps
condition|)
block|{
name|copyset
argument_list|(
name|matches
argument_list|,
name|labels
index|[
name|ngrps
index|]
argument_list|)
expr_stmt|;
name|zeroset
argument_list|(
name|matches
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|grps
index|[
name|ngrps
index|]
operator|.
name|elems
argument_list|,
name|_position
argument_list|,
name|r
operator|->
name|nleaves
argument_list|)
expr_stmt|;
name|grps
index|[
name|ngrps
index|]
operator|.
name|nelem
operator|=
literal|1
expr_stmt|;
name|grps
index|[
name|ngrps
index|]
operator|.
name|elems
index|[
literal|0
index|]
operator|=
name|pos
expr_stmt|;
operator|++
name|ngrps
expr_stmt|;
block|}
block|}
name|MALLOC
argument_list|(
name|follows
operator|.
name|elems
argument_list|,
name|_position
argument_list|,
name|r
operator|->
name|nleaves
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|tmp
operator|.
name|elems
argument_list|,
name|_position
argument_list|,
name|r
operator|->
name|nleaves
argument_list|)
expr_stmt|;
comment|/* If we are a searching matcher, the default transition is to a state      containing the positions of state 0, otherwise the default transition      is to fail miserably. */
if|if
condition|(
name|r
operator|->
name|searchflag
condition|)
block|{
name|wants_newline
operator|=
literal|0
expr_stmt|;
name|wants_letter
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
operator|->
name|states
index|[
literal|0
index|]
operator|.
name|elems
operator|.
name|nelem
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|_PREV_NEWLINE_DEPENDENT
argument_list|(
name|r
operator|->
name|states
index|[
literal|0
index|]
operator|.
name|elems
operator|.
name|elems
index|[
name|i
index|]
operator|.
name|constraint
argument_list|)
condition|)
name|wants_newline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|_PREV_LETTER_DEPENDENT
argument_list|(
name|r
operator|->
name|states
index|[
literal|0
index|]
operator|.
name|elems
operator|.
name|elems
index|[
name|i
index|]
operator|.
name|constraint
argument_list|)
condition|)
name|wants_letter
operator|=
literal|1
expr_stmt|;
block|}
name|copy
argument_list|(
operator|&
name|r
operator|->
name|states
index|[
literal|0
index|]
operator|.
name|elems
argument_list|,
operator|&
name|follows
argument_list|)
expr_stmt|;
name|state
operator|=
name|state_index
argument_list|(
name|r
argument_list|,
operator|&
name|follows
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wants_newline
condition|)
name|state_newline
operator|=
name|state_index
argument_list|(
name|r
argument_list|,
operator|&
name|follows
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|state_newline
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|wants_letter
condition|)
name|state_letter
operator|=
name|state_index
argument_list|(
name|r
argument_list|,
operator|&
name|follows
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|state_letter
operator|=
name|state
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_NOTCHAR
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|i
operator|==
literal|'\n'
condition|)
name|trans
index|[
name|i
index|]
operator|=
name|state_newline
expr_stmt|;
elseif|else
if|if
condition|(
name|ISALNUM
argument_list|(
name|i
argument_list|)
condition|)
name|trans
index|[
name|i
index|]
operator|=
name|state_letter
expr_stmt|;
else|else
name|trans
index|[
name|i
index|]
operator|=
name|state
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_NOTCHAR
condition|;
operator|++
name|i
control|)
name|trans
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngrps
condition|;
operator|++
name|i
control|)
block|{
name|follows
operator|.
name|nelem
operator|=
literal|0
expr_stmt|;
comment|/* Find the union of the follows of the positions of the group. 	 This is a hideously inefficient loop.  Fix it someday. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|grps
index|[
name|i
index|]
operator|.
name|nelem
condition|;
operator|++
name|j
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|r
operator|->
name|follows
index|[
name|grps
index|[
name|i
index|]
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|index
index|]
operator|.
name|nelem
condition|;
operator|++
name|k
control|)
name|insert
argument_list|(
name|r
operator|->
name|follows
index|[
name|grps
index|[
name|i
index|]
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|index
index|]
operator|.
name|elems
index|[
name|k
index|]
argument_list|,
operator|&
name|follows
argument_list|)
expr_stmt|;
comment|/* If we are building a searching matcher, throw in the positions 	 of state 0 as well. */
if|if
condition|(
name|r
operator|->
name|searchflag
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|r
operator|->
name|states
index|[
literal|0
index|]
operator|.
name|elems
operator|.
name|nelem
condition|;
operator|++
name|j
control|)
name|insert
argument_list|(
name|r
operator|->
name|states
index|[
literal|0
index|]
operator|.
name|elems
operator|.
name|elems
index|[
name|j
index|]
argument_list|,
operator|&
name|follows
argument_list|)
expr_stmt|;
comment|/* Find out if the new state will want any context information. */
name|wants_newline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tstbit
argument_list|(
literal|'\n'
argument_list|,
name|labels
index|[
name|i
index|]
argument_list|)
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|follows
operator|.
name|nelem
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|_PREV_NEWLINE_DEPENDENT
argument_list|(
name|follows
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|constraint
argument_list|)
condition|)
name|wants_newline
operator|=
literal|1
expr_stmt|;
name|wants_letter
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|_CHARSET_INTS
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|labels
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|letters
index|[
name|j
index|]
condition|)
break|break;
if|if
condition|(
name|j
operator|<
name|_CHARSET_INTS
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|follows
operator|.
name|nelem
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|_PREV_LETTER_DEPENDENT
argument_list|(
name|follows
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|constraint
argument_list|)
condition|)
name|wants_letter
operator|=
literal|1
expr_stmt|;
comment|/* Find the state(s) corresponding to the union of the follows. */
name|state
operator|=
name|state_index
argument_list|(
name|r
argument_list|,
operator|&
name|follows
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wants_newline
condition|)
name|state_newline
operator|=
name|state_index
argument_list|(
name|r
argument_list|,
operator|&
name|follows
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|state_newline
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|wants_letter
condition|)
name|state_letter
operator|=
name|state_index
argument_list|(
name|r
argument_list|,
operator|&
name|follows
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|state_letter
operator|=
name|state
expr_stmt|;
comment|/* Set the transitions for each character in the current label. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|_CHARSET_INTS
condition|;
operator|++
name|j
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|INTBITS
condition|;
operator|++
name|k
control|)
if|if
condition|(
name|labels
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
literal|1
operator|<<
name|k
condition|)
block|{
name|int
name|c
init|=
name|j
operator|*
name|INTBITS
operator|+
name|k
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|trans
index|[
name|c
index|]
operator|=
name|state_newline
expr_stmt|;
elseif|else
if|if
condition|(
name|ISALNUM
argument_list|(
name|c
argument_list|)
condition|)
name|trans
index|[
name|c
index|]
operator|=
name|state_letter
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
name|_NOTCHAR
condition|)
name|trans
index|[
name|c
index|]
operator|=
name|state
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngrps
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|grps
index|[
name|i
index|]
operator|.
name|elems
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|follows
operator|.
name|elems
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
operator|.
name|elems
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Some routines for manipulating a compiled regexp's transition tables.    Each state may or may not have a transition table; if it does, and it    is a non-accepting state, then r->trans[state] points to its table.    If it is an accepting state then r->fails[state] points to its table.    If it has no table at all, then r->trans[state] is NULL.    TODO: Improve this comment, get rid of the unnecessary redundancy. */
end_comment

begin_function
specifier|static
name|void
name|build_state
parameter_list|(
name|s
parameter_list|,
name|r
parameter_list|)
name|int
name|s
decl_stmt|;
name|struct
name|regexp
modifier|*
name|r
decl_stmt|;
block|{
name|int
modifier|*
name|trans
decl_stmt|;
comment|/* The new transition table. */
name|int
name|i
decl_stmt|;
comment|/* Set an upper limit on the number of transition tables that will ever      exist at once.  1024 is arbitrary.  The idea is that the frequently      used transition tables will be quickly rebuilt, whereas the ones that      were only needed once or twice will be cleared away. */
if|if
condition|(
name|r
operator|->
name|trcount
operator|>=
literal|1024
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
operator|->
name|tralloc
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|r
operator|->
name|trans
index|[
name|i
index|]
condition|)
block|{
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|r
operator|->
name|trans
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|r
operator|->
name|trans
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|fails
index|[
name|i
index|]
condition|)
block|{
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|r
operator|->
name|fails
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|r
operator|->
name|fails
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|r
operator|->
name|trcount
operator|=
literal|0
expr_stmt|;
block|}
operator|++
name|r
operator|->
name|trcount
expr_stmt|;
comment|/* Set up the success bits for this state. */
name|r
operator|->
name|success
index|[
name|s
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ACCEPTS_IN_CONTEXT
argument_list|(
name|r
operator|->
name|states
index|[
name|s
index|]
operator|.
name|newline
argument_list|,
literal|1
argument_list|,
name|r
operator|->
name|states
index|[
name|s
index|]
operator|.
name|letter
argument_list|,
literal|0
argument_list|,
name|s
argument_list|,
operator|*
name|r
argument_list|)
condition|)
name|r
operator|->
name|success
index|[
name|s
index|]
operator||=
literal|4
expr_stmt|;
if|if
condition|(
name|ACCEPTS_IN_CONTEXT
argument_list|(
name|r
operator|->
name|states
index|[
name|s
index|]
operator|.
name|newline
argument_list|,
literal|0
argument_list|,
name|r
operator|->
name|states
index|[
name|s
index|]
operator|.
name|letter
argument_list|,
literal|1
argument_list|,
name|s
argument_list|,
operator|*
name|r
argument_list|)
condition|)
name|r
operator|->
name|success
index|[
name|s
index|]
operator||=
literal|2
expr_stmt|;
if|if
condition|(
name|ACCEPTS_IN_CONTEXT
argument_list|(
name|r
operator|->
name|states
index|[
name|s
index|]
operator|.
name|newline
argument_list|,
literal|0
argument_list|,
name|r
operator|->
name|states
index|[
name|s
index|]
operator|.
name|letter
argument_list|,
literal|0
argument_list|,
name|s
argument_list|,
operator|*
name|r
argument_list|)
condition|)
name|r
operator|->
name|success
index|[
name|s
index|]
operator||=
literal|1
expr_stmt|;
name|MALLOC
argument_list|(
name|trans
argument_list|,
name|int
argument_list|,
name|_NOTCHAR
argument_list|)
expr_stmt|;
name|regstate
argument_list|(
name|s
argument_list|,
name|r
argument_list|,
name|trans
argument_list|)
expr_stmt|;
comment|/* Now go through the new transition table, and make sure that the trans      and fail arrays are allocated large enough to hold a pointer for the      largest state mentioned in the table. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_NOTCHAR
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|trans
index|[
name|i
index|]
operator|>=
name|r
operator|->
name|tralloc
condition|)
block|{
name|int
name|oldalloc
init|=
name|r
operator|->
name|tralloc
decl_stmt|;
while|while
condition|(
name|trans
index|[
name|i
index|]
operator|>=
name|r
operator|->
name|tralloc
condition|)
name|r
operator|->
name|tralloc
operator|*=
literal|2
expr_stmt|;
name|REALLOC
argument_list|(
name|r
operator|->
name|realtrans
argument_list|,
name|int
operator|*
argument_list|,
name|r
operator|->
name|tralloc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|r
operator|->
name|trans
operator|=
name|r
operator|->
name|realtrans
operator|+
literal|1
expr_stmt|;
name|REALLOC
argument_list|(
name|r
operator|->
name|fails
argument_list|,
name|int
operator|*
argument_list|,
name|r
operator|->
name|tralloc
argument_list|)
expr_stmt|;
name|REALLOC
argument_list|(
name|r
operator|->
name|success
argument_list|,
name|int
argument_list|,
name|r
operator|->
name|tralloc
argument_list|)
expr_stmt|;
name|REALLOC
argument_list|(
name|r
operator|->
name|newlines
argument_list|,
name|int
argument_list|,
name|r
operator|->
name|tralloc
argument_list|)
expr_stmt|;
while|while
condition|(
name|oldalloc
operator|<
name|r
operator|->
name|tralloc
condition|)
block|{
name|r
operator|->
name|trans
index|[
name|oldalloc
index|]
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|fails
index|[
name|oldalloc
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Keep the newline transition in a special place so we can use it as      a sentinel. */
name|r
operator|->
name|newlines
index|[
name|s
index|]
operator|=
name|trans
index|[
literal|'\n'
index|]
expr_stmt|;
name|trans
index|[
literal|'\n'
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ACCEPTING
argument_list|(
name|s
argument_list|,
operator|*
name|r
argument_list|)
condition|)
name|r
operator|->
name|fails
index|[
name|s
index|]
operator|=
name|trans
expr_stmt|;
else|else
name|r
operator|->
name|trans
index|[
name|s
index|]
operator|=
name|trans
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_state_zero
parameter_list|(
name|r
parameter_list|)
name|struct
name|regexp
modifier|*
name|r
decl_stmt|;
block|{
name|r
operator|->
name|tralloc
operator|=
literal|1
expr_stmt|;
name|r
operator|->
name|trcount
operator|=
literal|0
expr_stmt|;
name|CALLOC
argument_list|(
name|r
operator|->
name|realtrans
argument_list|,
name|int
operator|*
argument_list|,
name|r
operator|->
name|tralloc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|r
operator|->
name|trans
operator|=
name|r
operator|->
name|realtrans
operator|+
literal|1
expr_stmt|;
name|CALLOC
argument_list|(
name|r
operator|->
name|fails
argument_list|,
name|int
operator|*
argument_list|,
name|r
operator|->
name|tralloc
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|r
operator|->
name|success
argument_list|,
name|int
argument_list|,
name|r
operator|->
name|tralloc
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|r
operator|->
name|newlines
argument_list|,
name|int
argument_list|,
name|r
operator|->
name|tralloc
argument_list|)
expr_stmt|;
name|build_state
argument_list|(
literal|0
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Search through a buffer looking for a match to the given struct regexp.    Find the first occurrence of a string matching the regexp in the buffer,    and the shortest possible version thereof.  Return a pointer to the first    character after the match, or NULL if none is found.  Begin points to    the beginning of the buffer, and end points to the first character after    its end.  We store a newline in *end to act as a sentinel, so end had    better point somewhere valid.  Newline is a flag indicating whether to    allow newlines to be in the matching string.  If count is non-    NULL it points to a place we're supposed to increment every time we    see a newline.  Finally, if backref is non-NULL it points to a place    where we're supposed to store a 1 if backreferencing happened and the    match needs to be verified by a backtracking matcher.  Otherwise    we store a 0 in *backref. */
end_comment

begin_function
name|char
modifier|*
name|regexecute
parameter_list|(
name|r
parameter_list|,
name|begin
parameter_list|,
name|end
parameter_list|,
name|newline
parameter_list|,
name|count
parameter_list|,
name|backref
parameter_list|)
name|struct
name|regexp
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|begin
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|newline
decl_stmt|;
name|int
modifier|*
name|count
decl_stmt|;
name|int
modifier|*
name|backref
decl_stmt|;
block|{
specifier|register
name|s
operator|,
name|s1
operator|,
name|tmp
expr_stmt|;
comment|/* Current state. */
specifier|register
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Current input character. */
specifier|register
operator|*
operator|*
name|trans
operator|,
operator|*
name|t
expr_stmt|;
comment|/* Copy of r->trans so it can be optimized 				   into a register. */
specifier|static
name|sbit
index|[
name|_NOTCHAR
index|]
expr_stmt|;
comment|/* Table for anding with r->success. */
specifier|static
name|sbit_init
expr_stmt|;
if|if
condition|(
operator|!
name|sbit_init
condition|)
block|{
name|int
name|i
decl_stmt|;
name|sbit_init
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_NOTCHAR
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|i
operator|==
literal|'\n'
condition|)
name|sbit
index|[
name|i
index|]
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|ISALNUM
argument_list|(
name|i
argument_list|)
condition|)
name|sbit
index|[
name|i
index|]
operator|=
literal|2
expr_stmt|;
else|else
name|sbit
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|r
operator|->
name|tralloc
condition|)
name|build_state_zero
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|s
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|begin
expr_stmt|;
name|trans
operator|=
name|r
operator|->
name|trans
expr_stmt|;
operator|*
name|end
operator|=
literal|'\n'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* The dreaded inner loop. */
if|if
condition|(
name|t
operator|=
name|trans
index|[
name|s
index|]
condition|)
do|do
block|{
name|s1
operator|=
name|t
index|[
operator|*
name|p
operator|++
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|t
operator|=
name|trans
index|[
name|s1
index|]
operator|)
condition|)
goto|goto
name|last_was_s
goto|;
name|s
operator|=
name|t
index|[
operator|*
name|p
operator|++
index|]
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|=
name|trans
index|[
name|s
index|]
condition|)
do|;
goto|goto
name|last_was_s1
goto|;
name|last_was_s
label|:
name|tmp
operator|=
name|s
operator|,
name|s
operator|=
name|s1
operator|,
name|s1
operator|=
name|tmp
expr_stmt|;
name|last_was_s1
label|:
if|if
condition|(
name|s
operator|>=
literal|0
operator|&&
name|p
operator|<=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|end
operator|&&
name|r
operator|->
name|fails
index|[
name|s
index|]
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|success
index|[
name|s
index|]
operator|&
name|sbit
index|[
operator|*
name|p
index|]
condition|)
block|{
if|if
condition|(
name|backref
condition|)
if|if
condition|(
name|r
operator|->
name|states
index|[
name|s
index|]
operator|.
name|backref
condition|)
operator|*
name|backref
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|backref
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|p
return|;
block|}
name|s1
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|r
operator|->
name|fails
index|[
name|s
index|]
index|[
operator|*
name|p
operator|++
index|]
expr_stmt|;
continue|continue;
block|}
comment|/* If the previous character was a newline, count it. */
if|if
condition|(
name|count
operator|&&
operator|(
name|char
operator|*
operator|)
name|p
operator|<=
name|end
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
operator|++
operator|*
name|count
expr_stmt|;
comment|/* Check if we've run off the end of the buffer. */
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|p
operator|>=
name|end
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|s
operator|>=
literal|0
condition|)
block|{
name|build_state
argument_list|(
name|s
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|trans
operator|=
name|r
operator|->
name|trans
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|&&
name|newline
condition|)
block|{
name|s
operator|=
name|r
operator|->
name|newlines
index|[
name|s1
index|]
expr_stmt|;
continue|continue;
block|}
name|s
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the components of a regexp that the other routines don't    initialize for themselves. */
end_comment

begin_function
name|void
name|reginit
parameter_list|(
name|r
parameter_list|)
name|struct
name|regexp
modifier|*
name|r
decl_stmt|;
block|{
name|r
operator|->
name|calloc
operator|=
literal|1
expr_stmt|;
name|MALLOC
argument_list|(
name|r
operator|->
name|charsets
argument_list|,
name|_charset
argument_list|,
name|r
operator|->
name|calloc
argument_list|)
expr_stmt|;
name|r
operator|->
name|cindex
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|talloc
operator|=
literal|1
expr_stmt|;
name|MALLOC
argument_list|(
name|r
operator|->
name|tokens
argument_list|,
name|_token
argument_list|,
name|r
operator|->
name|talloc
argument_list|)
expr_stmt|;
name|r
operator|->
name|tindex
operator|=
name|r
operator|->
name|depth
operator|=
name|r
operator|->
name|nleaves
operator|=
name|r
operator|->
name|nregexps
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|searchflag
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|tralloc
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse and analyze a single string of the given length. */
end_comment

begin_function
name|void
name|regcompile
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|,
name|r
parameter_list|,
name|searchflag
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|regexp
modifier|*
name|r
decl_stmt|;
name|int
name|searchflag
decl_stmt|;
block|{
if|if
condition|(
name|case_fold
condition|)
comment|/* dummy folding in service of regmust() */
block|{
name|char
modifier|*
name|copy
decl_stmt|;
name|int
name|i
decl_stmt|;
name|copy
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|copy
condition|)
name|regerror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
comment|/* This is a complete kludge and could potentially break 	 \<letter> escapes . . . */
name|case_fold
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|ISUPPER
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
condition|)
name|copy
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|copy
index|[
name|i
index|]
operator|=
name|s
index|[
name|i
index|]
expr_stmt|;
name|reginit
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|mustn
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|must
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|regparse
argument_list|(
name|copy
argument_list|,
name|len
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|regmust
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|reganalyze
argument_list|(
name|r
argument_list|,
name|searchflag
argument_list|)
expr_stmt|;
name|case_fold
operator|=
literal|1
expr_stmt|;
name|reginit
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|regparse
argument_list|(
name|s
argument_list|,
name|len
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|reganalyze
argument_list|(
name|r
argument_list|,
name|searchflag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reginit
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|regparse
argument_list|(
name|s
argument_list|,
name|len
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|regmust
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|reganalyze
argument_list|(
name|r
argument_list|,
name|searchflag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free the storage held by the components of a regexp. */
end_comment

begin_function
name|void
name|regfree
parameter_list|(
name|r
parameter_list|)
name|struct
name|regexp
modifier|*
name|r
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|r
operator|->
name|charsets
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|r
operator|->
name|tokens
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
operator|->
name|sindex
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|r
operator|->
name|states
index|[
name|i
index|]
operator|.
name|elems
operator|.
name|elems
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|r
operator|->
name|states
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|r
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|elems
condition|)
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|r
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|elems
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|r
operator|->
name|follows
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|r
operator|->
name|tralloc
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|r
operator|->
name|trans
index|[
name|i
index|]
condition|)
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|r
operator|->
name|trans
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|fails
index|[
name|i
index|]
condition|)
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|r
operator|->
name|fails
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|r
operator|->
name|realtrans
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|r
operator|->
name|fails
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|r
operator|->
name|newlines
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Having found the postfix representation of the regular expression, try to find a long sequence of characters that must appear in any line containing the r.e. Finding a "longest" sequence is beyond the scope here; we take an easy way out and hope for the best. (Take "(ab|a)b"--please.)  We do a bottom-up calculation of sequences of characters that must appear in matches of r.e.'s represented by trees rooted at the nodes of the postfix representation: 	sequences that must appear at the left of the match ("left") 	sequences that must appear at the right of the match ("right") 	lists of sequences that must appear somewhere in the match ("in") 	sequences that must constitute the match ("is") When we get to the root of the tree, we use one of the longest of its calculated "in" sequences as our answer.  The sequence we find is returned in r->must (where "r" is the single argument passed to "regmust"); the length of the sequence is returned in r->mustn.  The sequences calculated for the various types of node (in pseudo ANSI c) are shown below.  "p" is the operand of unary operators (and the left-hand operand of binary operators); "q" is the right-hand operand of binary operators . "ZERO" means "a zero-length sequence" below.  Type	left		right		is		in ----	----		-----		--		-- char c	# c		# c		# c		# c  SET	ZERO		ZERO		ZERO		ZERO  STAR	ZERO		ZERO		ZERO		ZERO  QMARK	ZERO		ZERO		ZERO		ZERO  PLUS	p->left		p->right	ZERO		p->in  CAT	(p->is==ZERO)?	(q->is==ZERO)?	(p->is!=ZERO&&	p->in plus 	p->left :	q->right :	q->is!=ZERO) ?	q->in plus 	p->is##q->left	p->right##q->is	p->is##q->is :	p->right##q->left 					ZERO  OR	longest common	longest common	(do p->is and	substrings common to 	leading		trailing	q->is have same	p->in and q->in 	(sub)sequence	(sub)sequence	length and	 	of p->left	of p->right	content) ?	 	and q->left	and q->right	p->is : NULL	  If there's anything else we recognize in the tree, all four sequences get set to zero-length sequences.  If there's something we don't recognize in the tree, we just return a zero-length sequence.  Break ties in favor of infrequent letters (choosing 'zzz' in preference to 'aaa')?  And. . .is it here or someplace that we might ponder "optimizations" such as 	egrep 'psi|epsilon'	->	egrep 'psi' 	egrep 'pepsi|epsilon'	->	egrep 'epsi' 					(Yes, we now find "epsi" as a "string 					that must occur", but we might also 					simplify the *entire* r.e. being sought ) 	grep '[c]'		->	grep 'c' 	grep '(ab|a)b'		->	grep 'ab' 	grep 'ab*'		->	grep 'a' 	grep 'a*b'		->	grep 'b' There are several issues: 	Is optimization easy (enough)?  	Does optimization actually accomplish anything, 	or is the automaton you get from "psi|epsilon" (for example) 	the same as the one you get from "psi" (for example)?  	Are optimizable r.e.'s likely to be used in real-life situations 	(something like 'ab*' is probably unlikely; something like is 	'psi|epsilon' is likelier)? */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|icatalloc
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|)
name|char
modifier|*
name|old
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|result
decl_stmt|;
specifier|register
name|int
name|oldsize
decl_stmt|,
name|newsize
decl_stmt|;
name|newsize
operator|=
operator|(
name|new
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|NULL
condition|)
name|oldsize
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|newsize
operator|==
literal|0
condition|)
return|return
name|old
return|;
else|else
name|oldsize
operator|=
name|strlen
argument_list|(
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|NULL
condition|)
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|newsize
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|old
argument_list|,
name|oldsize
operator|+
name|newsize
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|NULL
operator|&&
name|new
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|result
operator|+
name|oldsize
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|icpyalloc
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
return|return
name|icatalloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|string
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|istrstr
parameter_list|(
name|lookin
parameter_list|,
name|lookfor
parameter_list|)
name|char
modifier|*
name|lookin
decl_stmt|;
specifier|register
name|char
modifier|*
name|lookfor
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|lookfor
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|lookin
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
operator|++
name|cp
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
name|lookfor
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|cp
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ifree
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|freelist
parameter_list|(
name|cpp
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|cpp
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cpp
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cpp
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
name|free
argument_list|(
name|cpp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cpp
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|enlist
parameter_list|(
name|cpp
parameter_list|,
name|new
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|cpp
decl_stmt|;
specifier|register
name|char
modifier|*
name|new
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|cpp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|new
operator|=
name|icpyalloc
argument_list|(
name|new
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|freelist
argument_list|(
name|cpp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|new
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	** Is there already something in the list that's new (or longer)? 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cpp
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|istrstr
argument_list|(
name|cpp
index|[
name|i
index|]
argument_list|,
name|new
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|new
argument_list|)
expr_stmt|;
return|return
name|cpp
return|;
block|}
comment|/* 	** Eliminate any obsoleted strings. 	*/
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cpp
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
if|if
condition|(
name|istrstr
argument_list|(
name|new
argument_list|,
name|cpp
index|[
name|j
index|]
argument_list|)
operator|==
name|NULL
condition|)
operator|++
name|j
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|cpp
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|i
operator|==
name|j
condition|)
break|break;
name|cpp
index|[
name|j
index|]
operator|=
name|cpp
index|[
name|i
index|]
expr_stmt|;
name|cpp
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	** Add the new string. 	*/
name|cpp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cpp
argument_list|,
operator|(
name|i
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
expr|*
name|cpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|cpp
index|[
name|i
index|]
operator|=
name|new
expr_stmt|;
name|cpp
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|cpp
return|;
block|}
end_function

begin_comment
comment|/* ** Given pointers to two strings, ** return a pointer to an allocated list of their distinct common substrings. ** Return NULL if something seems wild. */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|comsubs
parameter_list|(
name|left
parameter_list|,
name|right
parameter_list|)
name|char
modifier|*
name|left
decl_stmt|;
name|char
modifier|*
name|right
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|cpp
decl_stmt|;
specifier|register
name|char
modifier|*
name|lcp
decl_stmt|;
specifier|register
name|char
modifier|*
name|rcp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|left
operator|==
name|NULL
operator|||
name|right
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|cpp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|cpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|cpp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|lcp
operator|=
name|left
init|;
operator|*
name|lcp
operator|!=
literal|'\0'
condition|;
operator|++
name|lcp
control|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
name|rcp
operator|=
name|index
argument_list|(
name|right
argument_list|,
operator|*
name|lcp
argument_list|)
expr_stmt|;
while|while
condition|(
name|rcp
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|lcp
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|&&
name|lcp
index|[
name|i
index|]
operator|==
name|rcp
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|>
name|len
condition|)
name|len
operator|=
name|i
expr_stmt|;
name|rcp
operator|=
name|index
argument_list|(
name|rcp
operator|+
literal|1
argument_list|,
operator|*
name|lcp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|cpp
operator|=
name|enlist
argument_list|(
name|cpp
argument_list|,
name|lcp
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
block|}
return|return
name|cpp
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|addlists
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|)
name|char
modifier|*
modifier|*
name|old
decl_stmt|;
name|char
modifier|*
modifier|*
name|new
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|old
operator|==
name|NULL
operator|||
name|new
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|new
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
name|old
operator|=
name|enlist
argument_list|(
name|old
argument_list|,
name|new
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|new
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|NULL
condition|)
break|break;
block|}
return|return
name|old
return|;
block|}
end_function

begin_comment
comment|/* ** Given two lists of substrings, ** return a new list giving substrings common to both. */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|inboth
parameter_list|(
name|left
parameter_list|,
name|right
parameter_list|)
name|char
modifier|*
modifier|*
name|left
decl_stmt|;
name|char
modifier|*
modifier|*
name|right
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|both
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|temp
decl_stmt|;
specifier|register
name|int
name|lnum
decl_stmt|,
name|rnum
decl_stmt|;
if|if
condition|(
name|left
operator|==
name|NULL
operator|||
name|right
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|both
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|both
argument_list|)
expr_stmt|;
if|if
condition|(
name|both
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|both
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|lnum
operator|=
literal|0
init|;
name|left
index|[
name|lnum
index|]
operator|!=
name|NULL
condition|;
operator|++
name|lnum
control|)
block|{
for|for
control|(
name|rnum
operator|=
literal|0
init|;
name|right
index|[
name|rnum
index|]
operator|!=
name|NULL
condition|;
operator|++
name|rnum
control|)
block|{
name|temp
operator|=
name|comsubs
argument_list|(
name|left
index|[
name|lnum
index|]
argument_list|,
name|right
index|[
name|rnum
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
block|{
name|freelist
argument_list|(
name|both
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|both
operator|=
name|addlists
argument_list|(
name|both
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|freelist
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|both
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
block|}
return|return
name|both
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
modifier|*
name|in
decl_stmt|;
name|char
modifier|*
name|left
decl_stmt|;
name|char
modifier|*
name|right
decl_stmt|;
name|char
modifier|*
name|is
decl_stmt|;
block|}
name|must
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|resetmust
parameter_list|(
name|mp
parameter_list|)
specifier|register
name|must
modifier|*
name|mp
decl_stmt|;
block|{
name|mp
operator|->
name|left
index|[
literal|0
index|]
operator|=
name|mp
operator|->
name|right
index|[
literal|0
index|]
operator|=
name|mp
operator|->
name|is
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|freelist
argument_list|(
name|mp
operator|->
name|in
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|regmust
parameter_list|(
name|reg
parameter_list|)
specifier|register
name|struct
name|regexp
modifier|*
name|reg
decl_stmt|;
block|{
specifier|register
name|must
modifier|*
name|musts
decl_stmt|;
specifier|register
name|must
modifier|*
name|mp
decl_stmt|;
specifier|register
name|char
modifier|*
name|result
decl_stmt|;
specifier|register
name|int
name|ri
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|_token
name|t
decl_stmt|;
specifier|static
name|must
name|must0
decl_stmt|;
name|reg
operator|->
name|mustn
operator|=
literal|0
expr_stmt|;
name|reg
operator|->
name|must
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|musts
operator|=
operator|(
name|must
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|reg
operator|->
name|tindex
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|musts
argument_list|)
expr_stmt|;
if|if
condition|(
name|musts
operator|==
name|NULL
condition|)
return|return;
name|mp
operator|=
name|musts
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|reg
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
name|mp
index|[
name|i
index|]
operator|=
name|must0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|reg
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
block|{
name|mp
index|[
name|i
index|]
operator|.
name|in
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|mp
index|[
name|i
index|]
operator|.
name|in
argument_list|)
expr_stmt|;
name|mp
index|[
name|i
index|]
operator|.
name|left
operator|=
name|malloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|mp
index|[
name|i
index|]
operator|.
name|right
operator|=
name|malloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|mp
index|[
name|i
index|]
operator|.
name|is
operator|=
name|malloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
index|[
name|i
index|]
operator|.
name|in
operator|==
name|NULL
operator|||
name|mp
index|[
name|i
index|]
operator|.
name|left
operator|==
name|NULL
operator|||
name|mp
index|[
name|i
index|]
operator|.
name|right
operator|==
name|NULL
operator|||
name|mp
index|[
name|i
index|]
operator|.
name|is
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|mp
index|[
name|i
index|]
operator|.
name|left
index|[
literal|0
index|]
operator|=
name|mp
index|[
name|i
index|]
operator|.
name|right
index|[
literal|0
index|]
operator|=
name|mp
index|[
name|i
index|]
operator|.
name|is
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mp
index|[
name|i
index|]
operator|.
name|in
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|result
operator|=
literal|""
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"regmust:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reg
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|reg
operator|->
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|ri
operator|=
literal|0
init|;
name|ri
operator|<
name|reg
operator|->
name|tindex
condition|;
operator|++
name|ri
control|)
block|{
switch|switch
condition|(
name|t
operator|=
name|reg
operator|->
name|tokens
index|[
name|ri
index|]
condition|)
block|{
case|case
name|_ALLBEGLINE
case|:
case|case
name|_ALLENDLINE
case|:
case|case
name|_LPAREN
case|:
case|case
name|_RPAREN
case|:
goto|goto
name|done
goto|;
comment|/* "cannot happen" */
case|case
name|_EMPTY
case|:
case|case
name|_BEGLINE
case|:
case|case
name|_ENDLINE
case|:
case|case
name|_BEGWORD
case|:
case|case
name|_ENDWORD
case|:
case|case
name|_LIMWORD
case|:
case|case
name|_NOTLIMWORD
case|:
case|case
name|_BACKREF
case|:
name|resetmust
argument_list|(
name|mp
argument_list|)
expr_stmt|;
break|break;
case|case
name|_STAR
case|:
case|case
name|_QMARK
case|:
if|if
condition|(
name|mp
operator|<=
name|musts
condition|)
goto|goto
name|done
goto|;
comment|/* "cannot happen" */
operator|--
name|mp
expr_stmt|;
name|resetmust
argument_list|(
name|mp
argument_list|)
expr_stmt|;
break|break;
case|case
name|_OR
case|:
if|if
condition|(
name|mp
operator|<
operator|&
name|musts
index|[
literal|2
index|]
condition|)
goto|goto
name|done
goto|;
comment|/* "cannot happen" */
block|{
specifier|register
name|char
modifier|*
modifier|*
name|new
decl_stmt|;
specifier|register
name|must
modifier|*
name|lmp
decl_stmt|;
specifier|register
name|must
modifier|*
name|rmp
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|,
name|ln
decl_stmt|,
name|rn
decl_stmt|,
name|n
decl_stmt|;
name|rmp
operator|=
operator|--
name|mp
expr_stmt|;
name|lmp
operator|=
operator|--
name|mp
expr_stmt|;
comment|/* Guaranteed to be.  Unlikely, but. . . */
if|if
condition|(
name|strcmp
argument_list|(
name|lmp
operator|->
name|is
argument_list|,
name|rmp
operator|->
name|is
argument_list|)
operator|!=
literal|0
condition|)
name|lmp
operator|->
name|is
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Left side--easy */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lmp
operator|->
name|left
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|&&
name|lmp
operator|->
name|left
index|[
name|i
index|]
operator|==
name|rmp
operator|->
name|left
index|[
name|i
index|]
condition|)
operator|++
name|i
expr_stmt|;
name|lmp
operator|->
name|left
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Right side */
name|ln
operator|=
name|strlen
argument_list|(
name|lmp
operator|->
name|right
argument_list|)
expr_stmt|;
name|rn
operator|=
name|strlen
argument_list|(
name|rmp
operator|->
name|right
argument_list|)
expr_stmt|;
name|n
operator|=
name|ln
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|rn
condition|)
name|n
operator|=
name|rn
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|lmp
operator|->
name|right
index|[
name|ln
operator|-
name|i
operator|-
literal|1
index|]
operator|!=
name|rmp
operator|->
name|right
index|[
name|rn
operator|-
name|i
operator|-
literal|1
index|]
condition|)
break|break;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
name|lmp
operator|->
name|right
index|[
name|j
index|]
operator|=
name|lmp
operator|->
name|right
index|[
operator|(
name|ln
operator|-
name|i
operator|)
operator|+
name|j
index|]
expr_stmt|;
name|lmp
operator|->
name|right
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|new
operator|=
name|inboth
argument_list|(
name|lmp
operator|->
name|in
argument_list|,
name|rmp
operator|->
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|freelist
argument_list|(
name|lmp
operator|->
name|in
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lmp
operator|->
name|in
argument_list|)
expr_stmt|;
name|lmp
operator|->
name|in
operator|=
name|new
expr_stmt|;
block|}
break|break;
case|case
name|_PLUS
case|:
if|if
condition|(
name|mp
operator|<=
name|musts
condition|)
goto|goto
name|done
goto|;
comment|/* "cannot happen" */
operator|--
name|mp
expr_stmt|;
name|mp
operator|->
name|is
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|_END
case|:
if|if
condition|(
name|mp
operator|!=
operator|&
name|musts
index|[
literal|1
index|]
condition|)
goto|goto
name|done
goto|;
comment|/* "cannot happen" */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|musts
index|[
literal|0
index|]
operator|.
name|in
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|strlen
argument_list|(
name|musts
index|[
literal|0
index|]
operator|.
name|in
index|[
name|i
index|]
argument_list|)
operator|>
name|strlen
argument_list|(
name|result
argument_list|)
condition|)
name|result
operator|=
name|musts
index|[
literal|0
index|]
operator|.
name|in
index|[
name|i
index|]
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|_CAT
case|:
if|if
condition|(
name|mp
operator|<
operator|&
name|musts
index|[
literal|2
index|]
condition|)
goto|goto
name|done
goto|;
comment|/* "cannot happen" */
block|{
specifier|register
name|must
modifier|*
name|lmp
decl_stmt|;
specifier|register
name|must
modifier|*
name|rmp
decl_stmt|;
name|rmp
operator|=
operator|--
name|mp
expr_stmt|;
name|lmp
operator|=
operator|--
name|mp
expr_stmt|;
comment|/* 				** In.  Everything in left, plus everything in 				** right, plus catenation of 				** left's right and right's left. 				*/
name|lmp
operator|->
name|in
operator|=
name|addlists
argument_list|(
name|lmp
operator|->
name|in
argument_list|,
name|rmp
operator|->
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmp
operator|->
name|in
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|lmp
operator|->
name|right
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|rmp
operator|->
name|left
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|icpyalloc
argument_list|(
name|lmp
operator|->
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|tp
operator|=
name|icatalloc
argument_list|(
name|tp
argument_list|,
name|rmp
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|lmp
operator|->
name|in
operator|=
name|enlist
argument_list|(
name|lmp
operator|->
name|in
argument_list|,
name|tp
argument_list|,
name|strlen
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmp
operator|->
name|in
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* Left-hand */
if|if
condition|(
name|lmp
operator|->
name|is
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|lmp
operator|->
name|left
operator|=
name|icatalloc
argument_list|(
name|lmp
operator|->
name|left
argument_list|,
name|rmp
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmp
operator|->
name|left
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* Right-hand */
if|if
condition|(
name|rmp
operator|->
name|is
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|lmp
operator|->
name|right
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|lmp
operator|->
name|right
operator|=
name|icatalloc
argument_list|(
name|lmp
operator|->
name|right
argument_list|,
name|rmp
operator|->
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmp
operator|->
name|right
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
comment|/* Guaranteed to be */
if|if
condition|(
name|lmp
operator|->
name|is
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|rmp
operator|->
name|is
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|lmp
operator|->
name|is
operator|=
name|icatalloc
argument_list|(
name|lmp
operator|->
name|is
argument_list|,
name|rmp
operator|->
name|is
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmp
operator|->
name|is
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
block|}
else|else
name|lmp
operator|->
name|is
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|t
operator|<
name|_END
condition|)
block|{
comment|/* "cannot happen" */
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
literal|'\0'
condition|)
block|{
comment|/* not on *my* shift */
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|t
operator|>=
name|_SET
condition|)
block|{
comment|/* easy enough */
name|resetmust
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* plain character */
name|resetmust
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|is
index|[
literal|0
index|]
operator|=
name|mp
operator|->
name|left
index|[
literal|0
index|]
operator|=
name|mp
operator|->
name|right
index|[
literal|0
index|]
operator|=
name|t
expr_stmt|;
name|mp
operator|->
name|is
index|[
literal|1
index|]
operator|=
name|mp
operator|->
name|left
index|[
literal|1
index|]
operator|=
name|mp
operator|->
name|right
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mp
operator|->
name|in
operator|=
name|enlist
argument_list|(
name|mp
operator|->
name|in
argument_list|,
name|mp
operator|->
name|is
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|in
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" node: %d:"
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|reg
operator|->
name|tokens
index|[
name|ri
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n  in:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mp
operator|->
name|in
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" \"%s\""
argument_list|,
name|mp
operator|->
name|in
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n  is: \"%s\"\n"
argument_list|,
name|mp
operator|->
name|is
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  left: \"%s\"\n"
argument_list|,
name|mp
operator|->
name|left
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  right: \"%s\"\n"
argument_list|,
name|mp
operator|->
name|right
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|mp
expr_stmt|;
block|}
name|done
label|:
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|reg
operator|->
name|must
argument_list|,
name|result
argument_list|,
name|MUST_MAX
operator|-
literal|1
argument_list|)
expr_stmt|;
name|reg
operator|->
name|must
index|[
name|MUST_MAX
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|reg
operator|->
name|mustn
operator|=
name|strlen
argument_list|(
name|reg
operator|->
name|must
argument_list|)
expr_stmt|;
name|mp
operator|=
name|musts
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|reg
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
block|{
name|freelist
argument_list|(
name|mp
index|[
name|i
index|]
operator|.
name|in
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mp
index|[
name|i
index|]
operator|.
name|in
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|mp
index|[
name|i
index|]
operator|.
name|left
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|mp
index|[
name|i
index|]
operator|.
name|right
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|mp
index|[
name|i
index|]
operator|.
name|is
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

