begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dfa.c - deterministic extended regexp routines for GNU    Copyright 1988, 1998, 2000 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA */
end_comment

begin_comment
comment|/* Written June, 1988 by Mike Haertel    Modified July, 1988 by Arthur David Olson to assist BMG speedups  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|STDC_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|calloc
argument_list|()
decl_stmt|,
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_STRING_H
argument_list|)
operator|||
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SETLOCALE
end_if

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|HAVE_WCTYPE_H
operator|&&
name|defined
name|HAVE_WCHAR_H
operator|&&
name|defined
name|HAVE_MBRTOWC
end_if

begin_comment
comment|/* We can handle multibyte string.  */
end_comment

begin_define
define|#
directive|define
name|MBS_SUPPORT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MBS_SUPPORT
end_ifdef

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<wctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef

begin_comment
comment|/* use the same approach as regex.c */
end_comment

begin_undef
undef|#
directive|undef
name|assert
end_undef

begin_define
define|#
directive|define
name|assert
parameter_list|(
name|e
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|isgraph
end_ifndef

begin_define
define|#
directive|define
name|isgraph
parameter_list|(
name|C
parameter_list|)
value|(isprint(C)&& !isspace(C))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
operator|||
operator|(
operator|!
name|defined
argument_list|(
name|isascii
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_ISASCII
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|ISALPHA
parameter_list|(
name|C
parameter_list|)
value|isalpha(C)
end_define

begin_define
define|#
directive|define
name|ISUPPER
parameter_list|(
name|C
parameter_list|)
value|isupper(C)
end_define

begin_define
define|#
directive|define
name|ISLOWER
parameter_list|(
name|C
parameter_list|)
value|islower(C)
end_define

begin_define
define|#
directive|define
name|ISDIGIT
parameter_list|(
name|C
parameter_list|)
value|isdigit(C)
end_define

begin_define
define|#
directive|define
name|ISXDIGIT
parameter_list|(
name|C
parameter_list|)
value|isxdigit(C)
end_define

begin_define
define|#
directive|define
name|ISSPACE
parameter_list|(
name|C
parameter_list|)
value|isspace(C)
end_define

begin_define
define|#
directive|define
name|ISPUNCT
parameter_list|(
name|C
parameter_list|)
value|ispunct(C)
end_define

begin_define
define|#
directive|define
name|ISALNUM
parameter_list|(
name|C
parameter_list|)
value|isalnum(C)
end_define

begin_define
define|#
directive|define
name|ISPRINT
parameter_list|(
name|C
parameter_list|)
value|isprint(C)
end_define

begin_define
define|#
directive|define
name|ISGRAPH
parameter_list|(
name|C
parameter_list|)
value|isgraph(C)
end_define

begin_define
define|#
directive|define
name|ISCNTRL
parameter_list|(
name|C
parameter_list|)
value|iscntrl(C)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ISALPHA
parameter_list|(
name|C
parameter_list|)
value|(isascii(C)&& isalpha(C))
end_define

begin_define
define|#
directive|define
name|ISUPPER
parameter_list|(
name|C
parameter_list|)
value|(isascii(C)&& isupper(C))
end_define

begin_define
define|#
directive|define
name|ISLOWER
parameter_list|(
name|C
parameter_list|)
value|(isascii(C)&& islower(C))
end_define

begin_define
define|#
directive|define
name|ISDIGIT
parameter_list|(
name|C
parameter_list|)
value|(isascii(C)&& isdigit(C))
end_define

begin_define
define|#
directive|define
name|ISXDIGIT
parameter_list|(
name|C
parameter_list|)
value|(isascii(C)&& isxdigit(C))
end_define

begin_define
define|#
directive|define
name|ISSPACE
parameter_list|(
name|C
parameter_list|)
value|(isascii(C)&& isspace(C))
end_define

begin_define
define|#
directive|define
name|ISPUNCT
parameter_list|(
name|C
parameter_list|)
value|(isascii(C)&& ispunct(C))
end_define

begin_define
define|#
directive|define
name|ISALNUM
parameter_list|(
name|C
parameter_list|)
value|(isascii(C)&& isalnum(C))
end_define

begin_define
define|#
directive|define
name|ISPRINT
parameter_list|(
name|C
parameter_list|)
value|(isascii(C)&& isprint(C))
end_define

begin_define
define|#
directive|define
name|ISGRAPH
parameter_list|(
name|C
parameter_list|)
value|(isascii(C)&& isgraph(C))
end_define

begin_define
define|#
directive|define
name|ISCNTRL
parameter_list|(
name|C
parameter_list|)
value|(isascii(C)&& iscntrl(C))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISASCIIDIGIT differs from ISDIGIT, as follows:    - Its arg may be any int or unsigned int; it need not be an unsigned char.    - It's guaranteed to evaluate its argument exactly once.    - It's typically faster.    Posix 1003.2-1992 section 2.5.2.1 page 50 lines 1556-1558 says that    only '0' through '9' are digits.  Prefer ISASCIIDIGIT to ISDIGIT unless    it's important to use the locale's definition of `digit' even when the    host does not conform to Posix.  */
end_comment

begin_define
define|#
directive|define
name|ISASCIIDIGIT
parameter_list|(
name|c
parameter_list|)
value|((unsigned) (c) - '0'<= 9)
end_define

begin_comment
comment|/* If we (don't) have I18N.  */
end_comment

begin_comment
comment|/* glibc defines _ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBINTL_H
end_ifdef

begin_include
include|#
directive|include
file|<libintl.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_
end_ifndef

begin_define
define|#
directive|define
name|_
parameter_list|(
name|Str
parameter_list|)
value|gettext (Str)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_
parameter_list|(
name|Str
parameter_list|)
value|(Str)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"regex.h"
end_include

begin_include
include|#
directive|include
file|"dfa.h"
end_include

begin_include
include|#
directive|include
file|"hard-locale.h"
end_include

begin_comment
comment|/* HPUX, define those as macros in sys/param.h */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|setbit
end_ifdef

begin_undef
undef|#
directive|undef
name|setbit
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|clrbit
end_ifdef

begin_undef
undef|#
directive|undef
name|clrbit
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|dfamust
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dfa
operator|*
name|dfa
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|regexp
name|PARAMS
argument_list|(
operator|(
name|int
name|toplevel
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|ptr_t
name|xcalloc
parameter_list|(
name|size_t
name|n
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|ptr_t
name|r
init|=
name|calloc
argument_list|(
name|n
argument_list|,
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|dfaerror
argument_list|(
name|_
argument_list|(
literal|"Memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|ptr_t
name|xmalloc
parameter_list|(
name|size_t
name|n
parameter_list|)
block|{
name|ptr_t
name|r
init|=
name|malloc
argument_list|(
name|n
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|n
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|dfaerror
argument_list|(
name|_
argument_list|(
literal|"Memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|ptr_t
name|xrealloc
parameter_list|(
name|ptr_t
name|p
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|ptr_t
name|r
init|=
name|realloc
argument_list|(
name|p
argument_list|,
name|n
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|n
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|dfaerror
argument_list|(
name|_
argument_list|(
literal|"Memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CALLOC
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|,
name|n
parameter_list|)
value|((p) = (t *) xcalloc((size_t)(n), sizeof (t)))
end_define

begin_define
define|#
directive|define
name|MALLOC
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|,
name|n
parameter_list|)
value|((p) = (t *) xmalloc((n) * sizeof (t)))
end_define

begin_define
define|#
directive|define
name|REALLOC
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|,
name|n
parameter_list|)
value|((p) = (t *) xrealloc((ptr_t) (p), (n) * sizeof (t)))
end_define

begin_comment
comment|/* Reallocate an array of type t if nalloc is too small for index. */
end_comment

begin_define
define|#
directive|define
name|REALLOC_IF_NECESSARY
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|,
name|nalloc
parameter_list|,
name|index
parameter_list|)
define|\
value|if ((index)>= (nalloc))			  \     {						  \       do					  \ 	(nalloc) *= 2;				  \       while ((index)>= (nalloc));		  \       REALLOC(p, t, nalloc);			  \     }
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|prtok
parameter_list|(
name|token
name|t
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"END"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|<
name|NOTCHAR
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c"
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|EMPTY
case|:
name|s
operator|=
literal|"EMPTY"
expr_stmt|;
break|break;
case|case
name|BACKREF
case|:
name|s
operator|=
literal|"BACKREF"
expr_stmt|;
break|break;
case|case
name|BEGLINE
case|:
name|s
operator|=
literal|"BEGLINE"
expr_stmt|;
break|break;
case|case
name|ENDLINE
case|:
name|s
operator|=
literal|"ENDLINE"
expr_stmt|;
break|break;
case|case
name|BEGWORD
case|:
name|s
operator|=
literal|"BEGWORD"
expr_stmt|;
break|break;
case|case
name|ENDWORD
case|:
name|s
operator|=
literal|"ENDWORD"
expr_stmt|;
break|break;
case|case
name|LIMWORD
case|:
name|s
operator|=
literal|"LIMWORD"
expr_stmt|;
break|break;
case|case
name|NOTLIMWORD
case|:
name|s
operator|=
literal|"NOTLIMWORD"
expr_stmt|;
break|break;
case|case
name|QMARK
case|:
name|s
operator|=
literal|"QMARK"
expr_stmt|;
break|break;
case|case
name|STAR
case|:
name|s
operator|=
literal|"STAR"
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|s
operator|=
literal|"PLUS"
expr_stmt|;
break|break;
case|case
name|CAT
case|:
name|s
operator|=
literal|"CAT"
expr_stmt|;
break|break;
case|case
name|OR
case|:
name|s
operator|=
literal|"OR"
expr_stmt|;
break|break;
case|case
name|ORTOP
case|:
name|s
operator|=
literal|"ORTOP"
expr_stmt|;
break|break;
case|case
name|LPAREN
case|:
name|s
operator|=
literal|"LPAREN"
expr_stmt|;
break|break;
case|case
name|RPAREN
case|:
name|s
operator|=
literal|"RPAREN"
expr_stmt|;
break|break;
case|case
name|CRANGE
case|:
name|s
operator|=
literal|"CRANGE"
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
case|case
name|ANYCHAR
case|:
name|s
operator|=
literal|"ANYCHAR"
expr_stmt|;
break|break;
case|case
name|MBCSET
case|:
name|s
operator|=
literal|"MBCSET"
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* MBS_SUPPORT */
default|default:
name|s
operator|=
literal|"CSET"
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/* Stuff pertaining to charclasses. */
end_comment

begin_function
specifier|static
name|int
name|tstbit
parameter_list|(
name|unsigned
name|b
parameter_list|,
name|charclass
name|c
parameter_list|)
block|{
return|return
name|c
index|[
name|b
operator|/
name|INTBITS
index|]
operator|&
literal|1
operator|<<
name|b
operator|%
name|INTBITS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|setbit
parameter_list|(
name|unsigned
name|b
parameter_list|,
name|charclass
name|c
parameter_list|)
block|{
name|c
index|[
name|b
operator|/
name|INTBITS
index|]
operator||=
literal|1
operator|<<
name|b
operator|%
name|INTBITS
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clrbit
parameter_list|(
name|unsigned
name|b
parameter_list|,
name|charclass
name|c
parameter_list|)
block|{
name|c
index|[
name|b
operator|/
name|INTBITS
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|b
operator|%
name|INTBITS
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|copyset
parameter_list|(
name|charclass
name|src
parameter_list|,
name|charclass
name|dst
parameter_list|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
sizeof|sizeof
argument_list|(
name|charclass
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zeroset
parameter_list|(
name|charclass
name|s
parameter_list|)
block|{
name|memset
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|charclass
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|notset
parameter_list|(
name|charclass
name|s
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CHARCLASS_INTS
condition|;
operator|++
name|i
control|)
name|s
index|[
name|i
index|]
operator|=
operator|~
name|s
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|equal
parameter_list|(
name|charclass
name|s1
parameter_list|,
name|charclass
name|s2
parameter_list|)
block|{
return|return
name|memcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
sizeof|sizeof
argument_list|(
name|charclass
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* A pointer to the current dfa is kept here during parsing. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dfa
modifier|*
name|dfa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Find the index of charclass s in dfa->charclasses, or allocate a new charclass. */
end_comment

begin_function
specifier|static
name|int
name|charclass_index
parameter_list|(
name|charclass
name|s
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dfa
operator|->
name|cindex
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|equal
argument_list|(
name|s
argument_list|,
name|dfa
operator|->
name|charclasses
index|[
name|i
index|]
argument_list|)
condition|)
return|return
name|i
return|;
name|REALLOC_IF_NECESSARY
argument_list|(
name|dfa
operator|->
name|charclasses
argument_list|,
name|charclass
argument_list|,
name|dfa
operator|->
name|calloc
argument_list|,
name|dfa
operator|->
name|cindex
argument_list|)
expr_stmt|;
operator|++
name|dfa
operator|->
name|cindex
expr_stmt|;
name|copyset
argument_list|(
name|s
argument_list|,
name|dfa
operator|->
name|charclasses
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Syntax bits controlling the behavior of the lexical analyzer. */
end_comment

begin_decl_stmt
specifier|static
name|reg_syntax_t
name|syntax_bits
decl_stmt|,
name|syntax_bits_set
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag for case-folding letters into sets. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|case_fold
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* End-of-line byte in data.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|eolbyte
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Entry point to set syntax options. */
end_comment

begin_function
name|void
name|dfasyntax
parameter_list|(
name|reg_syntax_t
name|bits
parameter_list|,
name|int
name|fold
parameter_list|,
name|unsigned
name|char
name|eol
parameter_list|)
block|{
name|syntax_bits_set
operator|=
literal|1
expr_stmt|;
name|syntax_bits
operator|=
name|bits
expr_stmt|;
name|case_fold
operator|=
name|fold
expr_stmt|;
name|eolbyte
operator|=
name|eol
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like setbit, but if case is folded, set both cases of a letter.  */
end_comment

begin_function
specifier|static
name|void
name|setbit_case_fold
parameter_list|(
name|unsigned
name|b
parameter_list|,
name|charclass
name|c
parameter_list|)
block|{
name|setbit
argument_list|(
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|case_fold
condition|)
block|{
if|if
condition|(
name|ISUPPER
argument_list|(
name|b
argument_list|)
condition|)
name|setbit
argument_list|(
name|tolower
argument_list|(
name|b
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISLOWER
argument_list|(
name|b
argument_list|)
condition|)
name|setbit
argument_list|(
name|toupper
argument_list|(
name|b
argument_list|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Lexical analyzer.  All the dross that deals with the obnoxious    GNU Regex syntax bits is located here.  The poor, suffering    reader is referred to the GNU Regex documentation for the    meaning of the @#%!@#%^!@ syntax bits. */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|lexstart
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to beginning of input string. */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|lexptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to next input character. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lexleft
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of characters remaining. */
end_comment

begin_decl_stmt
specifier|static
name|token
name|lasttok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Previous token returned; initially END. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|laststart
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if we're separated from beginning or (, | 				   only by zero-width characters. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|parens
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of outstanding left parens. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|minrep
decl_stmt|,
name|maxrep
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Repeat counts for {m,n}. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hard_LC_COLLATE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if LC_COLLATE is hard.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MBS_SUPPORT
end_ifdef

begin_comment
comment|/* These variables are used only if (MB_CUR_MAX> 1).  */
end_comment

begin_decl_stmt
specifier|static
name|mbstate_t
name|mbs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mbstate for mbrlen().  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cur_mb_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Byte length of the current scanning 				   multibyte character.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cur_mb_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Byte index of the current scanning multibyte                                    character.  				   singlebyte character : cur_mb_index = 0 				   multibyte character 				       1st byte : cur_mb_index = 1 				       2nd byte : cur_mb_index = 2 				         ... 				       nth byte : cur_mb_index = n  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|mblen_buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Correspond to the input buffer in dfaexec().                                   Each element store the amount of remain                                   byte of corresponding multibyte character                                   in the input string.  A element's value                                   is 0 if corresponding character is a                                   singlebyte chracter.                                   e.g. input : 'a',<mb(0)>,<mb(1)>,<mb(2)>                                    mblen_buf :   0,       3,       2,       1                                */
end_comment

begin_decl_stmt
specifier|static
name|wchar_t
modifier|*
name|inputwcs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Wide character representation of input 				   string in dfaexec(). 				   The length of this array is same as 				   the length of input string(char array). 				   inputstring[i] is a single-byte char, 				   or 1st byte of a multibyte char. 				   And inputwcs[i] is the codepoint.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
specifier|const
modifier|*
name|buf_begin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* refference to begin in dfaexec().  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
specifier|const
modifier|*
name|buf_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* refference to end in dfaexec().  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MBS_SUPPORT  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MBS_SUPPORT
end_ifdef

begin_comment
comment|/* This function update cur_mb_len, and cur_mb_index.    p points current lexptr, len is the remaining buffer length.  */
end_comment

begin_function
specifier|static
name|void
name|update_mb_len_index
parameter_list|(
name|unsigned
name|char
specifier|const
modifier|*
name|p
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|/* If last character is a part of a multibyte character,      we update cur_mb_index.  */
if|if
condition|(
name|cur_mb_index
condition|)
name|cur_mb_index
operator|=
operator|(
name|cur_mb_index
operator|>=
name|cur_mb_len
operator|)
condition|?
literal|0
else|:
name|cur_mb_index
operator|+
literal|1
expr_stmt|;
comment|/* If last character is a single byte character, or the      last portion of a multibyte character, we check whether      next character is a multibyte character or not.  */
if|if
condition|(
operator|!
name|cur_mb_index
condition|)
block|{
name|cur_mb_len
operator|=
name|mbrlen
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_mb_len
operator|>
literal|1
condition|)
comment|/* It is a multibyte character. 	   cur_mb_len was already set by mbrlen().  */
name|cur_mb_index
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cur_mb_len
operator|<
literal|1
condition|)
comment|/* Invalid sequence.  We treat it as a singlebyte character. 	   cur_mb_index is aleady 0.  */
name|cur_mb_len
operator|=
literal|1
expr_stmt|;
comment|/* Otherwise, cur_mb_len == 1, it is a singlebyte character. 	 cur_mb_index is aleady 0.  */
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MBS_SUPPORT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MBS_SUPPORT
end_ifdef

begin_comment
comment|/* Note that characters become unsigned here. */
end_comment

begin_define
define|#
directive|define
name|FETCH
parameter_list|(
name|c
parameter_list|,
name|eoferr
parameter_list|)
define|\
value|{						\     if (! lexleft)				\      {						\ 	if (eoferr != 0)			\ 	  dfaerror (eoferr);			\ 	else					\ 	  return lasttok = END;			\       }						\     if (MB_CUR_MAX> 1)				\       update_mb_len_index(lexptr, lexleft);	\     (c) = (unsigned char) *lexptr++;		\     --lexleft;					\   }
end_define

begin_comment
comment|/* This function fetch a wide character, and update cur_mb_len,    used only if the current locale is a multibyte environment.  */
end_comment

begin_function
specifier|static
name|wint_t
name|fetch_wc
parameter_list|(
name|char
specifier|const
modifier|*
name|eoferr
parameter_list|)
block|{
name|wchar_t
name|wc
decl_stmt|;
if|if
condition|(
operator|!
name|lexleft
condition|)
block|{
if|if
condition|(
name|eoferr
operator|!=
literal|0
condition|)
name|dfaerror
argument_list|(
name|eoferr
argument_list|)
expr_stmt|;
else|else
return|return
name|WEOF
return|;
block|}
name|cur_mb_len
operator|=
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|lexptr
argument_list|,
name|lexleft
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_mb_len
operator|<=
literal|0
condition|)
block|{
name|cur_mb_len
operator|=
literal|1
expr_stmt|;
name|wc
operator|=
operator|*
name|lexptr
expr_stmt|;
block|}
name|lexptr
operator|+=
name|cur_mb_len
expr_stmt|;
name|lexleft
operator|-=
name|cur_mb_len
expr_stmt|;
return|return
name|wc
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Note that characters become unsigned here. */
end_comment

begin_define
define|#
directive|define
name|FETCH
parameter_list|(
name|c
parameter_list|,
name|eoferr
parameter_list|)
define|\
value|{			   	      \     if (! lexleft)	   	      \       {				      \ 	if (eoferr != 0)	      \ 	  dfaerror (eoferr);	      \ 	else		   	      \ 	  return lasttok = END;	      \       }				      \     (c) = (unsigned char) *lexptr++;  \     --lexleft;		   	      \   }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MBS_SUPPORT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MBS_SUPPORT
end_ifdef

begin_comment
comment|/* Multibyte character handling sub-routin for lex.    This function  parse a bracket expression and build a struct    mb_char_classes.  */
end_comment

begin_function
specifier|static
name|void
name|parse_bracket_exp_mb
parameter_list|()
block|{
name|wint_t
name|wc
decl_stmt|,
name|wc1
decl_stmt|,
name|wc2
decl_stmt|;
comment|/* Work area to build a mb_char_classes.  */
name|struct
name|mb_char_classes
modifier|*
name|work_mbc
decl_stmt|;
name|int
name|chars_al
decl_stmt|,
name|range_sts_al
decl_stmt|,
name|range_ends_al
decl_stmt|,
name|ch_classes_al
decl_stmt|,
name|equivs_al
decl_stmt|,
name|coll_elems_al
decl_stmt|;
name|REALLOC_IF_NECESSARY
argument_list|(
name|dfa
operator|->
name|mbcsets
argument_list|,
expr|struct
name|mb_char_classes
argument_list|,
name|dfa
operator|->
name|mbcsets_alloc
argument_list|,
name|dfa
operator|->
name|nmbcsets
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* dfa->multibyte_prop[] hold the index of dfa->mbcsets.      We will update dfa->multibyte_prop in addtok(), because we can't      decide the index in dfa->tokens[].  */
comment|/* Initialize work are */
name|work_mbc
operator|=
operator|&
operator|(
name|dfa
operator|->
name|mbcsets
index|[
name|dfa
operator|->
name|nmbcsets
operator|++
index|]
operator|)
expr_stmt|;
name|chars_al
operator|=
literal|1
expr_stmt|;
name|range_sts_al
operator|=
name|range_ends_al
operator|=
literal|0
expr_stmt|;
name|ch_classes_al
operator|=
name|equivs_al
operator|=
name|coll_elems_al
operator|=
literal|0
expr_stmt|;
name|MALLOC
argument_list|(
name|work_mbc
operator|->
name|chars
argument_list|,
name|wchar_t
argument_list|,
name|chars_al
argument_list|)
expr_stmt|;
name|work_mbc
operator|->
name|nchars
operator|=
name|work_mbc
operator|->
name|nranges
operator|=
name|work_mbc
operator|->
name|nch_classes
operator|=
literal|0
expr_stmt|;
name|work_mbc
operator|->
name|nequivs
operator|=
name|work_mbc
operator|->
name|ncoll_elems
operator|=
literal|0
expr_stmt|;
name|work_mbc
operator|->
name|chars
operator|=
name|work_mbc
operator|->
name|ch_classes
operator|=
name|NULL
expr_stmt|;
name|work_mbc
operator|->
name|range_sts
operator|=
name|work_mbc
operator|->
name|range_ends
operator|=
name|NULL
expr_stmt|;
name|work_mbc
operator|->
name|equivs
operator|=
name|work_mbc
operator|->
name|coll_elems
operator|=
name|NULL
expr_stmt|;
name|wc
operator|=
name|fetch_wc
argument_list|(
name|_
argument_list|(
literal|"Unbalanced ["
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc
operator|==
literal|L'
expr|^'
condition|)
block|{
name|wc
operator|=
name|fetch_wc
argument_list|(
name|_
argument_list|(
literal|"Unbalanced ["
argument_list|)
argument_list|)
expr_stmt|;
name|work_mbc
operator|->
name|invert
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|work_mbc
operator|->
name|invert
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|wc1
operator|=
name|WEOF
expr_stmt|;
comment|/* mark wc1 is not initialized".  */
comment|/* Note that if we're looking at some other [:...:] construct, 	 we just treat it as a bunch of ordinary characters.  We can do 	 this because we assume regex has checked for syntax errors before 	 dfa is ever called. */
if|if
condition|(
name|wc
operator|==
literal|L'
expr|['
operator|&&
operator|(
name|syntax_bits
operator|&
name|RE_CHAR_CLASSES
operator|)
condition|)
block|{
define|#
directive|define
name|BRACKET_BUFFER_SIZE
value|128
name|char
name|str
index|[
name|BRACKET_BUFFER_SIZE
index|]
decl_stmt|;
name|wc1
operator|=
name|wc
expr_stmt|;
name|wc
operator|=
name|fetch_wc
argument_list|(
name|_
argument_list|(
literal|"Unbalanced ["
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If pattern contains `[[:', `[[.', or `[[='.  */
if|if
condition|(
name|cur_mb_len
operator|==
literal|1
operator|&&
operator|(
name|wc
operator|==
literal|L'
expr|:'
operator|||
name|wc
operator|==
literal|L'
expr|.'
operator|||
name|wc
operator|==
literal|L'
expr|='
operator|)
condition|)
block|{
name|unsigned
name|char
name|c
decl_stmt|;
name|unsigned
name|char
name|delim
init|=
operator|(
name|unsigned
name|char
operator|)
name|wc
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|lexleft
condition|)
name|dfaerror
argument_list|(
name|_
argument_list|(
literal|"Unbalanced ["
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|lexptr
operator|++
expr_stmt|;
operator|--
name|lexleft
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|delim
operator|&&
operator|*
name|lexptr
operator|==
literal|']'
operator|)
operator|||
name|lexleft
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|len
operator|<
name|BRACKET_BUFFER_SIZE
condition|)
name|str
index|[
name|len
operator|++
index|]
operator|=
name|c
expr_stmt|;
else|else
comment|/* This is in any case an invalid class name.  */
name|str
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|str
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|lexleft
operator|==
literal|0
condition|)
block|{
name|REALLOC_IF_NECESSARY
argument_list|(
name|work_mbc
operator|->
name|chars
argument_list|,
name|wchar_t
argument_list|,
name|chars_al
argument_list|,
name|work_mbc
operator|->
name|nchars
operator|+
literal|2
argument_list|)
expr_stmt|;
name|work_mbc
operator|->
name|chars
index|[
name|work_mbc
operator|->
name|nchars
operator|++
index|]
operator|=
literal|L'
expr|['
expr_stmt|;
name|work_mbc
operator|->
name|chars
index|[
name|work_mbc
operator|->
name|nchars
operator|++
index|]
operator|=
name|delim
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|--
name|lexleft
operator|,
operator|*
name|lexptr
operator|++
operator|!=
literal|']'
condition|)
name|dfaerror
argument_list|(
name|_
argument_list|(
literal|"Unbalanced ["
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|delim
operator|==
literal|':'
condition|)
comment|/* build character class.  */
block|{
name|wctype_t
name|wt
decl_stmt|;
comment|/* Query the character class as wctype_t.  */
name|wt
operator|=
name|wctype
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch_classes_al
operator|==
literal|0
condition|)
name|MALLOC
argument_list|(
name|work_mbc
operator|->
name|ch_classes
argument_list|,
name|wchar_t
argument_list|,
operator|++
name|ch_classes_al
argument_list|)
expr_stmt|;
name|REALLOC_IF_NECESSARY
argument_list|(
name|work_mbc
operator|->
name|ch_classes
argument_list|,
name|wctype_t
argument_list|,
name|ch_classes_al
argument_list|,
name|work_mbc
operator|->
name|nch_classes
operator|+
literal|1
argument_list|)
expr_stmt|;
name|work_mbc
operator|->
name|ch_classes
index|[
name|work_mbc
operator|->
name|nch_classes
operator|++
index|]
operator|=
name|wt
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|delim
operator|==
literal|'='
operator|||
name|delim
operator|==
literal|'.'
condition|)
block|{
name|char
modifier|*
name|elem
decl_stmt|;
name|MALLOC
argument_list|(
name|elem
argument_list|,
name|char
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|elem
argument_list|,
name|str
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|delim
operator|==
literal|'='
condition|)
comment|/* build equivalent class.  */
block|{
if|if
condition|(
name|equivs_al
operator|==
literal|0
condition|)
name|MALLOC
argument_list|(
name|work_mbc
operator|->
name|equivs
argument_list|,
name|char
operator|*
argument_list|,
operator|++
name|equivs_al
argument_list|)
expr_stmt|;
name|REALLOC_IF_NECESSARY
argument_list|(
name|work_mbc
operator|->
name|equivs
argument_list|,
name|char
operator|*
argument_list|,
name|equivs_al
argument_list|,
name|work_mbc
operator|->
name|nequivs
operator|+
literal|1
argument_list|)
expr_stmt|;
name|work_mbc
operator|->
name|equivs
index|[
name|work_mbc
operator|->
name|nequivs
operator|++
index|]
operator|=
name|elem
expr_stmt|;
block|}
if|if
condition|(
name|delim
operator|==
literal|'.'
condition|)
comment|/* build collating element.  */
block|{
if|if
condition|(
name|coll_elems_al
operator|==
literal|0
condition|)
name|MALLOC
argument_list|(
name|work_mbc
operator|->
name|coll_elems
argument_list|,
name|char
operator|*
argument_list|,
operator|++
name|coll_elems_al
argument_list|)
expr_stmt|;
name|REALLOC_IF_NECESSARY
argument_list|(
name|work_mbc
operator|->
name|coll_elems
argument_list|,
name|char
operator|*
argument_list|,
name|coll_elems_al
argument_list|,
name|work_mbc
operator|->
name|ncoll_elems
operator|+
literal|1
argument_list|)
expr_stmt|;
name|work_mbc
operator|->
name|coll_elems
index|[
name|work_mbc
operator|->
name|ncoll_elems
operator|++
index|]
operator|=
name|elem
expr_stmt|;
block|}
block|}
name|wc1
operator|=
name|wc
operator|=
name|WEOF
expr_stmt|;
block|}
else|else
comment|/* We treat '[' as a normal character here.  */
block|{
name|wc2
operator|=
name|wc1
expr_stmt|;
name|wc1
operator|=
name|wc
expr_stmt|;
name|wc
operator|=
name|wc2
expr_stmt|;
comment|/* swap */
block|}
block|}
else|else
block|{
if|if
condition|(
name|wc
operator|==
literal|L'
expr|\\'
operator|&&
operator|(
name|syntax_bits
operator|&
name|RE_BACKSLASH_ESCAPE_IN_LISTS
operator|)
condition|)
name|wc
operator|=
name|fetch_wc
argument_list|(
operator|(
literal|"Unbalanced ["
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wc1
operator|==
name|WEOF
condition|)
name|wc1
operator|=
name|fetch_wc
argument_list|(
name|_
argument_list|(
literal|"Unbalanced ["
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc1
operator|==
literal|L'
expr|-'
condition|)
comment|/* build range characters.  */
block|{
name|wc2
operator|=
name|fetch_wc
argument_list|(
name|_
argument_list|(
literal|"Unbalanced ["
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc2
operator|==
literal|L'
expr|]'
condition|)
block|{
comment|/* In the case [x-], the - is an ordinary hyphen, 		 which is left in c1, the lookahead character. */
name|lexptr
operator|-=
name|cur_mb_len
expr_stmt|;
name|lexleft
operator|+=
name|cur_mb_len
expr_stmt|;
name|wc2
operator|=
name|wc
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wc2
operator|==
literal|L'
expr|\\'
operator|&&
operator|(
name|syntax_bits
operator|&
name|RE_BACKSLASH_ESCAPE_IN_LISTS
operator|)
condition|)
name|wc2
operator|=
name|fetch_wc
argument_list|(
name|_
argument_list|(
literal|"Unbalanced ["
argument_list|)
argument_list|)
expr_stmt|;
name|wc1
operator|=
name|fetch_wc
argument_list|(
name|_
argument_list|(
literal|"Unbalanced ["
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|range_sts_al
operator|==
literal|0
condition|)
block|{
name|MALLOC
argument_list|(
name|work_mbc
operator|->
name|range_sts
argument_list|,
name|wchar_t
argument_list|,
operator|++
name|range_sts_al
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|work_mbc
operator|->
name|range_ends
argument_list|,
name|wchar_t
argument_list|,
operator|++
name|range_ends_al
argument_list|)
expr_stmt|;
block|}
name|REALLOC_IF_NECESSARY
argument_list|(
name|work_mbc
operator|->
name|range_sts
argument_list|,
name|wchar_t
argument_list|,
name|range_sts_al
argument_list|,
name|work_mbc
operator|->
name|nranges
operator|+
literal|1
argument_list|)
expr_stmt|;
name|work_mbc
operator|->
name|range_sts
index|[
name|work_mbc
operator|->
name|nranges
index|]
operator|=
operator|(
name|wchar_t
operator|)
name|wc
expr_stmt|;
name|REALLOC_IF_NECESSARY
argument_list|(
name|work_mbc
operator|->
name|range_ends
argument_list|,
name|wchar_t
argument_list|,
name|range_ends_al
argument_list|,
name|work_mbc
operator|->
name|nranges
operator|+
literal|1
argument_list|)
expr_stmt|;
name|work_mbc
operator|->
name|range_ends
index|[
name|work_mbc
operator|->
name|nranges
operator|++
index|]
operator|=
operator|(
name|wchar_t
operator|)
name|wc2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wc
operator|!=
name|WEOF
condition|)
comment|/* build normal characters.  */
block|{
name|REALLOC_IF_NECESSARY
argument_list|(
name|work_mbc
operator|->
name|chars
argument_list|,
name|wchar_t
argument_list|,
name|chars_al
argument_list|,
name|work_mbc
operator|->
name|nchars
operator|+
literal|1
argument_list|)
expr_stmt|;
name|work_mbc
operator|->
name|chars
index|[
name|work_mbc
operator|->
name|nchars
operator|++
index|]
operator|=
operator|(
name|wchar_t
operator|)
name|wc
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|wc
operator|=
name|wc1
operator|)
operator|!=
literal|L'
expr|]'
condition|)
do|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MBS_SUPPORT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|FUNC
parameter_list|(
name|F
parameter_list|,
name|P
parameter_list|)
value|static int F(int c) { return P(c); }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FUNC
parameter_list|(
name|F
parameter_list|,
name|P
parameter_list|)
value|static int F(c) int c; { return P(c); }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|FUNC
argument_list|(
argument|is_alpha
argument_list|,
argument|ISALPHA
argument_list|)
end_macro

begin_macro
name|FUNC
argument_list|(
argument|is_upper
argument_list|,
argument|ISUPPER
argument_list|)
end_macro

begin_macro
name|FUNC
argument_list|(
argument|is_lower
argument_list|,
argument|ISLOWER
argument_list|)
end_macro

begin_macro
name|FUNC
argument_list|(
argument|is_digit
argument_list|,
argument|ISDIGIT
argument_list|)
end_macro

begin_macro
name|FUNC
argument_list|(
argument|is_xdigit
argument_list|,
argument|ISXDIGIT
argument_list|)
end_macro

begin_macro
name|FUNC
argument_list|(
argument|is_space
argument_list|,
argument|ISSPACE
argument_list|)
end_macro

begin_macro
name|FUNC
argument_list|(
argument|is_punct
argument_list|,
argument|ISPUNCT
argument_list|)
end_macro

begin_macro
name|FUNC
argument_list|(
argument|is_alnum
argument_list|,
argument|ISALNUM
argument_list|)
end_macro

begin_macro
name|FUNC
argument_list|(
argument|is_print
argument_list|,
argument|ISPRINT
argument_list|)
end_macro

begin_macro
name|FUNC
argument_list|(
argument|is_graph
argument_list|,
argument|ISGRAPH
argument_list|)
end_macro

begin_macro
name|FUNC
argument_list|(
argument|is_cntrl
argument_list|,
argument|ISCNTRL
argument_list|)
end_macro

begin_function
specifier|static
name|int
name|is_blank
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The following list maps the names of the Posix named character classes    to predicate functions that determine whether a given character is in    the class.  The leading [ has already been eaten by the lexical analyzer. */
end_comment

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
argument_list|(
argument|*pred
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
block|}
decl|const
name|prednames
index|[]
init|=
block|{
block|{
literal|":alpha:]"
block|,
name|is_alpha
block|}
block|,
block|{
literal|":upper:]"
block|,
name|is_upper
block|}
block|,
block|{
literal|":lower:]"
block|,
name|is_lower
block|}
block|,
block|{
literal|":digit:]"
block|,
name|is_digit
block|}
block|,
block|{
literal|":xdigit:]"
block|,
name|is_xdigit
block|}
block|,
block|{
literal|":space:]"
block|,
name|is_space
block|}
block|,
block|{
literal|":punct:]"
block|,
name|is_punct
block|}
block|,
block|{
literal|":alnum:]"
block|,
name|is_alnum
block|}
block|,
block|{
literal|":print:]"
block|,
name|is_print
block|}
block|,
block|{
literal|":graph:]"
block|,
name|is_graph
block|}
block|,
block|{
literal|":cntrl:]"
block|,
name|is_cntrl
block|}
block|,
block|{
literal|":blank:]"
block|,
name|is_blank
block|}
block|,
block|{
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Return non-zero if C is a `word-constituent' byte; zero otherwise.  */
end_comment

begin_define
define|#
directive|define
name|IS_WORD_CONSTITUENT
parameter_list|(
name|C
parameter_list|)
value|(ISALNUM(C) || (C) == '_')
end_define

begin_function
specifier|static
name|int
name|looking_at
parameter_list|(
name|char
specifier|const
modifier|*
name|s
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|lexleft
operator|<
name|len
condition|)
return|return
literal|0
return|;
return|return
name|strncmp
argument_list|(
name|s
argument_list|,
name|lexptr
argument_list|,
name|len
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|token
name|lex
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|c
decl_stmt|,
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|int
name|backslash
init|=
literal|0
decl_stmt|,
name|invert
decl_stmt|;
name|charclass
name|ccl
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Basic plan: We fetch a character.  If it's a backslash,      we set the backslash flag and go through the loop again.      On the plus side, this avoids having a duplicate of the      main switch inside the backslash case.  On the minus side,      it means that just about every case begins with      "if (backslash) ...".  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|FETCH
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|cur_mb_index
condition|)
comment|/* If this is a part of a multi-byte character, we must treat 	   this byte data as a normal character. 	   e.g. In case of SJIS encoding, some character contains '\', 	        but they must not be backslash.  */
goto|goto
name|normal_char
goto|;
endif|#
directive|endif
comment|/* MBS_SUPPORT  */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
name|backslash
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
name|lexleft
operator|==
literal|0
condition|)
name|dfaerror
argument_list|(
name|_
argument_list|(
literal|"Unfinished \\ escape"
argument_list|)
argument_list|)
expr_stmt|;
name|backslash
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
if|if
condition|(
name|backslash
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
name|syntax_bits
operator|&
name|RE_CONTEXT_INDEP_ANCHORS
operator|||
name|lasttok
operator|==
name|END
operator|||
name|lasttok
operator|==
name|LPAREN
operator|||
name|lasttok
operator|==
name|OR
condition|)
return|return
name|lasttok
operator|=
name|BEGLINE
return|;
goto|goto
name|normal_char
goto|;
case|case
literal|'$'
case|:
if|if
condition|(
name|backslash
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
name|syntax_bits
operator|&
name|RE_CONTEXT_INDEP_ANCHORS
operator|||
name|lexleft
operator|==
literal|0
operator|||
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_PARENS
condition|?
name|lexleft
operator|>
literal|0
operator|&&
operator|*
name|lexptr
operator|==
literal|')'
else|:
name|lexleft
operator|>
literal|1
operator|&&
name|lexptr
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|lexptr
index|[
literal|1
index|]
operator|==
literal|')'
operator|)
operator|||
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_VBAR
condition|?
name|lexleft
operator|>
literal|0
operator|&&
operator|*
name|lexptr
operator|==
literal|'|'
else|:
name|lexleft
operator|>
literal|1
operator|&&
name|lexptr
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|lexptr
index|[
literal|1
index|]
operator|==
literal|'|'
operator|)
operator|||
operator|(
operator|(
name|syntax_bits
operator|&
name|RE_NEWLINE_ALT
operator|)
operator|&&
name|lexleft
operator|>
literal|0
operator|&&
operator|*
name|lexptr
operator|==
literal|'\n'
operator|)
condition|)
return|return
name|lasttok
operator|=
name|ENDLINE
return|;
goto|goto
name|normal_char
goto|;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|backslash
operator|&&
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_REFS
operator|)
condition|)
block|{
name|laststart
operator|=
literal|0
expr_stmt|;
return|return
name|lasttok
operator|=
name|BACKREF
return|;
block|}
goto|goto
name|normal_char
goto|;
case|case
literal|'`'
case|:
if|if
condition|(
name|backslash
operator|&&
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
return|return
name|lasttok
operator|=
name|BEGLINE
return|;
comment|/* FIXME: should be beginning of string */
goto|goto
name|normal_char
goto|;
case|case
literal|'\''
case|:
if|if
condition|(
name|backslash
operator|&&
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
return|return
name|lasttok
operator|=
name|ENDLINE
return|;
comment|/* FIXME: should be end of string */
goto|goto
name|normal_char
goto|;
case|case
literal|'<'
case|:
if|if
condition|(
name|backslash
operator|&&
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
return|return
name|lasttok
operator|=
name|BEGWORD
return|;
goto|goto
name|normal_char
goto|;
case|case
literal|'>'
case|:
if|if
condition|(
name|backslash
operator|&&
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
return|return
name|lasttok
operator|=
name|ENDWORD
return|;
goto|goto
name|normal_char
goto|;
case|case
literal|'b'
case|:
if|if
condition|(
name|backslash
operator|&&
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
return|return
name|lasttok
operator|=
name|LIMWORD
return|;
goto|goto
name|normal_char
goto|;
case|case
literal|'B'
case|:
if|if
condition|(
name|backslash
operator|&&
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
return|return
name|lasttok
operator|=
name|NOTLIMWORD
return|;
goto|goto
name|normal_char
goto|;
case|case
literal|'?'
case|:
if|if
condition|(
name|syntax_bits
operator|&
name|RE_LIMITED_OPS
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
name|backslash
operator|!=
operator|(
operator|(
name|syntax_bits
operator|&
name|RE_BK_PLUS_QM
operator|)
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
operator|&&
name|laststart
condition|)
goto|goto
name|normal_char
goto|;
return|return
name|lasttok
operator|=
name|QMARK
return|;
case|case
literal|'*'
case|:
if|if
condition|(
name|backslash
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
operator|&&
name|laststart
condition|)
goto|goto
name|normal_char
goto|;
return|return
name|lasttok
operator|=
name|STAR
return|;
case|case
literal|'+'
case|:
if|if
condition|(
name|syntax_bits
operator|&
name|RE_LIMITED_OPS
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
name|backslash
operator|!=
operator|(
operator|(
name|syntax_bits
operator|&
name|RE_BK_PLUS_QM
operator|)
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
operator|&&
name|laststart
condition|)
goto|goto
name|normal_char
goto|;
return|return
name|lasttok
operator|=
name|PLUS
return|;
case|case
literal|'{'
case|:
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_INTERVALS
operator|)
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
name|backslash
operator|!=
operator|(
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_BRACES
operator|)
operator|==
literal|0
operator|)
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_CONTEXT_INDEP_OPS
operator|)
operator|&&
name|laststart
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
name|syntax_bits
operator|&
name|RE_NO_BK_BRACES
condition|)
block|{
comment|/* Scan ahead for a valid interval; if it's not valid, 		 treat it as a literal '{'.  */
name|int
name|lo
init|=
operator|-
literal|1
decl_stmt|,
name|hi
init|=
operator|-
literal|1
decl_stmt|;
name|char
specifier|const
modifier|*
name|p
init|=
name|lexptr
decl_stmt|;
name|char
specifier|const
modifier|*
name|lim
init|=
name|p
operator|+
name|lexleft
decl_stmt|;
for|for
control|(
init|;
name|p
operator|!=
name|lim
operator|&&
name|ISASCIIDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
name|lo
operator|=
operator|(
name|lo
operator|<
literal|0
condition|?
literal|0
else|:
name|lo
operator|*
literal|10
operator|)
operator|+
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|lim
operator|&&
operator|*
name|p
operator|==
literal|','
condition|)
while|while
condition|(
operator|++
name|p
operator|!=
name|lim
operator|&&
name|ISASCIIDIGIT
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|hi
operator|=
operator|(
name|hi
operator|<
literal|0
condition|?
literal|0
else|:
name|hi
operator|*
literal|10
operator|)
operator|+
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
else|else
name|hi
operator|=
name|lo
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|lim
operator|||
operator|*
name|p
operator|!=
literal|'}'
operator|||
name|lo
operator|<
literal|0
operator|||
name|RE_DUP_MAX
operator|<
name|hi
operator|||
operator|(
literal|0
operator|<=
name|hi
operator|&&
name|hi
operator|<
name|lo
operator|)
condition|)
goto|goto
name|normal_char
goto|;
block|}
name|minrep
operator|=
literal|0
expr_stmt|;
comment|/* Cases: 	     {M} - exact count 	     {M,} - minimum count, maximum is infinity 	     {M,N} - M through N */
name|FETCH
argument_list|(
name|c
argument_list|,
name|_
argument_list|(
literal|"unfinished repeat count"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISASCIIDIGIT
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|minrep
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|FETCH
argument_list|(
name|c
argument_list|,
name|_
argument_list|(
literal|"unfinished repeat count"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISASCIIDIGIT
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|minrep
operator|=
literal|10
operator|*
name|minrep
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
block|}
else|else
name|dfaerror
argument_list|(
name|_
argument_list|(
literal|"malformed repeat count"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|FETCH
argument_list|(
name|c
argument_list|,
name|_
argument_list|(
literal|"unfinished repeat count"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISASCIIDIGIT
argument_list|(
name|c
argument_list|)
condition|)
name|maxrep
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|maxrep
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|FETCH
argument_list|(
name|c
argument_list|,
name|_
argument_list|(
literal|"unfinished repeat count"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ISASCIIDIGIT
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|maxrep
operator|=
literal|10
operator|*
name|maxrep
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<=
name|maxrep
operator|&&
name|maxrep
operator|<
name|minrep
condition|)
name|dfaerror
argument_list|(
name|_
argument_list|(
literal|"malformed repeat count"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|maxrep
operator|=
name|minrep
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_BRACES
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'\\'
condition|)
name|dfaerror
argument_list|(
name|_
argument_list|(
literal|"malformed repeat count"
argument_list|)
argument_list|)
expr_stmt|;
name|FETCH
argument_list|(
name|c
argument_list|,
name|_
argument_list|(
literal|"unfinished repeat count"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'}'
condition|)
name|dfaerror
argument_list|(
name|_
argument_list|(
literal|"malformed repeat count"
argument_list|)
argument_list|)
expr_stmt|;
name|laststart
operator|=
literal|0
expr_stmt|;
return|return
name|lasttok
operator|=
name|REPMN
return|;
case|case
literal|'|'
case|:
if|if
condition|(
name|syntax_bits
operator|&
name|RE_LIMITED_OPS
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
name|backslash
operator|!=
operator|(
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_VBAR
operator|)
operator|==
literal|0
operator|)
condition|)
goto|goto
name|normal_char
goto|;
name|laststart
operator|=
literal|1
expr_stmt|;
return|return
name|lasttok
operator|=
name|OR
return|;
case|case
literal|'\n'
case|:
if|if
condition|(
name|syntax_bits
operator|&
name|RE_LIMITED_OPS
operator|||
name|backslash
operator|||
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_NEWLINE_ALT
operator|)
condition|)
goto|goto
name|normal_char
goto|;
name|laststart
operator|=
literal|1
expr_stmt|;
return|return
name|lasttok
operator|=
name|OR
return|;
case|case
literal|'('
case|:
if|if
condition|(
name|backslash
operator|!=
operator|(
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_PARENS
operator|)
operator|==
literal|0
operator|)
condition|)
goto|goto
name|normal_char
goto|;
operator|++
name|parens
expr_stmt|;
name|laststart
operator|=
literal|1
expr_stmt|;
return|return
name|lasttok
operator|=
name|LPAREN
return|;
case|case
literal|')'
case|:
if|if
condition|(
name|backslash
operator|!=
operator|(
operator|(
name|syntax_bits
operator|&
name|RE_NO_BK_PARENS
operator|)
operator|==
literal|0
operator|)
condition|)
goto|goto
name|normal_char
goto|;
if|if
condition|(
name|parens
operator|==
literal|0
operator|&&
name|syntax_bits
operator|&
name|RE_UNMATCHED_RIGHT_PAREN_ORD
condition|)
goto|goto
name|normal_char
goto|;
operator|--
name|parens
expr_stmt|;
name|laststart
operator|=
literal|0
expr_stmt|;
return|return
name|lasttok
operator|=
name|RPAREN
return|;
case|case
literal|'.'
case|:
if|if
condition|(
name|backslash
condition|)
goto|goto
name|normal_char
goto|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
condition|)
block|{
comment|/* In multibyte environment period must match with a single 		 character not a byte.  So we use ANYCHAR.  */
name|laststart
operator|=
literal|0
expr_stmt|;
return|return
name|lasttok
operator|=
name|ANYCHAR
return|;
block|}
endif|#
directive|endif
comment|/* MBS_SUPPORT */
name|zeroset
argument_list|(
name|ccl
argument_list|)
expr_stmt|;
name|notset
argument_list|(
name|ccl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_DOT_NEWLINE
operator|)
condition|)
name|clrbit
argument_list|(
name|eolbyte
argument_list|,
name|ccl
argument_list|)
expr_stmt|;
if|if
condition|(
name|syntax_bits
operator|&
name|RE_DOT_NOT_NULL
condition|)
name|clrbit
argument_list|(
literal|'\0'
argument_list|,
name|ccl
argument_list|)
expr_stmt|;
name|laststart
operator|=
literal|0
expr_stmt|;
return|return
name|lasttok
operator|=
name|CSET
operator|+
name|charclass_index
argument_list|(
name|ccl
argument_list|)
return|;
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
if|if
condition|(
operator|!
name|backslash
operator|||
operator|(
name|syntax_bits
operator|&
name|RE_NO_GNU_OPS
operator|)
condition|)
goto|goto
name|normal_char
goto|;
name|zeroset
argument_list|(
name|ccl
argument_list|)
expr_stmt|;
for|for
control|(
name|c2
operator|=
literal|0
init|;
name|c2
operator|<
name|NOTCHAR
condition|;
operator|++
name|c2
control|)
if|if
condition|(
name|IS_WORD_CONSTITUENT
argument_list|(
name|c2
argument_list|)
condition|)
name|setbit
argument_list|(
name|c2
argument_list|,
name|ccl
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'W'
condition|)
name|notset
argument_list|(
name|ccl
argument_list|)
expr_stmt|;
name|laststart
operator|=
literal|0
expr_stmt|;
return|return
name|lasttok
operator|=
name|CSET
operator|+
name|charclass_index
argument_list|(
name|ccl
argument_list|)
return|;
case|case
literal|'['
case|:
if|if
condition|(
name|backslash
condition|)
goto|goto
name|normal_char
goto|;
name|laststart
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
condition|)
block|{
comment|/* In multibyte environment a bracket expression may contain 		 multibyte characters, which must be treated as characters 		 (not bytes).  So we parse it by parse_bracket_exp_mb().  */
name|parse_bracket_exp_mb
argument_list|()
expr_stmt|;
return|return
name|lasttok
operator|=
name|MBCSET
return|;
block|}
endif|#
directive|endif
name|zeroset
argument_list|(
name|ccl
argument_list|)
expr_stmt|;
name|FETCH
argument_list|(
name|c
argument_list|,
name|_
argument_list|(
literal|"Unbalanced ["
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'^'
condition|)
block|{
name|FETCH
argument_list|(
name|c
argument_list|,
name|_
argument_list|(
literal|"Unbalanced ["
argument_list|)
argument_list|)
expr_stmt|;
name|invert
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|invert
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* Nobody ever said this had to be fast. :-) 		 Note that if we're looking at some other [:...:] 		 construct, we just treat it as a bunch of ordinary 		 characters.  We can do this because we assume 		 regex has checked for syntax errors before 		 dfa is ever called. */
if|if
condition|(
name|c
operator|==
literal|'['
operator|&&
operator|(
name|syntax_bits
operator|&
name|RE_CHAR_CLASSES
operator|)
condition|)
for|for
control|(
name|c1
operator|=
literal|0
init|;
name|prednames
index|[
name|c1
index|]
operator|.
name|name
condition|;
operator|++
name|c1
control|)
if|if
condition|(
name|looking_at
argument_list|(
name|prednames
index|[
name|c1
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|int
argument_list|(
argument|*pred
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|=
name|prednames
index|[
name|c1
index|]
operator|.
name|pred
expr_stmt|;
for|for
control|(
name|c2
operator|=
literal|0
init|;
name|c2
operator|<
name|NOTCHAR
condition|;
operator|++
name|c2
control|)
if|if
condition|(
call|(
modifier|*
name|pred
call|)
argument_list|(
name|c2
argument_list|)
condition|)
name|setbit_case_fold
argument_list|(
name|c2
argument_list|,
name|ccl
argument_list|)
expr_stmt|;
name|lexptr
operator|+=
name|strlen
argument_list|(
name|prednames
index|[
name|c1
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|lexleft
operator|-=
name|strlen
argument_list|(
name|prednames
index|[
name|c1
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|FETCH
argument_list|(
name|c1
argument_list|,
name|_
argument_list|(
literal|"Unbalanced ["
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
operator|(
name|syntax_bits
operator|&
name|RE_BACKSLASH_ESCAPE_IN_LISTS
operator|)
condition|)
name|FETCH
argument_list|(
name|c
argument_list|,
name|_
argument_list|(
literal|"Unbalanced ["
argument_list|)
argument_list|)
expr_stmt|;
name|FETCH
argument_list|(
name|c1
argument_list|,
name|_
argument_list|(
literal|"Unbalanced ["
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'-'
condition|)
block|{
name|FETCH
argument_list|(
name|c2
argument_list|,
name|_
argument_list|(
literal|"Unbalanced ["
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c2
operator|==
literal|']'
condition|)
block|{
comment|/* In the case [x-], the - is an ordinary hyphen, 			 which is left in c1, the lookahead character. */
operator|--
name|lexptr
expr_stmt|;
operator|++
name|lexleft
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c2
operator|==
literal|'\\'
operator|&&
operator|(
name|syntax_bits
operator|&
name|RE_BACKSLASH_ESCAPE_IN_LISTS
operator|)
condition|)
name|FETCH
argument_list|(
name|c2
argument_list|,
name|_
argument_list|(
literal|"Unbalanced ["
argument_list|)
argument_list|)
expr_stmt|;
name|FETCH
argument_list|(
name|c1
argument_list|,
name|_
argument_list|(
literal|"Unbalanced ["
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hard_LC_COLLATE
condition|)
block|{
for|for
control|(
init|;
name|c
operator|<=
name|c2
condition|;
name|c
operator|++
control|)
name|setbit_case_fold
argument_list|(
name|c
argument_list|,
name|ccl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* POSIX locales are painful - leave the decision to libc */
name|char
name|expr
index|[
literal|6
index|]
init|=
block|{
literal|'['
block|,
name|c
block|,
literal|'-'
block|,
name|c2
block|,
literal|']'
block|,
literal|'\0'
block|}
decl_stmt|;
name|regex_t
name|re
decl_stmt|;
if|if
condition|(
name|regcomp
argument_list|(
operator|&
name|re
argument_list|,
name|expr
argument_list|,
name|case_fold
condition|?
name|REG_ICASE
else|:
literal|0
argument_list|)
operator|==
name|REG_NOERROR
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|NOTCHAR
condition|;
operator|++
name|c
control|)
block|{
name|char
name|buf
index|[
literal|2
index|]
init|=
block|{
name|c
block|,
literal|'\0'
block|}
decl_stmt|;
name|regmatch_t
name|mat
decl_stmt|;
if|if
condition|(
name|regexec
argument_list|(
operator|&
name|re
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|,
operator|&
name|mat
argument_list|,
literal|0
argument_list|)
operator|==
name|REG_NOERROR
operator|&&
name|mat
operator|.
name|rm_so
operator|==
literal|0
operator|&&
name|mat
operator|.
name|rm_eo
operator|==
literal|1
condition|)
name|setbit_case_fold
argument_list|(
name|c
argument_list|,
name|ccl
argument_list|)
expr_stmt|;
block|}
name|regfree
argument_list|(
operator|&
name|re
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
block|}
block|}
name|setbit_case_fold
argument_list|(
name|c
argument_list|,
name|ccl
argument_list|)
expr_stmt|;
name|skip
label|:
empty_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|c1
operator|)
operator|!=
literal|']'
condition|)
do|;
if|if
condition|(
name|invert
condition|)
block|{
name|notset
argument_list|(
name|ccl
argument_list|)
expr_stmt|;
if|if
condition|(
name|syntax_bits
operator|&
name|RE_HAT_LISTS_NOT_NEWLINE
condition|)
name|clrbit
argument_list|(
name|eolbyte
argument_list|,
name|ccl
argument_list|)
expr_stmt|;
block|}
return|return
name|lasttok
operator|=
name|CSET
operator|+
name|charclass_index
argument_list|(
name|ccl
argument_list|)
return|;
default|default:
name|normal_char
label|:
name|laststart
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|case_fold
operator|&&
name|ISALPHA
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|zeroset
argument_list|(
name|ccl
argument_list|)
expr_stmt|;
name|setbit_case_fold
argument_list|(
name|c
argument_list|,
name|ccl
argument_list|)
expr_stmt|;
return|return
name|lasttok
operator|=
name|CSET
operator|+
name|charclass_index
argument_list|(
name|ccl
argument_list|)
return|;
block|}
return|return
name|c
return|;
block|}
block|}
comment|/* The above loop should consume at most a backslash      and some other character. */
name|abort
argument_list|()
expr_stmt|;
return|return
name|END
return|;
comment|/* keeps pedantic compilers happy. */
block|}
end_function

begin_comment
comment|/* Recursive descent parser for regular expressions. */
end_comment

begin_decl_stmt
specifier|static
name|token
name|tok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lookahead token. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current depth of a hypothetical stack 				   holding deferred productions.  This is 				   used to determine the depth that will be 				   required of the real stack later on in 				   dfaanalyze(). */
end_comment

begin_comment
comment|/* Add the given token to the parse tree, maintaining the depth count and    updating the maximum depth if necessary. */
end_comment

begin_function
specifier|static
name|void
name|addtok
parameter_list|(
name|token
name|t
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
condition|)
block|{
name|REALLOC_IF_NECESSARY
argument_list|(
name|dfa
operator|->
name|multibyte_prop
argument_list|,
name|int
argument_list|,
name|dfa
operator|->
name|nmultibyte_prop
argument_list|,
name|dfa
operator|->
name|tindex
argument_list|)
expr_stmt|;
comment|/* Set dfa->multibyte_prop.  See struct dfa in dfa.h.  */
if|if
condition|(
name|t
operator|==
name|MBCSET
condition|)
name|dfa
operator|->
name|multibyte_prop
index|[
name|dfa
operator|->
name|tindex
index|]
operator|=
operator|(
operator|(
name|dfa
operator|->
name|nmbcsets
operator|-
literal|1
operator|)
operator|<<
literal|2
operator|)
operator|+
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|<
name|NOTCHAR
condition|)
name|dfa
operator|->
name|multibyte_prop
index|[
name|dfa
operator|->
name|tindex
index|]
operator|=
operator|(
name|cur_mb_len
operator|==
literal|1
operator|)
condition|?
literal|3
comment|/* single-byte char */
else|:
operator|(
operator|(
operator|(
name|cur_mb_index
operator|==
literal|1
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
comment|/* 1st-byte of multibyte char */
operator|+
operator|(
operator|(
name|cur_mb_index
operator|==
name|cur_mb_len
operator|)
condition|?
literal|2
else|:
literal|0
operator|)
operator|)
expr_stmt|;
comment|/* last-byte */
else|else
comment|/* It may be unnecesssary, but it is safer to treat other 	   symbols as singlebyte characters.  */
name|dfa
operator|->
name|multibyte_prop
index|[
name|dfa
operator|->
name|tindex
index|]
operator|=
literal|3
expr_stmt|;
block|}
endif|#
directive|endif
name|REALLOC_IF_NECESSARY
argument_list|(
name|dfa
operator|->
name|tokens
argument_list|,
name|token
argument_list|,
name|dfa
operator|->
name|talloc
argument_list|,
name|dfa
operator|->
name|tindex
argument_list|)
expr_stmt|;
name|dfa
operator|->
name|tokens
index|[
name|dfa
operator|->
name|tindex
operator|++
index|]
operator|=
name|t
expr_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|QMARK
case|:
case|case
name|STAR
case|:
case|case
name|PLUS
case|:
break|break;
case|case
name|CAT
case|:
case|case
name|OR
case|:
case|case
name|ORTOP
case|:
operator|--
name|depth
expr_stmt|;
break|break;
default|default:
operator|++
name|dfa
operator|->
name|nleaves
expr_stmt|;
case|case
name|EMPTY
case|:
operator|++
name|depth
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|depth
operator|>
name|dfa
operator|->
name|depth
condition|)
name|dfa
operator|->
name|depth
operator|=
name|depth
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The grammar understood by the parser is as follows.     regexp:      regexp OR branch      branch     branch:      branch closure      closure     closure:      closure QMARK      closure STAR      closure PLUS      closure REPMN      atom     atom:<normal character><multibyte character>      ANYCHAR      MBCSET      CSET      BACKREF      BEGLINE      ENDLINE      BEGWORD      ENDWORD      LIMWORD      NOTLIMWORD      CRANGE      LPAREN regexp RPAREN<empty>     The parser builds a parse tree in postfix form in an array of tokens. */
end_comment

begin_function
specifier|static
name|void
name|atom
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|(
name|tok
operator|>=
literal|0
operator|&&
name|tok
operator|<
name|NOTCHAR
operator|)
operator|||
name|tok
operator|>=
name|CSET
operator|||
name|tok
operator|==
name|BACKREF
operator|||
name|tok
operator|==
name|BEGLINE
operator|||
name|tok
operator|==
name|ENDLINE
operator|||
name|tok
operator|==
name|BEGWORD
ifdef|#
directive|ifdef
name|MBS_SUPPORT
operator|||
name|tok
operator|==
name|ANYCHAR
operator|||
name|tok
operator|==
name|MBCSET
comment|/* MB_CUR_MAX> 1 */
endif|#
directive|endif
comment|/* MBS_SUPPORT */
operator|||
name|tok
operator|==
name|ENDWORD
operator|||
name|tok
operator|==
name|LIMWORD
operator|||
name|tok
operator|==
name|NOTLIMWORD
condition|)
block|{
name|addtok
argument_list|(
name|tok
argument_list|)
expr_stmt|;
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
comment|/* We treat a multibyte character as a single atom, so that DFA 	 can treat a multibyte character as a single expression.           e.g. We construct following tree from "<mb1><mb2>".<mb1(1st-byte)><mb1(2nd-byte)><CAT><mb1(3rd-byte)><CAT><mb2(1st-byte)><mb2(2nd-byte)><CAT><mb2(3rd-byte)><CAT><CAT>       */
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
condition|)
block|{
while|while
condition|(
name|cur_mb_index
operator|>
literal|1
operator|&&
name|tok
operator|>=
literal|0
operator|&&
name|tok
operator|<
name|NOTCHAR
condition|)
block|{
name|addtok
argument_list|(
name|tok
argument_list|)
expr_stmt|;
name|addtok
argument_list|(
name|CAT
argument_list|)
expr_stmt|;
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* MBS_SUPPORT  */
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|CRANGE
condition|)
block|{
comment|/* A character range like "[a-z]" in a locale other than "C" or 	 "POSIX".  This range might any sequence of one or more 	 characters.  Unfortunately the POSIX locale primitives give 	 us no practical way to find what character sequences might be 	 matched.  Treat this approximately like "(.\1)" -- i.e. match 	 one character, and then punt to the full matcher.  */
name|charclass
name|ccl
decl_stmt|;
name|zeroset
argument_list|(
name|ccl
argument_list|)
expr_stmt|;
name|notset
argument_list|(
name|ccl
argument_list|)
expr_stmt|;
name|addtok
argument_list|(
name|CSET
operator|+
name|charclass_index
argument_list|(
name|ccl
argument_list|)
argument_list|)
expr_stmt|;
name|addtok
argument_list|(
name|BACKREF
argument_list|)
expr_stmt|;
name|addtok
argument_list|(
name|CAT
argument_list|)
expr_stmt|;
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tok
operator|==
name|LPAREN
condition|)
block|{
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
name|regexp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|RPAREN
condition|)
name|dfaerror
argument_list|(
name|_
argument_list|(
literal|"Unbalanced ("
argument_list|)
argument_list|)
expr_stmt|;
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
block|}
else|else
name|addtok
argument_list|(
name|EMPTY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the number of tokens in the given subexpression. */
end_comment

begin_function
specifier|static
name|int
name|nsubtoks
parameter_list|(
name|int
name|tindex
parameter_list|)
block|{
name|int
name|ntoks1
decl_stmt|;
switch|switch
condition|(
name|dfa
operator|->
name|tokens
index|[
name|tindex
operator|-
literal|1
index|]
condition|)
block|{
default|default:
return|return
literal|1
return|;
case|case
name|QMARK
case|:
case|case
name|STAR
case|:
case|case
name|PLUS
case|:
return|return
literal|1
operator|+
name|nsubtoks
argument_list|(
name|tindex
operator|-
literal|1
argument_list|)
return|;
case|case
name|CAT
case|:
case|case
name|OR
case|:
case|case
name|ORTOP
case|:
name|ntoks1
operator|=
name|nsubtoks
argument_list|(
name|tindex
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
operator|+
name|ntoks1
operator|+
name|nsubtoks
argument_list|(
name|tindex
operator|-
literal|1
operator|-
name|ntoks1
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Copy the given subexpression to the top of the tree. */
end_comment

begin_function
specifier|static
name|void
name|copytoks
parameter_list|(
name|int
name|tindex
parameter_list|,
name|int
name|ntokens
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntokens
condition|;
operator|++
name|i
control|)
name|addtok
argument_list|(
name|dfa
operator|->
name|tokens
index|[
name|tindex
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|closure
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|tindex
decl_stmt|,
name|ntokens
decl_stmt|,
name|i
decl_stmt|;
name|atom
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|QMARK
operator|||
name|tok
operator|==
name|STAR
operator|||
name|tok
operator|==
name|PLUS
operator|||
name|tok
operator|==
name|REPMN
condition|)
if|if
condition|(
name|tok
operator|==
name|REPMN
condition|)
block|{
name|ntokens
operator|=
name|nsubtoks
argument_list|(
name|dfa
operator|->
name|tindex
argument_list|)
expr_stmt|;
name|tindex
operator|=
name|dfa
operator|->
name|tindex
operator|-
name|ntokens
expr_stmt|;
if|if
condition|(
name|maxrep
operator|<
literal|0
condition|)
name|addtok
argument_list|(
name|PLUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|minrep
operator|==
literal|0
condition|)
name|addtok
argument_list|(
name|QMARK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|minrep
condition|;
operator|++
name|i
control|)
block|{
name|copytoks
argument_list|(
name|tindex
argument_list|,
name|ntokens
argument_list|)
expr_stmt|;
name|addtok
argument_list|(
name|CAT
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|maxrep
condition|;
operator|++
name|i
control|)
block|{
name|copytoks
argument_list|(
name|tindex
argument_list|,
name|ntokens
argument_list|)
expr_stmt|;
name|addtok
argument_list|(
name|QMARK
argument_list|)
expr_stmt|;
name|addtok
argument_list|(
name|CAT
argument_list|)
expr_stmt|;
block|}
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|addtok
argument_list|(
name|tok
argument_list|)
expr_stmt|;
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|branch
parameter_list|(
name|void
parameter_list|)
block|{
name|closure
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|!=
name|RPAREN
operator|&&
name|tok
operator|!=
name|OR
operator|&&
name|tok
operator|>=
literal|0
condition|)
block|{
name|closure
argument_list|()
expr_stmt|;
name|addtok
argument_list|(
name|CAT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|regexp
parameter_list|(
name|int
name|toplevel
parameter_list|)
block|{
name|branch
argument_list|()
expr_stmt|;
while|while
condition|(
name|tok
operator|==
name|OR
condition|)
block|{
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
name|branch
argument_list|()
expr_stmt|;
if|if
condition|(
name|toplevel
condition|)
name|addtok
argument_list|(
name|ORTOP
argument_list|)
expr_stmt|;
else|else
name|addtok
argument_list|(
name|OR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Main entry point for the parser.  S is a string to be parsed, len is the    length of the string, so s can include NUL characters.  D is a pointer to    the struct dfa to parse into. */
end_comment

begin_function
name|void
name|dfaparse
parameter_list|(
name|char
specifier|const
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|dfa
modifier|*
name|d
parameter_list|)
block|{
name|dfa
operator|=
name|d
expr_stmt|;
name|lexstart
operator|=
name|lexptr
operator|=
name|s
expr_stmt|;
name|lexleft
operator|=
name|len
expr_stmt|;
name|lasttok
operator|=
name|END
expr_stmt|;
name|laststart
operator|=
literal|1
expr_stmt|;
name|parens
operator|=
literal|0
expr_stmt|;
name|hard_LC_COLLATE
operator|=
name|hard_locale
argument_list|(
name|LC_COLLATE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
condition|)
block|{
name|cur_mb_index
operator|=
literal|0
expr_stmt|;
name|cur_mb_len
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MBS_SUPPORT  */
if|if
condition|(
operator|!
name|syntax_bits_set
condition|)
name|dfaerror
argument_list|(
name|_
argument_list|(
literal|"No syntax specified"
argument_list|)
argument_list|)
expr_stmt|;
name|tok
operator|=
name|lex
argument_list|()
expr_stmt|;
name|depth
operator|=
name|d
operator|->
name|depth
expr_stmt|;
name|regexp
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|END
condition|)
name|dfaerror
argument_list|(
name|_
argument_list|(
literal|"Unbalanced )"
argument_list|)
argument_list|)
expr_stmt|;
name|addtok
argument_list|(
name|END
operator|-
name|d
operator|->
name|nregexps
argument_list|)
expr_stmt|;
name|addtok
argument_list|(
name|CAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|nregexps
condition|)
name|addtok
argument_list|(
name|ORTOP
argument_list|)
expr_stmt|;
operator|++
name|d
operator|->
name|nregexps
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Some primitives for operating on sets of positions. */
end_comment

begin_comment
comment|/* Copy one set to another; the destination must be large enough. */
end_comment

begin_function
specifier|static
name|void
name|copy
parameter_list|(
name|position_set
specifier|const
modifier|*
name|src
parameter_list|,
name|position_set
modifier|*
name|dst
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|src
operator|->
name|nelem
condition|;
operator|++
name|i
control|)
name|dst
operator|->
name|elems
index|[
name|i
index|]
operator|=
name|src
operator|->
name|elems
index|[
name|i
index|]
expr_stmt|;
name|dst
operator|->
name|nelem
operator|=
name|src
operator|->
name|nelem
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert a position in a set.  Position sets are maintained in sorted    order according to index.  If position already exists in the set with    the same index then their constraints are logically or'd together.    S->elems must point to an array large enough to hold the resulting set. */
end_comment

begin_function
specifier|static
name|void
name|insert
parameter_list|(
name|position
name|p
parameter_list|,
name|position_set
modifier|*
name|s
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|position
name|t1
decl_stmt|,
name|t2
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|nelem
operator|&&
name|p
operator|.
name|index
operator|<
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
condition|;
operator|++
name|i
control|)
continue|continue;
if|if
condition|(
name|i
operator|<
name|s
operator|->
name|nelem
operator|&&
name|p
operator|.
name|index
operator|==
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
condition|)
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|constraint
operator||=
name|p
operator|.
name|constraint
expr_stmt|;
else|else
block|{
name|t1
operator|=
name|p
expr_stmt|;
operator|++
name|s
operator|->
name|nelem
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|s
operator|->
name|nelem
condition|)
block|{
name|t2
operator|=
name|s
operator|->
name|elems
index|[
name|i
index|]
expr_stmt|;
name|s
operator|->
name|elems
index|[
name|i
operator|++
index|]
operator|=
name|t1
expr_stmt|;
name|t1
operator|=
name|t2
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Merge two sets of positions into a third.  The result is exactly as if    the positions of both sets were inserted into an initially empty set. */
end_comment

begin_function
specifier|static
name|void
name|merge
parameter_list|(
name|position_set
specifier|const
modifier|*
name|s1
parameter_list|,
name|position_set
specifier|const
modifier|*
name|s2
parameter_list|,
name|position_set
modifier|*
name|m
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|m
operator|->
name|nelem
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|s1
operator|->
name|nelem
operator|&&
name|j
operator|<
name|s2
operator|->
name|nelem
condition|)
if|if
condition|(
name|s1
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
operator|>
name|s2
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|index
condition|)
name|m
operator|->
name|elems
index|[
name|m
operator|->
name|nelem
operator|++
index|]
operator|=
name|s1
operator|->
name|elems
index|[
name|i
operator|++
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|s1
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
operator|<
name|s2
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|index
condition|)
name|m
operator|->
name|elems
index|[
name|m
operator|->
name|nelem
operator|++
index|]
operator|=
name|s2
operator|->
name|elems
index|[
name|j
operator|++
index|]
expr_stmt|;
else|else
block|{
name|m
operator|->
name|elems
index|[
name|m
operator|->
name|nelem
index|]
operator|=
name|s1
operator|->
name|elems
index|[
name|i
operator|++
index|]
expr_stmt|;
name|m
operator|->
name|elems
index|[
name|m
operator|->
name|nelem
operator|++
index|]
operator|.
name|constraint
operator||=
name|s2
operator|->
name|elems
index|[
name|j
operator|++
index|]
operator|.
name|constraint
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
name|s1
operator|->
name|nelem
condition|)
name|m
operator|->
name|elems
index|[
name|m
operator|->
name|nelem
operator|++
index|]
operator|=
name|s1
operator|->
name|elems
index|[
name|i
operator|++
index|]
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|s2
operator|->
name|nelem
condition|)
name|m
operator|->
name|elems
index|[
name|m
operator|->
name|nelem
operator|++
index|]
operator|=
name|s2
operator|->
name|elems
index|[
name|j
operator|++
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Delete a position from a set. */
end_comment

begin_function
specifier|static
name|void
name|delete
parameter_list|(
name|position
name|p
parameter_list|,
name|position_set
modifier|*
name|s
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|nelem
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|p
operator|.
name|index
operator|==
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|s
operator|->
name|nelem
condition|)
for|for
control|(
operator|--
name|s
operator|->
name|nelem
init|;
name|i
operator|<
name|s
operator|->
name|nelem
condition|;
operator|++
name|i
control|)
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|=
name|s
operator|->
name|elems
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the index of the state corresponding to the given position set with    the given preceding context, or create a new state if there is no such    state.  Newline and letter tell whether we got here on a newline or    letter, respectively. */
end_comment

begin_function
specifier|static
name|int
name|state_index
parameter_list|(
name|struct
name|dfa
modifier|*
name|d
parameter_list|,
name|position_set
specifier|const
modifier|*
name|s
parameter_list|,
name|int
name|newline
parameter_list|,
name|int
name|letter
parameter_list|)
block|{
name|int
name|hash
init|=
literal|0
decl_stmt|;
name|int
name|constraint
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|newline
operator|=
name|newline
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|letter
operator|=
name|letter
condition|?
literal|1
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|nelem
condition|;
operator|++
name|i
control|)
name|hash
operator|^=
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
operator|+
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|constraint
expr_stmt|;
comment|/* Try to find a state that exactly matches the proposed one. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|sindex
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|hash
operator|!=
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|hash
operator|||
name|s
operator|->
name|nelem
operator|!=
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|elems
operator|.
name|nelem
operator|||
name|newline
operator|!=
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|newline
operator|||
name|letter
operator|!=
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|letter
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|s
operator|->
name|nelem
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|s
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|constraint
operator|!=
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|elems
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|constraint
operator|||
name|s
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|index
operator|!=
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|elems
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|index
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|s
operator|->
name|nelem
condition|)
return|return
name|i
return|;
block|}
comment|/* We'll have to create a new state. */
name|REALLOC_IF_NECESSARY
argument_list|(
name|d
operator|->
name|states
argument_list|,
name|dfa_state
argument_list|,
name|d
operator|->
name|salloc
argument_list|,
name|d
operator|->
name|sindex
argument_list|)
expr_stmt|;
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|hash
operator|=
name|hash
expr_stmt|;
name|MALLOC
argument_list|(
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|elems
operator|.
name|elems
argument_list|,
name|position
argument_list|,
name|s
operator|->
name|nelem
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|s
argument_list|,
operator|&
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|elems
argument_list|)
expr_stmt|;
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|newline
operator|=
name|newline
expr_stmt|;
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|letter
operator|=
name|letter
expr_stmt|;
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|backref
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|constraint
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|first_end
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
condition|)
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|mbps
operator|.
name|nelem
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|s
operator|->
name|nelem
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|d
operator|->
name|tokens
index|[
name|s
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|index
index|]
operator|<
literal|0
condition|)
block|{
name|constraint
operator|=
name|s
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|constraint
expr_stmt|;
if|if
condition|(
name|SUCCEEDS_IN_CONTEXT
argument_list|(
name|constraint
argument_list|,
name|newline
argument_list|,
literal|0
argument_list|,
name|letter
argument_list|,
literal|0
argument_list|)
operator|||
name|SUCCEEDS_IN_CONTEXT
argument_list|(
name|constraint
argument_list|,
name|newline
argument_list|,
literal|0
argument_list|,
name|letter
argument_list|,
literal|1
argument_list|)
operator|||
name|SUCCEEDS_IN_CONTEXT
argument_list|(
name|constraint
argument_list|,
name|newline
argument_list|,
literal|1
argument_list|,
name|letter
argument_list|,
literal|0
argument_list|)
operator|||
name|SUCCEEDS_IN_CONTEXT
argument_list|(
name|constraint
argument_list|,
name|newline
argument_list|,
literal|1
argument_list|,
name|letter
argument_list|,
literal|1
argument_list|)
condition|)
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|constraint
operator||=
name|constraint
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|first_end
condition|)
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|first_end
operator|=
name|d
operator|->
name|tokens
index|[
name|s
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|index
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|tokens
index|[
name|s
operator|->
name|elems
index|[
name|j
index|]
operator|.
name|index
index|]
operator|==
name|BACKREF
condition|)
block|{
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|constraint
operator|=
name|NO_CONSTRAINT
expr_stmt|;
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|backref
operator|=
literal|1
expr_stmt|;
block|}
operator|++
name|d
operator|->
name|sindex
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Find the epsilon closure of a set of positions.  If any position of the set    contains a symbol that matches the empty string in some context, replace    that position with the elements of its follow labeled with an appropriate    constraint.  Repeat exhaustively until no funny positions are left.    S->elems must be large enough to hold the result. */
end_comment

begin_function
specifier|static
name|void
name|epsclosure
parameter_list|(
name|position_set
modifier|*
name|s
parameter_list|,
name|struct
name|dfa
specifier|const
modifier|*
name|d
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
modifier|*
name|visited
decl_stmt|;
name|position
name|p
decl_stmt|,
name|old
decl_stmt|;
name|MALLOC
argument_list|(
name|visited
argument_list|,
name|int
argument_list|,
name|d
operator|->
name|tindex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
name|visited
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|nelem
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|d
operator|->
name|tokens
index|[
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
index|]
operator|>=
name|NOTCHAR
operator|&&
name|d
operator|->
name|tokens
index|[
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
index|]
operator|!=
name|BACKREF
ifdef|#
directive|ifdef
name|MBS_SUPPORT
operator|&&
name|d
operator|->
name|tokens
index|[
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
index|]
operator|!=
name|ANYCHAR
operator|&&
name|d
operator|->
name|tokens
index|[
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
index|]
operator|!=
name|MBCSET
endif|#
directive|endif
operator|&&
name|d
operator|->
name|tokens
index|[
name|s
operator|->
name|elems
index|[
name|i
index|]
operator|.
name|index
index|]
operator|<
name|CSET
condition|)
block|{
name|old
operator|=
name|s
operator|->
name|elems
index|[
name|i
index|]
expr_stmt|;
name|p
operator|.
name|constraint
operator|=
name|old
operator|.
name|constraint
expr_stmt|;
name|delete
argument_list|(
name|s
operator|->
name|elems
index|[
name|i
index|]
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|visited
index|[
name|old
operator|.
name|index
index|]
condition|)
block|{
operator|--
name|i
expr_stmt|;
continue|continue;
block|}
name|visited
index|[
name|old
operator|.
name|index
index|]
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|tokens
index|[
name|old
operator|.
name|index
index|]
condition|)
block|{
case|case
name|BEGLINE
case|:
name|p
operator|.
name|constraint
operator|&=
name|BEGLINE_CONSTRAINT
expr_stmt|;
break|break;
case|case
name|ENDLINE
case|:
name|p
operator|.
name|constraint
operator|&=
name|ENDLINE_CONSTRAINT
expr_stmt|;
break|break;
case|case
name|BEGWORD
case|:
name|p
operator|.
name|constraint
operator|&=
name|BEGWORD_CONSTRAINT
expr_stmt|;
break|break;
case|case
name|ENDWORD
case|:
name|p
operator|.
name|constraint
operator|&=
name|ENDWORD_CONSTRAINT
expr_stmt|;
break|break;
case|case
name|LIMWORD
case|:
name|p
operator|.
name|constraint
operator|&=
name|LIMWORD_CONSTRAINT
expr_stmt|;
break|break;
case|case
name|NOTLIMWORD
case|:
name|p
operator|.
name|constraint
operator|&=
name|NOTLIMWORD_CONSTRAINT
expr_stmt|;
break|break;
default|default:
break|break;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|d
operator|->
name|follows
index|[
name|old
operator|.
name|index
index|]
operator|.
name|nelem
condition|;
operator|++
name|j
control|)
block|{
name|p
operator|.
name|index
operator|=
name|d
operator|->
name|follows
index|[
name|old
operator|.
name|index
index|]
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|index
expr_stmt|;
name|insert
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* Force rescan to start at the beginning. */
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|visited
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform bottom-up analysis on the parse tree, computing various functions.    Note that at this point, we're pretending constructs like \< are real    characters rather than constraints on what can follow them.     Nullable:  A node is nullable if it is at the root of a regexp that can    match the empty string.    *  EMPTY leaves are nullable.    * No other leaf is nullable.    * A QMARK or STAR node is nullable.    * A PLUS node is nullable if its argument is nullable.    * A CAT node is nullable if both its arguments are nullable.    * An OR node is nullable if either argument is nullable.     Firstpos:  The firstpos of a node is the set of positions (nonempty leaves)    that could correspond to the first character of a string matching the    regexp rooted at the given node.    * EMPTY leaves have empty firstpos.    * The firstpos of a nonempty leaf is that leaf itself.    * The firstpos of a QMARK, STAR, or PLUS node is the firstpos of its      argument.    * The firstpos of a CAT node is the firstpos of the left argument, union      the firstpos of the right if the left argument is nullable.    * The firstpos of an OR node is the union of firstpos of each argument.     Lastpos:  The lastpos of a node is the set of positions that could    correspond to the last character of a string matching the regexp at    the given node.    * EMPTY leaves have empty lastpos.    * The lastpos of a nonempty leaf is that leaf itself.    * The lastpos of a QMARK, STAR, or PLUS node is the lastpos of its      argument.    * The lastpos of a CAT node is the lastpos of its right argument, union      the lastpos of the left if the right argument is nullable.    * The lastpos of an OR node is the union of the lastpos of each argument.     Follow:  The follow of a position is the set of positions that could    correspond to the character following a character matching the node in    a string matching the regexp.  At this point we consider special symbols    that match the empty string in some context to be just normal characters.    Later, if we find that a special symbol is in a follow set, we will    replace it with the elements of its follow, labeled with an appropriate    constraint.    * Every node in the firstpos of the argument of a STAR or PLUS node is in      the follow of every node in the lastpos.    * Every node in the firstpos of the second argument of a CAT node is in      the follow of every node in the lastpos of the first argument.     Because of the postfix representation of the parse tree, the depth-first    analysis is conveniently done by a linear scan with the aid of a stack.    Sets are stored as arrays of the elements, obeying a stack-like allocation    scheme; the number of elements in each set deeper in the stack can be    used to determine the address of a particular set's array. */
end_comment

begin_function
name|void
name|dfaanalyze
parameter_list|(
name|struct
name|dfa
modifier|*
name|d
parameter_list|,
name|int
name|searchflag
parameter_list|)
block|{
name|int
modifier|*
name|nullable
decl_stmt|;
comment|/* Nullable stack. */
name|int
modifier|*
name|nfirstpos
decl_stmt|;
comment|/* Element count stack for firstpos sets. */
name|position
modifier|*
name|firstpos
decl_stmt|;
comment|/* Array where firstpos elements are stored. */
name|int
modifier|*
name|nlastpos
decl_stmt|;
comment|/* Element count stack for lastpos sets. */
name|position
modifier|*
name|lastpos
decl_stmt|;
comment|/* Array where lastpos elements are stored. */
name|int
modifier|*
name|nalloc
decl_stmt|;
comment|/* Sizes of arrays allocated to follow sets. */
name|position_set
name|tmp
decl_stmt|;
comment|/* Temporary set for merging sets. */
name|position_set
name|merged
decl_stmt|;
comment|/* Result of merging sets. */
name|int
name|wants_newline
decl_stmt|;
comment|/* True if some position wants newline info. */
name|int
modifier|*
name|o_nullable
decl_stmt|;
name|int
modifier|*
name|o_nfirst
decl_stmt|,
modifier|*
name|o_nlast
decl_stmt|;
name|position
modifier|*
name|o_firstpos
decl_stmt|,
modifier|*
name|o_lastpos
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|position
modifier|*
name|pos
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dfaanalyze:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|d
operator|->
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|searchflag
operator|=
name|searchflag
expr_stmt|;
name|MALLOC
argument_list|(
name|nullable
argument_list|,
name|int
argument_list|,
name|d
operator|->
name|depth
argument_list|)
expr_stmt|;
name|o_nullable
operator|=
name|nullable
expr_stmt|;
name|MALLOC
argument_list|(
name|nfirstpos
argument_list|,
name|int
argument_list|,
name|d
operator|->
name|depth
argument_list|)
expr_stmt|;
name|o_nfirst
operator|=
name|nfirstpos
expr_stmt|;
name|MALLOC
argument_list|(
name|firstpos
argument_list|,
name|position
argument_list|,
name|d
operator|->
name|nleaves
argument_list|)
expr_stmt|;
name|o_firstpos
operator|=
name|firstpos
operator|,
name|firstpos
operator|+=
name|d
operator|->
name|nleaves
expr_stmt|;
name|MALLOC
argument_list|(
name|nlastpos
argument_list|,
name|int
argument_list|,
name|d
operator|->
name|depth
argument_list|)
expr_stmt|;
name|o_nlast
operator|=
name|nlastpos
expr_stmt|;
name|MALLOC
argument_list|(
name|lastpos
argument_list|,
name|position
argument_list|,
name|d
operator|->
name|nleaves
argument_list|)
expr_stmt|;
name|o_lastpos
operator|=
name|lastpos
operator|,
name|lastpos
operator|+=
name|d
operator|->
name|nleaves
expr_stmt|;
name|MALLOC
argument_list|(
name|nalloc
argument_list|,
name|int
argument_list|,
name|d
operator|->
name|tindex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
name|nalloc
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|MALLOC
argument_list|(
name|merged
operator|.
name|elems
argument_list|,
name|position
argument_list|,
name|d
operator|->
name|nleaves
argument_list|)
expr_stmt|;
name|CALLOC
argument_list|(
name|d
operator|->
name|follows
argument_list|,
name|position_set
argument_list|,
name|d
operator|->
name|tindex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
ifdef|#
directive|ifdef
name|DEBUG
block|{
comment|/* Nonsyntactic #ifdef goo... */
endif|#
directive|endif
switch|switch
condition|(
name|d
operator|->
name|tokens
index|[
name|i
index|]
condition|)
block|{
case|case
name|EMPTY
case|:
comment|/* The empty set is nullable. */
operator|*
name|nullable
operator|++
operator|=
literal|1
expr_stmt|;
comment|/* The firstpos and lastpos of the empty leaf are both empty. */
operator|*
name|nfirstpos
operator|++
operator|=
operator|*
name|nlastpos
operator|++
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|STAR
case|:
case|case
name|PLUS
case|:
comment|/* Every element in the firstpos of the argument is in the follow 	   of every element in the lastpos. */
name|tmp
operator|.
name|nelem
operator|=
name|nfirstpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|tmp
operator|.
name|elems
operator|=
name|firstpos
expr_stmt|;
name|pos
operator|=
name|lastpos
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nlastpos
index|[
operator|-
literal|1
index|]
condition|;
operator|++
name|j
control|)
block|{
name|merge
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|d
operator|->
name|follows
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|,
operator|&
name|merged
argument_list|)
expr_stmt|;
name|REALLOC_IF_NECESSARY
argument_list|(
name|d
operator|->
name|follows
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
operator|.
name|elems
argument_list|,
name|position
argument_list|,
name|nalloc
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|,
name|merged
operator|.
name|nelem
operator|-
literal|1
argument_list|)
expr_stmt|;
name|copy
argument_list|(
operator|&
name|merged
argument_list|,
operator|&
name|d
operator|->
name|follows
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|)
expr_stmt|;
block|}
case|case
name|QMARK
case|:
comment|/* A QMARK or STAR node is automatically nullable. */
if|if
condition|(
name|d
operator|->
name|tokens
index|[
name|i
index|]
operator|!=
name|PLUS
condition|)
name|nullable
index|[
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CAT
case|:
comment|/* Every element in the firstpos of the second argument is in the 	   follow of every element in the lastpos of the first argument. */
name|tmp
operator|.
name|nelem
operator|=
name|nfirstpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|tmp
operator|.
name|elems
operator|=
name|firstpos
expr_stmt|;
name|pos
operator|=
name|lastpos
operator|+
name|nlastpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nlastpos
index|[
operator|-
literal|2
index|]
condition|;
operator|++
name|j
control|)
block|{
name|merge
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|d
operator|->
name|follows
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|,
operator|&
name|merged
argument_list|)
expr_stmt|;
name|REALLOC_IF_NECESSARY
argument_list|(
name|d
operator|->
name|follows
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
operator|.
name|elems
argument_list|,
name|position
argument_list|,
name|nalloc
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|,
name|merged
operator|.
name|nelem
operator|-
literal|1
argument_list|)
expr_stmt|;
name|copy
argument_list|(
operator|&
name|merged
argument_list|,
operator|&
name|d
operator|->
name|follows
index|[
name|pos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* The firstpos of a CAT node is the firstpos of the first argument, 	   union that of the second argument if the first is nullable. */
if|if
condition|(
name|nullable
index|[
operator|-
literal|2
index|]
condition|)
name|nfirstpos
index|[
operator|-
literal|2
index|]
operator|+=
name|nfirstpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|firstpos
operator|+=
name|nfirstpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
operator|--
name|nfirstpos
expr_stmt|;
comment|/* The lastpos of a CAT node is the lastpos of the second argument, 	   union that of the first argument if the second is nullable. */
if|if
condition|(
name|nullable
index|[
operator|-
literal|1
index|]
condition|)
name|nlastpos
index|[
operator|-
literal|2
index|]
operator|+=
name|nlastpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
else|else
block|{
name|pos
operator|=
name|lastpos
operator|+
name|nlastpos
index|[
operator|-
literal|2
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|nlastpos
index|[
operator|-
literal|1
index|]
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
name|pos
index|[
name|j
index|]
operator|=
name|lastpos
index|[
name|j
index|]
expr_stmt|;
name|lastpos
operator|+=
name|nlastpos
index|[
operator|-
literal|2
index|]
expr_stmt|;
name|nlastpos
index|[
operator|-
literal|2
index|]
operator|=
name|nlastpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
operator|--
name|nlastpos
expr_stmt|;
comment|/* A CAT node is nullable if both arguments are nullable. */
name|nullable
index|[
operator|-
literal|2
index|]
operator|=
name|nullable
index|[
operator|-
literal|1
index|]
operator|&&
name|nullable
index|[
operator|-
literal|2
index|]
expr_stmt|;
operator|--
name|nullable
expr_stmt|;
break|break;
case|case
name|OR
case|:
case|case
name|ORTOP
case|:
comment|/* The firstpos is the union of the firstpos of each argument. */
name|nfirstpos
index|[
operator|-
literal|2
index|]
operator|+=
name|nfirstpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
operator|--
name|nfirstpos
expr_stmt|;
comment|/* The lastpos is the union of the lastpos of each argument. */
name|nlastpos
index|[
operator|-
literal|2
index|]
operator|+=
name|nlastpos
index|[
operator|-
literal|1
index|]
expr_stmt|;
operator|--
name|nlastpos
expr_stmt|;
comment|/* An OR node is nullable if either argument is nullable. */
name|nullable
index|[
operator|-
literal|2
index|]
operator|=
name|nullable
index|[
operator|-
literal|1
index|]
operator|||
name|nullable
index|[
operator|-
literal|2
index|]
expr_stmt|;
operator|--
name|nullable
expr_stmt|;
break|break;
default|default:
comment|/* Anything else is a nonempty position.  (Note that special 	   constructs like \< are treated as nonempty strings here; 	   an "epsilon closure" effectively makes them nullable later. 	   Backreferences have to get a real position so we can detect 	   transitions on them later.  But they are nullable. */
operator|*
name|nullable
operator|++
operator|=
name|d
operator|->
name|tokens
index|[
name|i
index|]
operator|==
name|BACKREF
expr_stmt|;
comment|/* This position is in its own firstpos and lastpos. */
operator|*
name|nfirstpos
operator|++
operator|=
operator|*
name|nlastpos
operator|++
operator|=
literal|1
expr_stmt|;
operator|--
name|firstpos
operator|,
operator|--
name|lastpos
expr_stmt|;
name|firstpos
operator|->
name|index
operator|=
name|lastpos
operator|->
name|index
operator|=
name|i
expr_stmt|;
name|firstpos
operator|->
name|constraint
operator|=
name|lastpos
operator|->
name|constraint
operator|=
name|NO_CONSTRAINT
expr_stmt|;
comment|/* Allocate the follow set for this position. */
name|nalloc
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|MALLOC
argument_list|(
name|d
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|elems
argument_list|,
name|position
argument_list|,
name|nalloc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
comment|/* ... balance the above nonsyntactic #ifdef goo... */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"node %d:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|d
operator|->
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|nullable
index|[
operator|-
literal|1
index|]
condition|?
literal|" nullable: yes\n"
else|:
literal|" nullable: no\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" firstpos:"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|nfirstpos
index|[
operator|-
literal|1
index|]
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d:"
argument_list|,
name|firstpos
index|[
name|j
index|]
operator|.
name|index
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|d
operator|->
name|tokens
index|[
name|firstpos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n lastpos:"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|nlastpos
index|[
operator|-
literal|1
index|]
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d:"
argument_list|,
name|lastpos
index|[
name|j
index|]
operator|.
name|index
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|d
operator|->
name|tokens
index|[
name|lastpos
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* For each follow set that is the follow set of a real position, replace      it with its epsilon closure. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|d
operator|->
name|tokens
index|[
name|i
index|]
operator|<
name|NOTCHAR
operator|||
name|d
operator|->
name|tokens
index|[
name|i
index|]
operator|==
name|BACKREF
ifdef|#
directive|ifdef
name|MBS_SUPPORT
operator|||
name|d
operator|->
name|tokens
index|[
name|i
index|]
operator|==
name|ANYCHAR
operator|||
name|d
operator|->
name|tokens
index|[
name|i
index|]
operator|==
name|MBCSET
endif|#
directive|endif
operator|||
name|d
operator|->
name|tokens
index|[
name|i
index|]
operator|>=
name|CSET
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"follows(%d:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|d
operator|->
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"):"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|d
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|nelem
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d:"
argument_list|,
name|d
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|index
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|d
operator|->
name|tokens
index|[
name|d
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|index
index|]
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|copy
argument_list|(
operator|&
name|d
operator|->
name|follows
index|[
name|i
index|]
argument_list|,
operator|&
name|merged
argument_list|)
expr_stmt|;
name|epsclosure
argument_list|(
operator|&
name|merged
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|nelem
operator|<
name|merged
operator|.
name|nelem
condition|)
name|REALLOC
argument_list|(
name|d
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|elems
argument_list|,
name|position
argument_list|,
name|merged
operator|.
name|nelem
argument_list|)
expr_stmt|;
name|copy
argument_list|(
operator|&
name|merged
argument_list|,
operator|&
name|d
operator|->
name|follows
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Get the epsilon closure of the firstpos of the regexp.  The result will      be the set of positions of state 0. */
name|merged
operator|.
name|nelem
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfirstpos
index|[
operator|-
literal|1
index|]
condition|;
operator|++
name|i
control|)
name|insert
argument_list|(
name|firstpos
index|[
name|i
index|]
argument_list|,
operator|&
name|merged
argument_list|)
expr_stmt|;
name|epsclosure
argument_list|(
operator|&
name|merged
argument_list|,
name|d
argument_list|)
expr_stmt|;
comment|/* Check if any of the positions of state 0 will want newline context. */
name|wants_newline
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|merged
operator|.
name|nelem
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|PREV_NEWLINE_DEPENDENT
argument_list|(
name|merged
operator|.
name|elems
index|[
name|i
index|]
operator|.
name|constraint
argument_list|)
condition|)
name|wants_newline
operator|=
literal|1
expr_stmt|;
comment|/* Build the initial state. */
name|d
operator|->
name|salloc
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|sindex
operator|=
literal|0
expr_stmt|;
name|MALLOC
argument_list|(
name|d
operator|->
name|states
argument_list|,
name|dfa_state
argument_list|,
name|d
operator|->
name|salloc
argument_list|)
expr_stmt|;
name|state_index
argument_list|(
name|d
argument_list|,
operator|&
name|merged
argument_list|,
name|wants_newline
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|o_nullable
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|o_nfirst
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|o_firstpos
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|o_nlast
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|o_lastpos
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nalloc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|merged
operator|.
name|elems
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find, for each character, the transition out of state s of d, and store    it in the appropriate slot of trans.     We divide the positions of s into groups (positions can appear in more    than one group).  Each group is labeled with a set of characters that    every position in the group matches (taking into account, if necessary,    preceding context information of s).  For each group, find the union    of the its elements' follows.  This set is the set of positions of the    new state.  For each character in the group's label, set the transition    on this character to be to a state corresponding to the set's positions,    and its associated backward context information, if necessary.     If we are building a searching matcher, we include the positions of state    0 in every state.     The collection of groups is constructed by building an equivalence-class    partition of the positions of s.     For each position, find the set of characters C that it matches.  Eliminate    any characters from C that fail on grounds of backward context.     Search through the groups, looking for a group whose label L has nonempty    intersection with C.  If L - C is nonempty, create a new group labeled    L - C and having the same positions as the current group, and set L to    the intersection of L and C.  Insert the position in this group, set    C = C - L, and resume scanning.     If after comparing with every group there are characters remaining in C,    create a new group labeled with the characters of C and insert this    position in that group. */
end_comment

begin_function
name|void
name|dfastate
parameter_list|(
name|int
name|s
parameter_list|,
name|struct
name|dfa
modifier|*
name|d
parameter_list|,
name|int
name|trans
index|[]
parameter_list|)
block|{
name|position_set
name|grps
index|[
name|NOTCHAR
index|]
decl_stmt|;
comment|/* As many as will ever be needed. */
name|charclass
name|labels
index|[
name|NOTCHAR
index|]
decl_stmt|;
comment|/* Labels corresponding to the groups. */
name|int
name|ngrps
init|=
literal|0
decl_stmt|;
comment|/* Number of groups actually used. */
name|position
name|pos
decl_stmt|;
comment|/* Current position being considered. */
name|charclass
name|matches
decl_stmt|;
comment|/* Set of matching characters. */
name|int
name|matchesf
decl_stmt|;
comment|/* True if matches is nonempty. */
name|charclass
name|intersect
decl_stmt|;
comment|/* Intersection with some label set. */
name|int
name|intersectf
decl_stmt|;
comment|/* True if intersect is nonempty. */
name|charclass
name|leftovers
decl_stmt|;
comment|/* Stuff in the label that didn't match. */
name|int
name|leftoversf
decl_stmt|;
comment|/* True if leftovers is nonempty. */
specifier|static
name|charclass
name|letters
decl_stmt|;
comment|/* Set of characters considered letters. */
specifier|static
name|charclass
name|newline
decl_stmt|;
comment|/* Set of characters that aren't newline. */
name|position_set
name|follows
decl_stmt|;
comment|/* Union of the follows of some group. */
name|position_set
name|tmp
decl_stmt|;
comment|/* Temporary space for merging sets. */
name|int
name|state
decl_stmt|;
comment|/* New state. */
name|int
name|wants_newline
decl_stmt|;
comment|/* New state wants to know newline context. */
name|int
name|state_newline
decl_stmt|;
comment|/* New state on a newline transition. */
name|int
name|wants_letter
decl_stmt|;
comment|/* New state wants to know letter context. */
name|int
name|state_letter
decl_stmt|;
comment|/* New state on a letter transition. */
specifier|static
name|int
name|initialized
decl_stmt|;
comment|/* Flag for static initialization. */
ifdef|#
directive|ifdef
name|MBS_SUPPORT
name|int
name|next_isnt_1st_byte
init|=
literal|0
decl_stmt|;
comment|/* Flag If we can't add state0.  */
endif|#
directive|endif
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
comment|/* Initialize the set of letters, if necessary. */
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|initialized
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOTCHAR
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|IS_WORD_CONSTITUENT
argument_list|(
name|i
argument_list|)
condition|)
name|setbit
argument_list|(
name|i
argument_list|,
name|letters
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|eolbyte
argument_list|,
name|newline
argument_list|)
expr_stmt|;
block|}
name|zeroset
argument_list|(
name|matches
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|elems
operator|.
name|nelem
condition|;
operator|++
name|i
control|)
block|{
name|pos
operator|=
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|elems
operator|.
name|elems
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
operator|>=
literal|0
operator|&&
name|d
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
operator|<
name|NOTCHAR
condition|)
name|setbit
argument_list|(
name|d
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
argument_list|,
name|matches
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
operator|>=
name|CSET
condition|)
name|copyset
argument_list|(
name|d
operator|->
name|charclasses
index|[
name|d
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
operator|-
name|CSET
index|]
argument_list|,
name|matches
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
elseif|else
if|if
condition|(
name|d
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
operator|==
name|ANYCHAR
operator|||
name|d
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
operator|==
name|MBCSET
condition|)
comment|/* MB_CUR_MAX> 1  */
block|{
comment|/* ANYCHAR and MBCSET must match with a single character, so we 	     must put it to d->states[s].mbps, which contains the positions 	     which can match with a single character not a byte.  */
if|if
condition|(
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|mbps
operator|.
name|nelem
operator|==
literal|0
condition|)
block|{
name|MALLOC
argument_list|(
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|mbps
operator|.
name|elems
argument_list|,
name|position
argument_list|,
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|elems
operator|.
name|nelem
argument_list|)
expr_stmt|;
block|}
name|insert
argument_list|(
name|pos
argument_list|,
operator|&
operator|(
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|mbps
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* MBS_SUPPORT */
else|else
continue|continue;
comment|/* Some characters may need to be eliminated from matches because 	 they fail in the current context. */
if|if
condition|(
name|pos
operator|.
name|constraint
operator|!=
literal|0xFF
condition|)
block|{
if|if
condition|(
operator|!
name|MATCHES_NEWLINE_CONTEXT
argument_list|(
name|pos
operator|.
name|constraint
argument_list|,
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|newline
argument_list|,
literal|1
argument_list|)
condition|)
name|clrbit
argument_list|(
name|eolbyte
argument_list|,
name|matches
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MATCHES_NEWLINE_CONTEXT
argument_list|(
name|pos
operator|.
name|constraint
argument_list|,
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|newline
argument_list|,
literal|0
argument_list|)
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CHARCLASS_INTS
condition|;
operator|++
name|j
control|)
name|matches
index|[
name|j
index|]
operator|&=
name|newline
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|MATCHES_LETTER_CONTEXT
argument_list|(
name|pos
operator|.
name|constraint
argument_list|,
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|letter
argument_list|,
literal|1
argument_list|)
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CHARCLASS_INTS
condition|;
operator|++
name|j
control|)
name|matches
index|[
name|j
index|]
operator|&=
operator|~
name|letters
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|MATCHES_LETTER_CONTEXT
argument_list|(
name|pos
operator|.
name|constraint
argument_list|,
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|letter
argument_list|,
literal|0
argument_list|)
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CHARCLASS_INTS
condition|;
operator|++
name|j
control|)
name|matches
index|[
name|j
index|]
operator|&=
name|letters
index|[
name|j
index|]
expr_stmt|;
comment|/* If there are no characters left, there's no point in going on. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CHARCLASS_INTS
operator|&&
operator|!
name|matches
index|[
name|j
index|]
condition|;
operator|++
name|j
control|)
continue|continue;
if|if
condition|(
name|j
operator|==
name|CHARCLASS_INTS
condition|)
continue|continue;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ngrps
condition|;
operator|++
name|j
control|)
block|{
comment|/* If matches contains a single character only, and the current 	     group's label doesn't contain that character, go on to the 	     next group. */
if|if
condition|(
name|d
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
operator|>=
literal|0
operator|&&
name|d
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
operator|<
name|NOTCHAR
operator|&&
operator|!
name|tstbit
argument_list|(
name|d
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
argument_list|,
name|labels
index|[
name|j
index|]
argument_list|)
condition|)
continue|continue;
comment|/* Check if this group's label has a nonempty intersection with 	     matches. */
name|intersectf
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|CHARCLASS_INTS
condition|;
operator|++
name|k
control|)
operator|(
name|intersect
index|[
name|k
index|]
operator|=
name|matches
index|[
name|k
index|]
operator|&
name|labels
index|[
name|j
index|]
index|[
name|k
index|]
operator|)
condition|?
operator|(
name|intersectf
operator|=
literal|1
operator|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|intersectf
condition|)
continue|continue;
comment|/* It does; now find the set differences both ways. */
name|leftoversf
operator|=
name|matchesf
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|CHARCLASS_INTS
condition|;
operator|++
name|k
control|)
block|{
comment|/* Even an optimizing compiler can't know this for sure. */
name|int
name|match
init|=
name|matches
index|[
name|k
index|]
decl_stmt|,
name|label
init|=
name|labels
index|[
name|j
index|]
index|[
name|k
index|]
decl_stmt|;
operator|(
name|leftovers
index|[
name|k
index|]
operator|=
operator|~
name|match
operator|&
name|label
operator|)
condition|?
operator|(
name|leftoversf
operator|=
literal|1
operator|)
else|:
literal|0
expr_stmt|;
operator|(
name|matches
index|[
name|k
index|]
operator|=
name|match
operator|&
operator|~
name|label
operator|)
condition|?
operator|(
name|matchesf
operator|=
literal|1
operator|)
else|:
literal|0
expr_stmt|;
block|}
comment|/* If there were leftovers, create a new group labeled with them. */
if|if
condition|(
name|leftoversf
condition|)
block|{
name|copyset
argument_list|(
name|leftovers
argument_list|,
name|labels
index|[
name|ngrps
index|]
argument_list|)
expr_stmt|;
name|copyset
argument_list|(
name|intersect
argument_list|,
name|labels
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|grps
index|[
name|ngrps
index|]
operator|.
name|elems
argument_list|,
name|position
argument_list|,
name|d
operator|->
name|nleaves
argument_list|)
expr_stmt|;
name|copy
argument_list|(
operator|&
name|grps
index|[
name|j
index|]
argument_list|,
operator|&
name|grps
index|[
name|ngrps
index|]
argument_list|)
expr_stmt|;
operator|++
name|ngrps
expr_stmt|;
block|}
comment|/* Put the position in the current group.  Note that there is no 	     reason to call insert() here. */
name|grps
index|[
name|j
index|]
operator|.
name|elems
index|[
name|grps
index|[
name|j
index|]
operator|.
name|nelem
operator|++
index|]
operator|=
name|pos
expr_stmt|;
comment|/* If every character matching the current position has been 	     accounted for, we're done. */
if|if
condition|(
operator|!
name|matchesf
condition|)
break|break;
block|}
comment|/* If we've passed the last group, and there are still characters 	 unaccounted for, then we'll have to create a new group. */
if|if
condition|(
name|j
operator|==
name|ngrps
condition|)
block|{
name|copyset
argument_list|(
name|matches
argument_list|,
name|labels
index|[
name|ngrps
index|]
argument_list|)
expr_stmt|;
name|zeroset
argument_list|(
name|matches
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|grps
index|[
name|ngrps
index|]
operator|.
name|elems
argument_list|,
name|position
argument_list|,
name|d
operator|->
name|nleaves
argument_list|)
expr_stmt|;
name|grps
index|[
name|ngrps
index|]
operator|.
name|nelem
operator|=
literal|1
expr_stmt|;
name|grps
index|[
name|ngrps
index|]
operator|.
name|elems
index|[
literal|0
index|]
operator|=
name|pos
expr_stmt|;
operator|++
name|ngrps
expr_stmt|;
block|}
block|}
name|MALLOC
argument_list|(
name|follows
operator|.
name|elems
argument_list|,
name|position
argument_list|,
name|d
operator|->
name|nleaves
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|tmp
operator|.
name|elems
argument_list|,
name|position
argument_list|,
name|d
operator|->
name|nleaves
argument_list|)
expr_stmt|;
comment|/* If we are a searching matcher, the default transition is to a state      containing the positions of state 0, otherwise the default transition      is to fail miserably. */
if|if
condition|(
name|d
operator|->
name|searchflag
condition|)
block|{
name|wants_newline
operator|=
literal|0
expr_stmt|;
name|wants_letter
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|states
index|[
literal|0
index|]
operator|.
name|elems
operator|.
name|nelem
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|PREV_NEWLINE_DEPENDENT
argument_list|(
name|d
operator|->
name|states
index|[
literal|0
index|]
operator|.
name|elems
operator|.
name|elems
index|[
name|i
index|]
operator|.
name|constraint
argument_list|)
condition|)
name|wants_newline
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|PREV_LETTER_DEPENDENT
argument_list|(
name|d
operator|->
name|states
index|[
literal|0
index|]
operator|.
name|elems
operator|.
name|elems
index|[
name|i
index|]
operator|.
name|constraint
argument_list|)
condition|)
name|wants_letter
operator|=
literal|1
expr_stmt|;
block|}
name|copy
argument_list|(
operator|&
name|d
operator|->
name|states
index|[
literal|0
index|]
operator|.
name|elems
argument_list|,
operator|&
name|follows
argument_list|)
expr_stmt|;
name|state
operator|=
name|state_index
argument_list|(
name|d
argument_list|,
operator|&
name|follows
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wants_newline
condition|)
name|state_newline
operator|=
name|state_index
argument_list|(
name|d
argument_list|,
operator|&
name|follows
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|state_newline
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|wants_letter
condition|)
name|state_letter
operator|=
name|state_index
argument_list|(
name|d
argument_list|,
operator|&
name|follows
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|state_letter
operator|=
name|state
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOTCHAR
condition|;
operator|++
name|i
control|)
name|trans
index|[
name|i
index|]
operator|=
operator|(
name|IS_WORD_CONSTITUENT
argument_list|(
name|i
argument_list|)
operator|)
condition|?
name|state_letter
else|:
name|state
expr_stmt|;
name|trans
index|[
name|eolbyte
index|]
operator|=
name|state_newline
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOTCHAR
condition|;
operator|++
name|i
control|)
name|trans
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngrps
condition|;
operator|++
name|i
control|)
block|{
name|follows
operator|.
name|nelem
operator|=
literal|0
expr_stmt|;
comment|/* Find the union of the follows of the positions of the group. 	 This is a hideously inefficient loop.  Fix it someday. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|grps
index|[
name|i
index|]
operator|.
name|nelem
condition|;
operator|++
name|j
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|d
operator|->
name|follows
index|[
name|grps
index|[
name|i
index|]
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|index
index|]
operator|.
name|nelem
condition|;
operator|++
name|k
control|)
name|insert
argument_list|(
name|d
operator|->
name|follows
index|[
name|grps
index|[
name|i
index|]
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|index
index|]
operator|.
name|elems
index|[
name|k
index|]
argument_list|,
operator|&
name|follows
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
condition|)
block|{
comment|/* If a token in follows.elems is not 1st byte of a multibyte 	     character, or the states of follows must accept the bytes 	     which are not 1st byte of the multibyte character. 	     Then, if a state of follows encounter a byte, it must not be 	     a 1st byte of a multibyte character nor singlebyte character. 	     We cansel to add state[0].follows to next state, because 	     state[0] must accept 1st-byte  	     For example, we assume<sb a> is a certain singlebyte 	     character,<mb A> is a certain multibyte character, and the 	     codepoint of<sb a> equals the 2nd byte of the codepoint of<mb A>. 	     When state[0] accepts<sb a>, state[i] transit to state[i+1] 	     by accepting accepts 1st byte of<mb A>, and state[i+1] 	     accepts 2nd byte of<mb A>, if state[i+1] encounter the 	     codepoint of<sb a>, it must not be<sb a> but 2nd byte of<mb A>, so we can not add state[0].  */
name|next_isnt_1st_byte
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|follows
operator|.
name|nelem
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|multibyte_prop
index|[
name|follows
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|index
index|]
operator|&
literal|1
operator|)
condition|)
block|{
name|next_isnt_1st_byte
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* If we are building a searching matcher, throw in the positions 	 of state 0 as well. */
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|d
operator|->
name|searchflag
operator|&&
operator|(
name|MB_CUR_MAX
operator|==
literal|1
operator|||
operator|!
name|next_isnt_1st_byte
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|d
operator|->
name|searchflag
condition|)
endif|#
directive|endif
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|d
operator|->
name|states
index|[
literal|0
index|]
operator|.
name|elems
operator|.
name|nelem
condition|;
operator|++
name|j
control|)
name|insert
argument_list|(
name|d
operator|->
name|states
index|[
literal|0
index|]
operator|.
name|elems
operator|.
name|elems
index|[
name|j
index|]
argument_list|,
operator|&
name|follows
argument_list|)
expr_stmt|;
comment|/* Find out if the new state will want any context information. */
name|wants_newline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tstbit
argument_list|(
name|eolbyte
argument_list|,
name|labels
index|[
name|i
index|]
argument_list|)
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|follows
operator|.
name|nelem
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|PREV_NEWLINE_DEPENDENT
argument_list|(
name|follows
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|constraint
argument_list|)
condition|)
name|wants_newline
operator|=
literal|1
expr_stmt|;
name|wants_letter
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CHARCLASS_INTS
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|labels
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
name|letters
index|[
name|j
index|]
condition|)
break|break;
if|if
condition|(
name|j
operator|<
name|CHARCLASS_INTS
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|follows
operator|.
name|nelem
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|PREV_LETTER_DEPENDENT
argument_list|(
name|follows
operator|.
name|elems
index|[
name|j
index|]
operator|.
name|constraint
argument_list|)
condition|)
name|wants_letter
operator|=
literal|1
expr_stmt|;
comment|/* Find the state(s) corresponding to the union of the follows. */
name|state
operator|=
name|state_index
argument_list|(
name|d
argument_list|,
operator|&
name|follows
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wants_newline
condition|)
name|state_newline
operator|=
name|state_index
argument_list|(
name|d
argument_list|,
operator|&
name|follows
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|state_newline
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|wants_letter
condition|)
name|state_letter
operator|=
name|state_index
argument_list|(
name|d
argument_list|,
operator|&
name|follows
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|state_letter
operator|=
name|state
expr_stmt|;
comment|/* Set the transitions for each character in the current label. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CHARCLASS_INTS
condition|;
operator|++
name|j
control|)
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|INTBITS
condition|;
operator|++
name|k
control|)
if|if
condition|(
name|labels
index|[
name|i
index|]
index|[
name|j
index|]
operator|&
literal|1
operator|<<
name|k
condition|)
block|{
name|int
name|c
init|=
name|j
operator|*
name|INTBITS
operator|+
name|k
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|eolbyte
condition|)
name|trans
index|[
name|c
index|]
operator|=
name|state_newline
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_WORD_CONSTITUENT
argument_list|(
name|c
argument_list|)
condition|)
name|trans
index|[
name|c
index|]
operator|=
name|state_letter
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
name|NOTCHAR
condition|)
name|trans
index|[
name|c
index|]
operator|=
name|state
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngrps
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
name|grps
index|[
name|i
index|]
operator|.
name|elems
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|follows
operator|.
name|elems
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
operator|.
name|elems
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Some routines for manipulating a compiled dfa's transition tables.    Each state may or may not have a transition table; if it does, and it    is a non-accepting state, then d->trans[state] points to its table.    If it is an accepting state then d->fails[state] points to its table.    If it has no table at all, then d->trans[state] is NULL.    TODO: Improve this comment, get rid of the unnecessary redundancy. */
end_comment

begin_function
specifier|static
name|void
name|build_state
parameter_list|(
name|int
name|s
parameter_list|,
name|struct
name|dfa
modifier|*
name|d
parameter_list|)
block|{
name|int
modifier|*
name|trans
decl_stmt|;
comment|/* The new transition table. */
name|int
name|i
decl_stmt|;
comment|/* Set an upper limit on the number of transition tables that will ever      exist at once.  1024 is arbitrary.  The idea is that the frequently      used transition tables will be quickly rebuilt, whereas the ones that      were only needed once or twice will be cleared away. */
if|if
condition|(
name|d
operator|->
name|trcount
operator|>=
literal|1024
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|tralloc
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|d
operator|->
name|trans
index|[
name|i
index|]
condition|)
block|{
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|trans
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|d
operator|->
name|trans
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|fails
index|[
name|i
index|]
condition|)
block|{
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|fails
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|d
operator|->
name|fails
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|d
operator|->
name|trcount
operator|=
literal|0
expr_stmt|;
block|}
operator|++
name|d
operator|->
name|trcount
expr_stmt|;
comment|/* Set up the success bits for this state. */
name|d
operator|->
name|success
index|[
name|s
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ACCEPTS_IN_CONTEXT
argument_list|(
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|newline
argument_list|,
literal|1
argument_list|,
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|letter
argument_list|,
literal|0
argument_list|,
name|s
argument_list|,
operator|*
name|d
argument_list|)
condition|)
name|d
operator|->
name|success
index|[
name|s
index|]
operator||=
literal|4
expr_stmt|;
if|if
condition|(
name|ACCEPTS_IN_CONTEXT
argument_list|(
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|newline
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|letter
argument_list|,
literal|1
argument_list|,
name|s
argument_list|,
operator|*
name|d
argument_list|)
condition|)
name|d
operator|->
name|success
index|[
name|s
index|]
operator||=
literal|2
expr_stmt|;
if|if
condition|(
name|ACCEPTS_IN_CONTEXT
argument_list|(
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|newline
argument_list|,
literal|0
argument_list|,
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|letter
argument_list|,
literal|0
argument_list|,
name|s
argument_list|,
operator|*
name|d
argument_list|)
condition|)
name|d
operator|->
name|success
index|[
name|s
index|]
operator||=
literal|1
expr_stmt|;
name|MALLOC
argument_list|(
name|trans
argument_list|,
name|int
argument_list|,
name|NOTCHAR
argument_list|)
expr_stmt|;
name|dfastate
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
name|trans
argument_list|)
expr_stmt|;
comment|/* Now go through the new transition table, and make sure that the trans      and fail arrays are allocated large enough to hold a pointer for the      largest state mentioned in the table. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOTCHAR
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|trans
index|[
name|i
index|]
operator|>=
name|d
operator|->
name|tralloc
condition|)
block|{
name|int
name|oldalloc
init|=
name|d
operator|->
name|tralloc
decl_stmt|;
while|while
condition|(
name|trans
index|[
name|i
index|]
operator|>=
name|d
operator|->
name|tralloc
condition|)
name|d
operator|->
name|tralloc
operator|*=
literal|2
expr_stmt|;
name|REALLOC
argument_list|(
name|d
operator|->
name|realtrans
argument_list|,
name|int
operator|*
argument_list|,
name|d
operator|->
name|tralloc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|trans
operator|=
name|d
operator|->
name|realtrans
operator|+
literal|1
expr_stmt|;
name|REALLOC
argument_list|(
name|d
operator|->
name|fails
argument_list|,
name|int
operator|*
argument_list|,
name|d
operator|->
name|tralloc
argument_list|)
expr_stmt|;
name|REALLOC
argument_list|(
name|d
operator|->
name|success
argument_list|,
name|int
argument_list|,
name|d
operator|->
name|tralloc
argument_list|)
expr_stmt|;
while|while
condition|(
name|oldalloc
operator|<
name|d
operator|->
name|tralloc
condition|)
block|{
name|d
operator|->
name|trans
index|[
name|oldalloc
index|]
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|fails
index|[
name|oldalloc
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Newline is a sentinel.  */
name|trans
index|[
name|eolbyte
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ACCEPTING
argument_list|(
name|s
argument_list|,
operator|*
name|d
argument_list|)
condition|)
name|d
operator|->
name|fails
index|[
name|s
index|]
operator|=
name|trans
expr_stmt|;
else|else
name|d
operator|->
name|trans
index|[
name|s
index|]
operator|=
name|trans
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_state_zero
parameter_list|(
name|struct
name|dfa
modifier|*
name|d
parameter_list|)
block|{
name|d
operator|->
name|tralloc
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|trcount
operator|=
literal|0
expr_stmt|;
name|CALLOC
argument_list|(
name|d
operator|->
name|realtrans
argument_list|,
name|int
operator|*
argument_list|,
name|d
operator|->
name|tralloc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|trans
operator|=
name|d
operator|->
name|realtrans
operator|+
literal|1
expr_stmt|;
name|CALLOC
argument_list|(
name|d
operator|->
name|fails
argument_list|,
name|int
operator|*
argument_list|,
name|d
operator|->
name|tralloc
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|d
operator|->
name|success
argument_list|,
name|int
argument_list|,
name|d
operator|->
name|tralloc
argument_list|)
expr_stmt|;
name|build_state
argument_list|(
literal|0
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MBS_SUPPORT
end_ifdef

begin_comment
comment|/* Multibyte character handling sub-routins for dfaexec.  */
end_comment

begin_comment
comment|/* Initial state may encounter the byte which is not a singlebyte character    nor 1st byte of a multibyte character.  But it is incorrect for initial    state to accept such a byte.    For example, in sjis encoding the regular expression like "\\" accepts    the codepoint 0x5c, but should not accept the 2nd byte of the codepoint    0x815c. Then Initial state must skip the bytes which are not a singlebyte    character nor 1st byte of a multibyte character.  */
end_comment

begin_define
define|#
directive|define
name|SKIP_REMAINS_MB_IF_INITIAL_STATE
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|)
define|\
value|if (s == 0)						\     {							\       while (inputwcs[p - buf_begin] == 0		\&& mblen_buf[p - buf_begin]> 0		\&& p< buf_end)				\         ++p;						\       if (p>= end)					\ 	{						\           free(mblen_buf);				\           free(inputwcs);				\ 	  return (size_t) -1;				\ 	}						\     }
end_define

begin_function
specifier|static
name|void
name|realloc_trans_if_necessary
parameter_list|(
name|struct
name|dfa
modifier|*
name|d
parameter_list|,
name|int
name|new_state
parameter_list|)
block|{
comment|/* Make sure that the trans and fail arrays are allocated large enough      to hold a pointer for the new state. */
if|if
condition|(
name|new_state
operator|>=
name|d
operator|->
name|tralloc
condition|)
block|{
name|int
name|oldalloc
init|=
name|d
operator|->
name|tralloc
decl_stmt|;
while|while
condition|(
name|new_state
operator|>=
name|d
operator|->
name|tralloc
condition|)
name|d
operator|->
name|tralloc
operator|*=
literal|2
expr_stmt|;
name|REALLOC
argument_list|(
name|d
operator|->
name|realtrans
argument_list|,
name|int
operator|*
argument_list|,
name|d
operator|->
name|tralloc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|trans
operator|=
name|d
operator|->
name|realtrans
operator|+
literal|1
expr_stmt|;
name|REALLOC
argument_list|(
name|d
operator|->
name|fails
argument_list|,
name|int
operator|*
argument_list|,
name|d
operator|->
name|tralloc
argument_list|)
expr_stmt|;
name|REALLOC
argument_list|(
name|d
operator|->
name|success
argument_list|,
name|int
argument_list|,
name|d
operator|->
name|tralloc
argument_list|)
expr_stmt|;
while|while
condition|(
name|oldalloc
operator|<
name|d
operator|->
name|tralloc
condition|)
block|{
name|d
operator|->
name|trans
index|[
name|oldalloc
index|]
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|fails
index|[
name|oldalloc
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return values of transit_state_singlebyte(), and    transit_state_consume_1char.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|TRANSIT_STATE_IN_PROGRESS
block|,
comment|/* State transition has not finished.  */
name|TRANSIT_STATE_DONE
block|,
comment|/* State transition has finished.  */
name|TRANSIT_STATE_END_BUFFER
comment|/* Reach the end of the buffer.  */
block|}
name|status_transit_state
typedef|;
end_typedef

begin_comment
comment|/* Consume a single byte and transit state from 's' to '*next_state'.    This function is almost same as the state transition routin in dfaexec().    But state transition is done just once, otherwise matching succeed or    reach the end of the buffer.  */
end_comment

begin_function
specifier|static
name|status_transit_state
name|transit_state_singlebyte
parameter_list|(
name|struct
name|dfa
modifier|*
name|d
parameter_list|,
name|int
name|s
parameter_list|,
name|unsigned
name|char
specifier|const
modifier|*
name|p
parameter_list|,
name|int
modifier|*
name|next_state
parameter_list|)
block|{
name|int
modifier|*
name|t
decl_stmt|;
name|int
name|works
init|=
name|s
decl_stmt|;
name|status_transit_state
name|rval
init|=
name|TRANSIT_STATE_IN_PROGRESS
decl_stmt|;
while|while
condition|(
name|rval
operator|==
name|TRANSIT_STATE_IN_PROGRESS
condition|)
block|{
if|if
condition|(
operator|(
name|t
operator|=
name|d
operator|->
name|trans
index|[
name|works
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|works
operator|=
name|t
index|[
operator|*
name|p
index|]
expr_stmt|;
name|rval
operator|=
name|TRANSIT_STATE_DONE
expr_stmt|;
if|if
condition|(
name|works
operator|<
literal|0
condition|)
name|works
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|works
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|buf_end
condition|)
comment|/* At the moment, it must not happen.  */
return|return
name|TRANSIT_STATE_END_BUFFER
return|;
name|works
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|fails
index|[
name|works
index|]
condition|)
block|{
name|works
operator|=
name|d
operator|->
name|fails
index|[
name|works
index|]
index|[
operator|*
name|p
index|]
expr_stmt|;
name|rval
operator|=
name|TRANSIT_STATE_DONE
expr_stmt|;
block|}
else|else
block|{
name|build_state
argument_list|(
name|works
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|next_state
operator|=
name|works
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* Check whether period can match or not in the current context.  If it can,    return the amount of the bytes with which period can match, otherwise    return 0.    `pos' is the position of the period.  `index' is the index from the    buf_begin, and it is the current position in the buffer.  */
end_comment

begin_function
specifier|static
name|int
name|match_anychar
parameter_list|(
name|struct
name|dfa
modifier|*
name|d
parameter_list|,
name|int
name|s
parameter_list|,
name|position
name|pos
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|int
name|newline
init|=
literal|0
decl_stmt|;
name|int
name|letter
init|=
literal|0
decl_stmt|;
name|wchar_t
name|wc
decl_stmt|;
name|int
name|mbclen
decl_stmt|;
name|wc
operator|=
name|inputwcs
index|[
name|index
index|]
expr_stmt|;
name|mbclen
operator|=
operator|(
name|mblen_buf
index|[
name|index
index|]
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
name|mblen_buf
index|[
name|index
index|]
expr_stmt|;
comment|/* Check context.  */
if|if
condition|(
name|wc
operator|==
operator|(
name|wchar_t
operator|)
name|eolbyte
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_DOT_NEWLINE
operator|)
condition|)
return|return
literal|0
return|;
name|newline
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wc
operator|==
operator|(
name|wchar_t
operator|)
literal|'\0'
condition|)
block|{
if|if
condition|(
name|syntax_bits
operator|&
name|RE_DOT_NOT_NULL
condition|)
return|return
literal|0
return|;
name|newline
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|iswalnum
argument_list|(
name|wc
argument_list|)
operator|||
name|wc
operator|==
literal|L'
expr|_'
condition|)
name|letter
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|SUCCEEDS_IN_CONTEXT
argument_list|(
name|pos
operator|.
name|constraint
argument_list|,
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|newline
argument_list|,
name|newline
argument_list|,
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|letter
argument_list|,
name|letter
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|mbclen
return|;
block|}
end_function

begin_comment
comment|/* Check whether bracket expression can match or not in the current context.    If it can, return the amount of the bytes with which expression can match,    otherwise return 0.    `pos' is the position of the bracket expression.  `index' is the index    from the buf_begin, and it is the current position in the buffer.  */
end_comment

begin_function
name|int
name|match_mb_charset
parameter_list|(
name|struct
name|dfa
modifier|*
name|d
parameter_list|,
name|int
name|s
parameter_list|,
name|position
name|pos
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|match
decl_stmt|;
comment|/* Flag which represent that matching succeed.  */
name|int
name|match_len
decl_stmt|;
comment|/* Length of the character (or collating element) 			   with which this operator match.  */
name|int
name|op_len
decl_stmt|;
comment|/* Length of the operator.  */
name|char
name|buffer
index|[
literal|128
index|]
decl_stmt|;
name|wchar_t
name|wcbuf
index|[
literal|6
index|]
decl_stmt|;
comment|/* Pointer to the structure to which we are currently reffering.  */
name|struct
name|mb_char_classes
modifier|*
name|work_mbc
decl_stmt|;
name|int
name|newline
init|=
literal|0
decl_stmt|;
name|int
name|letter
init|=
literal|0
decl_stmt|;
name|wchar_t
name|wc
decl_stmt|;
comment|/* Current reffering character.  */
name|wc
operator|=
name|inputwcs
index|[
name|index
index|]
expr_stmt|;
comment|/* Check context.  */
if|if
condition|(
name|wc
operator|==
operator|(
name|wchar_t
operator|)
name|eolbyte
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|syntax_bits
operator|&
name|RE_DOT_NEWLINE
operator|)
condition|)
return|return
literal|0
return|;
name|newline
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wc
operator|==
operator|(
name|wchar_t
operator|)
literal|'\0'
condition|)
block|{
if|if
condition|(
name|syntax_bits
operator|&
name|RE_DOT_NOT_NULL
condition|)
return|return
literal|0
return|;
name|newline
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|iswalnum
argument_list|(
name|wc
argument_list|)
operator|||
name|wc
operator|==
literal|L'
expr|_'
condition|)
name|letter
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|SUCCEEDS_IN_CONTEXT
argument_list|(
name|pos
operator|.
name|constraint
argument_list|,
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|newline
argument_list|,
name|newline
argument_list|,
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|letter
argument_list|,
name|letter
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Assign the current reffering operator to work_mbc.  */
name|work_mbc
operator|=
operator|&
operator|(
name|d
operator|->
name|mbcsets
index|[
operator|(
name|d
operator|->
name|multibyte_prop
index|[
name|pos
operator|.
name|index
index|]
operator|)
operator|>>
literal|2
index|]
operator|)
expr_stmt|;
name|match
operator|=
operator|!
name|work_mbc
operator|->
name|invert
expr_stmt|;
name|match_len
operator|=
operator|(
name|mblen_buf
index|[
name|index
index|]
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
name|mblen_buf
index|[
name|index
index|]
expr_stmt|;
comment|/* match with a character class?  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|work_mbc
operator|->
name|nch_classes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|iswctype
argument_list|(
operator|(
name|wint_t
operator|)
name|wc
argument_list|,
name|work_mbc
operator|->
name|ch_classes
index|[
name|i
index|]
argument_list|)
condition|)
goto|goto
name|charset_matched
goto|;
block|}
name|strncpy
argument_list|(
name|buffer
argument_list|,
name|buf_begin
operator|+
name|index
argument_list|,
name|match_len
argument_list|)
expr_stmt|;
name|buffer
index|[
name|match_len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* match with an equivalent class?  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|work_mbc
operator|->
name|nequivs
condition|;
name|i
operator|++
control|)
block|{
name|op_len
operator|=
name|strlen
argument_list|(
name|work_mbc
operator|->
name|equivs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buffer
argument_list|,
name|buf_begin
operator|+
name|index
argument_list|,
name|op_len
argument_list|)
expr_stmt|;
name|buffer
index|[
name|op_len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcoll
argument_list|(
name|work_mbc
operator|->
name|equivs
index|[
name|i
index|]
argument_list|,
name|buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|match_len
operator|=
name|op_len
expr_stmt|;
goto|goto
name|charset_matched
goto|;
block|}
block|}
comment|/* match with a collating element?  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|work_mbc
operator|->
name|ncoll_elems
condition|;
name|i
operator|++
control|)
block|{
name|op_len
operator|=
name|strlen
argument_list|(
name|work_mbc
operator|->
name|coll_elems
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buffer
argument_list|,
name|buf_begin
operator|+
name|index
argument_list|,
name|op_len
argument_list|)
expr_stmt|;
name|buffer
index|[
name|op_len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcoll
argument_list|(
name|work_mbc
operator|->
name|coll_elems
index|[
name|i
index|]
argument_list|,
name|buffer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|match_len
operator|=
name|op_len
expr_stmt|;
goto|goto
name|charset_matched
goto|;
block|}
block|}
name|wcbuf
index|[
literal|0
index|]
operator|=
name|wc
expr_stmt|;
name|wcbuf
index|[
literal|1
index|]
operator|=
name|wcbuf
index|[
literal|3
index|]
operator|=
name|wcbuf
index|[
literal|5
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* match with a range?  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|work_mbc
operator|->
name|nranges
condition|;
name|i
operator|++
control|)
block|{
name|wcbuf
index|[
literal|2
index|]
operator|=
name|work_mbc
operator|->
name|range_sts
index|[
name|i
index|]
expr_stmt|;
name|wcbuf
index|[
literal|4
index|]
operator|=
name|work_mbc
operator|->
name|range_ends
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|wcscoll
argument_list|(
name|wcbuf
argument_list|,
name|wcbuf
operator|+
literal|2
argument_list|)
operator|>=
literal|0
operator|&&
name|wcscoll
argument_list|(
name|wcbuf
operator|+
literal|4
argument_list|,
name|wcbuf
argument_list|)
operator|>=
literal|0
condition|)
goto|goto
name|charset_matched
goto|;
block|}
comment|/* match with a character?  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|work_mbc
operator|->
name|nchars
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wc
operator|==
name|work_mbc
operator|->
name|chars
index|[
name|i
index|]
condition|)
goto|goto
name|charset_matched
goto|;
block|}
name|match
operator|=
operator|!
name|match
expr_stmt|;
name|charset_matched
label|:
return|return
name|match
condition|?
name|match_len
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Check each of `d->states[s].mbps.elem' can match or not. Then return the    array which corresponds to `d->states[s].mbps.elem' and each element of    the array contains the amount of the bytes with which the element can    match.    `index' is the index from the buf_begin, and it is the current position    in the buffer.    Caller MUST free the array which this function return.  */
end_comment

begin_function
specifier|static
name|int
modifier|*
name|check_matching_with_multibyte_ops
parameter_list|(
name|struct
name|dfa
modifier|*
name|d
parameter_list|,
name|int
name|s
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|rarray
decl_stmt|;
name|MALLOC
argument_list|(
name|rarray
argument_list|,
name|int
argument_list|,
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|mbps
operator|.
name|nelem
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|mbps
operator|.
name|nelem
condition|;
operator|++
name|i
control|)
block|{
name|position
name|pos
init|=
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|mbps
operator|.
name|elems
index|[
name|i
index|]
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|tokens
index|[
name|pos
operator|.
name|index
index|]
condition|)
block|{
case|case
name|ANYCHAR
case|:
name|rarray
index|[
name|i
index|]
operator|=
name|match_anychar
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
name|pos
argument_list|,
name|index
argument_list|)
expr_stmt|;
break|break;
case|case
name|MBCSET
case|:
name|rarray
index|[
name|i
index|]
operator|=
name|match_mb_charset
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
name|pos
argument_list|,
name|index
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
comment|/* can not happen.  */
block|}
block|}
return|return
name|rarray
return|;
block|}
end_function

begin_comment
comment|/* Consume a single character and enumerate all of the positions which can    be next position from the state `s'.    `match_lens' is the input. It can be NULL, but it can also be the output    of check_matching_with_multibyte_ops() for optimization.    `mbclen' and `pps' are the output.  `mbclen' is the length of the    character consumed, and `pps' is the set this function enumerate.  */
end_comment

begin_function
specifier|static
name|status_transit_state
name|transit_state_consume_1char
parameter_list|(
name|struct
name|dfa
modifier|*
name|d
parameter_list|,
name|int
name|s
parameter_list|,
name|unsigned
name|char
specifier|const
modifier|*
modifier|*
name|pp
parameter_list|,
name|int
modifier|*
name|match_lens
parameter_list|,
name|int
modifier|*
name|mbclen
parameter_list|,
name|position_set
modifier|*
name|pps
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|s1
decl_stmt|,
name|s2
decl_stmt|;
name|int
modifier|*
name|work_mbls
decl_stmt|;
name|status_transit_state
name|rs
init|=
name|TRANSIT_STATE_DONE
decl_stmt|;
comment|/* Calculate the length of the (single/multi byte) character      to which p points.  */
operator|*
name|mbclen
operator|=
operator|(
name|mblen_buf
index|[
operator|*
name|pp
operator|-
name|buf_begin
index|]
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
name|mblen_buf
index|[
operator|*
name|pp
operator|-
name|buf_begin
index|]
expr_stmt|;
comment|/* Calculate the state which can be reached from the state `s' by      consuming `*mbclen' single bytes from the buffer.  */
name|s1
operator|=
name|s
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|mbclen
condition|;
name|i
operator|++
control|)
block|{
name|s2
operator|=
name|s1
expr_stmt|;
name|rs
operator|=
name|transit_state_singlebyte
argument_list|(
name|d
argument_list|,
name|s2
argument_list|,
operator|(
operator|*
name|pp
operator|)
operator|++
argument_list|,
operator|&
name|s1
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the positions contained by `s1' to the set `pps'.  */
name|copy
argument_list|(
operator|&
operator|(
name|d
operator|->
name|states
index|[
name|s1
index|]
operator|.
name|elems
operator|)
argument_list|,
name|pps
argument_list|)
expr_stmt|;
comment|/* Check (inputed)match_lens, and initialize if it is NULL.  */
if|if
condition|(
name|match_lens
operator|==
name|NULL
operator|&&
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|mbps
operator|.
name|nelem
operator|!=
literal|0
condition|)
name|work_mbls
operator|=
name|check_matching_with_multibyte_ops
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
operator|*
name|pp
operator|-
name|buf_begin
argument_list|)
expr_stmt|;
else|else
name|work_mbls
operator|=
name|match_lens
expr_stmt|;
comment|/* Add all of the positions which can be reached from `s' by consuming      a single character.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|mbps
operator|.
name|nelem
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|work_mbls
index|[
name|i
index|]
operator|==
operator|*
name|mbclen
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|d
operator|->
name|follows
index|[
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|mbps
operator|.
name|elems
index|[
name|i
index|]
operator|.
name|index
index|]
operator|.
name|nelem
condition|;
name|j
operator|++
control|)
name|insert
argument_list|(
name|d
operator|->
name|follows
index|[
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|mbps
operator|.
name|elems
index|[
name|i
index|]
operator|.
name|index
index|]
operator|.
name|elems
index|[
name|j
index|]
argument_list|,
name|pps
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|match_lens
operator|==
name|NULL
operator|&&
name|work_mbls
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|work_mbls
argument_list|)
expr_stmt|;
return|return
name|rs
return|;
block|}
end_function

begin_comment
comment|/* Transit state from s, then return new state and update the pointer of the    buffer.  This function is for some operator which can match with a multi-    byte character or a collating element(which may be multi characters).  */
end_comment

begin_function
specifier|static
name|int
name|transit_state
parameter_list|(
name|struct
name|dfa
modifier|*
name|d
parameter_list|,
name|int
name|s
parameter_list|,
name|unsigned
name|char
specifier|const
modifier|*
modifier|*
name|pp
parameter_list|)
block|{
name|int
name|s1
decl_stmt|;
name|int
name|mbclen
decl_stmt|;
comment|/* The length of current input multibyte character. */
name|int
name|maxlen
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
modifier|*
name|match_lens
init|=
name|NULL
decl_stmt|;
name|int
name|nelem
init|=
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|mbps
operator|.
name|nelem
decl_stmt|;
comment|/* Just a alias.  */
name|position_set
name|follows
decl_stmt|;
name|unsigned
name|char
specifier|const
modifier|*
name|p1
init|=
operator|*
name|pp
decl_stmt|;
name|status_transit_state
name|rs
decl_stmt|;
name|wchar_t
name|wc
decl_stmt|;
if|if
condition|(
name|nelem
operator|>
literal|0
condition|)
comment|/* This state has (a) multibyte operator(s).        We check whether each of them can match or not.  */
block|{
comment|/* Note: caller must free the return value of this function.  */
name|match_lens
operator|=
name|check_matching_with_multibyte_ops
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
operator|*
name|pp
operator|-
name|buf_begin
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelem
condition|;
name|i
operator|++
control|)
comment|/* Search the operator which match the longest string, 	   in this state.  */
block|{
if|if
condition|(
name|match_lens
index|[
name|i
index|]
operator|>
name|maxlen
condition|)
name|maxlen
operator|=
name|match_lens
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nelem
operator|==
literal|0
operator|||
name|maxlen
operator|==
literal|0
condition|)
comment|/* This state has no multibyte operator which can match.        We need to  check only one singlebyte character.  */
block|{
name|status_transit_state
name|rs
decl_stmt|;
name|rs
operator|=
name|transit_state_singlebyte
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
operator|*
name|pp
argument_list|,
operator|&
name|s1
argument_list|)
expr_stmt|;
comment|/* We must update the pointer if state transition succeeded.  */
if|if
condition|(
name|rs
operator|==
name|TRANSIT_STATE_DONE
condition|)
operator|++
operator|*
name|pp
expr_stmt|;
if|if
condition|(
name|match_lens
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|match_lens
argument_list|)
expr_stmt|;
return|return
name|s1
return|;
block|}
comment|/* This state has some operators which can match a multibyte character.  */
name|follows
operator|.
name|nelem
operator|=
literal|0
expr_stmt|;
name|MALLOC
argument_list|(
name|follows
operator|.
name|elems
argument_list|,
name|position
argument_list|,
name|d
operator|->
name|nleaves
argument_list|)
expr_stmt|;
comment|/* `maxlen' may be longer than the length of a character, because it may      not be a character but a (multi character) collating element.      We enumerate all of the positions which `s' can reach by consuming      `maxlen' bytes.  */
name|rs
operator|=
name|transit_state_consume_1char
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
name|pp
argument_list|,
name|match_lens
argument_list|,
operator|&
name|mbclen
argument_list|,
operator|&
name|follows
argument_list|)
expr_stmt|;
name|wc
operator|=
name|inputwcs
index|[
operator|*
name|pp
operator|-
name|mbclen
operator|-
name|buf_begin
index|]
expr_stmt|;
name|s1
operator|=
name|state_index
argument_list|(
name|d
argument_list|,
operator|&
name|follows
argument_list|,
name|wc
operator|==
literal|L'
expr|\n'
argument_list|,
name|iswalnum
argument_list|(
name|wc
argument_list|)
argument_list|)
expr_stmt|;
name|realloc_trans_if_necessary
argument_list|(
name|d
argument_list|,
name|s1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|pp
operator|-
name|p1
operator|<
name|maxlen
condition|)
block|{
name|follows
operator|.
name|nelem
operator|=
literal|0
expr_stmt|;
name|rs
operator|=
name|transit_state_consume_1char
argument_list|(
name|d
argument_list|,
name|s1
argument_list|,
name|pp
argument_list|,
name|NULL
argument_list|,
operator|&
name|mbclen
argument_list|,
operator|&
name|follows
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelem
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|match_lens
index|[
name|i
index|]
operator|==
operator|*
name|pp
operator|-
name|p1
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|d
operator|->
name|follows
index|[
name|d
operator|->
name|states
index|[
name|s1
index|]
operator|.
name|mbps
operator|.
name|elems
index|[
name|i
index|]
operator|.
name|index
index|]
operator|.
name|nelem
condition|;
name|j
operator|++
control|)
name|insert
argument_list|(
name|d
operator|->
name|follows
index|[
name|d
operator|->
name|states
index|[
name|s1
index|]
operator|.
name|mbps
operator|.
name|elems
index|[
name|i
index|]
operator|.
name|index
index|]
operator|.
name|elems
index|[
name|j
index|]
argument_list|,
operator|&
name|follows
argument_list|)
expr_stmt|;
block|}
name|wc
operator|=
name|inputwcs
index|[
operator|*
name|pp
operator|-
name|mbclen
operator|-
name|buf_begin
index|]
expr_stmt|;
name|s1
operator|=
name|state_index
argument_list|(
name|d
argument_list|,
operator|&
name|follows
argument_list|,
name|wc
operator|==
literal|L'
expr|\n'
argument_list|,
name|iswalnum
argument_list|(
name|wc
argument_list|)
argument_list|)
expr_stmt|;
name|realloc_trans_if_necessary
argument_list|(
name|d
argument_list|,
name|s1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|match_lens
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|follows
operator|.
name|elems
argument_list|)
expr_stmt|;
return|return
name|s1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Search through a buffer looking for a match to the given struct dfa.    Find the first occurrence of a string matching the regexp in the buffer,    and the shortest possible version thereof.  Return the offset of the first    character after the match, or (size_t) -1 if none is found.  BEGIN points to    the beginning of the buffer, and SIZE is the size of the buffer.  If SIZE    is nonzero, BEGIN[SIZE - 1] must be a newline.  BACKREF points to a place    where we're supposed to store a 1 if backreferencing happened and the    match needs to be verified by a backtracking matcher.  Otherwise    we store a 0 in *backref. */
end_comment

begin_function
name|size_t
name|dfaexec
parameter_list|(
name|struct
name|dfa
modifier|*
name|d
parameter_list|,
name|char
specifier|const
modifier|*
name|begin
parameter_list|,
name|size_t
name|size
parameter_list|,
name|int
modifier|*
name|backref
parameter_list|)
block|{
specifier|register
name|int
name|s
decl_stmt|;
comment|/* Current state. */
specifier|register
name|unsigned
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
comment|/* Current input character. */
specifier|register
name|unsigned
name|char
specifier|const
modifier|*
name|end
decl_stmt|;
comment|/* One past the last input character.  */
specifier|register
name|int
modifier|*
modifier|*
name|trans
decl_stmt|,
modifier|*
name|t
decl_stmt|;
comment|/* Copy of d->trans so it can be optimized 				   into a register. */
specifier|register
name|unsigned
name|char
name|eol
init|=
name|eolbyte
decl_stmt|;
comment|/* Likewise for eolbyte.  */
specifier|static
name|int
name|sbit
index|[
name|NOTCHAR
index|]
decl_stmt|;
comment|/* Table for anding with d->success. */
specifier|static
name|int
name|sbit_init
decl_stmt|;
if|if
condition|(
operator|!
name|sbit_init
condition|)
block|{
name|int
name|i
decl_stmt|;
name|sbit_init
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NOTCHAR
condition|;
operator|++
name|i
control|)
name|sbit
index|[
name|i
index|]
operator|=
operator|(
name|IS_WORD_CONSTITUENT
argument_list|(
name|i
argument_list|)
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|sbit
index|[
name|eol
index|]
operator|=
literal|4
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|tralloc
condition|)
name|build_state_zero
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|s
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
specifier|const
operator|*
operator|)
name|begin
expr_stmt|;
name|end
operator|=
name|p
operator|+
name|size
expr_stmt|;
name|trans
operator|=
name|d
operator|->
name|trans
expr_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
condition|)
block|{
name|int
name|remain_bytes
decl_stmt|,
name|i
decl_stmt|;
name|buf_begin
operator|=
name|begin
expr_stmt|;
name|buf_end
operator|=
name|end
expr_stmt|;
comment|/* initialize mblen_buf, and inputwcs.  */
name|MALLOC
argument_list|(
argument|mblen_buf
argument_list|,
argument|unsigned char
argument_list|,
argument|end - (unsigned char const *)begin +
literal|2
argument_list|)
empty_stmt|;
name|MALLOC
argument_list|(
name|inputwcs
argument_list|,
name|wchar_t
argument_list|,
name|end
operator|-
operator|(
name|unsigned
name|char
specifier|const
operator|*
operator|)
name|begin
operator|+
literal|2
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbstate_t
argument_list|)
argument_list|)
expr_stmt|;
name|remain_bytes
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|end
operator|-
operator|(
name|unsigned
name|char
specifier|const
operator|*
operator|)
name|begin
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|remain_bytes
operator|==
literal|0
condition|)
block|{
name|remain_bytes
operator|=
name|mbrtowc
argument_list|(
name|inputwcs
operator|+
name|i
argument_list|,
name|begin
operator|+
name|i
argument_list|,
name|end
operator|-
operator|(
name|unsigned
name|char
specifier|const
operator|*
operator|)
name|begin
operator|-
name|i
operator|+
literal|1
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|remain_bytes
operator|<=
literal|1
condition|)
block|{
name|remain_bytes
operator|=
literal|0
expr_stmt|;
name|inputwcs
index|[
name|i
index|]
operator|=
operator|(
name|wchar_t
operator|)
name|begin
index|[
name|i
index|]
expr_stmt|;
name|mblen_buf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mblen_buf
index|[
name|i
index|]
operator|=
name|remain_bytes
expr_stmt|;
name|remain_bytes
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
name|mblen_buf
index|[
name|i
index|]
operator|=
name|remain_bytes
expr_stmt|;
name|inputwcs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|remain_bytes
operator|--
expr_stmt|;
block|}
block|}
name|mblen_buf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|inputwcs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* sentinel */
block|}
endif|#
directive|endif
comment|/* MBS_SUPPORT */
for|for
control|(
init|;
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
condition|)
while|while
condition|(
operator|(
name|t
operator|=
name|trans
index|[
name|s
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|mbps
operator|.
name|nelem
operator|!=
literal|0
condition|)
block|{
comment|/* Can match with a multibyte character( and multi character 		   collating element).  */
name|unsigned
name|char
specifier|const
modifier|*
name|nextp
decl_stmt|;
name|SKIP_REMAINS_MB_IF_INITIAL_STATE
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|nextp
operator|=
name|p
expr_stmt|;
name|s
operator|=
name|transit_state
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
operator|&
name|nextp
argument_list|)
expr_stmt|;
name|p
operator|=
name|nextp
expr_stmt|;
comment|/* Trans table might be updated.  */
name|trans
operator|=
name|d
operator|->
name|trans
expr_stmt|;
block|}
else|else
block|{
name|SKIP_REMAINS_MB_IF_INITIAL_STATE
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|s
operator|=
name|t
index|[
operator|*
name|p
operator|++
index|]
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* MBS_SUPPORT */
while|while
condition|(
operator|(
name|t
operator|=
name|trans
index|[
name|s
index|]
operator|)
condition|)
name|s
operator|=
name|t
index|[
operator|*
name|p
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|end
condition|)
block|{
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
condition|)
block|{
name|free
argument_list|(
name|mblen_buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inputwcs
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MBS_SUPPORT */
return|return
operator|(
name|size_t
operator|)
operator|-
literal|1
return|;
block|}
name|s
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|t
operator|=
name|d
operator|->
name|fails
index|[
name|s
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|success
index|[
name|s
index|]
operator|&
name|sbit
index|[
operator|*
name|p
index|]
condition|)
block|{
if|if
condition|(
name|backref
condition|)
operator|*
name|backref
operator|=
operator|(
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|backref
operator|!=
literal|0
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
condition|)
block|{
name|free
argument_list|(
name|mblen_buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inputwcs
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MBS_SUPPORT */
return|return
operator|(
name|char
specifier|const
operator|*
operator|)
name|p
operator|-
name|begin
return|;
block|}
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
condition|)
block|{
name|SKIP_REMAINS_MB_IF_INITIAL_STATE
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|states
index|[
name|s
index|]
operator|.
name|mbps
operator|.
name|nelem
operator|!=
literal|0
condition|)
block|{
comment|/* Can match with a multibyte character( and multi 		       character collating element).  */
name|unsigned
name|char
specifier|const
modifier|*
name|nextp
decl_stmt|;
name|nextp
operator|=
name|p
expr_stmt|;
name|s
operator|=
name|transit_state
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
operator|&
name|nextp
argument_list|)
expr_stmt|;
name|p
operator|=
name|nextp
expr_stmt|;
comment|/* Trans table might be updated.  */
name|trans
operator|=
name|d
operator|->
name|trans
expr_stmt|;
block|}
else|else
name|s
operator|=
name|t
index|[
operator|*
name|p
operator|++
index|]
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* MBS_SUPPORT */
name|s
operator|=
name|t
index|[
operator|*
name|p
operator|++
index|]
expr_stmt|;
block|}
else|else
block|{
name|build_state
argument_list|(
name|s
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|trans
operator|=
name|d
operator|->
name|trans
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Initialize the components of a dfa that the other routines don't    initialize for themselves. */
end_comment

begin_function
name|void
name|dfainit
parameter_list|(
name|struct
name|dfa
modifier|*
name|d
parameter_list|)
block|{
name|d
operator|->
name|calloc
operator|=
literal|1
expr_stmt|;
name|MALLOC
argument_list|(
name|d
operator|->
name|charclasses
argument_list|,
name|charclass
argument_list|,
name|d
operator|->
name|calloc
argument_list|)
expr_stmt|;
name|d
operator|->
name|cindex
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|talloc
operator|=
literal|1
expr_stmt|;
name|MALLOC
argument_list|(
name|d
operator|->
name|tokens
argument_list|,
name|token
argument_list|,
name|d
operator|->
name|talloc
argument_list|)
expr_stmt|;
name|d
operator|->
name|tindex
operator|=
name|d
operator|->
name|depth
operator|=
name|d
operator|->
name|nleaves
operator|=
name|d
operator|->
name|nregexps
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
condition|)
block|{
name|d
operator|->
name|nmultibyte_prop
operator|=
literal|1
expr_stmt|;
name|MALLOC
argument_list|(
name|d
operator|->
name|multibyte_prop
argument_list|,
name|int
argument_list|,
name|d
operator|->
name|nmultibyte_prop
argument_list|)
expr_stmt|;
name|d
operator|->
name|nmbcsets
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|mbcsets_alloc
operator|=
literal|1
expr_stmt|;
name|MALLOC
argument_list|(
name|d
operator|->
name|mbcsets
argument_list|,
expr|struct
name|mb_char_classes
argument_list|,
name|d
operator|->
name|mbcsets_alloc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|d
operator|->
name|searchflag
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|tralloc
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|musts
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse and analyze a single string of the given length. */
end_comment

begin_function
name|void
name|dfacomp
parameter_list|(
name|char
specifier|const
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|dfa
modifier|*
name|d
parameter_list|,
name|int
name|searchflag
parameter_list|)
block|{
if|if
condition|(
name|case_fold
condition|)
comment|/* dummy folding in service of dfamust() */
block|{
name|char
modifier|*
name|lcopy
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lcopy
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lcopy
condition|)
name|dfaerror
argument_list|(
name|_
argument_list|(
literal|"out of memory"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This is a kludge. */
name|case_fold
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|ISUPPER
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|s
index|[
name|i
index|]
argument_list|)
condition|)
name|lcopy
index|[
name|i
index|]
operator|=
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|lcopy
index|[
name|i
index|]
operator|=
name|s
index|[
name|i
index|]
expr_stmt|;
name|dfainit
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|dfaparse
argument_list|(
name|lcopy
argument_list|,
name|len
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lcopy
argument_list|)
expr_stmt|;
name|dfamust
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|cindex
operator|=
name|d
operator|->
name|tindex
operator|=
name|d
operator|->
name|depth
operator|=
name|d
operator|->
name|nleaves
operator|=
name|d
operator|->
name|nregexps
operator|=
literal|0
expr_stmt|;
name|case_fold
operator|=
literal|1
expr_stmt|;
name|dfaparse
argument_list|(
name|s
argument_list|,
name|len
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|dfaanalyze
argument_list|(
name|d
argument_list|,
name|searchflag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dfainit
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|dfaparse
argument_list|(
name|s
argument_list|,
name|len
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|dfamust
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|dfaanalyze
argument_list|(
name|d
argument_list|,
name|searchflag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Free the storage held by the components of a dfa. */
end_comment

begin_function
name|void
name|dfafree
parameter_list|(
name|struct
name|dfa
modifier|*
name|d
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|dfamust
modifier|*
name|dm
decl_stmt|,
modifier|*
name|ndm
decl_stmt|;
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|charclasses
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|tokens
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MBS_SUPPORT
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
condition|)
block|{
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|multibyte_prop
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|nmbcsets
condition|;
operator|++
name|i
control|)
block|{
name|int
name|j
decl_stmt|;
name|struct
name|mb_char_classes
modifier|*
name|p
init|=
operator|&
operator|(
name|d
operator|->
name|mbcsets
index|[
name|i
index|]
operator|)
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|chars
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|p
operator|->
name|chars
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|ch_classes
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|p
operator|->
name|ch_classes
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|range_sts
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|p
operator|->
name|range_sts
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|range_ends
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|p
operator|->
name|range_ends
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p
operator|->
name|nequivs
condition|;
operator|++
name|j
control|)
name|free
argument_list|(
name|p
operator|->
name|equivs
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|equivs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|p
operator|->
name|equivs
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|p
operator|->
name|ncoll_elems
condition|;
operator|++
name|j
control|)
name|free
argument_list|(
name|p
operator|->
name|coll_elems
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|coll_elems
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|p
operator|->
name|coll_elems
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|mbcsets
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MBS_SUPPORT */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|sindex
condition|;
operator|++
name|i
control|)
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|states
index|[
name|i
index|]
operator|.
name|elems
operator|.
name|elems
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|states
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|d
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|elems
condition|)
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|follows
index|[
name|i
index|]
operator|.
name|elems
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|follows
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|tralloc
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|d
operator|->
name|trans
index|[
name|i
index|]
condition|)
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|trans
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|->
name|fails
index|[
name|i
index|]
condition|)
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|fails
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|realtrans
condition|)
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|realtrans
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|fails
condition|)
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|fails
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|success
condition|)
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|d
operator|->
name|success
argument_list|)
expr_stmt|;
for|for
control|(
name|dm
operator|=
name|d
operator|->
name|musts
init|;
name|dm
condition|;
name|dm
operator|=
name|ndm
control|)
block|{
name|ndm
operator|=
name|dm
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|dm
operator|->
name|must
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|ptr_t
operator|)
name|dm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Having found the postfix representation of the regular expression,    try to find a long sequence of characters that must appear in any line    containing the r.e.    Finding a "longest" sequence is beyond the scope here;    we take an easy way out and hope for the best.    (Take "(ab|a)b"--please.)     We do a bottom-up calculation of sequences of characters that must appear    in matches of r.e.'s represented by trees rooted at the nodes of the postfix    representation: 	sequences that must appear at the left of the match ("left") 	sequences that must appear at the right of the match ("right") 	lists of sequences that must appear somewhere in the match ("in") 	sequences that must constitute the match ("is")     When we get to the root of the tree, we use one of the longest of its    calculated "in" sequences as our answer.  The sequence we find is returned in    d->must (where "d" is the single argument passed to "dfamust");    the length of the sequence is returned in d->mustn.     The sequences calculated for the various types of node (in pseudo ANSI c)    are shown below.  "p" is the operand of unary operators (and the left-hand    operand of binary operators); "q" is the right-hand operand of binary    operators.     "ZERO" means "a zero-length sequence" below.  	Type	left		right		is		in 	----	----		-----		--		-- 	char c	# c		# c		# c		# c  	ANYCHAR	ZERO		ZERO		ZERO		ZERO  	MBCSET	ZERO		ZERO		ZERO		ZERO  	CSET	ZERO		ZERO		ZERO		ZERO  	STAR	ZERO		ZERO		ZERO		ZERO  	QMARK	ZERO		ZERO		ZERO		ZERO  	PLUS	p->left		p->right	ZERO		p->in  	CAT	(p->is==ZERO)?	(q->is==ZERO)?	(p->is!=ZERO&&	p->in plus 		p->left :	q->right :	q->is!=ZERO) ?	q->in plus 		p->is##q->left	p->right##q->is	p->is##q->is :	p->right##q->left 						ZERO  	OR	longest common	longest common	(do p->is and	substrings common to 		leading		trailing	q->is have same	p->in and q->in 		(sub)sequence	(sub)sequence	length and 		of p->left	of p->right	content) ? 		and q->left	and q->right	p->is : NULL     If there's anything else we recognize in the tree, all four sequences get set    to zero-length sequences.  If there's something we don't recognize in the tree,    we just return a zero-length sequence.     Break ties in favor of infrequent letters (choosing 'zzz' in preference to    'aaa')?     And. . .is it here or someplace that we might ponder "optimizations" such as 	egrep 'psi|epsilon'	->	egrep 'psi' 	egrep 'pepsi|epsilon'	->	egrep 'epsi' 					(Yes, we now find "epsi" as a "string 					that must occur", but we might also 					simplify the *entire* r.e. being sought) 	grep '[c]'		->	grep 'c' 	grep '(ab|a)b'		->	grep 'ab' 	grep 'ab*'		->	grep 'a' 	grep 'a*b'		->	grep 'b'     There are several issues:     Is optimization easy (enough)?     Does optimization actually accomplish anything,    or is the automaton you get from "psi|epsilon" (for example)    the same as the one you get from "psi" (for example)?     Are optimizable r.e.'s likely to be used in real-life situations    (something like 'ab*' is probably unlikely; something like is    'psi|epsilon' is likelier)? */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|icatalloc
parameter_list|(
name|char
modifier|*
name|old
parameter_list|,
name|char
modifier|*
name|new
parameter_list|)
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|size_t
name|oldsize
decl_stmt|,
name|newsize
decl_stmt|;
name|newsize
operator|=
operator|(
name|new
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|NULL
condition|)
name|oldsize
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|newsize
operator|==
literal|0
condition|)
return|return
name|old
return|;
else|else
name|oldsize
operator|=
name|strlen
argument_list|(
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|NULL
condition|)
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|newsize
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|old
argument_list|,
name|oldsize
operator|+
name|newsize
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|NULL
operator|&&
name|new
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|result
operator|+
name|oldsize
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|icpyalloc
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
block|{
return|return
name|icatalloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|string
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|istrstr
parameter_list|(
name|char
modifier|*
name|lookin
parameter_list|,
name|char
modifier|*
name|lookfor
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|lookfor
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|lookin
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
operator|++
name|cp
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
name|lookfor
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|cp
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ifree
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|)
block|{
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|freelist
parameter_list|(
name|char
modifier|*
modifier|*
name|cpp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cpp
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cpp
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
name|free
argument_list|(
name|cpp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cpp
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|enlist
parameter_list|(
name|char
modifier|*
modifier|*
name|cpp
parameter_list|,
name|char
modifier|*
name|new
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|cpp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|new
operator|=
name|icpyalloc
argument_list|(
name|new
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|freelist
argument_list|(
name|cpp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|new
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Is there already something in the list that's new (or longer)? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cpp
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|istrstr
argument_list|(
name|cpp
index|[
name|i
index|]
argument_list|,
name|new
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|new
argument_list|)
expr_stmt|;
return|return
name|cpp
return|;
block|}
comment|/* Eliminate any obsoleted strings. */
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cpp
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
if|if
condition|(
name|istrstr
argument_list|(
name|new
argument_list|,
name|cpp
index|[
name|j
index|]
argument_list|)
operator|==
name|NULL
condition|)
operator|++
name|j
expr_stmt|;
else|else
block|{
name|free
argument_list|(
name|cpp
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|i
operator|==
name|j
condition|)
break|break;
name|cpp
index|[
name|j
index|]
operator|=
name|cpp
index|[
name|i
index|]
expr_stmt|;
name|cpp
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Add the new string. */
name|cpp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cpp
argument_list|,
operator|(
name|i
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
expr|*
name|cpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|cpp
index|[
name|i
index|]
operator|=
name|new
expr_stmt|;
name|cpp
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|cpp
return|;
block|}
end_function

begin_comment
comment|/* Given pointers to two strings, return a pointer to an allocated    list of their distinct common substrings. Return NULL if something    seems wild. */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|comsubs
parameter_list|(
name|char
modifier|*
name|left
parameter_list|,
name|char
modifier|*
name|right
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|cpp
decl_stmt|;
name|char
modifier|*
name|lcp
decl_stmt|;
name|char
modifier|*
name|rcp
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|left
operator|==
name|NULL
operator|||
name|right
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|cpp
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|cpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|cpp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|lcp
operator|=
name|left
init|;
operator|*
name|lcp
operator|!=
literal|'\0'
condition|;
operator|++
name|lcp
control|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
name|rcp
operator|=
name|strchr
argument_list|(
name|right
argument_list|,
operator|*
name|lcp
argument_list|)
expr_stmt|;
while|while
condition|(
name|rcp
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|lcp
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|&&
name|lcp
index|[
name|i
index|]
operator|==
name|rcp
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
continue|continue;
if|if
condition|(
name|i
operator|>
name|len
condition|)
name|len
operator|=
name|i
expr_stmt|;
name|rcp
operator|=
name|strchr
argument_list|(
name|rcp
operator|+
literal|1
argument_list|,
operator|*
name|lcp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|cpp
operator|=
name|enlist
argument_list|(
name|cpp
argument_list|,
name|lcp
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
block|}
return|return
name|cpp
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|addlists
parameter_list|(
name|char
modifier|*
modifier|*
name|old
parameter_list|,
name|char
modifier|*
modifier|*
name|new
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|old
operator|==
name|NULL
operator|||
name|new
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|new
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
name|old
operator|=
name|enlist
argument_list|(
name|old
argument_list|,
name|new
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|new
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|NULL
condition|)
break|break;
block|}
return|return
name|old
return|;
block|}
end_function

begin_comment
comment|/* Given two lists of substrings, return a new list giving substrings    common to both. */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|inboth
parameter_list|(
name|char
modifier|*
modifier|*
name|left
parameter_list|,
name|char
modifier|*
modifier|*
name|right
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|both
decl_stmt|;
name|char
modifier|*
modifier|*
name|temp
decl_stmt|;
name|int
name|lnum
decl_stmt|,
name|rnum
decl_stmt|;
if|if
condition|(
name|left
operator|==
name|NULL
operator|||
name|right
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|both
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|both
argument_list|)
expr_stmt|;
if|if
condition|(
name|both
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|both
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|lnum
operator|=
literal|0
init|;
name|left
index|[
name|lnum
index|]
operator|!=
name|NULL
condition|;
operator|++
name|lnum
control|)
block|{
for|for
control|(
name|rnum
operator|=
literal|0
init|;
name|right
index|[
name|rnum
index|]
operator|!=
name|NULL
condition|;
operator|++
name|rnum
control|)
block|{
name|temp
operator|=
name|comsubs
argument_list|(
name|left
index|[
name|lnum
index|]
argument_list|,
name|right
index|[
name|rnum
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
block|{
name|freelist
argument_list|(
name|both
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|both
operator|=
name|addlists
argument_list|(
name|both
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|freelist
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|both
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
block|}
return|return
name|both
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
modifier|*
name|in
decl_stmt|;
name|char
modifier|*
name|left
decl_stmt|;
name|char
modifier|*
name|right
decl_stmt|;
name|char
modifier|*
name|is
decl_stmt|;
block|}
name|must
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|resetmust
parameter_list|(
name|must
modifier|*
name|mp
parameter_list|)
block|{
name|mp
operator|->
name|left
index|[
literal|0
index|]
operator|=
name|mp
operator|->
name|right
index|[
literal|0
index|]
operator|=
name|mp
operator|->
name|is
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|freelist
argument_list|(
name|mp
operator|->
name|in
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dfamust
parameter_list|(
name|struct
name|dfa
modifier|*
name|dfa
parameter_list|)
block|{
name|must
modifier|*
name|musts
decl_stmt|;
name|must
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|ri
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|exact
decl_stmt|;
name|token
name|t
decl_stmt|;
specifier|static
name|must
name|must0
decl_stmt|;
name|struct
name|dfamust
modifier|*
name|dm
decl_stmt|;
specifier|static
name|char
name|empty_string
index|[]
init|=
literal|""
decl_stmt|;
name|result
operator|=
name|empty_string
expr_stmt|;
name|exact
operator|=
literal|0
expr_stmt|;
name|musts
operator|=
operator|(
name|must
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|dfa
operator|->
name|tindex
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|musts
argument_list|)
expr_stmt|;
if|if
condition|(
name|musts
operator|==
name|NULL
condition|)
return|return;
name|mp
operator|=
name|musts
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|dfa
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
name|mp
index|[
name|i
index|]
operator|=
name|must0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|dfa
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
block|{
name|mp
index|[
name|i
index|]
operator|.
name|in
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|mp
index|[
name|i
index|]
operator|.
name|in
argument_list|)
expr_stmt|;
name|mp
index|[
name|i
index|]
operator|.
name|left
operator|=
name|malloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|mp
index|[
name|i
index|]
operator|.
name|right
operator|=
name|malloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|mp
index|[
name|i
index|]
operator|.
name|is
operator|=
name|malloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
index|[
name|i
index|]
operator|.
name|in
operator|==
name|NULL
operator|||
name|mp
index|[
name|i
index|]
operator|.
name|left
operator|==
name|NULL
operator|||
name|mp
index|[
name|i
index|]
operator|.
name|right
operator|==
name|NULL
operator|||
name|mp
index|[
name|i
index|]
operator|.
name|is
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|mp
index|[
name|i
index|]
operator|.
name|left
index|[
literal|0
index|]
operator|=
name|mp
index|[
name|i
index|]
operator|.
name|right
index|[
literal|0
index|]
operator|=
name|mp
index|[
name|i
index|]
operator|.
name|is
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mp
index|[
name|i
index|]
operator|.
name|in
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dfamust:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dfa
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|dfa
operator|->
name|tokens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|ri
operator|=
literal|0
init|;
name|ri
operator|<
name|dfa
operator|->
name|tindex
condition|;
operator|++
name|ri
control|)
block|{
switch|switch
condition|(
name|t
operator|=
name|dfa
operator|->
name|tokens
index|[
name|ri
index|]
condition|)
block|{
case|case
name|LPAREN
case|:
case|case
name|RPAREN
case|:
goto|goto
name|done
goto|;
comment|/* "cannot happen" */
case|case
name|EMPTY
case|:
case|case
name|BEGLINE
case|:
case|case
name|ENDLINE
case|:
case|case
name|BEGWORD
case|:
case|case
name|ENDWORD
case|:
case|case
name|LIMWORD
case|:
case|case
name|NOTLIMWORD
case|:
case|case
name|BACKREF
case|:
name|resetmust
argument_list|(
name|mp
argument_list|)
expr_stmt|;
break|break;
case|case
name|STAR
case|:
case|case
name|QMARK
case|:
if|if
condition|(
name|mp
operator|<=
name|musts
condition|)
goto|goto
name|done
goto|;
comment|/* "cannot happen" */
operator|--
name|mp
expr_stmt|;
name|resetmust
argument_list|(
name|mp
argument_list|)
expr_stmt|;
break|break;
case|case
name|OR
case|:
case|case
name|ORTOP
case|:
if|if
condition|(
name|mp
operator|<
operator|&
name|musts
index|[
literal|2
index|]
condition|)
goto|goto
name|done
goto|;
comment|/* "cannot happen" */
block|{
name|char
modifier|*
modifier|*
name|new
decl_stmt|;
name|must
modifier|*
name|lmp
decl_stmt|;
name|must
modifier|*
name|rmp
decl_stmt|;
name|int
name|j
decl_stmt|,
name|ln
decl_stmt|,
name|rn
decl_stmt|,
name|n
decl_stmt|;
name|rmp
operator|=
operator|--
name|mp
expr_stmt|;
name|lmp
operator|=
operator|--
name|mp
expr_stmt|;
comment|/* Guaranteed to be.  Unlikely, but. . . */
if|if
condition|(
name|strcmp
argument_list|(
name|lmp
operator|->
name|is
argument_list|,
name|rmp
operator|->
name|is
argument_list|)
operator|!=
literal|0
condition|)
name|lmp
operator|->
name|is
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Left side--easy */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lmp
operator|->
name|left
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|&&
name|lmp
operator|->
name|left
index|[
name|i
index|]
operator|==
name|rmp
operator|->
name|left
index|[
name|i
index|]
condition|)
operator|++
name|i
expr_stmt|;
name|lmp
operator|->
name|left
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Right side */
name|ln
operator|=
name|strlen
argument_list|(
name|lmp
operator|->
name|right
argument_list|)
expr_stmt|;
name|rn
operator|=
name|strlen
argument_list|(
name|rmp
operator|->
name|right
argument_list|)
expr_stmt|;
name|n
operator|=
name|ln
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|rn
condition|)
name|n
operator|=
name|rn
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|lmp
operator|->
name|right
index|[
name|ln
operator|-
name|i
operator|-
literal|1
index|]
operator|!=
name|rmp
operator|->
name|right
index|[
name|rn
operator|-
name|i
operator|-
literal|1
index|]
condition|)
break|break;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
name|lmp
operator|->
name|right
index|[
name|j
index|]
operator|=
name|lmp
operator|->
name|right
index|[
operator|(
name|ln
operator|-
name|i
operator|)
operator|+
name|j
index|]
expr_stmt|;
name|lmp
operator|->
name|right
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|new
operator|=
name|inboth
argument_list|(
name|lmp
operator|->
name|in
argument_list|,
name|rmp
operator|->
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|freelist
argument_list|(
name|lmp
operator|->
name|in
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lmp
operator|->
name|in
argument_list|)
expr_stmt|;
name|lmp
operator|->
name|in
operator|=
name|new
expr_stmt|;
block|}
break|break;
case|case
name|PLUS
case|:
if|if
condition|(
name|mp
operator|<=
name|musts
condition|)
goto|goto
name|done
goto|;
comment|/* "cannot happen" */
operator|--
name|mp
expr_stmt|;
name|mp
operator|->
name|is
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|END
case|:
if|if
condition|(
name|mp
operator|!=
operator|&
name|musts
index|[
literal|1
index|]
condition|)
goto|goto
name|done
goto|;
comment|/* "cannot happen" */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|musts
index|[
literal|0
index|]
operator|.
name|in
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|strlen
argument_list|(
name|musts
index|[
literal|0
index|]
operator|.
name|in
index|[
name|i
index|]
argument_list|)
operator|>
name|strlen
argument_list|(
name|result
argument_list|)
condition|)
name|result
operator|=
name|musts
index|[
literal|0
index|]
operator|.
name|in
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|result
argument_list|,
name|musts
index|[
literal|0
index|]
operator|.
name|is
argument_list|)
operator|==
literal|0
condition|)
name|exact
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|CAT
case|:
if|if
condition|(
name|mp
operator|<
operator|&
name|musts
index|[
literal|2
index|]
condition|)
goto|goto
name|done
goto|;
comment|/* "cannot happen" */
block|{
name|must
modifier|*
name|lmp
decl_stmt|;
name|must
modifier|*
name|rmp
decl_stmt|;
name|rmp
operator|=
operator|--
name|mp
expr_stmt|;
name|lmp
operator|=
operator|--
name|mp
expr_stmt|;
comment|/* In.  Everything in left, plus everything in 	       right, plus catenation of 	       left's right and right's left. */
name|lmp
operator|->
name|in
operator|=
name|addlists
argument_list|(
name|lmp
operator|->
name|in
argument_list|,
name|rmp
operator|->
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmp
operator|->
name|in
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|lmp
operator|->
name|right
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|rmp
operator|->
name|left
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|icpyalloc
argument_list|(
name|lmp
operator|->
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|tp
operator|=
name|icatalloc
argument_list|(
name|tp
argument_list|,
name|rmp
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
name|lmp
operator|->
name|in
operator|=
name|enlist
argument_list|(
name|lmp
operator|->
name|in
argument_list|,
name|tp
argument_list|,
name|strlen
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmp
operator|->
name|in
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* Left-hand */
if|if
condition|(
name|lmp
operator|->
name|is
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|lmp
operator|->
name|left
operator|=
name|icatalloc
argument_list|(
name|lmp
operator|->
name|left
argument_list|,
name|rmp
operator|->
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmp
operator|->
name|left
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* Right-hand */
if|if
condition|(
name|rmp
operator|->
name|is
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|lmp
operator|->
name|right
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|lmp
operator|->
name|right
operator|=
name|icatalloc
argument_list|(
name|lmp
operator|->
name|right
argument_list|,
name|rmp
operator|->
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmp
operator|->
name|right
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
comment|/* Guaranteed to be */
if|if
condition|(
name|lmp
operator|->
name|is
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|rmp
operator|->
name|is
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|lmp
operator|->
name|is
operator|=
name|icatalloc
argument_list|(
name|lmp
operator|->
name|is
argument_list|,
name|rmp
operator|->
name|is
argument_list|)
expr_stmt|;
if|if
condition|(
name|lmp
operator|->
name|is
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
block|}
else|else
name|lmp
operator|->
name|is
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|t
operator|<
name|END
condition|)
block|{
comment|/* "cannot happen" */
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
literal|'\0'
condition|)
block|{
comment|/* not on *my* shift */
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|t
operator|>=
name|CSET
ifdef|#
directive|ifdef
name|MBS_SUPPORT
operator|||
name|t
operator|==
name|ANYCHAR
operator|||
name|t
operator|==
name|MBCSET
endif|#
directive|endif
comment|/* MBS_SUPPORT */
condition|)
block|{
comment|/* easy enough */
name|resetmust
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* plain character */
name|resetmust
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|is
index|[
literal|0
index|]
operator|=
name|mp
operator|->
name|left
index|[
literal|0
index|]
operator|=
name|mp
operator|->
name|right
index|[
literal|0
index|]
operator|=
name|t
expr_stmt|;
name|mp
operator|->
name|is
index|[
literal|1
index|]
operator|=
name|mp
operator|->
name|left
index|[
literal|1
index|]
operator|=
name|mp
operator|->
name|right
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mp
operator|->
name|in
operator|=
name|enlist
argument_list|(
name|mp
operator|->
name|in
argument_list|,
name|mp
operator|->
name|is
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|in
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" node: %d:"
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|prtok
argument_list|(
name|dfa
operator|->
name|tokens
index|[
name|ri
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n  in:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mp
operator|->
name|in
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" \"%s\""
argument_list|,
name|mp
operator|->
name|in
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n  is: \"%s\"\n"
argument_list|,
name|mp
operator|->
name|is
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  left: \"%s\"\n"
argument_list|,
name|mp
operator|->
name|left
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  right: \"%s\"\n"
argument_list|,
name|mp
operator|->
name|right
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|mp
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|strlen
argument_list|(
name|result
argument_list|)
condition|)
block|{
name|dm
operator|=
operator|(
expr|struct
name|dfamust
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dfamust
argument_list|)
argument_list|)
expr_stmt|;
name|dm
operator|->
name|exact
operator|=
name|exact
expr_stmt|;
name|dm
operator|->
name|must
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|result
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dm
operator|->
name|must
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|dm
operator|->
name|next
operator|=
name|dfa
operator|->
name|musts
expr_stmt|;
name|dfa
operator|->
name|musts
operator|=
name|dm
expr_stmt|;
block|}
name|mp
operator|=
name|musts
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|dfa
operator|->
name|tindex
condition|;
operator|++
name|i
control|)
block|{
name|freelist
argument_list|(
name|mp
index|[
name|i
index|]
operator|.
name|in
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mp
index|[
name|i
index|]
operator|.
name|in
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|mp
index|[
name|i
index|]
operator|.
name|left
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|mp
index|[
name|i
index|]
operator|.
name|right
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|mp
index|[
name|i
index|]
operator|.
name|is
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* vim:set shiftwidth=2: */
end_comment

end_unit

