begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gzip (GNU zip) -- compress files with zip algorithm and 'compress' interface  * Copyright (C) 1992-1993 Jean-loup Gailly  * The unzip code was written and put in the public domain by Mark Adler.  * Portions of the lzw code are derived from the public domain 'compress'  * written by Spencer Thomas, Joe Orost, James Woods, Jim McKie, Steve Davies,  * Ken Turkowski, Dave Mack and Peter Jannesen.  *  * See the license_msg below and the file COPYING for the software license.  * See the file algorithm.doc for the compression algorithms and file formats.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|license_msg
index|[]
init|=
block|{
literal|"   Copyright (C) 1992-1993 Jean-loup Gailly"
block|,
literal|"   This program is free software; you can redistribute it and/or modify"
block|,
literal|"   it under the terms of the GNU General Public License as published by"
block|,
literal|"   the Free Software Foundation; either version 2, or (at your option)"
block|,
literal|"   any later version."
block|,
literal|""
block|,
literal|"   This program is distributed in the hope that it will be useful,"
block|,
literal|"   but WITHOUT ANY WARRANTY; without even the implied warranty of"
block|,
literal|"   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the"
block|,
literal|"   GNU General Public License for more details."
block|,
literal|""
block|,
literal|"   You should have received a copy of the GNU General Public License"
block|,
literal|"   along with this program; if not, write to the Free Software"
block|,
literal|"   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA."
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compress files with zip algorithm and 'compress' interface.  * See usage() and help() functions below for all options.  * Outputs:  *        file.gz:   compressed file with same mode, owner, and utimes  *     or stdout with -c option or if stdin used as input.  * If the output file name had to be truncated, the original name is kept  * in the compressed file.  * On MSDOS, file.tmp -> file.tmz. On VMS, file.tmp -> file.tmp-gz.  *  * Using gz on MSDOS would create too many file name conflicts. For  * example, foo.txt -> foo.tgz (.tgz must be reserved as shorthand for  * tar.gz). Similarly, foo.dir and foo.doc would both be mapped to foo.dgz.  * I also considered 12345678.txt -> 12345txt.gz but this truncates the name  * too heavily. There is no ideal solution given the MSDOS 8+3 limitation.  *  * For the meaning of all compilation flags, see comments in Makefile.in.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: gzip.c,v 1.7 1997/03/15 22:43:58 guido Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_include
include|#
directive|include
file|"gzip.h"
end_include

begin_include
include|#
directive|include
file|"lzw.h"
end_include

begin_include
include|#
directive|include
file|"revision.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_comment
comment|/* configuration */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NO_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_FCNTL_H
end_ifndef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|NO_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DIRENT
argument_list|)
end_if

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_typedef
typedef|typedef
name|struct
name|dirent
name|dir_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NLENGTH
parameter_list|(
name|dirent
parameter_list|)
value|((int)strlen((dirent)->d_name))
end_define

begin_define
define|#
directive|define
name|DIR_OPT
value|"DIRENT"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NLENGTH
parameter_list|(
name|dirent
parameter_list|)
value|((dirent)->d_namlen)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SYSDIR
end_ifdef

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_typedef
typedef|typedef
name|struct
name|direct
name|dir_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|DIR_OPT
value|"SYSDIR"
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|SYSNDIR
end_ifdef

begin_include
include|#
directive|include
file|<sys/ndir.h>
end_include

begin_typedef
typedef|typedef
name|struct
name|direct
name|dir_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|DIR_OPT
value|"SYSNDIR"
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|NDIR
end_ifdef

begin_include
include|#
directive|include
file|<ndir.h>
end_include

begin_typedef
typedef|typedef
name|struct
name|direct
name|dir_type
typedef|;
end_typedef

begin_define
define|#
directive|define
name|DIR_OPT
value|"NDIR"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NO_DIR
end_define

begin_define
define|#
directive|define
name|DIR_OPT
value|"NO_DIR"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_UTIME
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|NO_UTIME_H
end_ifndef

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_define
define|#
directive|define
name|TIME_OPT
value|"UTIME"
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_UTIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/utime.h>
end_include

begin_define
define|#
directive|define
name|TIME_OPT
value|"SYS_UTIME"
end_define

begin_else
else|#
directive|else
end_else

begin_struct
struct|struct
name|utimbuf
block|{
name|time_t
name|actime
decl_stmt|;
name|time_t
name|modtime
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|TIME_OPT
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TIME_OPT
value|"NO_UTIME"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|S_ISDIR
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IFDIR
argument_list|)
end_if

begin_define
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|S_ISREG
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IFREG
argument_list|)
end_if

begin_define
define|#
directive|define
name|S_ISREG
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFREG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|RETSIGTYPE
argument_list|(
argument|*sig_type
argument_list|)
name|OF
argument_list|(
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_comment
comment|/* creation mode for open() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_CREAT
end_ifndef

begin_comment
comment|/* Pure BSD system? */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|O_CREAT
end_ifndef

begin_define
define|#
directive|define
name|O_CREAT
value|FCREAT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|O_EXCL
end_ifndef

begin_define
define|#
directive|define
name|O_EXCL
value|FEXCL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_IRUSR
end_ifndef

begin_define
define|#
directive|define
name|S_IRUSR
value|0400
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_IWUSR
end_ifndef

begin_define
define|#
directive|define
name|S_IWUSR
value|0200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RW_USER
value|(S_IRUSR | S_IWUSR)
end_define

begin_comment
comment|/* creation mode for open() */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_PATH_LEN
end_ifndef

begin_define
define|#
directive|define
name|MAX_PATH_LEN
value|1024
end_define

begin_comment
comment|/* max pathname length */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SEEK_END
end_ifndef

begin_define
define|#
directive|define
name|SEEK_END
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_OFF_T
end_ifdef

begin_typedef
typedef|typedef
name|long
name|off_t
typedef|;
end_typedef

begin_decl_stmt
name|off_t
name|lseek
name|OF
argument_list|(
operator|(
name|int
name|fd
operator|,
name|off_t
name|offset
operator|,
name|int
name|whence
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Separator for file name parts (see shorten_name()) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NO_MULTIPLE_DOTS
end_ifdef

begin_define
define|#
directive|define
name|PART_SEP
value|"-"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PART_SEP
value|"."
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* global buffers */
end_comment

begin_expr_stmt
name|DECLARE
argument_list|(
name|uch
argument_list|,
name|inbuf
argument_list|,
name|INBUFSIZ
operator|+
name|INBUF_EXTRA
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE
argument_list|(
name|uch
argument_list|,
name|outbuf
argument_list|,
name|OUTBUFSIZ
operator|+
name|OUTBUF_EXTRA
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE
argument_list|(
name|ush
argument_list|,
name|d_buf
argument_list|,
name|DIST_BUFSIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE
argument_list|(
name|uch
argument_list|,
name|window
argument_list|,
literal|2L
operator|*
name|WSIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MAXSEG_64K
end_ifndef

begin_expr_stmt
name|DECLARE
argument_list|(
name|ush
argument_list|,
name|tab_prefix
argument_list|,
literal|1L
operator|<<
name|BITS
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|DECLARE
argument_list|(
name|ush
argument_list|,
name|tab_prefix0
argument_list|,
literal|1L
operator|<<
operator|(
name|BITS
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE
argument_list|(
name|ush
argument_list|,
name|tab_prefix1
argument_list|,
literal|1L
operator|<<
operator|(
name|BITS
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* local variables */
end_comment

begin_decl_stmt
name|int
name|ascii
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* convert end-of-lines to local OS conventions */
end_comment

begin_decl_stmt
name|int
name|to_stdout
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output to stdout (-c) */
end_comment

begin_decl_stmt
name|int
name|decompress
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* decompress (-d) */
end_comment

begin_decl_stmt
name|int
name|force
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't ask questions, compress links (-f) */
end_comment

begin_decl_stmt
name|int
name|no_name
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't save or restore the original file name */
end_comment

begin_decl_stmt
name|int
name|no_time
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't save or restore the original file time */
end_comment

begin_decl_stmt
name|int
name|recursive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* recurse through directories (-r) */
end_comment

begin_decl_stmt
name|int
name|list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list the file contents (-l) */
end_comment

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* be verbose (-v) */
end_comment

begin_decl_stmt
name|int
name|quiet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* be very quiet (-q) */
end_comment

begin_decl_stmt
name|int
name|do_lzw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* generate output compatible with old compress (-Z) */
end_comment

begin_decl_stmt
name|int
name|test
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* test .gz file integrity */
end_comment

begin_decl_stmt
name|int
name|foreground
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if program run in foreground */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program name */
end_comment

begin_decl_stmt
name|int
name|maxbits
init|=
name|BITS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max bits per code for LZW */
end_comment

begin_decl_stmt
name|int
name|method
init|=
name|DEFLATED
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* compression method */
end_comment

begin_decl_stmt
name|int
name|level
init|=
literal|6
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* compression level */
end_comment

begin_decl_stmt
name|int
name|exit_code
init|=
name|OK
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program exit code */
end_comment

begin_decl_stmt
name|int
name|save_orig_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if original name must be saved */
end_comment

begin_decl_stmt
name|int
name|last_member
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set for .zip and .Z files */
end_comment

begin_decl_stmt
name|int
name|part_nb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of parts in .gz file */
end_comment

begin_decl_stmt
name|long
name|time_stamp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* original time stamp (modification time) */
end_comment

begin_decl_stmt
name|long
name|ifile_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file size, -1 for devices (debug only) */
end_comment

begin_decl_stmt
name|char
modifier|*
name|env
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* contents of GZIP env variable */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|args
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* argv pointer if GZIP env variable defined */
end_comment

begin_decl_stmt
name|char
name|z_suffix
index|[
name|MAX_SUFFIX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default suffix (can be set with --suffix) */
end_comment

begin_decl_stmt
name|int
name|z_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* strlen(z_suffix) */
end_comment

begin_decl_stmt
name|long
name|bytes_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of input bytes */
end_comment

begin_decl_stmt
name|long
name|bytes_out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of output bytes */
end_comment

begin_decl_stmt
name|long
name|total_in
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input bytes for all files */
end_comment

begin_decl_stmt
name|long
name|total_out
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output bytes for all files */
end_comment

begin_decl_stmt
name|char
name|ifname
index|[
name|MAX_PATH_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file name */
end_comment

begin_decl_stmt
name|char
name|ofname
index|[
name|MAX_PATH_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output file name */
end_comment

begin_decl_stmt
name|int
name|remove_ofname
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* remove output file on error */
end_comment

begin_decl_stmt
name|struct
name|stat
name|istat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* status for input file */
end_comment

begin_decl_stmt
name|int
name|ifd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file descriptor */
end_comment

begin_decl_stmt
name|int
name|ofd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output file descriptor */
end_comment

begin_decl_stmt
name|unsigned
name|insize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* valid bytes in inbuf */
end_comment

begin_decl_stmt
name|unsigned
name|inptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index of next byte to be processed in inbuf */
end_comment

begin_decl_stmt
name|unsigned
name|outcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bytes in output buffer */
end_comment

begin_decl_stmt
name|struct
name|option
name|longopts
index|[]
init|=
block|{
comment|/* { name  has_arg  *flag  val } */
block|{
literal|"ascii"
block|,
literal|0
block|,
literal|0
block|,
literal|'a'
block|}
block|,
comment|/* ascii text mode */
block|{
literal|"to-stdout"
block|,
literal|0
block|,
literal|0
block|,
literal|'c'
block|}
block|,
comment|/* write output on standard output */
block|{
literal|"stdout"
block|,
literal|0
block|,
literal|0
block|,
literal|'c'
block|}
block|,
comment|/* write output on standard output */
block|{
literal|"decompress"
block|,
literal|0
block|,
literal|0
block|,
literal|'d'
block|}
block|,
comment|/* decompress */
block|{
literal|"uncompress"
block|,
literal|0
block|,
literal|0
block|,
literal|'d'
block|}
block|,
comment|/* decompress */
comment|/* {"encrypt",    0, 0, 'e'},    encrypt */
block|{
literal|"force"
block|,
literal|0
block|,
literal|0
block|,
literal|'f'
block|}
block|,
comment|/* force overwrite of output file */
block|{
literal|"help"
block|,
literal|0
block|,
literal|0
block|,
literal|'h'
block|}
block|,
comment|/* give help */
comment|/* {"pkzip",      0, 0, 'k'},    force output in pkzip format */
block|{
literal|"list"
block|,
literal|0
block|,
literal|0
block|,
literal|'l'
block|}
block|,
comment|/* list .gz file contents */
block|{
literal|"license"
block|,
literal|0
block|,
literal|0
block|,
literal|'L'
block|}
block|,
comment|/* display software license */
block|{
literal|"no-name"
block|,
literal|0
block|,
literal|0
block|,
literal|'n'
block|}
block|,
comment|/* don't save or restore original name& time */
block|{
literal|"name"
block|,
literal|0
block|,
literal|0
block|,
literal|'N'
block|}
block|,
comment|/* save or restore original name& time */
block|{
literal|"quiet"
block|,
literal|0
block|,
literal|0
block|,
literal|'q'
block|}
block|,
comment|/* quiet mode */
block|{
literal|"silent"
block|,
literal|0
block|,
literal|0
block|,
literal|'q'
block|}
block|,
comment|/* quiet mode */
block|{
literal|"recursive"
block|,
literal|0
block|,
literal|0
block|,
literal|'r'
block|}
block|,
comment|/* recurse through directories */
block|{
literal|"suffix"
block|,
literal|1
block|,
literal|0
block|,
literal|'S'
block|}
block|,
comment|/* use given suffix instead of .gz */
block|{
literal|"test"
block|,
literal|0
block|,
literal|0
block|,
literal|'t'
block|}
block|,
comment|/* test compressed file integrity */
block|{
literal|"no-time"
block|,
literal|0
block|,
literal|0
block|,
literal|'T'
block|}
block|,
comment|/* don't save or restore the time stamp */
block|{
literal|"verbose"
block|,
literal|0
block|,
literal|0
block|,
literal|'v'
block|}
block|,
comment|/* verbose mode */
block|{
literal|"version"
block|,
literal|0
block|,
literal|0
block|,
literal|'V'
block|}
block|,
comment|/* display version number */
block|{
literal|"fast"
block|,
literal|0
block|,
literal|0
block|,
literal|'1'
block|}
block|,
comment|/* compress faster */
block|{
literal|"best"
block|,
literal|0
block|,
literal|0
block|,
literal|'9'
block|}
block|,
comment|/* compress better */
block|{
literal|"lzw"
block|,
literal|0
block|,
literal|0
block|,
literal|'Z'
block|}
block|,
comment|/* make output compatible with old compress */
block|{
literal|"bits"
block|,
literal|1
block|,
literal|0
block|,
literal|'b'
block|}
block|,
comment|/* max number of bits per code (implies -Z) */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local functions */
end_comment

begin_decl_stmt
name|local
name|void
name|usage
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|help
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|license
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|version
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|treat_stdin
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|treat_file
name|OF
argument_list|(
operator|(
name|char
operator|*
name|iname
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|create_outfile
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|do_stat
name|OF
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
expr|struct
name|stat
operator|*
name|sbuf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|char
modifier|*
name|get_suffix
name|OF
argument_list|(
operator|(
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|get_istat
name|OF
argument_list|(
operator|(
name|char
operator|*
name|iname
operator|,
expr|struct
name|stat
operator|*
name|sbuf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|make_ofname
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|same_file
name|OF
argument_list|(
operator|(
expr|struct
name|stat
operator|*
name|stat1
operator|,
expr|struct
name|stat
operator|*
name|stat2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|name_too_long
name|OF
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
expr|struct
name|stat
operator|*
name|statb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|shorten_name
name|OF
argument_list|(
operator|(
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|get_method
name|OF
argument_list|(
operator|(
name|int
name|in
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|do_list
name|OF
argument_list|(
operator|(
name|int
name|ifd
operator|,
name|int
name|method
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|check_ofname
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|copy_stat
name|OF
argument_list|(
operator|(
expr|struct
name|stat
operator|*
name|ifstat
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|do_exit
name|OF
argument_list|(
operator|(
name|int
name|exitcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
decl|main
name|OF
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_macro
name|int
argument_list|(
argument|*work
argument_list|)
end_macro

begin_expr_stmt
name|OF
argument_list|(
operator|(
name|int
name|infile
operator|,
name|int
name|outfile
operator|)
argument_list|)
operator|=
name|zip
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* function to call */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DIR
end_ifndef

begin_decl_stmt
name|local
name|void
name|treat_dir
name|OF
argument_list|(
operator|(
name|char
operator|*
name|dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_UTIME
end_ifndef

begin_decl_stmt
name|local
name|void
name|reset_times
name|OF
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
expr|struct
name|stat
operator|*
name|statb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|strequ
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
value|(strcmp((s1),(s2)) == 0)
end_define

begin_comment
comment|/* ======================================================================== */
end_comment

begin_function
name|local
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s [-%scdfhlLnN%stvV19] [-S suffix] [file ...]\n"
argument_list|,
name|progname
argument_list|,
if|#
directive|if
name|O_BINARY
literal|"a"
argument_list|,
else|#
directive|else
literal|""
argument_list|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_DIR
literal|""
else|#
directive|else
literal|"r"
endif|#
directive|endif
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ======================================================================== */
end_comment

begin_function
name|local
name|void
name|help
parameter_list|()
block|{
specifier|static
name|char
modifier|*
name|help_msg
index|[]
init|=
block|{
if|#
directive|if
name|O_BINARY
literal|" -a --ascii       ascii text; convert end-of-lines using local conventions"
block|,
endif|#
directive|endif
literal|" -c --stdout      write on standard output, keep original files unchanged"
block|,
literal|" -d --decompress  decompress"
block|,
comment|/* -e --encrypt     encrypt */
literal|" -f --force       force overwrite of output file and compress links"
block|,
literal|" -h --help        give this help"
block|,
comment|/* -k --pkzip       force output in pkzip format */
literal|" -l --list        list compressed file contents"
block|,
literal|" -L --license     display software license"
block|,
ifdef|#
directive|ifdef
name|UNDOCUMENTED
literal|" -m --no-time     do not save or restore the original modification time"
block|,
literal|" -M --time        save or restore the original modification time"
block|,
endif|#
directive|endif
literal|" -n --no-name     do not save or restore the original name and time stamp"
block|,
literal|" -N --name        save or restore the original name and time stamp"
block|,
literal|" -q --quiet       suppress all warnings"
block|,
ifndef|#
directive|ifndef
name|NO_DIR
literal|" -r --recursive   operate recursively on directories"
block|,
endif|#
directive|endif
literal|" -S .suf  --suffix .suf     use suffix .suf on compressed files"
block|,
literal|" -t --test        test compressed file integrity"
block|,
literal|" -v --verbose     verbose mode"
block|,
literal|" -V --version     display version number"
block|,
literal|" -1 --fast        compress faster"
block|,
literal|" -9 --best        compress better"
block|,
ifdef|#
directive|ifdef
name|LZW
literal|" -Z --lzw         produce output compatible with old compress"
block|,
literal|" -b --bits maxbits   max number of bits per code (implies -Z)"
block|,
endif|#
directive|endif
literal|" file...          files to (de)compress. If none given, use standard input."
block|,
literal|0
block|}
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
init|=
name|help_msg
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %s (%s)\n"
argument_list|,
name|progname
argument_list|,
name|VERSION
argument_list|,
name|REVDATE
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ======================================================================== */
end_comment

begin_function
name|local
name|void
name|license
parameter_list|()
block|{
name|char
modifier|*
modifier|*
name|p
init|=
name|license_msg
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %s (%s)\n"
argument_list|,
name|progname
argument_list|,
name|VERSION
argument_list|,
name|REVDATE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ======================================================================== */
end_comment

begin_function
name|local
name|void
name|version
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %s (%s)\n"
argument_list|,
name|progname
argument_list|,
name|VERSION
argument_list|,
name|REVDATE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Compilation options:\n%s %s "
argument_list|,
name|DIR_OPT
argument_list|,
name|TIME_OPT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STDC_HEADERS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"STDC_HEADERS "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"HAVE_UNISTD_H "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_MEMORY_H
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"NO_MEMORY_H "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_STRING_H
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"NO_STRING_H "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_SYMLINK
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"NO_SYMLINK "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_MULTIPLE_DOTS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"NO_MULTIPLE_DOTS "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_CHOWN
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"NO_CHOWN "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PROTO
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PROTO "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ASMV
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ASMV "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEBUG "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DYN_ALLOC
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DYN_ALLOC "
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MAXSEG_64K
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"MAXSEG_64K"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ======================================================================== */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|file_count
decl_stmt|;
comment|/* number of files to precess */
name|int
name|proglen
decl_stmt|;
comment|/* length of progname */
name|int
name|optc
decl_stmt|;
comment|/* current option */
name|EXPAND
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* wild card expansion if necessary */
name|progname
operator|=
name|basename
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|proglen
operator|=
name|strlen
argument_list|(
name|progname
argument_list|)
expr_stmt|;
comment|/* Suppress .exe for MSDOS, OS/2 and VMS: */
if|if
condition|(
name|proglen
operator|>
literal|4
operator|&&
name|strequ
argument_list|(
name|progname
operator|+
name|proglen
operator|-
literal|4
argument_list|,
literal|".exe"
argument_list|)
condition|)
block|{
name|progname
index|[
name|proglen
operator|-
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Add options in GZIP environment variable if there is one */
name|env
operator|=
name|add_envopt
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|,
name|OPTIONS_VAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|!=
name|NULL
condition|)
name|args
operator|=
name|argv
expr_stmt|;
name|foreground
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
expr_stmt|;
if|if
condition|(
name|foreground
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
operator|(
name|sig_type
operator|)
name|abort_gzip
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SIGTERM
if|if
condition|(
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
operator|(
name|sig_type
operator|)
name|abort_gzip
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
operator|(
name|sig_type
operator|)
name|abort_gzip
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|GNU_STANDARD
comment|/* For compatibility with old compress, use program name as an option.      * If you compile with -DGNU_STANDARD, this program will behave as      * gzip even if it is invoked under the name gunzip or zcat.      *      * Systems which do not support links can still use -d or -dc.      * Ignore an .exe extension for MSDOS, OS/2 and VMS.      */
if|if
condition|(
name|strncmp
argument_list|(
name|progname
argument_list|,
literal|"un"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
comment|/* ungzip, uncompress */
operator|||
name|strncmp
argument_list|(
name|progname
argument_list|,
literal|"gun"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* gunzip */
name|decompress
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strequ
argument_list|(
name|progname
operator|+
literal|1
argument_list|,
literal|"cat"
argument_list|)
comment|/* zcat, pcat, gcat */
operator|||
name|strequ
argument_list|(
name|progname
argument_list|,
literal|"gzcat"
argument_list|)
condition|)
block|{
comment|/* gzcat */
name|decompress
operator|=
name|to_stdout
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|strncpy
argument_list|(
name|z_suffix
argument_list|,
name|Z_SUFFIX
argument_list|,
sizeof|sizeof
argument_list|(
name|z_suffix
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|z_len
operator|=
name|strlen
argument_list|(
name|z_suffix
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|optc
operator|=
name|getopt_long
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ab:cdfhH?lLmMnNqrS:tvVZ123456789"
argument_list|,
name|longopts
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|optc
condition|)
block|{
case|case
literal|'a'
case|:
name|ascii
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|maxbits
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|to_stdout
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|decompress
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|force
operator|++
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
case|case
literal|'?'
case|:
name|help
argument_list|()
expr_stmt|;
name|do_exit
argument_list|(
name|OK
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|list
operator|=
name|decompress
operator|=
name|to_stdout
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|license
argument_list|()
expr_stmt|;
name|do_exit
argument_list|(
name|OK
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* undocumented, may change later */
name|no_time
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* undocumented, may change later */
name|no_time
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|no_name
operator|=
name|no_time
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|no_name
operator|=
name|no_time
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
name|verbose
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
ifdef|#
directive|ifdef
name|NO_DIR
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -r not supported on this system\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
name|do_exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
name|recursive
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'S'
case|:
ifdef|#
directive|ifdef
name|NO_MULTIPLE_DOTS
if|if
condition|(
operator|*
name|optarg
operator|==
literal|'.'
condition|)
name|optarg
operator|++
expr_stmt|;
endif|#
directive|endif
name|z_len
operator|=
name|strlen
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|z_suffix
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|test
operator|=
name|decompress
operator|=
name|to_stdout
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
name|quiet
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|version
argument_list|()
expr_stmt|;
name|do_exit
argument_list|(
name|OK
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
ifdef|#
directive|ifdef
name|LZW
name|do_lzw
operator|=
literal|1
expr_stmt|;
break|break;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: -Z not supported in this version\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
name|do_exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|level
operator|=
name|optc
operator|-
literal|'0'
expr_stmt|;
break|break;
default|default:
comment|/* Error message already emitted by getopt_long. */
name|usage
argument_list|()
expr_stmt|;
name|do_exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* loop on all arguments */
comment|/* By default, save name and timestamp on compression but do not      * restore them on decompression.      */
if|if
condition|(
name|no_time
operator|<
literal|0
condition|)
name|no_time
operator|=
name|decompress
expr_stmt|;
if|if
condition|(
name|no_name
operator|<
literal|0
condition|)
name|no_name
operator|=
name|decompress
expr_stmt|;
name|file_count
operator|=
name|argc
operator|-
name|optind
expr_stmt|;
if|#
directive|if
name|O_BINARY
else|#
directive|else
if|if
condition|(
name|ascii
operator|&&
operator|!
name|quiet
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: option --ascii ignored on this system\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|z_len
operator|==
literal|0
operator|&&
operator|!
name|decompress
operator|)
operator|||
name|z_len
operator|>
name|MAX_SUFFIX
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: incorrect suffix '%s'\n"
argument_list|,
name|progname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|do_exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_lzw
operator|&&
operator|!
name|decompress
condition|)
name|work
operator|=
name|lzw
expr_stmt|;
comment|/* Allocate all global buffers (for DYN_ALLOC option) */
name|ALLOC
argument_list|(
name|uch
argument_list|,
name|inbuf
argument_list|,
name|INBUFSIZ
operator|+
name|INBUF_EXTRA
argument_list|)
expr_stmt|;
name|ALLOC
argument_list|(
name|uch
argument_list|,
name|outbuf
argument_list|,
name|OUTBUFSIZ
operator|+
name|OUTBUF_EXTRA
argument_list|)
expr_stmt|;
name|ALLOC
argument_list|(
name|ush
argument_list|,
name|d_buf
argument_list|,
name|DIST_BUFSIZE
argument_list|)
expr_stmt|;
name|ALLOC
argument_list|(
name|uch
argument_list|,
name|window
argument_list|,
literal|2L
operator|*
name|WSIZE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MAXSEG_64K
name|ALLOC
argument_list|(
name|ush
argument_list|,
name|tab_prefix
argument_list|,
literal|1L
operator|<<
name|BITS
argument_list|)
expr_stmt|;
else|#
directive|else
name|ALLOC
argument_list|(
name|ush
argument_list|,
name|tab_prefix0
argument_list|,
literal|1L
operator|<<
operator|(
name|BITS
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|ALLOC
argument_list|(
name|ush
argument_list|,
name|tab_prefix1
argument_list|,
literal|1L
operator|<<
operator|(
name|BITS
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* And get to work */
if|if
condition|(
name|file_count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|to_stdout
operator|&&
operator|!
name|test
operator|&&
operator|!
name|list
operator|&&
operator|(
operator|!
name|decompress
operator|||
operator|!
name|ascii
operator|)
condition|)
block|{
name|SET_BINARY_MODE
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|treat_file
argument_list|(
name|argv
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Standard input */
name|treat_stdin
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|list
operator|&&
operator|!
name|quiet
operator|&&
name|file_count
operator|>
literal|1
condition|)
block|{
name|do_list
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* print totals */
block|}
name|do_exit
argument_list|(
name|exit_code
argument_list|)
expr_stmt|;
return|return
name|exit_code
return|;
comment|/* just to avoid lint warning */
block|}
end_function

begin_comment
comment|/* ========================================================================  * Compress or decompress stdin  */
end_comment

begin_function
name|local
name|void
name|treat_stdin
parameter_list|()
block|{
if|if
condition|(
operator|!
name|force
operator|&&
operator|!
name|list
operator|&&
name|isatty
argument_list|(
name|fileno
argument_list|(
operator|(
name|FILE
operator|*
operator|)
operator|(
name|decompress
condition|?
name|stdin
else|:
name|stdout
operator|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Do not send compressed data to the terminal or read it from 	 * the terminal. We get here when user invoked the program 	 * without parameters, so be helpful. According to the GNU standards: 	 * 	 *   If there is one behavior you think is most useful when the output 	 *   is to a terminal, and another that you think is most useful when 	 *   the output is a file or a pipe, then it is usually best to make 	 *   the default behavior the one that is useful with output to a 	 *   terminal, and have an option for the other behavior. 	 * 	 * Here we use the --force option to get the other behavior. 	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: compressed data not %s a terminal. Use -f to force %scompression.\n"
argument_list|,
name|progname
argument_list|,
name|decompress
condition|?
literal|"read from"
else|:
literal|"written to"
argument_list|,
name|decompress
condition|?
literal|"de"
else|:
literal|""
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"For help, type: %s -h\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|do_exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|decompress
operator|||
operator|!
name|ascii
condition|)
block|{
name|SET_BINARY_MODE
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|test
operator|&&
operator|!
name|list
operator|&&
operator|(
operator|!
name|decompress
operator|||
operator|!
name|ascii
operator|)
condition|)
block|{
name|SET_BINARY_MODE
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|ifname
argument_list|,
literal|"stdin"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ofname
argument_list|,
literal|"stdout"
argument_list|)
expr_stmt|;
comment|/* Get the time stamp on the input file. */
name|time_stamp
operator|=
literal|0
expr_stmt|;
comment|/* time unknown by default */
ifndef|#
directive|ifndef
name|NO_STDIN_FSTAT
if|if
condition|(
name|list
operator|||
operator|!
name|no_time
condition|)
block|{
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|istat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"fstat(stdin)"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NO_PIPE_TIMESTAMP
if|if
condition|(
name|S_ISREG
argument_list|(
name|istat
operator|.
name|st_mode
argument_list|)
condition|)
endif|#
directive|endif
name|time_stamp
operator|=
name|istat
operator|.
name|st_mtime
expr_stmt|;
endif|#
directive|endif
comment|/* NO_STDIN_FSTAT */
block|}
name|ifile_size
operator|=
operator|-
literal|1L
expr_stmt|;
comment|/* convention for unknown size */
name|clear_bufs
argument_list|()
expr_stmt|;
comment|/* clear input and output buffers */
name|to_stdout
operator|=
literal|1
expr_stmt|;
name|part_nb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|decompress
condition|)
block|{
name|method
operator|=
name|get_method
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
operator|<
literal|0
condition|)
block|{
name|do_exit
argument_list|(
name|exit_code
argument_list|)
expr_stmt|;
comment|/* error message already emitted */
block|}
block|}
if|if
condition|(
name|list
condition|)
block|{
name|do_list
argument_list|(
name|ifd
argument_list|,
name|method
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Actually do the compression/decompression. Loop over zipped members.      */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
call|(
modifier|*
name|work
call|)
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
operator|!=
name|OK
condition|)
return|return;
if|if
condition|(
operator|!
name|decompress
operator|||
name|last_member
operator|||
name|inptr
operator|==
name|insize
condition|)
break|break;
comment|/* end of file */
name|method
operator|=
name|get_method
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
operator|<
literal|0
condition|)
return|return;
comment|/* error message already emitted */
name|bytes_out
operator|=
literal|0
expr_stmt|;
comment|/* required for length check */
block|}
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|test
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" OK\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|decompress
condition|)
block|{
name|display_ratio
argument_list|(
name|bytes_in
operator|-
operator|(
name|bytes_out
operator|-
name|header_bytes
operator|)
argument_list|,
name|bytes_in
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DISPLAY_STDIN_RATIO
block|}
else|else
block|{
name|display_ratio
argument_list|(
name|bytes_out
operator|-
operator|(
name|bytes_in
operator|-
name|header_bytes
operator|)
argument_list|,
name|bytes_out
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/* ========================================================================  * Compress or decompress the given file  */
end_comment

begin_function
name|local
name|void
name|treat_file
parameter_list|(
name|iname
parameter_list|)
name|char
modifier|*
name|iname
decl_stmt|;
block|{
comment|/* Accept "-" as synonym for stdin */
if|if
condition|(
name|strequ
argument_list|(
name|iname
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|int
name|cflag
init|=
name|to_stdout
decl_stmt|;
name|treat_stdin
argument_list|()
expr_stmt|;
name|to_stdout
operator|=
name|cflag
expr_stmt|;
return|return;
block|}
comment|/* Check if the input file is present, set ifname and istat: */
if|if
condition|(
name|get_istat
argument_list|(
name|iname
argument_list|,
operator|&
name|istat
argument_list|)
operator|!=
name|OK
condition|)
return|return;
comment|/* If the input name is that of a directory, recurse or ignore: */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|istat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_DIR
if|if
condition|(
name|recursive
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|st
operator|=
name|istat
expr_stmt|;
name|treat_dir
argument_list|(
name|iname
argument_list|)
expr_stmt|;
comment|/* Warning: ifname is now garbage */
ifndef|#
directive|ifndef
name|NO_UTIME
name|reset_times
argument_list|(
name|iname
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
endif|#
directive|endif
name|WARN
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: %s is a directory -- ignored\n"
operator|,
name|progname
operator|,
name|ifname
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|istat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|WARN
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: %s is not a directory or a regular file - ignored\n"
operator|,
name|progname
operator|,
name|ifname
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|istat
operator|.
name|st_nlink
operator|>
literal|1
operator|&&
operator|!
name|to_stdout
operator|&&
operator|!
name|force
condition|)
block|{
name|WARN
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: %s has %d other link%c -- unchanged\n"
operator|,
name|progname
operator|,
name|ifname
operator|,
operator|(
name|int
operator|)
name|istat
operator|.
name|st_nlink
operator|-
literal|1
operator|,
name|istat
operator|.
name|st_nlink
operator|>
literal|2
condition|?
literal|'s'
else|:
literal|' '
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifile_size
operator|=
name|istat
operator|.
name|st_size
expr_stmt|;
name|time_stamp
operator|=
name|no_time
operator|&&
operator|!
name|list
condition|?
literal|0
else|:
name|istat
operator|.
name|st_mtime
expr_stmt|;
comment|/* Generate output file name. For -r and (-t or -l), skip files      * without a valid gzip suffix (check done in make_ofname).      */
if|if
condition|(
name|to_stdout
operator|&&
operator|!
name|list
operator|&&
operator|!
name|test
condition|)
block|{
name|strcpy
argument_list|(
name|ofname
argument_list|,
literal|"stdout"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|make_ofname
argument_list|()
operator|!=
name|OK
condition|)
block|{
return|return;
block|}
comment|/* Open the input file and determine compression method. The mode      * parameter is ignored but required by some systems (VMS) and forbidden      * on other systems (MacOS).      */
name|ifd
operator|=
name|OPEN
argument_list|(
name|ifname
argument_list|,
name|ascii
operator|&&
operator|!
name|decompress
condition|?
name|O_RDONLY
else|:
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
name|RW_USER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifd
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return;
block|}
name|clear_bufs
argument_list|()
expr_stmt|;
comment|/* clear input and output buffers */
name|part_nb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|decompress
condition|)
block|{
name|method
operator|=
name|get_method
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
comment|/* updates ofname if original given */
if|if
condition|(
name|method
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
return|return;
comment|/* error message already emitted */
block|}
block|}
if|if
condition|(
name|list
condition|)
block|{
name|do_list
argument_list|(
name|ifd
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If compressing to a file, check if ofname is not ambiguous      * because the operating system truncates names. Otherwise, generate      * a new ofname and save the original name in the compressed file.      */
if|if
condition|(
name|to_stdout
condition|)
block|{
name|ofd
operator|=
name|fileno
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* keep remove_ofname as zero */
block|}
else|else
block|{
if|if
condition|(
name|create_outfile
argument_list|()
operator|!=
name|OK
condition|)
return|return;
if|if
condition|(
operator|!
name|decompress
operator|&&
name|save_orig_name
operator|&&
operator|!
name|verbose
operator|&&
operator|!
name|quiet
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s compressed to %s\n"
argument_list|,
name|progname
argument_list|,
name|ifname
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Keep the name even if not truncated except with --no-name: */
if|if
condition|(
operator|!
name|save_orig_name
condition|)
name|save_orig_name
operator|=
operator|!
name|no_name
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:\t%s"
argument_list|,
name|ifname
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|ifname
argument_list|)
operator|>=
literal|15
condition|?
literal|""
else|:
operator|(
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|ifname
argument_list|)
operator|>=
literal|7
condition|?
literal|"\t"
else|:
literal|"\t\t"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Actually do the compression/decompression. Loop over zipped members.      */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
call|(
modifier|*
name|work
call|)
argument_list|(
name|ifd
argument_list|,
name|ofd
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|method
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* force cleanup */
break|break;
block|}
if|if
condition|(
operator|!
name|decompress
operator|||
name|last_member
operator|||
name|inptr
operator|==
name|insize
condition|)
break|break;
comment|/* end of file */
name|method
operator|=
name|get_method
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
operator|<
literal|0
condition|)
break|break;
comment|/* error message already emitted */
name|bytes_out
operator|=
literal|0
expr_stmt|;
comment|/* required for length check */
block|}
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|to_stdout
operator|&&
name|close
argument_list|(
name|ofd
argument_list|)
condition|)
block|{
name|write_error
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|method
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|to_stdout
condition|)
name|unlink
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Display statistics */
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|test
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" OK"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decompress
condition|)
block|{
name|display_ratio
argument_list|(
name|bytes_out
operator|-
operator|(
name|bytes_in
operator|-
name|header_bytes
operator|)
argument_list|,
name|bytes_out
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|display_ratio
argument_list|(
name|bytes_in
operator|-
operator|(
name|bytes_out
operator|-
name|header_bytes
operator|)
argument_list|,
name|bytes_in
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|test
operator|&&
operator|!
name|to_stdout
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -- replaced with %s"
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Copy modes, times, ownership, and remove the input file */
if|if
condition|(
operator|!
name|to_stdout
condition|)
block|{
name|copy_stat
argument_list|(
operator|&
name|istat
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ========================================================================  * Create the output file. Return OK or ERROR.  * Try several times if necessary to avoid truncating the z_suffix. For  * example, do not create a compressed file of name "1234567890123."  * Sets save_orig_name to true if the file name has been truncated.  * IN assertions: the input file has already been open (ifd is set) and  *   ofname has already been updated if there was an original name.  * OUT assertions: ifd and ofd are closed in case of error.  */
end_comment

begin_function
name|local
name|int
name|create_outfile
parameter_list|()
block|{
name|struct
name|stat
name|ostat
decl_stmt|;
comment|/* stat for ofname */
name|int
name|flags
init|=
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
operator||
name|O_BINARY
decl_stmt|;
if|if
condition|(
name|ascii
operator|&&
name|decompress
condition|)
block|{
name|flags
operator|&=
operator|~
name|O_BINARY
expr_stmt|;
comment|/* force ascii text mode */
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Make sure that ofname is not an existing file */
if|if
condition|(
name|check_ofname
argument_list|()
operator|!=
name|OK
condition|)
block|{
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
comment|/* Create the output file */
name|remove_ofname
operator|=
literal|1
expr_stmt|;
name|ofd
operator|=
name|OPEN
argument_list|(
name|ofname
argument_list|,
name|flags
argument_list|,
name|RW_USER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofd
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return
name|ERROR
return|;
block|}
comment|/* Check for name truncation on new file (1234567890123.gz) */
ifdef|#
directive|ifdef
name|NO_FSTAT
if|if
condition|(
name|stat
argument_list|(
name|ofname
argument_list|,
operator|&
name|ostat
argument_list|)
operator|!=
literal|0
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|fstat
argument_list|(
name|ofd
argument_list|,
operator|&
name|ostat
argument_list|)
operator|!=
literal|0
condition|)
block|{
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return
name|ERROR
return|;
block|}
if|if
condition|(
operator|!
name|name_too_long
argument_list|(
name|ofname
argument_list|,
operator|&
name|ostat
argument_list|)
condition|)
return|return
name|OK
return|;
if|if
condition|(
name|decompress
condition|)
block|{
comment|/* name might be too long if an original name was saved */
name|WARN
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: %s: warning, name truncated\n"
operator|,
name|progname
operator|,
name|ofname
operator|)
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
name|close
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_MULTIPLE_DOTS
comment|/* Should never happen, see check_ofname() */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: name too long\n"
argument_list|,
name|progname
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
name|do_exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|shorten_name
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ========================================================================  * Use lstat if available, except for -c or -f. Use stat otherwise.  * This allows links when not removing the original file.  */
name|local
name|int
name|do_stat
parameter_list|(
name|name
parameter_list|,
name|sbuf
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|stat
modifier|*
name|sbuf
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|S_IFLNK
argument_list|)
operator|||
name|defined
argument_list|(
name|S_ISLNK
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_SYMLINK
argument_list|)
if|if
condition|(
operator|!
name|to_stdout
operator|&&
operator|!
name|force
condition|)
block|{
return|return
name|lstat
argument_list|(
name|name
argument_list|,
name|sbuf
argument_list|)
return|;
block|}
endif|#
directive|endif
return|return
name|stat
argument_list|(
name|name
argument_list|,
name|sbuf
argument_list|)
return|;
block|}
comment|/* ========================================================================  * Return a pointer to the 'z' suffix of a file name, or NULL. For all  * systems, ".gz", ".z", ".Z", ".taz", ".tgz", "-gz", "-z" and "_z" are  * accepted suffixes, in addition to the value of the --suffix option.  * ".tgz" is a useful convention for tar.z files on systems limited  * to 3 characters extensions. On such systems, ".?z" and ".??z" are  * also accepted suffixes. For Unix, we do not want to accept any  * .??z suffix as indicating a compressed file; some people use .xyz  * to denote volume data.  *   On systems allowing multiple versions of the same file (such as VMS),  * this function removes any version suffix in the given name.  */
name|local
name|char
modifier|*
name|get_suffix
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|nlen
decl_stmt|,
name|slen
decl_stmt|;
name|char
name|suffix
index|[
name|MAX_SUFFIX
operator|+
literal|3
index|]
decl_stmt|;
comment|/* last chars of name, forced to lower case */
specifier|static
name|char
modifier|*
name|known_suffixes
index|[]
init|=
block|{
name|z_suffix
block|,
literal|".gz"
block|,
literal|".z"
block|,
literal|".taz"
block|,
literal|".tgz"
block|,
literal|"-gz"
block|,
literal|"-z"
block|,
literal|"_z"
block|,
ifdef|#
directive|ifdef
name|MAX_EXT_CHARS
literal|"z"
block|,
endif|#
directive|endif
name|NULL
block|}
decl_stmt|;
name|char
modifier|*
modifier|*
name|suf
init|=
name|known_suffixes
decl_stmt|;
if|if
condition|(
name|strequ
argument_list|(
name|z_suffix
argument_list|,
literal|"z"
argument_list|)
condition|)
name|suf
operator|++
expr_stmt|;
comment|/* check long suffixes first */
ifdef|#
directive|ifdef
name|SUFFIX_SEP
comment|/* strip a version number from the file name */
block|{
name|char
modifier|*
name|v
init|=
name|strrchr
argument_list|(
name|name
argument_list|,
name|SUFFIX_SEP
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
operator|*
name|v
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
name|nlen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlen
operator|<=
name|MAX_SUFFIX
operator|+
literal|2
condition|)
block|{
name|strcpy
argument_list|(
name|suffix
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|suffix
argument_list|,
name|name
operator|+
name|nlen
operator|-
name|MAX_SUFFIX
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
name|strlwr
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
name|slen
operator|=
name|strlen
argument_list|(
name|suffix
argument_list|)
expr_stmt|;
do|do
block|{
name|int
name|s
init|=
name|strlen
argument_list|(
operator|*
name|suf
argument_list|)
decl_stmt|;
if|if
condition|(
name|slen
operator|>
name|s
operator|&&
name|suffix
index|[
name|slen
operator|-
name|s
operator|-
literal|1
index|]
operator|!=
name|PATH_SEP
operator|&&
name|strequ
argument_list|(
name|suffix
operator|+
name|slen
operator|-
name|s
argument_list|,
operator|*
name|suf
argument_list|)
condition|)
block|{
return|return
name|name
operator|+
name|nlen
operator|-
name|s
return|;
block|}
block|}
do|while
condition|(
operator|*
operator|++
name|suf
operator|!=
name|NULL
condition|)
do|;
return|return
name|NULL
return|;
block|}
comment|/* ========================================================================  * Set ifname to the input file name (with a suffix appended if necessary)  * and istat to its stats. For decompression, if no file exists with the  * original name, try adding successively z_suffix, .gz, .z, -z and .Z.  * For MSDOS, we try only z_suffix and z.  * Return OK or ERROR.  */
name|local
name|int
name|get_istat
parameter_list|(
name|iname
parameter_list|,
name|sbuf
parameter_list|)
name|char
modifier|*
name|iname
decl_stmt|;
name|struct
name|stat
modifier|*
name|sbuf
decl_stmt|;
block|{
name|int
name|ilen
decl_stmt|;
comment|/* strlen(ifname) */
specifier|static
name|char
modifier|*
name|suffixes
index|[]
init|=
block|{
name|z_suffix
block|,
literal|".gz"
block|,
literal|".z"
block|,
literal|"-z"
block|,
literal|".Z"
block|,
name|NULL
block|}
decl_stmt|;
name|char
modifier|*
modifier|*
name|suf
init|=
name|suffixes
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|NO_MULTIPLE_DOTS
name|char
modifier|*
name|dot
decl_stmt|;
comment|/* pointer to ifname extension, or NULL */
endif|#
directive|endif
if|if
condition|(
name|strlen
argument_list|(
name|iname
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|ifname
argument_list|)
operator|-
literal|3
condition|)
block|{
name|errno
operator|=
name|ENAMETOOLONG
expr_stmt|;
name|perror
argument_list|(
name|iname
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return
name|ERROR
return|;
block|}
name|strcpy
argument_list|(
name|ifname
argument_list|,
name|iname
argument_list|)
expr_stmt|;
comment|/* If input file exists, return OK. */
if|if
condition|(
name|do_stat
argument_list|(
name|ifname
argument_list|,
name|sbuf
argument_list|)
operator|==
literal|0
condition|)
return|return
name|OK
return|;
if|if
condition|(
operator|!
name|decompress
operator|||
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|perror
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return
name|ERROR
return|;
block|}
comment|/* file.ext doesn't exist, try adding a suffix (after removing any      * version number for VMS).      */
name|s
operator|=
name|get_suffix
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
comment|/* ifname already has z suffix and does not exist */
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return
name|ERROR
return|;
block|}
ifdef|#
directive|ifdef
name|NO_MULTIPLE_DOTS
name|dot
operator|=
name|strrchr
argument_list|(
name|ifname
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
operator|==
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|ifname
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|dot
operator|=
name|strrchr
argument_list|(
name|ifname
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ilen
operator|=
name|strlen
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strequ
argument_list|(
name|z_suffix
argument_list|,
literal|".gz"
argument_list|)
condition|)
name|suf
operator|++
expr_stmt|;
comment|/* Search for all suffixes */
do|do
block|{
name|s
operator|=
operator|*
name|suf
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_MULTIPLE_DOTS
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
name|s
operator|++
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MAX_EXT_CHARS
name|strcpy
argument_list|(
name|ifname
argument_list|,
name|iname
argument_list|)
expr_stmt|;
comment|/* Needed if the suffixes are not sorted by increasing length */
if|if
condition|(
operator|*
name|dot
operator|==
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|dot
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|dot
index|[
name|MAX_EXT_CHARS
operator|+
literal|1
operator|-
name|strlen
argument_list|(
name|s
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
name|strcat
argument_list|(
name|ifname
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_stat
argument_list|(
name|ifname
argument_list|,
name|sbuf
argument_list|)
operator|==
literal|0
condition|)
return|return
name|OK
return|;
name|ifname
index|[
name|ilen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|++
name|suf
operator|!=
name|NULL
condition|)
do|;
comment|/* No suffix found, complain using z_suffix: */
ifdef|#
directive|ifdef
name|MAX_EXT_CHARS
name|strcpy
argument_list|(
name|ifname
argument_list|,
name|iname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dot
operator|==
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|dot
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|dot
index|[
name|MAX_EXT_CHARS
operator|+
literal|1
operator|-
name|z_len
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
name|strcat
argument_list|(
name|ifname
argument_list|,
name|z_suffix
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return
name|ERROR
return|;
block|}
comment|/* ========================================================================  * Generate ofname given ifname. Return OK, or WARNING if file must be skipped.  * Sets save_orig_name to true if the file name has been truncated.  */
name|local
name|int
name|make_ofname
parameter_list|()
block|{
name|char
modifier|*
name|suff
decl_stmt|;
comment|/* ofname z suffix */
name|strcpy
argument_list|(
name|ofname
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
comment|/* strip a version number if any and get the gzip suffix if present: */
name|suff
operator|=
name|get_suffix
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
if|if
condition|(
name|decompress
condition|)
block|{
if|if
condition|(
name|suff
operator|==
name|NULL
condition|)
block|{
comment|/* Whith -t or -l, try all files (even without .gz suffix) 	     * except with -r (behave as with just -dr).              */
if|if
condition|(
operator|!
name|recursive
operator|&&
operator|(
name|list
operator|||
name|test
operator|)
condition|)
return|return
name|OK
return|;
comment|/* Avoid annoying messages with -r */
if|if
condition|(
name|verbose
operator|||
operator|(
operator|!
name|recursive
operator|&&
operator|!
name|quiet
operator|)
condition|)
block|{
name|WARN
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: %s: unknown suffix -- ignored\n"
operator|,
name|progname
operator|,
name|ifname
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|WARNING
return|;
block|}
comment|/* Make a special case for .tgz and .taz: */
name|strlwr
argument_list|(
name|suff
argument_list|)
expr_stmt|;
if|if
condition|(
name|strequ
argument_list|(
name|suff
argument_list|,
literal|".tgz"
argument_list|)
operator|||
name|strequ
argument_list|(
name|suff
argument_list|,
literal|".taz"
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|suff
argument_list|,
literal|".tar"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|suff
operator|=
literal|'\0'
expr_stmt|;
comment|/* strip the z suffix */
block|}
comment|/* ofname might be changed later if infile contains an original name */
block|}
elseif|else
if|if
condition|(
name|suff
operator|!=
name|NULL
condition|)
block|{
comment|/* Avoid annoying messages with -r (see treat_dir()) */
if|if
condition|(
name|verbose
operator|||
operator|(
operator|!
name|recursive
operator|&&
operator|!
name|quiet
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s already has %s suffix -- unchanged\n"
argument_list|,
name|progname
argument_list|,
name|ifname
argument_list|,
name|suff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exit_code
operator|==
name|OK
condition|)
name|exit_code
operator|=
name|WARNING
expr_stmt|;
return|return
name|WARNING
return|;
block|}
else|else
block|{
name|save_orig_name
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_MULTIPLE_DOTS
name|suff
operator|=
name|strrchr
argument_list|(
name|ofname
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|suff
operator|==
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|ofname
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAX_EXT_CHARS
if|if
condition|(
name|strequ
argument_list|(
name|z_suffix
argument_list|,
literal|"z"
argument_list|)
condition|)
block|{
name|strcat
argument_list|(
name|ofname
argument_list|,
literal|"gz"
argument_list|)
expr_stmt|;
comment|/* enough room */
return|return
name|OK
return|;
block|}
comment|/* On the Atari and some versions of MSDOS, name_too_long()          * does not work correctly because of a bug in stat(). So we          * must truncate here.          */
block|}
elseif|else
if|if
condition|(
name|strlen
argument_list|(
name|suff
argument_list|)
operator|-
literal|1
operator|+
name|z_len
operator|>
name|MAX_SUFFIX
condition|)
block|{
name|suff
index|[
name|MAX_SUFFIX
operator|+
literal|1
operator|-
name|z_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|save_orig_name
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* NO_MULTIPLE_DOTS */
name|strcat
argument_list|(
name|ofname
argument_list|,
name|z_suffix
argument_list|)
expr_stmt|;
block|}
comment|/* decompress ? */
return|return
name|OK
return|;
block|}
comment|/* ========================================================================  * Check the magic number of the input file and update ofname if an  * original name was given and to_stdout is not set.  * Return the compression method, -1 for error, -2 for warning.  * Set inptr to the offset of the next byte to be processed.  * Updates time_stamp if there is one and --no-time is not used.  * This function may be called repeatedly for an input file consisting  * of several contiguous gzip'ed members.  * IN assertions: there is at least one remaining compressed member.  *   If the member is a zip file, it must be the only one.  */
name|local
name|int
name|get_method
parameter_list|(
name|in
parameter_list|)
name|int
name|in
decl_stmt|;
comment|/* input file descriptor */
block|{
name|uch
name|flags
decl_stmt|;
comment|/* compression flags */
name|char
name|magic
index|[
literal|2
index|]
decl_stmt|;
comment|/* magic header */
name|ulg
name|stamp
decl_stmt|;
comment|/* time stamp */
comment|/* If --force and --stdout, zcat == cat, so do not complain about      * premature end of file: use try_byte instead of get_byte.      */
if|if
condition|(
name|force
operator|&&
name|to_stdout
condition|)
block|{
name|magic
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|try_byte
argument_list|()
expr_stmt|;
name|magic
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|)
name|try_byte
argument_list|()
expr_stmt|;
comment|/* If try_byte returned EOF, magic[1] == 0xff */
block|}
else|else
block|{
name|magic
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|get_byte
argument_list|()
expr_stmt|;
name|magic
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|)
name|get_byte
argument_list|()
expr_stmt|;
block|}
name|method
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* unknown yet */
name|part_nb
operator|++
expr_stmt|;
comment|/* number of parts in gzip file */
name|header_bytes
operator|=
literal|0
expr_stmt|;
name|last_member
operator|=
name|RECORD_IO
expr_stmt|;
comment|/* assume multiple members in gzip file except for record oriented I/O */
if|if
condition|(
name|memcmp
argument_list|(
name|magic
argument_list|,
name|GZIP_MAGIC
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|memcmp
argument_list|(
name|magic
argument_list|,
name|OLD_GZIP_MAGIC
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|method
operator|=
operator|(
name|int
operator|)
name|get_byte
argument_list|()
expr_stmt|;
if|if
condition|(
name|method
operator|!=
name|DEFLATED
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: unknown method %d -- get newer version of gzip\n"
argument_list|,
name|progname
argument_list|,
name|ifname
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|work
operator|=
name|unzip
expr_stmt|;
name|flags
operator|=
operator|(
name|uch
operator|)
name|get_byte
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ENCRYPTED
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s is encrypted -- get newer version of gzip\n"
argument_list|,
name|progname
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|CONTINUATION
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s is a a multi-part gzip file -- get newer version of gzip\n"
argument_list|,
name|progname
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
if|if
condition|(
name|force
operator|<=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|RESERVED
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s has flags 0x%x -- get newer version of gzip\n"
argument_list|,
name|progname
argument_list|,
name|ifname
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
if|if
condition|(
name|force
operator|<=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|stamp
operator|=
operator|(
name|ulg
operator|)
name|get_byte
argument_list|()
expr_stmt|;
name|stamp
operator||=
operator|(
operator|(
name|ulg
operator|)
name|get_byte
argument_list|()
operator|)
operator|<<
literal|8
expr_stmt|;
name|stamp
operator||=
operator|(
operator|(
name|ulg
operator|)
name|get_byte
argument_list|()
operator|)
operator|<<
literal|16
expr_stmt|;
name|stamp
operator||=
operator|(
operator|(
name|ulg
operator|)
name|get_byte
argument_list|()
operator|)
operator|<<
literal|24
expr_stmt|;
if|if
condition|(
name|stamp
operator|!=
literal|0
operator|&&
operator|!
name|no_time
condition|)
name|time_stamp
operator|=
name|stamp
expr_stmt|;
operator|(
name|void
operator|)
name|get_byte
argument_list|()
expr_stmt|;
comment|/* Ignore extra flags for the moment */
operator|(
name|void
operator|)
name|get_byte
argument_list|()
expr_stmt|;
comment|/* Ignore OS type for the moment */
if|if
condition|(
operator|(
name|flags
operator|&
name|CONTINUATION
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|part
init|=
operator|(
name|unsigned
operator|)
name|get_byte
argument_list|()
decl_stmt|;
name|part
operator||=
operator|(
operator|(
name|unsigned
operator|)
name|get_byte
argument_list|()
operator|)
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: part number %u\n"
argument_list|,
name|progname
argument_list|,
name|ifname
argument_list|,
name|part
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|EXTRA_FIELD
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|len
init|=
operator|(
name|unsigned
operator|)
name|get_byte
argument_list|()
decl_stmt|;
name|len
operator||=
operator|(
operator|(
name|unsigned
operator|)
name|get_byte
argument_list|()
operator|)
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: extra field of %u bytes ignored\n"
argument_list|,
name|progname
argument_list|,
name|ifname
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|--
condition|)
operator|(
name|void
operator|)
name|get_byte
argument_list|()
expr_stmt|;
block|}
comment|/* Get original file name if it was truncated */
if|if
condition|(
operator|(
name|flags
operator|&
name|ORIG_NAME
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|no_name
operator|||
operator|(
name|to_stdout
operator|&&
operator|!
name|list
operator|)
operator|||
name|part_nb
operator|>
literal|1
condition|)
block|{
comment|/* Discard the old name */
name|char
name|c
decl_stmt|;
comment|/* dummy used for NeXTstep 3.0 cc optimizer bug */
do|do
block|{
name|c
operator|=
name|get_byte
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|0
condition|)
do|;
block|}
else|else
block|{
comment|/* Copy the base name. Keep a directory prefix intact. */
name|char
modifier|*
name|p
init|=
name|basename
argument_list|(
name|ofname
argument_list|)
decl_stmt|;
name|char
modifier|*
name|base
init|=
name|p
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|get_char
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|p
operator|>=
name|ofname
operator|+
sizeof|sizeof
argument_list|(
name|ofname
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"corrupted input -- file name too large"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If necessary, adapt the name to local OS conventions: */
if|if
condition|(
operator|!
name|list
condition|)
block|{
name|MAKE_LEGAL_NAME
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
condition|)
name|list
operator|=
literal|0
expr_stmt|;
comment|/* avoid warning about unused variable */
block|}
block|}
comment|/* no_name || to_stdout */
block|}
comment|/* ORIG_NAME */
comment|/* Discard file comment if any */
if|if
condition|(
operator|(
name|flags
operator|&
name|COMMENT
operator|)
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|get_char
argument_list|()
operator|!=
literal|0
condition|)
comment|/* null */
empty_stmt|;
block|}
if|if
condition|(
name|part_nb
operator|==
literal|1
condition|)
block|{
name|header_bytes
operator|=
name|inptr
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
comment|/* include crc and size */
block|}
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|magic
argument_list|,
name|PKZIP_MAGIC
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|&&
name|inptr
operator|==
literal|2
operator|&&
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|inbuf
argument_list|,
name|PKZIP_MAGIC
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* To simplify the code, we support a zip file when alone only.          * We are thus guaranteed that the entire local header fits in inbuf.          */
name|inptr
operator|=
literal|0
expr_stmt|;
name|work
operator|=
name|unzip
expr_stmt|;
if|if
condition|(
name|check_zipfile
argument_list|(
name|in
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|-
literal|1
return|;
comment|/* check_zipfile may get ofname from the local header */
name|last_member
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|magic
argument_list|,
name|PACK_MAGIC
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|work
operator|=
name|unpack
expr_stmt|;
name|method
operator|=
name|PACKED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|magic
argument_list|,
name|LZW_MAGIC
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|work
operator|=
name|unlzw
expr_stmt|;
name|method
operator|=
name|COMPRESSED
expr_stmt|;
name|last_member
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|magic
argument_list|,
name|LZH_MAGIC
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|work
operator|=
name|unlzh
expr_stmt|;
name|method
operator|=
name|LZHED
expr_stmt|;
name|last_member
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|force
operator|&&
name|to_stdout
operator|&&
operator|!
name|list
condition|)
block|{
comment|/* pass input unchanged */
name|method
operator|=
name|STORED
expr_stmt|;
name|work
operator|=
name|copy
expr_stmt|;
name|inptr
operator|=
literal|0
expr_stmt|;
name|last_member
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|method
operator|>=
literal|0
condition|)
return|return
name|method
return|;
if|if
condition|(
name|part_nb
operator|==
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: %s: not in gzip format\n"
argument_list|,
name|progname
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|WARN
argument_list|(
operator|(
name|stderr
operator|,
literal|"\n%s: %s: decompression OK, trailing garbage ignored\n"
operator|,
name|progname
operator|,
name|ifname
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
block|}
comment|/* ========================================================================  * Display the characteristics of the compressed file.  * If the given method is< 0, display the accumulated totals.  * IN assertions: time_stamp, header_bytes and ifile_size are initialized.  */
name|local
name|void
name|do_list
parameter_list|(
name|ifd
parameter_list|,
name|method
parameter_list|)
name|int
name|ifd
decl_stmt|;
comment|/* input file descriptor */
name|int
name|method
decl_stmt|;
comment|/* compression method */
block|{
name|ulg
name|crc
decl_stmt|;
comment|/* original crc */
specifier|static
name|int
name|first_time
init|=
literal|1
decl_stmt|;
specifier|static
name|char
modifier|*
name|methods
index|[
name|MAX_METHODS
index|]
init|=
block|{
literal|"store"
block|,
comment|/* 0 */
literal|"compr"
block|,
comment|/* 1 */
literal|"pack "
block|,
comment|/* 2 */
literal|"lzh  "
block|,
comment|/* 3 */
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 4 to 7 reserved */
literal|"defla"
block|}
decl_stmt|;
comment|/* 8 */
name|char
modifier|*
name|date
decl_stmt|;
if|if
condition|(
name|first_time
operator|&&
name|method
operator|>=
literal|0
condition|)
block|{
name|first_time
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"method  crc     date  time  "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|printf
argument_list|(
literal|"compressed  uncompr. ratio uncompressed_name\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|method
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|total_in
operator|<=
literal|0
operator|||
name|total_out
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"                            %9lu %9lu "
argument_list|,
name|total_in
argument_list|,
name|total_out
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|printf
argument_list|(
literal|"%9ld %9ld "
argument_list|,
name|total_in
argument_list|,
name|total_out
argument_list|)
expr_stmt|;
block|}
name|display_ratio
argument_list|(
name|total_out
operator|-
operator|(
name|total_in
operator|-
name|header_bytes
operator|)
argument_list|,
name|total_out
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* header_bytes is not meaningful but used to ensure the same 	 * ratio if there is a single file. 	 */
name|printf
argument_list|(
literal|" (totals)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|crc
operator|=
operator|(
name|ulg
operator|)
operator|~
literal|0
expr_stmt|;
comment|/* unknown */
name|bytes_out
operator|=
operator|-
literal|1L
expr_stmt|;
name|bytes_in
operator|=
name|ifile_size
expr_stmt|;
if|#
directive|if
name|RECORD_IO
operator|==
literal|0
if|if
condition|(
name|method
operator|==
name|DEFLATED
operator|&&
operator|!
name|last_member
condition|)
block|{
comment|/* Get the crc and uncompressed size for gzip'ed (not zip'ed) files.          * If the lseek fails, we could use read() to get to the end, but          * --list is used to get quick results.          * Use "gunzip< foo.gz | wc -c" to get the uncompressed size if          * you are not concerned about speed.          */
name|bytes_in
operator|=
operator|(
name|long
operator|)
name|lseek
argument_list|(
name|ifd
argument_list|,
call|(
name|off_t
call|)
argument_list|(
operator|-
literal|8
argument_list|)
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_in
operator|!=
operator|-
literal|1L
condition|)
block|{
name|uch
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|bytes_in
operator|+=
literal|8L
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|ifd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|read_error
argument_list|()
expr_stmt|;
block|}
name|crc
operator|=
name|LG
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|bytes_out
operator|=
name|LG
argument_list|(
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* RECORD_IO */
name|date
operator|=
name|ctime
argument_list|(
operator|(
name|time_t
operator|*
operator|)
operator|&
name|time_stamp
argument_list|)
operator|+
literal|4
expr_stmt|;
comment|/* skip the day of the week */
name|date
index|[
literal|12
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* suppress the 1/100sec and the year */
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"%5s %08lx %11s "
argument_list|,
name|methods
index|[
name|method
index|]
argument_list|,
name|crc
argument_list|,
name|date
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%9ld %9ld "
argument_list|,
name|bytes_in
argument_list|,
name|bytes_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_in
operator|==
operator|-
literal|1L
condition|)
block|{
name|total_in
operator|=
operator|-
literal|1L
expr_stmt|;
name|bytes_in
operator|=
name|bytes_out
operator|=
name|header_bytes
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|total_in
operator|>=
literal|0
condition|)
block|{
name|total_in
operator|+=
name|bytes_in
expr_stmt|;
block|}
if|if
condition|(
name|bytes_out
operator|==
operator|-
literal|1L
condition|)
block|{
name|total_out
operator|=
operator|-
literal|1L
expr_stmt|;
name|bytes_in
operator|=
name|bytes_out
operator|=
name|header_bytes
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|total_out
operator|>=
literal|0
condition|)
block|{
name|total_out
operator|+=
name|bytes_out
expr_stmt|;
block|}
name|display_ratio
argument_list|(
name|bytes_out
operator|-
operator|(
name|bytes_in
operator|-
name|header_bytes
operator|)
argument_list|,
name|bytes_out
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s\n"
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
block|}
comment|/* ========================================================================  * Return true if the two stat structures correspond to the same file.  */
name|local
name|int
name|same_file
parameter_list|(
name|stat1
parameter_list|,
name|stat2
parameter_list|)
name|struct
name|stat
modifier|*
name|stat1
decl_stmt|;
name|struct
name|stat
modifier|*
name|stat2
decl_stmt|;
block|{
return|return
name|stat1
operator|->
name|st_ino
operator|==
name|stat2
operator|->
name|st_ino
operator|&&
name|stat1
operator|->
name|st_dev
operator|==
name|stat2
operator|->
name|st_dev
ifdef|#
directive|ifdef
name|NO_ST_INO
comment|/* Can't rely on st_ino and st_dev, use other fields: */
operator|&&
name|stat1
operator|->
name|st_mode
operator|==
name|stat2
operator|->
name|st_mode
operator|&&
name|stat1
operator|->
name|st_uid
operator|==
name|stat2
operator|->
name|st_uid
operator|&&
name|stat1
operator|->
name|st_gid
operator|==
name|stat2
operator|->
name|st_gid
operator|&&
name|stat1
operator|->
name|st_size
operator|==
name|stat2
operator|->
name|st_size
operator|&&
name|stat1
operator|->
name|st_atime
operator|==
name|stat2
operator|->
name|st_atime
operator|&&
name|stat1
operator|->
name|st_mtime
operator|==
name|stat2
operator|->
name|st_mtime
operator|&&
name|stat1
operator|->
name|st_ctime
operator|==
name|stat2
operator|->
name|st_ctime
endif|#
directive|endif
return|;
block|}
comment|/* ========================================================================  * Return true if a file name is ambiguous because the operating system  * truncates file names.  */
name|local
name|int
name|name_too_long
parameter_list|(
name|name
parameter_list|,
name|statb
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* file name to check */
name|struct
name|stat
modifier|*
name|statb
decl_stmt|;
comment|/* stat buf for this file name */
block|{
name|int
name|s
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|char
name|c
init|=
name|name
index|[
name|s
operator|-
literal|1
index|]
decl_stmt|;
name|struct
name|stat
name|tstat
decl_stmt|;
comment|/* stat for truncated name */
name|int
name|res
decl_stmt|;
name|tstat
operator|=
operator|*
name|statb
expr_stmt|;
comment|/* Just in case OS does not fill all fields */
name|name
index|[
name|s
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|res
operator|=
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|tstat
argument_list|)
operator|==
literal|0
operator|&&
name|same_file
argument_list|(
name|statb
argument_list|,
operator|&
name|tstat
argument_list|)
expr_stmt|;
name|name
index|[
name|s
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
name|Trace
argument_list|(
operator|(
name|stderr
operator|,
literal|" too_long(%s) => %d\n"
operator|,
name|name
operator|,
name|res
operator|)
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
comment|/* ========================================================================  * Shorten the given name by one character, or replace a .tar extension  * with .tgz. Truncate the last part of the name which is longer than  * MIN_PART characters: 1234.678.012.gz -> 123.678.012.gz. If the name  * has only parts shorter than MIN_PART truncate the longest part.  * For decompression, just remove the last character of the name.  *  * IN assertion: for compression, the suffix of the given name is z_suffix.  */
name|local
name|void
name|shorten_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
comment|/* length of name without z_suffix */
name|char
modifier|*
name|trunc
init|=
name|NULL
decl_stmt|;
comment|/* character to be truncated */
name|int
name|plen
decl_stmt|;
comment|/* current part length */
name|int
name|min_part
init|=
name|MIN_PART
decl_stmt|;
comment|/* current minimum part length */
name|char
modifier|*
name|p
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|decompress
condition|)
block|{
if|if
condition|(
name|len
operator|<=
literal|1
condition|)
name|error
argument_list|(
literal|"name too short"
argument_list|)
expr_stmt|;
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|get_suffix
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"can't recover suffix\n"
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|save_orig_name
operator|=
literal|1
expr_stmt|;
comment|/* compress 1234567890.tar to 1234567890.tgz */
if|if
condition|(
name|len
operator|>
literal|4
operator|&&
name|strequ
argument_list|(
name|p
operator|-
literal|4
argument_list|,
literal|".tar"
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|p
operator|-
literal|4
argument_list|,
literal|".tgz"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Try keeping short extensions intact:      * 1234.678.012.gz -> 123.678.012.gz      */
do|do
block|{
name|p
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
name|PATH_SEP
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
condition|?
name|p
operator|+
literal|1
else|:
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|plen
operator|=
name|strcspn
argument_list|(
name|p
argument_list|,
name|PART_SEP
argument_list|)
expr_stmt|;
name|p
operator|+=
name|plen
expr_stmt|;
if|if
condition|(
name|plen
operator|>
name|min_part
condition|)
name|trunc
operator|=
name|p
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|trunc
operator|==
name|NULL
operator|&&
operator|--
name|min_part
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|trunc
operator|!=
name|NULL
condition|)
block|{
do|do
block|{
name|trunc
index|[
literal|0
index|]
operator|=
name|trunc
index|[
literal|1
index|]
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|trunc
operator|++
condition|)
do|;
name|trunc
operator|--
expr_stmt|;
block|}
else|else
block|{
name|trunc
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
name|PART_SEP
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|trunc
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"internal error in shorten_name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|trunc
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|trunc
operator|--
expr_stmt|;
comment|/* force truncation */
block|}
name|strcpy
argument_list|(
name|trunc
argument_list|,
name|z_suffix
argument_list|)
expr_stmt|;
block|}
comment|/* ========================================================================  * If compressing to a file, check if ofname is not ambiguous  * because the operating system truncates names. Otherwise, generate  * a new ofname and save the original name in the compressed file.  * If the compressed file already exists, ask for confirmation.  *    The check for name truncation is made dynamically, because different  * file systems on the same OS might use different truncation rules (on SVR4  * s5 truncates to 14 chars and ufs does not truncate).  *    This function returns -1 if the file must be skipped, and  * updates save_orig_name if necessary.  * IN assertions: save_orig_name is already set if ofname has been  * already truncated because of NO_MULTIPLE_DOTS. The input file has  * already been open and istat is set.  */
name|local
name|int
name|check_ofname
parameter_list|()
block|{
name|struct
name|stat
name|ostat
decl_stmt|;
comment|/* stat for ofname */
ifdef|#
directive|ifdef
name|ENAMETOOLONG
comment|/* Check for strictly conforming Posix systems (which return ENAMETOOLONG      * instead of silently truncating filenames).      */
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|stat
argument_list|(
name|ofname
argument_list|,
operator|&
name|ostat
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENAMETOOLONG
condition|)
return|return
literal|0
return|;
comment|/* ofname does not exist */
name|shorten_name
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|stat
argument_list|(
name|ofname
argument_list|,
operator|&
name|ostat
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* Check for name truncation on existing file. Do this even on systems      * defining ENAMETOOLONG, because on most systems the strict Posix      * behavior is disabled by default (silent name truncation allowed).      */
if|if
condition|(
operator|!
name|decompress
operator|&&
name|name_too_long
argument_list|(
name|ofname
argument_list|,
operator|&
name|ostat
argument_list|)
condition|)
block|{
name|shorten_name
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|ofname
argument_list|,
operator|&
name|ostat
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* Check that the input and output files are different (could be      * the same by name truncation or links).      */
if|if
condition|(
name|same_file
argument_list|(
operator|&
name|istat
argument_list|,
operator|&
name|ostat
argument_list|)
condition|)
block|{
if|if
condition|(
name|strequ
argument_list|(
name|ifname
argument_list|,
name|ofname
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: cannot %scompress onto itself\n"
argument_list|,
name|progname
argument_list|,
name|ifname
argument_list|,
name|decompress
condition|?
literal|"de"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s and %s are the same file\n"
argument_list|,
name|progname
argument_list|,
name|ifname
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
block|}
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return
name|ERROR
return|;
block|}
comment|/* Ask permission to overwrite the existing file */
if|if
condition|(
operator|!
name|force
condition|)
block|{
name|char
name|response
index|[
literal|80
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|response
argument_list|,
literal|"n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s already exists;"
argument_list|,
name|progname
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
if|if
condition|(
name|foreground
operator|&&
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" do you wish to overwrite (y or n)? "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|response
argument_list|,
sizeof|sizeof
argument_list|(
name|response
argument_list|)
operator|-
literal|1
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tolow
argument_list|(
operator|*
name|response
argument_list|)
operator|!=
literal|'y'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tnot overwritten\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_code
operator|==
name|OK
condition|)
name|exit_code
operator|=
name|WARNING
expr_stmt|;
return|return
name|ERROR
return|;
block|}
block|}
if|if
condition|(
name|unlink
argument_list|(
name|ofname
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return
name|ERROR
return|;
block|}
return|return
name|OK
return|;
block|}
ifndef|#
directive|ifndef
name|NO_UTIME
comment|/* ========================================================================  * Set the access and modification times from the given stat buffer.  */
name|local
name|void
name|reset_times
parameter_list|(
name|name
parameter_list|,
name|statb
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|stat
modifier|*
name|statb
decl_stmt|;
block|{
name|struct
name|utimbuf
name|timep
decl_stmt|;
comment|/* Copy the time stamp */
name|timep
operator|.
name|actime
operator|=
name|statb
operator|->
name|st_atime
expr_stmt|;
name|timep
operator|.
name|modtime
operator|=
name|statb
operator|->
name|st_mtime
expr_stmt|;
comment|/* Some systems (at least OS/2) do not support utime on directories */
if|if
condition|(
name|utime
argument_list|(
name|name
argument_list|,
operator|&
name|timep
argument_list|)
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|statb
operator|->
name|st_mode
argument_list|)
condition|)
block|{
name|WARN
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: "
operator|,
name|progname
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|perror
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ========================================================================  * Copy modes, times, ownership from input file to output file.  * IN assertion: to_stdout is false.  */
name|local
name|void
name|copy_stat
parameter_list|(
name|ifstat
parameter_list|)
name|struct
name|stat
modifier|*
name|ifstat
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|NO_UTIME
if|if
condition|(
name|decompress
operator|&&
name|time_stamp
operator|!=
literal|0
operator|&&
name|ifstat
operator|->
name|st_mtime
operator|!=
name|time_stamp
condition|)
block|{
name|ifstat
operator|->
name|st_mtime
operator|=
name|time_stamp
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: time stamp restored\n"
argument_list|,
name|ofname
argument_list|)
expr_stmt|;
block|}
block|}
name|reset_times
argument_list|(
name|ofname
argument_list|,
name|ifstat
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Copy the protection modes */
if|if
condition|(
name|chmod
argument_list|(
name|ofname
argument_list|,
name|ifstat
operator|->
name|st_mode
operator|&
literal|07777
argument_list|)
condition|)
block|{
name|WARN
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: "
operator|,
name|progname
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|perror
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_CHOWN
name|chown
argument_list|(
name|ofname
argument_list|,
name|ifstat
operator|->
name|st_uid
argument_list|,
name|ifstat
operator|->
name|st_gid
argument_list|)
expr_stmt|;
comment|/* Copy ownership */
endif|#
directive|endif
name|remove_ofname
operator|=
literal|0
expr_stmt|;
comment|/* It's now safe to remove the input file: */
if|if
condition|(
name|unlink
argument_list|(
name|ifname
argument_list|)
condition|)
block|{
name|WARN
argument_list|(
operator|(
name|stderr
operator|,
literal|"%s: "
operator|,
name|progname
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|perror
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|NO_DIR
comment|/* ========================================================================  * Recurse through the given directory. This code is taken from ncompress.  */
name|local
name|void
name|treat_dir
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|dir_type
modifier|*
name|dp
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|char
name|nbuf
index|[
name|MAX_PATH_LEN
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|dirp
operator|=
name|opendir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s unreadable\n"
argument_list|,
name|progname
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return ;
block|}
comment|/*      ** WARNING: the following algorithm could occasionally cause      ** compress to produce error warnings of the form "<filename>.gz      ** already has .gz suffix - ignored". This occurs when the      ** .gz output file is inserted into the directory below      ** readdir's current pointer.      ** These warnings are harmless but annoying, so they are suppressed      ** with option -r (except when -v is on). An alternative      ** to allowing this would be to store the entire directory      ** list in memory, then compress the entries in the stored      ** list. Given the depth-first recursive algorithm used here,      ** this could use up a tremendous amount of memory. I don't      ** think it's worth it. -- Dave Mack      ** (An other alternative might be two passes to avoid depth-first.)      */
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strequ
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|||
name|strequ
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
name|NLENGTH
argument_list|(
name|dp
argument_list|)
operator|+
literal|1
operator|<
name|MAX_PATH_LEN
operator|-
literal|1
condition|)
block|{
name|strcpy
argument_list|(
name|nbuf
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
comment|/* dir = "" means current dir on Amiga */
ifdef|#
directive|ifdef
name|PATH_SEP2
operator|&&
name|dir
index|[
name|len
operator|-
literal|1
index|]
operator|!=
name|PATH_SEP2
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PATH_SEP3
operator|&&
name|dir
index|[
name|len
operator|-
literal|1
index|]
operator|!=
name|PATH_SEP3
endif|#
directive|endif
condition|)
block|{
name|nbuf
index|[
name|len
operator|++
index|]
operator|=
name|PATH_SEP
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|nbuf
operator|+
name|len
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|treat_file
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s/%s: pathname too long\n"
argument_list|,
name|progname
argument_list|,
name|dir
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
block|}
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ? NO_DIR */
comment|/* ========================================================================  * Free all dynamically allocated variables and exit with the given code.  */
name|local
name|void
name|do_exit
parameter_list|(
name|exitcode
parameter_list|)
name|int
name|exitcode
decl_stmt|;
block|{
specifier|static
name|int
name|in_exit
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|in_exit
condition|)
name|exit
argument_list|(
name|exitcode
argument_list|)
expr_stmt|;
name|in_exit
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|env
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|env
argument_list|)
operator|,
name|env
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|args
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|args
argument_list|)
operator|,
name|args
operator|=
name|NULL
expr_stmt|;
name|FREE
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|d_buf
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|window
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MAXSEG_64K
name|FREE
argument_list|(
name|tab_prefix
argument_list|)
expr_stmt|;
else|#
directive|else
name|FREE
argument_list|(
name|tab_prefix0
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|tab_prefix1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|exitcode
argument_list|)
expr_stmt|;
block|}
comment|/* ========================================================================  * Signal and error handler.  */
name|RETSIGTYPE
name|abort_gzip
parameter_list|()
block|{
if|if
condition|(
name|remove_ofname
condition|)
block|{
name|close
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
block|}
name|do_exit
argument_list|(
name|ERROR
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

