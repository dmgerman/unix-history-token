begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* inflate.c -- Not copyrighted 1992 by Mark Adler    version c10p1, 10 January 1993 */
end_comment

begin_comment
comment|/* You can do whatever you like with this source file, though I would    prefer that if you modify it and redistribute it that you include    comments to that effect with your name and the date.  Thank you.    [The history has been moved to the file ChangeLog.]  */
end_comment

begin_comment
comment|/*    Inflate deflated (PKZIP's method 8 compressed) data.  The compression    method searches for as much of the current string of bytes (up to a    length of 258) in the previous 32K bytes.  If it doesn't find any    matches (of at least length 3), it codes the next byte.  Otherwise, it    codes the length of the matched string and its distance backwards from    the current position.  There is a single Huffman code that codes both    single bytes (called "literals") and match lengths.  A second Huffman    code codes the distance information, which follows a length code.  Each    length or distance code actually represents a base value and a number    of "extra" (sometimes zero) bits to get to add to the base value.  At    the end of each deflated block is a special end-of-block (EOB) literal/    length code.  The decoding process is basically: get a literal/length    code; if EOB then done; if a literal, emit the decoded byte; if a    length then get the distance and emit the referred-to bytes from the    sliding window of previously emitted data.     There are (currently) three kinds of inflate blocks: stored, fixed, and    dynamic.  The compressor deals with some chunk of data at a time, and    decides which method to use on a chunk-by-chunk basis.  A chunk might    typically be 32K or 64K.  If the chunk is uncompressible, then the    "stored" method is used.  In this case, the bytes are simply stored as    is, eight bits per byte, with none of the above coding.  The bytes are    preceded by a count, since there is no longer an EOB code.     If the data is compressible, then either the fixed or dynamic methods    are used.  In the dynamic method, the compressed data is preceded by    an encoding of the literal/length and distance Huffman codes that are    to be used to decode this block.  The representation is itself Huffman    coded, and so is preceded by a description of that code.  These code    descriptions take up a little space, and so for small blocks, there is    a predefined set of codes, called the fixed codes.  The fixed method is    used if the block codes up smaller that way (usually for quite small    chunks), otherwise the dynamic method is used.  In the latter case, the    codes are customized to the probabilities in the current block, and so    can code it much better than the pre-determined fixed codes.     The Huffman codes themselves are decoded using a mutli-level table    lookup, in order to maximize the speed of decoding plus the speed of    building the decoding tables.  See the comments below that precede the    lbits and dbits tuning parameters.  */
end_comment

begin_comment
comment|/*    Notes beyond the 1.93a appnote.txt:     1. Distance pointers never point before the beginning of the output       stream.    2. Distance pointers can point back across blocks, up to 32k away.    3. There is an implied maximum of 7 bits for the bit length table and       15 bits for the actual data.    4. If only one code exists, then it is encoded using one bit.  (Zero       would be more efficient, but perhaps a little confusing.)  If two       codes exist, they are coded using one bit each (0 and 1).    5. There is no way of sending zero distance codes--a dummy must be       sent if there are none.  (History: a pre 2.0 version of PKZIP would       store blocks with no distance codes, but this was discovered to be       too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow       zero distance codes, which is sent as one code of zero bits in       length.    6. There are up to 286 literal/length codes.  Code 256 represents the       end-of-block.  Note however that the static length tree defines       288 codes just to fill out the Huffman codes.  Codes 286 and 287       cannot be used though, since there is no length base or extra bits       defined for them.  Similarly, there are up to 30 distance codes.       However, static trees define 32 codes (all 5 bits) to fill out the       Huffman codes, but the last two had better not show up in the data.    7. Unzip can check dynamic Huffman blocks for complete code sets.       The exception is that a single code would not be complete (see #4).    8. The five bits following the block type is really the number of       literal codes sent minus 257.    9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits       (1+6+6).  Therefore, to output three times the length, you output       three codes (1+1+1), whereas to output four times the same length,       you only need two codes (1+3).  Hmm.   10. In the tree reconstruction algorithm, Code = Code + Increment       only if BitLength(i) is not zero.  (Pretty obvious.)   11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)   12. Note: length code 284 can represent 227-258, but length code 285       really is 258.  The last length deserves its own, short code       since it gets used a lot in very redundant files.  The length       258 is special since 258 - 3 (the min match length) is 255.   13. The literal/length and distance code bit lengths are read as a       single stream of lengths.  It is possible (and advantageous) for       a repeat code (16, 17, or 18) to go across the boundary between       the two sets of lengths.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: inflate.c,v 1.4 1995/05/30 05:00:37 rgrimes Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|NO_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gzip.h"
end_include

begin_define
define|#
directive|define
name|slide
value|window
end_define

begin_comment
comment|/* Huffman code lookup table entry--this entry is four bytes for machines    that have 16-bit pointers (e.g. PC's in the small or medium model).    Valid extra bits are 0..13.  e == 15 is EOB (end of block), e == 16    means that v is a literal, 16< e< 32 means that v is a pointer to    the next table, which codes e - 16 bits, and lastly e == 99 indicates    an unused code.  If a code with e == 99 is looked up, this implies an    error in the data. */
end_comment

begin_struct
struct|struct
name|huft
block|{
name|uch
name|e
decl_stmt|;
comment|/* number of extra bits or operation */
name|uch
name|b
decl_stmt|;
comment|/* number of bits in this code or subcode */
union|union
block|{
name|ush
name|n
decl_stmt|;
comment|/* literal, length base, or distance base */
name|struct
name|huft
modifier|*
name|t
decl_stmt|;
comment|/* pointer to next level of table */
block|}
name|v
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Function prototypes */
end_comment

begin_decl_stmt
name|int
name|huft_build
name|OF
argument_list|(
operator|(
name|unsigned
operator|*
operator|,
name|unsigned
operator|,
name|unsigned
operator|,
name|ush
operator|*
operator|,
name|ush
operator|*
operator|,
expr|struct
name|huft
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|huft_free
name|OF
argument_list|(
operator|(
expr|struct
name|huft
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inflate_codes
name|OF
argument_list|(
operator|(
expr|struct
name|huft
operator|*
operator|,
expr|struct
name|huft
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inflate_stored
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inflate_fixed
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inflate_dynamic
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inflate_block
name|OF
argument_list|(
operator|(
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inflate
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The inflate algorithm uses a sliding 32K byte window on the uncompressed    stream to find repeated byte strings.  This is implemented here as a    circular buffer.  The index is updated simply by incrementing and then    and'ing with 0x7fff (32K-1). */
end_comment

begin_comment
comment|/* It is left to other modules to supply the 32K area.  It is assumed    to be usable as if it were declared "uch slide[32768];" or as just    "uch *slide;" and then malloc'ed in the latter case.  The definition    must be in unzip.h, included above. */
end_comment

begin_comment
comment|/* unsigned wp;             current position in slide */
end_comment

begin_define
define|#
directive|define
name|wp
value|outcnt
end_define

begin_define
define|#
directive|define
name|flush_output
parameter_list|(
name|w
parameter_list|)
value|(wp=(w),flush_window())
end_define

begin_comment
comment|/* Tables for deflate from PKZIP's appnote.txt. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|border
index|[]
init|=
block|{
comment|/* Order of the bit length code lengths */
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|0
block|,
literal|8
block|,
literal|7
block|,
literal|9
block|,
literal|6
block|,
literal|10
block|,
literal|5
block|,
literal|11
block|,
literal|4
block|,
literal|12
block|,
literal|3
block|,
literal|13
block|,
literal|2
block|,
literal|14
block|,
literal|1
block|,
literal|15
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ush
name|cplens
index|[]
init|=
block|{
comment|/* Copy lengths for literal codes 257..285 */
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|13
block|,
literal|15
block|,
literal|17
block|,
literal|19
block|,
literal|23
block|,
literal|27
block|,
literal|31
block|,
literal|35
block|,
literal|43
block|,
literal|51
block|,
literal|59
block|,
literal|67
block|,
literal|83
block|,
literal|99
block|,
literal|115
block|,
literal|131
block|,
literal|163
block|,
literal|195
block|,
literal|227
block|,
literal|258
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* note: see note #13 above about the 258 in this list. */
end_comment

begin_decl_stmt
specifier|static
name|ush
name|cplext
index|[]
init|=
block|{
comment|/* Extra bits for literal codes 257..285 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|0
block|,
literal|99
block|,
literal|99
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 99==invalid */
end_comment

begin_decl_stmt
specifier|static
name|ush
name|cpdist
index|[]
init|=
block|{
comment|/* Copy offsets for distance codes 0..29 */
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|7
block|,
literal|9
block|,
literal|13
block|,
literal|17
block|,
literal|25
block|,
literal|33
block|,
literal|49
block|,
literal|65
block|,
literal|97
block|,
literal|129
block|,
literal|193
block|,
literal|257
block|,
literal|385
block|,
literal|513
block|,
literal|769
block|,
literal|1025
block|,
literal|1537
block|,
literal|2049
block|,
literal|3073
block|,
literal|4097
block|,
literal|6145
block|,
literal|8193
block|,
literal|12289
block|,
literal|16385
block|,
literal|24577
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ush
name|cpdext
index|[]
init|=
block|{
comment|/* Extra bits for distance codes */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|8
block|,
literal|8
block|,
literal|9
block|,
literal|9
block|,
literal|10
block|,
literal|10
block|,
literal|11
block|,
literal|11
block|,
literal|12
block|,
literal|12
block|,
literal|13
block|,
literal|13
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macros for inflate() bit peeking and grabbing.    The usage is:          NEEDBITS(j)         x = b& mask_bits[j];         DUMPBITS(j)     where NEEDBITS makes sure that b has at least j bits in it, and    DUMPBITS removes the bits from b.  The macros use the variable k    for the number of bits in b.  Normally, b and k are register    variables for speed, and are initialized at the beginning of a    routine that uses these macros from a global bit buffer and count.     If we assume that EOB will be the longest code, then we will never    ask for bits with NEEDBITS that are beyond the end of the stream.    So, NEEDBITS should not read any more bytes than are needed to    meet the request.  Then no bytes need to be "returned" to the buffer    at the end of the last block.     However, this assumption is not true for fixed blocks--the EOB code    is 7 bits, but the other literal/length codes can be 8 or 9 bits.    (The EOB code is shorter than other codes because fixed blocks are    generally short.  So, while a block always has an EOB, many other    literal/length codes have a significantly lower probability of    showing up at all.)  However, by making the first table have a    lookup of seven bits, the EOB code will be found in that first    lookup, and so will not require that too many bits be pulled from    the stream.  */
end_comment

begin_decl_stmt
name|ulg
name|bb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bit buffer */
end_comment

begin_decl_stmt
name|unsigned
name|bk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bits in bit buffer */
end_comment

begin_decl_stmt
name|ush
name|mask_bits
index|[]
init|=
block|{
literal|0x0000
block|,
literal|0x0001
block|,
literal|0x0003
block|,
literal|0x0007
block|,
literal|0x000f
block|,
literal|0x001f
block|,
literal|0x003f
block|,
literal|0x007f
block|,
literal|0x00ff
block|,
literal|0x01ff
block|,
literal|0x03ff
block|,
literal|0x07ff
block|,
literal|0x0fff
block|,
literal|0x1fff
block|,
literal|0x3fff
block|,
literal|0x7fff
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CRYPT
end_ifdef

begin_decl_stmt
name|uch
name|cc
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NEXTBYTE
parameter_list|()
define|\
value|(decrypt ? (cc = get_byte(), zdecode(cc), cc) : get_byte())
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NEXTBYTE
parameter_list|()
value|(uch)get_byte()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NEEDBITS
parameter_list|(
name|n
parameter_list|)
value|{while(k<(n)){b|=((ulg)NEXTBYTE())<<k;k+=8;}}
end_define

begin_define
define|#
directive|define
name|DUMPBITS
parameter_list|(
name|n
parameter_list|)
value|{b>>=(n);k-=(n);}
end_define

begin_comment
comment|/*    Huffman code decoding is performed using a multi-level table lookup.    The fastest way to decode is to simply build a lookup table whose    size is determined by the longest code.  However, the time it takes    to build this table can also be a factor if the data being decoded    is not very long.  The most common codes are necessarily the    shortest codes, so those codes dominate the decoding time, and hence    the speed.  The idea is you can have a shorter table that decodes the    shorter, more probable codes, and then point to subsidiary tables for    the longer codes.  The time it costs to decode the longer codes is    then traded against the time it takes to make longer tables.     This results of this trade are in the variables lbits and dbits    below.  lbits is the number of bits the first level table for literal/    length codes can decode in one step, and dbits is the same thing for    the distance codes.  Subsequent tables are also less than or equal to    those sizes.  These values may be adjusted either when all of the    codes are shorter than that, in which case the longest code length in    bits is used, or when the shortest code is *longer* than the requested    table size, in which case the length of the shortest code in bits is    used.     There are two different values for the two tables, since they code a    different number of possibilities each.  The literal/length table    codes 286 possible values, or in a flat code, a little over eight    bits.  The distance table codes 30 possible values, or a little less    than five bits, flat.  The optimum values for speed end up being    about one bit more than those, so lbits is 8+1 and dbits is 5+1.    The optimum values may differ though from machine to machine, and    possibly even between compilers.  Your mileage may vary.  */
end_comment

begin_decl_stmt
name|int
name|lbits
init|=
literal|9
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bits in base literal/length lookup table */
end_comment

begin_decl_stmt
name|int
name|dbits
init|=
literal|6
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bits in base distance lookup table */
end_comment

begin_comment
comment|/* If BMAX needs to be larger than 16, then h and x[] should be ulg. */
end_comment

begin_define
define|#
directive|define
name|BMAX
value|16
end_define

begin_comment
comment|/* maximum bit length of any code (16 for explode) */
end_comment

begin_define
define|#
directive|define
name|N_MAX
value|288
end_define

begin_comment
comment|/* maximum number of codes in any set */
end_comment

begin_decl_stmt
name|unsigned
name|hufts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* track memory usage */
end_comment

begin_function
name|int
name|huft_build
parameter_list|(
name|b
parameter_list|,
name|n
parameter_list|,
name|s
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|t
parameter_list|,
name|m
parameter_list|)
name|unsigned
modifier|*
name|b
decl_stmt|;
comment|/* code lengths in bits (all assumed<= BMAX) */
name|unsigned
name|n
decl_stmt|;
comment|/* number of codes (assumed<= N_MAX) */
name|unsigned
name|s
decl_stmt|;
comment|/* number of simple-valued codes (0..s-1) */
name|ush
modifier|*
name|d
decl_stmt|;
comment|/* list of base values for non-simple codes */
name|ush
modifier|*
name|e
decl_stmt|;
comment|/* list of extra bits for non-simple codes */
name|struct
name|huft
modifier|*
modifier|*
name|t
decl_stmt|;
comment|/* result: starting table */
name|int
modifier|*
name|m
decl_stmt|;
comment|/* maximum lookup bits, returns actual */
comment|/* Given a list of code lengths and a maximum table size, make a set of    tables to decode that set of codes.  Return zero on success, one if    the given code set is incomplete (the tables are still built in this    case), two if the input is invalid (all zero length codes or an    oversubscribed set of lengths), and three if not enough memory. */
block|{
name|unsigned
name|a
decl_stmt|;
comment|/* counter for codes of length k */
name|unsigned
name|c
index|[
name|BMAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* bit length count table */
name|unsigned
name|f
decl_stmt|;
comment|/* i repeats in table every f entries */
name|int
name|g
decl_stmt|;
comment|/* maximum code length */
name|int
name|h
decl_stmt|;
comment|/* table level */
specifier|register
name|unsigned
name|i
decl_stmt|;
comment|/* counter, current code */
specifier|register
name|unsigned
name|j
decl_stmt|;
comment|/* counter */
specifier|register
name|int
name|k
decl_stmt|;
comment|/* number of bits in current code */
name|int
name|l
decl_stmt|;
comment|/* bits per table (returned in m) */
specifier|register
name|unsigned
modifier|*
name|p
decl_stmt|;
comment|/* pointer into c[], b[], or v[] */
specifier|register
name|struct
name|huft
modifier|*
name|q
decl_stmt|;
comment|/* points to current table */
name|struct
name|huft
name|r
decl_stmt|;
comment|/* table entry for structure assignment */
name|struct
name|huft
modifier|*
name|u
index|[
name|BMAX
index|]
decl_stmt|;
comment|/* table stack */
name|unsigned
name|v
index|[
name|N_MAX
index|]
decl_stmt|;
comment|/* values in order of bit length */
specifier|register
name|int
name|w
decl_stmt|;
comment|/* bits before this table == (l * h) */
name|unsigned
name|x
index|[
name|BMAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* bit offsets, then code stack */
name|unsigned
modifier|*
name|xp
decl_stmt|;
comment|/* pointer into x */
name|int
name|y
decl_stmt|;
comment|/* number of dummy codes added */
name|unsigned
name|z
decl_stmt|;
comment|/* number of entries in current table */
comment|/* Generate counts for each bit length */
name|memzero
argument_list|(
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|b
expr_stmt|;
name|i
operator|=
name|n
expr_stmt|;
do|do
block|{
name|Tracecv
argument_list|(
operator|*
name|p
argument_list|,
operator|(
name|stderr
operator|,
operator|(
name|n
operator|-
name|i
operator|>=
literal|' '
operator|&&
name|n
operator|-
name|i
operator|<=
literal|'~'
condition|?
literal|"%c %d\n"
else|:
literal|"0x%x %d\n"
operator|)
operator|,
name|n
operator|-
name|i
operator|,
operator|*
name|p
operator|)
argument_list|)
expr_stmt|;
name|c
index|[
operator|*
name|p
index|]
operator|++
expr_stmt|;
comment|/* assume all entries<= BMAX */
name|p
operator|++
expr_stmt|;
comment|/* Can't combine with above line (Solaris bug) */
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
if|if
condition|(
name|c
index|[
literal|0
index|]
operator|==
name|n
condition|)
comment|/* null input--all zero length codes */
block|{
operator|*
name|t
operator|=
operator|(
expr|struct
name|huft
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|m
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Find minimum and maximum length, bound *m by those */
name|l
operator|=
operator|*
name|m
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|BMAX
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|c
index|[
name|j
index|]
condition|)
break|break;
name|k
operator|=
name|j
expr_stmt|;
comment|/* minimum code length */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|l
operator|<
name|j
condition|)
name|l
operator|=
name|j
expr_stmt|;
for|for
control|(
name|i
operator|=
name|BMAX
init|;
name|i
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|c
index|[
name|i
index|]
condition|)
break|break;
name|g
operator|=
name|i
expr_stmt|;
comment|/* maximum code length */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|l
operator|>
name|i
condition|)
name|l
operator|=
name|i
expr_stmt|;
operator|*
name|m
operator|=
name|l
expr_stmt|;
comment|/* Adjust last length count to fill out codes, if needed */
for|for
control|(
name|y
operator|=
literal|1
operator|<<
name|j
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
operator|,
name|y
operator|<<=
literal|1
control|)
if|if
condition|(
operator|(
name|y
operator|-=
name|c
index|[
name|j
index|]
operator|)
operator|<
literal|0
condition|)
return|return
literal|2
return|;
comment|/* bad input: more codes than bits */
if|if
condition|(
operator|(
name|y
operator|-=
name|c
index|[
name|i
index|]
operator|)
operator|<
literal|0
condition|)
return|return
literal|2
return|;
name|c
index|[
name|i
index|]
operator|+=
name|y
expr_stmt|;
comment|/* Generate starting offsets into the value table for each length */
name|x
index|[
literal|1
index|]
operator|=
name|j
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|c
operator|+
literal|1
expr_stmt|;
name|xp
operator|=
name|x
operator|+
literal|2
expr_stmt|;
while|while
condition|(
operator|--
name|i
condition|)
block|{
comment|/* note that i == g from above */
operator|*
name|xp
operator|++
operator|=
operator|(
name|j
operator|+=
operator|*
name|p
operator|++
operator|)
expr_stmt|;
block|}
comment|/* Make a table of values in order of bit lengths */
name|p
operator|=
name|b
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|j
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|0
condition|)
name|v
index|[
name|x
index|[
name|j
index|]
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|n
condition|)
do|;
comment|/* Generate the Huffman codes and for each, make the table entries */
name|x
index|[
literal|0
index|]
operator|=
name|i
operator|=
literal|0
expr_stmt|;
comment|/* first Huffman code is zero */
name|p
operator|=
name|v
expr_stmt|;
comment|/* grab values in bit order */
name|h
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no tables yet--level -1 */
name|w
operator|=
operator|-
name|l
expr_stmt|;
comment|/* bits decoded == (l * h) */
name|u
index|[
literal|0
index|]
operator|=
operator|(
expr|struct
name|huft
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* just to keep compilers happy */
name|q
operator|=
operator|(
expr|struct
name|huft
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* ditto */
name|z
operator|=
literal|0
expr_stmt|;
comment|/* ditto */
comment|/* go through the bit lengths (k already is bits in shortest code) */
for|for
control|(
init|;
name|k
operator|<=
name|g
condition|;
name|k
operator|++
control|)
block|{
name|a
operator|=
name|c
index|[
name|k
index|]
expr_stmt|;
while|while
condition|(
name|a
operator|--
condition|)
block|{
comment|/* here i is the Huffman code of length k bits for value *p */
comment|/* make tables up to required level */
while|while
condition|(
name|k
operator|>
name|w
operator|+
name|l
condition|)
block|{
name|h
operator|++
expr_stmt|;
name|w
operator|+=
name|l
expr_stmt|;
comment|/* previous table always l bits */
comment|/* compute minimum size table less than or equal to l bits */
name|z
operator|=
operator|(
name|z
operator|=
name|g
operator|-
name|w
operator|)
operator|>
operator|(
name|unsigned
operator|)
name|l
condition|?
name|l
else|:
name|z
expr_stmt|;
comment|/* upper limit on table size */
if|if
condition|(
operator|(
name|f
operator|=
literal|1
operator|<<
operator|(
name|j
operator|=
name|k
operator|-
name|w
operator|)
operator|)
operator|>
name|a
operator|+
literal|1
condition|)
comment|/* try a k-w bit table */
block|{
comment|/* too few codes for k-w bit table */
name|f
operator|-=
name|a
operator|+
literal|1
expr_stmt|;
comment|/* deduct codes from patterns left */
name|xp
operator|=
name|c
operator|+
name|k
expr_stmt|;
while|while
condition|(
operator|++
name|j
operator|<
name|z
condition|)
comment|/* try smaller tables up to z bits */
block|{
if|if
condition|(
operator|(
name|f
operator|<<=
literal|1
operator|)
operator|<=
operator|*
operator|++
name|xp
condition|)
break|break;
comment|/* enough codes to use up j bits */
name|f
operator|-=
operator|*
name|xp
expr_stmt|;
comment|/* else deduct codes from patterns */
block|}
block|}
name|z
operator|=
literal|1
operator|<<
name|j
expr_stmt|;
comment|/* table entries for j-bit table */
comment|/* allocate and link in new table */
if|if
condition|(
operator|(
name|q
operator|=
operator|(
expr|struct
name|huft
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|z
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|huft
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|huft
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|h
condition|)
name|huft_free
argument_list|(
name|u
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
literal|3
return|;
comment|/* not enough memory */
block|}
name|hufts
operator|+=
name|z
operator|+
literal|1
expr_stmt|;
comment|/* track memory usage */
operator|*
name|t
operator|=
name|q
operator|+
literal|1
expr_stmt|;
comment|/* link to list for huft_free() */
operator|*
operator|(
name|t
operator|=
operator|&
operator|(
name|q
operator|->
name|v
operator|.
name|t
operator|)
operator|)
operator|=
operator|(
expr|struct
name|huft
operator|*
operator|)
name|NULL
expr_stmt|;
name|u
index|[
name|h
index|]
operator|=
operator|++
name|q
expr_stmt|;
comment|/* table starts after link */
comment|/* connect to last table, if there is one */
if|if
condition|(
name|h
condition|)
block|{
name|x
index|[
name|h
index|]
operator|=
name|i
expr_stmt|;
comment|/* save pattern for backing up */
name|r
operator|.
name|b
operator|=
operator|(
name|uch
operator|)
name|l
expr_stmt|;
comment|/* bits to dump before this table */
name|r
operator|.
name|e
operator|=
call|(
name|uch
call|)
argument_list|(
literal|16
operator|+
name|j
argument_list|)
expr_stmt|;
comment|/* bits in this table */
name|r
operator|.
name|v
operator|.
name|t
operator|=
name|q
expr_stmt|;
comment|/* pointer to this table */
name|j
operator|=
name|i
operator|>>
operator|(
name|w
operator|-
name|l
operator|)
expr_stmt|;
comment|/* (get around Turbo C bug) */
name|u
index|[
name|h
operator|-
literal|1
index|]
index|[
name|j
index|]
operator|=
name|r
expr_stmt|;
comment|/* connect to last table */
block|}
block|}
comment|/* set up table entry in r */
name|r
operator|.
name|b
operator|=
call|(
name|uch
call|)
argument_list|(
name|k
operator|-
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|v
operator|+
name|n
condition|)
name|r
operator|.
name|e
operator|=
literal|99
expr_stmt|;
comment|/* out of values--invalid code */
elseif|else
if|if
condition|(
operator|*
name|p
operator|<
name|s
condition|)
block|{
name|r
operator|.
name|e
operator|=
call|(
name|uch
call|)
argument_list|(
operator|*
name|p
operator|<
literal|256
condition|?
literal|16
else|:
literal|15
argument_list|)
expr_stmt|;
comment|/* 256 is end-of-block code */
name|r
operator|.
name|v
operator|.
name|n
operator|=
call|(
name|ush
call|)
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
comment|/* simple code is just the value */
name|p
operator|++
expr_stmt|;
comment|/* one compiler does not like *p++ */
block|}
else|else
block|{
name|r
operator|.
name|e
operator|=
operator|(
name|uch
operator|)
name|e
index|[
operator|*
name|p
operator|-
name|s
index|]
expr_stmt|;
comment|/* non-simple--look up in lists */
name|r
operator|.
name|v
operator|.
name|n
operator|=
name|d
index|[
operator|*
name|p
operator|++
operator|-
name|s
index|]
expr_stmt|;
block|}
comment|/* fill code-like entries with r */
name|f
operator|=
literal|1
operator|<<
operator|(
name|k
operator|-
name|w
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|>>
name|w
init|;
name|j
operator|<
name|z
condition|;
name|j
operator|+=
name|f
control|)
name|q
index|[
name|j
index|]
operator|=
name|r
expr_stmt|;
comment|/* backwards increment the k-bit code i */
for|for
control|(
name|j
operator|=
literal|1
operator|<<
operator|(
name|k
operator|-
literal|1
operator|)
init|;
name|i
operator|&
name|j
condition|;
name|j
operator|>>=
literal|1
control|)
name|i
operator|^=
name|j
expr_stmt|;
name|i
operator|^=
name|j
expr_stmt|;
comment|/* backup over finished tables */
while|while
condition|(
operator|(
name|i
operator|&
operator|(
operator|(
literal|1
operator|<<
name|w
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
name|x
index|[
name|h
index|]
condition|)
block|{
name|h
operator|--
expr_stmt|;
comment|/* don't need to update q */
name|w
operator|-=
name|l
expr_stmt|;
block|}
block|}
block|}
comment|/* Return true (1) if we were given an incomplete table */
return|return
name|y
operator|!=
literal|0
operator|&&
name|g
operator|!=
literal|1
return|;
block|}
end_function

begin_function
name|int
name|huft_free
parameter_list|(
name|t
parameter_list|)
name|struct
name|huft
modifier|*
name|t
decl_stmt|;
comment|/* table to free */
comment|/* Free the malloc'ed tables built by huft_build(), which makes a linked    list of the tables it made, with the links in a dummy first entry of    each table. */
block|{
specifier|register
name|struct
name|huft
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* Go through linked list, freeing from the malloced (t[-1]) address. */
name|p
operator|=
name|t
expr_stmt|;
while|while
condition|(
name|p
operator|!=
operator|(
expr|struct
name|huft
operator|*
operator|)
name|NULL
condition|)
block|{
name|q
operator|=
operator|(
operator|--
name|p
operator|)
operator|->
name|v
operator|.
name|t
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|inflate_codes
parameter_list|(
name|tl
parameter_list|,
name|td
parameter_list|,
name|bl
parameter_list|,
name|bd
parameter_list|)
name|struct
name|huft
modifier|*
name|tl
decl_stmt|,
decl|*
name|td
decl_stmt|;
end_function

begin_comment
comment|/* literal/length and distance decoder tables */
end_comment

begin_decl_stmt
name|int
name|bl
decl_stmt|,
name|bd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of bits decoded by tl[] and td[] */
end_comment

begin_comment
comment|/* inflate (decompress) the codes in a deflated (compressed) block.    Return an error code or zero if it all goes ok. */
end_comment

begin_block
block|{
specifier|register
name|unsigned
name|e
decl_stmt|;
comment|/* table entry flag/number of extra bits */
name|unsigned
name|n
decl_stmt|,
name|d
decl_stmt|;
comment|/* length and index for copy */
name|unsigned
name|w
decl_stmt|;
comment|/* current window position */
name|struct
name|huft
modifier|*
name|t
decl_stmt|;
comment|/* pointer to table entry */
name|unsigned
name|ml
decl_stmt|,
name|md
decl_stmt|;
comment|/* masks for bl and bd bits */
specifier|register
name|ulg
name|b
decl_stmt|;
comment|/* bit buffer */
specifier|register
name|unsigned
name|k
decl_stmt|;
comment|/* number of bits in bit buffer */
comment|/* make local copies of globals */
name|b
operator|=
name|bb
expr_stmt|;
comment|/* initialize bit buffer */
name|k
operator|=
name|bk
expr_stmt|;
name|w
operator|=
name|wp
expr_stmt|;
comment|/* initialize window position */
comment|/* inflate the coded data */
name|ml
operator|=
name|mask_bits
index|[
name|bl
index|]
expr_stmt|;
comment|/* precompute masks for speed */
name|md
operator|=
name|mask_bits
index|[
name|bd
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
comment|/* do until end of block */
block|{
name|NEEDBITS
argument_list|(
argument|(unsigned)bl
argument_list|)
if|if
condition|(
operator|(
name|e
operator|=
operator|(
name|t
operator|=
name|tl
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
name|ml
operator|)
operator|)
operator|->
name|e
operator|)
operator|>
literal|16
condition|)
do|do
block|{
if|if
condition|(
name|e
operator|==
literal|99
condition|)
return|return
literal|1
return|;
name|DUMPBITS
argument_list|(
argument|t->b
argument_list|)
name|e
operator|-=
literal|16
expr_stmt|;
name|NEEDBITS
argument_list|(
argument|e
argument_list|)
block|}
do|while
condition|(
operator|(
name|e
operator|=
operator|(
name|t
operator|=
name|t
operator|->
name|v
operator|.
name|t
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
name|mask_bits
index|[
name|e
index|]
operator|)
operator|)
operator|->
name|e
operator|)
operator|>
literal|16
condition|)
do|;
name|DUMPBITS
argument_list|(
argument|t->b
argument_list|)
if|if
condition|(
name|e
operator|==
literal|16
condition|)
comment|/* then it's a literal */
block|{
name|slide
index|[
name|w
operator|++
index|]
operator|=
operator|(
name|uch
operator|)
name|t
operator|->
name|v
operator|.
name|n
expr_stmt|;
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"%c"
operator|,
name|slide
index|[
name|w
operator|-
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|WSIZE
condition|)
block|{
name|flush_output
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|w
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
comment|/* it's an EOB or a length */
block|{
comment|/* exit if end of block */
if|if
condition|(
name|e
operator|==
literal|15
condition|)
break|break;
comment|/* get length of block to copy */
name|NEEDBITS
argument_list|(
argument|e
argument_list|)
name|n
operator|=
name|t
operator|->
name|v
operator|.
name|n
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
name|mask_bits
index|[
name|e
index|]
operator|)
expr_stmt|;
name|DUMPBITS
argument_list|(
name|e
argument_list|)
expr_stmt|;
comment|/* decode distance of block to copy */
name|NEEDBITS
argument_list|(
argument|(unsigned)bd
argument_list|)
if|if
condition|(
operator|(
name|e
operator|=
operator|(
name|t
operator|=
name|td
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
name|md
operator|)
operator|)
operator|->
name|e
operator|)
operator|>
literal|16
condition|)
do|do
block|{
if|if
condition|(
name|e
operator|==
literal|99
condition|)
return|return
literal|1
return|;
name|DUMPBITS
argument_list|(
argument|t->b
argument_list|)
name|e
operator|-=
literal|16
expr_stmt|;
name|NEEDBITS
argument_list|(
argument|e
argument_list|)
block|}
do|while
condition|(
operator|(
name|e
operator|=
operator|(
name|t
operator|=
name|t
operator|->
name|v
operator|.
name|t
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
name|mask_bits
index|[
name|e
index|]
operator|)
operator|)
operator|->
name|e
operator|)
operator|>
literal|16
condition|)
do|;
name|DUMPBITS
argument_list|(
argument|t->b
argument_list|)
name|NEEDBITS
argument_list|(
argument|e
argument_list|)
name|d
operator|=
name|w
operator|-
name|t
operator|->
name|v
operator|.
name|n
operator|-
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
name|mask_bits
index|[
name|e
index|]
operator|)
expr_stmt|;
name|DUMPBITS
argument_list|(
argument|e
argument_list|)
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"\\[%d,%d]"
operator|,
name|w
operator|-
name|d
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
comment|/* do the copy */
do|do
block|{
name|n
operator|-=
operator|(
name|e
operator|=
operator|(
name|e
operator|=
name|WSIZE
operator|-
operator|(
operator|(
name|d
operator|&=
name|WSIZE
operator|-
literal|1
operator|)
operator|>
name|w
condition|?
name|d
else|:
name|w
operator|)
operator|)
operator|>
name|n
condition|?
name|n
else|:
name|e
operator|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NOMEMCPY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DEBUG
argument_list|)
if|if
condition|(
name|w
operator|-
name|d
operator|>=
name|e
condition|)
comment|/* (this test assumes unsigned comparison) */
block|{
name|memcpy
argument_list|(
name|slide
operator|+
name|w
argument_list|,
name|slide
operator|+
name|d
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|w
operator|+=
name|e
expr_stmt|;
name|d
operator|+=
name|e
expr_stmt|;
block|}
else|else
comment|/* do it slow to avoid memcpy() overlap */
endif|#
directive|endif
comment|/* !NOMEMCPY */
do|do
block|{
name|slide
index|[
name|w
operator|++
index|]
operator|=
name|slide
index|[
name|d
operator|++
index|]
expr_stmt|;
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"%c"
operator|,
name|slide
index|[
name|w
operator|-
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|e
condition|)
do|;
if|if
condition|(
name|w
operator|==
name|WSIZE
condition|)
block|{
name|flush_output
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|w
operator|=
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
name|n
condition|)
do|;
block|}
block|}
comment|/* restore the globals from the locals */
name|wp
operator|=
name|w
expr_stmt|;
comment|/* restore global window pointer */
name|bb
operator|=
name|b
expr_stmt|;
comment|/* restore global bit buffer */
name|bk
operator|=
name|k
expr_stmt|;
comment|/* done */
return|return
literal|0
return|;
block|}
end_block

begin_function
name|int
name|inflate_stored
parameter_list|()
comment|/* "decompress" an inflated type 0 (stored) block. */
block|{
name|unsigned
name|n
decl_stmt|;
comment|/* number of bytes in block */
name|unsigned
name|w
decl_stmt|;
comment|/* current window position */
specifier|register
name|ulg
name|b
decl_stmt|;
comment|/* bit buffer */
specifier|register
name|unsigned
name|k
decl_stmt|;
comment|/* number of bits in bit buffer */
comment|/* make local copies of globals */
name|b
operator|=
name|bb
expr_stmt|;
comment|/* initialize bit buffer */
name|k
operator|=
name|bk
expr_stmt|;
name|w
operator|=
name|wp
expr_stmt|;
comment|/* initialize window position */
comment|/* go to byte boundary */
name|n
operator|=
name|k
operator|&
literal|7
expr_stmt|;
name|DUMPBITS
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* get the length and its complement */
name|NEEDBITS
argument_list|(
literal|16
argument_list|)
name|n
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|DUMPBITS
argument_list|(
literal|16
argument_list|)
name|NEEDBITS
argument_list|(
literal|16
argument_list|)
if|if
condition|(
name|n
operator|!=
call|(
name|unsigned
call|)
argument_list|(
operator|(
operator|~
name|b
operator|)
operator|&
literal|0xffff
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* error in compressed data */
name|DUMPBITS
argument_list|(
literal|16
argument_list|)
comment|/* read and output the compressed data */
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|NEEDBITS
argument_list|(
literal|8
argument_list|)
name|slide
index|[
name|w
operator|++
index|]
operator|=
operator|(
name|uch
operator|)
name|b
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|WSIZE
condition|)
block|{
name|flush_output
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|w
operator|=
literal|0
expr_stmt|;
block|}
name|DUMPBITS
argument_list|(
literal|8
argument_list|)
block|}
comment|/* restore the globals from the locals */
name|wp
operator|=
name|w
expr_stmt|;
comment|/* restore global window pointer */
name|bb
operator|=
name|b
expr_stmt|;
comment|/* restore global bit buffer */
name|bk
operator|=
name|k
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|inflate_fixed
parameter_list|()
comment|/* decompress an inflated type 1 (fixed Huffman codes) block.  We should    either replace this with a custom decoder, or at least precompute the    Huffman tables. */
block|{
name|int
name|i
decl_stmt|;
comment|/* temporary variable */
name|struct
name|huft
modifier|*
name|tl
decl_stmt|;
comment|/* literal/length code table */
name|struct
name|huft
modifier|*
name|td
decl_stmt|;
comment|/* distance code table */
name|int
name|bl
decl_stmt|;
comment|/* lookup bits for tl */
name|int
name|bd
decl_stmt|;
comment|/* lookup bits for td */
name|unsigned
name|l
index|[
literal|288
index|]
decl_stmt|;
comment|/* length list for huft_build */
comment|/* set up literal table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|144
condition|;
name|i
operator|++
control|)
name|l
index|[
name|i
index|]
operator|=
literal|8
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|l
index|[
name|i
index|]
operator|=
literal|9
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|280
condition|;
name|i
operator|++
control|)
name|l
index|[
name|i
index|]
operator|=
literal|7
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|288
condition|;
name|i
operator|++
control|)
comment|/* make a complete, but wrong code set */
name|l
index|[
name|i
index|]
operator|=
literal|8
expr_stmt|;
name|bl
operator|=
literal|7
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|huft_build
argument_list|(
name|l
argument_list|,
literal|288
argument_list|,
literal|257
argument_list|,
name|cplens
argument_list|,
name|cplext
argument_list|,
operator|&
name|tl
argument_list|,
operator|&
name|bl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|i
return|;
comment|/* set up distance table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|30
condition|;
name|i
operator|++
control|)
comment|/* make an incomplete code set */
name|l
index|[
name|i
index|]
operator|=
literal|5
expr_stmt|;
name|bd
operator|=
literal|5
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|huft_build
argument_list|(
name|l
argument_list|,
literal|30
argument_list|,
literal|0
argument_list|,
name|cpdist
argument_list|,
name|cpdext
argument_list|,
operator|&
name|td
argument_list|,
operator|&
name|bd
argument_list|)
operator|)
operator|>
literal|1
condition|)
block|{
name|huft_free
argument_list|(
name|tl
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
comment|/* decompress until an end-of-block code */
if|if
condition|(
name|inflate_codes
argument_list|(
name|tl
argument_list|,
name|td
argument_list|,
name|bl
argument_list|,
name|bd
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* free the decoding tables, return */
name|huft_free
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|huft_free
argument_list|(
name|td
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|inflate_dynamic
parameter_list|()
comment|/* decompress an inflated type 2 (dynamic Huffman codes) block. */
block|{
name|int
name|i
decl_stmt|;
comment|/* temporary variables */
name|unsigned
name|j
decl_stmt|;
name|unsigned
name|l
decl_stmt|;
comment|/* last length */
name|unsigned
name|m
decl_stmt|;
comment|/* mask for bit lengths table */
name|unsigned
name|n
decl_stmt|;
comment|/* number of lengths to get */
name|struct
name|huft
modifier|*
name|tl
decl_stmt|;
comment|/* literal/length code table */
name|struct
name|huft
modifier|*
name|td
decl_stmt|;
comment|/* distance code table */
name|int
name|bl
decl_stmt|;
comment|/* lookup bits for tl */
name|int
name|bd
decl_stmt|;
comment|/* lookup bits for td */
name|unsigned
name|nb
decl_stmt|;
comment|/* number of bit length codes */
name|unsigned
name|nl
decl_stmt|;
comment|/* number of literal/length codes */
name|unsigned
name|nd
decl_stmt|;
comment|/* number of distance codes */
ifdef|#
directive|ifdef
name|PKZIP_BUG_WORKAROUND
name|unsigned
name|ll
index|[
literal|288
operator|+
literal|32
index|]
decl_stmt|;
comment|/* literal/length and distance code lengths */
else|#
directive|else
name|unsigned
name|ll
index|[
literal|286
operator|+
literal|30
index|]
decl_stmt|;
comment|/* literal/length and distance code lengths */
endif|#
directive|endif
specifier|register
name|ulg
name|b
decl_stmt|;
comment|/* bit buffer */
specifier|register
name|unsigned
name|k
decl_stmt|;
comment|/* number of bits in bit buffer */
comment|/* make local bit buffer */
name|b
operator|=
name|bb
expr_stmt|;
name|k
operator|=
name|bk
expr_stmt|;
comment|/* read in table lengths */
name|NEEDBITS
argument_list|(
literal|5
argument_list|)
name|nl
operator|=
literal|257
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
literal|0x1f
operator|)
expr_stmt|;
comment|/* number of literal/length codes */
name|DUMPBITS
argument_list|(
literal|5
argument_list|)
name|NEEDBITS
argument_list|(
literal|5
argument_list|)
name|nd
operator|=
literal|1
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
literal|0x1f
operator|)
expr_stmt|;
comment|/* number of distance codes */
name|DUMPBITS
argument_list|(
literal|5
argument_list|)
name|NEEDBITS
argument_list|(
literal|4
argument_list|)
name|nb
operator|=
literal|4
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
literal|0xf
operator|)
expr_stmt|;
comment|/* number of bit length codes */
name|DUMPBITS
argument_list|(
literal|4
argument_list|)
ifdef|#
directive|ifdef
name|PKZIP_BUG_WORKAROUND
if|if
condition|(
name|nl
operator|>
literal|288
operator|||
name|nd
operator|>
literal|32
condition|)
else|#
directive|else
if|if
condition|(
name|nl
operator|>
literal|286
operator|||
name|nd
operator|>
literal|30
condition|)
endif|#
directive|endif
return|return
literal|1
return|;
comment|/* bad lengths */
comment|/* read in bit-length-code lengths */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nb
condition|;
name|j
operator|++
control|)
block|{
name|NEEDBITS
argument_list|(
literal|3
argument_list|)
name|ll
index|[
name|border
index|[
name|j
index|]
index|]
operator|=
operator|(
name|unsigned
operator|)
name|b
operator|&
literal|7
expr_stmt|;
name|DUMPBITS
argument_list|(
literal|3
argument_list|)
block|}
for|for
control|(
init|;
name|j
operator|<
literal|19
condition|;
name|j
operator|++
control|)
name|ll
index|[
name|border
index|[
name|j
index|]
index|]
operator|=
literal|0
expr_stmt|;
comment|/* build decoding table for trees--single level, 7 bit lookup */
name|bl
operator|=
literal|7
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|huft_build
argument_list|(
name|ll
argument_list|,
literal|19
argument_list|,
literal|19
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tl
argument_list|,
operator|&
name|bl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|huft_free
argument_list|(
name|tl
argument_list|)
expr_stmt|;
return|return
name|i
return|;
comment|/* incomplete code set */
block|}
if|if
condition|(
name|tl
operator|==
name|NULL
condition|)
comment|/* Grrrhhh */
return|return
literal|2
return|;
comment|/* read in literal and distance code lengths */
name|n
operator|=
name|nl
operator|+
name|nd
expr_stmt|;
name|m
operator|=
name|mask_bits
index|[
name|bl
index|]
expr_stmt|;
name|i
operator|=
name|l
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|unsigned
operator|)
name|i
operator|<
name|n
condition|)
block|{
name|NEEDBITS
argument_list|(
argument|(unsigned)bl
argument_list|)
name|j
operator|=
operator|(
name|td
operator|=
name|tl
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
name|m
operator|)
operator|)
operator|->
name|b
expr_stmt|;
name|DUMPBITS
argument_list|(
argument|j
argument_list|)
name|j
operator|=
name|td
operator|->
name|v
operator|.
name|n
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|16
condition|)
comment|/* length of code in bits (0..15) */
name|ll
index|[
name|i
operator|++
index|]
operator|=
name|l
operator|=
name|j
expr_stmt|;
comment|/* save last length in l */
elseif|else
if|if
condition|(
name|j
operator|==
literal|16
condition|)
comment|/* repeat last length 3 to 6 times */
block|{
name|NEEDBITS
argument_list|(
literal|2
argument_list|)
name|j
operator|=
literal|3
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
literal|3
operator|)
expr_stmt|;
name|DUMPBITS
argument_list|(
literal|2
argument_list|)
if|if
condition|(
operator|(
name|unsigned
operator|)
name|i
operator|+
name|j
operator|>
name|n
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|j
operator|--
condition|)
name|ll
index|[
name|i
operator|++
index|]
operator|=
name|l
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|==
literal|17
condition|)
comment|/* 3 to 10 zero length codes */
block|{
name|NEEDBITS
argument_list|(
literal|3
argument_list|)
name|j
operator|=
literal|3
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
literal|7
operator|)
expr_stmt|;
name|DUMPBITS
argument_list|(
literal|3
argument_list|)
if|if
condition|(
operator|(
name|unsigned
operator|)
name|i
operator|+
name|j
operator|>
name|n
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|j
operator|--
condition|)
name|ll
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* j == 18: 11 to 138 zero length codes */
block|{
name|NEEDBITS
argument_list|(
literal|7
argument_list|)
name|j
operator|=
literal|11
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|b
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|DUMPBITS
argument_list|(
literal|7
argument_list|)
if|if
condition|(
operator|(
name|unsigned
operator|)
name|i
operator|+
name|j
operator|>
name|n
condition|)
return|return
literal|1
return|;
while|while
condition|(
name|j
operator|--
condition|)
name|ll
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* free decoding table for trees */
name|huft_free
argument_list|(
name|tl
argument_list|)
expr_stmt|;
comment|/* restore the global bit buffer */
name|bb
operator|=
name|b
expr_stmt|;
name|bk
operator|=
name|k
expr_stmt|;
comment|/* build the decoding tables for literal/length and distance codes */
name|bl
operator|=
name|lbits
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|huft_build
argument_list|(
name|ll
argument_list|,
name|nl
argument_list|,
literal|257
argument_list|,
name|cplens
argument_list|,
name|cplext
argument_list|,
operator|&
name|tl
argument_list|,
operator|&
name|bl
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" incomplete literal tree\n"
argument_list|)
expr_stmt|;
name|huft_free
argument_list|(
name|tl
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
comment|/* incomplete code set */
block|}
name|bd
operator|=
name|dbits
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|huft_build
argument_list|(
name|ll
operator|+
name|nl
argument_list|,
name|nd
argument_list|,
literal|0
argument_list|,
name|cpdist
argument_list|,
name|cpdext
argument_list|,
operator|&
name|td
argument_list|,
operator|&
name|bd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" incomplete distance tree\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PKZIP_BUG_WORKAROUND
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
name|huft_free
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
name|huft_free
argument_list|(
name|tl
argument_list|)
expr_stmt|;
return|return
name|i
return|;
comment|/* incomplete code set */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* decompress until an end-of-block code */
end_comment

begin_if
if|if
condition|(
name|inflate_codes
argument_list|(
name|tl
argument_list|,
name|td
argument_list|,
name|bl
argument_list|,
name|bd
argument_list|)
condition|)
return|return
literal|1
return|;
end_if

begin_comment
comment|/* free the decoding tables, return */
end_comment

begin_expr_stmt
name|huft_free
argument_list|(
name|tl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|huft_free
argument_list|(
name|td
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
literal|0
return|;
end_return

begin_macro
unit|}    int
name|inflate_block
argument_list|(
argument|e
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last block flag */
end_comment

begin_comment
comment|/* decompress an inflated block */
end_comment

begin_block
block|{
name|unsigned
name|t
decl_stmt|;
comment|/* block type */
specifier|register
name|ulg
name|b
decl_stmt|;
comment|/* bit buffer */
specifier|register
name|unsigned
name|k
decl_stmt|;
comment|/* number of bits in bit buffer */
comment|/* make local bit buffer */
name|b
operator|=
name|bb
expr_stmt|;
name|k
operator|=
name|bk
expr_stmt|;
comment|/* read in last block bit */
name|NEEDBITS
argument_list|(
literal|1
argument_list|)
operator|*
name|e
operator|=
operator|(
name|int
operator|)
name|b
operator|&
literal|1
expr_stmt|;
name|DUMPBITS
argument_list|(
literal|1
argument_list|)
comment|/* read in block type */
name|NEEDBITS
argument_list|(
literal|2
argument_list|)
name|t
operator|=
operator|(
name|unsigned
operator|)
name|b
operator|&
literal|3
expr_stmt|;
name|DUMPBITS
argument_list|(
literal|2
argument_list|)
comment|/* restore the global bit buffer */
name|bb
operator|=
name|b
expr_stmt|;
name|bk
operator|=
name|k
expr_stmt|;
comment|/* inflate that block type */
if|if
condition|(
name|t
operator|==
literal|2
condition|)
return|return
name|inflate_dynamic
argument_list|()
return|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
return|return
name|inflate_stored
argument_list|()
return|;
if|if
condition|(
name|t
operator|==
literal|1
condition|)
return|return
name|inflate_fixed
argument_list|()
return|;
comment|/* bad block type */
return|return
literal|2
return|;
block|}
end_block

begin_function
name|int
name|inflate
parameter_list|()
comment|/* decompress an inflated entry */
block|{
name|int
name|e
decl_stmt|;
comment|/* last block flag */
name|int
name|r
decl_stmt|;
comment|/* result code */
name|unsigned
name|h
decl_stmt|;
comment|/* maximum struct huft's malloc'ed */
comment|/* initialize window, bit buffer */
name|wp
operator|=
literal|0
expr_stmt|;
name|bk
operator|=
literal|0
expr_stmt|;
name|bb
operator|=
literal|0
expr_stmt|;
comment|/* decompress until the last block */
name|h
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|hufts
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|inflate_block
argument_list|(
operator|&
name|e
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
if|if
condition|(
name|hufts
operator|>
name|h
condition|)
name|h
operator|=
name|hufts
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|e
condition|)
do|;
comment|/* Undo too much lookahead. The next read will be byte aligned so we    * can discard unused bits in the last meaningful byte.    */
while|while
condition|(
name|bk
operator|>=
literal|8
condition|)
block|{
name|bk
operator|-=
literal|8
expr_stmt|;
name|inptr
operator|--
expr_stmt|;
block|}
comment|/* flush out slide */
name|flush_output
argument_list|(
name|wp
argument_list|)
expr_stmt|;
comment|/* return success */
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<%u> "
argument_list|,
name|h
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
literal|0
return|;
block|}
end_function

end_unit

