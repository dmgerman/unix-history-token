begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* unlzh.c -- decompress files in SCO compress -H (LZH) format.  * The code in this file is directly derived from the public domain 'ar002'  * written by Haruhiko Okumura.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_include
include|#
directive|include
file|"gzip.h"
end_include

begin_include
include|#
directive|include
file|"lzw.h"
end_include

begin_comment
comment|/* just for consistency checking */
end_comment

begin_comment
comment|/* decode.c */
end_comment

begin_decl_stmt
name|local
name|unsigned
name|decode
name|OF
argument_list|(
operator|(
name|unsigned
name|count
operator|,
name|uch
name|buffer
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|decode_start
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* huf.c */
end_comment

begin_decl_stmt
name|local
name|void
name|huf_decode_start
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|unsigned
name|decode_c
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|unsigned
name|decode_p
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|read_pt_len
name|OF
argument_list|(
operator|(
name|int
name|nn
operator|,
name|int
name|nbit
operator|,
name|int
name|i_special
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|read_c_len
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* io.c */
end_comment

begin_decl_stmt
name|local
name|void
name|fillbuf
name|OF
argument_list|(
operator|(
name|int
name|n
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|unsigned
name|getbits
name|OF
argument_list|(
operator|(
name|int
name|n
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|init_getbits
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maketbl.c */
end_comment

begin_decl_stmt
name|local
name|void
name|make_table
name|OF
argument_list|(
operator|(
name|int
name|nchar
operator|,
name|uch
name|bitlen
index|[]
operator|,
name|int
name|tablebits
operator|,
name|ush
name|table
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DICBIT
value|13
end_define

begin_comment
comment|/* 12(-lh4-) or 13(-lh5-) */
end_comment

begin_define
define|#
directive|define
name|DICSIZ
value|((unsigned) 1<< DICBIT)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_BIT
end_ifndef

begin_define
define|#
directive|define
name|CHAR_BIT
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|UCHAR_MAX
end_ifndef

begin_define
define|#
directive|define
name|UCHAR_MAX
value|255
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BITBUFSIZ
value|(CHAR_BIT * 2 * sizeof(char))
end_define

begin_comment
comment|/* Do not use CHAR_BIT * sizeof(bitbuf), does not work on machines  * for which short is not on 16 bits (Cray).  */
end_comment

begin_comment
comment|/* encode.c and decode.c */
end_comment

begin_define
define|#
directive|define
name|MAXMATCH
value|256
end_define

begin_comment
comment|/* formerly F (not more than UCHAR_MAX + 1) */
end_comment

begin_define
define|#
directive|define
name|THRESHOLD
value|3
end_define

begin_comment
comment|/* choose optimal value */
end_comment

begin_comment
comment|/* huf.c */
end_comment

begin_define
define|#
directive|define
name|NC
value|(UCHAR_MAX + MAXMATCH + 2 - THRESHOLD)
end_define

begin_comment
comment|/* alphabet = {0, 1, 2, ..., NC - 1} */
end_comment

begin_define
define|#
directive|define
name|CBIT
value|9
end_define

begin_comment
comment|/* $\lfloor \log_2 NC \rfloor + 1$ */
end_comment

begin_define
define|#
directive|define
name|CODE_BIT
value|16
end_define

begin_comment
comment|/* codeword length */
end_comment

begin_define
define|#
directive|define
name|NP
value|(DICBIT + 1)
end_define

begin_define
define|#
directive|define
name|NT
value|(CODE_BIT + 3)
end_define

begin_define
define|#
directive|define
name|PBIT
value|4
end_define

begin_comment
comment|/* smallest integer such that (1U<< PBIT)> NP */
end_comment

begin_define
define|#
directive|define
name|TBIT
value|5
end_define

begin_comment
comment|/* smallest integer such that (1U<< TBIT)> NT */
end_comment

begin_if
if|#
directive|if
name|NT
operator|>
name|NP
end_if

begin_define
define|#
directive|define
name|NPT
value|NT
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NPT
value|NP
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* local ush left[2 * NC - 1]; */
end_comment

begin_comment
comment|/* local ush right[2 * NC - 1]; */
end_comment

begin_define
define|#
directive|define
name|left
value|prev
end_define

begin_define
define|#
directive|define
name|right
value|head
end_define

begin_if
if|#
directive|if
name|NC
operator|>
operator|(
literal|1
operator|<<
operator|(
name|BITS
operator|-
literal|2
operator|)
operator|)
end_if

begin_expr_stmt
name|error
name|cannot
name|overlay
name|left
operator|+
name|right
name|and
name|prev
endif|#
directive|endif
comment|/* local uch c_len[NC]; */
define|#
directive|define
name|c_len
value|outbuf
if|#
directive|if
name|NC
operator|>
name|OUTBUFSIZ
name|error
name|cannot
name|overlay
name|c_len
name|and
name|outbuf
endif|#
directive|endif
name|local
name|uch
name|pt_len
index|[
name|NPT
index|]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|local
name|unsigned
name|blocksize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|ush
name|pt_table
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local ush c_table[4096]; */
end_comment

begin_define
define|#
directive|define
name|c_table
value|d_buf
end_define

begin_if
if|#
directive|if
operator|(
name|DIST_BUFSIZE
operator|-
literal|1
operator|)
operator|<
literal|4095
end_if

begin_decl_stmt
name|error
name|cannot
name|overlay
name|c_table
name|and
name|d_buf
endif|#
directive|endif
comment|/***********************************************************         io.c -- input/output ***********************************************************/
name|local
name|ush
name|bitbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|unsigned
name|subbitbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|bitcount
decl_stmt|;
end_decl_stmt

begin_function
name|local
name|void
name|fillbuf
parameter_list|(
name|n
parameter_list|)
comment|/* Shift bitbuf n bits left, read n bits */
name|int
name|n
decl_stmt|;
block|{
name|bitbuf
operator|<<=
name|n
expr_stmt|;
while|while
condition|(
name|n
operator|>
name|bitcount
condition|)
block|{
name|bitbuf
operator||=
name|subbitbuf
operator|<<
operator|(
name|n
operator|-=
name|bitcount
operator|)
expr_stmt|;
name|subbitbuf
operator|=
operator|(
name|unsigned
operator|)
name|try_byte
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|subbitbuf
operator|==
name|EOF
condition|)
name|subbitbuf
operator|=
literal|0
expr_stmt|;
name|bitcount
operator|=
name|CHAR_BIT
expr_stmt|;
block|}
name|bitbuf
operator||=
name|subbitbuf
operator|>>
operator|(
name|bitcount
operator|-=
name|n
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|local
name|unsigned
name|getbits
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|unsigned
name|x
decl_stmt|;
name|x
operator|=
name|bitbuf
operator|>>
operator|(
name|BITBUFSIZ
operator|-
name|n
operator|)
expr_stmt|;
name|fillbuf
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_function
name|local
name|void
name|init_getbits
parameter_list|()
block|{
name|bitbuf
operator|=
literal|0
expr_stmt|;
name|subbitbuf
operator|=
literal|0
expr_stmt|;
name|bitcount
operator|=
literal|0
expr_stmt|;
name|fillbuf
argument_list|(
name|BITBUFSIZ
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************** 	maketbl.c -- make table for decoding ***********************************************************/
end_comment

begin_function
name|local
name|void
name|make_table
parameter_list|(
name|nchar
parameter_list|,
name|bitlen
parameter_list|,
name|tablebits
parameter_list|,
name|table
parameter_list|)
name|int
name|nchar
decl_stmt|;
name|uch
name|bitlen
index|[]
decl_stmt|;
name|int
name|tablebits
decl_stmt|;
name|ush
name|table
index|[]
decl_stmt|;
block|{
name|ush
name|count
index|[
literal|17
index|]
decl_stmt|,
name|weight
index|[
literal|17
index|]
decl_stmt|,
name|start
index|[
literal|18
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|k
decl_stmt|,
name|len
decl_stmt|,
name|ch
decl_stmt|,
name|jutbits
decl_stmt|,
name|avail
decl_stmt|,
name|nextcode
decl_stmt|,
name|mask
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|16
condition|;
name|i
operator|++
control|)
name|count
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|unsigned
operator|)
name|nchar
condition|;
name|i
operator|++
control|)
name|count
index|[
name|bitlen
index|[
name|i
index|]
index|]
operator|++
expr_stmt|;
name|start
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|16
condition|;
name|i
operator|++
control|)
name|start
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|start
index|[
name|i
index|]
operator|+
operator|(
name|count
index|[
name|i
index|]
operator|<<
operator|(
literal|16
operator|-
name|i
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|start
index|[
literal|17
index|]
operator|&
literal|0xffff
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Bad table\n"
argument_list|)
expr_stmt|;
name|jutbits
operator|=
literal|16
operator|-
name|tablebits
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
operator|(
name|unsigned
operator|)
name|tablebits
condition|;
name|i
operator|++
control|)
block|{
name|start
index|[
name|i
index|]
operator|>>=
name|jutbits
expr_stmt|;
name|weight
index|[
name|i
index|]
operator|=
operator|(
name|unsigned
operator|)
literal|1
operator|<<
operator|(
name|tablebits
operator|-
name|i
operator|)
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<=
literal|16
condition|)
block|{
name|weight
index|[
name|i
index|]
operator|=
operator|(
name|unsigned
operator|)
literal|1
operator|<<
operator|(
literal|16
operator|-
name|i
operator|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|i
operator|=
name|start
index|[
name|tablebits
operator|+
literal|1
index|]
operator|>>
name|jutbits
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|k
operator|=
literal|1
operator|<<
name|tablebits
expr_stmt|;
while|while
condition|(
name|i
operator|!=
name|k
condition|)
name|table
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|avail
operator|=
name|nchar
expr_stmt|;
name|mask
operator|=
operator|(
name|unsigned
operator|)
literal|1
operator|<<
operator|(
literal|15
operator|-
name|tablebits
operator|)
expr_stmt|;
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
operator|(
name|unsigned
operator|)
name|nchar
condition|;
name|ch
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|bitlen
index|[
name|ch
index|]
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|nextcode
operator|=
name|start
index|[
name|len
index|]
operator|+
name|weight
index|[
name|len
index|]
expr_stmt|;
if|if
condition|(
name|len
operator|<=
operator|(
name|unsigned
operator|)
name|tablebits
condition|)
block|{
for|for
control|(
name|i
operator|=
name|start
index|[
name|len
index|]
init|;
name|i
operator|<
name|nextcode
condition|;
name|i
operator|++
control|)
name|table
index|[
name|i
index|]
operator|=
name|ch
expr_stmt|;
block|}
else|else
block|{
name|k
operator|=
name|start
index|[
name|len
index|]
expr_stmt|;
name|p
operator|=
operator|&
name|table
index|[
name|k
operator|>>
name|jutbits
index|]
expr_stmt|;
name|i
operator|=
name|len
operator|-
name|tablebits
expr_stmt|;
while|while
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|right
index|[
name|avail
index|]
operator|=
name|left
index|[
name|avail
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|=
name|avail
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|&
name|mask
condition|)
name|p
operator|=
operator|&
name|right
index|[
operator|*
name|p
index|]
expr_stmt|;
else|else
name|p
operator|=
operator|&
name|left
index|[
operator|*
name|p
index|]
expr_stmt|;
name|k
operator|<<=
literal|1
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|ch
expr_stmt|;
block|}
name|start
index|[
name|len
index|]
operator|=
name|nextcode
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/***********************************************************         huf.c -- static Huffman ***********************************************************/
end_comment

begin_function
name|local
name|void
name|read_pt_len
parameter_list|(
name|nn
parameter_list|,
name|nbit
parameter_list|,
name|i_special
parameter_list|)
name|int
name|nn
decl_stmt|;
name|int
name|nbit
decl_stmt|;
name|int
name|i_special
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|n
decl_stmt|;
name|unsigned
name|mask
decl_stmt|;
name|n
operator|=
name|getbits
argument_list|(
name|nbit
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|getbits
argument_list|(
name|nbit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nn
condition|;
name|i
operator|++
control|)
name|pt_len
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|pt_table
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|c
operator|=
name|bitbuf
operator|>>
operator|(
name|BITBUFSIZ
operator|-
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|7
condition|)
block|{
name|mask
operator|=
operator|(
name|unsigned
operator|)
literal|1
operator|<<
operator|(
name|BITBUFSIZ
operator|-
literal|1
operator|-
literal|3
operator|)
expr_stmt|;
while|while
condition|(
name|mask
operator|&
name|bitbuf
condition|)
block|{
name|mask
operator|>>=
literal|1
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
block|}
name|fillbuf
argument_list|(
operator|(
name|c
operator|<
literal|7
operator|)
condition|?
literal|3
else|:
name|c
operator|-
literal|3
argument_list|)
expr_stmt|;
name|pt_len
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|i_special
condition|)
block|{
name|c
operator|=
name|getbits
argument_list|(
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|c
operator|>=
literal|0
condition|)
name|pt_len
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
while|while
condition|(
name|i
operator|<
name|nn
condition|)
name|pt_len
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|make_table
argument_list|(
name|nn
argument_list|,
name|pt_len
argument_list|,
literal|8
argument_list|,
name|pt_table
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|local
name|void
name|read_c_len
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|n
decl_stmt|;
name|unsigned
name|mask
decl_stmt|;
name|n
operator|=
name|getbits
argument_list|(
name|CBIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|c
operator|=
name|getbits
argument_list|(
name|CBIT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NC
condition|;
name|i
operator|++
control|)
name|c_len
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4096
condition|;
name|i
operator|++
control|)
name|c_table
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|c
operator|=
name|pt_table
index|[
name|bitbuf
operator|>>
operator|(
name|BITBUFSIZ
operator|-
literal|8
operator|)
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|>=
name|NT
condition|)
block|{
name|mask
operator|=
operator|(
name|unsigned
operator|)
literal|1
operator|<<
operator|(
name|BITBUFSIZ
operator|-
literal|1
operator|-
literal|8
operator|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|bitbuf
operator|&
name|mask
condition|)
name|c
operator|=
name|right
index|[
name|c
index|]
expr_stmt|;
else|else
name|c
operator|=
name|left
index|[
name|c
index|]
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|>=
name|NT
condition|)
do|;
block|}
name|fillbuf
argument_list|(
operator|(
name|int
operator|)
name|pt_len
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|2
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|c
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|1
condition|)
name|c
operator|=
name|getbits
argument_list|(
literal|4
argument_list|)
operator|+
literal|3
expr_stmt|;
else|else
name|c
operator|=
name|getbits
argument_list|(
name|CBIT
argument_list|)
operator|+
literal|20
expr_stmt|;
while|while
condition|(
operator|--
name|c
operator|>=
literal|0
condition|)
name|c_len
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|c_len
index|[
name|i
operator|++
index|]
operator|=
name|c
operator|-
literal|2
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
name|NC
condition|)
name|c_len
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|make_table
argument_list|(
name|NC
argument_list|,
name|c_len
argument_list|,
literal|12
argument_list|,
name|c_table
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|local
name|unsigned
name|decode_c
parameter_list|()
block|{
name|unsigned
name|j
decl_stmt|,
name|mask
decl_stmt|;
if|if
condition|(
name|blocksize
operator|==
literal|0
condition|)
block|{
name|blocksize
operator|=
name|getbits
argument_list|(
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocksize
operator|==
literal|0
condition|)
block|{
return|return
name|NC
return|;
comment|/* end of file */
block|}
name|read_pt_len
argument_list|(
name|NT
argument_list|,
name|TBIT
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|read_c_len
argument_list|()
expr_stmt|;
name|read_pt_len
argument_list|(
name|NP
argument_list|,
name|PBIT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|blocksize
operator|--
expr_stmt|;
name|j
operator|=
name|c_table
index|[
name|bitbuf
operator|>>
operator|(
name|BITBUFSIZ
operator|-
literal|12
operator|)
index|]
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|NC
condition|)
block|{
name|mask
operator|=
operator|(
name|unsigned
operator|)
literal|1
operator|<<
operator|(
name|BITBUFSIZ
operator|-
literal|1
operator|-
literal|12
operator|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|bitbuf
operator|&
name|mask
condition|)
name|j
operator|=
name|right
index|[
name|j
index|]
expr_stmt|;
else|else
name|j
operator|=
name|left
index|[
name|j
index|]
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|>=
name|NC
condition|)
do|;
block|}
name|fillbuf
argument_list|(
operator|(
name|int
operator|)
name|c_len
index|[
name|j
index|]
argument_list|)
expr_stmt|;
return|return
name|j
return|;
block|}
end_function

begin_function
name|local
name|unsigned
name|decode_p
parameter_list|()
block|{
name|unsigned
name|j
decl_stmt|,
name|mask
decl_stmt|;
name|j
operator|=
name|pt_table
index|[
name|bitbuf
operator|>>
operator|(
name|BITBUFSIZ
operator|-
literal|8
operator|)
index|]
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|NP
condition|)
block|{
name|mask
operator|=
operator|(
name|unsigned
operator|)
literal|1
operator|<<
operator|(
name|BITBUFSIZ
operator|-
literal|1
operator|-
literal|8
operator|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|bitbuf
operator|&
name|mask
condition|)
name|j
operator|=
name|right
index|[
name|j
index|]
expr_stmt|;
else|else
name|j
operator|=
name|left
index|[
name|j
index|]
expr_stmt|;
name|mask
operator|>>=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|>=
name|NP
condition|)
do|;
block|}
name|fillbuf
argument_list|(
operator|(
name|int
operator|)
name|pt_len
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|!=
literal|0
condition|)
name|j
operator|=
operator|(
operator|(
name|unsigned
operator|)
literal|1
operator|<<
operator|(
name|j
operator|-
literal|1
operator|)
operator|)
operator|+
name|getbits
argument_list|(
call|(
name|int
call|)
argument_list|(
name|j
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|j
return|;
block|}
end_function

begin_function
name|local
name|void
name|huf_decode_start
parameter_list|()
block|{
name|init_getbits
argument_list|()
expr_stmt|;
name|blocksize
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/***********************************************************         decode.c ***********************************************************/
end_comment

begin_decl_stmt
name|local
name|int
name|j
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* remaining bytes to copy */
end_comment

begin_decl_stmt
name|local
name|int
name|done
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set at end of input */
end_comment

begin_function
name|local
name|void
name|decode_start
parameter_list|()
block|{
name|huf_decode_start
argument_list|()
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decode the input and return the number of decoded bytes put in buffer  */
end_comment

begin_function
name|local
name|unsigned
name|decode
parameter_list|(
name|count
parameter_list|,
name|buffer
parameter_list|)
name|unsigned
name|count
decl_stmt|;
name|uch
name|buffer
index|[]
decl_stmt|;
comment|/* The calling function must keep the number of        bytes to be processed.  This function decodes        either 'count' bytes or 'DICSIZ' bytes, whichever        is smaller, into the array 'buffer[]' of size        'DICSIZ' or more.        Call decode_start() once for each new file        before calling this function.      */
block|{
name|local
name|unsigned
name|i
decl_stmt|;
name|unsigned
name|r
decl_stmt|,
name|c
decl_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
name|buffer
index|[
name|r
index|]
operator|=
name|buffer
index|[
name|i
index|]
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
operator|(
name|DICSIZ
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|++
name|r
operator|==
name|count
condition|)
return|return
name|r
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|decode_c
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NC
condition|)
block|{
name|done
operator|=
literal|1
expr_stmt|;
return|return
name|r
return|;
block|}
if|if
condition|(
name|c
operator|<=
name|UCHAR_MAX
condition|)
block|{
name|buffer
index|[
name|r
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|++
name|r
operator|==
name|count
condition|)
return|return
name|r
return|;
block|}
else|else
block|{
name|j
operator|=
name|c
operator|-
operator|(
name|UCHAR_MAX
operator|+
literal|1
operator|-
name|THRESHOLD
operator|)
expr_stmt|;
name|i
operator|=
operator|(
name|r
operator|-
name|decode_p
argument_list|()
operator|-
literal|1
operator|)
operator|&
operator|(
name|DICSIZ
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
block|{
name|buffer
index|[
name|r
index|]
operator|=
name|buffer
index|[
name|i
index|]
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
operator|(
name|DICSIZ
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|++
name|r
operator|==
name|count
condition|)
return|return
name|r
return|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Unlzh in to out. Return OK or ERROR.  */
end_comment

begin_function
name|int
name|unlzh
parameter_list|(
name|in
parameter_list|,
name|out
parameter_list|)
name|int
name|in
decl_stmt|;
name|int
name|out
decl_stmt|;
block|{
name|unsigned
name|n
decl_stmt|;
name|ifd
operator|=
name|in
expr_stmt|;
name|ofd
operator|=
name|out
expr_stmt|;
name|decode_start
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|n
operator|=
name|decode
argument_list|(
operator|(
name|unsigned
operator|)
name|DICSIZ
argument_list|,
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|test
operator|&&
name|n
operator|>
literal|0
condition|)
block|{
name|write_buf
argument_list|(
name|out
argument_list|,
operator|(
name|char
operator|*
operator|)
name|window
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|OK
return|;
block|}
end_function

end_unit

