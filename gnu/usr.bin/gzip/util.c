begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* util.c -- utility functions for gzip support  * Copyright (C) 1992-1993 Jean-loup Gailly  * This is free software; you can redistribute it and/or modify it under the  * terms of the GNU General Public License, see the file COPYING.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_FCNTL_H
end_ifndef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|NO_STDLIB_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gzip.h"
end_include

begin_include
include|#
directive|include
file|"crypt.h"
end_include

begin_decl_stmt
specifier|extern
name|ulg
name|crc_32_tab
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* crc table, defined below */
end_comment

begin_comment
comment|/* ===========================================================================  * Copy input to output unchanged: zcat == cat with --force.  * IN assertion: insize bytes have already been read in inbuf.  */
end_comment

begin_function
name|int
name|copy
parameter_list|(
name|in
parameter_list|,
name|out
parameter_list|)
name|int
name|in
decl_stmt|,
name|out
decl_stmt|;
comment|/* input and output file descriptors */
block|{
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|insize
operator|!=
literal|0
operator|&&
operator|(
name|int
operator|)
name|insize
operator|!=
name|EOF
condition|)
block|{
name|write_buf
argument_list|(
name|out
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inbuf
argument_list|,
name|insize
argument_list|)
expr_stmt|;
name|bytes_out
operator|+=
name|insize
expr_stmt|;
name|insize
operator|=
name|read
argument_list|(
name|in
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inbuf
argument_list|,
name|INBUFSIZ
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|insize
operator|==
name|EOF
operator|&&
name|errno
operator|!=
literal|0
condition|)
block|{
name|read_error
argument_list|()
expr_stmt|;
block|}
name|bytes_in
operator|=
name|bytes_out
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Run a set of bytes through the crc shift register.  If s is a NULL  * pointer, then initialize the crc shift register contents instead.  * Return the current crc in either case.  */
end_comment

begin_function
name|ulg
name|updcrc
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
name|uch
modifier|*
name|s
decl_stmt|;
comment|/* pointer to bytes to pump through */
name|unsigned
name|n
decl_stmt|;
comment|/* number of bytes in s[] */
block|{
specifier|register
name|ulg
name|c
decl_stmt|;
comment|/* temporary variable */
specifier|static
name|ulg
name|crc
init|=
operator|(
name|ulg
operator|)
literal|0xffffffffL
decl_stmt|;
comment|/* shift register contents */
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|c
operator|=
literal|0xffffffffL
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|crc
expr_stmt|;
if|if
condition|(
name|n
condition|)
do|do
block|{
name|c
operator|=
name|crc_32_tab
index|[
operator|(
operator|(
name|int
operator|)
name|c
operator|^
operator|(
operator|*
name|s
operator|++
operator|)
operator|)
operator|&
literal|0xff
index|]
operator|^
operator|(
name|c
operator|>>
literal|8
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
condition|)
do|;
block|}
name|crc
operator|=
name|c
expr_stmt|;
return|return
name|c
operator|^
literal|0xffffffffL
return|;
comment|/* (instead of ~c for 64-bit machines) */
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Clear input and output buffers  */
end_comment

begin_function
name|void
name|clear_bufs
parameter_list|()
block|{
name|outcnt
operator|=
literal|0
expr_stmt|;
name|insize
operator|=
name|inptr
operator|=
literal|0
expr_stmt|;
name|bytes_in
operator|=
name|bytes_out
operator|=
literal|0L
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Fill the input buffer. This is called only when the buffer is empty.  */
end_comment

begin_function
name|int
name|fill_inbuf
parameter_list|(
name|eof_ok
parameter_list|)
name|int
name|eof_ok
decl_stmt|;
comment|/* set if EOF acceptable as a result */
block|{
name|int
name|len
decl_stmt|;
comment|/* Read as much as possible */
name|insize
operator|=
literal|0
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|len
operator|=
name|read
argument_list|(
name|ifd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inbuf
operator|+
name|insize
argument_list|,
name|INBUFSIZ
operator|-
name|insize
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|||
name|len
operator|==
name|EOF
condition|)
break|break;
name|insize
operator|+=
name|len
expr_stmt|;
block|}
do|while
condition|(
name|insize
operator|<
name|INBUFSIZ
condition|)
do|;
if|if
condition|(
name|insize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|eof_ok
condition|)
return|return
name|EOF
return|;
name|read_error
argument_list|()
expr_stmt|;
block|}
name|bytes_in
operator|+=
operator|(
name|ulg
operator|)
name|insize
expr_stmt|;
name|inptr
operator|=
literal|1
expr_stmt|;
return|return
name|inbuf
index|[
literal|0
index|]
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Write the output buffer outbuf[0..outcnt-1] and update bytes_out.  * (used for the compressed data only)  */
end_comment

begin_function
name|void
name|flush_outbuf
parameter_list|()
block|{
if|if
condition|(
name|outcnt
operator|==
literal|0
condition|)
return|return;
name|write_buf
argument_list|(
name|ofd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|outbuf
argument_list|,
name|outcnt
argument_list|)
expr_stmt|;
name|bytes_out
operator|+=
operator|(
name|ulg
operator|)
name|outcnt
expr_stmt|;
name|outcnt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Write the output window window[0..outcnt-1] and update crc and bytes_out.  * (Used for the decompressed data only.)  */
end_comment

begin_function
name|void
name|flush_window
parameter_list|()
block|{
if|if
condition|(
name|outcnt
operator|==
literal|0
condition|)
return|return;
name|updcrc
argument_list|(
name|window
argument_list|,
name|outcnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|test
condition|)
block|{
name|write_buf
argument_list|(
name|ofd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|window
argument_list|,
name|outcnt
argument_list|)
expr_stmt|;
block|}
name|bytes_out
operator|+=
operator|(
name|ulg
operator|)
name|outcnt
expr_stmt|;
name|outcnt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Does the same as write(), but also handles partial pipe writes and checks  * for error return.  */
end_comment

begin_function
name|void
name|write_buf
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|cnt
parameter_list|)
name|int
name|fd
decl_stmt|;
name|voidp
name|buf
decl_stmt|;
name|unsigned
name|cnt
decl_stmt|;
block|{
name|unsigned
name|n
decl_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|cnt
argument_list|)
operator|)
operator|!=
name|cnt
condition|)
block|{
if|if
condition|(
name|n
operator|==
call|(
name|unsigned
call|)
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
block|{
name|write_error
argument_list|()
expr_stmt|;
block|}
name|cnt
operator|-=
name|n
expr_stmt|;
name|buf
operator|=
call|(
name|voidp
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ========================================================================  * Put string s in lower case, return s.  */
end_comment

begin_function
name|char
modifier|*
name|strlwr
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|s
init|;
operator|*
name|t
condition|;
name|t
operator|++
control|)
operator|*
name|t
operator|=
name|tolow
argument_list|(
operator|*
name|t
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================  * Return the base name of a file (remove any directory prefix and  * any version suffix). For systems with file names that are not  * case sensitive, force the base name to lower case.  */
end_comment

begin_function
name|char
modifier|*
name|basename
parameter_list|(
name|fname
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|fname
argument_list|,
name|PATH_SEP
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|fname
operator|=
name|p
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|PATH_SEP2
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|fname
argument_list|,
name|PATH_SEP2
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|fname
operator|=
name|p
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PATH_SEP3
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|fname
argument_list|,
name|PATH_SEP3
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|fname
operator|=
name|p
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SUFFIX_SEP
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|fname
argument_list|,
name|SUFFIX_SEP
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|casemap
argument_list|(
literal|'A'
argument_list|)
operator|==
literal|'a'
condition|)
name|strlwr
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
name|fname
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================  * Make a file name legal for file systems not allowing file names with  * multiple dots or starting with a dot (such as MSDOS), by changing  * all dots except the last one into underlines.  A target dependent  * function can be used instead of this simple function by defining the macro  * MAKE_LEGAL_NAME in tailor.h and providing the function in a target  * dependent module.  */
end_comment

begin_function
name|void
name|make_simple_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|p
operator|==
name|name
condition|)
name|p
operator|++
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
operator|--
name|p
operator|==
literal|'.'
condition|)
operator|*
name|p
operator|=
literal|'_'
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
name|name
condition|)
do|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NO_STRING_H
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
end_if

begin_comment
comment|/* Provide missing strspn and strcspn functions. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__STDC__
end_ifndef

begin_define
define|#
directive|define
name|const
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|strspn
name|OF
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|s
operator|,
specifier|const
name|char
operator|*
name|accept
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|strcspn
name|OF
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|s
operator|,
specifier|const
name|char
operator|*
name|reject
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ========================================================================  * Return the length of the maximum initial segment  * of s which contains only characters in accept.  */
end_comment

begin_function
name|int
name|strspn
parameter_list|(
name|s
parameter_list|,
name|accept
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|accept
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|a
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|s
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
for|for
control|(
name|a
operator|=
name|accept
init|;
operator|*
name|a
operator|!=
literal|'\0'
condition|;
operator|++
name|a
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
operator|*
name|a
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|a
operator|==
literal|'\0'
condition|)
return|return
name|count
return|;
operator|++
name|count
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================  * Return the length of the maximum inital segment of s  * which contains no characters from reject.  */
end_comment

begin_function
name|int
name|strcspn
parameter_list|(
name|s
parameter_list|,
name|reject
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|reject
decl_stmt|;
block|{
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|reject
argument_list|,
operator|*
name|s
operator|++
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|count
return|;
operator|++
name|count
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_STRING_H */
end_comment

begin_comment
comment|/* ========================================================================  * Add an environment variable (if any) before argv, and update argc.  * Return the expanded environment variable to be freed later, or NULL  * if no options were added to argv.  */
end_comment

begin_define
define|#
directive|define
name|SEPARATOR
value|" \t"
end_define

begin_comment
comment|/* separators in env variable */
end_comment

begin_function
name|char
modifier|*
name|add_envopt
parameter_list|(
name|argcp
parameter_list|,
name|argvp
parameter_list|,
name|env
parameter_list|)
name|int
modifier|*
name|argcp
decl_stmt|;
comment|/* pointer to argc */
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
comment|/* pointer to argv */
name|char
modifier|*
name|env
decl_stmt|;
comment|/* name of environment variable */
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* running pointer through env variable */
name|char
modifier|*
modifier|*
name|oargv
decl_stmt|;
comment|/* runs through old argv array */
name|char
modifier|*
modifier|*
name|nargv
decl_stmt|;
comment|/* runs through new argv array */
name|int
name|oargc
init|=
operator|*
name|argcp
decl_stmt|;
comment|/* old argc */
name|int
name|nargc
init|=
literal|0
decl_stmt|;
comment|/* number of arguments in env variable */
name|env
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|env
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|env
operator|=
name|strcpy
argument_list|(
name|p
argument_list|,
name|env
argument_list|)
expr_stmt|;
comment|/* keep env variable intact */
for|for
control|(
name|p
operator|=
name|env
init|;
operator|*
name|p
condition|;
name|nargc
operator|++
control|)
block|{
comment|/* move through env */
name|p
operator|+=
name|strspn
argument_list|(
name|p
argument_list|,
name|SEPARATOR
argument_list|)
expr_stmt|;
comment|/* skip leading separators */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
name|p
operator|+=
name|strcspn
argument_list|(
name|p
argument_list|,
name|SEPARATOR
argument_list|)
expr_stmt|;
comment|/* find end of word */
if|if
condition|(
operator|*
name|p
condition|)
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* mark it */
block|}
if|if
condition|(
name|nargc
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|argcp
operator|+=
name|nargc
expr_stmt|;
comment|/* Allocate the new argv array, with an extra element just in case      * the original arg list did not end with a NULL.      */
name|nargv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
operator|*
name|argcp
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargv
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
name|oargv
operator|=
operator|*
name|argvp
expr_stmt|;
operator|*
name|argvp
operator|=
name|nargv
expr_stmt|;
comment|/* Copy the program name first */
if|if
condition|(
name|oargc
operator|--
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"argc<=0"
argument_list|)
expr_stmt|;
operator|*
operator|(
name|nargv
operator|++
operator|)
operator|=
operator|*
operator|(
name|oargv
operator|++
operator|)
expr_stmt|;
comment|/* Then copy the environment args */
for|for
control|(
name|p
operator|=
name|env
init|;
name|nargc
operator|>
literal|0
condition|;
name|nargc
operator|--
control|)
block|{
name|p
operator|+=
name|strspn
argument_list|(
name|p
argument_list|,
name|SEPARATOR
argument_list|)
expr_stmt|;
comment|/* skip separators */
operator|*
operator|(
name|nargv
operator|++
operator|)
operator|=
name|p
expr_stmt|;
comment|/* store start */
while|while
condition|(
operator|*
name|p
operator|++
condition|)
empty_stmt|;
comment|/* skip over word */
block|}
comment|/* Finally copy the old args and add a NULL (usual convention) */
while|while
condition|(
name|oargc
operator|--
condition|)
operator|*
operator|(
name|nargv
operator|++
operator|)
operator|=
operator|*
operator|(
name|oargv
operator|++
operator|)
expr_stmt|;
operator|*
name|nargv
operator|=
name|NULL
expr_stmt|;
return|return
name|env
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================  * Error handlers.  */
end_comment

begin_function
name|void
name|error
parameter_list|(
name|m
parameter_list|)
name|char
modifier|*
name|m
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: %s: %s\n"
argument_list|,
name|progname
argument_list|,
name|ifname
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|abort_gzip
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|read_error
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|perror
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unexpected end of file\n"
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
block|}
name|abort_gzip
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_error
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|ofname
argument_list|)
expr_stmt|;
name|abort_gzip
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ========================================================================  * Display compression ratio on the given stream on 6 characters.  */
end_comment

begin_function
name|void
name|display_ratio
parameter_list|(
name|num
parameter_list|,
name|den
parameter_list|,
name|file
parameter_list|)
name|long
name|num
decl_stmt|;
name|long
name|den
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|long
name|ratio
decl_stmt|;
comment|/* 1000 times the compression ratio */
if|if
condition|(
name|den
operator|==
literal|0
condition|)
block|{
name|ratio
operator|=
literal|0
expr_stmt|;
comment|/* no compression */
block|}
elseif|else
if|if
condition|(
name|den
operator|<
literal|2147483L
condition|)
block|{
comment|/* (2**31 -1)/1000 */
name|ratio
operator|=
literal|1000L
operator|*
name|num
operator|/
name|den
expr_stmt|;
block|}
else|else
block|{
name|ratio
operator|=
name|num
operator|/
operator|(
name|den
operator|/
literal|1000L
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|ratio
operator|<
literal|0
condition|)
block|{
name|putc
argument_list|(
literal|'-'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ratio
operator|=
operator|-
name|ratio
expr_stmt|;
block|}
else|else
block|{
name|putc
argument_list|(
literal|' '
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%2ld.%1ld%%"
argument_list|,
name|ratio
operator|/
literal|10L
argument_list|,
name|ratio
operator|%
literal|10L
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ========================================================================  * Semi-safe malloc -- never returns NULL.  */
end_comment

begin_function
name|voidp
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
block|{
name|voidp
name|cp
init|=
operator|(
name|voidp
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|cp
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================  * Table of CRC-32's of all single-byte values (made by makecrc.c)  */
end_comment

begin_decl_stmt
name|ulg
name|crc_32_tab
index|[]
init|=
block|{
literal|0x00000000L
block|,
literal|0x77073096L
block|,
literal|0xee0e612cL
block|,
literal|0x990951baL
block|,
literal|0x076dc419L
block|,
literal|0x706af48fL
block|,
literal|0xe963a535L
block|,
literal|0x9e6495a3L
block|,
literal|0x0edb8832L
block|,
literal|0x79dcb8a4L
block|,
literal|0xe0d5e91eL
block|,
literal|0x97d2d988L
block|,
literal|0x09b64c2bL
block|,
literal|0x7eb17cbdL
block|,
literal|0xe7b82d07L
block|,
literal|0x90bf1d91L
block|,
literal|0x1db71064L
block|,
literal|0x6ab020f2L
block|,
literal|0xf3b97148L
block|,
literal|0x84be41deL
block|,
literal|0x1adad47dL
block|,
literal|0x6ddde4ebL
block|,
literal|0xf4d4b551L
block|,
literal|0x83d385c7L
block|,
literal|0x136c9856L
block|,
literal|0x646ba8c0L
block|,
literal|0xfd62f97aL
block|,
literal|0x8a65c9ecL
block|,
literal|0x14015c4fL
block|,
literal|0x63066cd9L
block|,
literal|0xfa0f3d63L
block|,
literal|0x8d080df5L
block|,
literal|0x3b6e20c8L
block|,
literal|0x4c69105eL
block|,
literal|0xd56041e4L
block|,
literal|0xa2677172L
block|,
literal|0x3c03e4d1L
block|,
literal|0x4b04d447L
block|,
literal|0xd20d85fdL
block|,
literal|0xa50ab56bL
block|,
literal|0x35b5a8faL
block|,
literal|0x42b2986cL
block|,
literal|0xdbbbc9d6L
block|,
literal|0xacbcf940L
block|,
literal|0x32d86ce3L
block|,
literal|0x45df5c75L
block|,
literal|0xdcd60dcfL
block|,
literal|0xabd13d59L
block|,
literal|0x26d930acL
block|,
literal|0x51de003aL
block|,
literal|0xc8d75180L
block|,
literal|0xbfd06116L
block|,
literal|0x21b4f4b5L
block|,
literal|0x56b3c423L
block|,
literal|0xcfba9599L
block|,
literal|0xb8bda50fL
block|,
literal|0x2802b89eL
block|,
literal|0x5f058808L
block|,
literal|0xc60cd9b2L
block|,
literal|0xb10be924L
block|,
literal|0x2f6f7c87L
block|,
literal|0x58684c11L
block|,
literal|0xc1611dabL
block|,
literal|0xb6662d3dL
block|,
literal|0x76dc4190L
block|,
literal|0x01db7106L
block|,
literal|0x98d220bcL
block|,
literal|0xefd5102aL
block|,
literal|0x71b18589L
block|,
literal|0x06b6b51fL
block|,
literal|0x9fbfe4a5L
block|,
literal|0xe8b8d433L
block|,
literal|0x7807c9a2L
block|,
literal|0x0f00f934L
block|,
literal|0x9609a88eL
block|,
literal|0xe10e9818L
block|,
literal|0x7f6a0dbbL
block|,
literal|0x086d3d2dL
block|,
literal|0x91646c97L
block|,
literal|0xe6635c01L
block|,
literal|0x6b6b51f4L
block|,
literal|0x1c6c6162L
block|,
literal|0x856530d8L
block|,
literal|0xf262004eL
block|,
literal|0x6c0695edL
block|,
literal|0x1b01a57bL
block|,
literal|0x8208f4c1L
block|,
literal|0xf50fc457L
block|,
literal|0x65b0d9c6L
block|,
literal|0x12b7e950L
block|,
literal|0x8bbeb8eaL
block|,
literal|0xfcb9887cL
block|,
literal|0x62dd1ddfL
block|,
literal|0x15da2d49L
block|,
literal|0x8cd37cf3L
block|,
literal|0xfbd44c65L
block|,
literal|0x4db26158L
block|,
literal|0x3ab551ceL
block|,
literal|0xa3bc0074L
block|,
literal|0xd4bb30e2L
block|,
literal|0x4adfa541L
block|,
literal|0x3dd895d7L
block|,
literal|0xa4d1c46dL
block|,
literal|0xd3d6f4fbL
block|,
literal|0x4369e96aL
block|,
literal|0x346ed9fcL
block|,
literal|0xad678846L
block|,
literal|0xda60b8d0L
block|,
literal|0x44042d73L
block|,
literal|0x33031de5L
block|,
literal|0xaa0a4c5fL
block|,
literal|0xdd0d7cc9L
block|,
literal|0x5005713cL
block|,
literal|0x270241aaL
block|,
literal|0xbe0b1010L
block|,
literal|0xc90c2086L
block|,
literal|0x5768b525L
block|,
literal|0x206f85b3L
block|,
literal|0xb966d409L
block|,
literal|0xce61e49fL
block|,
literal|0x5edef90eL
block|,
literal|0x29d9c998L
block|,
literal|0xb0d09822L
block|,
literal|0xc7d7a8b4L
block|,
literal|0x59b33d17L
block|,
literal|0x2eb40d81L
block|,
literal|0xb7bd5c3bL
block|,
literal|0xc0ba6cadL
block|,
literal|0xedb88320L
block|,
literal|0x9abfb3b6L
block|,
literal|0x03b6e20cL
block|,
literal|0x74b1d29aL
block|,
literal|0xead54739L
block|,
literal|0x9dd277afL
block|,
literal|0x04db2615L
block|,
literal|0x73dc1683L
block|,
literal|0xe3630b12L
block|,
literal|0x94643b84L
block|,
literal|0x0d6d6a3eL
block|,
literal|0x7a6a5aa8L
block|,
literal|0xe40ecf0bL
block|,
literal|0x9309ff9dL
block|,
literal|0x0a00ae27L
block|,
literal|0x7d079eb1L
block|,
literal|0xf00f9344L
block|,
literal|0x8708a3d2L
block|,
literal|0x1e01f268L
block|,
literal|0x6906c2feL
block|,
literal|0xf762575dL
block|,
literal|0x806567cbL
block|,
literal|0x196c3671L
block|,
literal|0x6e6b06e7L
block|,
literal|0xfed41b76L
block|,
literal|0x89d32be0L
block|,
literal|0x10da7a5aL
block|,
literal|0x67dd4accL
block|,
literal|0xf9b9df6fL
block|,
literal|0x8ebeeff9L
block|,
literal|0x17b7be43L
block|,
literal|0x60b08ed5L
block|,
literal|0xd6d6a3e8L
block|,
literal|0xa1d1937eL
block|,
literal|0x38d8c2c4L
block|,
literal|0x4fdff252L
block|,
literal|0xd1bb67f1L
block|,
literal|0xa6bc5767L
block|,
literal|0x3fb506ddL
block|,
literal|0x48b2364bL
block|,
literal|0xd80d2bdaL
block|,
literal|0xaf0a1b4cL
block|,
literal|0x36034af6L
block|,
literal|0x41047a60L
block|,
literal|0xdf60efc3L
block|,
literal|0xa867df55L
block|,
literal|0x316e8eefL
block|,
literal|0x4669be79L
block|,
literal|0xcb61b38cL
block|,
literal|0xbc66831aL
block|,
literal|0x256fd2a0L
block|,
literal|0x5268e236L
block|,
literal|0xcc0c7795L
block|,
literal|0xbb0b4703L
block|,
literal|0x220216b9L
block|,
literal|0x5505262fL
block|,
literal|0xc5ba3bbeL
block|,
literal|0xb2bd0b28L
block|,
literal|0x2bb45a92L
block|,
literal|0x5cb36a04L
block|,
literal|0xc2d7ffa7L
block|,
literal|0xb5d0cf31L
block|,
literal|0x2cd99e8bL
block|,
literal|0x5bdeae1dL
block|,
literal|0x9b64c2b0L
block|,
literal|0xec63f226L
block|,
literal|0x756aa39cL
block|,
literal|0x026d930aL
block|,
literal|0x9c0906a9L
block|,
literal|0xeb0e363fL
block|,
literal|0x72076785L
block|,
literal|0x05005713L
block|,
literal|0x95bf4a82L
block|,
literal|0xe2b87a14L
block|,
literal|0x7bb12baeL
block|,
literal|0x0cb61b38L
block|,
literal|0x92d28e9bL
block|,
literal|0xe5d5be0dL
block|,
literal|0x7cdcefb7L
block|,
literal|0x0bdbdf21L
block|,
literal|0x86d3d2d4L
block|,
literal|0xf1d4e242L
block|,
literal|0x68ddb3f8L
block|,
literal|0x1fda836eL
block|,
literal|0x81be16cdL
block|,
literal|0xf6b9265bL
block|,
literal|0x6fb077e1L
block|,
literal|0x18b74777L
block|,
literal|0x88085ae6L
block|,
literal|0xff0f6a70L
block|,
literal|0x66063bcaL
block|,
literal|0x11010b5cL
block|,
literal|0x8f659effL
block|,
literal|0xf862ae69L
block|,
literal|0x616bffd3L
block|,
literal|0x166ccf45L
block|,
literal|0xa00ae278L
block|,
literal|0xd70dd2eeL
block|,
literal|0x4e048354L
block|,
literal|0x3903b3c2L
block|,
literal|0xa7672661L
block|,
literal|0xd06016f7L
block|,
literal|0x4969474dL
block|,
literal|0x3e6e77dbL
block|,
literal|0xaed16a4aL
block|,
literal|0xd9d65adcL
block|,
literal|0x40df0b66L
block|,
literal|0x37d83bf0L
block|,
literal|0xa9bcae53L
block|,
literal|0xdebb9ec5L
block|,
literal|0x47b2cf7fL
block|,
literal|0x30b5ffe9L
block|,
literal|0xbdbdf21cL
block|,
literal|0xcabac28aL
block|,
literal|0x53b39330L
block|,
literal|0x24b4a3a6L
block|,
literal|0xbad03605L
block|,
literal|0xcdd70693L
block|,
literal|0x54de5729L
block|,
literal|0x23d967bfL
block|,
literal|0xb3667a2eL
block|,
literal|0xc4614ab8L
block|,
literal|0x5d681b02L
block|,
literal|0x2a6f2b94L
block|,
literal|0xb40bbe37L
block|,
literal|0xc30c8ea1L
block|,
literal|0x5a05df1bL
block|,
literal|0x2d02ef8dL
block|}
decl_stmt|;
end_decl_stmt

end_unit

