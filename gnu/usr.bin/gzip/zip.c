begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* zip.c -- compress files to the gzip or pkzip format  * Copyright (C) 1992-1993 Jean-loup Gailly  * This is free software; you can redistribute it and/or modify it under the  * terms of the GNU General Public License, see the file COPYING.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_include
include|#
directive|include
file|"gzip.h"
end_include

begin_include
include|#
directive|include
file|"crypt.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_FCNTL_H
end_ifndef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|local
name|ulg
name|crc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* crc on uncompressed file data */
end_comment

begin_decl_stmt
name|long
name|header_bytes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of bytes in gzip header */
end_comment

begin_comment
comment|/* ===========================================================================  * Deflate in to out.  * IN assertions: the input and output buffers are cleared.  *   The variables time_stamp and save_orig_name are initialized.  */
end_comment

begin_function
name|int
name|zip
parameter_list|(
name|in
parameter_list|,
name|out
parameter_list|)
name|int
name|in
decl_stmt|,
name|out
decl_stmt|;
comment|/* input and output file descriptors */
block|{
name|uch
name|flags
init|=
literal|0
decl_stmt|;
comment|/* general purpose bit flags */
name|ush
name|attr
init|=
literal|0
decl_stmt|;
comment|/* ascii/binary flag */
name|ush
name|deflate_flags
init|=
literal|0
decl_stmt|;
comment|/* pkzip -es, -en or -ex equivalent */
name|ifd
operator|=
name|in
expr_stmt|;
name|ofd
operator|=
name|out
expr_stmt|;
name|outcnt
operator|=
literal|0
expr_stmt|;
comment|/* Write the header to the gzip file. See algorithm.doc for the format */
name|method
operator|=
name|DEFLATED
expr_stmt|;
name|put_byte
argument_list|(
name|GZIP_MAGIC
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* magic header */
name|put_byte
argument_list|(
name|GZIP_MAGIC
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|DEFLATED
argument_list|)
expr_stmt|;
comment|/* compression method */
if|if
condition|(
name|save_orig_name
condition|)
block|{
name|flags
operator||=
name|ORIG_NAME
expr_stmt|;
block|}
name|put_byte
argument_list|(
name|flags
argument_list|)
expr_stmt|;
comment|/* general flags */
name|put_long
argument_list|(
name|time_stamp
argument_list|)
expr_stmt|;
comment|/* Write deflated file to zip file */
name|crc
operator|=
name|updcrc
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bi_init
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|ct_init
argument_list|(
operator|&
name|attr
argument_list|,
operator|&
name|method
argument_list|)
expr_stmt|;
name|lm_init
argument_list|(
name|level
argument_list|,
operator|&
name|deflate_flags
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
operator|(
name|uch
operator|)
name|deflate_flags
argument_list|)
expr_stmt|;
comment|/* extra flags */
name|put_byte
argument_list|(
name|OS_CODE
argument_list|)
expr_stmt|;
comment|/* OS identifier */
if|if
condition|(
name|save_orig_name
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|basename
argument_list|(
name|ifname
argument_list|)
decl_stmt|;
comment|/* Don't save the directory part. */
do|do
block|{
name|put_char
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p
operator|++
condition|)
do|;
block|}
name|header_bytes
operator|=
operator|(
name|long
operator|)
name|outcnt
expr_stmt|;
operator|(
name|void
operator|)
name|deflate
argument_list|()
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_SIZE_CHECK
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|RECORD_IO
argument_list|)
comment|/* Check input size (but not in VMS -- variable record lengths mess it up)    * and not on MSDOS -- diet in TSR mode reports an incorrect file size)    */
if|if
condition|(
name|ifile_size
operator|!=
operator|-
literal|1L
operator|&&
name|isize
operator|!=
operator|(
name|ulg
operator|)
name|ifile_size
condition|)
block|{
name|Trace
argument_list|(
operator|(
name|stderr
operator|,
literal|" actual=%ld, read=%ld "
operator|,
name|ifile_size
operator|,
name|isize
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: file size changed while zipping\n"
argument_list|,
name|progname
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Write the crc and uncompressed size */
name|put_long
argument_list|(
name|crc
argument_list|)
expr_stmt|;
name|put_long
argument_list|(
name|isize
argument_list|)
expr_stmt|;
name|header_bytes
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|flush_outbuf
argument_list|()
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Read a new buffer from the current input file, perform end-of-line  * translation, and update the crc and input file size.  * IN assertion: size>= 2 (for end-of-line translation)  */
end_comment

begin_function
name|int
name|file_read
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|{
name|unsigned
name|len
decl_stmt|;
name|Assert
argument_list|(
name|insize
operator|==
literal|0
argument_list|,
literal|"inbuf not empty"
argument_list|)
expr_stmt|;
name|len
operator|=
name|read
argument_list|(
name|ifd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
call|(
name|unsigned
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|||
name|len
operator|==
literal|0
condition|)
return|return
operator|(
name|int
operator|)
name|len
return|;
name|crc
operator|=
name|updcrc
argument_list|(
operator|(
name|uch
operator|*
operator|)
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|isize
operator|+=
operator|(
name|ulg
operator|)
name|len
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|len
return|;
block|}
end_function

end_unit

