begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* unlzw.c -- decompress files in LZW format.  * The code in this file is directly derived from the public domain 'compress'  * written by Spencer Thomas, Joe Orost, James Woods, Jim McKie, Steve Davies,  * Ken Turkowski, Dave Mack and Peter Jannesen.  *  * This is a temporary version which will be rewritten in some future version  * to accommodate in-memory decompression.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_FCNTL_H
end_ifndef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gzip.h"
end_include

begin_include
include|#
directive|include
file|"lzw.h"
end_include

begin_typedef
typedef|typedef
name|unsigned
name|char
name|char_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|long
name|code_int
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|count_int
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|short
name|count_short
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|cmp_code_int
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MAXCODE
parameter_list|(
name|n
parameter_list|)
value|(1L<< (n))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|REGISTERS
end_ifndef

begin_define
define|#
directive|define
name|REGISTERS
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|REG1
end_define

begin_define
define|#
directive|define
name|REG2
end_define

begin_define
define|#
directive|define
name|REG3
end_define

begin_define
define|#
directive|define
name|REG4
end_define

begin_define
define|#
directive|define
name|REG5
end_define

begin_define
define|#
directive|define
name|REG6
end_define

begin_define
define|#
directive|define
name|REG7
end_define

begin_define
define|#
directive|define
name|REG8
end_define

begin_define
define|#
directive|define
name|REG9
end_define

begin_define
define|#
directive|define
name|REG10
end_define

begin_define
define|#
directive|define
name|REG11
end_define

begin_define
define|#
directive|define
name|REG12
end_define

begin_define
define|#
directive|define
name|REG13
end_define

begin_define
define|#
directive|define
name|REG14
end_define

begin_define
define|#
directive|define
name|REG15
end_define

begin_define
define|#
directive|define
name|REG16
end_define

begin_if
if|#
directive|if
name|REGISTERS
operator|>=
literal|1
end_if

begin_undef
undef|#
directive|undef
name|REG1
end_undef

begin_define
define|#
directive|define
name|REG1
value|register
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|REGISTERS
operator|>=
literal|2
end_if

begin_undef
undef|#
directive|undef
name|REG2
end_undef

begin_define
define|#
directive|define
name|REG2
value|register
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|REGISTERS
operator|>=
literal|3
end_if

begin_undef
undef|#
directive|undef
name|REG3
end_undef

begin_define
define|#
directive|define
name|REG3
value|register
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|REGISTERS
operator|>=
literal|4
end_if

begin_undef
undef|#
directive|undef
name|REG4
end_undef

begin_define
define|#
directive|define
name|REG4
value|register
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|REGISTERS
operator|>=
literal|5
end_if

begin_undef
undef|#
directive|undef
name|REG5
end_undef

begin_define
define|#
directive|define
name|REG5
value|register
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|REGISTERS
operator|>=
literal|6
end_if

begin_undef
undef|#
directive|undef
name|REG6
end_undef

begin_define
define|#
directive|define
name|REG6
value|register
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|REGISTERS
operator|>=
literal|7
end_if

begin_undef
undef|#
directive|undef
name|REG7
end_undef

begin_define
define|#
directive|define
name|REG7
value|register
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|REGISTERS
operator|>=
literal|8
end_if

begin_undef
undef|#
directive|undef
name|REG8
end_undef

begin_define
define|#
directive|define
name|REG8
value|register
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|REGISTERS
operator|>=
literal|9
end_if

begin_undef
undef|#
directive|undef
name|REG9
end_undef

begin_define
define|#
directive|define
name|REG9
value|register
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|REGISTERS
operator|>=
literal|10
end_if

begin_undef
undef|#
directive|undef
name|REG10
end_undef

begin_define
define|#
directive|define
name|REG10
value|register
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|REGISTERS
operator|>=
literal|11
end_if

begin_undef
undef|#
directive|undef
name|REG11
end_undef

begin_define
define|#
directive|define
name|REG11
value|register
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|REGISTERS
operator|>=
literal|12
end_if

begin_undef
undef|#
directive|undef
name|REG12
end_undef

begin_define
define|#
directive|define
name|REG12
value|register
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|REGISTERS
operator|>=
literal|13
end_if

begin_undef
undef|#
directive|undef
name|REG13
end_undef

begin_define
define|#
directive|define
name|REG13
value|register
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|REGISTERS
operator|>=
literal|14
end_if

begin_undef
undef|#
directive|undef
name|REG14
end_undef

begin_define
define|#
directive|define
name|REG14
value|register
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|REGISTERS
operator|>=
literal|15
end_if

begin_undef
undef|#
directive|undef
name|REG15
end_undef

begin_define
define|#
directive|define
name|REG15
value|register
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|REGISTERS
operator|>=
literal|16
end_if

begin_undef
undef|#
directive|undef
name|REG16
end_undef

begin_define
define|#
directive|define
name|REG16
value|register
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BYTEORDER
end_ifndef

begin_define
define|#
directive|define
name|BYTEORDER
value|0000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NOALLIGN
end_ifndef

begin_define
define|#
directive|define
name|NOALLIGN
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_union
union|union
name|bytes
block|{
name|long
name|word
decl_stmt|;
struct|struct
block|{
if|#
directive|if
name|BYTEORDER
operator|==
literal|4321
name|char_type
name|b1
decl_stmt|;
name|char_type
name|b2
decl_stmt|;
name|char_type
name|b3
decl_stmt|;
name|char_type
name|b4
decl_stmt|;
else|#
directive|else
if|#
directive|if
name|BYTEORDER
operator|==
literal|1234
name|char_type
name|b4
decl_stmt|;
name|char_type
name|b3
decl_stmt|;
name|char_type
name|b2
decl_stmt|;
name|char_type
name|b1
decl_stmt|;
else|#
directive|else
undef|#
directive|undef
name|BYTEORDER
name|int
name|dummy
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
name|bytes
struct|;
block|}
union|;
end_union

begin_if
if|#
directive|if
name|BYTEORDER
operator|==
literal|4321
operator|&&
name|NOALLIGN
operator|==
literal|1
end_if

begin_define
define|#
directive|define
name|input
parameter_list|(
name|b
parameter_list|,
name|o
parameter_list|,
name|c
parameter_list|,
name|n
parameter_list|,
name|m
parameter_list|)
value|{ \      (c) = (*(long *)(&(b)[(o)>>3])>>((o)&0x7))&(m); \      (o) += (n); \    }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|input
parameter_list|(
name|b
parameter_list|,
name|o
parameter_list|,
name|c
parameter_list|,
name|n
parameter_list|,
name|m
parameter_list|)
value|{ \      REG1 char_type *p =&(b)[(o)>>3]; \      (c) = ((((long)(p[0]))|((long)(p[1])<<8)| \      ((long)(p[2])<<16))>>((o)&0x7))&(m); \      (o) += (n); \    }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAXSEG_64K
end_ifndef

begin_comment
comment|/* DECLARE(ush, tab_prefix, (1<<BITS)); -- prefix code */
end_comment

begin_define
define|#
directive|define
name|tab_prefixof
parameter_list|(
name|i
parameter_list|)
value|tab_prefix[i]
end_define

begin_define
define|#
directive|define
name|clear_tab_prefixof
parameter_list|()
value|memzero(tab_prefix, 256);
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* DECLARE(ush, tab_prefix0, (1<<(BITS-1)); -- prefix for even codes */
end_comment

begin_comment
comment|/* DECLARE(ush, tab_prefix1, (1<<(BITS-1)); -- prefix for odd  codes */
end_comment

begin_decl_stmt
name|ush
modifier|*
name|tab_prefix
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|tab_prefixof
parameter_list|(
name|i
parameter_list|)
value|tab_prefix[(i)&1][(i)>>1]
end_define

begin_define
define|#
directive|define
name|clear_tab_prefixof
parameter_list|()
define|\
value|memzero(tab_prefix0, 128), \       memzero(tab_prefix1, 128);
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|de_stack
value|((char_type *)(&d_buf[DIST_BUFSIZE-1]))
end_define

begin_define
define|#
directive|define
name|tab_suffixof
parameter_list|(
name|i
parameter_list|)
value|tab_suffix[i]
end_define

begin_decl_stmt
name|int
name|block_mode
init|=
name|BLOCK_MODE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* block compress mode -C compatible with 2.0 */
end_comment

begin_comment
comment|/* ============================================================================  * Decompress in to out.  This routine adapts to the codes in the  * file building the "string" table on-the-fly; requiring no table to  * be stored in the compressed file.  * IN assertions: the buffer inbuf contains already the beginning of  *   the compressed data, from offsets iptr to insize-1 included.  *   The magic header has already been checked and skipped.  *   bytes_in and bytes_out have been initialized.  */
end_comment

begin_function
name|int
name|unlzw
parameter_list|(
name|in
parameter_list|,
name|out
parameter_list|)
name|int
name|in
decl_stmt|,
name|out
decl_stmt|;
comment|/* input and output file descriptors */
block|{
name|REG2
name|char_type
modifier|*
name|stackp
decl_stmt|;
name|REG3
name|code_int
name|code
decl_stmt|;
name|REG4
name|int
name|finchar
decl_stmt|;
name|REG5
name|code_int
name|oldcode
decl_stmt|;
name|REG6
name|code_int
name|incode
decl_stmt|;
name|REG7
name|long
name|inbits
decl_stmt|;
name|REG8
name|long
name|posbits
decl_stmt|;
name|REG9
name|int
name|outpos
decl_stmt|;
comment|/*  REG10  int        insize; (global) */
name|REG11
name|unsigned
name|bitmask
decl_stmt|;
name|REG12
name|code_int
name|free_ent
decl_stmt|;
name|REG13
name|code_int
name|maxcode
decl_stmt|;
name|REG14
name|code_int
name|maxmaxcode
decl_stmt|;
name|REG15
name|int
name|n_bits
decl_stmt|;
name|REG16
name|int
name|rsize
decl_stmt|;
ifdef|#
directive|ifdef
name|MAXSEG_64K
name|tab_prefix
index|[
literal|0
index|]
operator|=
name|tab_prefix0
expr_stmt|;
name|tab_prefix
index|[
literal|1
index|]
operator|=
name|tab_prefix1
expr_stmt|;
endif|#
directive|endif
name|maxbits
operator|=
name|get_byte
argument_list|()
expr_stmt|;
name|block_mode
operator|=
name|maxbits
operator|&
name|BLOCK_MODE
expr_stmt|;
if|if
condition|(
operator|(
name|maxbits
operator|&
name|LZW_RESERVED
operator|)
operator|!=
literal|0
condition|)
block|{
name|WARN
argument_list|(
operator|(
name|stderr
operator|,
literal|"\n%s: %s: warning, unknown flags 0x%x\n"
operator|,
name|progname
operator|,
name|ifname
operator|,
name|maxbits
operator|&
name|LZW_RESERVED
operator|)
argument_list|)
expr_stmt|;
block|}
name|maxbits
operator|&=
name|BIT_MASK
expr_stmt|;
name|maxmaxcode
operator|=
name|MAXCODE
argument_list|(
name|maxbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxbits
operator|>
name|BITS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n%s: %s: compressed with %d bits, can only handle %d bits\n"
argument_list|,
name|progname
argument_list|,
name|ifname
argument_list|,
name|maxbits
argument_list|,
name|BITS
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|ERROR
expr_stmt|;
return|return
name|ERROR
return|;
block|}
name|rsize
operator|=
name|insize
expr_stmt|;
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
operator|=
name|INIT_BITS
argument_list|)
operator|-
literal|1
expr_stmt|;
name|bitmask
operator|=
operator|(
literal|1
operator|<<
name|n_bits
operator|)
operator|-
literal|1
expr_stmt|;
name|oldcode
operator|=
operator|-
literal|1
expr_stmt|;
name|finchar
operator|=
literal|0
expr_stmt|;
name|outpos
operator|=
literal|0
expr_stmt|;
name|posbits
operator|=
name|inptr
operator|<<
literal|3
expr_stmt|;
name|free_ent
operator|=
operator|(
operator|(
name|block_mode
operator|)
condition|?
name|FIRST
else|:
literal|256
operator|)
expr_stmt|;
name|clear_tab_prefixof
argument_list|()
expr_stmt|;
comment|/* Initialize the first 256 entries in the table. */
for|for
control|(
name|code
operator|=
literal|255
init|;
name|code
operator|>=
literal|0
condition|;
operator|--
name|code
control|)
block|{
name|tab_suffixof
argument_list|(
name|code
argument_list|)
operator|=
operator|(
name|char_type
operator|)
name|code
expr_stmt|;
block|}
do|do
block|{
name|REG1
name|int
name|i
decl_stmt|;
name|int
name|e
decl_stmt|;
name|int
name|o
decl_stmt|;
name|resetbuf
label|:
name|e
operator|=
name|insize
operator|-
operator|(
name|o
operator|=
operator|(
name|posbits
operator|>>
literal|3
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|e
condition|;
operator|++
name|i
control|)
block|{
name|inbuf
index|[
name|i
index|]
operator|=
name|inbuf
index|[
name|i
operator|+
name|o
index|]
expr_stmt|;
block|}
name|insize
operator|=
name|e
expr_stmt|;
name|posbits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|insize
operator|<
name|INBUF_EXTRA
condition|)
block|{
if|if
condition|(
operator|(
name|rsize
operator|=
name|read
argument_list|(
name|in
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inbuf
operator|+
name|insize
argument_list|,
name|INBUFSIZ
argument_list|)
operator|)
operator|==
name|EOF
condition|)
block|{
name|read_error
argument_list|()
expr_stmt|;
block|}
name|insize
operator|+=
name|rsize
expr_stmt|;
name|bytes_in
operator|+=
operator|(
name|ulg
operator|)
name|rsize
expr_stmt|;
block|}
name|inbits
operator|=
operator|(
operator|(
name|rsize
operator|!=
literal|0
operator|)
condition|?
operator|(
operator|(
name|long
operator|)
name|insize
operator|-
name|insize
operator|%
name|n_bits
operator|)
operator|<<
literal|3
else|:
operator|(
operator|(
name|long
operator|)
name|insize
operator|<<
literal|3
operator|)
operator|-
operator|(
name|n_bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
while|while
condition|(
name|inbits
operator|>
name|posbits
condition|)
block|{
if|if
condition|(
name|free_ent
operator|>
name|maxcode
condition|)
block|{
name|posbits
operator|=
operator|(
operator|(
name|posbits
operator|-
literal|1
operator|)
operator|+
operator|(
operator|(
name|n_bits
operator|<<
literal|3
operator|)
operator|-
operator|(
name|posbits
operator|-
literal|1
operator|+
operator|(
name|n_bits
operator|<<
literal|3
operator|)
operator|)
operator|%
operator|(
name|n_bits
operator|<<
literal|3
operator|)
operator|)
operator|)
expr_stmt|;
operator|++
name|n_bits
expr_stmt|;
if|if
condition|(
name|n_bits
operator|==
name|maxbits
condition|)
block|{
name|maxcode
operator|=
name|maxmaxcode
expr_stmt|;
block|}
else|else
block|{
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|bitmask
operator|=
operator|(
literal|1
operator|<<
name|n_bits
operator|)
operator|-
literal|1
expr_stmt|;
goto|goto
name|resetbuf
goto|;
block|}
name|input
argument_list|(
name|inbuf
argument_list|,
name|posbits
argument_list|,
name|code
argument_list|,
name|n_bits
argument_list|,
name|bitmask
argument_list|)
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"%d "
operator|,
name|code
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldcode
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|code
operator|>=
literal|256
condition|)
name|error
argument_list|(
literal|"corrupt input."
argument_list|)
expr_stmt|;
name|outbuf
index|[
name|outpos
operator|++
index|]
operator|=
call|(
name|char_type
call|)
argument_list|(
name|finchar
operator|=
call|(
name|int
call|)
argument_list|(
name|oldcode
operator|=
name|code
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|code
operator|==
name|CLEAR
operator|&&
name|block_mode
condition|)
block|{
name|clear_tab_prefixof
argument_list|()
expr_stmt|;
name|free_ent
operator|=
name|FIRST
operator|-
literal|1
expr_stmt|;
name|posbits
operator|=
operator|(
operator|(
name|posbits
operator|-
literal|1
operator|)
operator|+
operator|(
operator|(
name|n_bits
operator|<<
literal|3
operator|)
operator|-
operator|(
name|posbits
operator|-
literal|1
operator|+
operator|(
name|n_bits
operator|<<
literal|3
operator|)
operator|)
operator|%
operator|(
name|n_bits
operator|<<
literal|3
operator|)
operator|)
operator|)
expr_stmt|;
name|maxcode
operator|=
name|MAXCODE
argument_list|(
name|n_bits
operator|=
name|INIT_BITS
argument_list|)
operator|-
literal|1
expr_stmt|;
name|bitmask
operator|=
operator|(
literal|1
operator|<<
name|n_bits
operator|)
operator|-
literal|1
expr_stmt|;
goto|goto
name|resetbuf
goto|;
block|}
name|incode
operator|=
name|code
expr_stmt|;
name|stackp
operator|=
name|de_stack
expr_stmt|;
if|if
condition|(
name|code
operator|>=
name|free_ent
condition|)
block|{
comment|/* Special case for KwKwK string. */
if|if
condition|(
name|code
operator|>
name|free_ent
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|char_type
modifier|*
name|p
decl_stmt|;
name|posbits
operator|-=
name|n_bits
expr_stmt|;
name|p
operator|=
operator|&
name|inbuf
index|[
name|posbits
operator|>>
literal|3
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"code:%ld free_ent:%ld n_bits:%d insize:%u\n"
argument_list|,
name|code
argument_list|,
name|free_ent
argument_list|,
name|n_bits
argument_list|,
name|insize
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"posbits:%ld inbuf:%02X %02X %02X %02X %02X\n"
argument_list|,
name|posbits
argument_list|,
name|p
index|[
operator|-
literal|1
index|]
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|test
operator|&&
name|outpos
operator|>
literal|0
condition|)
block|{
name|write_buf
argument_list|(
name|out
argument_list|,
operator|(
name|char
operator|*
operator|)
name|outbuf
argument_list|,
name|outpos
argument_list|)
expr_stmt|;
name|bytes_out
operator|+=
operator|(
name|ulg
operator|)
name|outpos
expr_stmt|;
block|}
name|error
argument_list|(
name|to_stdout
condition|?
literal|"corrupt input."
else|:
literal|"corrupt input. Use zcat to recover some data."
argument_list|)
expr_stmt|;
block|}
operator|*
operator|--
name|stackp
operator|=
operator|(
name|char_type
operator|)
name|finchar
expr_stmt|;
name|code
operator|=
name|oldcode
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|cmp_code_int
operator|)
name|code
operator|>=
operator|(
name|cmp_code_int
operator|)
literal|256
condition|)
block|{
comment|/* Generate output characters in reverse order */
operator|*
operator|--
name|stackp
operator|=
name|tab_suffixof
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|code
operator|=
name|tab_prefixof
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
operator|*
operator|--
name|stackp
operator|=
call|(
name|char_type
call|)
argument_list|(
name|finchar
operator|=
name|tab_suffixof
argument_list|(
name|code
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And put them out in forward order */
block|{
name|REG1
name|int
name|i
decl_stmt|;
if|if
condition|(
name|outpos
operator|+
operator|(
name|i
operator|=
operator|(
name|de_stack
operator|-
name|stackp
operator|)
operator|)
operator|>=
name|OUTBUFSIZ
condition|)
block|{
do|do
block|{
if|if
condition|(
name|i
operator|>
name|OUTBUFSIZ
operator|-
name|outpos
condition|)
name|i
operator|=
name|OUTBUFSIZ
operator|-
name|outpos
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|outbuf
operator|+
name|outpos
argument_list|,
name|stackp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|outpos
operator|+=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|outpos
operator|>=
name|OUTBUFSIZ
condition|)
block|{
if|if
condition|(
operator|!
name|test
condition|)
block|{
name|write_buf
argument_list|(
name|out
argument_list|,
operator|(
name|char
operator|*
operator|)
name|outbuf
argument_list|,
name|outpos
argument_list|)
expr_stmt|;
name|bytes_out
operator|+=
operator|(
name|ulg
operator|)
name|outpos
expr_stmt|;
block|}
name|outpos
operator|=
literal|0
expr_stmt|;
block|}
name|stackp
operator|+=
name|i
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|i
operator|=
operator|(
name|de_stack
operator|-
name|stackp
operator|)
operator|)
operator|>
literal|0
condition|)
do|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|outbuf
operator|+
name|outpos
argument_list|,
name|stackp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|outpos
operator|+=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|code
operator|=
name|free_ent
operator|)
operator|<
name|maxmaxcode
condition|)
block|{
comment|/* Generate the new entry. */
name|tab_prefixof
argument_list|(
name|code
argument_list|)
operator|=
operator|(
name|unsigned
name|short
operator|)
name|oldcode
expr_stmt|;
name|tab_suffixof
argument_list|(
name|code
argument_list|)
operator|=
operator|(
name|char_type
operator|)
name|finchar
expr_stmt|;
name|free_ent
operator|=
name|code
operator|+
literal|1
expr_stmt|;
block|}
name|oldcode
operator|=
name|incode
expr_stmt|;
comment|/* Remember previous code.	*/
block|}
block|}
do|while
condition|(
name|rsize
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
operator|!
name|test
operator|&&
name|outpos
operator|>
literal|0
condition|)
block|{
name|write_buf
argument_list|(
name|out
argument_list|,
operator|(
name|char
operator|*
operator|)
name|outbuf
argument_list|,
name|outpos
argument_list|)
expr_stmt|;
name|bytes_out
operator|+=
operator|(
name|ulg
operator|)
name|outpos
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

end_unit

