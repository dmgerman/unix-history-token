begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* trees.c -- output deflated data using Huffman coding  * Copyright (C) 1992-1993 Jean-loup Gailly  * This is free software; you can redistribute it and/or modify it under the  * terms of the GNU General Public License, see the file COPYING.  */
end_comment

begin_comment
comment|/*  *  PURPOSE  *  *      Encode various sets of source values using variable-length  *      binary code trees.  *  *  DISCUSSION  *  *      The PKZIP "deflation" process uses several Huffman trees. The more  *      common source values are represented by shorter bit sequences.  *  *      Each code tree is stored in the ZIP file in a compressed form  *      which is itself a Huffman encoding of the lengths of  *      all the code strings (in ascending order by source values).  *      The actual code strings are reconstructed from the lengths in  *      the UNZIP process, as described in the "application note"  *      (APPNOTE.TXT) distributed as part of PKWARE's PKZIP program.  *  *  REFERENCES  *  *      Lynch, Thomas J.  *          Data Compression:  Techniques and Applications, pp. 53-55.  *          Lifetime Learning Publications, 1985.  ISBN 0-534-03418-7.  *  *      Storer, James A.  *          Data Compression:  Methods and Theory, pp. 49-50.  *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.  *  *      Sedgewick, R.  *          Algorithms, p290.  *          Addison-Wesley, 1983. ISBN 0-201-06672-6.  *  *  INTERFACE  *  *      void ct_init (ush *attr, int *methodp)  *          Allocate the match buffer, initialize the various tables and save  *          the location of the internal file attribute (ascii/binary) and  *          method (DEFLATE/STORE)  *  *      void ct_tally (int dist, int lc);  *          Save the match info and tally the frequency counts.  *  *      long flush_block (char *buf, ulg stored_len, int eof)  *          Determine the best encoding for the current block: dynamic trees,  *          static trees or store, and output the encoded block to the zip  *          file. Returns the total compressed length for the file so far.  *  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"tailor.h"
end_include

begin_include
include|#
directive|include
file|"gzip.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RCSID
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: trees.c,v 1.4 1995/05/30 05:00:40 rgrimes Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ===========================================================================  * Constants  */
end_comment

begin_define
define|#
directive|define
name|MAX_BITS
value|15
end_define

begin_comment
comment|/* All codes must not exceed MAX_BITS bits */
end_comment

begin_define
define|#
directive|define
name|MAX_BL_BITS
value|7
end_define

begin_comment
comment|/* Bit length codes must not exceed MAX_BL_BITS bits */
end_comment

begin_define
define|#
directive|define
name|LENGTH_CODES
value|29
end_define

begin_comment
comment|/* number of length codes, not counting the special END_BLOCK code */
end_comment

begin_define
define|#
directive|define
name|LITERALS
value|256
end_define

begin_comment
comment|/* number of literal bytes 0..255 */
end_comment

begin_define
define|#
directive|define
name|END_BLOCK
value|256
end_define

begin_comment
comment|/* end of block literal code */
end_comment

begin_define
define|#
directive|define
name|L_CODES
value|(LITERALS+1+LENGTH_CODES)
end_define

begin_comment
comment|/* number of Literal or Length codes, including the END_BLOCK code */
end_comment

begin_define
define|#
directive|define
name|D_CODES
value|30
end_define

begin_comment
comment|/* number of distance codes */
end_comment

begin_define
define|#
directive|define
name|BL_CODES
value|19
end_define

begin_comment
comment|/* number of codes used to transfer the bit lengths */
end_comment

begin_decl_stmt
name|local
name|int
name|near
name|extra_lbits
index|[
name|LENGTH_CODES
index|]
comment|/* extra bits for each length code */
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|near
name|extra_dbits
index|[
name|D_CODES
index|]
comment|/* extra bits for each distance code */
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|8
block|,
literal|8
block|,
literal|9
block|,
literal|9
block|,
literal|10
block|,
literal|10
block|,
literal|11
block|,
literal|11
block|,
literal|12
block|,
literal|12
block|,
literal|13
block|,
literal|13
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|near
name|extra_blbits
index|[
name|BL_CODES
index|]
comment|/* extra bits for each bit length code */
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|3
block|,
literal|7
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|STORED_BLOCK
value|0
end_define

begin_define
define|#
directive|define
name|STATIC_TREES
value|1
end_define

begin_define
define|#
directive|define
name|DYN_TREES
value|2
end_define

begin_comment
comment|/* The three kinds of block type */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LIT_BUFSIZE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|SMALL_MEM
end_ifdef

begin_define
define|#
directive|define
name|LIT_BUFSIZE
value|0x2000
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|MEDIUM_MEM
end_ifdef

begin_define
define|#
directive|define
name|LIT_BUFSIZE
value|0x4000
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LIT_BUFSIZE
value|0x8000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DIST_BUFSIZE
end_ifndef

begin_define
define|#
directive|define
name|DIST_BUFSIZE
value|LIT_BUFSIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Sizes of match buffers for literals/lengths and distances.  There are  * 4 reasons for limiting LIT_BUFSIZE to 64K:  *   - frequencies can be kept in 16 bit counters  *   - if compression is not successful for the first block, all input data is  *     still in the window so we can still emit a stored block even when input  *     comes from standard input.  (This can also be done for all blocks if  *     LIT_BUFSIZE is not greater than 32K.)  *   - if compression is not successful for a file smaller than 64K, we can  *     even emit a stored file instead of a stored block (saving 5 bytes).  *   - creating new Huffman trees less frequently may not provide fast  *     adaptation to changes in the input data statistics. (Take for  *     example a binary file with poorly compressible code followed by  *     a highly compressible string table.) Smaller buffer sizes give  *     fast adaptation but have of course the overhead of transmitting trees  *     more frequently.  *   - I can't count above 4  * The current code is general and allows DIST_BUFSIZE< LIT_BUFSIZE (to save  * memory at the expense of compression). Some optimizations would be possible  * if we rely on DIST_BUFSIZE == LIT_BUFSIZE.  */
end_comment

begin_if
if|#
directive|if
name|LIT_BUFSIZE
operator|>
name|INBUFSIZ
end_if

begin_expr_stmt
name|error
name|cannot
name|overlay
name|l_buf
name|and
name|inbuf
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|REP_3_6
value|16
end_define

begin_comment
comment|/* repeat previous bit length 3-6 times (2 bits of repeat count) */
end_comment

begin_define
define|#
directive|define
name|REPZ_3_10
value|17
end_define

begin_comment
comment|/* repeat a zero length 3-10 times  (3 bits of repeat count) */
end_comment

begin_define
define|#
directive|define
name|REPZ_11_138
value|18
end_define

begin_comment
comment|/* repeat a zero length 11-138 times  (7 bits of repeat count) */
end_comment

begin_comment
comment|/* ===========================================================================  * Local data  */
end_comment

begin_comment
comment|/* Data structure describing a single value and its code string. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ct_data
block|{
union|union
block|{
name|ush
name|freq
decl_stmt|;
comment|/* frequency count */
name|ush
name|code
decl_stmt|;
comment|/* bit string */
block|}
name|fc
union|;
union|union
block|{
name|ush
name|dad
decl_stmt|;
comment|/* father node in Huffman tree */
name|ush
name|len
decl_stmt|;
comment|/* length of bit string */
block|}
name|dl
union|;
block|}
name|ct_data
typedef|;
end_typedef

begin_define
define|#
directive|define
name|Freq
value|fc.freq
end_define

begin_define
define|#
directive|define
name|Code
value|fc.code
end_define

begin_define
define|#
directive|define
name|Dad
value|dl.dad
end_define

begin_define
define|#
directive|define
name|Len
value|dl.len
end_define

begin_define
define|#
directive|define
name|HEAP_SIZE
value|(2*L_CODES+1)
end_define

begin_comment
comment|/* maximum heap size */
end_comment

begin_decl_stmt
name|local
name|ct_data
name|near
name|dyn_ltree
index|[
name|HEAP_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* literal and length tree */
end_comment

begin_decl_stmt
name|local
name|ct_data
name|near
name|dyn_dtree
index|[
literal|2
operator|*
name|D_CODES
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* distance tree */
end_comment

begin_decl_stmt
name|local
name|ct_data
name|near
name|static_ltree
index|[
name|L_CODES
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The static literal tree. Since the bit lengths are imposed, there is no  * need for the L_CODES extra codes used during heap construction. However  * The codes 286 and 287 are needed to build a canonical tree (see ct_init  * below).  */
end_comment

begin_decl_stmt
name|local
name|ct_data
name|near
name|static_dtree
index|[
name|D_CODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The static distance tree. (Actually a trivial tree since all codes use  * 5 bits.)  */
end_comment

begin_decl_stmt
name|local
name|ct_data
name|near
name|bl_tree
index|[
literal|2
operator|*
name|BL_CODES
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Huffman tree for the bit lengths */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|tree_desc
block|{
name|ct_data
name|near
modifier|*
name|dyn_tree
decl_stmt|;
comment|/* the dynamic tree */
name|ct_data
name|near
modifier|*
name|static_tree
decl_stmt|;
comment|/* corresponding static tree or NULL */
name|int
name|near
modifier|*
name|extra_bits
decl_stmt|;
comment|/* extra bits for each code or NULL */
name|int
name|extra_base
decl_stmt|;
comment|/* base index for extra_bits */
name|int
name|elems
decl_stmt|;
comment|/* max number of elements in the tree */
name|int
name|max_length
decl_stmt|;
comment|/* max bit length for the codes */
name|int
name|max_code
decl_stmt|;
comment|/* largest code with non zero frequency */
block|}
name|tree_desc
typedef|;
end_typedef

begin_decl_stmt
name|local
name|tree_desc
name|near
name|l_desc
init|=
block|{
name|dyn_ltree
block|,
name|static_ltree
block|,
name|extra_lbits
block|,
name|LITERALS
operator|+
literal|1
block|,
name|L_CODES
block|,
name|MAX_BITS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|tree_desc
name|near
name|d_desc
init|=
block|{
name|dyn_dtree
block|,
name|static_dtree
block|,
name|extra_dbits
block|,
literal|0
block|,
name|D_CODES
block|,
name|MAX_BITS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|tree_desc
name|near
name|bl_desc
init|=
block|{
name|bl_tree
block|,
operator|(
name|ct_data
name|near
operator|*
operator|)
literal|0
block|,
name|extra_blbits
block|,
literal|0
block|,
name|BL_CODES
block|,
name|MAX_BL_BITS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|ush
name|near
name|bl_count
index|[
name|MAX_BITS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of codes at each bit length for an optimal tree */
end_comment

begin_decl_stmt
name|local
name|uch
name|near
name|bl_order
index|[
name|BL_CODES
index|]
init|=
block|{
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|0
block|,
literal|8
block|,
literal|7
block|,
literal|9
block|,
literal|6
block|,
literal|10
block|,
literal|5
block|,
literal|11
block|,
literal|4
block|,
literal|12
block|,
literal|3
block|,
literal|13
block|,
literal|2
block|,
literal|14
block|,
literal|1
block|,
literal|15
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The lengths of the bit length codes are sent in order of decreasing  * probability, to avoid transmitting the lengths for unused bit length codes.  */
end_comment

begin_decl_stmt
name|local
name|int
name|near
name|heap
index|[
literal|2
operator|*
name|L_CODES
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* heap used to build the Huffman trees */
end_comment

begin_decl_stmt
name|local
name|int
name|heap_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of elements in the heap */
end_comment

begin_decl_stmt
name|local
name|int
name|heap_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* element of largest frequency */
end_comment

begin_comment
comment|/* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.  * The same heap array is used to build all trees.  */
end_comment

begin_decl_stmt
name|local
name|uch
name|near
name|depth
index|[
literal|2
operator|*
name|L_CODES
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Depth of each subtree used as tie breaker for trees of equal frequency */
end_comment

begin_decl_stmt
name|local
name|uch
name|length_code
index|[
name|MAX_MATCH
operator|-
name|MIN_MATCH
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length code for each normalized match length (0 == MIN_MATCH) */
end_comment

begin_decl_stmt
name|local
name|uch
name|dist_code
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* distance codes. The first 256 values correspond to the distances  * 3 .. 258, the last 256 values correspond to the top 8 bits of  * the 15 bit distances.  */
end_comment

begin_decl_stmt
name|local
name|int
name|near
name|base_length
index|[
name|LENGTH_CODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First normalized length for each code (0 = MIN_MATCH) */
end_comment

begin_decl_stmt
name|local
name|int
name|near
name|base_dist
index|[
name|D_CODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First normalized distance for each code (0 = distance of 1) */
end_comment

begin_define
define|#
directive|define
name|l_buf
value|inbuf
end_define

begin_comment
comment|/* DECLARE(uch, l_buf, LIT_BUFSIZE);  buffer for literals or lengths */
end_comment

begin_comment
comment|/* DECLARE(ush, d_buf, DIST_BUFSIZE); buffer for distances */
end_comment

begin_decl_stmt
name|local
name|uch
name|near
name|flag_buf
index|[
operator|(
name|LIT_BUFSIZE
operator|/
literal|8
operator|)
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag_buf is a bit array distinguishing literals from lengths in  * l_buf, thus indicating the presence or absence of a distance.  */
end_comment

begin_decl_stmt
name|local
name|unsigned
name|last_lit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* running index in l_buf */
end_comment

begin_decl_stmt
name|local
name|unsigned
name|last_dist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* running index in d_buf */
end_comment

begin_decl_stmt
name|local
name|unsigned
name|last_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* running index in flag_buf */
end_comment

begin_decl_stmt
name|local
name|uch
name|flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current flags not yet saved in flag_buf */
end_comment

begin_decl_stmt
name|local
name|uch
name|flag_bit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current bit used in flags */
end_comment

begin_comment
comment|/* bits are filled in flags starting at bit 0 (least significant).  * Note: these flags are overkill in the current code since we don't  * take advantage of DIST_BUFSIZE == LIT_BUFSIZE.  */
end_comment

begin_decl_stmt
name|local
name|ulg
name|opt_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bit length of current block with optimal trees */
end_comment

begin_decl_stmt
name|local
name|ulg
name|static_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bit length of current block with static trees */
end_comment

begin_decl_stmt
name|local
name|ulg
name|compressed_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total bit length of compressed file */
end_comment

begin_decl_stmt
name|local
name|ulg
name|input_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total byte length of input file */
end_comment

begin_comment
comment|/* input_len is for debugging only since we can get it by other means. */
end_comment

begin_decl_stmt
name|ush
modifier|*
name|file_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to UNKNOWN, BINARY or ASCII */
end_comment

begin_decl_stmt
name|int
modifier|*
name|file_method
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to DEFLATE or STORE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|extern
name|ulg
name|bits_sent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bit length of the compressed data */
end_comment

begin_decl_stmt
specifier|extern
name|long
name|isize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* byte length of input file */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|long
name|block_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* window offset of current block */
end_comment

begin_decl_stmt
specifier|extern
name|unsigned
name|near
name|strstart
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* window offset of current string */
end_comment

begin_comment
comment|/* ===========================================================================  * Local (static) routines in this file.  */
end_comment

begin_decl_stmt
name|local
name|void
name|init_block
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|pqdownheap
name|OF
argument_list|(
operator|(
name|ct_data
name|near
operator|*
name|tree
operator|,
name|int
name|k
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|gen_bitlen
name|OF
argument_list|(
operator|(
name|tree_desc
name|near
operator|*
name|desc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|gen_codes
name|OF
argument_list|(
operator|(
name|ct_data
name|near
operator|*
name|tree
operator|,
name|int
name|max_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|build_tree
name|OF
argument_list|(
operator|(
name|tree_desc
name|near
operator|*
name|desc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|scan_tree
name|OF
argument_list|(
operator|(
name|ct_data
name|near
operator|*
name|tree
operator|,
name|int
name|max_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|send_tree
name|OF
argument_list|(
operator|(
name|ct_data
name|near
operator|*
name|tree
operator|,
name|int
name|max_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|build_bl_tree
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|send_all_trees
name|OF
argument_list|(
operator|(
name|int
name|lcodes
operator|,
name|int
name|dcodes
operator|,
name|int
name|blcodes
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|compress_block
name|OF
argument_list|(
operator|(
name|ct_data
name|near
operator|*
name|ltree
operator|,
name|ct_data
name|near
operator|*
name|dtree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|set_file_type
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG
end_ifndef

begin_define
define|#
directive|define
name|send_code
parameter_list|(
name|c
parameter_list|,
name|tree
parameter_list|)
value|send_bits(tree[c].Code, tree[c].Len)
end_define

begin_comment
comment|/* Send a code of the given tree. c and tree must not have side effects */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* DEBUG */
end_comment

begin_define
define|#
directive|define
name|send_code
parameter_list|(
name|c
parameter_list|,
name|tree
parameter_list|)
define|\
value|{ if (verbose>1) fprintf(stderr,"\ncd %3d ",(c)); \        send_bits(tree[c].Code, tree[c].Len); }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|d_code
parameter_list|(
name|dist
parameter_list|)
define|\
value|((dist)< 256 ? dist_code[dist] : dist_code[256+((dist)>>7)])
end_define

begin_comment
comment|/* Mapping from a distance to a distance code. dist is the distance - 1 and  * must not have side effects. dist_code[256] and dist_code[257] are never  * used.  */
end_comment

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(a>= b ? a : b)
end_define

begin_comment
comment|/* the arguments must not have side effects */
end_comment

begin_comment
comment|/* ===========================================================================  * Allocate the match buffer, initialize the various tables and save the  * location of the internal file attribute (ascii/binary) and method  * (DEFLATE/STORE).  */
end_comment

begin_function
name|void
name|ct_init
parameter_list|(
name|attr
parameter_list|,
name|methodp
parameter_list|)
name|ush
modifier|*
name|attr
decl_stmt|;
comment|/* pointer to internal file attribute */
name|int
modifier|*
name|methodp
decl_stmt|;
comment|/* pointer to compression method */
block|{
name|int
name|n
decl_stmt|;
comment|/* iterates over tree elements */
name|int
name|bits
decl_stmt|;
comment|/* bit counter */
name|int
name|length
decl_stmt|;
comment|/* length value */
name|int
name|code
decl_stmt|;
comment|/* code value */
name|int
name|dist
decl_stmt|;
comment|/* distance index */
name|file_type
operator|=
name|attr
expr_stmt|;
name|file_method
operator|=
name|methodp
expr_stmt|;
name|compressed_len
operator|=
name|input_len
operator|=
literal|0L
expr_stmt|;
if|if
condition|(
name|static_dtree
index|[
literal|0
index|]
operator|.
name|Len
operator|!=
literal|0
condition|)
return|return;
comment|/* ct_init already called */
comment|/* Initialize the mapping length (0..255) -> length code (0..28) */
name|length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|code
operator|=
literal|0
init|;
name|code
operator|<
name|LENGTH_CODES
operator|-
literal|1
condition|;
name|code
operator|++
control|)
block|{
name|base_length
index|[
name|code
index|]
operator|=
name|length
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
literal|1
operator|<<
name|extra_lbits
index|[
name|code
index|]
operator|)
condition|;
name|n
operator|++
control|)
block|{
name|length_code
index|[
name|length
operator|++
index|]
operator|=
operator|(
name|uch
operator|)
name|code
expr_stmt|;
block|}
block|}
name|Assert
argument_list|(
name|length
operator|==
literal|256
argument_list|,
literal|"ct_init: length != 256"
argument_list|)
expr_stmt|;
comment|/* Note that the length 255 (match length 258) can be represented      * in two different ways: code 284 + 5 bits or code 285, so we      * overwrite length_code[255] to use the best encoding:      */
name|length_code
index|[
name|length
operator|-
literal|1
index|]
operator|=
operator|(
name|uch
operator|)
name|code
expr_stmt|;
comment|/* Initialize the mapping dist (0..32K) -> dist code (0..29) */
name|dist
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|code
operator|=
literal|0
init|;
name|code
operator|<
literal|16
condition|;
name|code
operator|++
control|)
block|{
name|base_dist
index|[
name|code
index|]
operator|=
name|dist
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
literal|1
operator|<<
name|extra_dbits
index|[
name|code
index|]
operator|)
condition|;
name|n
operator|++
control|)
block|{
name|dist_code
index|[
name|dist
operator|++
index|]
operator|=
operator|(
name|uch
operator|)
name|code
expr_stmt|;
block|}
block|}
name|Assert
argument_list|(
name|dist
operator|==
literal|256
argument_list|,
literal|"ct_init: dist != 256"
argument_list|)
expr_stmt|;
name|dist
operator|>>=
literal|7
expr_stmt|;
comment|/* from now on, all distances are divided by 128 */
for|for
control|(
init|;
name|code
operator|<
name|D_CODES
condition|;
name|code
operator|++
control|)
block|{
name|base_dist
index|[
name|code
index|]
operator|=
name|dist
operator|<<
literal|7
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
literal|1
operator|<<
operator|(
name|extra_dbits
index|[
name|code
index|]
operator|-
literal|7
operator|)
operator|)
condition|;
name|n
operator|++
control|)
block|{
name|dist_code
index|[
literal|256
operator|+
name|dist
operator|++
index|]
operator|=
operator|(
name|uch
operator|)
name|code
expr_stmt|;
block|}
block|}
name|Assert
argument_list|(
name|dist
operator|==
literal|256
argument_list|,
literal|"ct_init: 256+dist != 512"
argument_list|)
expr_stmt|;
comment|/* Construct the codes of the static literal tree */
for|for
control|(
name|bits
operator|=
literal|0
init|;
name|bits
operator|<=
name|MAX_BITS
condition|;
name|bits
operator|++
control|)
name|bl_count
index|[
name|bits
index|]
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|n
operator|<=
literal|143
condition|)
name|static_ltree
index|[
name|n
operator|++
index|]
operator|.
name|Len
operator|=
literal|8
operator|,
name|bl_count
index|[
literal|8
index|]
operator|++
expr_stmt|;
while|while
condition|(
name|n
operator|<=
literal|255
condition|)
name|static_ltree
index|[
name|n
operator|++
index|]
operator|.
name|Len
operator|=
literal|9
operator|,
name|bl_count
index|[
literal|9
index|]
operator|++
expr_stmt|;
while|while
condition|(
name|n
operator|<=
literal|279
condition|)
name|static_ltree
index|[
name|n
operator|++
index|]
operator|.
name|Len
operator|=
literal|7
operator|,
name|bl_count
index|[
literal|7
index|]
operator|++
expr_stmt|;
while|while
condition|(
name|n
operator|<=
literal|287
condition|)
name|static_ltree
index|[
name|n
operator|++
index|]
operator|.
name|Len
operator|=
literal|8
operator|,
name|bl_count
index|[
literal|8
index|]
operator|++
expr_stmt|;
comment|/* Codes 286 and 287 do not exist, but we must include them in the      * tree construction to get a canonical Huffman tree (longest code      * all ones)      */
name|gen_codes
argument_list|(
operator|(
name|ct_data
name|near
operator|*
operator|)
name|static_ltree
argument_list|,
name|L_CODES
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* The static distance tree is trivial: */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|D_CODES
condition|;
name|n
operator|++
control|)
block|{
name|static_dtree
index|[
name|n
index|]
operator|.
name|Len
operator|=
literal|5
expr_stmt|;
name|static_dtree
index|[
name|n
index|]
operator|.
name|Code
operator|=
name|bi_reverse
argument_list|(
name|n
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the first block of the first file: */
name|init_block
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Initialize a new block.  */
end_comment

begin_function
name|local
name|void
name|init_block
parameter_list|()
block|{
name|int
name|n
decl_stmt|;
comment|/* iterates over tree elements */
comment|/* Initialize the trees. */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|L_CODES
condition|;
name|n
operator|++
control|)
name|dyn_ltree
index|[
name|n
index|]
operator|.
name|Freq
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|D_CODES
condition|;
name|n
operator|++
control|)
name|dyn_dtree
index|[
name|n
index|]
operator|.
name|Freq
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|BL_CODES
condition|;
name|n
operator|++
control|)
name|bl_tree
index|[
name|n
index|]
operator|.
name|Freq
operator|=
literal|0
expr_stmt|;
name|dyn_ltree
index|[
name|END_BLOCK
index|]
operator|.
name|Freq
operator|=
literal|1
expr_stmt|;
name|opt_len
operator|=
name|static_len
operator|=
literal|0L
expr_stmt|;
name|last_lit
operator|=
name|last_dist
operator|=
name|last_flags
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|flag_bit
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SMALLEST
value|1
end_define

begin_comment
comment|/* Index within the heap array of least frequent node in the Huffman tree */
end_comment

begin_comment
comment|/* ===========================================================================  * Remove the smallest element from the heap and recreate the heap with  * one less element. Updates heap and heap_len.  */
end_comment

begin_define
define|#
directive|define
name|pqremove
parameter_list|(
name|tree
parameter_list|,
name|top
parameter_list|)
define|\
value|{\     top = heap[SMALLEST]; \     heap[SMALLEST] = heap[heap_len--]; \     pqdownheap(tree, SMALLEST); \ }
end_define

begin_comment
comment|/* ===========================================================================  * Compares to subtrees, using the tree depth as tie breaker when  * the subtrees have equal frequency. This minimizes the worst case length.  */
end_comment

begin_define
define|#
directive|define
name|smaller
parameter_list|(
name|tree
parameter_list|,
name|n
parameter_list|,
name|m
parameter_list|)
define|\
value|(tree[n].Freq< tree[m].Freq || \    (tree[n].Freq == tree[m].Freq&& depth[n]<= depth[m]))
end_define

begin_comment
comment|/* ===========================================================================  * Restore the heap property by moving down the tree starting at node k,  * exchanging a node with the smallest of its two sons if necessary, stopping  * when the heap property is re-established (each father smaller than its  * two sons).  */
end_comment

begin_function
name|local
name|void
name|pqdownheap
parameter_list|(
name|tree
parameter_list|,
name|k
parameter_list|)
name|ct_data
name|near
modifier|*
name|tree
decl_stmt|;
comment|/* the tree to restore */
name|int
name|k
decl_stmt|;
comment|/* node to move down */
block|{
name|int
name|v
init|=
name|heap
index|[
name|k
index|]
decl_stmt|;
name|int
name|j
init|=
name|k
operator|<<
literal|1
decl_stmt|;
comment|/* left son of k */
while|while
condition|(
name|j
operator|<=
name|heap_len
condition|)
block|{
comment|/* Set j to the smallest of the two sons: */
if|if
condition|(
name|j
operator|<
name|heap_len
operator|&&
name|smaller
argument_list|(
name|tree
argument_list|,
name|heap
index|[
name|j
operator|+
literal|1
index|]
argument_list|,
name|heap
index|[
name|j
index|]
argument_list|)
condition|)
name|j
operator|++
expr_stmt|;
comment|/* Exit if v is smaller than both sons */
if|if
condition|(
name|smaller
argument_list|(
name|tree
argument_list|,
name|v
argument_list|,
name|heap
index|[
name|j
index|]
argument_list|)
condition|)
break|break;
comment|/* Exchange v with the smallest son */
name|heap
index|[
name|k
index|]
operator|=
name|heap
index|[
name|j
index|]
expr_stmt|;
name|k
operator|=
name|j
expr_stmt|;
comment|/* And continue down the tree, setting j to the left son of k */
name|j
operator|<<=
literal|1
expr_stmt|;
block|}
name|heap
index|[
name|k
index|]
operator|=
name|v
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Compute the optimal bit lengths for a tree and update the total bit length  * for the current block.  * IN assertion: the fields freq and dad are set, heap[heap_max] and  *    above are the tree nodes sorted by increasing frequency.  * OUT assertions: the field len is set to the optimal bit length, the  *     array bl_count contains the frequencies for each bit length.  *     The length opt_len is updated; static_len is also updated if stree is  *     not null.  */
end_comment

begin_function
name|local
name|void
name|gen_bitlen
parameter_list|(
name|desc
parameter_list|)
name|tree_desc
name|near
modifier|*
name|desc
decl_stmt|;
comment|/* the tree descriptor */
block|{
name|ct_data
name|near
modifier|*
name|tree
init|=
name|desc
operator|->
name|dyn_tree
decl_stmt|;
name|int
name|near
modifier|*
name|extra
init|=
name|desc
operator|->
name|extra_bits
decl_stmt|;
name|int
name|base
init|=
name|desc
operator|->
name|extra_base
decl_stmt|;
name|int
name|max_code
init|=
name|desc
operator|->
name|max_code
decl_stmt|;
name|int
name|max_length
init|=
name|desc
operator|->
name|max_length
decl_stmt|;
name|ct_data
name|near
modifier|*
name|stree
init|=
name|desc
operator|->
name|static_tree
decl_stmt|;
name|int
name|h
decl_stmt|;
comment|/* heap index */
name|int
name|n
decl_stmt|,
name|m
decl_stmt|;
comment|/* iterate over the tree elements */
name|int
name|bits
decl_stmt|;
comment|/* bit length */
name|int
name|xbits
decl_stmt|;
comment|/* extra bits */
name|ush
name|f
decl_stmt|;
comment|/* frequency */
name|int
name|overflow
init|=
literal|0
decl_stmt|;
comment|/* number of elements with bit length too large */
for|for
control|(
name|bits
operator|=
literal|0
init|;
name|bits
operator|<=
name|MAX_BITS
condition|;
name|bits
operator|++
control|)
name|bl_count
index|[
name|bits
index|]
operator|=
literal|0
expr_stmt|;
comment|/* In a first pass, compute the optimal bit lengths (which may      * overflow in the case of the bit length tree).      */
name|tree
index|[
name|heap
index|[
name|heap_max
index|]
index|]
operator|.
name|Len
operator|=
literal|0
expr_stmt|;
comment|/* root of the heap */
for|for
control|(
name|h
operator|=
name|heap_max
operator|+
literal|1
init|;
name|h
operator|<
name|HEAP_SIZE
condition|;
name|h
operator|++
control|)
block|{
name|n
operator|=
name|heap
index|[
name|h
index|]
expr_stmt|;
name|bits
operator|=
name|tree
index|[
name|tree
index|[
name|n
index|]
operator|.
name|Dad
index|]
operator|.
name|Len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|bits
operator|>
name|max_length
condition|)
name|bits
operator|=
name|max_length
operator|,
name|overflow
operator|++
expr_stmt|;
name|tree
index|[
name|n
index|]
operator|.
name|Len
operator|=
operator|(
name|ush
operator|)
name|bits
expr_stmt|;
comment|/* We overwrite tree[n].Dad which is no longer needed */
if|if
condition|(
name|n
operator|>
name|max_code
condition|)
continue|continue;
comment|/* not a leaf node */
name|bl_count
index|[
name|bits
index|]
operator|++
expr_stmt|;
name|xbits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|base
condition|)
name|xbits
operator|=
name|extra
index|[
name|n
operator|-
name|base
index|]
expr_stmt|;
name|f
operator|=
name|tree
index|[
name|n
index|]
operator|.
name|Freq
expr_stmt|;
name|opt_len
operator|+=
operator|(
name|ulg
operator|)
name|f
operator|*
operator|(
name|bits
operator|+
name|xbits
operator|)
expr_stmt|;
if|if
condition|(
name|stree
condition|)
name|static_len
operator|+=
operator|(
name|ulg
operator|)
name|f
operator|*
operator|(
name|stree
index|[
name|n
index|]
operator|.
name|Len
operator|+
name|xbits
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|overflow
operator|==
literal|0
condition|)
return|return;
name|Trace
argument_list|(
operator|(
name|stderr
operator|,
literal|"\nbit length overflow\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* This happens for example on obj2 and pic of the Calgary corpus */
comment|/* Find the first bit length which could increase: */
do|do
block|{
name|bits
operator|=
name|max_length
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|bl_count
index|[
name|bits
index|]
operator|==
literal|0
condition|)
name|bits
operator|--
expr_stmt|;
name|bl_count
index|[
name|bits
index|]
operator|--
expr_stmt|;
comment|/* move one leaf down the tree */
name|bl_count
index|[
name|bits
operator|+
literal|1
index|]
operator|+=
literal|2
expr_stmt|;
comment|/* move one overflow item as its brother */
name|bl_count
index|[
name|max_length
index|]
operator|--
expr_stmt|;
comment|/* The brother of the overflow item also moves one step up,          * but this does not affect bl_count[max_length]          */
name|overflow
operator|-=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|overflow
operator|>
literal|0
condition|)
do|;
comment|/* Now recompute all bit lengths, scanning in increasing frequency.      * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all      * lengths instead of fixing only the wrong ones. This idea is taken      * from 'ar' written by Haruhiko Okumura.)      */
for|for
control|(
name|bits
operator|=
name|max_length
init|;
name|bits
operator|!=
literal|0
condition|;
name|bits
operator|--
control|)
block|{
name|n
operator|=
name|bl_count
index|[
name|bits
index|]
expr_stmt|;
while|while
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|m
operator|=
name|heap
index|[
operator|--
name|h
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|>
name|max_code
condition|)
continue|continue;
if|if
condition|(
name|tree
index|[
name|m
index|]
operator|.
name|Len
operator|!=
operator|(
name|unsigned
operator|)
name|bits
condition|)
block|{
name|Trace
argument_list|(
operator|(
name|stderr
operator|,
literal|"code %d bits %d->%d\n"
operator|,
name|m
operator|,
name|tree
index|[
name|m
index|]
operator|.
name|Len
operator|,
name|bits
operator|)
argument_list|)
expr_stmt|;
name|opt_len
operator|+=
operator|(
operator|(
name|long
operator|)
name|bits
operator|-
operator|(
name|long
operator|)
name|tree
index|[
name|m
index|]
operator|.
name|Len
operator|)
operator|*
operator|(
name|long
operator|)
name|tree
index|[
name|m
index|]
operator|.
name|Freq
expr_stmt|;
name|tree
index|[
name|m
index|]
operator|.
name|Len
operator|=
operator|(
name|ush
operator|)
name|bits
expr_stmt|;
block|}
name|n
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Generate the codes for a given tree and bit counts (which need not be  * optimal).  * IN assertion: the array bl_count contains the bit length statistics for  * the given tree and the field len is set for all tree elements.  * OUT assertion: the field code is set for all tree elements of non  *     zero code length.  */
end_comment

begin_function
name|local
name|void
name|gen_codes
parameter_list|(
name|tree
parameter_list|,
name|max_code
parameter_list|)
name|ct_data
name|near
modifier|*
name|tree
decl_stmt|;
comment|/* the tree to decorate */
name|int
name|max_code
decl_stmt|;
comment|/* largest code with non zero frequency */
block|{
name|ush
name|next_code
index|[
name|MAX_BITS
operator|+
literal|1
index|]
decl_stmt|;
comment|/* next code value for each bit length */
name|ush
name|code
init|=
literal|0
decl_stmt|;
comment|/* running code value */
name|int
name|bits
decl_stmt|;
comment|/* bit index */
name|int
name|n
decl_stmt|;
comment|/* code index */
comment|/* The distribution counts are first used to generate the code values      * without bit reversal.      */
for|for
control|(
name|bits
operator|=
literal|1
init|;
name|bits
operator|<=
name|MAX_BITS
condition|;
name|bits
operator|++
control|)
block|{
name|next_code
index|[
name|bits
index|]
operator|=
name|code
operator|=
operator|(
name|code
operator|+
name|bl_count
index|[
name|bits
operator|-
literal|1
index|]
operator|)
operator|<<
literal|1
expr_stmt|;
block|}
comment|/* Check that the bit counts in bl_count are consistent. The last code      * must be all ones.      */
name|Assert
argument_list|(
name|code
operator|+
name|bl_count
index|[
name|MAX_BITS
index|]
operator|-
literal|1
operator|==
operator|(
literal|1
operator|<<
name|MAX_BITS
operator|)
operator|-
literal|1
argument_list|,
literal|"inconsistent bit counts"
argument_list|)
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"\ngen_codes: max_code %d "
operator|,
name|max_code
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|max_code
condition|;
name|n
operator|++
control|)
block|{
name|int
name|len
init|=
name|tree
index|[
name|n
index|]
operator|.
name|Len
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
continue|continue;
comment|/* Now reverse the bits */
name|tree
index|[
name|n
index|]
operator|.
name|Code
operator|=
name|bi_reverse
argument_list|(
name|next_code
index|[
name|len
index|]
operator|++
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|Tracec
argument_list|(
name|tree
operator|!=
name|static_ltree
argument_list|,
operator|(
name|stderr
operator|,
literal|"\nn %3d %c l %2d c %4x (%x) "
operator|,
name|n
operator|,
operator|(
name|isgraph
argument_list|(
name|n
argument_list|)
condition|?
name|n
else|:
literal|' '
operator|)
operator|,
name|len
operator|,
name|tree
index|[
name|n
index|]
operator|.
name|Code
operator|,
name|next_code
index|[
name|len
index|]
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Construct one Huffman tree and assigns the code bit strings and lengths.  * Update the total bit length for the current block.  * IN assertion: the field freq is set for all tree elements.  * OUT assertions: the fields len and code are set to the optimal bit length  *     and corresponding code. The length opt_len is updated; static_len is  *     also updated if stree is not null. The field max_code is set.  */
end_comment

begin_function
name|local
name|void
name|build_tree
parameter_list|(
name|desc
parameter_list|)
name|tree_desc
name|near
modifier|*
name|desc
decl_stmt|;
comment|/* the tree descriptor */
block|{
name|ct_data
name|near
modifier|*
name|tree
init|=
name|desc
operator|->
name|dyn_tree
decl_stmt|;
name|ct_data
name|near
modifier|*
name|stree
init|=
name|desc
operator|->
name|static_tree
decl_stmt|;
name|int
name|elems
init|=
name|desc
operator|->
name|elems
decl_stmt|;
name|int
name|n
decl_stmt|,
name|m
decl_stmt|;
comment|/* iterate over heap elements */
name|int
name|max_code
init|=
operator|-
literal|1
decl_stmt|;
comment|/* largest code with non zero frequency */
name|int
name|node
init|=
name|elems
decl_stmt|;
comment|/* next internal node of the tree */
comment|/* Construct the initial heap, with least frequent element in      * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].      * heap[0] is not used.      */
name|heap_len
operator|=
literal|0
operator|,
name|heap_max
operator|=
name|HEAP_SIZE
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|elems
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|tree
index|[
name|n
index|]
operator|.
name|Freq
operator|!=
literal|0
condition|)
block|{
name|heap
index|[
operator|++
name|heap_len
index|]
operator|=
name|max_code
operator|=
name|n
expr_stmt|;
name|depth
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tree
index|[
name|n
index|]
operator|.
name|Len
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* The pkzip format requires that at least one distance code exists,      * and that at least one bit should be sent even if there is only one      * possible code. So to avoid special checks later on we force at least      * two codes of non zero frequency.      */
while|while
condition|(
name|heap_len
operator|<
literal|2
condition|)
block|{
name|int
name|new
init|=
name|heap
index|[
operator|++
name|heap_len
index|]
operator|=
operator|(
name|max_code
operator|<
literal|2
condition|?
operator|++
name|max_code
else|:
literal|0
operator|)
decl_stmt|;
name|tree
index|[
name|new
index|]
operator|.
name|Freq
operator|=
literal|1
expr_stmt|;
name|depth
index|[
name|new
index|]
operator|=
literal|0
expr_stmt|;
name|opt_len
operator|--
expr_stmt|;
if|if
condition|(
name|stree
condition|)
name|static_len
operator|-=
name|stree
index|[
name|new
index|]
operator|.
name|Len
expr_stmt|;
comment|/* new is 0 or 1 so it does not have extra bits */
block|}
name|desc
operator|->
name|max_code
operator|=
name|max_code
expr_stmt|;
comment|/* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,      * establish sub-heaps of increasing lengths:      */
for|for
control|(
name|n
operator|=
name|heap_len
operator|/
literal|2
init|;
name|n
operator|>=
literal|1
condition|;
name|n
operator|--
control|)
name|pqdownheap
argument_list|(
name|tree
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Construct the Huffman tree by repeatedly combining the least two      * frequent nodes.      */
do|do
block|{
name|pqremove
argument_list|(
name|tree
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* n = node of least frequency */
name|m
operator|=
name|heap
index|[
name|SMALLEST
index|]
expr_stmt|;
comment|/* m = node of next least frequency */
name|heap
index|[
operator|--
name|heap_max
index|]
operator|=
name|n
expr_stmt|;
comment|/* keep the nodes sorted by frequency */
name|heap
index|[
operator|--
name|heap_max
index|]
operator|=
name|m
expr_stmt|;
comment|/* Create a new node father of n and m */
name|tree
index|[
name|node
index|]
operator|.
name|Freq
operator|=
name|tree
index|[
name|n
index|]
operator|.
name|Freq
operator|+
name|tree
index|[
name|m
index|]
operator|.
name|Freq
expr_stmt|;
name|depth
index|[
name|node
index|]
operator|=
call|(
name|uch
call|)
argument_list|(
name|MAX
argument_list|(
name|depth
index|[
name|n
index|]
argument_list|,
name|depth
index|[
name|m
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tree
index|[
name|n
index|]
operator|.
name|Dad
operator|=
name|tree
index|[
name|m
index|]
operator|.
name|Dad
operator|=
operator|(
name|ush
operator|)
name|node
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMP_BL_TREE
if|if
condition|(
name|tree
operator|==
name|bl_tree
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nnode %d(%d), sons %d(%d) %d(%d)"
argument_list|,
name|node
argument_list|,
name|tree
index|[
name|node
index|]
operator|.
name|Freq
argument_list|,
name|n
argument_list|,
name|tree
index|[
name|n
index|]
operator|.
name|Freq
argument_list|,
name|m
argument_list|,
name|tree
index|[
name|m
index|]
operator|.
name|Freq
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* and insert the new node in the heap */
name|heap
index|[
name|SMALLEST
index|]
operator|=
name|node
operator|++
expr_stmt|;
name|pqdownheap
argument_list|(
name|tree
argument_list|,
name|SMALLEST
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|heap_len
operator|>=
literal|2
condition|)
do|;
name|heap
index|[
operator|--
name|heap_max
index|]
operator|=
name|heap
index|[
name|SMALLEST
index|]
expr_stmt|;
comment|/* At this point, the fields freq and dad are set. We can now      * generate the bit lengths.      */
name|gen_bitlen
argument_list|(
operator|(
name|tree_desc
name|near
operator|*
operator|)
name|desc
argument_list|)
expr_stmt|;
comment|/* The field len is now set, we can generate the bit codes */
name|gen_codes
argument_list|(
operator|(
name|ct_data
name|near
operator|*
operator|)
name|tree
argument_list|,
name|max_code
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Scan a literal or distance tree to determine the frequencies of the codes  * in the bit length tree. Updates opt_len to take into account the repeat  * counts. (The contribution of the bit length codes will be added later  * during the construction of bl_tree.)  */
end_comment

begin_function
name|local
name|void
name|scan_tree
parameter_list|(
name|tree
parameter_list|,
name|max_code
parameter_list|)
name|ct_data
name|near
modifier|*
name|tree
decl_stmt|;
comment|/* the tree to be scanned */
name|int
name|max_code
decl_stmt|;
comment|/* and its largest code of non zero frequency */
block|{
name|int
name|n
decl_stmt|;
comment|/* iterates over all tree elements */
name|int
name|prevlen
init|=
operator|-
literal|1
decl_stmt|;
comment|/* last emitted length */
name|int
name|curlen
decl_stmt|;
comment|/* length of current code */
name|int
name|nextlen
init|=
name|tree
index|[
literal|0
index|]
operator|.
name|Len
decl_stmt|;
comment|/* length of next code */
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* repeat count of the current code */
name|int
name|max_count
init|=
literal|7
decl_stmt|;
comment|/* max repeat count */
name|int
name|min_count
init|=
literal|4
decl_stmt|;
comment|/* min repeat count */
if|if
condition|(
name|nextlen
operator|==
literal|0
condition|)
name|max_count
operator|=
literal|138
operator|,
name|min_count
operator|=
literal|3
expr_stmt|;
name|tree
index|[
name|max_code
operator|+
literal|1
index|]
operator|.
name|Len
operator|=
operator|(
name|ush
operator|)
literal|0xffff
expr_stmt|;
comment|/* guard */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|max_code
condition|;
name|n
operator|++
control|)
block|{
name|curlen
operator|=
name|nextlen
expr_stmt|;
name|nextlen
operator|=
name|tree
index|[
name|n
operator|+
literal|1
index|]
operator|.
name|Len
expr_stmt|;
if|if
condition|(
operator|++
name|count
operator|<
name|max_count
operator|&&
name|curlen
operator|==
name|nextlen
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|count
operator|<
name|min_count
condition|)
block|{
name|bl_tree
index|[
name|curlen
index|]
operator|.
name|Freq
operator|+=
name|count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curlen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|curlen
operator|!=
name|prevlen
condition|)
name|bl_tree
index|[
name|curlen
index|]
operator|.
name|Freq
operator|++
expr_stmt|;
name|bl_tree
index|[
name|REP_3_6
index|]
operator|.
name|Freq
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|<=
literal|10
condition|)
block|{
name|bl_tree
index|[
name|REPZ_3_10
index|]
operator|.
name|Freq
operator|++
expr_stmt|;
block|}
else|else
block|{
name|bl_tree
index|[
name|REPZ_11_138
index|]
operator|.
name|Freq
operator|++
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|prevlen
operator|=
name|curlen
expr_stmt|;
if|if
condition|(
name|nextlen
operator|==
literal|0
condition|)
block|{
name|max_count
operator|=
literal|138
operator|,
name|min_count
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curlen
operator|==
name|nextlen
condition|)
block|{
name|max_count
operator|=
literal|6
operator|,
name|min_count
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|max_count
operator|=
literal|7
operator|,
name|min_count
operator|=
literal|4
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Send a literal or distance tree in compressed form, using the codes in  * bl_tree.  */
end_comment

begin_function
name|local
name|void
name|send_tree
parameter_list|(
name|tree
parameter_list|,
name|max_code
parameter_list|)
name|ct_data
name|near
modifier|*
name|tree
decl_stmt|;
comment|/* the tree to be scanned */
name|int
name|max_code
decl_stmt|;
comment|/* and its largest code of non zero frequency */
block|{
name|int
name|n
decl_stmt|;
comment|/* iterates over all tree elements */
name|int
name|prevlen
init|=
operator|-
literal|1
decl_stmt|;
comment|/* last emitted length */
name|int
name|curlen
decl_stmt|;
comment|/* length of current code */
name|int
name|nextlen
init|=
name|tree
index|[
literal|0
index|]
operator|.
name|Len
decl_stmt|;
comment|/* length of next code */
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* repeat count of the current code */
name|int
name|max_count
init|=
literal|7
decl_stmt|;
comment|/* max repeat count */
name|int
name|min_count
init|=
literal|4
decl_stmt|;
comment|/* min repeat count */
comment|/* tree[max_code+1].Len = -1; */
comment|/* guard already set */
if|if
condition|(
name|nextlen
operator|==
literal|0
condition|)
name|max_count
operator|=
literal|138
operator|,
name|min_count
operator|=
literal|3
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|max_code
condition|;
name|n
operator|++
control|)
block|{
name|curlen
operator|=
name|nextlen
expr_stmt|;
name|nextlen
operator|=
name|tree
index|[
name|n
operator|+
literal|1
index|]
operator|.
name|Len
expr_stmt|;
if|if
condition|(
operator|++
name|count
operator|<
name|max_count
operator|&&
name|curlen
operator|==
name|nextlen
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|count
operator|<
name|min_count
condition|)
block|{
do|do
block|{
name|send_code
argument_list|(
name|curlen
argument_list|,
name|bl_tree
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|count
operator|!=
literal|0
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|curlen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|curlen
operator|!=
name|prevlen
condition|)
block|{
name|send_code
argument_list|(
name|curlen
argument_list|,
name|bl_tree
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
name|Assert
argument_list|(
name|count
operator|>=
literal|3
operator|&&
name|count
operator|<=
literal|6
argument_list|,
literal|" 3_6?"
argument_list|)
expr_stmt|;
name|send_code
argument_list|(
name|REP_3_6
argument_list|,
name|bl_tree
argument_list|)
expr_stmt|;
name|send_bits
argument_list|(
name|count
operator|-
literal|3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|<=
literal|10
condition|)
block|{
name|send_code
argument_list|(
name|REPZ_3_10
argument_list|,
name|bl_tree
argument_list|)
expr_stmt|;
name|send_bits
argument_list|(
name|count
operator|-
literal|3
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|send_code
argument_list|(
name|REPZ_11_138
argument_list|,
name|bl_tree
argument_list|)
expr_stmt|;
name|send_bits
argument_list|(
name|count
operator|-
literal|11
argument_list|,
literal|7
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|prevlen
operator|=
name|curlen
expr_stmt|;
if|if
condition|(
name|nextlen
operator|==
literal|0
condition|)
block|{
name|max_count
operator|=
literal|138
operator|,
name|min_count
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curlen
operator|==
name|nextlen
condition|)
block|{
name|max_count
operator|=
literal|6
operator|,
name|min_count
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|max_count
operator|=
literal|7
operator|,
name|min_count
operator|=
literal|4
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Construct the Huffman tree for the bit lengths and return the index in  * bl_order of the last bit length code to send.  */
end_comment

begin_function
name|local
name|int
name|build_bl_tree
parameter_list|()
block|{
name|int
name|max_blindex
decl_stmt|;
comment|/* index of last bit length code of non zero freq */
comment|/* Determine the bit length frequencies for literal and distance trees */
name|scan_tree
argument_list|(
operator|(
name|ct_data
name|near
operator|*
operator|)
name|dyn_ltree
argument_list|,
name|l_desc
operator|.
name|max_code
argument_list|)
expr_stmt|;
name|scan_tree
argument_list|(
operator|(
name|ct_data
name|near
operator|*
operator|)
name|dyn_dtree
argument_list|,
name|d_desc
operator|.
name|max_code
argument_list|)
expr_stmt|;
comment|/* Build the bit length tree: */
name|build_tree
argument_list|(
operator|(
name|tree_desc
name|near
operator|*
operator|)
operator|(
operator|&
name|bl_desc
operator|)
argument_list|)
expr_stmt|;
comment|/* opt_len now includes the length of the tree representations, except      * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.      */
comment|/* Determine the number of bit length codes to send. The pkzip format      * requires that at least 4 bit length codes be sent. (appnote.txt says      * 3 but the actual value used is 4.)      */
for|for
control|(
name|max_blindex
operator|=
name|BL_CODES
operator|-
literal|1
init|;
name|max_blindex
operator|>=
literal|3
condition|;
name|max_blindex
operator|--
control|)
block|{
if|if
condition|(
name|bl_tree
index|[
name|bl_order
index|[
name|max_blindex
index|]
index|]
operator|.
name|Len
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* Update opt_len to include the bit length tree and counts */
name|opt_len
operator|+=
literal|3
operator|*
operator|(
name|max_blindex
operator|+
literal|1
operator|)
operator|+
literal|5
operator|+
literal|5
operator|+
literal|4
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"\ndyn trees: dyn %ld, stat %ld"
operator|,
name|opt_len
operator|,
name|static_len
operator|)
argument_list|)
expr_stmt|;
return|return
name|max_blindex
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Send the header for a block using dynamic Huffman trees: the counts, the  * lengths of the bit length codes, the literal tree and the distance tree.  * IN assertion: lcodes>= 257, dcodes>= 1, blcodes>= 4.  */
end_comment

begin_function
name|local
name|void
name|send_all_trees
parameter_list|(
name|lcodes
parameter_list|,
name|dcodes
parameter_list|,
name|blcodes
parameter_list|)
name|int
name|lcodes
decl_stmt|,
name|dcodes
decl_stmt|,
name|blcodes
decl_stmt|;
comment|/* number of codes for each tree */
block|{
name|int
name|rank
decl_stmt|;
comment|/* index in bl_order */
name|Assert
argument_list|(
name|lcodes
operator|>=
literal|257
operator|&&
name|dcodes
operator|>=
literal|1
operator|&&
name|blcodes
operator|>=
literal|4
argument_list|,
literal|"not enough codes"
argument_list|)
expr_stmt|;
name|Assert
argument_list|(
name|lcodes
operator|<=
name|L_CODES
operator|&&
name|dcodes
operator|<=
name|D_CODES
operator|&&
name|blcodes
operator|<=
name|BL_CODES
argument_list|,
literal|"too many codes"
argument_list|)
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"\nbl counts: "
operator|)
argument_list|)
expr_stmt|;
name|send_bits
argument_list|(
name|lcodes
operator|-
literal|257
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* not +255 as stated in appnote.txt */
name|send_bits
argument_list|(
name|dcodes
operator|-
literal|1
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|send_bits
argument_list|(
name|blcodes
operator|-
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* not -3 as stated in appnote.txt */
for|for
control|(
name|rank
operator|=
literal|0
init|;
name|rank
operator|<
name|blcodes
condition|;
name|rank
operator|++
control|)
block|{
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"\nbl code %2d "
operator|,
name|bl_order
index|[
name|rank
index|]
operator|)
argument_list|)
expr_stmt|;
name|send_bits
argument_list|(
name|bl_tree
index|[
name|bl_order
index|[
name|rank
index|]
index|]
operator|.
name|Len
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"\nbl tree: sent %ld"
operator|,
name|bits_sent
operator|)
argument_list|)
expr_stmt|;
name|send_tree
argument_list|(
operator|(
name|ct_data
name|near
operator|*
operator|)
name|dyn_ltree
argument_list|,
name|lcodes
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* send the literal tree */
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"\nlit tree: sent %ld"
operator|,
name|bits_sent
operator|)
argument_list|)
expr_stmt|;
name|send_tree
argument_list|(
operator|(
name|ct_data
name|near
operator|*
operator|)
name|dyn_dtree
argument_list|,
name|dcodes
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* send the distance tree */
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"\ndist tree: sent %ld"
operator|,
name|bits_sent
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Determine the best encoding for the current block: dynamic trees, static  * trees or store, and output the encoded block to the zip file. This function  * returns the total compressed length for the file so far.  */
end_comment

begin_function
name|ulg
name|flush_block
parameter_list|(
name|buf
parameter_list|,
name|stored_len
parameter_list|,
name|eof
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* input block, or NULL if too old */
name|ulg
name|stored_len
decl_stmt|;
comment|/* length of input block */
name|int
name|eof
decl_stmt|;
comment|/* true if this is the last block for a file */
block|{
name|ulg
name|opt_lenb
decl_stmt|,
name|static_lenb
decl_stmt|;
comment|/* opt_len and static_len in bytes */
name|int
name|max_blindex
decl_stmt|;
comment|/* index of last bit length code of non zero freq */
name|flag_buf
index|[
name|last_flags
index|]
operator|=
name|flags
expr_stmt|;
comment|/* Save the flags for the last 8 items */
comment|/* Check if the file is ascii or binary */
if|if
condition|(
operator|*
name|file_type
operator|==
operator|(
name|ush
operator|)
name|UNKNOWN
condition|)
name|set_file_type
argument_list|()
expr_stmt|;
comment|/* Construct the literal and distance trees */
name|build_tree
argument_list|(
operator|(
name|tree_desc
name|near
operator|*
operator|)
operator|(
operator|&
name|l_desc
operator|)
argument_list|)
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"\nlit data: dyn %ld, stat %ld"
operator|,
name|opt_len
operator|,
name|static_len
operator|)
argument_list|)
expr_stmt|;
name|build_tree
argument_list|(
operator|(
name|tree_desc
name|near
operator|*
operator|)
operator|(
operator|&
name|d_desc
operator|)
argument_list|)
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"\ndist data: dyn %ld, stat %ld"
operator|,
name|opt_len
operator|,
name|static_len
operator|)
argument_list|)
expr_stmt|;
comment|/* At this point, opt_len and static_len are the total bit lengths of      * the compressed block data, excluding the tree representations.      */
comment|/* Build the bit length tree for the above two trees, and get the index      * in bl_order of the last bit length code to send.      */
name|max_blindex
operator|=
name|build_bl_tree
argument_list|()
expr_stmt|;
comment|/* Determine the best encoding. Compute first the block length in bytes */
name|opt_lenb
operator|=
operator|(
name|opt_len
operator|+
literal|3
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
name|static_lenb
operator|=
operator|(
name|static_len
operator|+
literal|3
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
name|input_len
operator|+=
name|stored_len
expr_stmt|;
comment|/* for debugging only */
name|Trace
argument_list|(
operator|(
name|stderr
operator|,
literal|"\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u dist %u "
operator|,
name|opt_lenb
operator|,
name|opt_len
operator|,
name|static_lenb
operator|,
name|static_len
operator|,
name|stored_len
operator|,
name|last_lit
operator|,
name|last_dist
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|static_lenb
operator|<=
name|opt_lenb
condition|)
name|opt_lenb
operator|=
name|static_lenb
expr_stmt|;
comment|/* If compression failed and this is the first and last block,      * and if the zip file can be seeked (to rewrite the local header),      * the whole file is transformed into a stored file:      */
ifdef|#
directive|ifdef
name|FORCE_METHOD
if|if
condition|(
name|level
operator|==
literal|1
operator|&&
name|eof
operator|&&
name|compressed_len
operator|==
literal|0L
condition|)
block|{
comment|/* force stored file */
else|#
directive|else
if|if
condition|(
name|stored_len
operator|<=
name|opt_lenb
operator|&&
name|eof
operator|&&
name|compressed_len
operator|==
literal|0L
operator|&&
name|seekable
argument_list|()
condition|)
block|{
endif|#
directive|endif
comment|/* Since LIT_BUFSIZE<= 2*WSIZE, the input data must be there: */
if|if
condition|(
name|buf
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|error
argument_list|(
literal|"block vanished"
argument_list|)
expr_stmt|;
name|copy_block
argument_list|(
name|buf
argument_list|,
operator|(
name|unsigned
operator|)
name|stored_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* without header */
name|compressed_len
operator|=
name|stored_len
operator|<<
literal|3
expr_stmt|;
operator|*
name|file_method
operator|=
name|STORED
expr_stmt|;
ifdef|#
directive|ifdef
name|FORCE_METHOD
block|}
elseif|else
if|if
condition|(
name|level
operator|==
literal|2
operator|&&
name|buf
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* force stored block */
else|#
directive|else
block|}
elseif|else
if|if
condition|(
name|stored_len
operator|+
literal|4
operator|<=
name|opt_lenb
operator|&&
name|buf
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* 4: two words for the lengths */
endif|#
directive|endif
comment|/* The test buf != NULL is only necessary if LIT_BUFSIZE> WSIZE.          * Otherwise we can't have processed more than WSIZE input bytes since          * the last block flush, because compression would have been          * successful. If LIT_BUFSIZE<= WSIZE, it is never too late to          * transform a block into a stored block.          */
name|send_bits
argument_list|(
operator|(
name|STORED_BLOCK
operator|<<
literal|1
operator|)
operator|+
name|eof
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* send block type */
name|compressed_len
operator|=
operator|(
name|compressed_len
operator|+
literal|3
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7L
expr_stmt|;
name|compressed_len
operator|+=
operator|(
name|stored_len
operator|+
literal|4
operator|)
operator|<<
literal|3
expr_stmt|;
name|copy_block
argument_list|(
name|buf
argument_list|,
operator|(
name|unsigned
operator|)
name|stored_len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* with header */
ifdef|#
directive|ifdef
name|FORCE_METHOD
block|}
elseif|else
if|if
condition|(
name|level
operator|==
literal|3
condition|)
block|{
comment|/* force static trees */
else|#
directive|else
block|}
elseif|else
if|if
condition|(
name|static_lenb
operator|==
name|opt_lenb
condition|)
block|{
endif|#
directive|endif
name|send_bits
argument_list|(
operator|(
name|STATIC_TREES
operator|<<
literal|1
operator|)
operator|+
name|eof
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|compress_block
argument_list|(
operator|(
name|ct_data
name|near
operator|*
operator|)
name|static_ltree
argument_list|,
operator|(
name|ct_data
name|near
operator|*
operator|)
name|static_dtree
argument_list|)
expr_stmt|;
name|compressed_len
operator|+=
literal|3
operator|+
name|static_len
expr_stmt|;
block|}
else|else
block|{
name|send_bits
argument_list|(
operator|(
name|DYN_TREES
operator|<<
literal|1
operator|)
operator|+
name|eof
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|send_all_trees
argument_list|(
name|l_desc
operator|.
name|max_code
operator|+
literal|1
argument_list|,
name|d_desc
operator|.
name|max_code
operator|+
literal|1
argument_list|,
name|max_blindex
operator|+
literal|1
argument_list|)
expr_stmt|;
name|compress_block
argument_list|(
operator|(
name|ct_data
name|near
operator|*
operator|)
name|dyn_ltree
argument_list|,
operator|(
name|ct_data
name|near
operator|*
operator|)
name|dyn_dtree
argument_list|)
expr_stmt|;
name|compressed_len
operator|+=
literal|3
operator|+
name|opt_len
expr_stmt|;
block|}
name|Assert
argument_list|(
name|compressed_len
operator|==
name|bits_sent
argument_list|,
literal|"bad compressed size"
argument_list|)
expr_stmt|;
name|init_block
argument_list|()
expr_stmt|;
if|if
condition|(
name|eof
condition|)
block|{
name|Assert
argument_list|(
name|input_len
operator|==
name|isize
argument_list|,
literal|"bad input size"
argument_list|)
expr_stmt|;
name|bi_windup
argument_list|()
expr_stmt|;
name|compressed_len
operator|+=
literal|7
expr_stmt|;
comment|/* align on byte boundary */
block|}
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"\ncomprlen %lu(%lu) "
operator|,
name|compressed_len
operator|>>
literal|3
operator|,
name|compressed_len
operator|-
literal|7
operator|*
name|eof
operator|)
argument_list|)
expr_stmt|;
return|return
name|compressed_len
operator|>>
literal|3
return|;
block|}
comment|/* ===========================================================================  * Save the match info and tally the frequency counts. Return true if  * the current block must be flushed.  */
name|int
name|ct_tally
parameter_list|(
name|dist
parameter_list|,
name|lc
parameter_list|)
name|int
name|dist
decl_stmt|;
comment|/* distance of matched string */
name|int
name|lc
decl_stmt|;
comment|/* match length-MIN_MATCH or unmatched char (if dist==0) */
block|{
name|l_buf
index|[
name|last_lit
operator|++
index|]
operator|=
operator|(
name|uch
operator|)
name|lc
expr_stmt|;
if|if
condition|(
name|dist
operator|==
literal|0
condition|)
block|{
comment|/* lc is the unmatched char */
name|dyn_ltree
index|[
name|lc
index|]
operator|.
name|Freq
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Here, lc is the match length - MIN_MATCH */
name|dist
operator|--
expr_stmt|;
comment|/* dist = match distance - 1 */
name|Assert
argument_list|(
operator|(
name|ush
operator|)
name|dist
operator|<
operator|(
name|ush
operator|)
name|MAX_DIST
operator|&&
operator|(
name|ush
operator|)
name|lc
operator|<=
call|(
name|ush
call|)
argument_list|(
name|MAX_MATCH
operator|-
name|MIN_MATCH
argument_list|)
operator|&&
operator|(
name|ush
operator|)
name|d_code
argument_list|(
name|dist
argument_list|)
operator|<
operator|(
name|ush
operator|)
name|D_CODES
argument_list|,
literal|"ct_tally: bad match"
argument_list|)
expr_stmt|;
name|dyn_ltree
index|[
name|length_code
index|[
name|lc
index|]
operator|+
name|LITERALS
operator|+
literal|1
index|]
operator|.
name|Freq
operator|++
expr_stmt|;
name|dyn_dtree
index|[
name|d_code
argument_list|(
name|dist
argument_list|)
index|]
operator|.
name|Freq
operator|++
expr_stmt|;
name|d_buf
index|[
name|last_dist
operator|++
index|]
operator|=
operator|(
name|ush
operator|)
name|dist
expr_stmt|;
name|flags
operator||=
name|flag_bit
expr_stmt|;
block|}
name|flag_bit
operator|<<=
literal|1
expr_stmt|;
comment|/* Output the flags if they fill a byte: */
if|if
condition|(
operator|(
name|last_lit
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
block|{
name|flag_buf
index|[
name|last_flags
operator|++
index|]
operator|=
name|flags
expr_stmt|;
name|flags
operator|=
literal|0
operator|,
name|flag_bit
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Try to guess if it is profitable to stop the current block here */
if|if
condition|(
name|level
operator|>
literal|2
operator|&&
operator|(
name|last_lit
operator|&
literal|0xfff
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Compute an upper bound for the compressed length */
name|ulg
name|out_length
init|=
operator|(
name|ulg
operator|)
name|last_lit
operator|*
literal|8L
decl_stmt|;
name|ulg
name|in_length
init|=
operator|(
name|ulg
operator|)
name|strstart
operator|-
name|block_start
decl_stmt|;
name|int
name|dcode
decl_stmt|;
for|for
control|(
name|dcode
operator|=
literal|0
init|;
name|dcode
operator|<
name|D_CODES
condition|;
name|dcode
operator|++
control|)
block|{
name|out_length
operator|+=
operator|(
name|ulg
operator|)
name|dyn_dtree
index|[
name|dcode
index|]
operator|.
name|Freq
operator|*
operator|(
literal|5L
operator|+
name|extra_dbits
index|[
name|dcode
index|]
operator|)
expr_stmt|;
block|}
name|out_length
operator|>>=
literal|3
expr_stmt|;
name|Trace
argument_list|(
operator|(
name|stderr
operator|,
literal|"\nlast_lit %u, last_dist %u, in %ld, out ~%ld(%ld%%) "
operator|,
name|last_lit
operator|,
name|last_dist
operator|,
name|in_length
operator|,
name|out_length
operator|,
literal|100L
operator|-
name|out_length
operator|*
literal|100L
operator|/
name|in_length
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_dist
operator|<
name|last_lit
operator|/
literal|2
operator|&&
name|out_length
operator|<
name|in_length
operator|/
literal|2
condition|)
return|return
literal|1
return|;
block|}
return|return
operator|(
name|last_lit
operator|==
name|LIT_BUFSIZE
operator|-
literal|1
operator|||
name|last_dist
operator|==
name|DIST_BUFSIZE
operator|)
return|;
comment|/* We avoid equality with LIT_BUFSIZE because of wraparound at 64K      * on 16 bit machines and because stored blocks are restricted to      * 64K-1 bytes.      */
block|}
comment|/* ===========================================================================  * Send the block data compressed using the given Huffman trees  */
name|local
name|void
name|compress_block
parameter_list|(
name|ltree
parameter_list|,
name|dtree
parameter_list|)
name|ct_data
name|near
modifier|*
name|ltree
decl_stmt|;
comment|/* literal tree */
name|ct_data
name|near
modifier|*
name|dtree
decl_stmt|;
comment|/* distance tree */
block|{
name|unsigned
name|dist
decl_stmt|;
comment|/* distance of matched string */
name|int
name|lc
decl_stmt|;
comment|/* match length or unmatched char (if dist == 0) */
name|unsigned
name|lx
init|=
literal|0
decl_stmt|;
comment|/* running index in l_buf */
name|unsigned
name|dx
init|=
literal|0
decl_stmt|;
comment|/* running index in d_buf */
name|unsigned
name|fx
init|=
literal|0
decl_stmt|;
comment|/* running index in flag_buf */
name|uch
name|flag
init|=
literal|0
decl_stmt|;
comment|/* current flags */
name|unsigned
name|code
decl_stmt|;
comment|/* the code to send */
name|int
name|extra
decl_stmt|;
comment|/* number of extra bits to send */
if|if
condition|(
name|last_lit
operator|!=
literal|0
condition|)
do|do
block|{
if|if
condition|(
operator|(
name|lx
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
name|flag
operator|=
name|flag_buf
index|[
name|fx
operator|++
index|]
expr_stmt|;
name|lc
operator|=
name|l_buf
index|[
name|lx
operator|++
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|send_code
argument_list|(
name|lc
argument_list|,
name|ltree
argument_list|)
expr_stmt|;
comment|/* send a literal byte */
name|Tracecv
argument_list|(
name|isgraph
argument_list|(
name|lc
argument_list|)
argument_list|,
operator|(
name|stderr
operator|,
literal|" '%c' "
operator|,
name|lc
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Here, lc is the match length - MIN_MATCH */
name|code
operator|=
name|length_code
index|[
name|lc
index|]
expr_stmt|;
name|send_code
argument_list|(
name|code
operator|+
name|LITERALS
operator|+
literal|1
argument_list|,
name|ltree
argument_list|)
expr_stmt|;
comment|/* send the length code */
name|extra
operator|=
name|extra_lbits
index|[
name|code
index|]
expr_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
block|{
name|lc
operator|-=
name|base_length
index|[
name|code
index|]
expr_stmt|;
name|send_bits
argument_list|(
name|lc
argument_list|,
name|extra
argument_list|)
expr_stmt|;
comment|/* send the extra length bits */
block|}
name|dist
operator|=
name|d_buf
index|[
name|dx
operator|++
index|]
expr_stmt|;
comment|/* Here, dist is the match distance - 1 */
name|code
operator|=
name|d_code
argument_list|(
name|dist
argument_list|)
expr_stmt|;
name|Assert
argument_list|(
name|code
operator|<
name|D_CODES
argument_list|,
literal|"bad d_code"
argument_list|)
expr_stmt|;
name|send_code
argument_list|(
name|code
argument_list|,
name|dtree
argument_list|)
expr_stmt|;
comment|/* send the distance code */
name|extra
operator|=
name|extra_dbits
index|[
name|code
index|]
expr_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
block|{
name|dist
operator|-=
name|base_dist
index|[
name|code
index|]
expr_stmt|;
name|send_bits
argument_list|(
name|dist
argument_list|,
name|extra
argument_list|)
expr_stmt|;
comment|/* send the extra distance bits */
block|}
block|}
comment|/* literal or match pair ? */
name|flag
operator|>>=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|lx
operator|<
name|last_lit
condition|)
do|;
name|send_code
argument_list|(
name|END_BLOCK
argument_list|,
name|ltree
argument_list|)
expr_stmt|;
block|}
comment|/* ===========================================================================  * Set the file type to ASCII or BINARY, using a crude approximation:  * binary if more than 20% of the bytes are<= 6 or>= 128, ascii otherwise.  * IN assertion: the fields freq of dyn_ltree are set and the total of all  * frequencies does not exceed 64K (to fit in an int on 16 bit machines).  */
name|local
name|void
name|set_file_type
parameter_list|()
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|unsigned
name|ascii_freq
init|=
literal|0
decl_stmt|;
name|unsigned
name|bin_freq
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|n
operator|<
literal|7
condition|)
name|bin_freq
operator|+=
name|dyn_ltree
index|[
name|n
operator|++
index|]
operator|.
name|Freq
expr_stmt|;
while|while
condition|(
name|n
operator|<
literal|128
condition|)
name|ascii_freq
operator|+=
name|dyn_ltree
index|[
name|n
operator|++
index|]
operator|.
name|Freq
expr_stmt|;
while|while
condition|(
name|n
operator|<
name|LITERALS
condition|)
name|bin_freq
operator|+=
name|dyn_ltree
index|[
name|n
operator|++
index|]
operator|.
name|Freq
expr_stmt|;
operator|*
name|file_type
operator|=
name|bin_freq
operator|>
operator|(
name|ascii_freq
operator|>>
literal|2
operator|)
condition|?
name|BINARY
else|:
name|ASCII
expr_stmt|;
if|if
condition|(
operator|*
name|file_type
operator|==
name|BINARY
operator|&&
name|translate_eol
condition|)
block|{
name|WARN
argument_list|(
operator|(
name|stderr
operator|,
literal|"-l used on binary file"
operator|,
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

