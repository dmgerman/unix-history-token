begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $RCSfile: hash.c,v $$Revision: 1.2 $$Date: 1995/05/30 05:03:07 $  *  *    Copyright (c) 1991, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  * $Log: hash.c,v $  * Revision 1.2  1995/05/30 05:03:07  rgrimes  * Remove trailing whitespace.  *  * Revision 1.1.1.1  1994/09/10  06:27:33  gclarkii  * Initial import of Perl 4.046 bmaked  *  * Revision 1.1.1.1  1993/08/23  21:29:37  nate  * PERL!  *  * Revision 4.0.1.3  92/06/08  13:26:29  lwall  * patch20: removed implicit int declarations on functions  * patch20: delete could cause %array to give too low a count of buckets filled  * patch20: hash tables now split only if the memory is available to do so  *  * Revision 4.0.1.2  91/11/05  17:24:13  lwall  * patch11: saberized perl  *  * Revision 4.0.1.1  91/06/07  11:10:11  lwall  * patch4: new copyright notice  *  * Revision 4.0  91/03/20  01:22:26  lwall  * 4.0 baseline.  *  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_function_decl
specifier|static
name|void
name|hsplit
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
name|coeff
index|[]
init|=
block|{
literal|61
block|,
literal|59
block|,
literal|53
block|,
literal|47
block|,
literal|43
block|,
literal|41
block|,
literal|37
block|,
literal|31
block|,
literal|29
block|,
literal|23
block|,
literal|17
block|,
literal|13
block|,
literal|11
block|,
literal|7
block|,
literal|3
block|,
literal|1
block|,
literal|61
block|,
literal|59
block|,
literal|53
block|,
literal|47
block|,
literal|43
block|,
literal|41
block|,
literal|37
block|,
literal|31
block|,
literal|29
block|,
literal|23
block|,
literal|17
block|,
literal|13
block|,
literal|11
block|,
literal|7
block|,
literal|3
block|,
literal|1
block|,
literal|61
block|,
literal|59
block|,
literal|53
block|,
literal|47
block|,
literal|43
block|,
literal|41
block|,
literal|37
block|,
literal|31
block|,
literal|29
block|,
literal|23
block|,
literal|17
block|,
literal|13
block|,
literal|11
block|,
literal|7
block|,
literal|3
block|,
literal|1
block|,
literal|61
block|,
literal|59
block|,
literal|53
block|,
literal|47
block|,
literal|43
block|,
literal|41
block|,
literal|37
block|,
literal|31
block|,
literal|29
block|,
literal|23
block|,
literal|17
block|,
literal|13
block|,
literal|11
block|,
literal|7
block|,
literal|3
block|,
literal|1
block|,
literal|61
block|,
literal|59
block|,
literal|53
block|,
literal|47
block|,
literal|43
block|,
literal|41
block|,
literal|37
block|,
literal|31
block|,
literal|29
block|,
literal|23
block|,
literal|17
block|,
literal|13
block|,
literal|11
block|,
literal|7
block|,
literal|3
block|,
literal|1
block|,
literal|61
block|,
literal|59
block|,
literal|53
block|,
literal|47
block|,
literal|43
block|,
literal|41
block|,
literal|37
block|,
literal|31
block|,
literal|29
block|,
literal|23
block|,
literal|17
block|,
literal|13
block|,
literal|11
block|,
literal|7
block|,
literal|3
block|,
literal|1
block|,
literal|61
block|,
literal|59
block|,
literal|53
block|,
literal|47
block|,
literal|43
block|,
literal|41
block|,
literal|37
block|,
literal|31
block|,
literal|29
block|,
literal|23
block|,
literal|17
block|,
literal|13
block|,
literal|11
block|,
literal|7
block|,
literal|3
block|,
literal|1
block|,
literal|61
block|,
literal|59
block|,
literal|53
block|,
literal|47
block|,
literal|43
block|,
literal|41
block|,
literal|37
block|,
literal|31
block|,
literal|29
block|,
literal|23
block|,
literal|17
block|,
literal|13
block|,
literal|11
block|,
literal|7
block|,
literal|3
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|hfreeentries
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|STR
modifier|*
name|hfetch
parameter_list|(
name|tb
parameter_list|,
name|key
parameter_list|,
name|klen
parameter_list|,
name|lval
parameter_list|)
specifier|register
name|HASH
modifier|*
name|tb
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|unsigned
name|int
name|klen
decl_stmt|;
name|int
name|lval
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|hash
decl_stmt|;
specifier|register
name|HENT
modifier|*
name|entry
decl_stmt|;
specifier|register
name|int
name|maxi
decl_stmt|;
name|STR
modifier|*
name|str
decl_stmt|;
ifdef|#
directive|ifdef
name|SOME_DBM
name|datum
name|dkey
decl_stmt|,
name|dcontent
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|tb
condition|)
return|return
operator|&
name|str_undef
return|;
if|if
condition|(
operator|!
name|tb
operator|->
name|tbl_array
condition|)
block|{
if|if
condition|(
name|lval
condition|)
name|Newz
argument_list|(
literal|503
argument_list|,
name|tb
operator|->
name|tbl_array
argument_list|,
name|tb
operator|->
name|tbl_max
operator|+
literal|1
argument_list|,
name|HENT
operator|*
argument_list|)
expr_stmt|;
else|else
return|return
operator|&
name|str_undef
return|;
block|}
comment|/* The hash function we use on symbols has to be equal to the first      * character when taken modulo 128, so that str_reset() can be implemented      * efficiently.  We throw in the second character and the last character      * (times 128) so that long chains of identifiers starting with the      * same letter don't have to be strEQ'ed within hfetch(), since it      * compares hash values before trying strEQ().      */
if|if
condition|(
operator|!
name|tb
operator|->
name|tbl_coeffsize
condition|)
name|hash
operator|=
operator|*
name|key
operator|+
literal|128
operator|*
name|key
index|[
literal|1
index|]
operator|+
literal|128
operator|*
name|key
index|[
name|klen
operator|-
literal|1
index|]
expr_stmt|;
comment|/* assuming klen> 0 */
else|else
block|{
comment|/* use normal coefficients */
if|if
condition|(
name|klen
operator|<
name|tb
operator|->
name|tbl_coeffsize
condition|)
name|maxi
operator|=
name|klen
expr_stmt|;
else|else
name|maxi
operator|=
name|tb
operator|->
name|tbl_coeffsize
expr_stmt|;
for|for
control|(
name|s
operator|=
name|key
operator|,
name|i
operator|=
literal|0
operator|,
name|hash
operator|=
literal|0
init|;
name|i
operator|<
name|maxi
condition|;
comment|/*SUPPRESS 8*/
name|s
operator|++
operator|,
name|i
operator|++
operator|,
name|hash
operator|*=
literal|5
control|)
block|{
name|hash
operator|+=
operator|*
name|s
operator|*
name|coeff
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|entry
operator|=
name|tb
operator|->
name|tbl_array
index|[
name|hash
operator|&
name|tb
operator|->
name|tbl_max
index|]
expr_stmt|;
for|for
control|(
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|hent_next
control|)
block|{
if|if
condition|(
name|entry
operator|->
name|hent_hash
operator|!=
name|hash
condition|)
comment|/* strings can't be equal */
continue|continue;
if|if
condition|(
name|entry
operator|->
name|hent_klen
operator|!=
name|klen
condition|)
continue|continue;
if|if
condition|(
name|bcmp
argument_list|(
name|entry
operator|->
name|hent_key
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
condition|)
comment|/* is this it? */
continue|continue;
return|return
name|entry
operator|->
name|hent_val
return|;
block|}
ifdef|#
directive|ifdef
name|SOME_DBM
if|if
condition|(
name|tb
operator|->
name|tbl_dbm
condition|)
block|{
name|dkey
operator|.
name|dptr
operator|=
name|key
expr_stmt|;
name|dkey
operator|.
name|dsize
operator|=
name|klen
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_GDBM
name|dcontent
operator|=
name|gdbm_fetch
argument_list|(
name|tb
operator|->
name|tbl_dbm
argument_list|,
name|dkey
argument_list|)
expr_stmt|;
else|#
directive|else
name|dcontent
operator|=
name|dbm_fetch
argument_list|(
name|tb
operator|->
name|tbl_dbm
argument_list|,
name|dkey
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dcontent
operator|.
name|dptr
condition|)
block|{
comment|/* found one */
name|str
operator|=
name|Str_new
argument_list|(
literal|60
argument_list|,
name|dcontent
operator|.
name|dsize
argument_list|)
expr_stmt|;
name|str_nset
argument_list|(
name|str
argument_list|,
name|dcontent
operator|.
name|dptr
argument_list|,
name|dcontent
operator|.
name|dsize
argument_list|)
expr_stmt|;
name|hstore
argument_list|(
name|tb
argument_list|,
name|key
argument_list|,
name|klen
argument_list|,
name|str
argument_list|,
name|hash
argument_list|)
expr_stmt|;
comment|/* cache it */
return|return
name|str
return|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|lval
condition|)
block|{
comment|/* gonna assign to this, so it better be there */
name|str
operator|=
name|Str_new
argument_list|(
literal|61
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hstore
argument_list|(
name|tb
argument_list|,
name|key
argument_list|,
name|klen
argument_list|,
name|str
argument_list|,
name|hash
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
return|return
operator|&
name|str_undef
return|;
block|}
end_function

begin_function
name|bool
name|hstore
parameter_list|(
name|tb
parameter_list|,
name|key
parameter_list|,
name|klen
parameter_list|,
name|val
parameter_list|,
name|hash
parameter_list|)
specifier|register
name|HASH
modifier|*
name|tb
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|unsigned
name|int
name|klen
decl_stmt|;
name|STR
modifier|*
name|val
decl_stmt|;
specifier|register
name|int
name|hash
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|HENT
modifier|*
name|entry
decl_stmt|;
specifier|register
name|HENT
modifier|*
modifier|*
name|oentry
decl_stmt|;
specifier|register
name|int
name|maxi
decl_stmt|;
if|if
condition|(
operator|!
name|tb
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|hash
condition|)
comment|/*SUPPRESS 530*/
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|tb
operator|->
name|tbl_coeffsize
condition|)
name|hash
operator|=
operator|*
name|key
operator|+
literal|128
operator|*
name|key
index|[
literal|1
index|]
operator|+
literal|128
operator|*
name|key
index|[
name|klen
operator|-
literal|1
index|]
expr_stmt|;
else|else
block|{
comment|/* use normal coefficients */
if|if
condition|(
name|klen
operator|<
name|tb
operator|->
name|tbl_coeffsize
condition|)
name|maxi
operator|=
name|klen
expr_stmt|;
else|else
name|maxi
operator|=
name|tb
operator|->
name|tbl_coeffsize
expr_stmt|;
for|for
control|(
name|s
operator|=
name|key
operator|,
name|i
operator|=
literal|0
operator|,
name|hash
operator|=
literal|0
init|;
name|i
operator|<
name|maxi
condition|;
comment|/*SUPPRESS 8*/
name|s
operator|++
operator|,
name|i
operator|++
operator|,
name|hash
operator|*=
literal|5
control|)
block|{
name|hash
operator|+=
operator|*
name|s
operator|*
name|coeff
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|tb
operator|->
name|tbl_array
condition|)
name|Newz
argument_list|(
literal|505
argument_list|,
name|tb
operator|->
name|tbl_array
argument_list|,
name|tb
operator|->
name|tbl_max
operator|+
literal|1
argument_list|,
name|HENT
operator|*
argument_list|)
expr_stmt|;
name|oentry
operator|=
operator|&
operator|(
name|tb
operator|->
name|tbl_array
index|[
name|hash
operator|&
name|tb
operator|->
name|tbl_max
index|]
operator|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|entry
operator|=
operator|*
name|oentry
init|;
name|entry
condition|;
name|i
operator|=
literal|0
operator|,
name|entry
operator|=
name|entry
operator|->
name|hent_next
control|)
block|{
if|if
condition|(
name|entry
operator|->
name|hent_hash
operator|!=
name|hash
condition|)
comment|/* strings can't be equal */
continue|continue;
if|if
condition|(
name|entry
operator|->
name|hent_klen
operator|!=
name|klen
condition|)
continue|continue;
if|if
condition|(
name|bcmp
argument_list|(
name|entry
operator|->
name|hent_key
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
condition|)
comment|/* is this it? */
continue|continue;
name|Safefree
argument_list|(
name|entry
operator|->
name|hent_val
argument_list|)
expr_stmt|;
name|entry
operator|->
name|hent_val
operator|=
name|val
expr_stmt|;
return|return
name|TRUE
return|;
block|}
name|New
argument_list|(
literal|501
argument_list|,
name|entry
argument_list|,
literal|1
argument_list|,
name|HENT
argument_list|)
expr_stmt|;
name|entry
operator|->
name|hent_klen
operator|=
name|klen
expr_stmt|;
name|entry
operator|->
name|hent_key
operator|=
name|nsavestr
argument_list|(
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|entry
operator|->
name|hent_val
operator|=
name|val
expr_stmt|;
name|entry
operator|->
name|hent_hash
operator|=
name|hash
expr_stmt|;
name|entry
operator|->
name|hent_next
operator|=
operator|*
name|oentry
expr_stmt|;
operator|*
name|oentry
operator|=
name|entry
expr_stmt|;
comment|/* hdbmstore not necessary here because it's called from stabset() */
if|if
condition|(
name|i
condition|)
block|{
comment|/* initial entry? */
name|tb
operator|->
name|tbl_fill
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SOME_DBM
if|if
condition|(
name|tb
operator|->
name|tbl_dbm
operator|&&
name|tb
operator|->
name|tbl_max
operator|>=
name|DBM_CACHE_MAX
condition|)
return|return
name|FALSE
return|;
endif|#
directive|endif
if|if
condition|(
name|tb
operator|->
name|tbl_fill
operator|>
name|tb
operator|->
name|tbl_dosplit
condition|)
name|hsplit
argument_list|(
name|tb
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SOME_DBM
elseif|else
if|if
condition|(
name|tb
operator|->
name|tbl_dbm
condition|)
block|{
comment|/* is this just a cache for dbm file? */
name|void
name|hentdelayfree
parameter_list|()
function_decl|;
name|entry
operator|=
name|tb
operator|->
name|tbl_array
index|[
name|hash
operator|&
name|tb
operator|->
name|tbl_max
index|]
expr_stmt|;
name|oentry
operator|=
operator|&
name|entry
operator|->
name|hent_next
expr_stmt|;
name|entry
operator|=
operator|*
name|oentry
expr_stmt|;
while|while
condition|(
name|entry
condition|)
block|{
comment|/* trim chain down to 1 entry */
operator|*
name|oentry
operator|=
name|entry
operator|->
name|hent_next
expr_stmt|;
name|hentdelayfree
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* no doubt they'll want this next. */
name|entry
operator|=
operator|*
name|oentry
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|STR
modifier|*
name|hdelete
parameter_list|(
name|tb
parameter_list|,
name|key
parameter_list|,
name|klen
parameter_list|)
specifier|register
name|HASH
modifier|*
name|tb
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|unsigned
name|int
name|klen
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|hash
decl_stmt|;
specifier|register
name|HENT
modifier|*
name|entry
decl_stmt|;
specifier|register
name|HENT
modifier|*
modifier|*
name|oentry
decl_stmt|;
name|STR
modifier|*
name|str
decl_stmt|;
name|int
name|maxi
decl_stmt|;
ifdef|#
directive|ifdef
name|SOME_DBM
name|datum
name|dkey
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|tb
operator|||
operator|!
name|tb
operator|->
name|tbl_array
condition|)
return|return
name|Nullstr
return|;
if|if
condition|(
operator|!
name|tb
operator|->
name|tbl_coeffsize
condition|)
name|hash
operator|=
operator|*
name|key
operator|+
literal|128
operator|*
name|key
index|[
literal|1
index|]
operator|+
literal|128
operator|*
name|key
index|[
name|klen
operator|-
literal|1
index|]
expr_stmt|;
else|else
block|{
comment|/* use normal coefficients */
if|if
condition|(
name|klen
operator|<
name|tb
operator|->
name|tbl_coeffsize
condition|)
name|maxi
operator|=
name|klen
expr_stmt|;
else|else
name|maxi
operator|=
name|tb
operator|->
name|tbl_coeffsize
expr_stmt|;
for|for
control|(
name|s
operator|=
name|key
operator|,
name|i
operator|=
literal|0
operator|,
name|hash
operator|=
literal|0
init|;
name|i
operator|<
name|maxi
condition|;
comment|/*SUPPRESS 8*/
name|s
operator|++
operator|,
name|i
operator|++
operator|,
name|hash
operator|*=
literal|5
control|)
block|{
name|hash
operator|+=
operator|*
name|s
operator|*
name|coeff
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|oentry
operator|=
operator|&
operator|(
name|tb
operator|->
name|tbl_array
index|[
name|hash
operator|&
name|tb
operator|->
name|tbl_max
index|]
operator|)
expr_stmt|;
name|entry
operator|=
operator|*
name|oentry
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|entry
condition|;
name|i
operator|=
literal|0
operator|,
name|oentry
operator|=
operator|&
name|entry
operator|->
name|hent_next
operator|,
name|entry
operator|=
operator|*
name|oentry
control|)
block|{
if|if
condition|(
name|entry
operator|->
name|hent_hash
operator|!=
name|hash
condition|)
comment|/* strings can't be equal */
continue|continue;
if|if
condition|(
name|entry
operator|->
name|hent_klen
operator|!=
name|klen
condition|)
continue|continue;
if|if
condition|(
name|bcmp
argument_list|(
name|entry
operator|->
name|hent_key
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
condition|)
comment|/* is this it? */
continue|continue;
operator|*
name|oentry
operator|=
name|entry
operator|->
name|hent_next
expr_stmt|;
if|if
condition|(
name|i
operator|&&
operator|!
operator|*
name|oentry
condition|)
name|tb
operator|->
name|tbl_fill
operator|--
expr_stmt|;
name|str
operator|=
name|str_mortal
argument_list|(
name|entry
operator|->
name|hent_val
argument_list|)
expr_stmt|;
name|hentfree
argument_list|(
name|entry
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOME_DBM
name|do_dbm_delete
label|:
if|if
condition|(
name|tb
operator|->
name|tbl_dbm
condition|)
block|{
name|dkey
operator|.
name|dptr
operator|=
name|key
expr_stmt|;
name|dkey
operator|.
name|dsize
operator|=
name|klen
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_GDBM
name|gdbm_delete
argument_list|(
name|tb
operator|->
name|tbl_dbm
argument_list|,
name|dkey
argument_list|)
expr_stmt|;
else|#
directive|else
name|dbm_delete
argument_list|(
name|tb
operator|->
name|tbl_dbm
argument_list|,
name|dkey
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
return|return
name|str
return|;
block|}
ifdef|#
directive|ifdef
name|SOME_DBM
name|str
operator|=
name|Nullstr
expr_stmt|;
goto|goto
name|do_dbm_delete
goto|;
else|#
directive|else
return|return
name|Nullstr
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|hsplit
parameter_list|(
name|tb
parameter_list|)
name|HASH
modifier|*
name|tb
decl_stmt|;
block|{
name|int
name|oldsize
init|=
name|tb
operator|->
name|tbl_max
operator|+
literal|1
decl_stmt|;
specifier|register
name|int
name|newsize
init|=
name|oldsize
operator|*
literal|2
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|HENT
modifier|*
modifier|*
name|a
decl_stmt|;
specifier|register
name|HENT
modifier|*
modifier|*
name|b
decl_stmt|;
specifier|register
name|HENT
modifier|*
name|entry
decl_stmt|;
specifier|register
name|HENT
modifier|*
modifier|*
name|oentry
decl_stmt|;
name|a
operator|=
name|tb
operator|->
name|tbl_array
expr_stmt|;
name|nomemok
operator|=
name|TRUE
expr_stmt|;
name|Renew
argument_list|(
name|a
argument_list|,
name|newsize
argument_list|,
name|HENT
operator|*
argument_list|)
expr_stmt|;
name|nomemok
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
block|{
name|tb
operator|->
name|tbl_dosplit
operator|=
name|tb
operator|->
name|tbl_max
operator|+
literal|1
expr_stmt|;
comment|/* never split again */
return|return;
block|}
name|Zero
argument_list|(
operator|&
name|a
index|[
name|oldsize
index|]
argument_list|,
name|oldsize
argument_list|,
name|HENT
operator|*
argument_list|)
expr_stmt|;
comment|/* zero 2nd half*/
name|tb
operator|->
name|tbl_max
operator|=
operator|--
name|newsize
expr_stmt|;
name|tb
operator|->
name|tbl_dosplit
operator|=
name|tb
operator|->
name|tbl_max
operator|*
name|FILLPCT
operator|/
literal|100
expr_stmt|;
name|tb
operator|->
name|tbl_array
operator|=
name|a
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldsize
condition|;
name|i
operator|++
operator|,
name|a
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|a
condition|)
comment|/* non-existent */
continue|continue;
name|b
operator|=
name|a
operator|+
name|oldsize
expr_stmt|;
for|for
control|(
name|oentry
operator|=
name|a
operator|,
name|entry
operator|=
operator|*
name|a
init|;
name|entry
condition|;
name|entry
operator|=
operator|*
name|oentry
control|)
block|{
if|if
condition|(
operator|(
name|entry
operator|->
name|hent_hash
operator|&
name|newsize
operator|)
operator|!=
name|i
condition|)
block|{
operator|*
name|oentry
operator|=
name|entry
operator|->
name|hent_next
expr_stmt|;
name|entry
operator|->
name|hent_next
operator|=
operator|*
name|b
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|b
condition|)
name|tb
operator|->
name|tbl_fill
operator|++
expr_stmt|;
operator|*
name|b
operator|=
name|entry
expr_stmt|;
continue|continue;
block|}
else|else
name|oentry
operator|=
operator|&
name|entry
operator|->
name|hent_next
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|a
condition|)
comment|/* everything moved */
name|tb
operator|->
name|tbl_fill
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
name|HASH
modifier|*
name|hnew
parameter_list|(
name|lookat
parameter_list|)
name|unsigned
name|int
name|lookat
decl_stmt|;
block|{
specifier|register
name|HASH
modifier|*
name|tb
decl_stmt|;
name|Newz
argument_list|(
literal|502
argument_list|,
name|tb
argument_list|,
literal|1
argument_list|,
name|HASH
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookat
condition|)
block|{
name|tb
operator|->
name|tbl_coeffsize
operator|=
name|lookat
expr_stmt|;
name|tb
operator|->
name|tbl_max
operator|=
literal|7
expr_stmt|;
comment|/* it's a normal associative array */
name|tb
operator|->
name|tbl_dosplit
operator|=
name|tb
operator|->
name|tbl_max
operator|*
name|FILLPCT
operator|/
literal|100
expr_stmt|;
block|}
else|else
block|{
name|tb
operator|->
name|tbl_max
operator|=
literal|127
expr_stmt|;
comment|/* it's a symbol table */
name|tb
operator|->
name|tbl_dosplit
operator|=
literal|128
expr_stmt|;
comment|/* so never split */
block|}
name|tb
operator|->
name|tbl_fill
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SOME_DBM
name|tb
operator|->
name|tbl_dbm
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|hiterinit
argument_list|(
name|tb
argument_list|)
expr_stmt|;
comment|/* so each() will start off right */
return|return
name|tb
return|;
block|}
end_function

begin_function
name|void
name|hentfree
parameter_list|(
name|hent
parameter_list|)
specifier|register
name|HENT
modifier|*
name|hent
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|hent
condition|)
return|return;
name|str_free
argument_list|(
name|hent
operator|->
name|hent_val
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|hent
operator|->
name|hent_key
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|hent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|hentdelayfree
parameter_list|(
name|hent
parameter_list|)
specifier|register
name|HENT
modifier|*
name|hent
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|hent
condition|)
return|return;
name|str_2mortal
argument_list|(
name|hent
operator|->
name|hent_val
argument_list|)
expr_stmt|;
comment|/* free between statements */
name|Safefree
argument_list|(
name|hent
operator|->
name|hent_key
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|hent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|hclear
parameter_list|(
name|tb
parameter_list|,
name|dodbm
parameter_list|)
specifier|register
name|HASH
modifier|*
name|tb
decl_stmt|;
name|int
name|dodbm
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|tb
condition|)
return|return;
name|hfreeentries
argument_list|(
name|tb
argument_list|,
name|dodbm
argument_list|)
expr_stmt|;
name|tb
operator|->
name|tbl_fill
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
if|if
condition|(
name|tb
operator|->
name|tbl_array
condition|)
operator|(
name|void
operator|)
name|memzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tb
operator|->
name|tbl_array
argument_list|,
operator|(
name|tb
operator|->
name|tbl_max
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|HENT
operator|*
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|hfreeentries
parameter_list|(
name|tb
parameter_list|,
name|dodbm
parameter_list|)
specifier|register
name|HASH
modifier|*
name|tb
decl_stmt|;
name|int
name|dodbm
decl_stmt|;
block|{
specifier|register
name|HENT
modifier|*
name|hent
decl_stmt|;
specifier|register
name|HENT
modifier|*
name|ohent
init|=
name|Null
argument_list|(
name|HENT
operator|*
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|SOME_DBM
name|datum
name|dkey
decl_stmt|;
name|datum
name|nextdkey
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_GDBM
name|GDBM_FILE
name|old_dbm
decl_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_NDBM
name|DBM
modifier|*
name|old_dbm
decl_stmt|;
else|#
directive|else
name|int
name|old_dbm
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
operator|!
name|tb
operator|||
operator|!
name|tb
operator|->
name|tbl_array
condition|)
return|return;
ifdef|#
directive|ifdef
name|SOME_DBM
if|if
condition|(
operator|(
name|old_dbm
operator|=
name|tb
operator|->
name|tbl_dbm
operator|)
operator|&&
name|dodbm
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_GDBM
while|while
condition|(
name|dkey
operator|=
name|gdbm_firstkey
argument_list|(
name|tb
operator|->
name|tbl_dbm
argument_list|)
operator|,
name|dkey
operator|.
name|dptr
condition|)
block|{
else|#
directive|else
while|while
condition|(
name|dkey
operator|=
name|dbm_firstkey
argument_list|(
name|tb
operator|->
name|tbl_dbm
argument_list|)
operator|,
name|dkey
operator|.
name|dptr
condition|)
block|{
endif|#
directive|endif
do|do
block|{
ifdef|#
directive|ifdef
name|HAS_GDBM
name|nextdkey
operator|=
name|gdbm_nextkey
argument_list|(
name|tb
operator|->
name|tbl_dbm
argument_list|,
name|dkey
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_NDBM
ifdef|#
directive|ifdef
name|_CX_UX
name|nextdkey
operator|=
name|dbm_nextkey
argument_list|(
name|tb
operator|->
name|tbl_dbm
argument_list|,
name|dkey
argument_list|)
expr_stmt|;
else|#
directive|else
name|nextdkey
operator|=
name|dbm_nextkey
argument_list|(
name|tb
operator|->
name|tbl_dbm
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|nextdkey
operator|=
name|nextkey
argument_list|(
name|dkey
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_GDBM
name|gdbm_delete
argument_list|(
name|tb
operator|->
name|tbl_dbm
argument_list|,
name|dkey
argument_list|)
expr_stmt|;
else|#
directive|else
name|dbm_delete
argument_list|(
name|tb
operator|->
name|tbl_dbm
argument_list|,
name|dkey
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dkey
operator|=
name|nextdkey
expr_stmt|;
block|}
do|while
condition|(
name|dkey
operator|.
name|dptr
condition|)
do|;
comment|/* one way or another, this works */
block|}
block|}
name|tb
operator|->
name|tbl_dbm
operator|=
literal|0
expr_stmt|;
comment|/* now clear just cache */
endif|#
directive|endif
operator|(
name|void
operator|)
name|hiterinit
argument_list|(
name|tb
argument_list|)
expr_stmt|;
comment|/*SUPPRESS 560*/
while|while
condition|(
name|hent
operator|=
name|hiternext
argument_list|(
name|tb
argument_list|)
condition|)
block|{
comment|/* concise but not very efficient */
name|hentfree
argument_list|(
name|ohent
argument_list|)
expr_stmt|;
name|ohent
operator|=
name|hent
expr_stmt|;
block|}
name|hentfree
argument_list|(
name|ohent
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOME_DBM
name|tb
operator|->
name|tbl_dbm
operator|=
name|old_dbm
expr_stmt|;
endif|#
directive|endif
block|}
name|void
name|hfree
parameter_list|(
name|tb
parameter_list|,
name|dodbm
parameter_list|)
specifier|register
name|HASH
modifier|*
name|tb
decl_stmt|;
name|int
name|dodbm
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|tb
condition|)
return|return;
name|hfreeentries
argument_list|(
name|tb
argument_list|,
name|dodbm
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|tb
operator|->
name|tbl_array
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|tb
argument_list|)
expr_stmt|;
block|}
name|int
name|hiterinit
parameter_list|(
name|tb
parameter_list|)
specifier|register
name|HASH
modifier|*
name|tb
decl_stmt|;
block|{
name|tb
operator|->
name|tbl_riter
operator|=
operator|-
literal|1
expr_stmt|;
name|tb
operator|->
name|tbl_eiter
operator|=
name|Null
argument_list|(
name|HENT
operator|*
argument_list|)
expr_stmt|;
return|return
name|tb
operator|->
name|tbl_fill
return|;
block|}
name|HENT
modifier|*
name|hiternext
parameter_list|(
name|tb
parameter_list|)
specifier|register
name|HASH
modifier|*
name|tb
decl_stmt|;
block|{
specifier|register
name|HENT
modifier|*
name|entry
decl_stmt|;
ifdef|#
directive|ifdef
name|SOME_DBM
name|datum
name|key
decl_stmt|;
endif|#
directive|endif
name|entry
operator|=
name|tb
operator|->
name|tbl_eiter
expr_stmt|;
ifdef|#
directive|ifdef
name|SOME_DBM
if|if
condition|(
name|tb
operator|->
name|tbl_dbm
condition|)
block|{
if|if
condition|(
name|entry
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_GDBM
name|key
operator|.
name|dptr
operator|=
name|entry
operator|->
name|hent_key
expr_stmt|;
name|key
operator|.
name|dsize
operator|=
name|entry
operator|->
name|hent_klen
expr_stmt|;
name|key
operator|=
name|gdbm_nextkey
argument_list|(
name|tb
operator|->
name|tbl_dbm
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_NDBM
ifdef|#
directive|ifdef
name|_CX_UX
name|key
operator|.
name|dptr
operator|=
name|entry
operator|->
name|hent_key
expr_stmt|;
name|key
operator|.
name|dsize
operator|=
name|entry
operator|->
name|hent_klen
expr_stmt|;
name|key
operator|=
name|dbm_nextkey
argument_list|(
name|tb
operator|->
name|tbl_dbm
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|#
directive|else
name|key
operator|=
name|dbm_nextkey
argument_list|(
name|tb
operator|->
name|tbl_dbm
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _CX_UX */
else|#
directive|else
name|key
operator|.
name|dptr
operator|=
name|entry
operator|->
name|hent_key
expr_stmt|;
name|key
operator|.
name|dsize
operator|=
name|entry
operator|->
name|hent_klen
expr_stmt|;
name|key
operator|=
name|nextkey
argument_list|(
name|key
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
else|else
block|{
name|Newz
argument_list|(
literal|504
argument_list|,
name|entry
argument_list|,
literal|1
argument_list|,
name|HENT
argument_list|)
expr_stmt|;
name|tb
operator|->
name|tbl_eiter
operator|=
name|entry
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_GDBM
name|key
operator|=
name|gdbm_firstkey
argument_list|(
name|tb
operator|->
name|tbl_dbm
argument_list|)
expr_stmt|;
else|#
directive|else
name|key
operator|=
name|dbm_firstkey
argument_list|(
name|tb
operator|->
name|tbl_dbm
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|entry
operator|->
name|hent_key
operator|=
name|key
operator|.
name|dptr
expr_stmt|;
name|entry
operator|->
name|hent_klen
operator|=
name|key
operator|.
name|dsize
expr_stmt|;
if|if
condition|(
operator|!
name|key
operator|.
name|dptr
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|hent_val
condition|)
name|str_free
argument_list|(
name|entry
operator|->
name|hent_val
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|tb
operator|->
name|tbl_eiter
operator|=
name|Null
argument_list|(
name|HENT
operator|*
argument_list|)
expr_stmt|;
return|return
name|Null
argument_list|(
name|HENT
operator|*
argument_list|)
return|;
block|}
return|return
name|entry
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|tb
operator|->
name|tbl_array
condition|)
name|Newz
argument_list|(
literal|506
argument_list|,
name|tb
operator|->
name|tbl_array
argument_list|,
name|tb
operator|->
name|tbl_max
operator|+
literal|1
argument_list|,
name|HENT
operator|*
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|entry
condition|)
name|entry
operator|=
name|entry
operator|->
name|hent_next
expr_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
block|{
name|tb
operator|->
name|tbl_riter
operator|++
expr_stmt|;
if|if
condition|(
name|tb
operator|->
name|tbl_riter
operator|>
name|tb
operator|->
name|tbl_max
condition|)
block|{
name|tb
operator|->
name|tbl_riter
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|entry
operator|=
name|tb
operator|->
name|tbl_array
index|[
name|tb
operator|->
name|tbl_riter
index|]
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|entry
condition|)
do|;
name|tb
operator|->
name|tbl_eiter
operator|=
name|entry
expr_stmt|;
return|return
name|entry
return|;
block|}
name|char
modifier|*
name|hiterkey
parameter_list|(
name|entry
parameter_list|,
name|retlen
parameter_list|)
specifier|register
name|HENT
modifier|*
name|entry
decl_stmt|;
name|int
modifier|*
name|retlen
decl_stmt|;
block|{
operator|*
name|retlen
operator|=
name|entry
operator|->
name|hent_klen
expr_stmt|;
return|return
name|entry
operator|->
name|hent_key
return|;
block|}
name|STR
modifier|*
name|hiterval
parameter_list|(
name|tb
parameter_list|,
name|entry
parameter_list|)
specifier|register
name|HASH
modifier|*
name|tb
decl_stmt|;
specifier|register
name|HENT
modifier|*
name|entry
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SOME_DBM
name|datum
name|key
decl_stmt|,
name|content
decl_stmt|;
if|if
condition|(
name|tb
operator|->
name|tbl_dbm
condition|)
block|{
name|key
operator|.
name|dptr
operator|=
name|entry
operator|->
name|hent_key
expr_stmt|;
name|key
operator|.
name|dsize
operator|=
name|entry
operator|->
name|hent_klen
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_GDBM
name|content
operator|=
name|gdbm_fetch
argument_list|(
name|tb
operator|->
name|tbl_dbm
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|#
directive|else
name|content
operator|=
name|dbm_fetch
argument_list|(
name|tb
operator|->
name|tbl_dbm
argument_list|,
name|key
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|entry
operator|->
name|hent_val
condition|)
name|entry
operator|->
name|hent_val
operator|=
name|Str_new
argument_list|(
literal|62
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str_nset
argument_list|(
name|entry
operator|->
name|hent_val
argument_list|,
name|content
operator|.
name|dptr
argument_list|,
name|content
operator|.
name|dsize
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|entry
operator|->
name|hent_val
return|;
block|}
ifdef|#
directive|ifdef
name|SOME_DBM
ifndef|#
directive|ifndef
name|O_CREAT
ifdef|#
directive|ifdef
name|I_FCNTL
include|#
directive|include
file|<fcntl.h>
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I_SYS_FILE
include|#
directive|include
file|<sys/file.h>
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|O_RDONLY
define|#
directive|define
name|O_RDONLY
value|0
endif|#
directive|endif
ifndef|#
directive|ifndef
name|O_RDWR
define|#
directive|define
name|O_RDWR
value|2
endif|#
directive|endif
ifndef|#
directive|ifndef
name|O_CREAT
define|#
directive|define
name|O_CREAT
value|01000
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_ODBM
specifier|static
name|int
name|dbmrefcnt
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|bool
name|hdbmopen
parameter_list|(
name|tb
parameter_list|,
name|fname
parameter_list|,
name|mode
parameter_list|)
specifier|register
name|HASH
modifier|*
name|tb
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|tb
condition|)
return|return
name|FALSE
return|;
ifdef|#
directive|ifdef
name|HAS_ODBM
if|if
condition|(
name|tb
operator|->
name|tbl_dbm
condition|)
comment|/* never really closed it */
return|return
name|TRUE
return|;
endif|#
directive|endif
if|if
condition|(
name|tb
operator|->
name|tbl_dbm
condition|)
block|{
name|hdbmclose
argument_list|(
name|tb
argument_list|)
expr_stmt|;
name|tb
operator|->
name|tbl_dbm
operator|=
literal|0
expr_stmt|;
block|}
name|hclear
argument_list|(
name|tb
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* clear cache */
ifdef|#
directive|ifdef
name|HAS_GDBM
if|if
condition|(
name|mode
operator|>=
literal|0
condition|)
name|tb
operator|->
name|tbl_dbm
operator|=
name|gdbm_open
argument_list|(
name|fname
argument_list|,
literal|0
argument_list|,
name|GDBM_WRCREAT
argument_list|,
name|mode
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tb
operator|->
name|tbl_dbm
condition|)
name|tb
operator|->
name|tbl_dbm
operator|=
name|gdbm_open
argument_list|(
name|fname
argument_list|,
literal|0
argument_list|,
name|GDBM_WRITER
argument_list|,
name|mode
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tb
operator|->
name|tbl_dbm
condition|)
name|tb
operator|->
name|tbl_dbm
operator|=
name|gdbm_open
argument_list|(
name|fname
argument_list|,
literal|0
argument_list|,
name|GDBM_READER
argument_list|,
name|mode
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_NDBM
if|if
condition|(
name|mode
operator|>=
literal|0
condition|)
name|tb
operator|->
name|tbl_dbm
operator|=
name|dbm_open
argument_list|(
name|fname
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tb
operator|->
name|tbl_dbm
condition|)
name|tb
operator|->
name|tbl_dbm
operator|=
name|dbm_open
argument_list|(
name|fname
argument_list|,
name|O_RDWR
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tb
operator|->
name|tbl_dbm
condition|)
name|tb
operator|->
name|tbl_dbm
operator|=
name|dbm_open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|dbmrefcnt
operator|++
condition|)
name|fatal
argument_list|(
literal|"Old dbm can only open one database"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s.dir"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|buf
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|mode
operator|<
literal|0
operator|||
name|close
argument_list|(
name|creat
argument_list|(
name|buf
argument_list|,
name|mode
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s.pag"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|creat
argument_list|(
name|buf
argument_list|,
name|mode
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
block|}
name|tb
operator|->
name|tbl_dbm
operator|=
name|dbminit
argument_list|(
name|fname
argument_list|)
operator|>=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
operator|!
name|tb
operator|->
name|tbl_array
operator|&&
name|tb
operator|->
name|tbl_dbm
operator|!=
literal|0
condition|)
name|Newz
argument_list|(
literal|507
argument_list|,
name|tb
operator|->
name|tbl_array
argument_list|,
name|tb
operator|->
name|tbl_max
operator|+
literal|1
argument_list|,
name|HENT
operator|*
argument_list|)
expr_stmt|;
return|return
name|tb
operator|->
name|tbl_dbm
operator|!=
literal|0
return|;
block|}
name|void
name|hdbmclose
parameter_list|(
name|tb
parameter_list|)
specifier|register
name|HASH
modifier|*
name|tb
decl_stmt|;
block|{
if|if
condition|(
name|tb
operator|&&
name|tb
operator|->
name|tbl_dbm
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_GDBM
name|gdbm_close
argument_list|(
name|tb
operator|->
name|tbl_dbm
argument_list|)
expr_stmt|;
name|tb
operator|->
name|tbl_dbm
operator|=
literal|0
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_NDBM
name|dbm_close
argument_list|(
name|tb
operator|->
name|tbl_dbm
argument_list|)
expr_stmt|;
name|tb
operator|->
name|tbl_dbm
operator|=
literal|0
expr_stmt|;
else|#
directive|else
comment|/* dbmrefcnt--;  */
comment|/* doesn't work, rats */
endif|#
directive|endif
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|dowarn
condition|)
name|warn
argument_list|(
literal|"Close on unopened dbm file"
argument_list|)
expr_stmt|;
block|}
name|bool
name|hdbmstore
parameter_list|(
name|tb
parameter_list|,
name|key
parameter_list|,
name|klen
parameter_list|,
name|str
parameter_list|)
specifier|register
name|HASH
modifier|*
name|tb
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|unsigned
name|int
name|klen
decl_stmt|;
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
block|{
name|datum
name|dkey
decl_stmt|,
name|dcontent
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|tb
operator|||
operator|!
name|tb
operator|->
name|tbl_dbm
condition|)
return|return
name|FALSE
return|;
name|dkey
operator|.
name|dptr
operator|=
name|key
expr_stmt|;
name|dkey
operator|.
name|dsize
operator|=
name|klen
expr_stmt|;
name|dcontent
operator|.
name|dptr
operator|=
name|str_get
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|dcontent
operator|.
name|dsize
operator|=
name|str
operator|->
name|str_cur
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_GDBM
name|error
operator|=
name|gdbm_store
argument_list|(
name|tb
operator|->
name|tbl_dbm
argument_list|,
name|dkey
argument_list|,
name|dcontent
argument_list|,
name|GDBM_REPLACE
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|dbm_store
argument_list|(
name|tb
operator|->
name|tbl_dbm
argument_list|,
name|dkey
argument_list|,
name|dcontent
argument_list|,
name|DBM_REPLACE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EPERM
condition|)
name|fatal
argument_list|(
literal|"No write permission to dbm file"
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"dbm store returned %d, errno %d, key \"%s\""
argument_list|,
name|error
argument_list|,
name|errno
argument_list|,
name|key
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_NDBM
name|dbm_clearerr
argument_list|(
name|tb
operator|->
name|tbl_dbm
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|!
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SOME_DBM */
end_comment

end_unit

