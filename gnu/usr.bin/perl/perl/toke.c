begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $RCSfile: toke.c,v $$Revision: 1.2.6.2 $$Date: 1997/08/27 17:19:19 $  *  *    Copyright (c) 1991, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  * $Log: toke.c,v $  * Revision 1.2.6.2  1997/08/27 17:19:19  joerg  * MFC: rev 1.4, pass all args down to scanident()  *  * Revision 1.2.6.1  1997/08/08 20:54:51  joerg  * MFC: fix buffer overflow condition.  *  * Revision 1.2  1995/05/30 05:03:26  rgrimes  * Remove trailing whitespace.  *  * Revision 1.1.1.1  1994/09/10  06:27:34  gclarkii  * Initial import of Perl 4.046 bmaked  *  * Revision 1.1.1.1  1993/08/23  21:29:40  nate  * PERL!  *  * Revision 4.0.1.9  1993/02/05  19:48:43  lwall  * patch36: now detects ambiguous use of filetest operators as well as unary  * patch36: fixed ambiguity on - within tr///  *  * Revision 4.0.1.8  92/06/23  12:33:45  lwall  * patch35: bad interaction between backslash and hyphen in tr///  *  * Revision 4.0.1.7  92/06/11  21:16:30  lwall  * patch34: expectterm incorrectly set to indicate start of program or block  *  * Revision 4.0.1.6  92/06/08  16:03:49  lwall  * patch20: an EXPR may now start with a bareword  * patch20: print $fh EXPR can now expect term rather than operator in EXPR  * patch20: added ... as variant on ..  * patch20: new warning on spurious backslash  * patch20: new warning on missing $ for foreach variable  * patch20: "foo"x1024 now legal without space after x  * patch20: new warning on print accidentally used as function  * patch20: tr/stuff// wasn't working right  * patch20: 2. now eats the dot  * patch20:<@ARGV> now notices @ARGV  * patch20: tr/// now lets you say \-  *  * Revision 4.0.1.5  91/11/11  16:45:51  lwall  * patch19: default arg for shift was wrong after first subroutine definition  *  * Revision 4.0.1.4  91/11/05  19:02:48  lwall  * patch11: \x and \c were subject to double interpretation in regexps  * patch11: prepared for ctype implementations that don't define isascii()  * patch11: nested list operators could miscount parens  * patch11: once-thru blocks didn't display right in the debugger  * patch11: sort eval "whatever" didn't work  * patch11: underscore is now allowed within literal octal and hex numbers  *  * Revision 4.0.1.3  91/06/10  01:32:26  lwall  * patch10: m'$foo' now treats string as single quoted  * patch10: certain pattern optimizations were botched  *  * Revision 4.0.1.2  91/06/07  12:05:56  lwall  * patch4: new copyright notice  * patch4: debugger lost track of lines in eval  * patch4: //o and s///o now optimize themselves fully at runtime  * patch4: added global modifier for pattern matches  *  * Revision 4.0.1.1  91/04/12  09:18:18  lwall  * patch1: perl -de "print" wouldn't stop at the first statement  *  * Revision 4.0  91/03/20  01:42:14  lwall  * 4.0 baseline.  *  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_include
include|#
directive|include
file|"perly.h"
end_include

begin_function_decl
specifier|static
name|void
name|set_csh
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|I_FCNTL
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_SYS_FILE
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|f_next
end_ifdef

begin_undef
undef|#
directive|undef
name|f_next
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* which backslash sequences to keep in m// or s// */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|patleave
init|=
literal|"\\.^$@dDwWsSbB+*?|()-nrtfeaxc0123456789[{]}"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|reparse
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if non-null, scanident found ${foo[$bar]} */
end_comment

begin_function_decl
name|void
name|checkcomma
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|CLINE
end_ifdef

begin_undef
undef|#
directive|undef
name|CLINE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CLINE
value|(cmdline = (curcmd->c_line< cmdline ? curcmd->c_line : cmdline))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|atarist
end_ifdef

begin_define
define|#
directive|define
name|PERL_META
parameter_list|(
name|c
parameter_list|)
value|((c) | 128)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|META
parameter_list|(
name|c
parameter_list|)
value|((c) | 128)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RETURN
parameter_list|(
name|retval
parameter_list|)
value|return (bufptr = s,(int)retval)
end_define

begin_define
define|#
directive|define
name|OPERATOR
parameter_list|(
name|retval
parameter_list|)
value|return (expectterm = TRUE,bufptr = s,(int)retval)
end_define

begin_define
define|#
directive|define
name|TERM
parameter_list|(
name|retval
parameter_list|)
value|return (CLINE, expectterm = FALSE,bufptr = s,(int)retval)
end_define

begin_define
define|#
directive|define
name|LOOPX
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,expectterm = FALSE,bufptr = s,(int)LOOPEX)
end_define

begin_define
define|#
directive|define
name|FTST
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,expectterm = TRUE,bufptr = s,(int)FILETEST)
end_define

begin_define
define|#
directive|define
name|FUN0
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival = f,expectterm = FALSE,bufptr = s,(int)FUNC0)
end_define

begin_define
define|#
directive|define
name|FUN1
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival = f,expectterm = FALSE,bufptr = s,(int)FUNC1)
end_define

begin_define
define|#
directive|define
name|FUN2
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival = f,expectterm = FALSE,bufptr = s,(int)FUNC2)
end_define

begin_define
define|#
directive|define
name|FUN2x
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival = f,expectterm = FALSE,bufptr = s,(int)FUNC2x)
end_define

begin_define
define|#
directive|define
name|FUN3
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival = f,expectterm = FALSE,bufptr = s,(int)FUNC3)
end_define

begin_define
define|#
directive|define
name|FUN4
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival = f,expectterm = FALSE,bufptr = s,(int)FUNC4)
end_define

begin_define
define|#
directive|define
name|FUN5
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival = f,expectterm = FALSE,bufptr = s,(int)FUNC5)
end_define

begin_define
define|#
directive|define
name|FL
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,expectterm = FALSE,bufptr = s,(int)FLIST)
end_define

begin_define
define|#
directive|define
name|FL2
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,expectterm = FALSE,bufptr = s,(int)FLIST2)
end_define

begin_define
define|#
directive|define
name|HFUN
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,expectterm = TRUE,bufptr = s,(int)HSHFUN)
end_define

begin_define
define|#
directive|define
name|HFUN3
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,expectterm = FALSE,bufptr = s,(int)HSHFUN3)
end_define

begin_define
define|#
directive|define
name|LFUN
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,expectterm = TRUE,bufptr = s,(int)LVALFUN)
end_define

begin_define
define|#
directive|define
name|AOP
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,expectterm = TRUE,bufptr = s,(int)ADDOP)
end_define

begin_define
define|#
directive|define
name|MOP
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,expectterm = TRUE,bufptr = s,(int)MULOP)
end_define

begin_define
define|#
directive|define
name|EOP
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,expectterm = TRUE,bufptr = s,(int)EQOP)
end_define

begin_define
define|#
directive|define
name|ROP
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,expectterm = TRUE,bufptr = s,(int)RELOP)
end_define

begin_define
define|#
directive|define
name|FOP
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,expectterm = FALSE,bufptr = s,(int)FILOP)
end_define

begin_define
define|#
directive|define
name|FOP2
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,expectterm = FALSE,bufptr = s,(int)FILOP2)
end_define

begin_define
define|#
directive|define
name|FOP3
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,expectterm = FALSE,bufptr = s,(int)FILOP3)
end_define

begin_define
define|#
directive|define
name|FOP4
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,expectterm = FALSE,bufptr = s,(int)FILOP4)
end_define

begin_define
define|#
directive|define
name|FOP22
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,expectterm = FALSE,bufptr = s,(int)FILOP22)
end_define

begin_define
define|#
directive|define
name|FOP25
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,expectterm = FALSE,bufptr = s,(int)FILOP25)
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_uni
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This bit of chicanery makes a unary function followed by  * a parenthesis into a function with one argument, highest precedence.  */
end_comment

begin_define
define|#
directive|define
name|UNI
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival = f, \ 	expectterm = TRUE, \ 	bufptr = s, \ 	last_uni = oldbufptr, \ 	(*s == '(' || (s = skipspace(s), *s == '(') ? (int)FUNC1 : (int)UNIOP) )
end_define

begin_comment
comment|/* This does similarly for list operators, merely by pretending that the  * paren came before the listop rather than after.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|atarist
end_ifdef

begin_define
define|#
directive|define
name|LOP
parameter_list|(
name|f
parameter_list|)
value|return(CLINE, *s == '(' || (s = skipspace(s), *s == '(') ? \ 	(*s = (char) PERL_META('('), bufptr = oldbufptr, '(') : \ 	(yylval.ival=f,expectterm = TRUE,bufptr = s,(int)LISTOP))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LOP
parameter_list|(
name|f
parameter_list|)
value|return(CLINE, *s == '(' || (s = skipspace(s), *s == '(') ? \ 	(*s = (char) META('('), bufptr = oldbufptr, '(') : \ 	(yylval.ival=f,expectterm = TRUE,bufptr = s,(int)LISTOP))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* grandfather return to old style */
end_comment

begin_define
define|#
directive|define
name|OLDLOP
parameter_list|(
name|f
parameter_list|)
value|return(yylval.ival=f,expectterm = TRUE,bufptr = s,(int)LISTOP)
end_define

begin_function
name|char
modifier|*
name|skipspace
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
while|while
condition|(
name|s
operator|<
name|bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|void
name|check_uni
parameter_list|()
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|ch
decl_stmt|;
if|if
condition|(
name|oldoldbufptr
operator|!=
name|last_uni
condition|)
return|return;
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|last_uni
argument_list|)
condition|)
name|last_uni
operator|++
expr_stmt|;
for|for
control|(
name|s
operator|=
name|last_uni
init|;
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'-'
condition|;
name|s
operator|++
control|)
empty_stmt|;
name|ch
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|warn
argument_list|(
literal|"Warning: Use of \"%s\" without parens is ambiguous"
argument_list|,
name|last_uni
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|ch
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CRIPPLED_CC
end_ifdef

begin_undef
undef|#
directive|undef
name|UNI
end_undef

begin_undef
undef|#
directive|undef
name|LOP
end_undef

begin_define
define|#
directive|define
name|UNI
parameter_list|(
name|f
parameter_list|)
value|return uni(f,s)
end_define

begin_define
define|#
directive|define
name|LOP
parameter_list|(
name|f
parameter_list|)
value|return lop(f,s)
end_define

begin_function
name|int
name|uni
parameter_list|(
name|f
parameter_list|,
name|s
parameter_list|)
name|int
name|f
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|yylval
operator|.
name|ival
operator|=
name|f
expr_stmt|;
name|expectterm
operator|=
name|TRUE
expr_stmt|;
name|bufptr
operator|=
name|s
expr_stmt|;
name|last_uni
operator|=
name|oldbufptr
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
return|return
name|FUNC1
return|;
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
return|return
name|FUNC1
return|;
else|else
return|return
name|UNIOP
return|;
block|}
end_function

begin_function
name|int
name|lop
parameter_list|(
name|f
parameter_list|,
name|s
parameter_list|)
name|int
name|f
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|CLINE
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'('
condition|)
name|s
operator|=
name|skipspace
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
block|{
ifdef|#
directive|ifdef
name|atarist
operator|*
name|s
operator|=
name|PERL_META
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|s
operator|=
name|META
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bufptr
operator|=
name|oldbufptr
expr_stmt|;
return|return
literal|'('
return|;
block|}
else|else
block|{
name|yylval
operator|.
name|ival
operator|=
name|f
expr_stmt|;
name|expectterm
operator|=
name|TRUE
expr_stmt|;
name|bufptr
operator|=
name|s
expr_stmt|;
return|return
name|LISTOP
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CRIPPLED_CC */
end_comment

begin_function
name|int
name|yylex
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|bufptr
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|int
name|tmp
decl_stmt|;
specifier|static
name|bool
name|in_format
init|=
name|FALSE
decl_stmt|;
specifier|static
name|bool
name|firstline
init|=
name|TRUE
decl_stmt|;
specifier|extern
name|int
name|yychar
decl_stmt|;
comment|/* last token */
name|oldoldbufptr
operator|=
name|oldbufptr
expr_stmt|;
name|oldbufptr
operator|=
name|s
expr_stmt|;
name|retry
label|:
ifdef|#
directive|ifdef
name|YYDEBUG
if|if
condition|(
name|debug
operator|&
literal|1
condition|)
if|if
condition|(
name|index
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tokener at %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tokener at %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BADSWITCH
if|if
condition|(
operator|*
name|s
operator|&
literal|128
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|s
operator|&
literal|127
operator|)
operator|==
literal|'('
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'('
expr_stmt|;
name|oldbufptr
operator|=
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|&
literal|127
operator|)
operator|==
literal|'}'
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'}'
expr_stmt|;
name|RETURN
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
else|else
name|warn
argument_list|(
literal|"Unrecognized character \\%03o ignored"
argument_list|,
operator|*
name|s
operator|++
operator|&
literal|255
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
endif|#
directive|endif
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
default|default:
if|if
condition|(
operator|(
operator|*
name|s
operator|&
literal|127
operator|)
operator|==
literal|'('
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'('
expr_stmt|;
name|oldbufptr
operator|=
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|&
literal|127
operator|)
operator|==
literal|'}'
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'}'
expr_stmt|;
name|RETURN
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
block|}
else|else
name|warn
argument_list|(
literal|"Unrecognized character \\%03o ignored"
argument_list|,
operator|*
name|s
operator|++
operator|&
literal|255
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
literal|4
case|:
case|case
literal|26
case|:
goto|goto
name|fake_eof
goto|;
comment|/* emulate EOF on ^D or ^Z */
case|case
literal|0
case|:
if|if
condition|(
operator|!
name|rsfp
condition|)
name|RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|++
operator|<
name|bufend
condition|)
goto|goto
name|retry
goto|;
comment|/* ignore stray nulls */
name|last_uni
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|firstline
condition|)
block|{
name|firstline
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|minus_n
operator|||
name|minus_p
operator|||
name|perldb
condition|)
block|{
name|str_set
argument_list|(
name|linestr
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|perldb
condition|)
block|{
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|char
modifier|*
name|pdb
init|=
name|getenv
argument_list|(
literal|"PERLDB"
argument_list|)
decl_stmt|;
name|str_cat
argument_list|(
name|linestr
argument_list|,
name|pdb
condition|?
name|pdb
else|:
literal|"require 'perldb.pl'"
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|linestr
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|minus_n
operator|||
name|minus_p
condition|)
block|{
name|str_cat
argument_list|(
name|linestr
argument_list|,
literal|"line: while (<>) {"
argument_list|)
expr_stmt|;
if|if
condition|(
name|minus_l
condition|)
name|str_cat
argument_list|(
name|linestr
argument_list|,
literal|"chop;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|minus_a
condition|)
name|str_cat
argument_list|(
name|linestr
argument_list|,
literal|"@F=split(' ');"
argument_list|)
expr_stmt|;
block|}
name|oldoldbufptr
operator|=
name|oldbufptr
operator|=
name|s
operator|=
name|str_get
argument_list|(
name|linestr
argument_list|)
expr_stmt|;
name|bufend
operator|=
name|linestr
operator|->
name|str_ptr
operator|+
name|linestr
operator|->
name|str_cur
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
if|if
condition|(
name|in_format
condition|)
block|{
name|bufptr
operator|=
name|bufend
expr_stmt|;
name|yylval
operator|.
name|formval
operator|=
name|load_format
argument_list|()
expr_stmt|;
name|in_format
operator|=
name|FALSE
expr_stmt|;
name|oldoldbufptr
operator|=
name|oldbufptr
operator|=
name|s
operator|=
name|str_get
argument_list|(
name|linestr
argument_list|)
operator|+
literal|1
expr_stmt|;
name|bufend
operator|=
name|linestr
operator|->
name|str_ptr
operator|+
name|linestr
operator|->
name|str_cur
expr_stmt|;
name|OPERATOR
argument_list|(
name|FORMLIST
argument_list|)
expr_stmt|;
block|}
name|curcmd
operator|->
name|c_line
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|CRYPTSCRIPT
name|cryptswitch
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* CRYPTSCRIPT */
do|do
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|str_gets
argument_list|(
name|linestr
argument_list|,
name|rsfp
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|Nullch
condition|)
block|{
name|fake_eof
label|:
if|if
condition|(
name|rsfp
condition|)
block|{
if|if
condition|(
name|preprocess
condition|)
operator|(
name|void
operator|)
name|mypclose
argument_list|(
name|rsfp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|FILE
operator|*
operator|)
name|rsfp
operator|==
name|stdin
condition|)
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|rsfp
argument_list|)
expr_stmt|;
name|rsfp
operator|=
name|Nullfp
expr_stmt|;
block|}
if|if
condition|(
name|minus_n
operator|||
name|minus_p
condition|)
block|{
name|str_set
argument_list|(
name|linestr
argument_list|,
name|minus_p
condition|?
literal|";}continue{print"
else|:
literal|""
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|linestr
argument_list|,
literal|";}"
argument_list|)
expr_stmt|;
name|oldoldbufptr
operator|=
name|oldbufptr
operator|=
name|s
operator|=
name|str_get
argument_list|(
name|linestr
argument_list|)
expr_stmt|;
name|bufend
operator|=
name|linestr
operator|->
name|str_ptr
operator|+
name|linestr
operator|->
name|str_cur
expr_stmt|;
name|minus_n
operator|=
name|minus_p
operator|=
literal|0
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|oldoldbufptr
operator|=
name|oldbufptr
operator|=
name|s
operator|=
name|str_get
argument_list|(
name|linestr
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|linestr
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|RETURN
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
comment|/* not infinite loop because rsfp is NULL now */
block|}
if|if
condition|(
name|doextract
operator|&&
operator|*
name|linestr
operator|->
name|str_ptr
operator|==
literal|'#'
condition|)
name|doextract
operator|=
name|FALSE
expr_stmt|;
block|}
do|while
condition|(
name|doextract
condition|)
do|;
name|oldoldbufptr
operator|=
name|oldbufptr
operator|=
name|bufptr
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|perldb
condition|)
block|{
name|STR
modifier|*
name|str
init|=
name|Str_new
argument_list|(
literal|85
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|str_sset
argument_list|(
name|str
argument_list|,
name|linestr
argument_list|)
expr_stmt|;
name|astore
argument_list|(
name|stab_xarray
argument_list|(
name|curcmd
operator|->
name|c_filestab
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|curcmd
operator|->
name|c_line
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|firstline
condition|)
block|{
name|char
modifier|*
name|showinput
parameter_list|()
function_decl|;
name|s
operator|=
name|showinput
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|bufend
operator|=
name|linestr
operator|->
name|str_ptr
operator|+
name|linestr
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
name|curcmd
operator|->
name|c_line
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'#'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'!'
condition|)
block|{
if|if
condition|(
operator|!
name|in_eval
operator|&&
operator|!
name|instr
argument_list|(
name|s
argument_list|,
literal|"perl"
argument_list|)
operator|&&
name|instr
argument_list|(
name|origargv
index|[
literal|0
index|]
argument_list|,
literal|"perl"
argument_list|)
condition|)
block|{
name|char
modifier|*
modifier|*
name|newargv
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
name|cmd
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|bufend
operator|&&
operator|!
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|bufend
condition|)
block|{
name|Newz
argument_list|(
literal|899
argument_list|,
name|newargv
argument_list|,
name|origargc
operator|+
literal|3
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|newargv
index|[
literal|1
index|]
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|bufend
operator|&&
operator|!
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|Copy
argument_list|(
name|origargv
operator|+
literal|1
argument_list|,
name|newargv
operator|+
literal|2
argument_list|,
name|origargc
operator|+
literal|1
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
name|newargv
operator|=
name|origargv
expr_stmt|;
name|newargv
index|[
literal|0
index|]
operator|=
name|cmd
expr_stmt|;
name|execv
argument_list|(
name|cmd
argument_list|,
name|newargv
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"Can't exec %s"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|s
operator|<
name|bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
condition|)
comment|/* for csh's that have to exec sh scripts */
name|s
operator|++
expr_stmt|;
block|}
block|}
goto|goto
name|retry
goto|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\r'
case|:
case|case
literal|013
case|:
name|s
operator|++
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
literal|'#'
case|:
if|if
condition|(
name|preprocess
operator|&&
name|s
operator|==
name|str_get
argument_list|(
name|linestr
argument_list|)
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|' '
operator|&&
operator|(
name|isDIGIT
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
operator|||
name|strnEQ
argument_list|(
name|s
operator|+
literal|2
argument_list|,
literal|"line "
argument_list|,
literal|5
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
operator|*
name|s
operator|&&
operator|!
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
name|curcmd
operator|->
name|c_line
operator|=
name|atoi
argument_list|(
name|s
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
name|d
operator|=
name|bufend
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|d
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
name|s
index|[
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* wipe out newline */
if|if
condition|(
operator|*
name|s
operator|==
literal|'"'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|s
index|[
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* wipe out trailing quote */
block|}
if|if
condition|(
operator|*
name|s
condition|)
name|curcmd
operator|->
name|c_filestab
operator|=
name|fstab
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|else
name|curcmd
operator|->
name|c_filestab
operator|=
name|fstab
argument_list|(
name|origfilename
argument_list|)
expr_stmt|;
name|oldoldbufptr
operator|=
name|oldbufptr
operator|=
name|s
operator|=
name|str_get
argument_list|(
name|linestr
argument_list|)
expr_stmt|;
block|}
comment|/* FALL THROUGH */
case|case
literal|'\n'
case|:
if|if
condition|(
name|in_eval
operator|&&
operator|!
name|rsfp
condition|)
block|{
name|d
operator|=
name|bufend
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|d
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|d
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|in_format
condition|)
block|{
name|bufptr
operator|=
name|s
expr_stmt|;
name|yylval
operator|.
name|formval
operator|=
name|load_format
argument_list|()
expr_stmt|;
name|in_format
operator|=
name|FALSE
expr_stmt|;
name|oldoldbufptr
operator|=
name|oldbufptr
operator|=
name|s
operator|=
name|bufptr
operator|+
literal|1
expr_stmt|;
name|TERM
argument_list|(
name|FORMLIST
argument_list|)
expr_stmt|;
block|}
name|curcmd
operator|->
name|c_line
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|bufend
operator|=
name|s
expr_stmt|;
block|}
goto|goto
name|retry
goto|;
case|case
literal|'-'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|&&
name|isALPHA
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|isALPHA
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|last_uni
operator|=
name|oldbufptr
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'r'
case|:
name|FTST
argument_list|(
name|O_FTEREAD
argument_list|)
expr_stmt|;
case|case
literal|'w'
case|:
name|FTST
argument_list|(
name|O_FTEWRITE
argument_list|)
expr_stmt|;
case|case
literal|'x'
case|:
name|FTST
argument_list|(
name|O_FTEEXEC
argument_list|)
expr_stmt|;
case|case
literal|'o'
case|:
name|FTST
argument_list|(
name|O_FTEOWNED
argument_list|)
expr_stmt|;
case|case
literal|'R'
case|:
name|FTST
argument_list|(
name|O_FTRREAD
argument_list|)
expr_stmt|;
case|case
literal|'W'
case|:
name|FTST
argument_list|(
name|O_FTRWRITE
argument_list|)
expr_stmt|;
case|case
literal|'X'
case|:
name|FTST
argument_list|(
name|O_FTREXEC
argument_list|)
expr_stmt|;
case|case
literal|'O'
case|:
name|FTST
argument_list|(
name|O_FTROWNED
argument_list|)
expr_stmt|;
case|case
literal|'e'
case|:
name|FTST
argument_list|(
name|O_FTIS
argument_list|)
expr_stmt|;
case|case
literal|'z'
case|:
name|FTST
argument_list|(
name|O_FTZERO
argument_list|)
expr_stmt|;
case|case
literal|'s'
case|:
name|FTST
argument_list|(
name|O_FTSIZE
argument_list|)
expr_stmt|;
case|case
literal|'f'
case|:
name|FTST
argument_list|(
name|O_FTFILE
argument_list|)
expr_stmt|;
case|case
literal|'d'
case|:
name|FTST
argument_list|(
name|O_FTDIR
argument_list|)
expr_stmt|;
case|case
literal|'l'
case|:
name|FTST
argument_list|(
name|O_FTLINK
argument_list|)
expr_stmt|;
case|case
literal|'p'
case|:
name|FTST
argument_list|(
name|O_FTPIPE
argument_list|)
expr_stmt|;
case|case
literal|'S'
case|:
name|FTST
argument_list|(
name|O_FTSOCK
argument_list|)
expr_stmt|;
case|case
literal|'u'
case|:
name|FTST
argument_list|(
name|O_FTSUID
argument_list|)
expr_stmt|;
case|case
literal|'g'
case|:
name|FTST
argument_list|(
name|O_FTSGID
argument_list|)
expr_stmt|;
case|case
literal|'k'
case|:
name|FTST
argument_list|(
name|O_FTSVTX
argument_list|)
expr_stmt|;
case|case
literal|'b'
case|:
name|FTST
argument_list|(
name|O_FTBLK
argument_list|)
expr_stmt|;
case|case
literal|'c'
case|:
name|FTST
argument_list|(
name|O_FTCHR
argument_list|)
expr_stmt|;
case|case
literal|'t'
case|:
name|FTST
argument_list|(
name|O_FTTTY
argument_list|)
expr_stmt|;
case|case
literal|'T'
case|:
name|FTST
argument_list|(
name|O_FTTEXT
argument_list|)
expr_stmt|;
case|case
literal|'B'
case|:
name|FTST
argument_list|(
name|O_FTBINARY
argument_list|)
expr_stmt|;
case|case
literal|'M'
case|:
name|stabent
argument_list|(
literal|"\024"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|FTST
argument_list|(
name|O_FTMTIME
argument_list|)
expr_stmt|;
case|case
literal|'A'
case|:
name|stabent
argument_list|(
literal|"\024"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|FTST
argument_list|(
name|O_FTATIME
argument_list|)
expr_stmt|;
case|case
literal|'C'
case|:
name|stabent
argument_list|(
literal|"\024"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|FTST
argument_list|(
name|O_FTCTIME
argument_list|)
expr_stmt|;
default|default:
name|s
operator|-=
literal|2
expr_stmt|;
break|break;
block|}
block|}
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|tmp
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|RETURN
argument_list|(
name|DEC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expectterm
condition|)
block|{
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|!
name|isSPACE
argument_list|(
operator|*
name|bufptr
argument_list|)
condition|)
name|check_uni
argument_list|()
expr_stmt|;
name|OPERATOR
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
block|}
else|else
name|AOP
argument_list|(
name|O_SUBTRACT
argument_list|)
expr_stmt|;
case|case
literal|'+'
case|:
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|tmp
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|RETURN
argument_list|(
name|INC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expectterm
condition|)
block|{
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|!
name|isSPACE
argument_list|(
operator|*
name|bufptr
argument_list|)
condition|)
name|check_uni
argument_list|()
expr_stmt|;
name|OPERATOR
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
block|}
else|else
name|AOP
argument_list|(
name|O_ADD
argument_list|)
expr_stmt|;
case|case
literal|'*'
case|:
if|if
condition|(
name|expectterm
condition|)
block|{
name|check_uni
argument_list|()
expr_stmt|;
name|s
operator|=
name|scanident
argument_list|(
name|s
argument_list|,
name|bufend
argument_list|,
name|tokenbuf
argument_list|,
sizeof|sizeof
name|tokenbuf
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|stabval
operator|=
name|stabent
argument_list|(
name|tokenbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|STAR
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|tmp
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|OPERATOR
argument_list|(
name|POW
argument_list|)
expr_stmt|;
block|}
name|MOP
argument_list|(
name|O_MULTIPLY
argument_list|)
expr_stmt|;
case|case
literal|'%'
case|:
if|if
condition|(
name|expectterm
condition|)
block|{
if|if
condition|(
operator|!
name|isALPHA
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|check_uni
argument_list|()
expr_stmt|;
name|s
operator|=
name|scanident
argument_list|(
name|s
argument_list|,
name|bufend
argument_list|,
name|tokenbuf
argument_list|,
sizeof|sizeof
name|tokenbuf
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|stabval
operator|=
name|hadd
argument_list|(
name|stabent
argument_list|(
name|tokenbuf
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|HSH
argument_list|)
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
name|MOP
argument_list|(
name|O_MODULO
argument_list|)
expr_stmt|;
case|case
literal|'^'
case|:
case|case
literal|'~'
case|:
case|case
literal|'('
case|:
case|case
literal|','
case|:
case|case
literal|':'
case|:
case|case
literal|'['
case|:
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|OPERATOR
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
case|case
literal|'{'
case|:
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
name|curcmd
operator|->
name|c_line
expr_stmt|;
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'#'
condition|)
name|cmdline
operator|=
name|NOLINE
expr_stmt|;
comment|/* invalidate current command line number */
name|expectterm
operator|=
literal|2
expr_stmt|;
name|RETURN
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
case|case
literal|';'
case|:
if|if
condition|(
name|curcmd
operator|->
name|c_line
operator|<
name|cmdline
condition|)
name|cmdline
operator|=
name|curcmd
operator|->
name|c_line
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|OPERATOR
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
case|case
literal|')'
case|:
case|case
literal|']'
case|:
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|TERM
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
case|case
literal|'}'
case|:
operator|*
name|s
operator||=
literal|128
expr_stmt|;
name|RETURN
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
case|case
literal|'&'
case|:
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'&'
condition|)
name|OPERATOR
argument_list|(
name|ANDAND
argument_list|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
if|if
condition|(
name|expectterm
condition|)
block|{
name|d
operator|=
name|bufend
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|d
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|isALPHA
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'_'
operator|||
operator|*
name|s
operator|==
literal|'\''
condition|)
operator|*
operator|(
operator|--
name|s
operator|)
operator|=
literal|'\\'
expr_stmt|;
comment|/* force next ident to WORD */
else|else
name|check_uni
argument_list|()
expr_stmt|;
name|OPERATOR
argument_list|(
name|AMPER
argument_list|)
expr_stmt|;
block|}
name|OPERATOR
argument_list|(
literal|'&'
argument_list|)
expr_stmt|;
case|case
literal|'|'
case|:
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'|'
condition|)
name|OPERATOR
argument_list|(
name|OROR
argument_list|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
name|OPERATOR
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
case|case
literal|'='
case|:
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'='
condition|)
name|EOP
argument_list|(
name|O_EQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'~'
condition|)
name|OPERATOR
argument_list|(
name|MATCH
argument_list|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
name|OPERATOR
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
case|case
literal|'!'
case|:
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'='
condition|)
name|EOP
argument_list|(
name|O_NE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'~'
condition|)
name|OPERATOR
argument_list|(
name|NMATCH
argument_list|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
name|OPERATOR
argument_list|(
literal|'!'
argument_list|)
expr_stmt|;
case|case
literal|'<'
case|:
if|if
condition|(
name|expectterm
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|!=
literal|'<'
operator|&&
operator|!
name|index
argument_list|(
name|s
argument_list|,
literal|'>'
argument_list|)
condition|)
name|check_uni
argument_list|()
expr_stmt|;
name|s
operator|=
name|scanstr
argument_list|(
name|s
argument_list|,
name|SCAN_DEF
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|RSTRING
argument_list|)
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'<'
condition|)
name|OPERATOR
argument_list|(
name|LS
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'='
condition|)
block|{
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'>'
condition|)
name|EOP
argument_list|(
name|O_NCMP
argument_list|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
name|ROP
argument_list|(
name|O_LE
argument_list|)
expr_stmt|;
block|}
name|s
operator|--
expr_stmt|;
name|ROP
argument_list|(
name|O_LT
argument_list|)
expr_stmt|;
case|case
literal|'>'
case|:
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'>'
condition|)
name|OPERATOR
argument_list|(
name|RS
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'='
condition|)
name|ROP
argument_list|(
name|O_GE
argument_list|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
name|ROP
argument_list|(
name|O_GT
argument_list|)
expr_stmt|;
define|#
directive|define
name|SNARFWORD
define|\
value|d = tokenbuf; \ 	while (isALNUM(*s) || *s == '\'') \ 	    *d++ = *s++; \ 	while (d[-1] == '\'') \ 	    d--,s--; \ 	*d = '\0'; \ 	d = tokenbuf;
case|case
literal|'$'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'#'
operator|&&
operator|(
name|isALPHA
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
operator|||
name|s
index|[
literal|2
index|]
operator|==
literal|'_'
operator|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|s
operator|=
name|scanident
argument_list|(
name|s
argument_list|,
name|bufend
argument_list|,
name|tokenbuf
argument_list|,
sizeof|sizeof
name|tokenbuf
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|stabval
operator|=
name|aadd
argument_list|(
name|stabent
argument_list|(
name|tokenbuf
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|ARYLEN
argument_list|)
expr_stmt|;
block|}
name|d
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|scanident
argument_list|(
name|s
argument_list|,
name|bufend
argument_list|,
name|tokenbuf
argument_list|,
sizeof|sizeof
name|tokenbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|reparse
condition|)
block|{
comment|/* turn ${foo[bar]} into ($foo[bar]) */
name|do_reparse
label|:
name|s
index|[
operator|-
literal|1
index|]
operator|=
literal|')'
expr_stmt|;
name|s
operator|=
name|d
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
name|s
index|[
literal|0
index|]
expr_stmt|;
name|s
index|[
literal|0
index|]
operator|=
literal|'('
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|yylval
operator|.
name|stabval
operator|=
name|stabent
argument_list|(
name|tokenbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|expectterm
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|oldoldbufptr
operator|&&
name|oldoldbufptr
operator|<
name|bufptr
condition|)
block|{
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|oldoldbufptr
argument_list|)
condition|)
name|oldoldbufptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|oldoldbufptr
operator|==
literal|'p'
operator|&&
name|strnEQ
argument_list|(
name|oldoldbufptr
argument_list|,
literal|"print"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
literal|"&*<%"
argument_list|,
operator|*
name|s
argument_list|)
operator|&&
name|isALPHA
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|expectterm
operator|=
name|TRUE
expr_stmt|;
comment|/* e.g. print $fh&sub */
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
operator|&&
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|expectterm
operator|=
name|TRUE
expr_stmt|;
comment|/* e.g. print $fh .3 */
elseif|else
if|if
condition|(
name|index
argument_list|(
literal|"/?-+"
argument_list|,
operator|*
name|s
argument_list|)
operator|&&
operator|!
name|isSPACE
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|expectterm
operator|=
name|TRUE
expr_stmt|;
comment|/* e.g. print $fh -1 */
block|}
block|}
name|RETURN
argument_list|(
name|REG
argument_list|)
expr_stmt|;
case|case
literal|'@'
case|:
name|d
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|scanident
argument_list|(
name|s
argument_list|,
name|bufend
argument_list|,
name|tokenbuf
argument_list|,
sizeof|sizeof
name|tokenbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|reparse
condition|)
goto|goto
name|do_reparse
goto|;
name|yylval
operator|.
name|stabval
operator|=
name|aadd
argument_list|(
name|stabent
argument_list|(
name|tokenbuf
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|ARY
argument_list|)
expr_stmt|;
case|case
literal|'/'
case|:
comment|/* may either be division or pattern */
case|case
literal|'?'
case|:
comment|/* may either be conditional or pattern */
if|if
condition|(
name|expectterm
condition|)
block|{
name|check_uni
argument_list|()
expr_stmt|;
name|s
operator|=
name|scanpat
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|PATTERN
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'/'
condition|)
name|MOP
argument_list|(
name|O_DIVIDE
argument_list|)
expr_stmt|;
name|OPERATOR
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
case|case
literal|'.'
case|:
if|if
condition|(
operator|!
name|expectterm
operator|||
operator|!
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|tmp
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
name|tmp
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|yylval
operator|.
name|ival
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|yylval
operator|.
name|ival
operator|=
name|AF_COMMON
expr_stmt|;
name|OPERATOR
argument_list|(
name|DOTDOT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expectterm
condition|)
name|check_uni
argument_list|()
expr_stmt|;
name|AOP
argument_list|(
name|O_CONCAT
argument_list|)
expr_stmt|;
block|}
comment|/* FALL THROUGH */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
case|case
literal|'`'
case|:
name|s
operator|=
name|scanstr
argument_list|(
name|s
argument_list|,
name|SCAN_DEF
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|RSTRING
argument_list|)
expr_stmt|;
case|case
literal|'\\'
case|:
comment|/* some magic to force next word to be a WORD */
name|s
operator|++
expr_stmt|;
comment|/* used by do and sub to force a separate namespace */
if|if
condition|(
operator|!
name|isALPHA
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|*
name|s
operator|!=
literal|'_'
operator|&&
operator|*
name|s
operator|!=
literal|'\''
condition|)
block|{
name|warn
argument_list|(
literal|"Spurious backslash ignored"
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
comment|/* FALL THROUGH */
case|case
literal|'_'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"__LINE__"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"__FILE__"
argument_list|)
condition|)
block|{
name|ARG
modifier|*
name|arg
init|=
name|op_new
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|yylval
operator|.
name|arg
operator|=
name|arg
expr_stmt|;
name|arg
operator|->
name|arg_type
operator|=
name|O_ITEM
expr_stmt|;
if|if
condition|(
name|d
index|[
literal|2
index|]
operator|==
literal|'L'
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tokenbuf
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|curcmd
operator|->
name|c_line
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|tokenbuf
argument_list|,
name|stab_val
argument_list|(
name|curcmd
operator|->
name|c_filestab
argument_list|)
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_SINGLE
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
operator|=
name|str_make
argument_list|(
name|tokenbuf
argument_list|,
name|strlen
argument_list|(
name|tokenbuf
argument_list|)
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|RSTRING
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"__END__"
argument_list|)
condition|)
block|{
name|STAB
modifier|*
name|stab
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/*SUPPRESS 560*/
if|if
condition|(
operator|!
name|in_eval
operator|&&
operator|(
name|stab
operator|=
name|stabent
argument_list|(
literal|"DATA"
argument_list|,
name|FALSE
argument_list|)
operator|)
condition|)
block|{
name|stab
operator|->
name|str_pok
operator||=
name|SP_MULTI
expr_stmt|;
if|if
condition|(
operator|!
name|stab_io
argument_list|(
name|stab
argument_list|)
condition|)
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|=
name|stio_new
argument_list|()
expr_stmt|;
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|ifp
operator|=
name|rsfp
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETFD
argument_list|)
name|fd
operator|=
name|fileno
argument_list|(
name|rsfp
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
name|fd
operator|>=
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|preprocess
condition|)
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|type
operator|=
literal|'|'
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|FILE
operator|*
operator|)
name|rsfp
operator|==
name|stdin
condition|)
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|type
operator|=
literal|'-'
expr_stmt|;
else|else
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|type
operator|=
literal|'<'
expr_stmt|;
name|rsfp
operator|=
name|Nullfp
expr_stmt|;
block|}
goto|goto
name|fake_eof
goto|;
block|}
block|}
break|break;
case|case
literal|'a'
case|:
case|case
literal|'A'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"alarm"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_ALARM
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"accept"
argument_list|)
condition|)
name|FOP22
argument_list|(
name|O_ACCEPT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"atan2"
argument_list|)
condition|)
name|FUN2
argument_list|(
name|O_ATAN2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"bind"
argument_list|)
condition|)
name|FOP2
argument_list|(
name|O_BIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"binmode"
argument_list|)
condition|)
name|FOP
argument_list|(
name|O_BINMODE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
case|case
literal|'C'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"chop"
argument_list|)
condition|)
name|LFUN
argument_list|(
name|O_CHOP
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"continue"
argument_list|)
condition|)
name|OPERATOR
argument_list|(
name|CONTINUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"chdir"
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|stabent
argument_list|(
literal|"ENV"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* may use HOME */
name|UNI
argument_list|(
name|O_CHDIR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"close"
argument_list|)
condition|)
name|FOP
argument_list|(
name|O_CLOSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"closedir"
argument_list|)
condition|)
name|FOP
argument_list|(
name|O_CLOSEDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"cmp"
argument_list|)
condition|)
name|EOP
argument_list|(
name|O_SCMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"caller"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_CALLER
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"crypt"
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|FCRYPT
specifier|static
name|int
name|cryptseen
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|cryptseen
operator|++
condition|)
name|init_des
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|FUN2
argument_list|(
name|O_CRYPT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"chmod"
argument_list|)
condition|)
name|LOP
argument_list|(
name|O_CHMOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"chown"
argument_list|)
condition|)
name|LOP
argument_list|(
name|O_CHOWN
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"connect"
argument_list|)
condition|)
name|FOP2
argument_list|(
name|O_CONNECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"cos"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_COS
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"chroot"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_CHROOT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"do"
argument_list|)
condition|)
block|{
name|d
operator|=
name|bufend
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|d
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|isALPHA
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'_'
condition|)
operator|*
operator|(
operator|--
name|s
operator|)
operator|=
literal|'\\'
expr_stmt|;
comment|/* force next ident to WORD */
name|OPERATOR
argument_list|(
name|DO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"die"
argument_list|)
condition|)
name|LOP
argument_list|(
name|O_DIE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"defined"
argument_list|)
condition|)
name|LFUN
argument_list|(
name|O_DEFINED
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"delete"
argument_list|)
condition|)
name|OPERATOR
argument_list|(
name|DELETE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"dbmopen"
argument_list|)
condition|)
name|HFUN3
argument_list|(
name|O_DBMOPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"dbmclose"
argument_list|)
condition|)
name|HFUN
argument_list|(
name|O_DBMCLOSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"dump"
argument_list|)
condition|)
name|LOOPX
argument_list|(
name|O_DUMP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"else"
argument_list|)
condition|)
name|OPERATOR
argument_list|(
name|ELSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"elsif"
argument_list|)
condition|)
block|{
name|yylval
operator|.
name|ival
operator|=
name|curcmd
operator|->
name|c_line
expr_stmt|;
name|OPERATOR
argument_list|(
name|ELSIF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"eq"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"EQ"
argument_list|)
condition|)
name|EOP
argument_list|(
name|O_SEQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"exit"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_EXIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"eval"
argument_list|)
condition|)
block|{
name|allstabs
operator|=
name|TRUE
expr_stmt|;
comment|/* must initialize everything since */
name|UNI
argument_list|(
name|O_EVAL
argument_list|)
expr_stmt|;
comment|/* we don't know what will be used */
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"eof"
argument_list|)
condition|)
name|FOP
argument_list|(
name|O_EOF
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"exp"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_EXP
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"each"
argument_list|)
condition|)
name|HFUN
argument_list|(
name|O_EACH
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"exec"
argument_list|)
condition|)
block|{
name|set_csh
argument_list|()
expr_stmt|;
name|LOP
argument_list|(
name|O_EXEC_OP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"endhostent"
argument_list|)
condition|)
name|FUN0
argument_list|(
name|O_EHOSTENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"endnetent"
argument_list|)
condition|)
name|FUN0
argument_list|(
name|O_ENETENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"endservent"
argument_list|)
condition|)
name|FUN0
argument_list|(
name|O_ESERVENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"endprotoent"
argument_list|)
condition|)
name|FUN0
argument_list|(
name|O_EPROTOENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"endpwent"
argument_list|)
condition|)
name|FUN0
argument_list|(
name|O_EPWENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"endgrent"
argument_list|)
condition|)
name|FUN0
argument_list|(
name|O_EGRENT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"for"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"foreach"
argument_list|)
condition|)
block|{
name|yylval
operator|.
name|ival
operator|=
name|curcmd
operator|->
name|c_line
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|isALPHA
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"Missing $ on loop variable"
argument_list|)
expr_stmt|;
name|OPERATOR
argument_list|(
name|FOR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"format"
argument_list|)
condition|)
block|{
name|d
operator|=
name|bufend
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|d
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|isALPHA
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'_'
condition|)
operator|*
operator|(
operator|--
name|s
operator|)
operator|=
literal|'\\'
expr_stmt|;
comment|/* force next ident to WORD */
name|in_format
operator|=
name|TRUE
expr_stmt|;
name|allstabs
operator|=
name|TRUE
expr_stmt|;
comment|/* must initialize everything since */
name|OPERATOR
argument_list|(
name|FORMAT
argument_list|)
expr_stmt|;
comment|/* we don't know what will be used */
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"fork"
argument_list|)
condition|)
name|FUN0
argument_list|(
name|O_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"fcntl"
argument_list|)
condition|)
name|FOP3
argument_list|(
name|O_FCNTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"fileno"
argument_list|)
condition|)
name|FOP
argument_list|(
name|O_FILENO
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"flock"
argument_list|)
condition|)
name|FOP2
argument_list|(
name|O_FLOCK
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"gt"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"GT"
argument_list|)
condition|)
name|ROP
argument_list|(
name|O_SGT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ge"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"GE"
argument_list|)
condition|)
name|ROP
argument_list|(
name|O_SGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"grep"
argument_list|)
condition|)
name|FL2
argument_list|(
name|O_GREP
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"goto"
argument_list|)
condition|)
name|LOOPX
argument_list|(
name|O_GOTO
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"gmtime"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_GMTIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"getc"
argument_list|)
condition|)
name|FOP
argument_list|(
name|O_GETC
argument_list|)
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|d
argument_list|,
literal|"get"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|d
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|*
name|d
operator|==
literal|'p'
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ppid"
argument_list|)
condition|)
name|FUN0
argument_list|(
name|O_GETPPID
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pgrp"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_GETPGRP
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"priority"
argument_list|)
condition|)
name|FUN2
argument_list|(
name|O_GETPRIORITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"protobyname"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_GPBYNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"protobynumber"
argument_list|)
condition|)
name|FUN1
argument_list|(
name|O_GPBYNUMBER
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"protoent"
argument_list|)
condition|)
name|FUN0
argument_list|(
name|O_GPROTOENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pwent"
argument_list|)
condition|)
name|FUN0
argument_list|(
name|O_GPWENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pwnam"
argument_list|)
condition|)
name|FUN1
argument_list|(
name|O_GPWNAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pwuid"
argument_list|)
condition|)
name|FUN1
argument_list|(
name|O_GPWUID
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"peername"
argument_list|)
condition|)
name|FOP
argument_list|(
name|O_GETPEERNAME
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'h'
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"hostbyname"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_GHBYNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"hostbyaddr"
argument_list|)
condition|)
name|FUN2
argument_list|(
name|O_GHBYADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"hostent"
argument_list|)
condition|)
name|FUN0
argument_list|(
name|O_GHOSTENT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'n'
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"netbyname"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_GNBYNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"netbyaddr"
argument_list|)
condition|)
name|FUN2
argument_list|(
name|O_GNBYADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"netent"
argument_list|)
condition|)
name|FUN0
argument_list|(
name|O_GNETENT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'s'
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"servbyname"
argument_list|)
condition|)
name|FUN2
argument_list|(
name|O_GSBYNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"servbyport"
argument_list|)
condition|)
name|FUN2
argument_list|(
name|O_GSBYPORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"servent"
argument_list|)
condition|)
name|FUN0
argument_list|(
name|O_GSERVENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sockname"
argument_list|)
condition|)
name|FOP
argument_list|(
name|O_GETSOCKNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sockopt"
argument_list|)
condition|)
name|FOP3
argument_list|(
name|O_GSOCKOPT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'g'
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"grent"
argument_list|)
condition|)
name|FUN0
argument_list|(
name|O_GGRENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"grnam"
argument_list|)
condition|)
name|FUN1
argument_list|(
name|O_GGRNAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"grgid"
argument_list|)
condition|)
name|FUN1
argument_list|(
name|O_GGRGID
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'l'
condition|)
block|{
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"login"
argument_list|)
condition|)
name|FUN0
argument_list|(
name|O_GETLOGIN
argument_list|)
expr_stmt|;
block|}
name|d
operator|-=
literal|3
expr_stmt|;
block|}
break|break;
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"hex"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_HEX
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"if"
argument_list|)
condition|)
block|{
name|yylval
operator|.
name|ival
operator|=
name|curcmd
operator|->
name|c_line
expr_stmt|;
name|OPERATOR
argument_list|(
name|IF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"index"
argument_list|)
condition|)
name|FUN2x
argument_list|(
name|O_INDEX
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"int"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ioctl"
argument_list|)
condition|)
name|FOP3
argument_list|(
name|O_IOCTL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
case|case
literal|'J'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"join"
argument_list|)
condition|)
name|FL2
argument_list|(
name|O_JOIN
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
case|case
literal|'K'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"keys"
argument_list|)
condition|)
name|HFUN
argument_list|(
name|O_KEYS
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"kill"
argument_list|)
condition|)
name|LOP
argument_list|(
name|O_KILL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"last"
argument_list|)
condition|)
name|LOOPX
argument_list|(
name|O_LAST
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"local"
argument_list|)
condition|)
name|OPERATOR
argument_list|(
name|LOCAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"length"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_LENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"lt"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"LT"
argument_list|)
condition|)
name|ROP
argument_list|(
name|O_SLT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"le"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"LE"
argument_list|)
condition|)
name|ROP
argument_list|(
name|O_SLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"localtime"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_LOCALTIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"log"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_LOG
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"link"
argument_list|)
condition|)
name|FUN2
argument_list|(
name|O_LINK
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"listen"
argument_list|)
condition|)
name|FOP2
argument_list|(
name|O_LISTEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"lstat"
argument_list|)
condition|)
name|FOP
argument_list|(
name|O_LSTAT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'\''
condition|)
block|{
name|d
operator|=
literal|"m"
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
name|SNARFWORD
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"m"
argument_list|)
condition|)
block|{
name|s
operator|=
name|scanpat
argument_list|(
name|s
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|yylval
operator|.
name|arg
condition|)
name|TERM
argument_list|(
name|PATTERN
argument_list|)
expr_stmt|;
else|else
name|RETURN
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* force error */
block|}
switch|switch
condition|(
name|d
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'k'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"mkdir"
argument_list|)
condition|)
name|FUN2
argument_list|(
name|O_MKDIR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"msgctl"
argument_list|)
condition|)
name|FUN3
argument_list|(
name|O_MSGCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"msgget"
argument_list|)
condition|)
name|FUN2
argument_list|(
name|O_MSGGET
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"msgrcv"
argument_list|)
condition|)
name|FUN5
argument_list|(
name|O_MSGRCV
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"msgsnd"
argument_list|)
condition|)
name|FUN3
argument_list|(
name|O_MSGSND
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"next"
argument_list|)
condition|)
name|LOOPX
argument_list|(
name|O_NEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ne"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"NE"
argument_list|)
condition|)
name|EOP
argument_list|(
name|O_SNE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
case|case
literal|'O'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"open"
argument_list|)
condition|)
name|OPERATOR
argument_list|(
name|OPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ord"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_ORD
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"oct"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_OCT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"opendir"
argument_list|)
condition|)
name|FOP2
argument_list|(
name|O_OPEN_DIR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"print"
argument_list|)
condition|)
block|{
name|checkcomma
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
literal|"filehandle"
argument_list|)
expr_stmt|;
name|LOP
argument_list|(
name|O_PRINT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"printf"
argument_list|)
condition|)
block|{
name|checkcomma
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
literal|"filehandle"
argument_list|)
expr_stmt|;
name|LOP
argument_list|(
name|O_PRTF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"push"
argument_list|)
condition|)
block|{
name|yylval
operator|.
name|ival
operator|=
name|O_PUSH
expr_stmt|;
name|OPERATOR
argument_list|(
name|PUSH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pop"
argument_list|)
condition|)
name|OPERATOR
argument_list|(
name|POP
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pack"
argument_list|)
condition|)
name|FL2
argument_list|(
name|O_PACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"package"
argument_list|)
condition|)
name|OPERATOR
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pipe"
argument_list|)
condition|)
name|FOP22
argument_list|(
name|O_PIPE_OP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"q"
argument_list|)
condition|)
block|{
name|s
operator|=
name|scanstr
argument_list|(
name|s
operator|-
literal|1
argument_list|,
name|SCAN_DEF
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|RSTRING
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"qq"
argument_list|)
condition|)
block|{
name|s
operator|=
name|scanstr
argument_list|(
name|s
operator|-
literal|2
argument_list|,
name|SCAN_DEF
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|RSTRING
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"qx"
argument_list|)
condition|)
block|{
name|s
operator|=
name|scanstr
argument_list|(
name|s
operator|-
literal|2
argument_list|,
name|SCAN_DEF
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|RSTRING
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"return"
argument_list|)
condition|)
name|OLDLOP
argument_list|(
name|O_RETURN
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"require"
argument_list|)
condition|)
block|{
name|allstabs
operator|=
name|TRUE
expr_stmt|;
comment|/* must initialize everything since */
name|UNI
argument_list|(
name|O_REQUIRE
argument_list|)
expr_stmt|;
comment|/* we don't know what will be used */
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"reset"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"redo"
argument_list|)
condition|)
name|LOOPX
argument_list|(
name|O_REDO
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"rename"
argument_list|)
condition|)
name|FUN2
argument_list|(
name|O_RENAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"rand"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_RAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"rmdir"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_RMDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"rindex"
argument_list|)
condition|)
name|FUN2x
argument_list|(
name|O_RINDEX
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"read"
argument_list|)
condition|)
name|FOP3
argument_list|(
name|O_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"readdir"
argument_list|)
condition|)
name|FOP
argument_list|(
name|O_READDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"rewinddir"
argument_list|)
condition|)
name|FOP
argument_list|(
name|O_REWINDDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"recv"
argument_list|)
condition|)
name|FOP4
argument_list|(
name|O_RECV
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"reverse"
argument_list|)
condition|)
name|LOP
argument_list|(
name|O_REVERSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"readlink"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_READLINK
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'\''
condition|)
block|{
name|d
operator|=
literal|"s"
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
name|SNARFWORD
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"s"
argument_list|)
condition|)
block|{
name|s
operator|=
name|scansubst
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|yylval
operator|.
name|arg
condition|)
name|TERM
argument_list|(
name|SUBST
argument_list|)
expr_stmt|;
else|else
name|RETURN
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* force error */
block|}
switch|switch
condition|(
name|d
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"scalar"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_SCALAR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"select"
argument_list|)
condition|)
name|OPERATOR
argument_list|(
name|SSELECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"seek"
argument_list|)
condition|)
name|FOP3
argument_list|(
name|O_SEEK
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"semctl"
argument_list|)
condition|)
name|FUN4
argument_list|(
name|O_SEMCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"semget"
argument_list|)
condition|)
name|FUN3
argument_list|(
name|O_SEMGET
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"semop"
argument_list|)
condition|)
name|FUN2
argument_list|(
name|O_SEMOP
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"send"
argument_list|)
condition|)
name|FOP3
argument_list|(
name|O_SEND
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setpgrp"
argument_list|)
condition|)
name|FUN2
argument_list|(
name|O_SETPGRP
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setpriority"
argument_list|)
condition|)
name|FUN3
argument_list|(
name|O_SETPRIORITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sethostent"
argument_list|)
condition|)
name|FUN1
argument_list|(
name|O_SHOSTENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setnetent"
argument_list|)
condition|)
name|FUN1
argument_list|(
name|O_SNETENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setservent"
argument_list|)
condition|)
name|FUN1
argument_list|(
name|O_SSERVENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setprotoent"
argument_list|)
condition|)
name|FUN1
argument_list|(
name|O_SPROTOENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setpwent"
argument_list|)
condition|)
name|FUN0
argument_list|(
name|O_SPWENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setgrent"
argument_list|)
condition|)
name|FUN0
argument_list|(
name|O_SGRENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"seekdir"
argument_list|)
condition|)
name|FOP2
argument_list|(
name|O_SEEKDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"setsockopt"
argument_list|)
condition|)
name|FOP4
argument_list|(
name|O_SSOCKOPT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"shift"
argument_list|)
condition|)
name|TERM
argument_list|(
name|SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"shmctl"
argument_list|)
condition|)
name|FUN3
argument_list|(
name|O_SHMCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"shmget"
argument_list|)
condition|)
name|FUN3
argument_list|(
name|O_SHMGET
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"shmread"
argument_list|)
condition|)
name|FUN4
argument_list|(
name|O_SHMREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"shmwrite"
argument_list|)
condition|)
name|FUN4
argument_list|(
name|O_SHMWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"shutdown"
argument_list|)
condition|)
name|FOP2
argument_list|(
name|O_SHUTDOWN
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sin"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_SIN
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sleep"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_SLEEP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"socket"
argument_list|)
condition|)
name|FOP4
argument_list|(
name|O_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"socketpair"
argument_list|)
condition|)
name|FOP25
argument_list|(
name|O_SOCKPAIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sort"
argument_list|)
condition|)
block|{
name|checkcomma
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
literal|"subroutine name"
argument_list|)
expr_stmt|;
name|d
operator|=
name|bufend
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|d
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|';'
operator|||
operator|*
name|s
operator|==
literal|')'
condition|)
comment|/* probably a close */
name|fatal
argument_list|(
literal|"sort is now a reserved word"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isALPHA
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'_'
condition|)
block|{
comment|/*SUPPRESS 530*/
for|for
control|(
name|d
operator|=
name|s
init|;
name|isALNUM
argument_list|(
operator|*
name|d
argument_list|)
condition|;
name|d
operator|++
control|)
empty_stmt|;
name|strncpy
argument_list|(
name|tokenbuf
argument_list|,
name|s
argument_list|,
name|d
operator|-
name|s
argument_list|)
expr_stmt|;
name|tokenbuf
index|[
name|d
operator|-
name|s
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strNE
argument_list|(
name|tokenbuf
argument_list|,
literal|"keys"
argument_list|)
operator|&&
name|strNE
argument_list|(
name|tokenbuf
argument_list|,
literal|"values"
argument_list|)
operator|&&
name|strNE
argument_list|(
name|tokenbuf
argument_list|,
literal|"split"
argument_list|)
operator|&&
name|strNE
argument_list|(
name|tokenbuf
argument_list|,
literal|"grep"
argument_list|)
operator|&&
name|strNE
argument_list|(
name|tokenbuf
argument_list|,
literal|"readdir"
argument_list|)
operator|&&
name|strNE
argument_list|(
name|tokenbuf
argument_list|,
literal|"unpack"
argument_list|)
operator|&&
name|strNE
argument_list|(
name|tokenbuf
argument_list|,
literal|"do"
argument_list|)
operator|&&
name|strNE
argument_list|(
name|tokenbuf
argument_list|,
literal|"eval"
argument_list|)
operator|&&
operator|(
name|d
operator|>=
name|bufend
operator|||
name|isSPACE
argument_list|(
operator|*
name|d
argument_list|)
operator|)
condition|)
operator|*
operator|(
operator|--
name|s
operator|)
operator|=
literal|'\\'
expr_stmt|;
comment|/* force next ident to WORD */
block|}
name|LOP
argument_list|(
name|O_SORT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"split"
argument_list|)
condition|)
name|TERM
argument_list|(
name|SPLIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sprintf"
argument_list|)
condition|)
name|FL
argument_list|(
name|O_SPRINTF
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"splice"
argument_list|)
condition|)
block|{
name|yylval
operator|.
name|ival
operator|=
name|O_SPLICE
expr_stmt|;
name|OPERATOR
argument_list|(
name|PUSH
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sqrt"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_SQRT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"srand"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_SRAND
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"stat"
argument_list|)
condition|)
name|FOP
argument_list|(
name|O_STAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"study"
argument_list|)
condition|)
block|{
name|sawstudy
operator|++
expr_stmt|;
name|LFUN
argument_list|(
name|O_STUDY
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"substr"
argument_list|)
condition|)
name|FUN2x
argument_list|(
name|O_SUBSTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sub"
argument_list|)
condition|)
block|{
name|yylval
operator|.
name|ival
operator|=
name|savestack
operator|->
name|ary_fill
expr_stmt|;
comment|/* restore stuff on reduce */
name|savelong
argument_list|(
operator|&
name|subline
argument_list|)
expr_stmt|;
name|saveitem
argument_list|(
name|subname
argument_list|)
expr_stmt|;
name|subline
operator|=
name|curcmd
operator|->
name|c_line
expr_stmt|;
name|d
operator|=
name|bufend
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|d
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|isALPHA
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'_'
operator|||
operator|*
name|s
operator|==
literal|'\''
condition|)
block|{
name|str_sset
argument_list|(
name|subname
argument_list|,
name|curstname
argument_list|)
expr_stmt|;
name|str_ncat
argument_list|(
name|subname
argument_list|,
literal|"'"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|d
operator|=
name|s
operator|+
literal|1
init|;
name|isALNUM
argument_list|(
operator|*
name|d
argument_list|)
operator|||
operator|*
name|d
operator|==
literal|'\''
condition|;
name|d
operator|++
control|)
comment|/*SUPPRESS 530*/
empty_stmt|;
if|if
condition|(
name|d
index|[
operator|-
literal|1
index|]
operator|==
literal|'\''
condition|)
name|d
operator|--
expr_stmt|;
name|str_ncat
argument_list|(
name|subname
argument_list|,
name|s
argument_list|,
name|d
operator|-
name|s
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|--
name|s
operator|)
operator|=
literal|'\\'
expr_stmt|;
comment|/* force next ident to WORD */
block|}
else|else
name|str_set
argument_list|(
name|subname
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
name|OPERATOR
argument_list|(
name|SUB
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
break|break;
case|case
literal|'y'
case|:
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"system"
argument_list|)
condition|)
block|{
name|set_csh
argument_list|()
expr_stmt|;
name|LOP
argument_list|(
name|O_SYSTEM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"symlink"
argument_list|)
condition|)
name|FUN2
argument_list|(
name|O_SYMLINK
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"syscall"
argument_list|)
condition|)
name|LOP
argument_list|(
name|O_SYSCALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sysread"
argument_list|)
condition|)
name|FOP3
argument_list|(
name|O_SYSREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"syswrite"
argument_list|)
condition|)
name|FOP3
argument_list|(
name|O_SYSWRITE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
break|break;
block|}
break|break;
case|case
literal|'t'
case|:
case|case
literal|'T'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"tr"
argument_list|)
condition|)
block|{
name|s
operator|=
name|scantrans
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|yylval
operator|.
name|arg
condition|)
name|TERM
argument_list|(
name|TRANS
argument_list|)
expr_stmt|;
else|else
name|RETURN
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* force error */
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"tell"
argument_list|)
condition|)
name|FOP
argument_list|(
name|O_TELL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"telldir"
argument_list|)
condition|)
name|FOP
argument_list|(
name|O_TELLDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"time"
argument_list|)
condition|)
name|FUN0
argument_list|(
name|O_TIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"times"
argument_list|)
condition|)
name|FUN0
argument_list|(
name|O_TMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"truncate"
argument_list|)
condition|)
name|FOP2
argument_list|(
name|O_TRUNCATE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"using"
argument_list|)
condition|)
name|OPERATOR
argument_list|(
name|USING
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"until"
argument_list|)
condition|)
block|{
name|yylval
operator|.
name|ival
operator|=
name|curcmd
operator|->
name|c_line
expr_stmt|;
name|OPERATOR
argument_list|(
name|UNTIL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"unless"
argument_list|)
condition|)
block|{
name|yylval
operator|.
name|ival
operator|=
name|curcmd
operator|->
name|c_line
expr_stmt|;
name|OPERATOR
argument_list|(
name|UNLESS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"unlink"
argument_list|)
condition|)
name|LOP
argument_list|(
name|O_UNLINK
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"undef"
argument_list|)
condition|)
name|LFUN
argument_list|(
name|O_UNDEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"unpack"
argument_list|)
condition|)
name|FUN2
argument_list|(
name|O_UNPACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"utime"
argument_list|)
condition|)
name|LOP
argument_list|(
name|O_UTIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"umask"
argument_list|)
condition|)
name|UNI
argument_list|(
name|O_UMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"unshift"
argument_list|)
condition|)
block|{
name|yylval
operator|.
name|ival
operator|=
name|O_UNSHIFT
expr_stmt|;
name|OPERATOR
argument_list|(
name|PUSH
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"values"
argument_list|)
condition|)
name|HFUN
argument_list|(
name|O_VALUES
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"vec"
argument_list|)
condition|)
block|{
name|sawvec
operator|=
name|TRUE
expr_stmt|;
name|FUN3
argument_list|(
name|O_VEC
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"while"
argument_list|)
condition|)
block|{
name|yylval
operator|.
name|ival
operator|=
name|curcmd
operator|->
name|c_line
expr_stmt|;
name|OPERATOR
argument_list|(
name|WHILE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"warn"
argument_list|)
condition|)
name|LOP
argument_list|(
name|O_WARN
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"wait"
argument_list|)
condition|)
name|FUN0
argument_list|(
name|O_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"waitpid"
argument_list|)
condition|)
name|FUN2
argument_list|(
name|O_WAITPID
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"wantarray"
argument_list|)
condition|)
block|{
name|yylval
operator|.
name|arg
operator|=
name|op_new
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|arg
operator|->
name|arg_type
operator|=
name|O_ITEM
expr_stmt|;
name|yylval
operator|.
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_WANTARRAY
expr_stmt|;
name|TERM
argument_list|(
name|RSTRING
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"write"
argument_list|)
condition|)
name|FOP
argument_list|(
name|O_WRITE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|'x'
operator|&&
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|expectterm
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|MOP
argument_list|(
name|O_REPEAT
argument_list|)
expr_stmt|;
block|}
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"x"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|expectterm
condition|)
name|MOP
argument_list|(
name|O_REPEAT
argument_list|)
expr_stmt|;
name|check_uni
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'y'
case|:
case|case
literal|'Y'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'\''
condition|)
block|{
name|d
operator|=
literal|"y"
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
name|SNARFWORD
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"y"
argument_list|)
condition|)
block|{
name|s
operator|=
name|scantrans
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|TERM
argument_list|(
name|TRANS
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'z'
case|:
case|case
literal|'Z'
case|:
name|SNARFWORD
expr_stmt|;
break|break;
block|}
name|yylval
operator|.
name|cval
operator|=
name|savestr
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|expectterm
operator|==
literal|2
condition|)
block|{
comment|/* special case: start of statement */
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|CLINE
expr_stmt|;
name|OPERATOR
argument_list|(
name|LABEL
argument_list|)
expr_stmt|;
block|}
name|TERM
argument_list|(
name|WORD
argument_list|)
expr_stmt|;
block|}
name|expectterm
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|oldoldbufptr
operator|&&
name|oldoldbufptr
operator|<
name|bufptr
condition|)
block|{
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|oldoldbufptr
argument_list|)
condition|)
name|oldoldbufptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|oldoldbufptr
operator|==
literal|'p'
operator|&&
name|strnEQ
argument_list|(
name|oldoldbufptr
argument_list|,
literal|"print"
argument_list|,
literal|5
argument_list|)
condition|)
name|expectterm
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|oldoldbufptr
operator|==
literal|'s'
operator|&&
name|strnEQ
argument_list|(
name|oldoldbufptr
argument_list|,
literal|"sort"
argument_list|,
literal|4
argument_list|)
condition|)
name|expectterm
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
operator|(
name|CLINE
operator|,
name|bufptr
operator|=
name|s
operator|,
operator|(
name|int
operator|)
name|WORD
operator|)
return|;
block|}
end_function

begin_function
name|void
name|checkcomma
parameter_list|(
name|s
parameter_list|,
name|name
parameter_list|,
name|what
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|what
decl_stmt|;
block|{
name|char
modifier|*
name|w
decl_stmt|;
if|if
condition|(
name|dowarn
operator|&&
operator|*
name|s
operator|==
literal|' '
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'('
condition|)
block|{
name|w
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
condition|)
for|for
control|(
name|w
operator|++
init|;
operator|*
name|w
operator|&&
name|isSPACE
argument_list|(
operator|*
name|w
argument_list|)
condition|;
name|w
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|w
operator|||
operator|!
operator|*
name|w
operator|||
operator|!
name|index
argument_list|(
literal|";|}"
argument_list|,
operator|*
name|w
argument_list|)
condition|)
comment|/* an advisory hack only... */
name|warn
argument_list|(
literal|"%s (...) interpreted as function"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|s
operator|<
name|bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'('
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|isALPHA
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'_'
condition|)
block|{
name|w
operator|=
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|bufend
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|w
operator|=
name|instr
argument_list|(
literal|"tell eof times getlogin wait length shift umask getppid \ 	      cos exp int log rand sin sqrt ord wantarray"
argument_list|,
name|w
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|','
expr_stmt|;
if|if
condition|(
name|w
condition|)
return|return;
name|fatal
argument_list|(
literal|"No comma allowed after %s"
argument_list|,
name|what
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|scanident
parameter_list|(
name|s
parameter_list|,
name|send
parameter_list|,
name|dest
parameter_list|,
name|destlen
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|send
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
name|STRLEN
name|destlen
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|e
decl_stmt|;
name|int
name|brackets
init|=
literal|0
decl_stmt|;
name|reparse
operator|=
name|Nullch
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|d
operator|=
name|dest
expr_stmt|;
name|e
operator|=
name|d
operator|+
name|destlen
operator|-
literal|3
expr_stmt|;
comment|/* two-character token, ending NUL */
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|d
operator|>=
name|e
condition|)
name|fatal
argument_list|(
literal|"Identifier too long"
argument_list|)
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'\''
condition|)
block|{
if|if
condition|(
name|d
operator|>=
name|e
condition|)
name|fatal
argument_list|(
literal|"Identifier too long"
argument_list|)
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
block|}
while|while
condition|(
name|d
operator|>
name|dest
operator|+
literal|1
operator|&&
name|d
index|[
operator|-
literal|1
index|]
operator|==
literal|'\''
condition|)
name|d
operator|--
operator|,
name|s
operator|--
expr_stmt|;
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|d
operator|=
name|dest
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|d
condition|)
block|{
operator|*
name|d
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|d
operator|==
literal|'{'
comment|/* } */
condition|)
block|{
name|d
operator|=
name|dest
expr_stmt|;
name|brackets
operator|++
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
operator|&&
name|brackets
condition|)
block|{
if|if
condition|(
operator|!
name|reparse
operator|&&
operator|(
name|d
operator|==
name|dest
operator|||
operator|(
operator|*
name|s
operator|&&
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
operator|)
operator|)
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|reparse
condition|)
name|reparse
operator|=
name|s
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
comment|/* { */
case|case
literal|'}'
case|:
name|brackets
operator|--
expr_stmt|;
if|if
condition|(
name|reparse
operator|&&
name|reparse
operator|==
name|s
operator|-
literal|1
condition|)
name|reparse
operator|=
name|Nullch
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
comment|/* } */
name|brackets
operator|++
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|d
operator|=
name|dest
expr_stmt|;
block|}
else|else
name|d
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|d
operator|==
literal|'^'
operator|&&
operator|(
name|isUPPER
argument_list|(
operator|*
name|s
argument_list|)
operator|||
name|index
argument_list|(
literal|"[\\]^_?"
argument_list|,
operator|*
name|s
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
operator|*
name|s
operator|==
literal|'D'
condition|)
name|debug
operator||=
literal|32768
expr_stmt|;
endif|#
directive|endif
operator|*
name|d
operator|=
operator|*
name|s
operator|++
operator|^
literal|64
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
name|void
name|scanconst
parameter_list|(
name|spat
parameter_list|,
name|string
parameter_list|,
name|len
parameter_list|)
name|SPAT
modifier|*
name|spat
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
name|tmpstr
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|origstring
init|=
name|string
decl_stmt|;
specifier|static
name|char
modifier|*
name|vert
init|=
literal|"|"
decl_stmt|;
if|if
condition|(
name|ninstr
argument_list|(
name|string
argument_list|,
name|string
operator|+
name|len
argument_list|,
name|vert
argument_list|,
name|vert
operator|+
literal|1
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|*
name|string
operator|==
literal|'^'
condition|)
name|string
operator|++
operator|,
name|len
operator|--
expr_stmt|;
name|tmpstr
operator|=
name|Str_new
argument_list|(
literal|86
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|str_nset
argument_list|(
name|tmpstr
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|t
operator|=
name|str_get
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
name|e
operator|=
name|t
operator|+
name|len
expr_stmt|;
name|tmpstr
operator|->
name|str_u
operator|.
name|str_useful
operator|=
literal|100
expr_stmt|;
for|for
control|(
name|d
operator|=
name|t
init|;
name|d
operator|<
name|e
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|d
condition|)
block|{
case|case
literal|'{'
case|:
if|if
condition|(
name|isDIGIT
argument_list|(
name|d
index|[
literal|1
index|]
argument_list|)
condition|)
name|e
operator|=
name|d
expr_stmt|;
else|else
goto|goto
name|defchar
goto|;
break|break;
case|case
literal|'.'
case|:
case|case
literal|'['
case|:
case|case
literal|'$'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'|'
case|:
case|case
literal|'+'
case|:
case|case
literal|'^'
case|:
name|e
operator|=
name|d
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|&&
name|index
argument_list|(
literal|"wWbB0123456789sSdDlLuUExc"
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|e
operator|=
name|d
expr_stmt|;
break|break;
block|}
name|Move
argument_list|(
name|d
operator|+
literal|1
argument_list|,
name|d
argument_list|,
name|e
operator|-
name|d
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|e
operator|--
expr_stmt|;
switch|switch
condition|(
operator|*
name|d
condition|)
block|{
case|case
literal|'n'
case|:
operator|*
name|d
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|d
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|d
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|d
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
operator|*
name|d
operator|=
literal|'\033'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
operator|*
name|d
operator|=
literal|'\007'
expr_stmt|;
break|break;
block|}
comment|/* FALL THROUGH */
default|default:
name|defchar
label|:
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|==
literal|'*'
operator|||
operator|(
name|d
index|[
literal|1
index|]
operator|==
literal|'{'
operator|&&
name|d
index|[
literal|2
index|]
operator|==
literal|'0'
operator|)
operator|||
name|d
index|[
literal|1
index|]
operator|==
literal|'?'
condition|)
block|{
name|e
operator|=
name|d
expr_stmt|;
break|break;
block|}
name|d
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|d
operator|==
name|t
condition|)
block|{
name|str_free
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|tmpstr
operator|->
name|str_cur
operator|=
name|d
operator|-
name|t
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|t
operator|+
name|len
condition|)
name|spat
operator|->
name|spat_flags
operator||=
name|SPAT_ALL
expr_stmt|;
if|if
condition|(
operator|*
name|origstring
operator|!=
literal|'^'
condition|)
name|spat
operator|->
name|spat_flags
operator||=
name|SPAT_SCANFIRST
expr_stmt|;
name|spat
operator|->
name|spat_short
operator|=
name|tmpstr
expr_stmt|;
name|spat
operator|->
name|spat_slen
operator|=
name|d
operator|-
name|t
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|scanpat
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|SPAT
modifier|*
name|spat
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|e
decl_stmt|;
name|int
name|len
decl_stmt|;
name|SPAT
name|savespat
decl_stmt|;
name|STR
modifier|*
name|str
init|=
name|Str_new
argument_list|(
literal|93
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|char
name|delim
decl_stmt|;
name|Newz
argument_list|(
literal|801
argument_list|,
name|spat
argument_list|,
literal|1
argument_list|,
name|SPAT
argument_list|)
expr_stmt|;
name|spat
operator|->
name|spat_next
operator|=
name|curstash
operator|->
name|tbl_spatroot
expr_stmt|;
comment|/* link into spat list */
name|curstash
operator|->
name|tbl_spatroot
operator|=
name|spat
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'m'
case|:
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
break|break;
case|case
literal|'?'
case|:
name|spat
operator|->
name|spat_flags
operator||=
name|SPAT_ONCE
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"panic: scanpat"
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|str_append_till
argument_list|(
name|str
argument_list|,
name|s
argument_list|,
name|bufend
argument_list|,
name|s
index|[
operator|-
literal|1
index|]
argument_list|,
name|patleave
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|bufend
condition|)
block|{
name|str_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
literal|"Search pattern not terminated"
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|arg
operator|=
name|Nullarg
expr_stmt|;
return|return
name|s
return|;
block|}
name|delim
operator|=
operator|*
name|s
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|'i'
operator|||
operator|*
name|s
operator|==
literal|'o'
operator|||
operator|*
name|s
operator|==
literal|'g'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'i'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|sawi
operator|=
name|TRUE
expr_stmt|;
name|spat
operator|->
name|spat_flags
operator||=
name|SPAT_FOLD
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'o'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|spat
operator|->
name|spat_flags
operator||=
name|SPAT_KEEP
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'g'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|spat
operator|->
name|spat_flags
operator||=
name|SPAT_GLOBAL
expr_stmt|;
block|}
block|}
name|len
operator|=
name|str
operator|->
name|str_cur
expr_stmt|;
name|e
operator|=
name|str
operator|->
name|str_ptr
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|delim
operator|==
literal|'\''
condition|)
name|d
operator|=
name|e
expr_stmt|;
else|else
name|d
operator|=
name|str
operator|->
name|str_ptr
expr_stmt|;
for|for
control|(
init|;
name|d
operator|<
name|e
condition|;
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|d
operator|==
literal|'\\'
condition|)
name|d
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|d
operator|==
literal|'$'
operator|&&
name|d
index|[
literal|1
index|]
operator|&&
name|d
index|[
literal|1
index|]
operator|!=
literal|'|'
operator|&&
name|d
index|[
literal|1
index|]
operator|!=
literal|')'
operator|)
operator|||
operator|(
operator|*
name|d
operator|==
literal|'@'
operator|)
condition|)
block|{
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
name|spat
operator|->
name|spat_runtime
operator|=
name|arg
operator|=
name|op_new
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|arg
operator|->
name|arg_type
operator|=
name|O_ITEM
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_DOUBLE
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
operator|=
name|str_smake
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|d
operator|=
name|scanident
argument_list|(
name|d
argument_list|,
name|bufend
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|stabent
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* make sure it's created */
for|for
control|(
init|;
name|d
operator|<
name|e
condition|;
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|d
operator|==
literal|'\\'
condition|)
name|d
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'$'
operator|&&
name|d
index|[
literal|1
index|]
operator|&&
name|d
index|[
literal|1
index|]
operator|!=
literal|'|'
operator|&&
name|d
index|[
literal|1
index|]
operator|!=
literal|')'
condition|)
block|{
name|d
operator|=
name|scanident
argument_list|(
name|d
argument_list|,
name|bufend
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|stabent
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'@'
condition|)
block|{
name|d
operator|=
name|scanident
argument_list|(
name|d
argument_list|,
name|bufend
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|buf
argument_list|,
literal|"ARGV"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|buf
argument_list|,
literal|"ENV"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|buf
argument_list|,
literal|"SIG"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|buf
argument_list|,
literal|"INC"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|stabent
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|got_pat
goto|;
comment|/* skip compiling for now */
block|}
block|}
if|if
condition|(
name|spat
operator|->
name|spat_flags
operator|&
name|SPAT_FOLD
condition|)
name|StructCopy
argument_list|(
name|spat
argument_list|,
operator|&
name|savespat
argument_list|,
name|SPAT
argument_list|)
expr_stmt|;
name|scanconst
argument_list|(
name|spat
argument_list|,
name|str
operator|->
name|str_ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|spat
operator|->
name|spat_flags
operator|&
name|SPAT_ALL
operator|)
operator|&&
operator|(
name|spat
operator|->
name|spat_flags
operator|&
name|SPAT_SCANFIRST
operator|)
condition|)
block|{
name|fbmcompile
argument_list|(
name|spat
operator|->
name|spat_short
argument_list|,
name|spat
operator|->
name|spat_flags
operator|&
name|SPAT_FOLD
argument_list|)
expr_stmt|;
name|spat
operator|->
name|spat_regexp
operator|=
name|regcomp
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|,
name|str
operator|->
name|str_ptr
operator|+
name|len
argument_list|,
name|spat
operator|->
name|spat_flags
operator|&
name|SPAT_FOLD
argument_list|)
expr_stmt|;
comment|/* Note that this regexp can still be used if someone says 		 * something like /a/&& s//b/;  so we can't delete it. 		 */
block|}
else|else
block|{
if|if
condition|(
name|spat
operator|->
name|spat_flags
operator|&
name|SPAT_FOLD
condition|)
name|StructCopy
argument_list|(
operator|&
name|savespat
argument_list|,
name|spat
argument_list|,
name|SPAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|spat
operator|->
name|spat_short
condition|)
name|fbmcompile
argument_list|(
name|spat
operator|->
name|spat_short
argument_list|,
name|spat
operator|->
name|spat_flags
operator|&
name|SPAT_FOLD
argument_list|)
expr_stmt|;
name|spat
operator|->
name|spat_regexp
operator|=
name|regcomp
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|,
name|str
operator|->
name|str_ptr
operator|+
name|len
argument_list|,
name|spat
operator|->
name|spat_flags
operator|&
name|SPAT_FOLD
argument_list|)
expr_stmt|;
name|hoistmust
argument_list|(
name|spat
argument_list|)
expr_stmt|;
block|}
name|got_pat
label|:
name|str_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|arg
operator|=
name|make_match
argument_list|(
name|O_MATCH
argument_list|,
name|stab2arg
argument_list|(
name|A_STAB
argument_list|,
name|defstab
argument_list|)
argument_list|,
name|spat
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|scansubst
parameter_list|(
name|start
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|start
decl_stmt|;
specifier|register
name|SPAT
modifier|*
name|spat
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|e
decl_stmt|;
name|int
name|len
decl_stmt|;
name|STR
modifier|*
name|str
init|=
name|Str_new
argument_list|(
literal|93
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|char
name|term
init|=
operator|*
name|s
decl_stmt|;
if|if
condition|(
name|term
operator|&&
operator|(
name|d
operator|=
name|index
argument_list|(
literal|"([{< )]}> )]}>"
argument_list|,
name|term
argument_list|)
operator|)
condition|)
name|term
operator|=
name|d
index|[
literal|5
index|]
expr_stmt|;
name|Newz
argument_list|(
literal|802
argument_list|,
name|spat
argument_list|,
literal|1
argument_list|,
name|SPAT
argument_list|)
expr_stmt|;
name|spat
operator|->
name|spat_next
operator|=
name|curstash
operator|->
name|tbl_spatroot
expr_stmt|;
comment|/* link into spat list */
name|curstash
operator|->
name|tbl_spatroot
operator|=
name|spat
expr_stmt|;
name|s
operator|=
name|str_append_till
argument_list|(
name|str
argument_list|,
name|s
operator|+
literal|1
argument_list|,
name|bufend
argument_list|,
name|term
argument_list|,
name|patleave
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|bufend
condition|)
block|{
name|str_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
literal|"Substitution pattern not terminated"
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|arg
operator|=
name|Nullarg
expr_stmt|;
return|return
name|s
return|;
block|}
name|len
operator|=
name|str
operator|->
name|str_cur
expr_stmt|;
name|e
operator|=
name|str
operator|->
name|str_ptr
operator|+
name|len
expr_stmt|;
for|for
control|(
name|d
operator|=
name|str
operator|->
name|str_ptr
init|;
name|d
operator|<
name|e
condition|;
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|d
operator|==
literal|'\\'
condition|)
name|d
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|d
operator|==
literal|'$'
operator|&&
name|d
index|[
literal|1
index|]
operator|&&
name|d
index|[
literal|1
index|]
operator|!=
literal|'|'
operator|&&
comment|/*(*/
name|d
index|[
literal|1
index|]
operator|!=
literal|')'
operator|)
operator|||
operator|*
name|d
operator|==
literal|'@'
condition|)
block|{
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
name|spat
operator|->
name|spat_runtime
operator|=
name|arg
operator|=
name|op_new
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|arg
operator|->
name|arg_type
operator|=
name|O_ITEM
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_DOUBLE
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
operator|=
name|str_smake
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|d
operator|=
name|scanident
argument_list|(
name|d
argument_list|,
name|e
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|stabent
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* make sure it's created */
for|for
control|(
init|;
operator|*
name|d
condition|;
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|d
operator|==
literal|'$'
operator|&&
name|d
index|[
literal|1
index|]
operator|&&
name|d
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
operator|&&
name|d
index|[
literal|1
index|]
operator|!=
literal|'|'
condition|)
block|{
name|d
operator|=
name|scanident
argument_list|(
name|d
argument_list|,
name|e
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|stabent
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'@'
operator|&&
name|d
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
condition|)
block|{
name|d
operator|=
name|scanident
argument_list|(
name|d
argument_list|,
name|e
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|buf
argument_list|,
literal|"ARGV"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|buf
argument_list|,
literal|"ENV"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|buf
argument_list|,
literal|"SIG"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|buf
argument_list|,
literal|"INC"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|stabent
argument_list|(
name|buf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|get_repl
goto|;
comment|/* skip compiling for now */
block|}
block|}
name|scanconst
argument_list|(
name|spat
argument_list|,
name|str
operator|->
name|str_ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|get_repl
label|:
if|if
condition|(
name|term
operator|!=
operator|*
name|start
condition|)
name|s
operator|++
expr_stmt|;
name|s
operator|=
name|scanstr
argument_list|(
name|s
argument_list|,
name|SCAN_REPL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|bufend
condition|)
block|{
name|str_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
literal|"Substitution replacement not terminated"
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|arg
operator|=
name|Nullarg
expr_stmt|;
return|return
name|s
return|;
block|}
name|spat
operator|->
name|spat_repl
operator|=
name|yylval
operator|.
name|arg
expr_stmt|;
if|if
condition|(
operator|(
name|spat
operator|->
name|spat_repl
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_SINGLE
condition|)
name|spat
operator|->
name|spat_flags
operator||=
name|SPAT_CONST
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|spat
operator|->
name|spat_repl
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_DOUBLE
condition|)
block|{
name|STR
modifier|*
name|tmpstr
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|spat
operator|->
name|spat_flags
operator||=
name|SPAT_CONST
expr_stmt|;
name|tmpstr
operator|=
name|spat
operator|->
name|spat_repl
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
name|e
operator|=
name|tmpstr
operator|->
name|str_ptr
operator|+
name|tmpstr
operator|->
name|str_cur
expr_stmt|;
for|for
control|(
name|t
operator|=
name|tmpstr
operator|->
name|str_ptr
init|;
name|t
operator|<
name|e
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
literal|'$'
operator|&&
name|t
index|[
literal|1
index|]
operator|&&
operator|(
name|index
argument_list|(
literal|"`'&+0123456789"
argument_list|,
name|t
index|[
literal|1
index|]
argument_list|)
operator|||
operator|(
name|t
index|[
literal|1
index|]
operator|==
literal|'{'
comment|/*}*/
operator|&&
name|isDIGIT
argument_list|(
name|t
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
condition|)
name|spat
operator|->
name|spat_flags
operator|&=
operator|~
name|SPAT_CONST
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|*
name|s
operator|==
literal|'g'
operator|||
operator|*
name|s
operator|==
literal|'i'
operator|||
operator|*
name|s
operator|==
literal|'e'
operator|||
operator|*
name|s
operator|==
literal|'o'
condition|)
block|{
name|int
name|es
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'e'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|es
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|spat
operator|->
name|spat_repl
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_DOUBLE
condition|)
name|spat
operator|->
name|spat_repl
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_SINGLE
expr_stmt|;
name|spat
operator|->
name|spat_repl
operator|=
name|make_op
argument_list|(
operator|(
operator|!
name|es
operator|&&
name|spat
operator|->
name|spat_repl
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_SINGLE
condition|?
name|O_EVALONCE
else|:
name|O_EVAL
operator|)
argument_list|,
literal|2
argument_list|,
name|spat
operator|->
name|spat_repl
argument_list|,
name|Nullarg
argument_list|,
name|Nullarg
argument_list|)
expr_stmt|;
name|spat
operator|->
name|spat_flags
operator|&=
operator|~
name|SPAT_CONST
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'g'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|spat
operator|->
name|spat_flags
operator||=
name|SPAT_GLOBAL
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'i'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|sawi
operator|=
name|TRUE
expr_stmt|;
name|spat
operator|->
name|spat_flags
operator||=
name|SPAT_FOLD
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|spat
operator|->
name|spat_flags
operator|&
name|SPAT_SCANFIRST
operator|)
condition|)
block|{
name|str_free
argument_list|(
name|spat
operator|->
name|spat_short
argument_list|)
expr_stmt|;
comment|/* anchored opt doesn't do */
name|spat
operator|->
name|spat_short
operator|=
name|Nullstr
expr_stmt|;
comment|/* case insensitive match */
name|spat
operator|->
name|spat_slen
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'o'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|spat
operator|->
name|spat_flags
operator||=
name|SPAT_KEEP
expr_stmt|;
block|}
block|}
if|if
condition|(
name|spat
operator|->
name|spat_short
operator|&&
operator|(
name|spat
operator|->
name|spat_flags
operator|&
name|SPAT_SCANFIRST
operator|)
condition|)
name|fbmcompile
argument_list|(
name|spat
operator|->
name|spat_short
argument_list|,
name|spat
operator|->
name|spat_flags
operator|&
name|SPAT_FOLD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|spat
operator|->
name|spat_runtime
condition|)
block|{
name|spat
operator|->
name|spat_regexp
operator|=
name|regcomp
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|,
name|str
operator|->
name|str_ptr
operator|+
name|len
argument_list|,
name|spat
operator|->
name|spat_flags
operator|&
name|SPAT_FOLD
argument_list|)
expr_stmt|;
name|hoistmust
argument_list|(
name|spat
argument_list|)
expr_stmt|;
block|}
name|yylval
operator|.
name|arg
operator|=
name|make_match
argument_list|(
name|O_SUBST
argument_list|,
name|stab2arg
argument_list|(
name|A_STAB
argument_list|,
name|defstab
argument_list|)
argument_list|,
name|spat
argument_list|)
expr_stmt|;
name|str_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|void
name|hoistmust
parameter_list|(
name|spat
parameter_list|)
specifier|register
name|SPAT
modifier|*
name|spat
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|spat
operator|->
name|spat_short
operator|&&
name|spat
operator|->
name|spat_regexp
operator|->
name|regstart
operator|&&
operator|(
operator|!
name|spat
operator|->
name|spat_regexp
operator|->
name|regmust
operator|||
name|spat
operator|->
name|spat_regexp
operator|->
name|reganch
operator|&
name|ROPT_ANCH
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|spat
operator|->
name|spat_regexp
operator|->
name|reganch
operator|&
name|ROPT_ANCH
operator|)
condition|)
name|spat
operator|->
name|spat_flags
operator||=
name|SPAT_SCANFIRST
expr_stmt|;
elseif|else
if|if
condition|(
name|spat
operator|->
name|spat_flags
operator|&
name|SPAT_FOLD
condition|)
return|return;
name|spat
operator|->
name|spat_short
operator|=
name|str_smake
argument_list|(
name|spat
operator|->
name|spat_regexp
operator|->
name|regstart
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|spat
operator|->
name|spat_regexp
operator|->
name|regmust
condition|)
block|{
comment|/* is there a better short-circuit? */
if|if
condition|(
name|spat
operator|->
name|spat_short
operator|&&
name|str_eq
argument_list|(
name|spat
operator|->
name|spat_short
argument_list|,
name|spat
operator|->
name|spat_regexp
operator|->
name|regmust
argument_list|)
condition|)
block|{
if|if
condition|(
name|spat
operator|->
name|spat_flags
operator|&
name|SPAT_SCANFIRST
condition|)
block|{
name|str_free
argument_list|(
name|spat
operator|->
name|spat_short
argument_list|)
expr_stmt|;
name|spat
operator|->
name|spat_short
operator|=
name|Nullstr
expr_stmt|;
block|}
else|else
block|{
name|str_free
argument_list|(
name|spat
operator|->
name|spat_regexp
operator|->
name|regmust
argument_list|)
expr_stmt|;
name|spat
operator|->
name|spat_regexp
operator|->
name|regmust
operator|=
name|Nullstr
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
operator|!
name|spat
operator|->
name|spat_short
operator|||
comment|/* promote the better string */
operator|(
operator|(
name|spat
operator|->
name|spat_flags
operator|&
name|SPAT_SCANFIRST
operator|)
operator|&&
operator|(
name|spat
operator|->
name|spat_short
operator|->
name|str_cur
operator|<
name|spat
operator|->
name|spat_regexp
operator|->
name|regmust
operator|->
name|str_cur
operator|)
operator|)
condition|)
block|{
name|str_free
argument_list|(
name|spat
operator|->
name|spat_short
argument_list|)
expr_stmt|;
comment|/* ok if null */
name|spat
operator|->
name|spat_short
operator|=
name|spat
operator|->
name|spat_regexp
operator|->
name|regmust
expr_stmt|;
name|spat
operator|->
name|spat_regexp
operator|->
name|regmust
operator|=
name|Nullstr
expr_stmt|;
name|spat
operator|->
name|spat_flags
operator||=
name|SPAT_SCANFIRST
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|scantrans
parameter_list|(
name|start
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|start
decl_stmt|;
name|ARG
modifier|*
name|arg
init|=
name|l
argument_list|(
name|make_op
argument_list|(
name|O_TRANS
argument_list|,
literal|2
argument_list|,
name|stab2arg
argument_list|(
name|A_STAB
argument_list|,
name|defstab
argument_list|)
argument_list|,
name|Nullarg
argument_list|,
name|Nullarg
argument_list|)
argument_list|)
decl_stmt|;
name|STR
modifier|*
name|tstr
decl_stmt|;
name|STR
modifier|*
name|rstr
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|r
decl_stmt|;
specifier|register
name|short
modifier|*
name|tbl
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|int
name|tlen
decl_stmt|,
name|rlen
decl_stmt|;
name|int
name|squash
decl_stmt|;
name|int
name|delete
decl_stmt|;
name|int
name|complement
decl_stmt|;
name|New
argument_list|(
literal|803
argument_list|,
name|tbl
argument_list|,
literal|256
argument_list|,
name|short
argument_list|)
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|=
name|A_NULL
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_cval
operator|=
operator|(
name|char
operator|*
operator|)
name|tbl
expr_stmt|;
name|s
operator|=
name|scanstr
argument_list|(
name|s
argument_list|,
name|SCAN_TR
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|bufend
condition|)
block|{
name|yyerror
argument_list|(
literal|"Translation pattern not terminated"
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|arg
operator|=
name|Nullarg
expr_stmt|;
return|return
name|s
return|;
block|}
name|tstr
operator|=
name|yylval
operator|.
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
name|yylval
operator|.
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
operator|=
name|Nullstr
expr_stmt|;
name|arg_free
argument_list|(
name|yylval
operator|.
name|arg
argument_list|)
expr_stmt|;
name|t
operator|=
name|tstr
operator|->
name|str_ptr
expr_stmt|;
name|tlen
operator|=
name|tstr
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
operator|*
name|start
condition|)
name|s
operator|--
expr_stmt|;
name|s
operator|=
name|scanstr
argument_list|(
name|s
argument_list|,
name|SCAN_TR
operator||
name|SCAN_REPL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|bufend
condition|)
block|{
name|yyerror
argument_list|(
literal|"Translation replacement not terminated"
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|arg
operator|=
name|Nullarg
expr_stmt|;
return|return
name|s
return|;
block|}
name|rstr
operator|=
name|yylval
operator|.
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
name|yylval
operator|.
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
operator|=
name|Nullstr
expr_stmt|;
name|arg_free
argument_list|(
name|yylval
operator|.
name|arg
argument_list|)
expr_stmt|;
name|r
operator|=
name|rstr
operator|->
name|str_ptr
expr_stmt|;
name|rlen
operator|=
name|rstr
operator|->
name|str_cur
expr_stmt|;
name|complement
operator|=
name|delete
operator|=
name|squash
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|'c'
operator|||
operator|*
name|s
operator|==
literal|'d'
operator|||
operator|*
name|s
operator|==
literal|'s'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'c'
condition|)
name|complement
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'d'
condition|)
name|delete
operator|=
literal|2
expr_stmt|;
else|else
name|squash
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
name|arg
index|[
literal|2
index|]
operator|.
name|arg_len
operator|=
name|delete
operator||
name|squash
expr_stmt|;
name|yylval
operator|.
name|arg
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|complement
condition|)
block|{
name|Zero
argument_list|(
name|tbl
argument_list|,
literal|256
argument_list|,
name|short
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tlen
condition|;
name|i
operator|++
control|)
name|tbl
index|[
name|t
index|[
name|i
index|]
operator|&
literal|0377
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|tbl
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|j
operator|>=
name|rlen
condition|)
block|{
if|if
condition|(
name|delete
condition|)
name|tbl
index|[
name|i
index|]
operator|=
operator|-
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|rlen
condition|)
name|tbl
index|[
name|i
index|]
operator|=
name|r
index|[
name|j
operator|-
literal|1
index|]
operator|&
literal|0377
expr_stmt|;
else|else
name|tbl
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
else|else
name|tbl
index|[
name|i
index|]
operator|=
name|r
index|[
name|j
operator|++
index|]
operator|&
literal|0377
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|rlen
operator|&&
operator|!
name|delete
condition|)
block|{
name|r
operator|=
name|t
expr_stmt|;
name|rlen
operator|=
name|tlen
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|tbl
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|tlen
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
name|rlen
condition|)
block|{
if|if
condition|(
name|delete
condition|)
block|{
if|if
condition|(
name|tbl
index|[
name|t
index|[
name|i
index|]
operator|&
literal|0377
index|]
operator|==
operator|-
literal|1
condition|)
name|tbl
index|[
name|t
index|[
name|i
index|]
operator|&
literal|0377
index|]
operator|=
operator|-
literal|2
expr_stmt|;
continue|continue;
block|}
operator|--
name|j
expr_stmt|;
block|}
if|if
condition|(
name|tbl
index|[
name|t
index|[
name|i
index|]
operator|&
literal|0377
index|]
operator|==
operator|-
literal|1
condition|)
name|tbl
index|[
name|t
index|[
name|i
index|]
operator|&
literal|0377
index|]
operator|=
name|r
index|[
name|j
index|]
operator|&
literal|0377
expr_stmt|;
block|}
block|}
name|str_free
argument_list|(
name|tstr
argument_list|)
expr_stmt|;
name|str_free
argument_list|(
name|rstr
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|scanstr
parameter_list|(
name|start
parameter_list|,
name|in_what
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|in_what
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|start
decl_stmt|;
specifier|register
name|char
name|term
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
specifier|register
name|char
modifier|*
name|send
decl_stmt|;
specifier|register
name|bool
name|makesingle
init|=
name|FALSE
decl_stmt|;
specifier|register
name|STAB
modifier|*
name|stab
decl_stmt|;
name|bool
name|alwaysdollar
init|=
name|FALSE
decl_stmt|;
name|bool
name|hereis
init|=
name|FALSE
decl_stmt|;
name|STR
modifier|*
name|herewas
decl_stmt|;
name|STR
modifier|*
name|str
decl_stmt|;
comment|/* which backslash sequences to keep */
name|char
modifier|*
name|leave
init|=
operator|(
name|in_what
operator|&
name|SCAN_TR
operator|)
condition|?
literal|"\\$@nrtfbeacx0123456789-"
else|:
literal|"\\$@nrtfbeacx0123456789[{]}lLuUE"
decl_stmt|;
name|int
name|len
decl_stmt|;
name|arg
operator|=
name|op_new
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|arg
operator|=
name|arg
expr_stmt|;
name|arg
operator|->
name|arg_type
operator|=
name|O_ITEM
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
default|default:
comment|/* a substitution replacement */
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_DOUBLE
expr_stmt|;
name|makesingle
operator|=
name|TRUE
expr_stmt|;
comment|/* maybe disable runtime scanning */
name|term
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|term
operator|==
literal|'\''
condition|)
name|leave
operator|=
name|Nullch
expr_stmt|;
goto|goto
name|snarf_it
goto|;
case|case
literal|'0'
case|:
block|{
name|unsigned
name|long
name|i
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_SINGLE
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'x'
condition|)
block|{
name|shift
operator|=
literal|4
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
goto|goto
name|decimal
goto|;
else|else
name|shift
operator|=
literal|3
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
default|default:
goto|goto
name|out
goto|;
case|case
literal|'_'
case|:
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|shift
operator|!=
literal|4
condition|)
name|yyerror
argument_list|(
literal|"Illegal octal digit"
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|i
operator|<<=
name|shift
expr_stmt|;
name|i
operator|+=
operator|*
name|s
operator|++
operator|&
literal|15
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
if|if
condition|(
name|shift
operator|!=
literal|4
condition|)
goto|goto
name|out
goto|;
name|i
operator|<<=
literal|4
expr_stmt|;
name|i
operator|+=
operator|(
operator|*
name|s
operator|++
operator|&
literal|7
operator|)
operator|+
literal|9
expr_stmt|;
break|break;
block|}
block|}
name|out
label|:
name|str
operator|=
name|Str_new
argument_list|(
literal|92
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|double
operator|)
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|->
name|str_ptr
condition|)
block|{
name|Safefree
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_ptr
operator|=
name|Nullch
expr_stmt|;
name|str
operator|->
name|str_len
operator|=
name|str
operator|->
name|str_cur
operator|=
literal|0
expr_stmt|;
block|}
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
operator|=
name|str
expr_stmt|;
block|}
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'.'
case|:
name|decimal
label|:
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_SINGLE
expr_stmt|;
name|d
operator|=
name|tokenbuf
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'_'
condition|)
name|s
operator|++
expr_stmt|;
else|else
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
operator|&&
name|s
index|[
literal|1
index|]
operator|!=
literal|'.'
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'_'
condition|)
name|s
operator|++
expr_stmt|;
else|else
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|s
operator|&&
name|index
argument_list|(
literal|"eE"
argument_list|,
operator|*
name|s
argument_list|)
operator|&&
name|index
argument_list|(
literal|"+-0123456789"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
operator|||
operator|*
name|s
operator|==
literal|'-'
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|str
operator|=
name|Str_new
argument_list|(
literal|92
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
name|atof
argument_list|(
name|tokenbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|->
name|str_ptr
condition|)
block|{
name|Safefree
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_ptr
operator|=
name|Nullch
expr_stmt|;
name|str
operator|->
name|str_len
operator|=
name|str
operator|->
name|str_cur
operator|=
literal|0
expr_stmt|;
block|}
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
operator|=
name|str
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|in_what
operator|&
operator|(
name|SCAN_REPL
operator||
name|SCAN_TR
operator|)
condition|)
goto|goto
name|do_double
goto|;
if|if
condition|(
operator|*
operator|++
name|s
operator|==
literal|'<'
condition|)
block|{
name|hereis
operator|=
name|TRUE
expr_stmt|;
name|d
operator|=
name|tokenbuf
expr_stmt|;
if|if
condition|(
operator|!
name|rsfp
condition|)
operator|*
name|d
operator|++
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|s
operator|&&
name|index
argument_list|(
literal|"`'\""
argument_list|,
operator|*
name|s
argument_list|)
condition|)
block|{
name|term
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|s
operator|=
name|cpytill
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
name|bufend
argument_list|,
name|term
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|bufend
condition|)
name|s
operator|++
expr_stmt|;
name|d
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
name|s
operator|++
operator|,
name|term
operator|=
literal|'\''
expr_stmt|;
else|else
name|term
operator|=
literal|'"'
expr_stmt|;
while|while
condition|(
name|isALNUM
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
comment|/* assuming tokenbuf won't clobber */
operator|*
name|d
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|d
operator|-
name|tokenbuf
expr_stmt|;
name|d
operator|=
literal|"\n"
expr_stmt|;
if|if
condition|(
name|rsfp
operator|||
operator|!
operator|(
name|d
operator|=
name|ninstr
argument_list|(
name|s
argument_list|,
name|bufend
argument_list|,
name|d
argument_list|,
name|d
operator|+
literal|1
argument_list|)
operator|)
condition|)
name|herewas
operator|=
name|str_make
argument_list|(
name|s
argument_list|,
name|bufend
operator|-
name|s
argument_list|)
expr_stmt|;
else|else
name|s
operator|--
operator|,
name|herewas
operator|=
name|str_make
argument_list|(
name|s
argument_list|,
name|d
operator|-
name|s
argument_list|)
expr_stmt|;
name|s
operator|+=
name|herewas
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
name|term
operator|==
literal|'\''
condition|)
goto|goto
name|do_single
goto|;
if|if
condition|(
name|term
operator|==
literal|'`'
condition|)
goto|goto
name|do_back
goto|;
goto|goto
name|do_double
goto|;
block|}
name|d
operator|=
name|tokenbuf
expr_stmt|;
name|s
operator|=
name|cpytill
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
name|bufend
argument_list|,
literal|'>'
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|bufend
condition|)
name|s
operator|++
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"Unterminated<> operator"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|d
operator|==
literal|'$'
condition|)
name|d
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|d
operator|&&
operator|(
name|isALNUM
argument_list|(
operator|*
name|d
argument_list|)
operator|||
operator|*
name|d
operator|==
literal|'\''
operator|)
condition|)
name|d
operator|++
expr_stmt|;
if|if
condition|(
name|d
operator|-
name|tokenbuf
operator|!=
name|len
condition|)
block|{
name|s
operator|=
name|start
expr_stmt|;
name|term
operator|=
operator|*
name|s
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_GLOB
expr_stmt|;
name|set_csh
argument_list|()
expr_stmt|;
name|alwaysdollar
operator|=
name|TRUE
expr_stmt|;
comment|/* treat $) and $| as variables */
goto|goto
name|snarf_it
goto|;
block|}
else|else
block|{
name|d
operator|=
name|tokenbuf
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|d
argument_list|,
literal|"ARGV"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|d
operator|==
literal|'$'
condition|)
block|{
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_INDREAD
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
operator|=
name|stabent
argument_list|(
name|d
operator|+
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_READ
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
operator|=
name|stabent
argument_list|(
name|d
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_io
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
condition|)
name|stab_io
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
operator|=
name|stio_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ARGV"
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|aadd
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
expr_stmt|;
name|stab_io
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
operator|->
name|flags
operator||=
name|IOF_ARGV
operator||
name|IOF_START
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|'q'
case|:
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'q'
condition|)
block|{
name|s
operator|++
expr_stmt|;
goto|goto
name|do_double
goto|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'x'
condition|)
block|{
name|s
operator|++
expr_stmt|;
goto|goto
name|do_back
goto|;
block|}
comment|/* FALL THROUGH */
case|case
literal|'\''
case|:
name|do_single
label|:
name|term
operator|=
operator|*
name|s
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_SINGLE
expr_stmt|;
name|leave
operator|=
name|Nullch
expr_stmt|;
goto|goto
name|snarf_it
goto|;
case|case
literal|'"'
case|:
name|do_double
label|:
name|term
operator|=
operator|*
name|s
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_DOUBLE
expr_stmt|;
name|makesingle
operator|=
name|TRUE
expr_stmt|;
comment|/* maybe disable runtime scanning */
name|alwaysdollar
operator|=
name|TRUE
expr_stmt|;
comment|/* treat $) and $| as variables */
goto|goto
name|snarf_it
goto|;
case|case
literal|'`'
case|:
name|do_back
label|:
name|term
operator|=
operator|*
name|s
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_BACKTICK
expr_stmt|;
name|set_csh
argument_list|()
expr_stmt|;
name|alwaysdollar
operator|=
name|TRUE
expr_stmt|;
comment|/* treat $) and $| as variables */
name|snarf_it
label|:
block|{
name|STR
modifier|*
name|tmpstr
decl_stmt|;
name|STR
modifier|*
name|tmpstr2
init|=
name|Nullstr
decl_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|bool
name|dorange
init|=
name|FALSE
decl_stmt|;
name|CLINE
expr_stmt|;
name|multi_start
operator|=
name|curcmd
operator|->
name|c_line
expr_stmt|;
if|if
condition|(
name|hereis
condition|)
name|multi_open
operator|=
name|multi_close
operator|=
literal|'<'
expr_stmt|;
else|else
block|{
name|multi_open
operator|=
name|term
expr_stmt|;
if|if
condition|(
name|term
operator|&&
operator|(
name|tmps
operator|=
name|index
argument_list|(
literal|"([{< )]}> )]}>"
argument_list|,
name|term
argument_list|)
operator|)
condition|)
name|term
operator|=
name|tmps
index|[
literal|5
index|]
expr_stmt|;
name|multi_close
operator|=
name|term
expr_stmt|;
block|}
name|tmpstr
operator|=
name|Str_new
argument_list|(
literal|87
argument_list|,
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|hereis
condition|)
block|{
name|term
operator|=
operator|*
name|tokenbuf
expr_stmt|;
if|if
condition|(
operator|!
name|rsfp
condition|)
block|{
name|d
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|bufend
operator|&&
operator|(
operator|*
name|s
operator|!=
name|term
operator|||
name|bcmp
argument_list|(
name|s
argument_list|,
name|tokenbuf
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'\n'
condition|)
name|curcmd
operator|->
name|c_line
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|>=
name|bufend
condition|)
block|{
name|curcmd
operator|->
name|c_line
operator|=
name|multi_start
expr_stmt|;
name|fatal
argument_list|(
literal|"EOF in string"
argument_list|)
expr_stmt|;
block|}
name|str_nset
argument_list|(
name|tmpstr
argument_list|,
name|d
operator|+
literal|1
argument_list|,
name|s
operator|-
name|d
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
operator|-
literal|1
expr_stmt|;
name|str_ncat
argument_list|(
name|herewas
argument_list|,
name|s
argument_list|,
name|bufend
operator|-
name|s
argument_list|)
expr_stmt|;
name|str_replace
argument_list|(
name|linestr
argument_list|,
name|herewas
argument_list|)
expr_stmt|;
name|oldoldbufptr
operator|=
name|oldbufptr
operator|=
name|bufptr
operator|=
name|s
operator|=
name|str_get
argument_list|(
name|linestr
argument_list|)
expr_stmt|;
name|bufend
operator|=
name|linestr
operator|->
name|str_ptr
operator|+
name|linestr
operator|->
name|str_cur
expr_stmt|;
name|hereis
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
name|str_nset
argument_list|(
name|tmpstr
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* avoid "uninitialized" warning */
block|}
else|else
name|s
operator|=
name|str_append_till
argument_list|(
name|tmpstr
argument_list|,
name|s
operator|+
literal|1
argument_list|,
name|bufend
argument_list|,
name|term
argument_list|,
name|leave
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|>=
name|bufend
condition|)
block|{
comment|/* multiple line string? */
if|if
condition|(
operator|!
name|rsfp
operator|||
operator|!
operator|(
name|oldoldbufptr
operator|=
name|oldbufptr
operator|=
name|s
operator|=
name|str_gets
argument_list|(
name|linestr
argument_list|,
name|rsfp
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|curcmd
operator|->
name|c_line
operator|=
name|multi_start
expr_stmt|;
name|fatal
argument_list|(
literal|"EOF in string"
argument_list|)
expr_stmt|;
block|}
name|curcmd
operator|->
name|c_line
operator|++
expr_stmt|;
if|if
condition|(
name|perldb
condition|)
block|{
name|STR
modifier|*
name|str
init|=
name|Str_new
argument_list|(
literal|88
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|str_sset
argument_list|(
name|str
argument_list|,
name|linestr
argument_list|)
expr_stmt|;
name|astore
argument_list|(
name|stab_xarray
argument_list|(
name|curcmd
operator|->
name|c_filestab
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|curcmd
operator|->
name|c_line
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|bufend
operator|=
name|linestr
operator|->
name|str_ptr
operator|+
name|linestr
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
name|hereis
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
name|term
operator|&&
name|bcmp
argument_list|(
name|s
argument_list|,
name|tokenbuf
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|=
name|bufend
operator|-
literal|1
expr_stmt|;
operator|*
name|s
operator|=
literal|' '
expr_stmt|;
name|str_scat
argument_list|(
name|linestr
argument_list|,
name|herewas
argument_list|)
expr_stmt|;
name|bufend
operator|=
name|linestr
operator|->
name|str_ptr
operator|+
name|linestr
operator|->
name|str_cur
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|bufend
expr_stmt|;
name|str_scat
argument_list|(
name|tmpstr
argument_list|,
name|linestr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|s
operator|=
name|str_append_till
argument_list|(
name|tmpstr
argument_list|,
name|s
argument_list|,
name|bufend
argument_list|,
name|term
argument_list|,
name|leave
argument_list|)
expr_stmt|;
block|}
name|multi_end
operator|=
name|curcmd
operator|->
name|c_line
expr_stmt|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmpstr
operator|->
name|str_cur
operator|+
literal|5
operator|<
name|tmpstr
operator|->
name|str_len
condition|)
block|{
name|tmpstr
operator|->
name|str_len
operator|=
name|tmpstr
operator|->
name|str_cur
operator|+
literal|1
expr_stmt|;
name|Renew
argument_list|(
name|tmpstr
operator|->
name|str_ptr
argument_list|,
name|tmpstr
operator|->
name|str_len
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_SINGLE
condition|)
block|{
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
operator|=
name|tmpstr
expr_stmt|;
break|break;
block|}
name|tmps
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|tmpstr
operator|->
name|str_ptr
expr_stmt|;
name|send
operator|=
name|s
operator|+
name|tmpstr
operator|->
name|str_cur
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
comment|/* see if we can make SINGLE */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
operator|&&
name|s
index|[
literal|1
index|]
operator|&&
name|isDIGIT
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|isDIGIT
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
operator|&&
operator|!
name|alwaysdollar
operator|&&
name|s
index|[
literal|1
index|]
operator|!=
literal|'0'
condition|)
operator|*
name|s
operator|=
literal|'$'
expr_stmt|;
comment|/* grandfather \digit in subst */
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'$'
operator|||
operator|*
name|s
operator|==
literal|'@'
operator|)
operator|&&
name|s
operator|+
literal|1
operator|<
name|send
operator|&&
operator|(
name|alwaysdollar
operator|||
operator|(
name|s
index|[
literal|1
index|]
operator|!=
literal|')'
operator|&&
name|s
index|[
literal|1
index|]
operator|!=
literal|'|'
operator|)
operator|)
condition|)
block|{
name|makesingle
operator|=
name|FALSE
expr_stmt|;
comment|/* force interpretation */
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
operator|&&
name|s
operator|+
literal|1
operator|<
name|send
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
literal|"lLuUE"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|makesingle
operator|=
name|FALSE
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
name|s
operator|=
name|d
operator|=
name|start
operator|=
name|tmpstr
operator|->
name|str_ptr
expr_stmt|;
comment|/* assuming shrinkage only */
while|while
condition|(
name|s
operator|<
name|send
operator|||
name|dorange
condition|)
block|{
if|if
condition|(
name|in_what
operator|&
name|SCAN_TR
condition|)
block|{
if|if
condition|(
name|dorange
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|max
decl_stmt|;
if|if
condition|(
operator|!
name|tmpstr2
condition|)
block|{
comment|/* oops, have to grow */
name|tmpstr2
operator|=
name|str_smake
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
name|s
operator|=
name|tmpstr2
operator|->
name|str_ptr
operator|+
operator|(
name|s
operator|-
name|tmpstr
operator|->
name|str_ptr
operator|)
expr_stmt|;
name|send
operator|=
name|tmpstr2
operator|->
name|str_ptr
operator|+
operator|(
name|send
operator|-
name|tmpstr
operator|->
name|str_ptr
operator|)
expr_stmt|;
block|}
name|i
operator|=
name|d
operator|-
name|tmpstr
operator|->
name|str_ptr
expr_stmt|;
name|STR_GROW
argument_list|(
name|tmpstr
argument_list|,
name|tmpstr
operator|->
name|str_len
operator|+
literal|256
argument_list|)
expr_stmt|;
name|d
operator|=
name|tmpstr
operator|->
name|str_ptr
operator|+
name|i
expr_stmt|;
name|d
operator|-=
literal|2
expr_stmt|;
name|max
operator|=
name|d
index|[
literal|1
index|]
operator|&
literal|0377
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
operator|*
name|d
operator|&
literal|0377
operator|)
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
operator|*
name|d
operator|++
operator|=
name|i
expr_stmt|;
name|start
operator|=
name|s
expr_stmt|;
name|dorange
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
operator|&&
name|s
operator|+
literal|1
operator|<
name|send
operator|&&
name|s
operator|!=
name|start
condition|)
block|{
name|dorange
operator|=
name|TRUE
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'$'
operator|&&
name|s
operator|+
literal|1
operator|<
name|send
operator|&&
operator|(
name|alwaysdollar
operator|||
comment|/*(*/
operator|(
name|s
index|[
literal|1
index|]
operator|!=
literal|')'
operator|&&
name|s
index|[
literal|1
index|]
operator|!=
literal|'|'
operator|)
operator|)
operator|)
operator|||
operator|(
operator|*
name|s
operator|==
literal|'@'
operator|&&
name|s
operator|+
literal|1
operator|<
name|send
operator|)
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'#'
operator|&&
operator|(
name|isALPHA
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
operator|||
name|s
index|[
literal|2
index|]
operator|==
literal|'_'
operator|)
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|len
operator|=
name|scanident
argument_list|(
name|s
argument_list|,
name|send
argument_list|,
name|tokenbuf
argument_list|,
sizeof|sizeof
name|tokenbuf
argument_list|)
operator|-
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
operator|||
name|strEQ
argument_list|(
name|tokenbuf
argument_list|,
literal|"ARGV"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|tokenbuf
argument_list|,
literal|"ENV"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|tokenbuf
argument_list|,
literal|"SIG"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|tokenbuf
argument_list|,
literal|"INC"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|stabent
argument_list|(
name|tokenbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* add symbol */
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
operator|&&
name|s
operator|+
literal|1
operator|<
name|send
condition|)
block|{
name|s
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'-'
case|:
if|if
condition|(
name|in_what
operator|&
name|SCAN_TR
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* FALL THROUGH */
default|default:
if|if
condition|(
operator|!
name|makesingle
operator|&&
operator|(
operator|!
name|leave
operator|||
operator|(
operator|*
name|s
operator|&&
name|index
argument_list|(
name|leave
argument_list|,
operator|*
name|s
argument_list|)
operator|)
operator|)
condition|)
operator|*
name|d
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
operator|*
name|d
operator|++
operator|=
name|scanoct
argument_list|(
name|s
argument_list|,
literal|3
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
continue|continue;
case|case
literal|'x'
case|:
operator|*
name|d
operator|++
operator|=
name|scanhex
argument_list|(
operator|++
name|s
argument_list|,
literal|2
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
continue|continue;
case|case
literal|'c'
case|:
name|s
operator|++
expr_stmt|;
operator|*
name|d
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|isLOWER
argument_list|(
operator|*
name|d
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
operator|*
name|d
operator|++
operator|^=
literal|64
expr_stmt|;
continue|continue;
case|case
literal|'b'
case|:
operator|*
name|d
operator|++
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|d
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|d
operator|++
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|d
operator|++
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|d
operator|++
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
operator|*
name|d
operator|++
operator|=
literal|'\033'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
operator|*
name|d
operator|++
operator|=
literal|'\007'
expr_stmt|;
break|break;
block|}
name|s
operator|++
expr_stmt|;
continue|continue;
block|}
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_DOUBLE
operator|&&
name|makesingle
condition|)
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_SINGLE
expr_stmt|;
comment|/* now we can optimize on it */
name|tmpstr
operator|->
name|str_cur
operator|=
name|d
operator|-
name|tmpstr
operator|->
name|str_ptr
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_GLOB
condition|)
block|{
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
operator|=
name|stab
operator|=
name|genstab
argument_list|()
expr_stmt|;
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|=
name|stio_new
argument_list|()
expr_stmt|;
name|str_sset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
block|}
else|else
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
operator|=
name|tmpstr
expr_stmt|;
name|s
operator|=
name|tmps
expr_stmt|;
if|if
condition|(
name|tmpstr2
condition|)
name|str_free
argument_list|(
name|tmpstr2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|hereis
condition|)
name|str_free
argument_list|(
name|herewas
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|FCMD
modifier|*
name|load_format
parameter_list|()
block|{
name|FCMD
name|froot
decl_stmt|;
name|FCMD
modifier|*
name|flinebeg
decl_stmt|;
name|char
modifier|*
name|eol
decl_stmt|;
specifier|register
name|FCMD
modifier|*
name|fprev
init|=
operator|&
name|froot
decl_stmt|;
specifier|register
name|FCMD
modifier|*
name|fcmd
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
name|bool
name|noblank
decl_stmt|;
name|bool
name|repeater
decl_stmt|;
name|Zero
argument_list|(
operator|&
name|froot
argument_list|,
literal|1
argument_list|,
name|FCMD
argument_list|)
expr_stmt|;
name|s
operator|=
name|bufptr
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|bufend
operator|||
operator|(
name|rsfp
operator|&&
operator|(
name|s
operator|=
name|str_gets
argument_list|(
name|linestr
argument_list|,
name|rsfp
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|Nullch
operator|)
condition|)
block|{
name|curcmd
operator|->
name|c_line
operator|++
expr_stmt|;
if|if
condition|(
name|in_eval
operator|&&
operator|!
name|rsfp
condition|)
block|{
name|eol
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eol
operator|++
condition|)
name|eol
operator|=
name|bufend
expr_stmt|;
block|}
else|else
name|eol
operator|=
name|bufend
operator|=
name|linestr
operator|->
name|str_ptr
operator|+
name|linestr
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
name|perldb
condition|)
block|{
name|STR
modifier|*
name|tmpstr
init|=
name|Str_new
argument_list|(
literal|89
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|str_nset
argument_list|(
name|tmpstr
argument_list|,
name|s
argument_list|,
name|eol
operator|-
name|s
argument_list|)
expr_stmt|;
name|astore
argument_list|(
name|stab_xarray
argument_list|(
name|curcmd
operator|->
name|c_filestab
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|curcmd
operator|->
name|c_line
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
comment|/*SUPPRESS 530*/
for|for
control|(
name|t
operator|=
name|s
operator|+
literal|1
init|;
operator|*
name|t
operator|==
literal|' '
operator|||
operator|*
name|t
operator|==
literal|'\t'
condition|;
name|t
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'\n'
condition|)
block|{
name|bufptr
operator|=
name|s
expr_stmt|;
return|return
name|froot
operator|.
name|f_next
return|;
block|}
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'#'
condition|)
block|{
name|s
operator|=
name|eol
expr_stmt|;
continue|continue;
block|}
name|flinebeg
operator|=
name|Nullfcmd
expr_stmt|;
name|noblank
operator|=
name|FALSE
expr_stmt|;
name|repeater
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|eol
condition|)
block|{
name|Newz
argument_list|(
literal|804
argument_list|,
name|fcmd
argument_list|,
literal|1
argument_list|,
name|FCMD
argument_list|)
expr_stmt|;
name|fprev
operator|->
name|f_next
operator|=
name|fcmd
expr_stmt|;
name|fprev
operator|=
name|fcmd
expr_stmt|;
for|for
control|(
name|t
operator|=
name|s
init|;
name|t
operator|<
name|eol
operator|&&
operator|*
name|t
operator|!=
literal|'@'
operator|&&
operator|*
name|t
operator|!=
literal|'^'
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
literal|'~'
condition|)
block|{
name|noblank
operator|=
name|TRUE
expr_stmt|;
operator|*
name|t
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|t
index|[
literal|1
index|]
operator|==
literal|'~'
condition|)
block|{
name|repeater
operator|=
name|TRUE
expr_stmt|;
name|t
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
block|}
block|}
block|}
name|fcmd
operator|->
name|f_pre
operator|=
name|nsavestr
argument_list|(
name|s
argument_list|,
name|t
operator|-
name|s
argument_list|)
expr_stmt|;
name|fcmd
operator|->
name|f_presize
operator|=
name|t
operator|-
name|s
expr_stmt|;
name|s
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|eol
condition|)
block|{
if|if
condition|(
name|noblank
condition|)
name|fcmd
operator|->
name|f_flags
operator||=
name|FC_NOBLANK
expr_stmt|;
if|if
condition|(
name|repeater
condition|)
name|fcmd
operator|->
name|f_flags
operator||=
name|FC_REPEAT
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|flinebeg
condition|)
name|flinebeg
operator|=
name|fcmd
expr_stmt|;
comment|/* start values here */
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'^'
condition|)
name|fcmd
operator|->
name|f_flags
operator||=
name|FC_CHOP
expr_stmt|;
comment|/* for doing text filling */
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'*'
case|:
name|fcmd
operator|->
name|f_type
operator|=
name|F_LINES
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|fcmd
operator|->
name|f_type
operator|=
name|F_LEFT
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|'<'
condition|)
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|fcmd
operator|->
name|f_type
operator|=
name|F_RIGHT
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|'>'
condition|)
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
name|fcmd
operator|->
name|f_type
operator|=
name|F_CENTER
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|'|'
condition|)
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
case|case
literal|'.'
case|:
comment|/* Catch the special case @... and handle it as a string 		   field. */
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
goto|goto
name|default_format
goto|;
block|}
name|fcmd
operator|->
name|f_type
operator|=
name|F_DECIMAL
expr_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Read a format in the form @####.####, where either group 		       of ### may be empty, or the final .### may be missing. */
while|while
condition|(
operator|*
name|s
operator|==
literal|'#'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|p
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|'#'
condition|)
name|s
operator|++
expr_stmt|;
name|fcmd
operator|->
name|f_decimals
operator|=
name|s
operator|-
name|p
expr_stmt|;
name|fcmd
operator|->
name|f_flags
operator||=
name|FC_DP
expr_stmt|;
block|}
else|else
block|{
name|fcmd
operator|->
name|f_decimals
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|default_format
label|:
name|fcmd
operator|->
name|f_type
operator|=
name|F_LEFT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fcmd
operator|->
name|f_flags
operator|&
name|FC_CHOP
operator|&&
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
name|fcmd
operator|->
name|f_flags
operator||=
name|FC_MORE
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
name|s
operator|++
expr_stmt|;
block|}
name|fcmd
operator|->
name|f_size
operator|=
name|s
operator|-
name|t
expr_stmt|;
block|}
if|if
condition|(
name|flinebeg
condition|)
block|{
name|again
label|:
if|if
condition|(
name|s
operator|>=
name|bufend
operator|&&
operator|(
operator|!
name|rsfp
operator|||
operator|(
name|s
operator|=
name|str_gets
argument_list|(
name|linestr
argument_list|,
name|rsfp
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|Nullch
operator|)
condition|)
goto|goto
name|badform
goto|;
name|curcmd
operator|->
name|c_line
operator|++
expr_stmt|;
if|if
condition|(
name|in_eval
operator|&&
operator|!
name|rsfp
condition|)
block|{
name|eol
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eol
operator|++
condition|)
name|eol
operator|=
name|bufend
expr_stmt|;
block|}
else|else
name|eol
operator|=
name|bufend
operator|=
name|linestr
operator|->
name|str_ptr
operator|+
name|linestr
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
name|perldb
condition|)
block|{
name|STR
modifier|*
name|tmpstr
init|=
name|Str_new
argument_list|(
literal|90
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|str_nset
argument_list|(
name|tmpstr
argument_list|,
name|s
argument_list|,
name|eol
operator|-
name|s
argument_list|)
expr_stmt|;
name|astore
argument_list|(
name|stab_xarray
argument_list|(
name|curcmd
operator|->
name|c_filestab
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|curcmd
operator|->
name|c_line
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|".\n"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|bufptr
operator|=
name|s
expr_stmt|;
name|yyerror
argument_list|(
literal|"Missing values line"
argument_list|)
expr_stmt|;
return|return
name|froot
operator|.
name|f_next
return|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'#'
condition|)
block|{
name|s
operator|=
name|eol
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|str
operator|=
name|flinebeg
operator|->
name|f_unparsed
operator|=
name|Str_new
argument_list|(
literal|91
argument_list|,
name|eol
operator|-
name|s
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_u
operator|.
name|str_hash
operator|=
name|curstash
expr_stmt|;
name|str_nset
argument_list|(
name|str
argument_list|,
literal|"("
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|flinebeg
operator|->
name|f_line
operator|=
name|curcmd
operator|->
name|c_line
expr_stmt|;
name|eol
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|flinebeg
operator|->
name|f_next
operator|->
name|f_type
operator|||
name|index
argument_list|(
name|s
argument_list|,
literal|','
argument_list|)
condition|)
block|{
name|eol
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
name|str_ncat
argument_list|(
name|str
argument_list|,
name|s
argument_list|,
name|eol
operator|-
name|s
operator|-
literal|1
argument_list|)
expr_stmt|;
name|str_ncat
argument_list|(
name|str
argument_list|,
literal|",$$);"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|s
operator|=
name|eol
expr_stmt|;
block|}
else|else
block|{
name|eol
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|eol
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|eol
condition|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
case|case
literal|';'
case|:
name|str_ncat
argument_list|(
name|str
argument_list|,
name|t
argument_list|,
name|s
operator|-
name|t
argument_list|)
expr_stmt|;
name|str_ncat
argument_list|(
name|str
argument_list|,
literal|","
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|eol
operator|&&
operator|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|*
name|s
operator|==
literal|';'
operator|)
condition|)
name|s
operator|++
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
name|str_ncat
argument_list|(
name|str
argument_list|,
name|t
argument_list|,
name|s
operator|-
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
name|s
operator|=
name|scanident
argument_list|(
name|s
argument_list|,
name|eol
argument_list|,
name|tokenbuf
argument_list|,
sizeof|sizeof
name|tokenbuf
argument_list|)
expr_stmt|;
name|str_ncat
argument_list|(
name|str
argument_list|,
name|t
argument_list|,
name|s
operator|-
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|eol
operator|&&
operator|*
name|s
operator|&&
name|index
argument_list|(
literal|"$'\""
argument_list|,
operator|*
name|s
argument_list|)
condition|)
name|str_ncat
argument_list|(
name|str
argument_list|,
literal|","
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
name|str_ncat
argument_list|(
name|str
argument_list|,
name|t
argument_list|,
name|s
operator|-
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|eol
operator|&&
operator|(
operator|*
name|s
operator|!=
operator|*
name|t
operator|||
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
operator|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|eol
condition|)
name|s
operator|++
expr_stmt|;
name|str_ncat
argument_list|(
name|str
argument_list|,
name|t
argument_list|,
name|s
operator|-
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|eol
operator|&&
operator|*
name|s
operator|&&
name|index
argument_list|(
literal|"$'\""
argument_list|,
operator|*
name|s
argument_list|)
condition|)
name|str_ncat
argument_list|(
name|str
argument_list|,
literal|","
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|yyerror
argument_list|(
literal|"Please use commas to separate fields"
argument_list|)
expr_stmt|;
block|}
block|}
name|str_ncat
argument_list|(
name|str
argument_list|,
literal|"$$);"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|badform
label|:
name|bufptr
operator|=
name|str_get
argument_list|(
name|linestr
argument_list|)
expr_stmt|;
name|yyerror
argument_list|(
literal|"Format not terminated"
argument_list|)
expr_stmt|;
return|return
name|froot
operator|.
name|f_next
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_csh
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|CSH
if|if
condition|(
operator|!
name|cshlen
condition|)
name|cshlen
operator|=
name|strlen
argument_list|(
name|cshname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

