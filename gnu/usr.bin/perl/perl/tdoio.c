begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $RCSfile: tdoio.c,v $$Revision: 1.2 $$Date: 1995/05/30 05:03:23 $  *  *    Copyright (c) 1991, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  * $Log: tdoio.c,v $  * Revision 1.2  1995/05/30 05:03:23  rgrimes  * Remove trailing whitespace.  *  * Revision 1.1.1.1  1994/09/10  06:27:36  gclarkii  * Initial import of Perl 4.046 bmaked  *  * Revision 1.2  1994/03/09  22:24:27  ache  * (cast) added for last argument of semctl  *  * Revision 1.1.1.1  1993/08/23  21:29:36  nate  * PERL!  *  * Revision 4.0.1.6  92/06/11  21:08:16  lwall  * patch34: some systems don't declare h_errno extern in header files  *  * Revision 4.0.1.5  92/06/08  13:00:21  lwall  * patch20: some machines don't define ENOTSOCK in errno.h  * patch20: new warnings for failed use of stat operators on filenames with \n  * patch20: wait failed when STDOUT or STDERR reopened to a pipe  * patch20: end of file latch not reset on reopen of STDIN  * patch20: seek(HANDLE, 0, 1) went to eof because of ancient Ultrix workaround  * patch20: fixed memory leak on system() for vfork() machines  * patch20: get*by* routines now return something useful in a scalar context  * patch20: h_errno now accessible via $?  *  * Revision 4.0.1.4  91/11/05  16:51:43  lwall  * patch11: prepared for ctype implementations that don't define isascii()  * patch11: perl mistook some streams for sockets because they return mode 0 too  * patch11: reopening STDIN, STDOUT and STDERR failed on some machines  * patch11: certain perl errors should set EBADF so that $! looks better  * patch11: truncate on a closed filehandle could dump  * patch11: stats of _ forgot whether prior stat was actually lstat  * patch11: -T returned true on NFS directory  *  * Revision 4.0.1.3  91/06/10  01:21:19  lwall  * patch10: read didn't work from character special files open for writing  * patch10: close-on-exec wrongly set on system file descriptors  *  * Revision 4.0.1.2  91/06/07  10:53:39  lwall  * patch4: new copyright notice  * patch4: system fd's are now treated specially  * patch4: added $^F variable to specify maximum system fd, default 2  * patch4: character special files now opened with bidirectional stdio buffers  * patch4: taintchecks could improperly modify parent in vfork()  * patch4: many, many itty-bitty portability fixes  *  * Revision 4.0.1.1  91/04/11  17:41:06  lwall  * patch1: hopefully straightened out some of the Xenix mess  *  * Revision 4.0  91/03/20  01:07:06  lwall  * 4.0 baseline.  *  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_SOCKET
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|ENOTSOCK
end_ifndef

begin_include
include|#
directive|include
file|<net/errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_SELECT
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|I_SYS_SELECT
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|I_SYS_TIME
end_ifndef

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HOST_NOT_FOUND
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|h_errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_MSG
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SEM
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SHM
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ipc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_MSG
end_ifdef

begin_include
include|#
directive|include
file|<sys/msg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_SEM
end_ifdef

begin_include
include|#
directive|include
file|<sys/sem.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_SHM
end_ifdef

begin_include
include|#
directive|include
file|<sys/shm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_PWD
end_ifdef

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_GRP
end_ifdef

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_UTIME
end_ifdef

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_FCNTL
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_SYS_FILE
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|laststatval
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|laststype
init|=
name|O_STAT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|warn_nl
init|=
literal|"Unsuccessful %s on filename containing newline"
decl_stmt|;
end_decl_stmt

begin_function
name|bool
name|do_open
parameter_list|(
name|stab
parameter_list|,
name|name
parameter_list|,
name|len
parameter_list|)
name|STAB
modifier|*
name|stab
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|STIO
modifier|*
name|stio
init|=
name|stab_io
argument_list|(
name|stab
argument_list|)
decl_stmt|;
name|char
modifier|*
name|myname
init|=
name|savestr
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|writing
init|=
literal|0
decl_stmt|;
name|char
name|mode
index|[
literal|3
index|]
decl_stmt|;
comment|/* stdio file mode ("r\0" or "r+\0") */
name|FILE
modifier|*
name|saveifp
init|=
name|Nullfp
decl_stmt|;
name|FILE
modifier|*
name|saveofp
init|=
name|Nullfp
decl_stmt|;
name|char
name|savetype
init|=
literal|' '
decl_stmt|;
name|mode
index|[
literal|0
index|]
operator|=
name|mode
index|[
literal|1
index|]
operator|=
name|mode
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|myname
expr_stmt|;
name|forkprocess
operator|=
literal|1
expr_stmt|;
comment|/* assume true if no fork */
while|while
condition|(
name|len
operator|&&
name|isSPACE
argument_list|(
name|name
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|name
index|[
operator|--
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|stio
condition|)
name|stio
operator|=
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|=
name|stio_new
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|stio
operator|->
name|ifp
condition|)
block|{
name|fd
operator|=
name|fileno
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stio
operator|->
name|type
operator|==
literal|'-'
condition|)
name|result
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|fd
operator|<=
name|maxsysfd
condition|)
block|{
name|saveifp
operator|=
name|stio
operator|->
name|ifp
expr_stmt|;
name|saveofp
operator|=
name|stio
operator|->
name|ofp
expr_stmt|;
name|savetype
operator|=
name|stio
operator|->
name|type
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stio
operator|->
name|type
operator|==
literal|'|'
condition|)
name|result
operator|=
name|mypclose
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|stio
operator|->
name|ifp
operator|!=
name|stio
operator|->
name|ofp
condition|)
block|{
if|if
condition|(
name|stio
operator|->
name|ofp
condition|)
block|{
name|result
operator|=
name|fclose
argument_list|(
name|stio
operator|->
name|ofp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
expr_stmt|;
comment|/* clear stdio, fd already closed */
block|}
else|else
name|result
operator|=
name|fclose
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
else|else
name|result
operator|=
name|fclose
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|EOF
operator|&&
name|fd
operator|>
name|maxsysfd
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: unable to close filehandle %s properly.\n"
argument_list|,
name|stab_ename
argument_list|(
name|stab
argument_list|)
argument_list|)
expr_stmt|;
name|stio
operator|->
name|ofp
operator|=
name|stio
operator|->
name|ifp
operator|=
name|Nullfp
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|name
operator|==
literal|'+'
operator|&&
name|len
operator|>
literal|1
operator|&&
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'|'
condition|)
block|{
comment|/* scary */
name|mode
index|[
literal|1
index|]
operator|=
operator|*
name|name
operator|++
expr_stmt|;
name|mode
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|--
name|len
expr_stmt|;
name|writing
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|mode
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|stio
operator|->
name|type
operator|=
operator|*
name|name
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'|'
condition|)
block|{
comment|/*SUPPRESS 530*/
for|for
control|(
name|name
operator|++
init|;
name|isSPACE
argument_list|(
operator|*
name|name
argument_list|)
condition|;
name|name
operator|++
control|)
empty_stmt|;
ifdef|#
directive|ifdef
name|TAINT
name|taintenv
argument_list|()
expr_stmt|;
name|taintproper
argument_list|(
literal|"Insecure dependency in piped open"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fp
operator|=
name|mypopen
argument_list|(
name|name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|writing
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'>'
condition|)
block|{
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in open"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|name
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'>'
condition|)
block|{
name|mode
index|[
literal|0
index|]
operator|=
name|stio
operator|->
name|type
operator|=
literal|'a'
expr_stmt|;
name|name
operator|++
expr_stmt|;
block|}
else|else
name|mode
index|[
literal|0
index|]
operator|=
literal|'w'
expr_stmt|;
name|writing
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'&'
condition|)
block|{
name|duplicity
label|:
name|name
operator|++
expr_stmt|;
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|name
argument_list|)
condition|)
name|name
operator|++
expr_stmt|;
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|name
argument_list|)
condition|)
name|fd
operator|=
name|atoi
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|stab
operator|=
name|stabent
argument_list|(
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab
operator|||
operator|!
name|stab_io
argument_list|(
name|stab
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|EINVAL
name|errno
operator|=
name|EINVAL
expr_stmt|;
endif|#
directive|endif
goto|goto
name|say_false
goto|;
block|}
if|if
condition|(
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|&&
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|ifp
condition|)
block|{
name|fd
operator|=
name|fileno
argument_list|(
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|type
operator|==
literal|'s'
condition|)
name|stio
operator|->
name|type
operator|=
literal|'s'
expr_stmt|;
block|}
else|else
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
operator|=
name|dup
argument_list|(
name|fd
argument_list|)
argument_list|,
name|mode
argument_list|)
operator|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|name
argument_list|)
condition|)
name|name
operator|++
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|fp
operator|=
name|stdout
expr_stmt|;
name|stio
operator|->
name|type
operator|=
literal|'-'
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|*
name|name
operator|==
literal|'<'
condition|)
block|{
name|mode
index|[
literal|0
index|]
operator|=
literal|'r'
expr_stmt|;
name|name
operator|++
expr_stmt|;
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|name
argument_list|)
condition|)
name|name
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'&'
condition|)
goto|goto
name|duplicity
goto|;
if|if
condition|(
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|fp
operator|=
name|stdin
expr_stmt|;
name|stio
operator|->
name|type
operator|=
literal|'-'
expr_stmt|;
block|}
else|else
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'|'
condition|)
block|{
ifdef|#
directive|ifdef
name|TAINT
name|taintenv
argument_list|()
expr_stmt|;
name|taintproper
argument_list|(
literal|"Insecure dependency in piped open"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|name
index|[
operator|--
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|len
operator|&&
name|isSPACE
argument_list|(
name|name
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|name
index|[
operator|--
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*SUPPRESS 530*/
for|for
control|(
init|;
name|isSPACE
argument_list|(
operator|*
name|name
argument_list|)
condition|;
name|name
operator|++
control|)
empty_stmt|;
name|fp
operator|=
name|mypopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|stio
operator|->
name|type
operator|=
literal|'|'
expr_stmt|;
block|}
else|else
block|{
name|stio
operator|->
name|type
operator|=
literal|'<'
expr_stmt|;
comment|/*SUPPRESS 530*/
for|for
control|(
init|;
name|isSPACE
argument_list|(
operator|*
name|name
argument_list|)
condition|;
name|name
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|fp
operator|=
name|stdin
expr_stmt|;
name|stio
operator|->
name|type
operator|=
literal|'-'
expr_stmt|;
block|}
else|else
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|fp
condition|)
block|{
if|if
condition|(
name|dowarn
operator|&&
name|stio
operator|->
name|type
operator|==
literal|'<'
operator|&&
name|index
argument_list|(
name|name
argument_list|,
literal|'\n'
argument_list|)
condition|)
name|warn
argument_list|(
name|warn_nl
argument_list|,
literal|"open"
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|myname
argument_list|)
expr_stmt|;
goto|goto
name|say_false
goto|;
block|}
name|Safefree
argument_list|(
name|myname
argument_list|)
expr_stmt|;
if|if
condition|(
name|stio
operator|->
name|type
operator|&&
name|stio
operator|->
name|type
operator|!=
literal|'|'
operator|&&
name|stio
operator|->
name|type
operator|!=
literal|'-'
condition|)
block|{
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
goto|goto
name|say_false
goto|;
block|}
if|if
condition|(
name|S_ISSOCK
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
name|stio
operator|->
name|type
operator|=
literal|'s'
expr_stmt|;
comment|/* in case a socket was passed in to us */
ifdef|#
directive|ifdef
name|HAS_SOCKET
elseif|else
if|if
condition|(
ifdef|#
directive|ifdef
name|S_IFMT
operator|!
operator|(
name|statbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
else|#
directive|else
operator|!
name|statbuf
operator|.
name|st_mode
endif|#
directive|endif
condition|)
block|{
name|int
name|buflen
init|=
sizeof|sizeof
name|tokenbuf
decl_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|tokenbuf
argument_list|,
operator|&
name|buflen
argument_list|)
operator|>=
literal|0
operator|||
name|errno
operator|!=
name|ENOTSOCK
condition|)
name|stio
operator|->
name|type
operator|=
literal|'s'
expr_stmt|;
comment|/* some OS's return 0 on fstat()ed socket */
comment|/* but some return 0 for streams too, sigh */
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|saveifp
condition|)
block|{
comment|/* must use old fp? */
name|fd
operator|=
name|fileno
argument_list|(
name|saveifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|saveofp
condition|)
block|{
name|fflush
argument_list|(
name|saveofp
argument_list|)
expr_stmt|;
comment|/* emulate fclose() */
if|if
condition|(
name|saveofp
operator|!=
name|saveifp
condition|)
block|{
comment|/* was a socket? */
name|fclose
argument_list|(
name|saveofp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>
literal|2
condition|)
name|Safefree
argument_list|(
name|saveofp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fd
operator|!=
name|fileno
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|int
name|pid
decl_stmt|;
name|STR
modifier|*
name|str
decl_stmt|;
name|dup2
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|str
operator|=
name|afetch
argument_list|(
name|fdpid
argument_list|,
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pid
operator|=
name|str
operator|->
name|str_u
operator|.
name|str_useful
expr_stmt|;
name|str
operator|->
name|str_u
operator|.
name|str_useful
operator|=
literal|0
expr_stmt|;
name|str
operator|=
name|afetch
argument_list|(
name|fdpid
argument_list|,
name|fd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_u
operator|.
name|str_useful
operator|=
name|pid
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|fp
operator|=
name|saveifp
expr_stmt|;
name|clearerr
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_SETFD
argument_list|)
name|fd
operator|=
name|fileno
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
name|fd
operator|>
name|maxsysfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stio
operator|->
name|ifp
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|writing
condition|)
block|{
if|if
condition|(
name|stio
operator|->
name|type
operator|==
literal|'s'
operator|||
operator|(
name|stio
operator|->
name|type
operator|==
literal|'>'
operator|&&
name|S_ISCHR
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|stio
operator|->
name|ofp
operator|=
name|fdopen
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
literal|"w"
argument_list|)
operator|)
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|stio
operator|->
name|ifp
operator|=
name|Nullfp
expr_stmt|;
goto|goto
name|say_false
goto|;
block|}
block|}
else|else
name|stio
operator|->
name|ofp
operator|=
name|fp
expr_stmt|;
block|}
return|return
name|TRUE
return|;
name|say_false
label|:
name|stio
operator|->
name|ifp
operator|=
name|saveifp
expr_stmt|;
name|stio
operator|->
name|ofp
operator|=
name|saveofp
expr_stmt|;
name|stio
operator|->
name|type
operator|=
name|savetype
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|nextargv
parameter_list|(
name|stab
parameter_list|)
specifier|register
name|STAB
modifier|*
name|stab
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
ifndef|#
directive|ifndef
name|FLEXFILENAMES
name|int
name|filedev
decl_stmt|;
name|int
name|fileino
decl_stmt|;
endif|#
directive|endif
name|int
name|fileuid
decl_stmt|;
name|int
name|filegid
decl_stmt|;
specifier|static
name|int
name|filemode
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|lastfd
decl_stmt|;
specifier|static
name|char
modifier|*
name|oldname
decl_stmt|;
if|if
condition|(
operator|!
name|argvoutstab
condition|)
name|argvoutstab
operator|=
name|stabent
argument_list|(
literal|"ARGVOUT"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|filemode
operator|&
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator|)
condition|)
block|{
name|fflush
argument_list|(
name|stab_io
argument_list|(
name|argvoutstab
argument_list|)
operator|->
name|ifp
argument_list|)
expr_stmt|;
comment|/* chmod must follow last write */
ifdef|#
directive|ifdef
name|HAS_FCHMOD
operator|(
name|void
operator|)
name|fchmod
argument_list|(
name|lastfd
argument_list|,
name|filemode
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|oldname
argument_list|,
name|filemode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|filemode
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|alen
argument_list|(
name|stab_xarray
argument_list|(
name|stab
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|str
operator|=
name|ashift
argument_list|(
name|stab_xarray
argument_list|(
name|stab
argument_list|)
argument_list|)
expr_stmt|;
name|str_sset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|)
expr_stmt|;
name|oldname
operator|=
name|str_get
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_open
argument_list|(
name|stab
argument_list|,
name|oldname
argument_list|,
name|stab_val
argument_list|(
name|stab
argument_list|)
operator|->
name|str_cur
argument_list|)
condition|)
block|{
if|if
condition|(
name|inplace
condition|)
block|{
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in inplace open"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strEQ
argument_list|(
name|oldname
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|str_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|defoutstab
operator|=
name|stabent
argument_list|(
literal|"STDOUT"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|ifp
return|;
block|}
ifndef|#
directive|ifndef
name|FLEXFILENAMES
name|filedev
operator|=
name|statbuf
operator|.
name|st_dev
expr_stmt|;
name|fileino
operator|=
name|statbuf
operator|.
name|st_ino
expr_stmt|;
endif|#
directive|endif
name|filemode
operator|=
name|statbuf
operator|.
name|st_mode
expr_stmt|;
name|fileuid
operator|=
name|statbuf
operator|.
name|st_uid
expr_stmt|;
name|filegid
operator|=
name|statbuf
operator|.
name|st_gid
expr_stmt|;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|filemode
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"Can't do inplace edit: %s is not a regular file"
argument_list|,
name|oldname
argument_list|)
expr_stmt|;
name|do_close
argument_list|(
name|stab
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|str_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|inplace
condition|)
block|{
ifdef|#
directive|ifdef
name|SUFFIX
name|add_suffix
argument_list|(
name|str
argument_list|,
name|inplace
argument_list|)
expr_stmt|;
else|#
directive|else
name|str_cat
argument_list|(
name|str
argument_list|,
name|inplace
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|FLEXFILENAMES
if|if
condition|(
name|stat
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|>=
literal|0
operator|&&
name|statbuf
operator|.
name|st_dev
operator|==
name|filedev
operator|&&
name|statbuf
operator|.
name|st_ino
operator|==
name|fileino
condition|)
block|{
name|warn
argument_list|(
literal|"Can't do inplace edit: %s> 14 characters"
argument_list|,
name|str
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
name|do_close
argument_list|(
name|stab
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|str_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_RENAME
ifndef|#
directive|ifndef
name|DOSISH
if|if
condition|(
name|rename
argument_list|(
name|oldname
argument_list|,
name|str
operator|->
name|str_ptr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Can't rename %s to %s: %s, skipping file"
argument_list|,
name|oldname
argument_list|,
name|str
operator|->
name|str_ptr
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|do_close
argument_list|(
name|stab
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|str_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|#
directive|else
name|do_close
argument_list|(
name|stab
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rename
argument_list|(
name|oldname
argument_list|,
name|str
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
name|do_open
argument_list|(
name|stab
argument_list|,
name|str
operator|->
name|str_ptr
argument_list|,
name|stab_val
argument_list|(
name|stab
argument_list|)
operator|->
name|str_cur
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
else|#
directive|else
operator|(
name|void
operator|)
name|UNLINK
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|oldname
argument_list|,
name|str
operator|->
name|str_ptr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Can't rename %s to %s: %s, skipping file"
argument_list|,
name|oldname
argument_list|,
name|str
operator|->
name|str_ptr
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|do_close
argument_list|(
name|stab
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|str_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|UNLINK
argument_list|(
name|oldname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|DOSISH
if|if
condition|(
name|UNLINK
argument_list|(
name|oldname
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Can't rename %s to %s: %s, skipping file"
argument_list|,
name|oldname
argument_list|,
name|str
operator|->
name|str_ptr
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|do_close
argument_list|(
name|stab
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|str_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|#
directive|else
name|fatal
argument_list|(
literal|"Can't do inplace edit without backup"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|str_nset
argument_list|(
name|str
argument_list|,
literal|">"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|str
argument_list|,
name|oldname
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* in case sprintf set errno */
if|if
condition|(
operator|!
name|do_open
argument_list|(
name|argvoutstab
argument_list|,
name|str
operator|->
name|str_ptr
argument_list|,
name|str
operator|->
name|str_cur
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"Can't do inplace edit on %s: %s"
argument_list|,
name|oldname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|do_close
argument_list|(
name|stab
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|str_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|defoutstab
operator|=
name|argvoutstab
expr_stmt|;
name|lastfd
operator|=
name|fileno
argument_list|(
name|stab_io
argument_list|(
name|argvoutstab
argument_list|)
operator|->
name|ifp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fstat
argument_list|(
name|lastfd
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_FCHMOD
operator|(
name|void
operator|)
name|fchmod
argument_list|(
name|lastfd
argument_list|,
name|filemode
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|oldname
argument_list|,
name|filemode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fileuid
operator|!=
name|statbuf
operator|.
name|st_uid
operator|||
name|filegid
operator|!=
name|statbuf
operator|.
name|st_gid
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_FCHOWN
operator|(
name|void
operator|)
name|fchown
argument_list|(
name|lastfd
argument_list|,
name|fileuid
argument_list|,
name|filegid
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_CHOWN
operator|(
name|void
operator|)
name|chown
argument_list|(
name|oldname
argument_list|,
name|fileuid
argument_list|,
name|filegid
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
block|}
name|str_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|ifp
return|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't open %s: %s\n"
argument_list|,
name|str_get
argument_list|(
name|str
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|str_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inplace
condition|)
block|{
operator|(
name|void
operator|)
name|do_close
argument_list|(
name|argvoutstab
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|defoutstab
operator|=
name|stabent
argument_list|(
literal|"STDOUT"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
return|return
name|Nullfp
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_PIPE
end_ifdef

begin_function
name|void
name|do_pipe
parameter_list|(
name|str
parameter_list|,
name|rstab
parameter_list|,
name|wstab
parameter_list|)
name|STR
modifier|*
name|str
decl_stmt|;
name|STAB
modifier|*
name|rstab
decl_stmt|;
name|STAB
modifier|*
name|wstab
decl_stmt|;
block|{
specifier|register
name|STIO
modifier|*
name|rstio
decl_stmt|;
specifier|register
name|STIO
modifier|*
name|wstio
decl_stmt|;
name|int
name|fd
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|rstab
condition|)
goto|goto
name|badexit
goto|;
if|if
condition|(
operator|!
name|wstab
condition|)
goto|goto
name|badexit
goto|;
name|rstio
operator|=
name|stab_io
argument_list|(
name|rstab
argument_list|)
expr_stmt|;
name|wstio
operator|=
name|stab_io
argument_list|(
name|wstab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rstio
condition|)
name|rstio
operator|=
name|stab_io
argument_list|(
name|rstab
argument_list|)
operator|=
name|stio_new
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|rstio
operator|->
name|ifp
condition|)
name|do_close
argument_list|(
name|rstab
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wstio
condition|)
name|wstio
operator|=
name|stab_io
argument_list|(
name|wstab
argument_list|)
operator|=
name|stio_new
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|wstio
operator|->
name|ifp
condition|)
name|do_close
argument_list|(
name|wstab
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|badexit
goto|;
name|rstio
operator|->
name|ifp
operator|=
name|fdopen
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|wstio
operator|->
name|ofp
operator|=
name|fdopen
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|wstio
operator|->
name|ifp
operator|=
name|wstio
operator|->
name|ofp
expr_stmt|;
name|rstio
operator|->
name|type
operator|=
literal|'<'
expr_stmt|;
name|wstio
operator|->
name|type
operator|=
literal|'>'
expr_stmt|;
if|if
condition|(
operator|!
name|rstio
operator|->
name|ifp
operator|||
operator|!
name|wstio
operator|->
name|ofp
condition|)
block|{
if|if
condition|(
name|rstio
operator|->
name|ifp
condition|)
name|fclose
argument_list|(
name|rstio
operator|->
name|ifp
argument_list|)
expr_stmt|;
else|else
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|wstio
operator|->
name|ofp
condition|)
name|fclose
argument_list|(
name|wstio
operator|->
name|ofp
argument_list|)
expr_stmt|;
else|else
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|badexit
goto|;
block|}
name|str_sset
argument_list|(
name|str
argument_list|,
operator|&
name|str_yes
argument_list|)
expr_stmt|;
return|return;
name|badexit
label|:
name|str_sset
argument_list|(
name|str
argument_list|,
operator|&
name|str_undef
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|bool
name|do_close
parameter_list|(
name|stab
parameter_list|,
name|explicit
parameter_list|)
name|STAB
modifier|*
name|stab
decl_stmt|;
name|bool
name|explicit
decl_stmt|;
block|{
name|bool
name|retval
init|=
name|FALSE
decl_stmt|;
specifier|register
name|STIO
modifier|*
name|stio
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|stab
condition|)
name|stab
operator|=
name|argvstab
expr_stmt|;
if|if
condition|(
operator|!
name|stab
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|stio
operator|=
name|stab_io
argument_list|(
name|stab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stio
condition|)
block|{
comment|/* never opened */
if|if
condition|(
name|dowarn
operator|&&
name|explicit
condition|)
name|warn
argument_list|(
literal|"Close on unopened file<%s>"
argument_list|,
name|stab_ename
argument_list|(
name|stab
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|stio
operator|->
name|ifp
condition|)
block|{
if|if
condition|(
name|stio
operator|->
name|type
operator|==
literal|'|'
condition|)
block|{
name|status
operator|=
name|mypclose
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|status
operator|==
literal|0
operator|)
expr_stmt|;
name|statusvalue
operator|=
operator|(
name|unsigned
name|short
operator|)
name|status
operator|&
literal|0xffff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stio
operator|->
name|type
operator|==
literal|'-'
condition|)
name|retval
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
if|if
condition|(
name|stio
operator|->
name|ofp
operator|&&
name|stio
operator|->
name|ofp
operator|!=
name|stio
operator|->
name|ifp
condition|)
block|{
comment|/* a socket */
name|retval
operator|=
operator|(
name|fclose
argument_list|(
name|stio
operator|->
name|ofp
argument_list|)
operator|!=
name|EOF
operator|)
expr_stmt|;
name|fclose
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
expr_stmt|;
comment|/* clear stdio, fd already closed */
block|}
else|else
name|retval
operator|=
operator|(
name|fclose
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
operator|!=
name|EOF
operator|)
expr_stmt|;
block|}
name|stio
operator|->
name|ofp
operator|=
name|stio
operator|->
name|ifp
operator|=
name|Nullfp
expr_stmt|;
block|}
if|if
condition|(
name|explicit
condition|)
name|stio
operator|->
name|lines
operator|=
literal|0
expr_stmt|;
name|stio
operator|->
name|type
operator|=
literal|' '
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|bool
name|do_eof
parameter_list|(
name|stab
parameter_list|)
name|STAB
modifier|*
name|stab
decl_stmt|;
block|{
specifier|register
name|STIO
modifier|*
name|stio
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|if
condition|(
operator|!
name|stab
condition|)
block|{
comment|/* eof() */
if|if
condition|(
name|argvstab
condition|)
name|stio
operator|=
name|stab_io
argument_list|(
name|argvstab
argument_list|)
expr_stmt|;
else|else
return|return
name|TRUE
return|;
block|}
else|else
name|stio
operator|=
name|stab_io
argument_list|(
name|stab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stio
condition|)
return|return
name|TRUE
return|;
while|while
condition|(
name|stio
operator|->
name|ifp
condition|)
block|{
ifdef|#
directive|ifdef
name|STDSTDIO
comment|/* (the code works without this) */
if|if
condition|(
name|stio
operator|->
name|ifp
operator|->
name|_cnt
operator|>
literal|0
condition|)
comment|/* cheat a little, since */
return|return
name|FALSE
return|;
comment|/* this is the most usual case */
endif|#
directive|endif
name|ch
operator|=
name|getc
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
name|EOF
condition|)
block|{
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|ch
argument_list|,
name|stio
operator|->
name|ifp
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
ifdef|#
directive|ifdef
name|STDSTDIO
if|if
condition|(
name|stio
operator|->
name|ifp
operator|->
name|_cnt
operator|<
operator|-
literal|1
condition|)
name|stio
operator|->
name|ifp
operator|->
name|_cnt
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|stab
condition|)
block|{
comment|/* not necessarily a real EOF yet? */
if|if
condition|(
operator|!
name|nextargv
argument_list|(
name|argvstab
argument_list|)
condition|)
comment|/* get another fp handy */
return|return
name|TRUE
return|;
block|}
else|else
return|return
name|TRUE
return|;
comment|/* normal fp, definitely end of file */
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|long
name|do_tell
parameter_list|(
name|stab
parameter_list|)
name|STAB
modifier|*
name|stab
decl_stmt|;
block|{
specifier|register
name|STIO
modifier|*
name|stio
decl_stmt|;
if|if
condition|(
operator|!
name|stab
condition|)
goto|goto
name|phooey
goto|;
name|stio
operator|=
name|stab_io
argument_list|(
name|stab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stio
operator|||
operator|!
name|stio
operator|->
name|ifp
condition|)
goto|goto
name|phooey
goto|;
ifdef|#
directive|ifdef
name|ULTRIX_STDIO_BOTCH
if|if
condition|(
name|feof
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|stio
operator|->
name|ifp
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* ultrix 1.2 workaround */
endif|#
directive|endif
return|return
name|ftell
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
return|;
name|phooey
label|:
if|if
condition|(
name|dowarn
condition|)
name|warn
argument_list|(
literal|"tell() on unopened file"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|-
literal|1L
return|;
block|}
end_function

begin_function
name|bool
name|do_seek
parameter_list|(
name|stab
parameter_list|,
name|pos
parameter_list|,
name|whence
parameter_list|)
name|STAB
modifier|*
name|stab
decl_stmt|;
name|long
name|pos
decl_stmt|;
name|int
name|whence
decl_stmt|;
block|{
specifier|register
name|STIO
modifier|*
name|stio
decl_stmt|;
if|if
condition|(
operator|!
name|stab
condition|)
goto|goto
name|nuts
goto|;
name|stio
operator|=
name|stab_io
argument_list|(
name|stab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stio
operator|||
operator|!
name|stio
operator|->
name|ifp
condition|)
goto|goto
name|nuts
goto|;
ifdef|#
directive|ifdef
name|ULTRIX_STDIO_BOTCH
if|if
condition|(
name|feof
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fseek
argument_list|(
name|stio
operator|->
name|ifp
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* ultrix 1.2 workaround */
endif|#
directive|endif
return|return
name|fseek
argument_list|(
name|stio
operator|->
name|ifp
argument_list|,
name|pos
argument_list|,
name|whence
argument_list|)
operator|>=
literal|0
return|;
name|nuts
label|:
if|if
condition|(
name|dowarn
condition|)
name|warn
argument_list|(
literal|"seek() on unopened file"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|int
name|do_ctl
parameter_list|(
name|optype
parameter_list|,
name|stab
parameter_list|,
name|func
parameter_list|,
name|argstr
parameter_list|)
name|int
name|optype
decl_stmt|;
name|STAB
modifier|*
name|stab
decl_stmt|;
name|int
name|func
decl_stmt|;
name|STR
modifier|*
name|argstr
decl_stmt|;
block|{
specifier|register
name|STIO
modifier|*
name|stio
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
operator|!
name|stab
operator|||
operator|!
name|argstr
operator|||
operator|!
operator|(
name|stio
operator|=
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|)
operator|||
operator|!
name|stio
operator|->
name|ifp
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
comment|/* well, sort of... */
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|argstr
operator|->
name|str_pok
operator|||
operator|!
name|argstr
operator|->
name|str_nok
condition|)
block|{
if|if
condition|(
operator|!
name|argstr
operator|->
name|str_pok
condition|)
name|s
operator|=
name|str_get
argument_list|(
name|argstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IOCPARM_MASK
ifndef|#
directive|ifndef
name|IOCPARM_LEN
define|#
directive|define
name|IOCPARM_LEN
parameter_list|(
name|x
parameter_list|)
value|(((x)>> 16)& IOCPARM_MASK)
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IOCPARM_LEN
name|retval
operator|=
name|IOCPARM_LEN
argument_list|(
name|func
argument_list|)
expr_stmt|;
comment|/* on BSDish systes we're safe */
else|#
directive|else
name|retval
operator|=
literal|256
expr_stmt|;
comment|/* otherwise guess at what's safe */
endif|#
directive|endif
if|if
condition|(
name|argstr
operator|->
name|str_cur
operator|<
name|retval
condition|)
block|{
name|Str_Grow
argument_list|(
name|argstr
argument_list|,
name|retval
operator|+
literal|1
argument_list|)
expr_stmt|;
name|argstr
operator|->
name|str_cur
operator|=
name|retval
expr_stmt|;
block|}
name|s
operator|=
name|argstr
operator|->
name|str_ptr
expr_stmt|;
name|s
index|[
name|argstr
operator|->
name|str_cur
index|]
operator|=
literal|17
expr_stmt|;
comment|/* a little sanity check here */
block|}
else|else
block|{
name|retval
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|argstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DOSISH
name|s
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|long
operator|)
name|retval
expr_stmt|;
comment|/* ouch */
else|#
directive|else
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|retval
expr_stmt|;
comment|/* ouch */
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|lint
if|if
condition|(
name|optype
operator|==
name|O_IOCTL
condition|)
name|retval
operator|=
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
argument_list|,
name|func
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|DOSISH
name|fatal
argument_list|(
literal|"fcntl is not implemented"
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_FCNTL
name|retval
operator|=
name|fcntl
argument_list|(
name|fileno
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
argument_list|,
name|func
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|fatal
argument_list|(
literal|"fcntl is not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
else|#
directive|else
comment|/* lint */
name|retval
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* lint */
if|if
condition|(
name|argstr
operator|->
name|str_pok
condition|)
block|{
if|if
condition|(
name|s
index|[
name|argstr
operator|->
name|str_cur
index|]
operator|!=
literal|17
condition|)
name|fatal
argument_list|(
literal|"Return value overflowed string"
argument_list|)
expr_stmt|;
name|s
index|[
name|argstr
operator|->
name|str_cur
index|]
operator|=
literal|0
expr_stmt|;
comment|/* put our null back */
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|do_stat
parameter_list|(
name|str
parameter_list|,
name|arg
parameter_list|,
name|gimme
parameter_list|,
name|arglast
parameter_list|)
name|STR
modifier|*
name|str
decl_stmt|;
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
name|int
name|gimme
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|ARRAY
modifier|*
name|ary
init|=
name|stack
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|0
index|]
operator|+
literal|1
decl_stmt|;
name|int
name|max
init|=
literal|13
decl_stmt|;
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
block|{
name|tmpstab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
if|if
condition|(
name|tmpstab
operator|!=
name|defstab
condition|)
block|{
name|laststype
operator|=
name|O_STAT
expr_stmt|;
name|statstab
operator|=
name|tmpstab
expr_stmt|;
name|str_set
argument_list|(
name|statname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_io
argument_list|(
name|tmpstab
argument_list|)
operator|||
operator|!
name|stab_io
argument_list|(
name|tmpstab
argument_list|)
operator|->
name|ifp
operator|||
name|fstat
argument_list|(
name|fileno
argument_list|(
name|stab_io
argument_list|(
name|tmpstab
argument_list|)
operator|->
name|ifp
argument_list|)
argument_list|,
operator|&
name|statcache
argument_list|)
operator|<
literal|0
condition|)
block|{
name|max
operator|=
literal|0
expr_stmt|;
name|laststatval
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|laststatval
operator|<
literal|0
condition|)
name|max
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|str_set
argument_list|(
name|statname
argument_list|,
name|str_get
argument_list|(
name|ary
operator|->
name|ary_array
index|[
name|sp
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|statstab
operator|=
name|Nullstab
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_LSTAT
name|laststype
operator|=
name|arg
operator|->
name|arg_type
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_LSTAT
condition|)
name|laststatval
operator|=
name|lstat
argument_list|(
name|str_get
argument_list|(
name|statname
argument_list|)
argument_list|,
operator|&
name|statcache
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|laststatval
operator|=
name|stat
argument_list|(
name|str_get
argument_list|(
name|statname
argument_list|)
argument_list|,
operator|&
name|statcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|laststatval
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|dowarn
operator|&&
name|index
argument_list|(
name|str_get
argument_list|(
name|statname
argument_list|)
argument_list|,
literal|'\n'
argument_list|)
condition|)
name|warn
argument_list|(
name|warn_nl
argument_list|,
literal|"stat"
argument_list|)
expr_stmt|;
name|max
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gimme
operator|!=
name|G_ARRAY
condition|)
block|{
if|if
condition|(
name|max
condition|)
name|str_sset
argument_list|(
name|str
argument_list|,
operator|&
name|str_yes
argument_list|)
expr_stmt|;
else|else
name|str_sset
argument_list|(
name|str
argument_list|,
operator|&
name|str_undef
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|ary
operator|->
name|ary_array
index|[
name|sp
index|]
operator|=
name|str
expr_stmt|;
return|return
name|sp
return|;
block|}
name|sp
operator|--
expr_stmt|;
if|if
condition|(
name|max
condition|)
block|{
ifndef|#
directive|ifndef
name|lint
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str_2mortal
argument_list|(
name|str_nmake
argument_list|(
operator|(
name|double
operator|)
name|statcache
operator|.
name|st_dev
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str_2mortal
argument_list|(
name|str_nmake
argument_list|(
operator|(
name|double
operator|)
name|statcache
operator|.
name|st_ino
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str_2mortal
argument_list|(
name|str_nmake
argument_list|(
operator|(
name|double
operator|)
name|statcache
operator|.
name|st_mode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str_2mortal
argument_list|(
name|str_nmake
argument_list|(
operator|(
name|double
operator|)
name|statcache
operator|.
name|st_nlink
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str_2mortal
argument_list|(
name|str_nmake
argument_list|(
operator|(
name|double
operator|)
name|statcache
operator|.
name|st_uid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str_2mortal
argument_list|(
name|str_nmake
argument_list|(
operator|(
name|double
operator|)
name|statcache
operator|.
name|st_gid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str_2mortal
argument_list|(
name|str_nmake
argument_list|(
operator|(
name|double
operator|)
name|statcache
operator|.
name|st_rdev
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str_2mortal
argument_list|(
name|str_nmake
argument_list|(
operator|(
name|double
operator|)
name|statcache
operator|.
name|st_size
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str_2mortal
argument_list|(
name|str_nmake
argument_list|(
operator|(
name|double
operator|)
name|statcache
operator|.
name|st_atime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str_2mortal
argument_list|(
name|str_nmake
argument_list|(
operator|(
name|double
operator|)
name|statcache
operator|.
name|st_mtime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str_2mortal
argument_list|(
name|str_nmake
argument_list|(
operator|(
name|double
operator|)
name|statcache
operator|.
name|st_ctime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STATBLOCKS
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str_2mortal
argument_list|(
name|str_nmake
argument_list|(
operator|(
name|double
operator|)
name|statcache
operator|.
name|st_blksize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str_2mortal
argument_list|(
name|str_nmake
argument_list|(
operator|(
name|double
operator|)
name|statcache
operator|.
name|st_blocks
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str_2mortal
argument_list|(
name|str_make
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str_2mortal
argument_list|(
name|str_make
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* lint */
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str_nmake
argument_list|(
literal|0.0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* lint */
block|}
return|return
name|sp
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_TRUNCATE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAS_CHSIZE
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_FREESP
argument_list|)
end_if

begin_comment
comment|/* code courtesy of William Kucharski */
end_comment

begin_define
define|#
directive|define
name|HAS_CHSIZE
end_define

begin_function
name|int
name|chsize
parameter_list|(
name|fd
parameter_list|,
name|length
parameter_list|)
name|int
name|fd
decl_stmt|;
comment|/* file descriptor */
name|off_t
name|length
decl_stmt|;
comment|/* length to set file to */
block|{
specifier|extern
name|long
name|lseek
parameter_list|()
function_decl|;
name|struct
name|flock
name|fl
decl_stmt|;
name|struct
name|stat
name|filebuf
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|filebuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|filebuf
operator|.
name|st_size
operator|<
name|length
condition|)
block|{
comment|/* extend file length */
if|if
condition|(
operator|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|length
operator|-
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* write a "0" byte */
if|if
condition|(
operator|(
name|write
argument_list|(
name|fd
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
comment|/* truncate length */
name|fl
operator|.
name|l_whence
operator|=
literal|0
expr_stmt|;
name|fl
operator|.
name|l_len
operator|=
literal|0
expr_stmt|;
name|fl
operator|.
name|l_start
operator|=
name|length
expr_stmt|;
name|fl
operator|.
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
comment|/* write lock on file space */
comment|/* 	* This relies on the UNDOCUMENTED F_FREESP argument to 	* fcntl(2), which truncates the file so that it ends at the 	* position indicated by fl.l_start. 	* 	* Will minor miracles never cease? 	*/
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_FREESP
argument_list|,
operator|&
name|fl
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* F_FREESP */
end_comment

begin_function
name|int
comment|/*SUPPRESS 590*/
name|do_truncate
parameter_list|(
name|str
parameter_list|,
name|arg
parameter_list|,
name|gimme
parameter_list|,
name|arglast
parameter_list|)
name|STR
modifier|*
name|str
decl_stmt|;
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
name|int
name|gimme
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|ARRAY
modifier|*
name|ary
init|=
name|stack
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|0
index|]
operator|+
literal|1
decl_stmt|;
name|off_t
name|len
init|=
operator|(
name|off_t
operator|)
name|str_gnum
argument_list|(
name|ary
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
name|STAB
modifier|*
name|tmpstab
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAS_TRUNCATE
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_CHSIZE
argument_list|)
ifdef|#
directive|ifdef
name|HAS_TRUNCATE
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
block|{
name|tmpstab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
if|if
condition|(
operator|!
name|stab_io
argument_list|(
name|tmpstab
argument_list|)
operator|||
operator|!
name|stab_io
argument_list|(
name|tmpstab
argument_list|)
operator|->
name|ifp
operator|||
name|ftruncate
argument_list|(
name|fileno
argument_list|(
name|stab_io
argument_list|(
name|tmpstab
argument_list|)
operator|->
name|ifp
argument_list|)
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
name|result
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|truncate
argument_list|(
name|str_get
argument_list|(
name|ary
operator|->
name|ary_array
index|[
name|sp
index|]
argument_list|)
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
name|result
operator|=
literal|0
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
block|{
name|tmpstab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
if|if
condition|(
operator|!
name|stab_io
argument_list|(
name|tmpstab
argument_list|)
operator|||
operator|!
name|stab_io
argument_list|(
name|tmpstab
argument_list|)
operator|->
name|ifp
operator|||
name|chsize
argument_list|(
name|fileno
argument_list|(
name|stab_io
argument_list|(
name|tmpstab
argument_list|)
operator|->
name|ifp
argument_list|)
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
name|result
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|tmpfd
decl_stmt|;
if|if
condition|(
operator|(
name|tmpfd
operator|=
name|open
argument_list|(
name|str_get
argument_list|(
name|ary
operator|->
name|ary_array
index|[
name|sp
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|result
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|chsize
argument_list|(
name|tmpfd
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
name|result
operator|=
literal|0
expr_stmt|;
name|close
argument_list|(
name|tmpfd
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|result
condition|)
name|str_sset
argument_list|(
name|str
argument_list|,
operator|&
name|str_yes
argument_list|)
expr_stmt|;
else|else
name|str_sset
argument_list|(
name|str
argument_list|,
operator|&
name|str_undef
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|ary
operator|->
name|ary_array
index|[
name|sp
index|]
operator|=
name|str
expr_stmt|;
return|return
name|sp
return|;
else|#
directive|else
name|fatal
argument_list|(
literal|"truncate not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|looks_like_number
parameter_list|(
name|str
parameter_list|)
name|STR
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|send
decl_stmt|;
if|if
condition|(
operator|!
name|str
operator|->
name|str_pok
condition|)
return|return
name|TRUE
return|;
name|s
operator|=
name|str
operator|->
name|str_ptr
expr_stmt|;
name|send
operator|=
name|s
operator|+
name|str
operator|->
name|str_cur
expr_stmt|;
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|send
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
operator|||
operator|*
name|s
operator|==
literal|'-'
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|send
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|s
operator|==
name|str
operator|->
name|str_ptr
condition|)
return|return
name|FALSE
return|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|send
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'e'
operator|||
operator|*
name|s
operator|==
literal|'E'
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
operator|||
operator|*
name|s
operator|==
literal|'-'
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|send
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|bool
name|do_print
parameter_list|(
name|str
parameter_list|,
name|fp
parameter_list|)
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|tmps
decl_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
if|if
condition|(
name|dowarn
condition|)
name|warn
argument_list|(
literal|"print to unopened file"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|str
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|ofmt
operator|&&
operator|(
operator|(
name|str
operator|->
name|str_nok
operator|&&
name|str
operator|->
name|str_u
operator|.
name|str_nval
operator|!=
literal|0.0
operator|)
operator|||
operator|(
name|looks_like_number
argument_list|(
name|str
argument_list|)
operator|&&
name|str_gnum
argument_list|(
name|str
argument_list|)
operator|!=
literal|0.0
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
name|ofmt
argument_list|,
name|str
operator|->
name|str_u
operator|.
name|str_nval
argument_list|)
expr_stmt|;
return|return
operator|!
name|ferror
argument_list|(
name|fp
argument_list|)
return|;
block|}
else|else
block|{
name|tmps
operator|=
name|str_get
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tmps
operator|==
literal|'S'
operator|&&
name|tmps
index|[
literal|1
index|]
operator|==
literal|'t'
operator|&&
name|tmps
index|[
literal|2
index|]
operator|==
literal|'B'
operator|&&
name|tmps
index|[
literal|3
index|]
operator|==
literal|'\0'
operator|&&
name|str
operator|->
name|str_cur
operator|==
sizeof|sizeof
argument_list|(
name|STBP
argument_list|)
operator|&&
name|strlen
argument_list|(
name|tmps
argument_list|)
operator|<
name|str
operator|->
name|str_cur
condition|)
block|{
name|STR
modifier|*
name|tmpstr
init|=
name|str_mortal
argument_list|(
operator|&
name|str_undef
argument_list|)
decl_stmt|;
name|stab_efullname
argument_list|(
name|tmpstr
argument_list|,
operator|(
operator|(
name|STAB
operator|*
operator|)
name|str
operator|)
argument_list|)
expr_stmt|;
comment|/* a stab value, be nice */
name|str
operator|=
name|tmpstr
expr_stmt|;
name|tmps
operator|=
name|str
operator|->
name|str_ptr
expr_stmt|;
name|putc
argument_list|(
literal|'*'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|str
operator|->
name|str_cur
operator|&&
operator|(
name|fwrite
argument_list|(
name|tmps
argument_list|,
literal|1
argument_list|,
name|str
operator|->
name|str_cur
argument_list|,
name|fp
argument_list|)
operator|==
literal|0
operator|||
name|ferror
argument_list|(
name|fp
argument_list|)
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|bool
name|do_aprint
parameter_list|(
name|arg
parameter_list|,
name|fp
parameter_list|,
name|arglast
parameter_list|)
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|retval
decl_stmt|;
specifier|register
name|int
name|items
init|=
name|arglast
index|[
literal|2
index|]
operator|-
name|sp
decl_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
if|if
condition|(
name|dowarn
condition|)
name|warn
argument_list|(
literal|"print to unopened file"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|st
operator|+=
operator|++
name|sp
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_PRTF
condition|)
block|{
name|do_sprintf
argument_list|(
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
argument_list|,
name|items
argument_list|,
name|st
argument_list|)
expr_stmt|;
name|retval
operator|=
name|do_print
argument_list|(
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
operator|(
name|items
operator|<=
literal|0
operator|)
expr_stmt|;
for|for
control|(
init|;
name|items
operator|>
literal|0
condition|;
name|items
operator|--
operator|,
name|st
operator|++
control|)
block|{
if|if
condition|(
name|retval
operator|&&
name|ofslen
condition|)
block|{
if|if
condition|(
name|fwrite
argument_list|(
name|ofs
argument_list|,
literal|1
argument_list|,
name|ofslen
argument_list|,
name|fp
argument_list|)
operator|==
literal|0
operator|||
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|retval
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|retval
operator|=
name|do_print
argument_list|(
operator|*
name|st
argument_list|,
name|fp
argument_list|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|retval
operator|&&
name|orslen
condition|)
if|if
condition|(
name|fwrite
argument_list|(
name|ors
argument_list|,
literal|1
argument_list|,
name|orslen
argument_list|,
name|fp
argument_list|)
operator|==
literal|0
operator|||
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|retval
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
name|int
name|mystat
parameter_list|(
name|arg
parameter_list|,
name|str
parameter_list|)
name|ARG
modifier|*
name|arg
decl_stmt|;
name|STR
modifier|*
name|str
decl_stmt|;
block|{
name|STIO
modifier|*
name|stio
decl_stmt|;
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_DONT
condition|)
block|{
name|stio
operator|=
name|stab_io
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
expr_stmt|;
if|if
condition|(
name|stio
operator|&&
name|stio
operator|->
name|ifp
condition|)
block|{
name|statstab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
name|str_set
argument_list|(
name|statname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|laststype
operator|=
name|O_STAT
expr_stmt|;
return|return
operator|(
name|laststatval
operator|=
name|fstat
argument_list|(
name|fileno
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
argument_list|,
operator|&
name|statcache
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
operator|==
name|defstab
condition|)
return|return
name|laststatval
return|;
if|if
condition|(
name|dowarn
condition|)
name|warn
argument_list|(
literal|"Stat on unopened file<%s>"
argument_list|,
name|stab_ename
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
argument_list|)
expr_stmt|;
name|statstab
operator|=
name|Nullstab
expr_stmt|;
name|str_set
argument_list|(
name|statname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|laststatval
operator|=
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|statstab
operator|=
name|Nullstab
expr_stmt|;
name|str_set
argument_list|(
name|statname
argument_list|,
name|str_get
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|laststype
operator|=
name|O_STAT
expr_stmt|;
name|laststatval
operator|=
name|stat
argument_list|(
name|str_get
argument_list|(
name|str
argument_list|)
argument_list|,
operator|&
name|statcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|laststatval
operator|<
literal|0
operator|&&
name|dowarn
operator|&&
name|index
argument_list|(
name|str_get
argument_list|(
name|str
argument_list|)
argument_list|,
literal|'\n'
argument_list|)
condition|)
name|warn
argument_list|(
name|warn_nl
argument_list|,
literal|"stat"
argument_list|)
expr_stmt|;
return|return
name|laststatval
return|;
block|}
block|}
end_function

begin_function
name|int
name|mylstat
parameter_list|(
name|arg
parameter_list|,
name|str
parameter_list|)
name|ARG
modifier|*
name|arg
decl_stmt|;
name|STR
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_DONT
condition|)
block|{
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
operator|==
name|defstab
condition|)
block|{
if|if
condition|(
name|laststype
operator|!=
name|O_LSTAT
condition|)
name|fatal
argument_list|(
literal|"The stat preceding -l _ wasn't an lstat"
argument_list|)
expr_stmt|;
return|return
name|laststatval
return|;
block|}
name|fatal
argument_list|(
literal|"You can't use -l on a filehandle"
argument_list|)
expr_stmt|;
block|}
name|laststype
operator|=
name|O_LSTAT
expr_stmt|;
name|statstab
operator|=
name|Nullstab
expr_stmt|;
name|str_set
argument_list|(
name|statname
argument_list|,
name|str_get
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_LSTAT
name|laststatval
operator|=
name|lstat
argument_list|(
name|str_get
argument_list|(
name|str
argument_list|)
argument_list|,
operator|&
name|statcache
argument_list|)
expr_stmt|;
else|#
directive|else
name|laststatval
operator|=
name|stat
argument_list|(
name|str_get
argument_list|(
name|str
argument_list|)
argument_list|,
operator|&
name|statcache
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|laststatval
operator|<
literal|0
operator|&&
name|dowarn
operator|&&
name|index
argument_list|(
name|str_get
argument_list|(
name|str
argument_list|)
argument_list|,
literal|'\n'
argument_list|)
condition|)
name|warn
argument_list|(
name|warn_nl
argument_list|,
literal|"lstat"
argument_list|)
expr_stmt|;
return|return
name|laststatval
return|;
block|}
end_function

begin_function
name|STR
modifier|*
name|do_fttext
parameter_list|(
name|arg
parameter_list|,
name|str
parameter_list|)
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
name|STR
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|odd
init|=
literal|0
decl_stmt|;
name|STDCHAR
name|tbuf
index|[
literal|512
index|]
decl_stmt|;
specifier|register
name|STDCHAR
modifier|*
name|s
decl_stmt|;
specifier|register
name|STIO
modifier|*
name|stio
decl_stmt|;
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_DONT
condition|)
block|{
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
operator|==
name|defstab
condition|)
block|{
if|if
condition|(
name|statstab
condition|)
name|stio
operator|=
name|stab_io
argument_list|(
name|statstab
argument_list|)
expr_stmt|;
else|else
block|{
name|str
operator|=
name|statname
expr_stmt|;
goto|goto
name|really_filename
goto|;
block|}
block|}
else|else
block|{
name|statstab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
name|str_set
argument_list|(
name|statname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|stio
operator|=
name|stab_io
argument_list|(
name|statstab
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stio
operator|&&
name|stio
operator|->
name|ifp
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|STDSTDIO
argument_list|)
operator|||
name|defined
argument_list|(
name|atarist
argument_list|)
comment|/* this will work with atariST */
name|fstat
argument_list|(
name|fileno
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
argument_list|,
operator|&
name|statcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|statcache
operator|.
name|st_mode
argument_list|)
condition|)
comment|/* handle NFS glitch */
return|return
name|arg
operator|->
name|arg_type
operator|==
name|O_FTTEXT
condition|?
operator|&
name|str_no
else|:
operator|&
name|str_yes
return|;
if|if
condition|(
name|stio
operator|->
name|ifp
operator|->
name|_cnt
operator|<=
literal|0
condition|)
block|{
name|i
operator|=
name|getc
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|EOF
condition|)
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|i
argument_list|,
name|stio
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stio
operator|->
name|ifp
operator|->
name|_cnt
operator|<=
literal|0
condition|)
comment|/* null file is anything */
return|return
operator|&
name|str_yes
return|;
name|len
operator|=
name|stio
operator|->
name|ifp
operator|->
name|_cnt
operator|+
operator|(
name|stio
operator|->
name|ifp
operator|->
name|_ptr
operator|-
name|stio
operator|->
name|ifp
operator|->
name|_base
operator|)
expr_stmt|;
name|s
operator|=
name|stio
operator|->
name|ifp
operator|->
name|_base
expr_stmt|;
else|#
directive|else
if|#
directive|if
operator|(
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|(
name|BSD
operator|>=
literal|199103
operator|)
operator|)
name|s
operator|=
name|stio
operator|->
name|ifp
operator|->
name|_base
expr_stmt|;
name|fstat
argument_list|(
name|fileno
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
argument_list|,
operator|&
name|statcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|statcache
operator|.
name|st_mode
argument_list|)
condition|)
comment|/* handle NFS glitch */
return|return
name|arg
operator|->
name|arg_type
operator|==
name|O_FTTEXT
condition|?
operator|&
name|str_no
else|:
operator|&
name|str_yes
return|;
if|if
condition|(
name|stio
operator|->
name|ifp
operator|->
name|_bf
operator|.
name|_size
operator|<=
literal|0
condition|)
block|{
name|i
operator|=
name|getc
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|EOF
condition|)
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|i
argument_list|,
name|stio
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stio
operator|->
name|ifp
operator|->
name|_bf
operator|.
name|_size
operator|<=
literal|0
condition|)
return|return
operator|&
name|str_yes
return|;
name|len
operator|=
name|stio
operator|->
name|ifp
operator|->
name|_bf
operator|.
name|_size
operator|+
operator|(
name|stio
operator|->
name|ifp
operator|->
name|_p
operator|-
name|stio
operator|->
name|ifp
operator|->
name|_bf
operator|.
name|_base
operator|)
expr_stmt|;
name|s
operator|=
name|stio
operator|->
name|ifp
operator|->
name|_bf
operator|.
name|_base
expr_stmt|;
else|#
directive|else
name|fatal
argument_list|(
literal|"-T and -B not implemented on filehandles"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|dowarn
condition|)
name|warn
argument_list|(
literal|"Test on unopened file<%s>"
argument_list|,
name|stab_ename
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|&
name|str_undef
return|;
block|}
block|}
else|else
block|{
name|statstab
operator|=
name|Nullstab
expr_stmt|;
name|str_set
argument_list|(
name|statname
argument_list|,
name|str_get
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|really_filename
label|:
name|i
operator|=
name|open
argument_list|(
name|str_get
argument_list|(
name|str
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|dowarn
operator|&&
name|index
argument_list|(
name|str_get
argument_list|(
name|str
argument_list|)
argument_list|,
literal|'\n'
argument_list|)
condition|)
name|warn
argument_list|(
name|warn_nl
argument_list|,
literal|"open"
argument_list|)
expr_stmt|;
return|return
operator|&
name|str_undef
return|;
block|}
name|fstat
argument_list|(
name|i
argument_list|,
operator|&
name|statcache
argument_list|)
expr_stmt|;
name|len
operator|=
name|read
argument_list|(
name|i
argument_list|,
name|tbuf
argument_list|,
literal|512
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|S_ISDIR
argument_list|(
name|statcache
operator|.
name|st_mode
argument_list|)
operator|&&
name|arg
operator|->
name|arg_type
operator|==
name|O_FTTEXT
condition|)
return|return
operator|&
name|str_no
return|;
comment|/* special case NFS directories */
return|return
operator|&
name|str_yes
return|;
comment|/* null file is anything */
block|}
name|s
operator|=
name|tbuf
expr_stmt|;
block|}
comment|/* now scan s to look for textiness */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|s
condition|)
block|{
comment|/* null never allowed in text */
name|odd
operator|+=
name|len
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|&
literal|128
condition|)
name|odd
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|<
literal|32
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
operator|&&
operator|*
name|s
operator|!=
literal|'\r'
operator|&&
operator|*
name|s
operator|!=
literal|'\b'
operator|&&
operator|*
name|s
operator|!=
literal|'\t'
operator|&&
operator|*
name|s
operator|!=
literal|'\f'
operator|&&
operator|*
name|s
operator|!=
literal|27
condition|)
name|odd
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|odd
operator|*
literal|10
operator|>
name|len
operator|)
operator|==
operator|(
name|arg
operator|->
name|arg_type
operator|==
name|O_FTTEXT
operator|)
condition|)
comment|/* allow 10% odd */
return|return
operator|&
name|str_no
return|;
else|else
return|return
operator|&
name|str_yes
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|Argv
init|=
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|Cmd
init|=
name|Nullch
decl_stmt|;
end_decl_stmt

begin_function
name|bool
name|do_aexec
parameter_list|(
name|really
parameter_list|,
name|arglast
parameter_list|)
name|STR
modifier|*
name|really
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|items
init|=
name|arglast
index|[
literal|2
index|]
operator|-
name|sp
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
if|if
condition|(
name|items
condition|)
block|{
name|New
argument_list|(
literal|401
argument_list|,
name|Argv
argument_list|,
name|items
operator|+
literal|1
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|a
operator|=
name|Argv
expr_stmt|;
for|for
control|(
name|st
operator|+=
operator|++
name|sp
init|;
name|items
operator|>
literal|0
condition|;
name|items
operator|--
operator|,
name|st
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|st
condition|)
operator|*
name|a
operator|++
operator|=
name|str_get
argument_list|(
operator|*
name|st
argument_list|)
expr_stmt|;
else|else
operator|*
name|a
operator|++
operator|=
literal|""
expr_stmt|;
block|}
operator|*
name|a
operator|=
name|Nullch
expr_stmt|;
ifdef|#
directive|ifdef
name|TAINT
if|if
condition|(
operator|*
name|Argv
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
comment|/* will execvp use PATH? */
name|taintenv
argument_list|()
expr_stmt|;
comment|/* testing IFS here is overkill, probably */
endif|#
directive|endif
if|if
condition|(
name|really
operator|&&
operator|*
operator|(
name|tmps
operator|=
name|str_get
argument_list|(
name|really
argument_list|)
operator|)
condition|)
name|execvp
argument_list|(
name|tmps
argument_list|,
name|Argv
argument_list|)
expr_stmt|;
else|else
name|execvp
argument_list|(
name|Argv
index|[
literal|0
index|]
argument_list|,
name|Argv
argument_list|)
expr_stmt|;
block|}
name|do_execfree
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|void
name|do_execfree
parameter_list|()
block|{
if|if
condition|(
name|Argv
condition|)
block|{
name|Safefree
argument_list|(
name|Argv
argument_list|)
expr_stmt|;
name|Argv
operator|=
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Cmd
condition|)
block|{
name|Safefree
argument_list|(
name|Cmd
argument_list|)
expr_stmt|;
name|Cmd
operator|=
name|Nullch
expr_stmt|;
block|}
block|}
end_function

begin_function
name|bool
name|do_exec
parameter_list|(
name|cmd
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|a
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|flags
index|[
literal|10
index|]
decl_stmt|;
comment|/* save an extra exec if possible */
ifdef|#
directive|ifdef
name|CSH
if|if
condition|(
name|strnEQ
argument_list|(
name|cmd
argument_list|,
name|cshname
argument_list|,
name|cshlen
argument_list|)
operator|&&
name|strnEQ
argument_list|(
name|cmd
operator|+
name|cshlen
argument_list|,
literal|" -c"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|flags
argument_list|,
literal|"-c"
argument_list|)
expr_stmt|;
name|s
operator|=
name|cmd
operator|+
name|cshlen
operator|+
literal|3
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'f'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|strcat
argument_list|(
name|flags
argument_list|,
literal|"f"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'\''
condition|)
block|{
name|char
modifier|*
name|ncmd
init|=
name|s
decl_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
operator|*
operator|--
name|s
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'\''
condition|)
block|{
operator|*
operator|--
name|s
operator|=
literal|'\0'
expr_stmt|;
name|execl
argument_list|(
name|cshname
argument_list|,
literal|"csh"
argument_list|,
name|flags
argument_list|,
name|ncmd
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|'\''
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* CSH */
comment|/* see if there are shell metacharacters in it */
comment|/*SUPPRESS 530*/
for|for
control|(
name|s
operator|=
name|cmd
init|;
operator|*
name|s
operator|&&
name|isALPHA
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
comment|/* catch VAR=val gizmo */
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
condition|)
goto|goto
name|doshell
goto|;
for|for
control|(
name|s
operator|=
name|cmd
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|!=
literal|' '
operator|&&
operator|!
name|isALPHA
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
name|index
argument_list|(
literal|"$&*(){}[]'\";\\|?<>~`\n"
argument_list|,
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
operator|&&
operator|!
name|s
index|[
literal|1
index|]
condition|)
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|doshell
label|:
name|execl
argument_list|(
literal|"/bin/sh"
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|cmd
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|New
argument_list|(
literal|402
argument_list|,
name|Argv
argument_list|,
operator|(
name|s
operator|-
name|cmd
operator|)
operator|/
literal|2
operator|+
literal|2
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|Cmd
operator|=
name|nsavestr
argument_list|(
name|cmd
argument_list|,
name|s
operator|-
name|cmd
argument_list|)
expr_stmt|;
name|a
operator|=
name|Argv
expr_stmt|;
for|for
control|(
name|s
operator|=
name|Cmd
init|;
operator|*
name|s
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|s
operator|&&
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
operator|*
operator|(
name|a
operator|++
operator|)
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|&&
operator|!
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|*
name|a
operator|=
name|Nullch
expr_stmt|;
if|if
condition|(
name|Argv
index|[
literal|0
index|]
condition|)
block|{
name|execvp
argument_list|(
name|Argv
index|[
literal|0
index|]
argument_list|,
name|Argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ENOEXEC
condition|)
block|{
comment|/* for system V NIH syndrome */
name|do_execfree
argument_list|()
expr_stmt|;
goto|goto
name|doshell
goto|;
block|}
block|}
name|do_execfree
argument_list|()
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_SOCKET
end_ifdef

begin_function
name|int
name|do_socket
parameter_list|(
name|stab
parameter_list|,
name|arglast
parameter_list|)
name|STAB
modifier|*
name|stab
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|STIO
modifier|*
name|stio
decl_stmt|;
name|int
name|domain
decl_stmt|,
name|type
decl_stmt|,
name|protocol
decl_stmt|,
name|fd
decl_stmt|;
if|if
condition|(
operator|!
name|stab
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|stio
operator|=
name|stab_io
argument_list|(
name|stab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stio
condition|)
name|stio
operator|=
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|=
name|stio_new
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|stio
operator|->
name|ifp
condition|)
name|do_close
argument_list|(
name|stab
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|domain
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
name|type
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
name|protocol
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in socket"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fd
operator|=
name|socket
argument_list|(
name|domain
argument_list|,
name|type
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
name|stio
operator|->
name|ifp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/* stdio gets confused about sockets */
name|stio
operator|->
name|ofp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|stio
operator|->
name|type
operator|=
literal|'s'
expr_stmt|;
if|if
condition|(
operator|!
name|stio
operator|->
name|ifp
operator|||
operator|!
name|stio
operator|->
name|ofp
condition|)
block|{
if|if
condition|(
name|stio
operator|->
name|ifp
condition|)
name|fclose
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stio
operator|->
name|ofp
condition|)
name|fclose
argument_list|(
name|stio
operator|->
name|ofp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stio
operator|->
name|ifp
operator|&&
operator|!
name|stio
operator|->
name|ofp
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|int
name|do_bind
parameter_list|(
name|stab
parameter_list|,
name|arglast
parameter_list|)
name|STAB
modifier|*
name|stab
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|STIO
modifier|*
name|stio
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
if|if
condition|(
operator|!
name|stab
condition|)
goto|goto
name|nuts
goto|;
name|stio
operator|=
name|stab_io
argument_list|(
name|stab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stio
operator|||
operator|!
name|stio
operator|->
name|ifp
condition|)
goto|goto
name|nuts
goto|;
name|addr
operator|=
name|str_get
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in bind"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|bind
argument_list|(
name|fileno
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
argument_list|,
name|addr
argument_list|,
name|st
index|[
name|sp
index|]
operator|->
name|str_cur
argument_list|)
operator|>=
literal|0
return|;
name|nuts
label|:
if|if
condition|(
name|dowarn
condition|)
name|warn
argument_list|(
literal|"bind() on closed fd"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|int
name|do_connect
parameter_list|(
name|stab
parameter_list|,
name|arglast
parameter_list|)
name|STAB
modifier|*
name|stab
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|STIO
modifier|*
name|stio
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
if|if
condition|(
operator|!
name|stab
condition|)
goto|goto
name|nuts
goto|;
name|stio
operator|=
name|stab_io
argument_list|(
name|stab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stio
operator|||
operator|!
name|stio
operator|->
name|ifp
condition|)
goto|goto
name|nuts
goto|;
name|addr
operator|=
name|str_get
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in connect"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|connect
argument_list|(
name|fileno
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
argument_list|,
name|addr
argument_list|,
name|st
index|[
name|sp
index|]
operator|->
name|str_cur
argument_list|)
operator|>=
literal|0
return|;
name|nuts
label|:
if|if
condition|(
name|dowarn
condition|)
name|warn
argument_list|(
literal|"connect() on closed fd"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|int
name|do_listen
parameter_list|(
name|stab
parameter_list|,
name|arglast
parameter_list|)
name|STAB
modifier|*
name|stab
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|STIO
modifier|*
name|stio
decl_stmt|;
name|int
name|backlog
decl_stmt|;
if|if
condition|(
operator|!
name|stab
condition|)
goto|goto
name|nuts
goto|;
name|stio
operator|=
name|stab_io
argument_list|(
name|stab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stio
operator|||
operator|!
name|stio
operator|->
name|ifp
condition|)
goto|goto
name|nuts
goto|;
name|backlog
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
return|return
name|listen
argument_list|(
name|fileno
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
argument_list|,
name|backlog
argument_list|)
operator|>=
literal|0
return|;
name|nuts
label|:
if|if
condition|(
name|dowarn
condition|)
name|warn
argument_list|(
literal|"listen() on closed fd"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|void
name|do_accept
parameter_list|(
name|str
parameter_list|,
name|nstab
parameter_list|,
name|gstab
parameter_list|)
name|STR
modifier|*
name|str
decl_stmt|;
name|STAB
modifier|*
name|nstab
decl_stmt|;
name|STAB
modifier|*
name|gstab
decl_stmt|;
block|{
specifier|register
name|STIO
modifier|*
name|nstio
decl_stmt|;
specifier|register
name|STIO
modifier|*
name|gstio
decl_stmt|;
name|int
name|len
init|=
sizeof|sizeof
name|buf
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|!
name|nstab
condition|)
goto|goto
name|badexit
goto|;
if|if
condition|(
operator|!
name|gstab
condition|)
goto|goto
name|nuts
goto|;
name|gstio
operator|=
name|stab_io
argument_list|(
name|gstab
argument_list|)
expr_stmt|;
name|nstio
operator|=
name|stab_io
argument_list|(
name|nstab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gstio
operator|||
operator|!
name|gstio
operator|->
name|ifp
condition|)
goto|goto
name|nuts
goto|;
if|if
condition|(
operator|!
name|nstio
condition|)
name|nstio
operator|=
name|stab_io
argument_list|(
name|nstab
argument_list|)
operator|=
name|stio_new
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|nstio
operator|->
name|ifp
condition|)
name|do_close
argument_list|(
name|nstab
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|fd
operator|=
name|accept
argument_list|(
name|fileno
argument_list|(
name|gstio
operator|->
name|ifp
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|buf
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
goto|goto
name|badexit
goto|;
name|nstio
operator|->
name|ifp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|nstio
operator|->
name|ofp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|nstio
operator|->
name|type
operator|=
literal|'s'
expr_stmt|;
if|if
condition|(
operator|!
name|nstio
operator|->
name|ifp
operator|||
operator|!
name|nstio
operator|->
name|ofp
condition|)
block|{
if|if
condition|(
name|nstio
operator|->
name|ifp
condition|)
name|fclose
argument_list|(
name|nstio
operator|->
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstio
operator|->
name|ofp
condition|)
name|fclose
argument_list|(
name|nstio
operator|->
name|ofp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nstio
operator|->
name|ifp
operator|&&
operator|!
name|nstio
operator|->
name|ofp
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
goto|goto
name|badexit
goto|;
block|}
name|str_nset
argument_list|(
name|str
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
name|nuts
label|:
if|if
condition|(
name|dowarn
condition|)
name|warn
argument_list|(
literal|"accept() on closed fd"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EBADF
expr_stmt|;
name|badexit
label|:
name|str_sset
argument_list|(
name|str
argument_list|,
operator|&
name|str_undef
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|do_shutdown
parameter_list|(
name|stab
parameter_list|,
name|arglast
parameter_list|)
name|STAB
modifier|*
name|stab
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|STIO
modifier|*
name|stio
decl_stmt|;
name|int
name|how
decl_stmt|;
if|if
condition|(
operator|!
name|stab
condition|)
goto|goto
name|nuts
goto|;
name|stio
operator|=
name|stab_io
argument_list|(
name|stab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stio
operator|||
operator|!
name|stio
operator|->
name|ifp
condition|)
goto|goto
name|nuts
goto|;
name|how
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
return|return
name|shutdown
argument_list|(
name|fileno
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
argument_list|,
name|how
argument_list|)
operator|>=
literal|0
return|;
name|nuts
label|:
if|if
condition|(
name|dowarn
condition|)
name|warn
argument_list|(
literal|"shutdown() on closed fd"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|int
name|do_sopt
parameter_list|(
name|optype
parameter_list|,
name|stab
parameter_list|,
name|arglast
parameter_list|)
name|int
name|optype
decl_stmt|;
name|STAB
modifier|*
name|stab
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|STIO
modifier|*
name|stio
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|unsigned
name|int
name|lvl
decl_stmt|;
name|unsigned
name|int
name|optname
decl_stmt|;
if|if
condition|(
operator|!
name|stab
condition|)
goto|goto
name|nuts
goto|;
name|stio
operator|=
name|stab_io
argument_list|(
name|stab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stio
operator|||
operator|!
name|stio
operator|->
name|ifp
condition|)
goto|goto
name|nuts
goto|;
name|fd
operator|=
name|fileno
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|lvl
operator|=
operator|(
name|unsigned
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
name|sp
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|optname
operator|=
operator|(
name|unsigned
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
name|sp
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|O_GSOCKOPT
case|:
name|st
index|[
name|sp
index|]
operator|=
name|str_2mortal
argument_list|(
name|Str_new
argument_list|(
literal|22
argument_list|,
literal|257
argument_list|)
argument_list|)
expr_stmt|;
name|st
index|[
name|sp
index|]
operator|->
name|str_cur
operator|=
literal|256
expr_stmt|;
name|st
index|[
name|sp
index|]
operator|->
name|str_pok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|getsockopt
argument_list|(
name|fd
argument_list|,
name|lvl
argument_list|,
name|optname
argument_list|,
name|st
index|[
name|sp
index|]
operator|->
name|str_ptr
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|st
index|[
name|sp
index|]
operator|->
name|str_cur
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|nuts
goto|;
break|break;
case|case
name|O_SSOCKOPT
case|:
name|st
index|[
name|sp
index|]
operator|=
name|st
index|[
name|sp
operator|+
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|fd
argument_list|,
name|lvl
argument_list|,
name|optname
argument_list|,
name|st
index|[
name|sp
index|]
operator|->
name|str_ptr
argument_list|,
name|st
index|[
name|sp
index|]
operator|->
name|str_cur
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|nuts
goto|;
name|st
index|[
name|sp
index|]
operator|=
operator|&
name|str_yes
expr_stmt|;
break|break;
block|}
return|return
name|sp
return|;
name|nuts
label|:
if|if
condition|(
name|dowarn
condition|)
name|warn
argument_list|(
literal|"[gs]etsockopt() on closed fd"
argument_list|)
expr_stmt|;
name|st
index|[
name|sp
index|]
operator|=
operator|&
name|str_undef
expr_stmt|;
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_function
name|int
name|do_getsockname
parameter_list|(
name|optype
parameter_list|,
name|stab
parameter_list|,
name|arglast
parameter_list|)
name|int
name|optype
decl_stmt|;
name|STAB
modifier|*
name|stab
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|STIO
modifier|*
name|stio
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|!
name|stab
condition|)
goto|goto
name|nuts
goto|;
name|stio
operator|=
name|stab_io
argument_list|(
name|stab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stio
operator|||
operator|!
name|stio
operator|->
name|ifp
condition|)
goto|goto
name|nuts
goto|;
name|st
index|[
name|sp
index|]
operator|=
name|str_2mortal
argument_list|(
name|Str_new
argument_list|(
literal|22
argument_list|,
literal|257
argument_list|)
argument_list|)
expr_stmt|;
name|st
index|[
name|sp
index|]
operator|->
name|str_cur
operator|=
literal|256
expr_stmt|;
name|st
index|[
name|sp
index|]
operator|->
name|str_pok
operator|=
literal|1
expr_stmt|;
name|fd
operator|=
name|fileno
argument_list|(
name|stio
operator|->
name|ifp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|O_GETSOCKNAME
case|:
if|if
condition|(
name|getsockname
argument_list|(
name|fd
argument_list|,
name|st
index|[
name|sp
index|]
operator|->
name|str_ptr
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|st
index|[
name|sp
index|]
operator|->
name|str_cur
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|nuts2
goto|;
break|break;
case|case
name|O_GETPEERNAME
case|:
if|if
condition|(
name|getpeername
argument_list|(
name|fd
argument_list|,
name|st
index|[
name|sp
index|]
operator|->
name|str_ptr
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|st
index|[
name|sp
index|]
operator|->
name|str_cur
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|nuts2
goto|;
break|break;
block|}
return|return
name|sp
return|;
name|nuts
label|:
if|if
condition|(
name|dowarn
condition|)
name|warn
argument_list|(
literal|"get{sock,peer}name() on closed fd"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EBADF
expr_stmt|;
name|nuts2
label|:
name|st
index|[
name|sp
index|]
operator|=
operator|&
name|str_undef
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_function
name|int
name|do_ghent
parameter_list|(
name|which
parameter_list|,
name|gimme
parameter_list|,
name|arglast
parameter_list|)
name|int
name|which
decl_stmt|;
name|int
name|gimme
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|ARRAY
modifier|*
name|ary
init|=
name|stack
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|elem
decl_stmt|;
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
name|struct
name|hostent
modifier|*
name|gethostbyname
parameter_list|()
function_decl|;
name|struct
name|hostent
modifier|*
name|gethostbyaddr
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|HAS_GETHOSTENT
name|struct
name|hostent
modifier|*
name|gethostent
parameter_list|()
function_decl|;
endif|#
directive|endif
name|struct
name|hostent
modifier|*
name|hent
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|;
if|if
condition|(
name|which
operator|==
name|O_GHBYNAME
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|str_get
argument_list|(
name|ary
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
name|hent
operator|=
name|gethostbyname
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|which
operator|==
name|O_GHBYADDR
condition|)
block|{
name|STR
modifier|*
name|addrstr
init|=
name|ary
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|addrtype
init|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|ary
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|2
index|]
argument_list|)
decl_stmt|;
name|char
modifier|*
name|addr
init|=
name|str_get
argument_list|(
name|addrstr
argument_list|)
decl_stmt|;
name|hent
operator|=
name|gethostbyaddr
argument_list|(
name|addr
argument_list|,
name|addrstr
operator|->
name|str_cur
argument_list|,
name|addrtype
argument_list|)
expr_stmt|;
block|}
else|else
ifdef|#
directive|ifdef
name|HAS_GETHOSTENT
name|hent
operator|=
name|gethostent
argument_list|()
expr_stmt|;
else|#
directive|else
name|fatal
argument_list|(
literal|"gethostent not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HOST_NOT_FOUND
if|if
condition|(
operator|!
name|hent
condition|)
name|statusvalue
operator|=
operator|(
name|unsigned
name|short
operator|)
name|h_errno
operator|&
literal|0xffff
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|gimme
operator|!=
name|G_ARRAY
condition|)
block|{
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_undef
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hent
condition|)
block|{
if|if
condition|(
name|which
operator|==
name|O_GHBYNAME
condition|)
block|{
ifdef|#
directive|ifdef
name|h_addr
name|str_nset
argument_list|(
name|str
argument_list|,
operator|*
name|hent
operator|->
name|h_addr
argument_list|,
name|hent
operator|->
name|h_length
argument_list|)
expr_stmt|;
else|#
directive|else
name|str_nset
argument_list|(
name|str
argument_list|,
name|hent
operator|->
name|h_addr
argument_list|,
name|hent
operator|->
name|h_length
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|str_set
argument_list|(
name|str
argument_list|,
name|hent
operator|->
name|h_name
argument_list|)
expr_stmt|;
block|}
return|return
name|sp
return|;
block|}
if|if
condition|(
name|hent
condition|)
block|{
ifndef|#
directive|ifndef
name|lint
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
name|hent
operator|->
name|h_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|elem
operator|=
name|hent
operator|->
name|h_aliases
init|;
operator|*
name|elem
condition|;
name|elem
operator|++
control|)
block|{
name|str_cat
argument_list|(
name|str
argument_list|,
operator|*
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
index|[
literal|1
index|]
condition|)
name|str_ncat
argument_list|(
name|str
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|double
operator|)
name|hent
operator|->
name|h_addrtype
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|hent
operator|->
name|h_length
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|double
operator|)
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|h_addr
for|for
control|(
name|elem
operator|=
name|hent
operator|->
name|h_addr_list
init|;
operator|*
name|elem
condition|;
name|elem
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
name|str_nset
argument_list|(
name|str
argument_list|,
operator|*
name|elem
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
name|str_nset
argument_list|(
name|str
argument_list|,
name|hent
operator|->
name|h_addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* h_addr */
else|#
directive|else
comment|/* lint */
name|elem
operator|=
name|Nullch
expr_stmt|;
name|elem
operator|=
name|elem
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* lint */
block|}
return|return
name|sp
return|;
block|}
end_function

begin_function
name|int
name|do_gnent
parameter_list|(
name|which
parameter_list|,
name|gimme
parameter_list|,
name|arglast
parameter_list|)
name|int
name|which
decl_stmt|;
name|int
name|gimme
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|ARRAY
modifier|*
name|ary
init|=
name|stack
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|elem
decl_stmt|;
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
name|struct
name|netent
modifier|*
name|getnetbyname
parameter_list|()
function_decl|;
name|struct
name|netent
modifier|*
name|getnetbyaddr
parameter_list|()
function_decl|;
name|struct
name|netent
modifier|*
name|getnetent
parameter_list|()
function_decl|;
name|struct
name|netent
modifier|*
name|nent
decl_stmt|;
if|if
condition|(
name|which
operator|==
name|O_GNBYNAME
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|str_get
argument_list|(
name|ary
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
name|nent
operator|=
name|getnetbyname
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|which
operator|==
name|O_GNBYADDR
condition|)
block|{
name|unsigned
name|long
name|addr
init|=
name|U_L
argument_list|(
name|str_gnum
argument_list|(
name|ary
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|1
index|]
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|addrtype
init|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|ary
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|2
index|]
argument_list|)
decl_stmt|;
name|nent
operator|=
name|getnetbyaddr
argument_list|(
operator|(
name|long
operator|)
name|addr
argument_list|,
name|addrtype
argument_list|)
expr_stmt|;
block|}
else|else
name|nent
operator|=
name|getnetent
argument_list|()
expr_stmt|;
if|if
condition|(
name|gimme
operator|!=
name|G_ARRAY
condition|)
block|{
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_undef
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nent
condition|)
block|{
if|if
condition|(
name|which
operator|==
name|O_GNBYNAME
condition|)
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|double
operator|)
name|nent
operator|->
name|n_net
argument_list|)
expr_stmt|;
else|else
name|str_set
argument_list|(
name|str
argument_list|,
name|nent
operator|->
name|n_name
argument_list|)
expr_stmt|;
block|}
return|return
name|sp
return|;
block|}
if|if
condition|(
name|nent
condition|)
block|{
ifndef|#
directive|ifndef
name|lint
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
name|nent
operator|->
name|n_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|elem
operator|=
name|nent
operator|->
name|n_aliases
init|;
operator|*
name|elem
condition|;
name|elem
operator|++
control|)
block|{
name|str_cat
argument_list|(
name|str
argument_list|,
operator|*
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
index|[
literal|1
index|]
condition|)
name|str_ncat
argument_list|(
name|str
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|double
operator|)
name|nent
operator|->
name|n_addrtype
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|double
operator|)
name|nent
operator|->
name|n_net
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* lint */
name|elem
operator|=
name|Nullch
expr_stmt|;
name|elem
operator|=
name|elem
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* lint */
block|}
return|return
name|sp
return|;
block|}
end_function

begin_function
name|int
name|do_gpent
parameter_list|(
name|which
parameter_list|,
name|gimme
parameter_list|,
name|arglast
parameter_list|)
name|int
name|which
decl_stmt|;
name|int
name|gimme
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|ARRAY
modifier|*
name|ary
init|=
name|stack
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|elem
decl_stmt|;
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
name|struct
name|protoent
modifier|*
name|getprotobyname
parameter_list|()
function_decl|;
name|struct
name|protoent
modifier|*
name|getprotobynumber
parameter_list|()
function_decl|;
name|struct
name|protoent
modifier|*
name|getprotoent
parameter_list|()
function_decl|;
name|struct
name|protoent
modifier|*
name|pent
decl_stmt|;
if|if
condition|(
name|which
operator|==
name|O_GPBYNAME
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|str_get
argument_list|(
name|ary
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
name|pent
operator|=
name|getprotobyname
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|which
operator|==
name|O_GPBYNUMBER
condition|)
block|{
name|int
name|proto
init|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|ary
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
name|pent
operator|=
name|getprotobynumber
argument_list|(
name|proto
argument_list|)
expr_stmt|;
block|}
else|else
name|pent
operator|=
name|getprotoent
argument_list|()
expr_stmt|;
if|if
condition|(
name|gimme
operator|!=
name|G_ARRAY
condition|)
block|{
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_undef
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pent
condition|)
block|{
if|if
condition|(
name|which
operator|==
name|O_GPBYNAME
condition|)
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|double
operator|)
name|pent
operator|->
name|p_proto
argument_list|)
expr_stmt|;
else|else
name|str_set
argument_list|(
name|str
argument_list|,
name|pent
operator|->
name|p_name
argument_list|)
expr_stmt|;
block|}
return|return
name|sp
return|;
block|}
if|if
condition|(
name|pent
condition|)
block|{
ifndef|#
directive|ifndef
name|lint
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
name|pent
operator|->
name|p_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|elem
operator|=
name|pent
operator|->
name|p_aliases
init|;
operator|*
name|elem
condition|;
name|elem
operator|++
control|)
block|{
name|str_cat
argument_list|(
name|str
argument_list|,
operator|*
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
index|[
literal|1
index|]
condition|)
name|str_ncat
argument_list|(
name|str
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|double
operator|)
name|pent
operator|->
name|p_proto
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* lint */
name|elem
operator|=
name|Nullch
expr_stmt|;
name|elem
operator|=
name|elem
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* lint */
block|}
return|return
name|sp
return|;
block|}
end_function

begin_function
name|int
name|do_gsent
parameter_list|(
name|which
parameter_list|,
name|gimme
parameter_list|,
name|arglast
parameter_list|)
name|int
name|which
decl_stmt|;
name|int
name|gimme
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|ARRAY
modifier|*
name|ary
init|=
name|stack
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|elem
decl_stmt|;
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
name|struct
name|servent
modifier|*
name|getservbyname
parameter_list|()
function_decl|;
name|struct
name|servent
modifier|*
name|getservbynumber
parameter_list|()
function_decl|;
name|struct
name|servent
modifier|*
name|getservent
parameter_list|()
function_decl|;
name|struct
name|servent
modifier|*
name|sent
decl_stmt|;
if|if
condition|(
name|which
operator|==
name|O_GSBYNAME
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|str_get
argument_list|(
name|ary
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
name|char
modifier|*
name|proto
init|=
name|str_get
argument_list|(
name|ary
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|2
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|proto
operator|&&
operator|!
operator|*
name|proto
condition|)
name|proto
operator|=
name|Nullch
expr_stmt|;
name|sent
operator|=
name|getservbyname
argument_list|(
name|name
argument_list|,
name|proto
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|which
operator|==
name|O_GSBYPORT
condition|)
block|{
name|int
name|port
init|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|ary
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
name|char
modifier|*
name|proto
init|=
name|str_get
argument_list|(
name|ary
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|2
index|]
argument_list|)
decl_stmt|;
name|sent
operator|=
name|getservbyport
argument_list|(
name|port
argument_list|,
name|proto
argument_list|)
expr_stmt|;
block|}
else|else
name|sent
operator|=
name|getservent
argument_list|()
expr_stmt|;
if|if
condition|(
name|gimme
operator|!=
name|G_ARRAY
condition|)
block|{
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_undef
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sent
condition|)
block|{
if|if
condition|(
name|which
operator|==
name|O_GSBYNAME
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_NTOHS
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|double
operator|)
name|ntohs
argument_list|(
name|sent
operator|->
name|s_port
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|str_numset
argument_list|(
name|str
argument_list|,
call|(
name|double
call|)
argument_list|(
name|sent
operator|->
name|s_port
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|str_set
argument_list|(
name|str
argument_list|,
name|sent
operator|->
name|s_name
argument_list|)
expr_stmt|;
block|}
return|return
name|sp
return|;
block|}
if|if
condition|(
name|sent
condition|)
block|{
ifndef|#
directive|ifndef
name|lint
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
name|sent
operator|->
name|s_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|elem
operator|=
name|sent
operator|->
name|s_aliases
init|;
operator|*
name|elem
condition|;
name|elem
operator|++
control|)
block|{
name|str_cat
argument_list|(
name|str
argument_list|,
operator|*
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
index|[
literal|1
index|]
condition|)
name|str_ncat
argument_list|(
name|str
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_NTOHS
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|double
operator|)
name|ntohs
argument_list|(
name|sent
operator|->
name|s_port
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|str_numset
argument_list|(
name|str
argument_list|,
call|(
name|double
call|)
argument_list|(
name|sent
operator|->
name|s_port
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
name|sent
operator|->
name|s_proto
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* lint */
name|elem
operator|=
name|Nullch
expr_stmt|;
name|elem
operator|=
name|elem
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* lint */
block|}
return|return
name|sp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAS_SOCKET */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_SELECT
end_ifdef

begin_function
name|int
name|do_select
parameter_list|(
name|gimme
parameter_list|,
name|arglast
parameter_list|)
name|int
name|gimme
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
name|double
name|value
decl_stmt|;
name|int
name|maxlen
init|=
literal|0
decl_stmt|;
name|int
name|nfound
decl_stmt|;
name|struct
name|timeval
name|timebuf
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tbuf
init|=
operator|&
name|timebuf
decl_stmt|;
name|int
name|growsize
decl_stmt|;
if|#
directive|if
name|BYTEORDER
operator|!=
literal|0x1234
operator|&&
name|BYTEORDER
operator|!=
literal|0x12345678
name|int
name|masksize
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|char
modifier|*
name|fd_sets
index|[
literal|4
index|]
decl_stmt|;
name|int
name|k
decl_stmt|;
if|#
directive|if
name|BYTEORDER
operator|&
literal|0xf0000
define|#
directive|define
name|ORDERBYTE
value|(0x88888888 - BYTEORDER)
else|#
directive|else
define|#
directive|define
name|ORDERBYTE
value|(0x4444 - BYTEORDER)
endif|#
directive|endif
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|st
index|[
name|sp
operator|+
name|i
index|]
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
name|maxlen
operator|<
name|j
condition|)
name|maxlen
operator|=
name|j
expr_stmt|;
block|}
if|#
directive|if
name|BYTEORDER
operator|==
literal|0x1234
operator|||
name|BYTEORDER
operator|==
literal|0x12345678
name|growsize
operator|=
name|maxlen
expr_stmt|;
comment|/* little endians can use vecs directly */
else|#
directive|else
ifdef|#
directive|ifdef
name|NFDBITS
ifndef|#
directive|ifndef
name|NBBY
define|#
directive|define
name|NBBY
value|8
endif|#
directive|endif
name|masksize
operator|=
name|NFDBITS
operator|/
name|NBBY
expr_stmt|;
else|#
directive|else
name|masksize
operator|=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
comment|/* documented int, everyone seems to use long */
endif|#
directive|endif
name|growsize
operator|=
name|maxlen
operator|+
operator|(
name|masksize
operator|-
operator|(
name|maxlen
operator|%
name|masksize
operator|)
operator|)
expr_stmt|;
name|Zero
argument_list|(
operator|&
name|fd_sets
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|str
operator|=
name|st
index|[
name|sp
operator|+
name|i
index|]
expr_stmt|;
name|j
operator|=
name|str
operator|->
name|str_len
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|growsize
condition|)
block|{
if|if
condition|(
name|str
operator|->
name|str_pok
condition|)
block|{
name|Str_Grow
argument_list|(
name|str
argument_list|,
name|growsize
argument_list|)
expr_stmt|;
name|s
operator|=
name|str_get
argument_list|(
name|str
argument_list|)
operator|+
name|j
expr_stmt|;
while|while
condition|(
operator|++
name|j
operator|<=
name|growsize
condition|)
block|{
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|str
operator|->
name|str_ptr
condition|)
block|{
name|Safefree
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_ptr
operator|=
name|Nullch
expr_stmt|;
block|}
block|}
if|#
directive|if
name|BYTEORDER
operator|!=
literal|0x1234
operator|&&
name|BYTEORDER
operator|!=
literal|0x12345678
name|s
operator|=
name|str
operator|->
name|str_ptr
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|New
argument_list|(
literal|403
argument_list|,
name|fd_sets
index|[
name|i
index|]
argument_list|,
name|growsize
argument_list|,
name|char
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|growsize
condition|;
name|offset
operator|+=
name|masksize
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|k
operator|=
name|ORDERBYTE
init|;
name|j
operator|<
name|masksize
condition|;
name|j
operator|++
operator|,
operator|(
name|k
operator|>>=
literal|4
operator|)
control|)
name|fd_sets
index|[
name|i
index|]
index|[
name|j
operator|+
name|offset
index|]
operator|=
name|s
index|[
operator|(
name|k
operator|%
name|masksize
operator|)
operator|+
name|offset
index|]
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
name|str
operator|=
name|st
index|[
name|sp
operator|+
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|str
operator|->
name|str_nok
operator|||
name|str
operator|->
name|str_pok
condition|)
block|{
name|value
operator|=
name|str_gnum
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0.0
condition|)
name|value
operator|=
literal|0.0
expr_stmt|;
name|timebuf
operator|.
name|tv_sec
operator|=
operator|(
name|long
operator|)
name|value
expr_stmt|;
name|value
operator|-=
operator|(
name|double
operator|)
name|timebuf
operator|.
name|tv_sec
expr_stmt|;
name|timebuf
operator|.
name|tv_usec
operator|=
call|(
name|long
call|)
argument_list|(
name|value
operator|*
literal|1000000.0
argument_list|)
expr_stmt|;
block|}
else|else
name|tbuf
operator|=
name|Null
argument_list|(
expr|struct
name|timeval
operator|*
argument_list|)
expr_stmt|;
if|#
directive|if
name|BYTEORDER
operator|==
literal|0x1234
operator|||
name|BYTEORDER
operator|==
literal|0x12345678
name|nfound
operator|=
name|select
argument_list|(
name|maxlen
operator|*
literal|8
argument_list|,
name|st
index|[
name|sp
operator|+
literal|1
index|]
operator|->
name|str_ptr
argument_list|,
name|st
index|[
name|sp
operator|+
literal|2
index|]
operator|->
name|str_ptr
argument_list|,
name|st
index|[
name|sp
operator|+
literal|3
index|]
operator|->
name|str_ptr
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
else|#
directive|else
name|nfound
operator|=
name|select
argument_list|(
name|maxlen
operator|*
literal|8
argument_list|,
name|fd_sets
index|[
literal|1
index|]
argument_list|,
name|fd_sets
index|[
literal|2
index|]
argument_list|,
name|fd_sets
index|[
literal|3
index|]
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fd_sets
index|[
name|i
index|]
condition|)
block|{
name|str
operator|=
name|st
index|[
name|sp
operator|+
name|i
index|]
expr_stmt|;
name|s
operator|=
name|str
operator|->
name|str_ptr
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|growsize
condition|;
name|offset
operator|+=
name|masksize
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|k
operator|=
name|ORDERBYTE
init|;
name|j
operator|<
name|masksize
condition|;
name|j
operator|++
operator|,
operator|(
name|k
operator|>>=
literal|4
operator|)
control|)
name|s
index|[
operator|(
name|k
operator|%
name|masksize
operator|)
operator|+
name|offset
index|]
operator|=
name|fd_sets
index|[
name|i
index|]
index|[
name|j
operator|+
name|offset
index|]
expr_stmt|;
block|}
name|Safefree
argument_list|(
name|fd_sets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|st
index|[
operator|++
name|sp
index|]
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|st
index|[
name|sp
index|]
argument_list|,
operator|(
name|double
operator|)
name|nfound
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
operator|&&
name|tbuf
condition|)
block|{
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|timebuf
operator|.
name|tv_sec
argument_list|)
operator|+
call|(
name|double
call|)
argument_list|(
name|timebuf
operator|.
name|tv_usec
argument_list|)
operator|/
literal|1000000.0
expr_stmt|;
name|st
index|[
operator|++
name|sp
index|]
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|st
index|[
name|sp
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|sp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SELECT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_SOCKET
end_ifdef

begin_function
name|int
name|do_spair
parameter_list|(
name|stab1
parameter_list|,
name|stab2
parameter_list|,
name|arglast
parameter_list|)
name|STAB
modifier|*
name|stab1
decl_stmt|;
name|STAB
modifier|*
name|stab2
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|STIO
modifier|*
name|stio1
decl_stmt|;
specifier|register
name|STIO
modifier|*
name|stio2
decl_stmt|;
name|int
name|domain
decl_stmt|,
name|type
decl_stmt|,
name|protocol
decl_stmt|,
name|fd
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|stab1
operator|||
operator|!
name|stab2
condition|)
return|return
name|FALSE
return|;
name|stio1
operator|=
name|stab_io
argument_list|(
name|stab1
argument_list|)
expr_stmt|;
name|stio2
operator|=
name|stab_io
argument_list|(
name|stab2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stio1
condition|)
name|stio1
operator|=
name|stab_io
argument_list|(
name|stab1
argument_list|)
operator|=
name|stio_new
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|stio1
operator|->
name|ifp
condition|)
name|do_close
argument_list|(
name|stab1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stio2
condition|)
name|stio2
operator|=
name|stab_io
argument_list|(
name|stab2
argument_list|)
operator|=
name|stio_new
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|stio2
operator|->
name|ifp
condition|)
name|do_close
argument_list|(
name|stab2
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|domain
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
name|type
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
name|protocol
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in socketpair"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_SOCKETPAIR
if|if
condition|(
name|socketpair
argument_list|(
name|domain
argument_list|,
name|type
argument_list|,
name|protocol
argument_list|,
name|fd
argument_list|)
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
else|#
directive|else
name|fatal
argument_list|(
literal|"Socketpair unimplemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stio1
operator|->
name|ifp
operator|=
name|fdopen
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|stio1
operator|->
name|ofp
operator|=
name|fdopen
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|stio1
operator|->
name|type
operator|=
literal|'s'
expr_stmt|;
name|stio2
operator|->
name|ifp
operator|=
name|fdopen
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|stio2
operator|->
name|ofp
operator|=
name|fdopen
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|stio2
operator|->
name|type
operator|=
literal|'s'
expr_stmt|;
if|if
condition|(
operator|!
name|stio1
operator|->
name|ifp
operator|||
operator|!
name|stio1
operator|->
name|ofp
operator|||
operator|!
name|stio2
operator|->
name|ifp
operator|||
operator|!
name|stio2
operator|->
name|ofp
condition|)
block|{
if|if
condition|(
name|stio1
operator|->
name|ifp
condition|)
name|fclose
argument_list|(
name|stio1
operator|->
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stio1
operator|->
name|ofp
condition|)
name|fclose
argument_list|(
name|stio1
operator|->
name|ofp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stio1
operator|->
name|ifp
operator|&&
operator|!
name|stio1
operator|->
name|ofp
condition|)
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|stio2
operator|->
name|ifp
condition|)
name|fclose
argument_list|(
name|stio2
operator|->
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stio2
operator|->
name|ofp
condition|)
name|fclose
argument_list|(
name|stio2
operator|->
name|ofp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stio2
operator|->
name|ifp
operator|&&
operator|!
name|stio2
operator|->
name|ofp
condition|)
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAS_SOCKET */
end_comment

begin_function
name|int
name|do_gpwent
parameter_list|(
name|which
parameter_list|,
name|gimme
parameter_list|,
name|arglast
parameter_list|)
name|int
name|which
decl_stmt|;
name|int
name|gimme
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|I_PWD
specifier|register
name|ARRAY
modifier|*
name|ary
init|=
name|stack
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
name|struct
name|passwd
modifier|*
name|getpwent
parameter_list|()
function_decl|;
name|struct
name|passwd
modifier|*
name|pwent
decl_stmt|;
if|if
condition|(
name|which
operator|==
name|O_GPWNAM
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|str_get
argument_list|(
name|ary
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
name|pwent
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|which
operator|==
name|O_GPWUID
condition|)
block|{
name|int
name|uid
init|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|ary
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
name|pwent
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
block|}
else|else
name|pwent
operator|=
name|getpwent
argument_list|()
expr_stmt|;
if|if
condition|(
name|gimme
operator|!=
name|G_ARRAY
condition|)
block|{
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_undef
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwent
condition|)
block|{
if|if
condition|(
name|which
operator|==
name|O_GPWNAM
condition|)
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|double
operator|)
name|pwent
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
else|else
name|str_set
argument_list|(
name|str
argument_list|,
name|pwent
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
return|return
name|sp
return|;
block|}
if|if
condition|(
name|pwent
condition|)
block|{
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
name|pwent
operator|->
name|pw_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
name|pwent
operator|->
name|pw_passwd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|double
operator|)
name|pwent
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|double
operator|)
name|pwent
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PWCHANGE
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|double
operator|)
name|pwent
operator|->
name|pw_change
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|PWQUOTA
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|double
operator|)
name|pwent
operator|->
name|pw_quota
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|PWAGE
name|str_set
argument_list|(
name|str
argument_list|,
name|pwent
operator|->
name|pw_age
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PWCLASS
name|str_set
argument_list|(
name|str
argument_list|,
name|pwent
operator|->
name|pw_class
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|PWCOMMENT
name|str_set
argument_list|(
name|str
argument_list|,
name|pwent
operator|->
name|pw_comment
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
name|pwent
operator|->
name|pw_gecos
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
name|pwent
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
name|pwent
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PWEXPIRE
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|double
operator|)
name|pwent
operator|->
name|pw_expire
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|sp
return|;
else|#
directive|else
name|fatal
argument_list|(
literal|"password routines not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|do_ggrent
parameter_list|(
name|which
parameter_list|,
name|gimme
parameter_list|,
name|arglast
parameter_list|)
name|int
name|which
decl_stmt|;
name|int
name|gimme
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|I_GRP
specifier|register
name|ARRAY
modifier|*
name|ary
init|=
name|stack
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|elem
decl_stmt|;
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
name|struct
name|group
modifier|*
name|getgrnam
parameter_list|()
function_decl|;
name|struct
name|group
modifier|*
name|getgrgid
parameter_list|()
function_decl|;
name|struct
name|group
modifier|*
name|getgrent
parameter_list|()
function_decl|;
name|struct
name|group
modifier|*
name|grent
decl_stmt|;
if|if
condition|(
name|which
operator|==
name|O_GGRNAM
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|str_get
argument_list|(
name|ary
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
name|grent
operator|=
name|getgrnam
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|which
operator|==
name|O_GGRGID
condition|)
block|{
name|int
name|gid
init|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|ary
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
name|grent
operator|=
name|getgrgid
argument_list|(
name|gid
argument_list|)
expr_stmt|;
block|}
else|else
name|grent
operator|=
name|getgrent
argument_list|()
expr_stmt|;
if|if
condition|(
name|gimme
operator|!=
name|G_ARRAY
condition|)
block|{
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_undef
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|grent
condition|)
block|{
if|if
condition|(
name|which
operator|==
name|O_GGRNAM
condition|)
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|double
operator|)
name|grent
operator|->
name|gr_gid
argument_list|)
expr_stmt|;
else|else
name|str_set
argument_list|(
name|str
argument_list|,
name|grent
operator|->
name|gr_name
argument_list|)
expr_stmt|;
block|}
return|return
name|sp
return|;
block|}
if|if
condition|(
name|grent
condition|)
block|{
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
name|grent
operator|->
name|gr_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
name|grent
operator|->
name|gr_passwd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|double
operator|)
name|grent
operator|->
name|gr_gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_no
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|elem
operator|=
name|grent
operator|->
name|gr_mem
init|;
operator|*
name|elem
condition|;
name|elem
operator|++
control|)
block|{
name|str_cat
argument_list|(
name|str
argument_list|,
operator|*
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
index|[
literal|1
index|]
condition|)
name|str_ncat
argument_list|(
name|str
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|sp
return|;
else|#
directive|else
name|fatal
argument_list|(
literal|"group routines not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|do_dirop
parameter_list|(
name|optype
parameter_list|,
name|stab
parameter_list|,
name|gimme
parameter_list|,
name|arglast
parameter_list|)
name|int
name|optype
decl_stmt|;
name|STAB
modifier|*
name|stab
decl_stmt|;
name|int
name|gimme
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|DIRENT
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAS_READDIR
argument_list|)
specifier|register
name|ARRAY
modifier|*
name|ary
init|=
name|stack
decl_stmt|;
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|ary
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|STIO
modifier|*
name|stio
decl_stmt|;
name|long
name|along
decl_stmt|;
ifndef|#
directive|ifndef
name|apollo
name|struct
name|DIRENT
modifier|*
name|readdir
parameter_list|()
function_decl|;
endif|#
directive|endif
specifier|register
name|struct
name|DIRENT
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|!
name|stab
condition|)
goto|goto
name|nope
goto|;
if|if
condition|(
operator|!
operator|(
name|stio
operator|=
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|)
condition|)
name|stio
operator|=
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|=
name|stio_new
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|stio
operator|->
name|dirp
operator|&&
name|optype
operator|!=
name|O_OPEN_DIR
condition|)
goto|goto
name|nope
goto|;
name|st
index|[
name|sp
index|]
operator|=
operator|&
name|str_yes
expr_stmt|;
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|O_OPEN_DIR
case|:
if|if
condition|(
name|stio
operator|->
name|dirp
condition|)
name|closedir
argument_list|(
name|stio
operator|->
name|dirp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|stio
operator|->
name|dirp
operator|=
name|opendir
argument_list|(
name|str_get
argument_list|(
name|st
index|[
name|sp
operator|+
literal|1
index|]
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|nope
goto|;
break|break;
case|case
name|O_READDIR
case|:
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
block|{
operator|--
name|sp
expr_stmt|;
comment|/*SUPPRESS 560*/
while|while
condition|(
name|dp
operator|=
name|readdir
argument_list|(
name|stio
operator|->
name|dirp
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DIRNAMLEN
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str_2mortal
argument_list|(
name|str_make
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|dp
operator|->
name|d_namlen
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
operator|++
name|sp
argument_list|,
name|str_2mortal
argument_list|(
name|str_make
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|stio
operator|->
name|dirp
argument_list|)
operator|)
condition|)
goto|goto
name|nope
goto|;
name|st
index|[
name|sp
index|]
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_undef
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIRNAMLEN
name|str_nset
argument_list|(
name|st
index|[
name|sp
index|]
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|dp
operator|->
name|d_namlen
argument_list|)
expr_stmt|;
else|#
directive|else
name|str_set
argument_list|(
name|st
index|[
name|sp
index|]
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
if|#
directive|if
name|defined
argument_list|(
name|HAS_TELLDIR
argument_list|)
operator|||
name|defined
argument_list|(
name|telldir
argument_list|)
case|case
name|O_TELLDIR
case|:
block|{
ifndef|#
directive|ifndef
name|telldir
name|long
name|telldir
parameter_list|()
function_decl|;
endif|#
directive|endif
name|st
index|[
name|sp
index|]
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_undef
argument_list|)
expr_stmt|;
name|str_numset
argument_list|(
name|st
index|[
name|sp
index|]
argument_list|,
operator|(
name|double
operator|)
name|telldir
argument_list|(
name|stio
operator|->
name|dirp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAS_SEEKDIR
argument_list|)
operator|||
name|defined
argument_list|(
name|seekdir
argument_list|)
case|case
name|O_SEEKDIR
case|:
name|st
index|[
name|sp
index|]
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_undef
argument_list|)
expr_stmt|;
name|along
operator|=
operator|(
name|long
operator|)
name|str_gnum
argument_list|(
name|st
index|[
name|sp
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|seekdir
argument_list|(
name|stio
operator|->
name|dirp
argument_list|,
name|along
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAS_REWINDDIR
argument_list|)
operator|||
name|defined
argument_list|(
name|rewinddir
argument_list|)
case|case
name|O_REWINDDIR
case|:
name|st
index|[
name|sp
index|]
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_undef
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rewinddir
argument_list|(
name|stio
operator|->
name|dirp
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|O_CLOSEDIR
case|:
name|st
index|[
name|sp
index|]
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_undef
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|stio
operator|->
name|dirp
argument_list|)
expr_stmt|;
name|stio
operator|->
name|dirp
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
goto|goto
name|phooey
goto|;
block|}
return|return
name|sp
return|;
name|nope
label|:
name|st
index|[
name|sp
index|]
operator|=
operator|&
name|str_undef
expr_stmt|;
if|if
condition|(
operator|!
name|errno
condition|)
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
name|sp
return|;
endif|#
directive|endif
name|phooey
label|:
name|fatal
argument_list|(
literal|"Unimplemented directory operation"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|apply
parameter_list|(
name|type
parameter_list|,
name|arglast
parameter_list|)
name|int
name|type
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|1
index|]
decl_stmt|;
specifier|register
name|int
name|items
init|=
name|arglast
index|[
literal|2
index|]
operator|-
name|sp
decl_stmt|;
specifier|register
name|int
name|val
decl_stmt|;
specifier|register
name|int
name|val2
decl_stmt|;
specifier|register
name|int
name|tot
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|TAINT
for|for
control|(
name|st
operator|+=
operator|++
name|sp
init|;
name|items
operator|--
condition|;
name|st
operator|++
control|)
name|tainted
operator||=
operator|(
operator|*
name|st
operator|)
operator|->
name|str_tainted
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
name|sp
operator|=
name|arglast
index|[
literal|1
index|]
expr_stmt|;
name|items
operator|=
name|arglast
index|[
literal|2
index|]
operator|-
name|sp
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|O_CHMOD
case|:
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in chmod"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|--
name|items
operator|>
literal|0
condition|)
block|{
name|tot
operator|=
name|items
expr_stmt|;
name|val
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|items
operator|--
condition|)
block|{
if|if
condition|(
name|chmod
argument_list|(
name|str_get
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
argument_list|,
name|val
argument_list|)
condition|)
name|tot
operator|--
expr_stmt|;
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|HAS_CHOWN
case|case
name|O_CHOWN
case|:
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in chown"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|items
operator|>
literal|2
condition|)
block|{
name|items
operator|-=
literal|2
expr_stmt|;
name|tot
operator|=
name|items
expr_stmt|;
name|val
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
name|val2
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|items
operator|--
condition|)
block|{
if|if
condition|(
name|chown
argument_list|(
name|str_get
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
argument_list|,
name|val
argument_list|,
name|val2
argument_list|)
condition|)
name|tot
operator|--
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_KILL
case|case
name|O_KILL
case|:
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in kill"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|--
name|items
operator|>
literal|0
condition|)
block|{
name|tot
operator|=
name|items
expr_stmt|;
name|s
operator|=
name|str_get
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|isUPPER
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'S'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'I'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'G'
condition|)
name|s
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|=
name|whichsig
argument_list|(
name|s
argument_list|)
operator|)
condition|)
name|fatal
argument_list|(
literal|"Unrecognized signal name \"%s\""
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|val
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
name|sp
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
name|val
operator|=
operator|-
name|val
expr_stmt|;
while|while
condition|(
name|items
operator|--
condition|)
block|{
name|int
name|proc
init|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_KILLPG
if|if
condition|(
name|killpg
argument_list|(
name|proc
argument_list|,
name|val
argument_list|)
condition|)
comment|/* BSD */
else|#
directive|else
if|if
condition|(
name|kill
argument_list|(
operator|-
name|proc
argument_list|,
name|val
argument_list|)
condition|)
comment|/* SYSV */
endif|#
directive|endif
name|tot
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|items
operator|--
condition|)
block|{
if|if
condition|(
name|kill
argument_list|(
call|(
name|int
call|)
argument_list|(
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
argument_list|)
argument_list|,
name|val
argument_list|)
condition|)
name|tot
operator|--
expr_stmt|;
block|}
block|}
block|}
break|break;
endif|#
directive|endif
case|case
name|O_UNLINK
case|:
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in unlink"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tot
operator|=
name|items
expr_stmt|;
while|while
condition|(
name|items
operator|--
condition|)
block|{
name|s
operator|=
name|str_get
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|euid
operator|||
name|unsafe
condition|)
block|{
if|if
condition|(
name|UNLINK
argument_list|(
name|s
argument_list|)
condition|)
name|tot
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* don't let root wipe out directories without -U */
ifdef|#
directive|ifdef
name|HAS_LSTAT
if|if
condition|(
name|lstat
argument_list|(
name|s
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
operator|||
name|S_ISDIR
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|stat
argument_list|(
name|s
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
operator|||
name|S_ISDIR
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
endif|#
directive|endif
name|tot
operator|--
expr_stmt|;
else|else
block|{
if|if
condition|(
name|UNLINK
argument_list|(
name|s
argument_list|)
condition|)
name|tot
operator|--
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|O_UTIME
case|:
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in utime"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|items
operator|>
literal|2
condition|)
block|{
ifdef|#
directive|ifdef
name|I_UTIME
name|struct
name|utimbuf
name|utbuf
decl_stmt|;
else|#
directive|else
struct|struct
block|{
name|long
name|actime
decl_stmt|;
name|long
name|modtime
decl_stmt|;
block|}
name|utbuf
struct|;
endif|#
directive|endif
name|Zero
argument_list|(
operator|&
name|utbuf
argument_list|,
sizeof|sizeof
name|utbuf
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|utbuf
operator|.
name|actime
operator|=
operator|(
name|long
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
comment|/* time accessed */
name|utbuf
operator|.
name|modtime
operator|=
operator|(
name|long
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
comment|/* time modified */
name|items
operator|-=
literal|2
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|tot
operator|=
name|items
expr_stmt|;
while|while
condition|(
name|items
operator|--
condition|)
block|{
if|if
condition|(
name|utime
argument_list|(
name|str_get
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
argument_list|,
operator|&
name|utbuf
argument_list|)
condition|)
name|tot
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
name|items
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|tot
return|;
block|}
end_function

begin_comment
comment|/* Do the permissions allow some operation?  Assumes statcache already set. */
end_comment

begin_function
name|int
name|cando
parameter_list|(
name|bit
parameter_list|,
name|effective
parameter_list|,
name|statbufp
parameter_list|)
name|int
name|bit
decl_stmt|;
name|int
name|effective
decl_stmt|;
specifier|register
name|struct
name|stat
modifier|*
name|statbufp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DOSISH
comment|/* [Comments and code from Len Reed]      * MS-DOS "user" is similar to UNIX's "superuser," but can't write      * to write-protected files.  The execute permission bit is set      * by the Miscrosoft C library stat() function for the following:      *		.exe files      *		.com files      *		.bat files      *		directories      * All files and directories are readable.      * Directories and special files, e.g. "CON", cannot be      * write-protected.      * [Comment by Tom Dinger -- a directory can have the write-protect      *		bit set in the file system, but DOS permits changes to      *		the directory anyway.  In addition, all bets are off      *		here for networked software, such as Novell and      *		Sun's PC-NFS.]      */
comment|/* Atari stat() does pretty much the same thing. we set x_bit_set_in_stat       * too so it will actually look into the files for magic numbers       */
return|return
operator|(
name|bit
operator|&
name|statbufp
operator|->
name|st_mode
operator|)
condition|?
name|TRUE
else|:
name|FALSE
return|;
else|#
directive|else
comment|/* ! MSDOS */
if|if
condition|(
operator|(
name|effective
condition|?
name|euid
else|:
name|uid
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* root is special */
if|if
condition|(
name|bit
operator|==
name|S_IXUSR
condition|)
block|{
if|if
condition|(
name|statbufp
operator|->
name|st_mode
operator|&
literal|0111
operator|||
name|S_ISDIR
argument_list|(
name|statbufp
operator|->
name|st_mode
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
else|else
return|return
name|TRUE
return|;
comment|/* root reads and writes anything */
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|statbufp
operator|->
name|st_uid
operator|==
operator|(
name|effective
condition|?
name|euid
else|:
name|uid
operator|)
condition|)
block|{
if|if
condition|(
name|statbufp
operator|->
name|st_mode
operator|&
name|bit
condition|)
return|return
name|TRUE
return|;
comment|/* ok as "user" */
block|}
elseif|else
if|if
condition|(
name|ingroup
argument_list|(
operator|(
name|int
operator|)
name|statbufp
operator|->
name|st_gid
argument_list|,
name|effective
argument_list|)
condition|)
block|{
if|if
condition|(
name|statbufp
operator|->
name|st_mode
operator|&
name|bit
operator|>>
literal|3
condition|)
return|return
name|TRUE
return|;
comment|/* ok as "group" */
block|}
elseif|else
if|if
condition|(
name|statbufp
operator|->
name|st_mode
operator|&
name|bit
operator|>>
literal|6
condition|)
return|return
name|TRUE
return|;
comment|/* ok as "other" */
return|return
name|FALSE
return|;
endif|#
directive|endif
comment|/* ! MSDOS */
block|}
end_function

begin_function
name|int
name|ingroup
parameter_list|(
name|testgid
parameter_list|,
name|effective
parameter_list|)
name|int
name|testgid
decl_stmt|;
name|int
name|effective
decl_stmt|;
block|{
if|if
condition|(
name|testgid
operator|==
operator|(
name|effective
condition|?
name|egid
else|:
name|gid
operator|)
condition|)
return|return
name|TRUE
return|;
ifdef|#
directive|ifdef
name|HAS_GETGROUPS
ifndef|#
directive|ifndef
name|NGROUPS
define|#
directive|define
name|NGROUPS
value|32
endif|#
directive|endif
block|{
name|GROUPSTYPE
name|gary
index|[
name|NGROUPS
index|]
decl_stmt|;
name|int
name|anum
decl_stmt|;
name|anum
operator|=
name|getgroups
argument_list|(
name|NGROUPS
argument_list|,
name|gary
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|anum
operator|>=
literal|0
condition|)
if|if
condition|(
name|gary
index|[
name|anum
index|]
operator|==
name|testgid
condition|)
return|return
name|TRUE
return|;
block|}
endif|#
directive|endif
return|return
name|FALSE
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_MSG
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SEM
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SHM
argument_list|)
end_if

begin_function
name|int
name|do_ipcget
parameter_list|(
name|optype
parameter_list|,
name|arglast
parameter_list|)
name|int
name|optype
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|0
index|]
decl_stmt|;
name|key_t
name|key
decl_stmt|;
name|int
name|n
decl_stmt|,
name|flags
decl_stmt|;
name|key
operator|=
operator|(
name|key_t
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|optype
operator|==
name|O_MSGGET
operator|)
condition|?
literal|0
else|:
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
name|flags
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|optype
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_MSG
case|case
name|O_MSGGET
case|:
return|return
name|msgget
argument_list|(
name|key
argument_list|,
name|flags
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_SEM
case|case
name|O_SEMGET
case|:
return|return
name|semget
argument_list|(
name|key
argument_list|,
name|n
argument_list|,
name|flags
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_SHM
case|case
name|O_SHMGET
case|:
return|return
name|shmget
argument_list|(
name|key
argument_list|,
name|n
argument_list|,
name|flags
argument_list|)
return|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_MSG
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAS_SEM
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAS_SHM
argument_list|)
default|default:
name|fatal
argument_list|(
literal|"%s not implemented"
argument_list|,
name|opname
index|[
name|optype
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|-
literal|1
return|;
comment|/* should never happen */
block|}
end_function

begin_function
name|int
name|do_ipcctl
parameter_list|(
name|optype
parameter_list|,
name|arglast
parameter_list|)
name|int
name|optype
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|0
index|]
decl_stmt|;
name|STR
modifier|*
name|astr
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|;
name|int
name|id
decl_stmt|,
name|n
decl_stmt|,
name|cmd
decl_stmt|,
name|infosize
decl_stmt|,
name|getinfo
decl_stmt|,
name|ret
decl_stmt|;
name|id
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|optype
operator|==
name|O_SEMCTL
operator|)
condition|?
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
else|:
literal|0
expr_stmt|;
name|cmd
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
name|astr
operator|=
name|st
index|[
operator|++
name|sp
index|]
expr_stmt|;
name|infosize
operator|=
literal|0
expr_stmt|;
name|getinfo
operator|=
operator|(
name|cmd
operator|==
name|IPC_STAT
operator|)
expr_stmt|;
switch|switch
condition|(
name|optype
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_MSG
case|case
name|O_MSGCTL
case|:
if|if
condition|(
name|cmd
operator|==
name|IPC_STAT
operator|||
name|cmd
operator|==
name|IPC_SET
condition|)
name|infosize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|msqid_ds
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_SHM
case|case
name|O_SHMCTL
case|:
if|if
condition|(
name|cmd
operator|==
name|IPC_STAT
operator|||
name|cmd
operator|==
name|IPC_SET
condition|)
name|infosize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|shmid_ds
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_SEM
case|case
name|O_SEMCTL
case|:
if|if
condition|(
name|cmd
operator|==
name|IPC_STAT
operator|||
name|cmd
operator|==
name|IPC_SET
condition|)
name|infosize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|semid_ds
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|==
name|GETALL
operator|||
name|cmd
operator|==
name|SETALL
condition|)
block|{
name|struct
name|semid_ds
name|semds
decl_stmt|;
if|if
condition|(
name|semctl
argument_list|(
name|id
argument_list|,
literal|0
argument_list|,
name|IPC_STAT
argument_list|,
operator|(
expr|union
name|semun
operator|)
operator|&
name|semds
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|getinfo
operator|=
operator|(
name|cmd
operator|==
name|GETALL
operator|)
expr_stmt|;
name|infosize
operator|=
name|semds
operator|.
name|sem_nsems
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
comment|/* "short" is technically wrong but much more portable 		   than guessing about u_?short(_t)? */
block|}
break|break;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_MSG
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAS_SEM
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAS_SHM
argument_list|)
default|default:
name|fatal
argument_list|(
literal|"%s not implemented"
argument_list|,
name|opname
index|[
name|optype
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|infosize
condition|)
block|{
if|if
condition|(
name|getinfo
condition|)
block|{
name|STR_GROW
argument_list|(
name|astr
argument_list|,
name|infosize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|a
operator|=
name|str_get
argument_list|(
name|astr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|a
operator|=
name|str_get
argument_list|(
name|astr
argument_list|)
expr_stmt|;
if|if
condition|(
name|astr
operator|->
name|str_cur
operator|!=
name|infosize
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
else|else
block|{
name|int
name|i
init|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|astr
argument_list|)
decl_stmt|;
name|a
operator|=
operator|(
name|char
operator|*
operator|)
name|i
expr_stmt|;
comment|/* ouch */
block|}
name|errno
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|optype
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_MSG
case|case
name|O_MSGCTL
case|:
name|ret
operator|=
name|msgctl
argument_list|(
name|id
argument_list|,
name|cmd
argument_list|,
operator|(
expr|struct
name|msqid_ds
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_SEM
case|case
name|O_SEMCTL
case|:
name|ret
operator|=
name|semctl
argument_list|(
name|id
argument_list|,
name|n
argument_list|,
name|cmd
argument_list|,
operator|(
expr|union
name|semun
operator|)
operator|(
operator|(
name|int
operator|)
name|a
operator|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_SHM
case|case
name|O_SHMCTL
case|:
name|ret
operator|=
name|shmctl
argument_list|(
name|id
argument_list|,
name|cmd
argument_list|,
operator|(
expr|struct
name|shmid_ds
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
if|if
condition|(
name|getinfo
operator|&&
name|ret
operator|>=
literal|0
condition|)
block|{
name|astr
operator|->
name|str_cur
operator|=
name|infosize
expr_stmt|;
name|astr
operator|->
name|str_ptr
index|[
name|infosize
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|do_msgsnd
parameter_list|(
name|arglast
parameter_list|)
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAS_MSG
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|0
index|]
decl_stmt|;
name|STR
modifier|*
name|mstr
decl_stmt|;
name|char
modifier|*
name|mbuf
decl_stmt|;
name|int
name|id
decl_stmt|,
name|msize
decl_stmt|,
name|flags
decl_stmt|;
name|id
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
name|mstr
operator|=
name|st
index|[
operator|++
name|sp
index|]
expr_stmt|;
name|flags
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
name|mbuf
operator|=
name|str_get
argument_list|(
name|mstr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msize
operator|=
name|mstr
operator|->
name|str_cur
operator|-
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
return|return
name|msgsnd
argument_list|(
name|id
argument_list|,
operator|(
expr|struct
name|msgbuf
operator|*
operator|)
name|mbuf
argument_list|,
name|msize
argument_list|,
name|flags
argument_list|)
return|;
else|#
directive|else
name|fatal
argument_list|(
literal|"msgsnd not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|do_msgrcv
parameter_list|(
name|arglast
parameter_list|)
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAS_MSG
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|0
index|]
decl_stmt|;
name|STR
modifier|*
name|mstr
decl_stmt|;
name|char
modifier|*
name|mbuf
decl_stmt|;
name|long
name|mtype
decl_stmt|;
name|int
name|id
decl_stmt|,
name|msize
decl_stmt|,
name|flags
decl_stmt|,
name|ret
decl_stmt|;
name|id
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
name|mstr
operator|=
name|st
index|[
operator|++
name|sp
index|]
expr_stmt|;
name|msize
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
name|mtype
operator|=
operator|(
name|long
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
name|flags
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
name|mbuf
operator|=
name|str_get
argument_list|(
name|mstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mstr
operator|->
name|str_cur
operator|<
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|+
name|msize
operator|+
literal|1
condition|)
block|{
name|STR_GROW
argument_list|(
name|mstr
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|+
name|msize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mbuf
operator|=
name|str_get
argument_list|(
name|mstr
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|msgrcv
argument_list|(
name|id
argument_list|,
operator|(
expr|struct
name|msgbuf
operator|*
operator|)
name|mbuf
argument_list|,
name|msize
argument_list|,
name|mtype
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
name|mstr
operator|->
name|str_cur
operator|=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|+
name|ret
expr_stmt|;
name|mstr
operator|->
name|str_ptr
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|+
name|ret
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|ret
return|;
else|#
directive|else
name|fatal
argument_list|(
literal|"msgrcv not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|do_semop
parameter_list|(
name|arglast
parameter_list|)
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAS_SEM
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|0
index|]
decl_stmt|;
name|STR
modifier|*
name|opstr
decl_stmt|;
name|char
modifier|*
name|opbuf
decl_stmt|;
name|int
name|id
decl_stmt|,
name|opsize
decl_stmt|;
name|id
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
name|opstr
operator|=
name|st
index|[
operator|++
name|sp
index|]
expr_stmt|;
name|opbuf
operator|=
name|str_get
argument_list|(
name|opstr
argument_list|)
expr_stmt|;
name|opsize
operator|=
name|opstr
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
name|opsize
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sembuf
argument_list|)
operator|||
operator|(
name|opsize
operator|%
sizeof|sizeof
argument_list|(
expr|struct
name|sembuf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
return|return
name|semop
argument_list|(
name|id
argument_list|,
operator|(
expr|struct
name|sembuf
operator|*
operator|)
name|opbuf
argument_list|,
name|opsize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|sembuf
argument_list|)
argument_list|)
return|;
else|#
directive|else
name|fatal
argument_list|(
literal|"semop not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|do_shmio
parameter_list|(
name|optype
parameter_list|,
name|arglast
parameter_list|)
name|int
name|optype
decl_stmt|;
name|int
modifier|*
name|arglast
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAS_SHM
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
specifier|register
name|int
name|sp
init|=
name|arglast
index|[
literal|0
index|]
decl_stmt|;
name|STR
modifier|*
name|mstr
decl_stmt|;
name|char
modifier|*
name|mbuf
decl_stmt|,
modifier|*
name|shm
decl_stmt|;
name|int
name|id
decl_stmt|,
name|mpos
decl_stmt|,
name|msize
decl_stmt|;
name|struct
name|shmid_ds
name|shmds
decl_stmt|;
ifndef|#
directive|ifndef
name|VOIDSHMAT
specifier|extern
name|char
modifier|*
name|shmat
parameter_list|()
function_decl|;
endif|#
directive|endif
name|id
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
name|mstr
operator|=
name|st
index|[
operator|++
name|sp
index|]
expr_stmt|;
name|mpos
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
name|msize
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
operator|++
name|sp
index|]
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|shmctl
argument_list|(
name|id
argument_list|,
name|IPC_STAT
argument_list|,
operator|&
name|shmds
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|mpos
operator|<
literal|0
operator|||
name|msize
operator|<
literal|0
operator|||
name|mpos
operator|+
name|msize
operator|>
name|shmds
operator|.
name|shm_segsz
condition|)
block|{
name|errno
operator|=
name|EFAULT
expr_stmt|;
comment|/* can't do as caller requested */
return|return
operator|-
literal|1
return|;
block|}
name|shm
operator|=
operator|(
name|char
operator|*
operator|)
name|shmat
argument_list|(
name|id
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|optype
operator|==
name|O_SHMREAD
operator|)
condition|?
name|SHM_RDONLY
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|shm
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
comment|/* I hate System V IPC, I really do */
return|return
operator|-
literal|1
return|;
name|mbuf
operator|=
name|str_get
argument_list|(
name|mstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|optype
operator|==
name|O_SHMREAD
condition|)
block|{
if|if
condition|(
name|mstr
operator|->
name|str_cur
operator|<
name|msize
condition|)
block|{
name|STR_GROW
argument_list|(
name|mstr
argument_list|,
name|msize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mbuf
operator|=
name|str_get
argument_list|(
name|mstr
argument_list|)
expr_stmt|;
block|}
name|Copy
argument_list|(
name|shm
operator|+
name|mpos
argument_list|,
name|mbuf
argument_list|,
name|msize
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|mstr
operator|->
name|str_cur
operator|=
name|msize
expr_stmt|;
name|mstr
operator|->
name|str_ptr
index|[
name|msize
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|mstr
operator|->
name|str_cur
operator|)
operator|>
name|msize
condition|)
name|n
operator|=
name|msize
expr_stmt|;
name|Copy
argument_list|(
name|mbuf
argument_list|,
name|shm
operator|+
name|mpos
argument_list|,
name|n
argument_list|,
name|char
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|msize
condition|)
name|memzero
argument_list|(
name|shm
operator|+
name|mpos
operator|+
name|n
argument_list|,
name|msize
operator|-
name|n
argument_list|)
expr_stmt|;
block|}
return|return
name|shmdt
argument_list|(
name|shm
argument_list|)
return|;
else|#
directive|else
name|fatal
argument_list|(
literal|"shm I/O not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYSV IPC */
end_comment

end_unit

