begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* NOTE: this is derived from Henry Spencer's regexp code, and should not  * confused with the original package (see point 3 below).  Thanks, Henry!  */
end_comment

begin_comment
comment|/* Additional note: this code is very heavily munged from Henry's version  * in places.  In some spots I've traded clarity for efficiency, so don't  * blame Henry for some of the lack of readability.  */
end_comment

begin_comment
comment|/* $RCSfile: regexec.c,v $$Revision: 1.2 $$Date: 1995/05/30 05:03:16 $  *  * $Log: regexec.c,v $  * Revision 1.2  1995/05/30 05:03:16  rgrimes  * Remove trailing whitespace.  *  * Revision 1.1.1.1  1994/09/10  06:27:33  gclarkii  * Initial import of Perl 4.046 bmaked  *  * Revision 1.1.1.1  1993/08/23  21:29:39  nate  * PERL!  *  * Revision 4.0.1.4  92/06/08  15:25:50  lwall  * patch20: pattern modifiers i and g didn't interact right  * patch20: in some cases $` and $' didn't get set by match  * patch20: /x{0}/ was wrongly interpreted as /x{0,}/  *  * Revision 4.0.1.3  91/11/05  18:23:55  lwall  * patch11: prepared for ctype implementations that don't define isascii()  * patch11: initial .* in pattern had dependency on value of $*  *  * Revision 4.0.1.2  91/06/07  11:50:33  lwall  * patch4: new copyright notice  * patch4: // wouldn't use previous pattern if it started with a null character  *  * Revision 4.0.1.1  91/04/12  09:07:39  lwall  * patch1: regexec only allocated space for 9 subexpresssions  *  * Revision 4.0  91/03/20  01:39:16  lwall  * 4.0 baseline.  *  */
end_comment

begin_comment
comment|/*SUPPRESS 112*/
end_comment

begin_comment
comment|/*  * regcomp and regexec -- regsub and regerror are not used in perl  *  *	Copyright (c) 1986 by University of Toronto.  *	Written by Henry Spencer.  Not derived from licensed software.  *  *	Permission is granted to anyone to use this software for any  *	purpose on any computer system, and to redistribute it freely,  *	subject to the following restrictions:  *  *	1. The author is not responsible for the consequences of use of  *		this software, no matter how awful, even if they arise  *		from defects in it.  *  *	2. The origin of this software must not be misrepresented, either  *		by explicit claim or by omission.  *  *	3. Altered versions must be plainly marked as such, and must not  *		be misrepresented as being the original software.  *  ****    Alterations to Henry's code are...  ****  ****    Copyright (c) 1991, Larry Wall  ****  ****    You may distribute under the terms of either the GNU General Public  ****    License or the Artistic License, as specified in the README file.  *  * Beware that some of this code is subtly aware of the way operator  * precedence is structured in regular expressions.  Serious changes in  * regular-expression syntax might require a total rethink.  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_include
include|#
directive|include
file|"regcomp.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|STATIC
end_ifndef

begin_define
define|#
directive|define
name|STATIC
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING
end_ifdef

begin_decl_stmt
name|int
name|regnarrate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * regexec and friends  */
end_comment

begin_comment
comment|/*  * Global work variables for regexec().  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|regprecomp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reginput
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String-input pointer. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|regprev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* char before regbol, \n if none */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|regbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Beginning of input, for ^ check. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|regeol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* End of input, for $ check. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|regstartp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to startp array. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|regendp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ditto for endp. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reglastparen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similarly for lastparen. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|regtill
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|regmyp_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|regmystartp
init|=
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|regmyendp
init|=
name|Null
argument_list|(
name|char
operator|*
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Forwards.  */
end_comment

begin_function_decl
name|STATIC
name|int
name|regtry
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|regmatch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|regrepeat
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|multiline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  - regexec - match a regexp against a string  */
end_comment

begin_function
name|int
name|regexec
parameter_list|(
name|prog
parameter_list|,
name|stringarg
parameter_list|,
name|strend
parameter_list|,
name|strbeg
parameter_list|,
name|minend
parameter_list|,
name|screamer
parameter_list|,
name|safebase
parameter_list|)
specifier|register
name|regexp
modifier|*
name|prog
decl_stmt|;
name|char
modifier|*
name|stringarg
decl_stmt|;
specifier|register
name|char
modifier|*
name|strend
decl_stmt|;
comment|/* pointer to null at end of string */
name|char
modifier|*
name|strbeg
decl_stmt|;
comment|/* real beginning of string */
name|int
name|minend
decl_stmt|;
comment|/* end of match must be at least minend after stringarg */
name|STR
modifier|*
name|screamer
decl_stmt|;
name|int
name|safebase
decl_stmt|;
comment|/* no need to remember string in subbase */
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|string
init|=
name|stringarg
decl_stmt|;
specifier|register
name|int
name|tmp
decl_stmt|;
name|int
name|minlen
init|=
literal|0
decl_stmt|;
comment|/* must match at least this many chars */
name|int
name|dontbother
init|=
literal|0
decl_stmt|;
comment|/* how many characters not to try at end */
comment|/* Be paranoid... */
if|if
condition|(
name|prog
operator|==
name|NULL
operator|||
name|string
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"NULL regexp parameter"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|string
operator|==
name|strbeg
condition|)
comment|/* is ^ valid at stringarg? */
name|regprev
operator|=
literal|'\n'
expr_stmt|;
else|else
block|{
name|regprev
operator|=
name|stringarg
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|multiline
operator|&&
name|regprev
operator|==
literal|'\n'
condition|)
name|regprev
operator|=
literal|'\0'
expr_stmt|;
comment|/* force ^ to NOT match */
block|}
name|regprecomp
operator|=
name|prog
operator|->
name|precomp
expr_stmt|;
comment|/* Check validity of program. */
if|if
condition|(
name|UCHARAT
argument_list|(
name|prog
operator|->
name|program
argument_list|)
operator|!=
name|MAGIC
condition|)
block|{
name|FAIL
argument_list|(
literal|"corrupted regexp program"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prog
operator|->
name|do_folding
condition|)
block|{
name|i
operator|=
name|strend
operator|-
name|string
expr_stmt|;
name|New
argument_list|(
literal|1101
argument_list|,
name|c
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|string
argument_list|,
name|c
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|string
operator|=
name|c
expr_stmt|;
name|strend
operator|=
name|string
operator|+
name|i
expr_stmt|;
for|for
control|(
name|s
operator|=
name|string
init|;
name|s
operator|<
name|strend
condition|;
name|s
operator|++
control|)
if|if
condition|(
name|isUPPER
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|s
operator|=
name|tolower
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* If there is a "must appear" string, look for it. */
name|s
operator|=
name|string
expr_stmt|;
if|if
condition|(
name|prog
operator|->
name|regmust
operator|!=
name|Nullstr
operator|&&
operator|(
operator|!
operator|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_ANCH
operator|)
operator|||
operator|(
name|multiline
operator|&&
name|prog
operator|->
name|regback
operator|>=
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|stringarg
operator|==
name|strbeg
operator|&&
name|screamer
condition|)
block|{
if|if
condition|(
name|screamfirst
index|[
name|prog
operator|->
name|regmust
operator|->
name|str_rare
index|]
operator|>=
literal|0
condition|)
name|s
operator|=
name|screaminstr
argument_list|(
name|screamer
argument_list|,
name|prog
operator|->
name|regmust
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
name|Nullch
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|lint
else|else
name|s
operator|=
name|fbminstr
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|strend
argument_list|,
name|prog
operator|->
name|regmust
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|s
condition|)
block|{
operator|++
name|prog
operator|->
name|regmust
operator|->
name|str_u
operator|.
name|str_useful
expr_stmt|;
comment|/* hooray */
goto|goto
name|phooey
goto|;
comment|/* not present */
block|}
elseif|else
if|if
condition|(
name|prog
operator|->
name|regback
operator|>=
literal|0
condition|)
block|{
name|s
operator|-=
name|prog
operator|->
name|regback
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|string
condition|)
name|s
operator|=
name|string
expr_stmt|;
name|minlen
operator|=
name|prog
operator|->
name|regback
operator|+
name|prog
operator|->
name|regmust
operator|->
name|str_cur
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|--
name|prog
operator|->
name|regmust
operator|->
name|str_u
operator|.
name|str_useful
operator|<
literal|0
condition|)
block|{
comment|/* boo */
name|str_free
argument_list|(
name|prog
operator|->
name|regmust
argument_list|)
expr_stmt|;
name|prog
operator|->
name|regmust
operator|=
name|Nullstr
expr_stmt|;
comment|/* disable regmust */
name|s
operator|=
name|string
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|string
expr_stmt|;
name|minlen
operator|=
name|prog
operator|->
name|regmust
operator|->
name|str_cur
expr_stmt|;
block|}
block|}
comment|/* Mark beginning of line for ^ . */
name|regbol
operator|=
name|string
expr_stmt|;
comment|/* Mark end of line for $ (and such) */
name|regeol
operator|=
name|strend
expr_stmt|;
comment|/* see how far we have to get to not match where we matched before */
name|regtill
operator|=
name|string
operator|+
name|minend
expr_stmt|;
comment|/* Allocate our backreference arrays */
if|if
condition|(
name|regmyp_size
operator|<
name|prog
operator|->
name|nparens
operator|+
literal|1
condition|)
block|{
comment|/* Allocate or enlarge the arrays */
name|regmyp_size
operator|=
name|prog
operator|->
name|nparens
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|regmyp_size
operator|<
literal|10
condition|)
name|regmyp_size
operator|=
literal|10
expr_stmt|;
comment|/* minimum */
if|if
condition|(
name|regmystartp
condition|)
block|{
comment|/* reallocate larger */
name|Renew
argument_list|(
name|regmystartp
argument_list|,
name|regmyp_size
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|Renew
argument_list|(
name|regmyendp
argument_list|,
name|regmyp_size
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Initial allocation */
name|New
argument_list|(
literal|1102
argument_list|,
name|regmystartp
argument_list|,
name|regmyp_size
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|1102
argument_list|,
name|regmyendp
argument_list|,
name|regmyp_size
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Simplest case:  anchored match need be tried only once. */
comment|/*  [unless multiline is set] */
if|if
condition|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_ANCH
condition|)
block|{
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|string
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
elseif|else
if|if
condition|(
name|multiline
operator|||
operator|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_IMPLICIT
operator|)
condition|)
block|{
if|if
condition|(
name|minlen
condition|)
name|dontbother
operator|=
name|minlen
operator|-
literal|1
expr_stmt|;
name|strend
operator|-=
name|dontbother
expr_stmt|;
comment|/* for multiline we only have to try after newlines */
if|if
condition|(
name|s
operator|>
name|string
condition|)
name|s
operator|--
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|s
operator|<
name|strend
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
block|}
block|}
block|}
goto|goto
name|phooey
goto|;
block|}
comment|/* Messy cases:  unanchored match. */
if|if
condition|(
name|prog
operator|->
name|regstart
condition|)
block|{
if|if
condition|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_SKIP
condition|)
block|{
comment|/* we have /x+whatever/ */
comment|/* it must be a one character string */
name|i
operator|=
name|prog
operator|->
name|regstart
operator|->
name|str_ptr
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
name|i
condition|)
block|{
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
operator|&&
operator|*
name|s
operator|==
name|i
condition|)
name|s
operator|++
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|prog
operator|->
name|regstart
operator|->
name|str_pok
operator|==
literal|3
condition|)
block|{
comment|/* We know what string it must start with. */
ifndef|#
directive|ifndef
name|lint
while|while
condition|(
operator|(
name|s
operator|=
name|fbminstr
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|strend
argument_list|,
name|prog
operator|->
name|regstart
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
else|#
directive|else
while|while
condition|(
name|s
operator|=
name|Nullch
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
name|s
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|c
operator|=
name|prog
operator|->
name|regstart
operator|->
name|str_ptr
expr_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|ninstr
argument_list|(
name|s
argument_list|,
name|strend
argument_list|,
name|c
argument_list|,
name|c
operator|+
name|prog
operator|->
name|regstart
operator|->
name|str_cur
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
name|s
operator|++
expr_stmt|;
block|}
block|}
goto|goto
name|phooey
goto|;
block|}
comment|/*SUPPRESS 560*/
if|if
condition|(
name|c
operator|=
name|prog
operator|->
name|regstclass
condition|)
block|{
name|int
name|doevery
init|=
operator|(
name|prog
operator|->
name|reganch
operator|&
name|ROPT_SKIP
operator|)
operator|==
literal|0
decl_stmt|;
if|if
condition|(
name|minlen
condition|)
name|dontbother
operator|=
name|minlen
operator|-
literal|1
expr_stmt|;
name|strend
operator|-=
name|dontbother
expr_stmt|;
comment|/* don't bother with what can't match */
name|tmp
operator|=
literal|1
expr_stmt|;
comment|/* We know what class it must start with. */
switch|switch
condition|(
name|OP
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
name|ANYOF
case|:
name|c
operator|=
name|OPERAND
argument_list|(
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
name|i
operator|=
name|UCHARAT
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
index|[
name|i
operator|>>
literal|3
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|&
literal|7
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|BOUND
case|:
if|if
condition|(
name|minlen
condition|)
name|dontbother
operator|++
operator|,
name|strend
operator|--
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|string
condition|)
block|{
name|i
operator|=
name|s
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|tmp
operator|=
name|isALNUM
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|tmp
operator|=
name|isALNUM
argument_list|(
name|regprev
argument_list|)
expr_stmt|;
comment|/* assume not alphanumeric */
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
name|i
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|isALNUM
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|tmp
operator|=
operator|!
name|tmp
expr_stmt|;
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
block|}
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|minlen
operator|||
name|tmp
operator|)
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
break|break;
case|case
name|NBOUND
case|:
if|if
condition|(
name|minlen
condition|)
name|dontbother
operator|++
operator|,
name|strend
operator|--
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|string
condition|)
block|{
name|i
operator|=
name|s
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|tmp
operator|=
name|isALNUM
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|tmp
operator|=
name|isALNUM
argument_list|(
name|regprev
argument_list|)
expr_stmt|;
comment|/* assume not alphanumeric */
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
name|i
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|isALNUM
argument_list|(
name|i
argument_list|)
condition|)
name|tmp
operator|=
operator|!
name|tmp
expr_stmt|;
elseif|else
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|minlen
operator|||
operator|!
name|tmp
operator|)
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
break|break;
case|case
name|ALNUM
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
name|i
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|isALNUM
argument_list|(
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|NALNUM
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
name|i
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|isALNUM
argument_list|(
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|SPACE
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|NSPACE
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|!
name|isSPACE
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|DIGIT
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|NDIGIT
case|:
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
if|if
condition|(
operator|!
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
name|tmp
operator|&&
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
else|else
name|tmp
operator|=
name|doevery
expr_stmt|;
block|}
else|else
name|tmp
operator|=
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|minlen
condition|)
name|dontbother
operator|=
name|minlen
operator|-
literal|1
expr_stmt|;
name|strend
operator|-=
name|dontbother
expr_stmt|;
comment|/* We don't know much -- general case. */
do|do
block|{
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
goto|goto
name|got_it
goto|;
block|}
do|while
condition|(
name|s
operator|++
operator|<
name|strend
condition|)
do|;
block|}
comment|/* Failure. */
goto|goto
name|phooey
goto|;
name|got_it
label|:
name|prog
operator|->
name|subbeg
operator|=
name|strbeg
expr_stmt|;
name|prog
operator|->
name|subend
operator|=
name|strend
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|safebase
operator|&&
operator|(
name|prog
operator|->
name|nparens
operator|||
name|sawampersand
operator|)
operator|)
operator|||
name|prog
operator|->
name|do_folding
condition|)
block|{
name|strend
operator|+=
name|dontbother
expr_stmt|;
comment|/* uncheat */
if|if
condition|(
name|safebase
condition|)
comment|/* no need for $digit later */
name|s
operator|=
name|strbeg
expr_stmt|;
elseif|else
if|if
condition|(
name|strbeg
operator|!=
name|prog
operator|->
name|subbase
condition|)
block|{
name|i
operator|=
name|strend
operator|-
name|string
operator|+
operator|(
name|stringarg
operator|-
name|strbeg
operator|)
expr_stmt|;
name|s
operator|=
name|nsavestr
argument_list|(
name|strbeg
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* so $digit will work later */
if|if
condition|(
name|prog
operator|->
name|subbase
condition|)
name|Safefree
argument_list|(
name|prog
operator|->
name|subbase
argument_list|)
expr_stmt|;
name|prog
operator|->
name|subbeg
operator|=
name|prog
operator|->
name|subbase
operator|=
name|s
expr_stmt|;
name|prog
operator|->
name|subend
operator|=
name|s
operator|+
name|i
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|strend
operator|-
name|string
operator|+
operator|(
name|stringarg
operator|-
name|strbeg
operator|)
expr_stmt|;
name|prog
operator|->
name|subbeg
operator|=
name|s
operator|=
name|prog
operator|->
name|subbase
expr_stmt|;
name|prog
operator|->
name|subend
operator|=
name|s
operator|+
name|i
expr_stmt|;
block|}
name|s
operator|+=
operator|(
name|stringarg
operator|-
name|strbeg
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|prog
operator|->
name|nparens
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|prog
operator|->
name|endp
index|[
name|i
index|]
condition|)
block|{
name|prog
operator|->
name|startp
index|[
name|i
index|]
operator|=
name|s
operator|+
operator|(
name|prog
operator|->
name|startp
index|[
name|i
index|]
operator|-
name|string
operator|)
expr_stmt|;
name|prog
operator|->
name|endp
index|[
name|i
index|]
operator|=
name|s
operator|+
operator|(
name|prog
operator|->
name|endp
index|[
name|i
index|]
operator|-
name|string
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|prog
operator|->
name|do_folding
condition|)
name|Safefree
argument_list|(
name|string
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
name|phooey
label|:
if|if
condition|(
name|prog
operator|->
name|do_folding
condition|)
name|Safefree
argument_list|(
name|string
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regtry - try match at specific point  */
end_comment

begin_function
specifier|static
name|int
comment|/* 0 failure, 1 success */
name|regtry
parameter_list|(
name|prog
parameter_list|,
name|string
parameter_list|)
name|regexp
modifier|*
name|prog
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|sp
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|ep
decl_stmt|;
name|reginput
operator|=
name|string
expr_stmt|;
name|regstartp
operator|=
name|prog
operator|->
name|startp
expr_stmt|;
name|regendp
operator|=
name|prog
operator|->
name|endp
expr_stmt|;
name|reglastparen
operator|=
operator|&
name|prog
operator|->
name|lastparen
expr_stmt|;
name|prog
operator|->
name|lastparen
operator|=
literal|0
expr_stmt|;
name|sp
operator|=
name|prog
operator|->
name|startp
expr_stmt|;
name|ep
operator|=
name|prog
operator|->
name|endp
expr_stmt|;
if|if
condition|(
name|prog
operator|->
name|nparens
condition|)
block|{
for|for
control|(
name|i
operator|=
name|prog
operator|->
name|nparens
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
operator|*
name|sp
operator|++
operator|=
name|NULL
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|regmatch
argument_list|(
name|prog
operator|->
name|program
operator|+
literal|1
argument_list|)
operator|&&
name|reginput
operator|>=
name|regtill
condition|)
block|{
name|prog
operator|->
name|startp
index|[
literal|0
index|]
operator|=
name|string
expr_stmt|;
name|prog
operator|->
name|endp
index|[
literal|0
index|]
operator|=
name|reginput
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regmatch - main matching routine  *  * Conceptually the strategy is simple:  check to see whether the current  * node matches, call self recursively to see whether the rest matches,  * and then act accordingly.  In practice we make some effort to avoid  * recursion, in particular by going through "ordinary" nodes (that don't  * need to know whether the rest of the match failed) by a loop instead of  * by recursion.  */
end_comment

begin_comment
comment|/* [lwall] I've hoisted the register declarations to the outer block in order to  * maybe save a little bit of pushing and popping on the stack.  It also takes  * advantage of machines that use a register save mask on subroutine entry.  */
end_comment

begin_function
specifier|static
name|int
comment|/* 0 failure, 1 success */
name|regmatch
parameter_list|(
name|prog
parameter_list|)
name|char
modifier|*
name|prog
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|scan
decl_stmt|;
comment|/* Current node. */
name|char
modifier|*
name|next
decl_stmt|;
comment|/* Next node. */
specifier|register
name|int
name|nextchar
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
comment|/* no or next */
specifier|register
name|int
name|ln
decl_stmt|;
comment|/* len or last */
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
comment|/* operand or save */
specifier|register
name|char
modifier|*
name|locinput
init|=
name|reginput
decl_stmt|;
name|nextchar
operator|=
operator|*
name|locinput
expr_stmt|;
name|scan
operator|=
name|prog
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|scan
operator|!=
name|NULL
operator|&&
name|regnarrate
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s(\n"
argument_list|,
name|regprop
argument_list|(
name|scan
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|scan
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|regnarrate
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s...\n"
argument_list|,
name|regprop
argument_list|(
name|scan
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|REGALIGN
name|next
operator|=
name|scan
operator|+
name|NEXT
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|scan
condition|)
name|next
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
name|next
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
condition|)
block|{
case|case
name|BOL
case|:
if|if
condition|(
name|locinput
operator|==
name|regbol
condition|?
name|regprev
operator|==
literal|'\n'
else|:
operator|(
operator|(
name|nextchar
operator|||
name|locinput
operator|<
name|regeol
operator|)
operator|&&
name|locinput
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
comment|/* regtill = regbol; */
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|EOL
case|:
if|if
condition|(
operator|(
name|nextchar
operator|||
name|locinput
operator|<
name|regeol
operator|)
operator|&&
name|nextchar
operator|!=
literal|'\n'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|multiline
operator|&&
name|regeol
operator|-
name|locinput
operator|>
literal|1
condition|)
return|return
literal|0
return|;
comment|/* regtill = regbol; */
break|break;
case|case
name|ANY
case|:
if|if
condition|(
operator|(
name|nextchar
operator|==
literal|'\0'
operator|&&
name|locinput
operator|>=
name|regeol
operator|)
operator|||
name|nextchar
operator|==
literal|'\n'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nextchar
operator|=
operator|*
operator|++
name|locinput
expr_stmt|;
break|break;
case|case
name|EXACTLY
case|:
name|s
operator|=
name|OPERAND
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|ln
operator|=
operator|*
name|s
operator|++
expr_stmt|;
comment|/* Inline the first character, for speed. */
if|if
condition|(
operator|*
name|s
operator|!=
name|nextchar
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|regeol
operator|-
name|locinput
operator|<
name|ln
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ln
operator|>
literal|1
operator|&&
name|bcmp
argument_list|(
name|s
argument_list|,
name|locinput
argument_list|,
name|ln
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|locinput
operator|+=
name|ln
expr_stmt|;
name|nextchar
operator|=
operator|*
name|locinput
expr_stmt|;
break|break;
case|case
name|ANYOF
case|:
name|s
operator|=
name|OPERAND
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextchar
operator|<
literal|0
condition|)
name|nextchar
operator|=
name|UCHARAT
argument_list|(
name|locinput
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
name|nextchar
operator|>>
literal|3
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|nextchar
operator|&
literal|7
operator|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|nextchar
operator|&&
name|locinput
operator|>=
name|regeol
condition|)
return|return
literal|0
return|;
name|nextchar
operator|=
operator|*
operator|++
name|locinput
expr_stmt|;
break|break;
case|case
name|ALNUM
case|:
if|if
condition|(
operator|!
name|nextchar
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|isALNUM
argument_list|(
name|nextchar
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nextchar
operator|=
operator|*
operator|++
name|locinput
expr_stmt|;
break|break;
case|case
name|NALNUM
case|:
if|if
condition|(
operator|!
name|nextchar
operator|&&
name|locinput
operator|>=
name|regeol
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|isALNUM
argument_list|(
name|nextchar
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nextchar
operator|=
operator|*
operator|++
name|locinput
expr_stmt|;
break|break;
case|case
name|NBOUND
case|:
case|case
name|BOUND
case|:
if|if
condition|(
name|locinput
operator|==
name|regbol
condition|)
comment|/* was last char in word? */
name|ln
operator|=
name|isALNUM
argument_list|(
name|regprev
argument_list|)
expr_stmt|;
else|else
name|ln
operator|=
name|isALNUM
argument_list|(
name|locinput
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|n
operator|=
name|isALNUM
argument_list|(
name|nextchar
argument_list|)
expr_stmt|;
comment|/* is next char in word? */
if|if
condition|(
operator|(
name|ln
operator|==
name|n
operator|)
operator|==
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|BOUND
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|SPACE
case|:
if|if
condition|(
operator|!
name|nextchar
operator|&&
name|locinput
operator|>=
name|regeol
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|isSPACE
argument_list|(
name|nextchar
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nextchar
operator|=
operator|*
operator|++
name|locinput
expr_stmt|;
break|break;
case|case
name|NSPACE
case|:
if|if
condition|(
operator|!
name|nextchar
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|isSPACE
argument_list|(
name|nextchar
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nextchar
operator|=
operator|*
operator|++
name|locinput
expr_stmt|;
break|break;
case|case
name|DIGIT
case|:
if|if
condition|(
operator|!
name|isDIGIT
argument_list|(
name|nextchar
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nextchar
operator|=
operator|*
operator|++
name|locinput
expr_stmt|;
break|break;
case|case
name|NDIGIT
case|:
if|if
condition|(
operator|!
name|nextchar
operator|&&
name|locinput
operator|>=
name|regeol
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|isDIGIT
argument_list|(
name|nextchar
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nextchar
operator|=
operator|*
operator|++
name|locinput
expr_stmt|;
break|break;
case|case
name|REF
case|:
name|n
operator|=
name|ARG1
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* which paren pair */
name|s
operator|=
name|regmystartp
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|regmyendp
index|[
name|n
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|s
operator|==
name|regmyendp
index|[
name|n
index|]
condition|)
break|break;
comment|/* Inline the first character, for speed. */
if|if
condition|(
operator|*
name|s
operator|!=
name|nextchar
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ln
operator|=
name|regmyendp
index|[
name|n
index|]
operator|-
name|s
expr_stmt|;
if|if
condition|(
name|locinput
operator|+
name|ln
operator|>
name|regeol
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ln
operator|>
literal|1
operator|&&
name|bcmp
argument_list|(
name|s
argument_list|,
name|locinput
argument_list|,
name|ln
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|locinput
operator|+=
name|ln
expr_stmt|;
name|nextchar
operator|=
operator|*
name|locinput
expr_stmt|;
break|break;
case|case
name|NOTHING
case|:
break|break;
case|case
name|BACK
case|:
break|break;
case|case
name|OPEN
case|:
name|n
operator|=
name|ARG1
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* which paren pair */
name|reginput
operator|=
name|locinput
expr_stmt|;
name|regmystartp
index|[
name|n
index|]
operator|=
name|locinput
expr_stmt|;
comment|/* for REF */
if|if
condition|(
name|regmatch
argument_list|(
name|next
argument_list|)
condition|)
block|{
comment|/* 				 * Don't set startp if some later 				 * invocation of the same parentheses 				 * already has. 				 */
if|if
condition|(
name|regstartp
index|[
name|n
index|]
operator|==
name|NULL
condition|)
name|regstartp
index|[
name|n
index|]
operator|=
name|locinput
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
comment|/* NOTREACHED */
case|case
name|CLOSE
case|:
block|{
name|n
operator|=
name|ARG1
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* which paren pair */
name|reginput
operator|=
name|locinput
expr_stmt|;
name|regmyendp
index|[
name|n
index|]
operator|=
name|locinput
expr_stmt|;
comment|/* for REF */
if|if
condition|(
name|regmatch
argument_list|(
name|next
argument_list|)
condition|)
block|{
comment|/* 					 * Don't set endp if some later 					 * invocation of the same parentheses 					 * already has. 					 */
if|if
condition|(
name|regendp
index|[
name|n
index|]
operator|==
name|NULL
condition|)
block|{
name|regendp
index|[
name|n
index|]
operator|=
name|locinput
expr_stmt|;
if|if
condition|(
name|n
operator|>
operator|*
name|reglastparen
condition|)
operator|*
name|reglastparen
operator|=
name|n
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*NOTREACHED*/
case|case
name|BRANCH
case|:
block|{
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|!=
name|BRANCH
condition|)
comment|/* No choice. */
name|next
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* Avoid recursion. */
else|else
block|{
do|do
block|{
name|reginput
operator|=
name|locinput
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|REGALIGN
comment|/*SUPPRESS 560*/
if|if
condition|(
name|n
operator|=
name|NEXT
argument_list|(
name|scan
argument_list|)
condition|)
name|scan
operator|+=
name|n
expr_stmt|;
else|else
name|scan
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
name|scan
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
do|while
condition|(
name|scan
operator|!=
name|NULL
operator|&&
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|BRANCH
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* NOTREACHED */
block|}
block|}
break|break;
case|case
name|CURLY
case|:
name|ln
operator|=
name|ARG1
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* min to match */
name|n
operator|=
name|ARG2
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* max to match */
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
operator|+
literal|4
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|STAR
case|:
name|ln
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|32767
expr_stmt|;
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
case|case
name|PLUS
case|:
comment|/* 			 * Lookahead to avoid useless match attempts 			 * when we know what character comes next. 			 */
name|ln
operator|=
literal|1
expr_stmt|;
name|n
operator|=
literal|32767
expr_stmt|;
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|repeat
label|:
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|EXACTLY
condition|)
name|nextchar
operator|=
operator|*
operator|(
name|OPERAND
argument_list|(
name|next
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
else|else
name|nextchar
operator|=
operator|-
literal|1000
expr_stmt|;
name|reginput
operator|=
name|locinput
expr_stmt|;
name|n
operator|=
name|regrepeat
argument_list|(
name|scan
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|multiline
operator|&&
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|EOL
operator|&&
name|ln
operator|<
name|n
condition|)
name|ln
operator|=
name|n
expr_stmt|;
comment|/* why back off? */
while|while
condition|(
name|n
operator|>=
name|ln
condition|)
block|{
comment|/* If it could work, try it. */
if|if
condition|(
name|nextchar
operator|==
operator|-
literal|1000
operator|||
operator|*
name|reginput
operator|==
name|nextchar
condition|)
if|if
condition|(
name|regmatch
argument_list|(
name|next
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Couldn't or didn't -- back up. */
name|n
operator|--
expr_stmt|;
name|reginput
operator|=
name|locinput
operator|+
name|n
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|END
case|:
name|reginput
operator|=
name|locinput
expr_stmt|;
comment|/* put where regtry can find it */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Success! */
default|default:
name|printf
argument_list|(
literal|"%x %d\n"
argument_list|,
name|scan
argument_list|,
name|scan
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|FAIL
argument_list|(
literal|"regexp memory corruption"
argument_list|)
expr_stmt|;
block|}
name|scan
operator|=
name|next
expr_stmt|;
block|}
comment|/* 	 * We get here only if there's trouble -- normally "case END" is 	 * the terminating point. 	 */
name|FAIL
argument_list|(
literal|"corrupted regexp pointers"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
ifdef|#
directive|ifdef
name|lint
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  - regrepeat - repeatedly match something simple, report how many  */
end_comment

begin_comment
comment|/*  * [This routine now assumes that it will only match on things of length 1.  * That was true before, but now we assume scan - reginput is the count,  * rather than incrementing count on every character.]  */
end_comment

begin_function
specifier|static
name|int
name|regrepeat
parameter_list|(
name|p
parameter_list|,
name|max
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|max
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|scan
decl_stmt|;
specifier|register
name|char
modifier|*
name|opnd
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|loceol
init|=
name|regeol
decl_stmt|;
name|scan
operator|=
name|reginput
expr_stmt|;
if|if
condition|(
name|max
operator|!=
literal|32767
operator|&&
name|max
operator|<
name|loceol
operator|-
name|scan
condition|)
name|loceol
operator|=
name|scan
operator|+
name|max
expr_stmt|;
name|opnd
operator|=
name|OPERAND
argument_list|(
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|OP
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|ANY
case|:
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|*
name|scan
operator|!=
literal|'\n'
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|EXACTLY
case|:
comment|/* length of string is 1 */
name|opnd
operator|++
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|*
name|opnd
operator|==
operator|*
name|scan
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|ANYOF
case|:
name|c
operator|=
name|UCHARAT
argument_list|(
name|scan
argument_list|)
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|!
operator|(
name|opnd
index|[
name|c
operator|>>
literal|3
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|7
operator|)
operator|)
operator|)
condition|)
block|{
name|scan
operator|++
expr_stmt|;
name|c
operator|=
name|UCHARAT
argument_list|(
name|scan
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ALNUM
case|:
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
name|isALNUM
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|NALNUM
case|:
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|!
name|isALNUM
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|SPACE
case|:
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
name|isSPACE
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|NSPACE
case|:
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|!
name|isSPACE
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|DIGIT
case|:
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
name|isDIGIT
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|NDIGIT
case|:
while|while
condition|(
name|scan
operator|<
name|loceol
operator|&&
operator|!
name|isDIGIT
argument_list|(
operator|*
name|scan
argument_list|)
condition|)
name|scan
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* Oh dear.  Called inappropriately. */
name|FAIL
argument_list|(
literal|"internal regexp foulup"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|c
operator|=
name|scan
operator|-
name|reginput
expr_stmt|;
name|reginput
operator|=
name|scan
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regnext - dig the "next" pointer out of a node  *  * [Note, when REGALIGN is defined there are two places in regmatch()  * that bypass this code for speed.]  */
end_comment

begin_function
name|char
modifier|*
name|regnext
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|p
operator|==
operator|&
name|regdummy
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|offset
operator|=
name|NEXT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
ifdef|#
directive|ifdef
name|REGALIGN
return|return
operator|(
name|p
operator|+
name|offset
operator|)
return|;
else|#
directive|else
if|if
condition|(
name|OP
argument_list|(
name|p
argument_list|)
operator|==
name|BACK
condition|)
return|return
operator|(
name|p
operator|-
name|offset
operator|)
return|;
else|else
return|return
operator|(
name|p
operator|+
name|offset
operator|)
return|;
endif|#
directive|endif
block|}
end_function

end_unit

