begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $RCSfile: form.c,v $$Revision: 1.2 $$Date: 1995/05/30 05:03:04 $  *  *    Copyright (c) 1991, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  * $Log: form.c,v $  * Revision 1.2  1995/05/30 05:03:04  rgrimes  * Remove trailing whitespace.  *  * Revision 1.1.1.1  1994/09/10  06:27:33  gclarkii  * Initial import of Perl 4.046 bmaked  *  * Revision 1.1.1.1  1993/08/23  21:29:36  nate  * PERL!  *  * Revision 4.0.1.4  1993/02/05  19:34:32  lwall  * patch36: formats now ignore literal text for ~~ loop determination  *  * Revision 4.0.1.3  92/06/08  13:21:42  lwall  * patch20: removed implicit int declarations on funcions  * patch20: form feed for formats is now specifiable via $^L  * patch20: Perl now distinguishes overlapped copies from non-overlapped  *  * Revision 4.0.1.2  91/11/05  17:18:43  lwall  * patch11: formats didn't fill their fields as well as they could  * patch11: ^ fields chopped hyphens on line break  * patch11: # fields could write outside allocated memory  *  * Revision 4.0.1.1  91/06/07  11:07:59  lwall  * patch4: new copyright notice  * patch4: default top-of-form format is now FILEHANDLE_TOP  *  * Revision 4.0  91/03/20  01:19:23  lwall  * 4.0 baseline.  *  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_comment
comment|/* Forms stuff */
end_comment

begin_function_decl
specifier|static
name|int
name|countlines
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|form_parseargs
parameter_list|(
name|fcmd
parameter_list|)
specifier|register
name|FCMD
modifier|*
name|fcmd
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
specifier|register
name|int
name|items
decl_stmt|;
name|STR
modifier|*
name|str
decl_stmt|;
name|ARG
modifier|*
name|parselist
parameter_list|()
function_decl|;
name|line_t
name|oldline
init|=
name|curcmd
operator|->
name|c_line
decl_stmt|;
name|int
name|oldsave
init|=
name|savestack
operator|->
name|ary_fill
decl_stmt|;
name|str
operator|=
name|fcmd
operator|->
name|f_unparsed
expr_stmt|;
name|curcmd
operator|->
name|c_line
operator|=
name|fcmd
operator|->
name|f_line
expr_stmt|;
name|fcmd
operator|->
name|f_unparsed
operator|=
name|Nullstr
expr_stmt|;
operator|(
name|void
operator|)
name|savehptr
argument_list|(
operator|&
name|curstash
argument_list|)
expr_stmt|;
name|curstash
operator|=
name|str
operator|->
name|str_u
operator|.
name|str_hash
expr_stmt|;
name|arg
operator|=
name|parselist
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|restorelist
argument_list|(
name|oldsave
argument_list|)
expr_stmt|;
name|items
operator|=
name|arg
operator|->
name|arg_len
operator|-
literal|1
expr_stmt|;
comment|/* ignore $$ on end */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|items
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|fcmd
operator|||
name|fcmd
operator|->
name|f_type
operator|==
name|F_NULL
condition|)
name|fatal
argument_list|(
literal|"Too many field values"
argument_list|)
expr_stmt|;
name|dehoist
argument_list|(
name|arg
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fcmd
operator|->
name|f_expr
operator|=
name|make_op
argument_list|(
name|O_ITEM
argument_list|,
literal|1
argument_list|,
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
argument_list|,
name|Nullarg
argument_list|,
name|Nullarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcmd
operator|->
name|f_flags
operator|&
name|FC_CHOP
condition|)
block|{
if|if
condition|(
operator|(
name|fcmd
operator|->
name|f_expr
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_STAB
condition|)
name|fcmd
operator|->
name|f_expr
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_LVAL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fcmd
operator|->
name|f_expr
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_EXPR
condition|)
name|fcmd
operator|->
name|f_expr
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_LEXPR
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"^ field requires scalar lvalue"
argument_list|)
expr_stmt|;
block|}
name|fcmd
operator|=
name|fcmd
operator|->
name|f_next
expr_stmt|;
block|}
if|if
condition|(
name|fcmd
operator|&&
name|fcmd
operator|->
name|f_type
condition|)
name|fatal
argument_list|(
literal|"Not enough field values"
argument_list|)
expr_stmt|;
name|curcmd
operator|->
name|c_line
operator|=
name|oldline
expr_stmt|;
name|Safefree
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|str_free
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|newsize
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CHKLEN
parameter_list|(
name|allow
parameter_list|)
define|\
value|newsize = (d - orec->o_str) + (allow); \ if (newsize>= curlen) { \     curlen = d - orec->o_str; \     GROWSTR(&orec->o_str,&orec->o_len,orec->o_len + (allow)); \     d = orec->o_str + curlen;
comment|/* in case it moves */
value|\     curlen = orec->o_len - 2; \ }
end_define

begin_function
name|void
name|format
parameter_list|(
name|orec
parameter_list|,
name|fcmd
parameter_list|,
name|sp
parameter_list|)
specifier|register
name|struct
name|outrec
modifier|*
name|orec
decl_stmt|;
specifier|register
name|FCMD
modifier|*
name|fcmd
decl_stmt|;
name|int
name|sp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|d
init|=
name|orec
operator|->
name|o_str
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|curlen
init|=
name|orec
operator|->
name|o_len
operator|-
literal|2
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
name|FCMD
modifier|*
name|nextfcmd
decl_stmt|;
name|FCMD
modifier|*
name|linebeg
init|=
name|fcmd
decl_stmt|;
name|char
name|tmpchar
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|CMD
name|mycmd
decl_stmt|;
name|STR
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|chophere
decl_stmt|;
name|int
name|blank
init|=
name|TRUE
decl_stmt|;
name|mycmd
operator|.
name|c_type
operator|=
name|C_NULL
expr_stmt|;
name|orec
operator|->
name|o_lines
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|fcmd
condition|;
name|fcmd
operator|=
name|nextfcmd
control|)
block|{
name|nextfcmd
operator|=
name|fcmd
operator|->
name|f_next
expr_stmt|;
name|CHKLEN
argument_list|(
name|fcmd
operator|->
name|f_presize
argument_list|)
expr_stmt|;
comment|/*SUPPRESS 560*/
if|if
condition|(
name|s
operator|=
name|fcmd
operator|->
name|f_pre
condition|)
block|{
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
condition|)
block|{
name|t
operator|=
name|orec
operator|->
name|o_str
expr_stmt|;
if|if
condition|(
name|blank
operator|&&
operator|(
name|fcmd
operator|->
name|f_flags
operator|&
name|FC_REPEAT
operator|)
condition|)
block|{
while|while
condition|(
name|d
operator|>
name|t
operator|&&
operator|(
name|d
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
operator|)
condition|)
name|d
operator|--
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|d
operator|>
name|t
operator|&&
operator|(
name|d
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|d
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|d
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|fcmd
operator|->
name|f_flags
operator|&
name|FC_NOBLANK
condition|)
block|{
if|if
condition|(
name|blank
operator|||
name|d
operator|==
name|orec
operator|->
name|o_str
operator|||
name|d
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|orec
operator|->
name|o_lines
operator|--
expr_stmt|;
comment|/* don't print blank line */
name|linebeg
operator|=
name|fcmd
operator|->
name|f_next
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|fcmd
operator|->
name|f_flags
operator|&
name|FC_REPEAT
condition|)
name|nextfcmd
operator|=
name|linebeg
expr_stmt|;
else|else
name|linebeg
operator|=
name|fcmd
operator|->
name|f_next
expr_stmt|;
block|}
else|else
name|linebeg
operator|=
name|fcmd
operator|->
name|f_next
expr_stmt|;
name|blank
operator|=
name|TRUE
expr_stmt|;
block|}
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fcmd
operator|->
name|f_unparsed
condition|)
name|form_parseargs
argument_list|(
name|fcmd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fcmd
operator|->
name|f_type
condition|)
block|{
case|case
name|F_NULL
case|:
name|orec
operator|->
name|o_lines
operator|++
expr_stmt|;
break|break;
case|case
name|F_LEFT
case|:
operator|(
name|void
operator|)
name|eval
argument_list|(
name|fcmd
operator|->
name|f_expr
argument_list|,
name|G_SCALAR
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|str
operator|=
name|stack
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|1
index|]
expr_stmt|;
name|s
operator|=
name|str_get
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|size
operator|=
name|fcmd
operator|->
name|f_size
expr_stmt|;
name|CHKLEN
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|chophere
operator|=
name|Nullch
expr_stmt|;
while|while
condition|(
name|size
operator|&&
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\t'
condition|)
operator|*
name|s
operator|=
literal|' '
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|!=
literal|' '
condition|)
name|blank
operator|=
name|FALSE
expr_stmt|;
name|size
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|&&
name|index
argument_list|(
name|chopset
argument_list|,
operator|(
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
argument_list|)
condition|)
name|chophere
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
operator|&&
operator|(
name|fcmd
operator|->
name|f_flags
operator|&
name|FC_CHOP
operator|)
condition|)
operator|*
name|s
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|||
operator|!
operator|*
name|s
condition|)
name|chophere
operator|=
name|s
expr_stmt|;
elseif|else
if|if
condition|(
name|chophere
operator|&&
name|chophere
operator|<
name|s
operator|&&
operator|*
name|s
operator|&&
name|index
argument_list|(
name|chopset
argument_list|,
operator|*
name|s
argument_list|)
condition|)
name|chophere
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|fcmd
operator|->
name|f_flags
operator|&
name|FC_CHOP
condition|)
block|{
if|if
condition|(
operator|!
name|chophere
condition|)
name|chophere
operator|=
name|s
expr_stmt|;
name|size
operator|+=
operator|(
name|s
operator|-
name|chophere
operator|)
expr_stmt|;
name|d
operator|-=
operator|(
name|s
operator|-
name|chophere
operator|)
expr_stmt|;
if|if
condition|(
name|fcmd
operator|->
name|f_flags
operator|&
name|FC_MORE
operator|&&
operator|*
name|chophere
operator|&&
name|strNE
argument_list|(
name|chophere
argument_list|,
literal|"\n"
argument_list|)
condition|)
block|{
while|while
condition|(
name|size
operator|<
literal|3
condition|)
block|{
name|d
operator|--
expr_stmt|;
name|size
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|d
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|&&
name|size
operator|<
name|fcmd
operator|->
name|f_size
condition|)
block|{
name|d
operator|--
expr_stmt|;
name|size
operator|++
expr_stmt|;
block|}
operator|*
name|d
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'.'
expr_stmt|;
name|size
operator|-=
literal|3
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|chophere
operator|&&
name|index
argument_list|(
name|chopset
argument_list|,
operator|*
name|chophere
argument_list|)
operator|&&
name|isSPACE
argument_list|(
operator|*
name|chophere
argument_list|)
condition|)
name|chophere
operator|++
expr_stmt|;
name|str_chop
argument_list|(
name|str
argument_list|,
name|chophere
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fcmd
operator|->
name|f_next
operator|&&
name|fcmd
operator|->
name|f_next
operator|->
name|f_pre
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
name|size
operator|=
literal|0
expr_stmt|;
comment|/* no spaces before newline */
while|while
condition|(
name|size
condition|)
block|{
name|size
operator|--
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
break|break;
case|case
name|F_RIGHT
case|:
operator|(
name|void
operator|)
name|eval
argument_list|(
name|fcmd
operator|->
name|f_expr
argument_list|,
name|G_SCALAR
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|str
operator|=
name|stack
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|1
index|]
expr_stmt|;
name|t
operator|=
name|s
operator|=
name|str_get
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|size
operator|=
name|fcmd
operator|->
name|f_size
expr_stmt|;
name|CHKLEN
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|chophere
operator|=
name|Nullch
expr_stmt|;
while|while
condition|(
name|size
operator|&&
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\t'
condition|)
operator|*
name|s
operator|=
literal|' '
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|!=
literal|' '
condition|)
name|blank
operator|=
name|FALSE
expr_stmt|;
name|size
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|&&
name|index
argument_list|(
name|chopset
argument_list|,
operator|*
name|s
operator|++
argument_list|)
condition|)
name|chophere
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
operator|&&
operator|(
name|fcmd
operator|->
name|f_flags
operator|&
name|FC_CHOP
operator|)
condition|)
operator|*
name|s
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|||
operator|!
operator|*
name|s
condition|)
name|chophere
operator|=
name|s
expr_stmt|;
elseif|else
if|if
condition|(
name|chophere
operator|&&
name|chophere
operator|<
name|s
operator|&&
operator|*
name|s
operator|&&
name|index
argument_list|(
name|chopset
argument_list|,
operator|*
name|s
argument_list|)
condition|)
name|chophere
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|fcmd
operator|->
name|f_flags
operator|&
name|FC_CHOP
condition|)
block|{
if|if
condition|(
operator|!
name|chophere
condition|)
name|chophere
operator|=
name|s
expr_stmt|;
name|size
operator|+=
operator|(
name|s
operator|-
name|chophere
operator|)
expr_stmt|;
name|s
operator|=
name|chophere
expr_stmt|;
while|while
condition|(
operator|*
name|chophere
operator|&&
name|index
argument_list|(
name|chopset
argument_list|,
operator|*
name|chophere
argument_list|)
operator|&&
name|isSPACE
argument_list|(
operator|*
name|chophere
argument_list|)
condition|)
name|chophere
operator|++
expr_stmt|;
block|}
name|tmpchar
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|size
condition|)
block|{
name|size
operator|--
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|size
operator|=
name|s
operator|-
name|t
expr_stmt|;
name|Copy
argument_list|(
name|t
argument_list|,
name|d
argument_list|,
name|size
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|d
operator|+=
name|size
expr_stmt|;
operator|*
name|s
operator|=
name|tmpchar
expr_stmt|;
if|if
condition|(
name|fcmd
operator|->
name|f_flags
operator|&
name|FC_CHOP
condition|)
name|str_chop
argument_list|(
name|str
argument_list|,
name|chophere
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_CENTER
case|:
block|{
name|int
name|halfsize
decl_stmt|;
operator|(
name|void
operator|)
name|eval
argument_list|(
name|fcmd
operator|->
name|f_expr
argument_list|,
name|G_SCALAR
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|str
operator|=
name|stack
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|1
index|]
expr_stmt|;
name|t
operator|=
name|s
operator|=
name|str_get
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|size
operator|=
name|fcmd
operator|->
name|f_size
expr_stmt|;
name|CHKLEN
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|chophere
operator|=
name|Nullch
expr_stmt|;
while|while
condition|(
name|size
operator|&&
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\t'
condition|)
operator|*
name|s
operator|=
literal|' '
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|!=
literal|' '
condition|)
name|blank
operator|=
name|FALSE
expr_stmt|;
name|size
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|&&
name|index
argument_list|(
name|chopset
argument_list|,
operator|*
name|s
operator|++
argument_list|)
condition|)
name|chophere
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
operator|&&
operator|(
name|fcmd
operator|->
name|f_flags
operator|&
name|FC_CHOP
operator|)
condition|)
operator|*
name|s
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|||
operator|!
operator|*
name|s
condition|)
name|chophere
operator|=
name|s
expr_stmt|;
elseif|else
if|if
condition|(
name|chophere
operator|&&
name|chophere
operator|<
name|s
operator|&&
operator|*
name|s
operator|&&
name|index
argument_list|(
name|chopset
argument_list|,
operator|*
name|s
argument_list|)
condition|)
name|chophere
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|fcmd
operator|->
name|f_flags
operator|&
name|FC_CHOP
condition|)
block|{
if|if
condition|(
operator|!
name|chophere
condition|)
name|chophere
operator|=
name|s
expr_stmt|;
name|size
operator|+=
operator|(
name|s
operator|-
name|chophere
operator|)
expr_stmt|;
name|s
operator|=
name|chophere
expr_stmt|;
while|while
condition|(
operator|*
name|chophere
operator|&&
name|index
argument_list|(
name|chopset
argument_list|,
operator|*
name|chophere
argument_list|)
operator|&&
name|isSPACE
argument_list|(
operator|*
name|chophere
argument_list|)
condition|)
name|chophere
operator|++
expr_stmt|;
block|}
name|tmpchar
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|halfsize
operator|=
name|size
operator|/
literal|2
expr_stmt|;
while|while
condition|(
name|size
operator|>
name|halfsize
condition|)
block|{
name|size
operator|--
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|size
operator|=
name|s
operator|-
name|t
expr_stmt|;
name|Copy
argument_list|(
name|t
argument_list|,
name|d
argument_list|,
name|size
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|d
operator|+=
name|size
expr_stmt|;
operator|*
name|s
operator|=
name|tmpchar
expr_stmt|;
if|if
condition|(
name|fcmd
operator|->
name|f_next
operator|&&
name|fcmd
operator|->
name|f_next
operator|->
name|f_pre
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
name|size
operator|=
literal|0
expr_stmt|;
comment|/* no spaces before newline */
else|else
name|size
operator|=
name|halfsize
expr_stmt|;
while|while
condition|(
name|size
condition|)
block|{
name|size
operator|--
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|fcmd
operator|->
name|f_flags
operator|&
name|FC_CHOP
condition|)
name|str_chop
argument_list|(
name|str
argument_list|,
name|chophere
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|F_LINES
case|:
operator|(
name|void
operator|)
name|eval
argument_list|(
name|fcmd
operator|->
name|f_expr
argument_list|,
name|G_SCALAR
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|str
operator|=
name|stack
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|1
index|]
expr_stmt|;
name|s
operator|=
name|str_get
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|size
operator|=
name|str_len
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|CHKLEN
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|orec
operator|->
name|o_lines
operator|+=
name|countlines
argument_list|(
name|s
argument_list|,
name|size
argument_list|)
operator|-
literal|1
expr_stmt|;
name|Copy
argument_list|(
name|s
argument_list|,
name|d
argument_list|,
name|size
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|d
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|&&
name|s
index|[
name|size
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
operator|*
name|d
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|orec
operator|->
name|o_lines
operator|++
expr_stmt|;
block|}
name|linebeg
operator|=
name|fcmd
operator|->
name|f_next
expr_stmt|;
break|break;
case|case
name|F_DECIMAL
case|:
block|{
name|double
name|value
decl_stmt|;
operator|(
name|void
operator|)
name|eval
argument_list|(
name|fcmd
operator|->
name|f_expr
argument_list|,
name|G_SCALAR
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|str
operator|=
name|stack
operator|->
name|ary_array
index|[
name|sp
operator|+
literal|1
index|]
expr_stmt|;
name|size
operator|=
name|fcmd
operator|->
name|f_size
expr_stmt|;
name|CHKLEN
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* If the field is marked with ^ and the value is undefined, 	       blank it out. */
if|if
condition|(
operator|(
name|fcmd
operator|->
name|f_flags
operator|&
name|FC_CHOP
operator|)
operator|&&
operator|!
name|str
operator|->
name|str_pok
operator|&&
operator|!
name|str
operator|->
name|str_nok
condition|)
block|{
while|while
condition|(
name|size
condition|)
block|{
name|size
operator|--
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
break|break;
block|}
name|blank
operator|=
name|FALSE
expr_stmt|;
name|value
operator|=
name|str_gnum
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcmd
operator|->
name|f_flags
operator|&
name|FC_DP
condition|)
block|{
name|sprintf
argument_list|(
name|d
argument_list|,
literal|"%#*.*f"
argument_list|,
name|size
argument_list|,
name|fcmd
operator|->
name|f_decimals
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|d
argument_list|,
literal|"%*.0f"
argument_list|,
name|size
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|d
operator|+=
name|size
expr_stmt|;
break|break;
block|}
block|}
block|}
name|CHKLEN
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|countlines
parameter_list|(
name|s
parameter_list|,
name|size
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|size
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'\n'
condition|)
name|count
operator|++
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
name|void
name|do_write
parameter_list|(
name|orec
parameter_list|,
name|stab
parameter_list|,
name|sp
parameter_list|)
name|struct
name|outrec
modifier|*
name|orec
decl_stmt|;
name|STAB
modifier|*
name|stab
decl_stmt|;
name|int
name|sp
decl_stmt|;
block|{
specifier|register
name|STIO
modifier|*
name|stio
init|=
name|stab_io
argument_list|(
name|stab
argument_list|)
decl_stmt|;
name|FILE
modifier|*
name|ofp
init|=
name|stio
operator|->
name|ofp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|256
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"left=%ld, todo=%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|stio
operator|->
name|lines_left
argument_list|,
operator|(
name|long
operator|)
name|orec
operator|->
name|o_lines
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stio
operator|->
name|lines_left
operator|<
name|orec
operator|->
name|o_lines
condition|)
block|{
if|if
condition|(
operator|!
name|stio
operator|->
name|top_stab
condition|)
block|{
name|STAB
modifier|*
name|topstab
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|stio
operator|->
name|top_name
condition|)
block|{
if|if
condition|(
operator|!
name|stio
operator|->
name|fmt_name
condition|)
name|stio
operator|->
name|fmt_name
operator|=
name|savestr
argument_list|(
name|stab_name
argument_list|(
name|stab
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%s_TOP"
argument_list|,
name|stio
operator|->
name|fmt_name
argument_list|)
expr_stmt|;
name|topstab
operator|=
name|stabent
argument_list|(
name|tmpbuf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|topstab
operator|&&
name|stab_form
argument_list|(
name|topstab
argument_list|)
condition|)
name|stio
operator|->
name|top_name
operator|=
name|savestr
argument_list|(
name|tmpbuf
argument_list|)
expr_stmt|;
else|else
name|stio
operator|->
name|top_name
operator|=
name|savestr
argument_list|(
literal|"top"
argument_list|)
expr_stmt|;
block|}
name|topstab
operator|=
name|stabent
argument_list|(
name|stio
operator|->
name|top_name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|topstab
operator|||
operator|!
name|stab_form
argument_list|(
name|topstab
argument_list|)
condition|)
block|{
name|stio
operator|->
name|lines_left
operator|=
literal|100000000
expr_stmt|;
goto|goto
name|forget_top
goto|;
block|}
name|stio
operator|->
name|top_stab
operator|=
name|topstab
expr_stmt|;
block|}
if|if
condition|(
name|stio
operator|->
name|lines_left
operator|>=
literal|0
operator|&&
name|stio
operator|->
name|page
operator|>
literal|0
condition|)
name|fwrite
argument_list|(
name|formfeed
operator|->
name|str_ptr
argument_list|,
name|formfeed
operator|->
name|str_cur
argument_list|,
literal|1
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|stio
operator|->
name|lines_left
operator|=
name|stio
operator|->
name|page_len
expr_stmt|;
name|stio
operator|->
name|page
operator|++
expr_stmt|;
name|format
argument_list|(
operator|&
name|toprec
argument_list|,
name|stab_form
argument_list|(
name|stio
operator|->
name|top_stab
argument_list|)
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|toprec
operator|.
name|o_str
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|stio
operator|->
name|lines_left
operator|-=
name|toprec
operator|.
name|o_lines
expr_stmt|;
block|}
name|forget_top
label|:
name|fputs
argument_list|(
name|orec
operator|->
name|o_str
argument_list|,
name|ofp
argument_list|)
expr_stmt|;
name|stio
operator|->
name|lines_left
operator|-=
name|orec
operator|->
name|o_lines
expr_stmt|;
block|}
end_function

end_unit

