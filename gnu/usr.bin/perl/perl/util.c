begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $RCSfile: util.c,v $$Revision: 1.2 $$Date: 1995/05/30 05:03:28 $  *  *    Copyright (c) 1991, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  * $Log: util.c,v $  * Revision 1.2  1995/05/30 05:03:28  rgrimes  * Remove trailing whitespace.  *  * Revision 1.1.1.1  1994/09/10  06:27:34  gclarkii  * Initial import of Perl 4.046 bmaked  *  * Revision 1.1.1.1  1993/08/23  21:29:40  nate  * PERL!  *  * Revision 4.0.1.6  92/06/11  21:18:47  lwall  * patch34: boneheaded typo in my_bcopy()  *  * Revision 4.0.1.5  92/06/08  16:08:37  lwall  * patch20: removed implicit int declarations on functions  * patch20: Perl now distinguishes overlapped copies from non-overlapped  * patch20: fixed confusion between a *var's real name and its effective name  * patch20: bcopy() and memcpy() now tested for overlap safety  * patch20: added Atari ST portability  *  * Revision 4.0.1.4  91/11/11  16:48:54  lwall  * patch19: study was busted by 4.018  * patch19: added little-endian pack/unpack options  *  * Revision 4.0.1.3  91/11/05  19:18:26  lwall  * patch11: safe malloc code now integrated into Perl's malloc when possible  * patch11: index("little", "longer string") could visit faraway places  * patch11: warn '-' x 10000 dumped core  * patch11: forked exec on non-existent program now issues a warning  *  * Revision 4.0.1.2  91/06/07  12:10:42  lwall  * patch4: new copyright notice  * patch4: made some allowances for "semi-standard" C  * patch4: index() could blow up searching for null string  * patch4: taintchecks could improperly modify parent in vfork()  * patch4: exec would close files even if you cleared close-on-exec flag  *  * Revision 4.0.1.1  91/04/12  09:19:25  lwall  * patch1: random cleanup in cpp namespace  *  * Revision 4.0  91/03/20  01:56:39  lwall  * 4.0 baseline.  *  */
end_comment

begin_comment
comment|/*SUPPRESS 112*/
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NSIG
argument_list|)
operator|||
name|defined
argument_list|(
name|M_UNIX
argument_list|)
operator|||
name|defined
argument_list|(
name|M_XENIX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_VFORK
end_ifdef

begin_include
include|#
directive|include
file|<vfork.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_VARARGS
end_ifdef

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_FCNTL
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_SYS_FILE
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FLUSH
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|safemalloc
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|nomem
index|[]
init|=
literal|"Out of memory!\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* paranoid version of malloc */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|an
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOTE:  Do not call the next three routines directly.  Use the macros  * in handy.h, so that we can easily redefine everything to do tracking of  * allocated hunks back to the original New to track down any memory leaks.  */
end_comment

begin_function
name|char
modifier|*
name|safemalloc
parameter_list|(
name|size
parameter_list|)
ifdef|#
directive|ifdef
name|MSDOS
name|unsigned
name|long
name|size
decl_stmt|;
else|#
directive|else
name|MEM_SIZE
name|size
decl_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
ifndef|#
directive|ifndef
name|STANDARD_C
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|/* ! STANDARD_C */
ifdef|#
directive|ifdef
name|MSDOS
if|if
condition|(
name|size
operator|>
literal|0xffff
condition|)
block|{
name|fprintf
argument_list|(
argument|stderr
argument_list|,
literal|"Allocation too large: %lx\n"
argument_list|,
argument|size
argument_list|)
name|FLUSH
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MSDOS */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
operator|(
name|long
operator|)
name|size
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"panic: malloc"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|=
name|malloc
argument_list|(
name|size
condition|?
name|size
else|:
literal|1
argument_list|)
expr_stmt|;
comment|/* malloc(0) is NASTY on our system */
ifdef|#
directive|ifdef
name|DEBUGGING
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|I286
argument_list|)
operator|||
name|defined
argument_list|(
name|atarist
argument_list|)
operator|)
if|if
condition|(
name|debug
operator|&
literal|128
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"0x%x: (%05d) malloc %ld bytes\n"
argument_list|,
name|ptr
argument_list|,
name|an
operator|++
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|debug
operator|&
literal|128
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"0x%lx: (%05d) malloc %ld bytes\n"
argument_list|,
name|ptr
argument_list|,
name|an
operator|++
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|ptr
operator|!=
name|Nullch
condition|)
return|return
name|ptr
return|;
elseif|else
if|if
condition|(
name|nomemok
condition|)
return|return
name|Nullch
return|;
else|else
block|{
name|fputs
argument_list|(
argument|nomem
argument_list|,
argument|stderr
argument_list|)
name|FLUSH
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*NOTREACHED*/
ifdef|#
directive|ifdef
name|lint
return|return
name|ptr
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* paranoid version of realloc */
end_comment

begin_function
name|char
modifier|*
name|saferealloc
parameter_list|(
name|where
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
name|MEM_SIZE
name|size
decl_stmt|;
else|#
directive|else
name|unsigned
name|long
name|size
decl_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
ifndef|#
directive|ifndef
name|STANDARD_C
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|/* ! STANDARD_C */
ifdef|#
directive|ifdef
name|MSDOS
if|if
condition|(
name|size
operator|>
literal|0xffff
condition|)
block|{
name|fprintf
argument_list|(
argument|stderr
argument_list|,
literal|"Reallocation too large: %lx\n"
argument_list|,
argument|size
argument_list|)
name|FLUSH
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MSDOS */
if|if
condition|(
operator|!
name|where
condition|)
name|fatal
argument_list|(
literal|"Null realloc"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
operator|(
name|long
operator|)
name|size
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"panic: realloc"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|=
name|realloc
argument_list|(
name|where
argument_list|,
name|size
condition|?
name|size
else|:
literal|1
argument_list|)
expr_stmt|;
comment|/* realloc(0) is NASTY on our system */
ifdef|#
directive|ifdef
name|DEBUGGING
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|I286
argument_list|)
operator|||
name|defined
argument_list|(
name|atarist
argument_list|)
operator|)
if|if
condition|(
name|debug
operator|&
literal|128
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"0x%x: (%05d) rfree\n"
argument_list|,
name|where
argument_list|,
name|an
operator|++
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"0x%x: (%05d) realloc %ld bytes\n"
argument_list|,
name|ptr
argument_list|,
name|an
operator|++
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|debug
operator|&
literal|128
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"0x%lx: (%05d) rfree\n"
argument_list|,
name|where
argument_list|,
name|an
operator|++
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"0x%lx: (%05d) realloc %ld bytes\n"
argument_list|,
name|ptr
argument_list|,
name|an
operator|++
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|ptr
operator|!=
name|Nullch
condition|)
return|return
name|ptr
return|;
elseif|else
if|if
condition|(
name|nomemok
condition|)
return|return
name|Nullch
return|;
else|else
block|{
name|fputs
argument_list|(
argument|nomem
argument_list|,
argument|stderr
argument_list|)
name|FLUSH
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*NOTREACHED*/
ifdef|#
directive|ifdef
name|lint
return|return
name|ptr
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* safe version of free */
end_comment

begin_function
name|void
name|safefree
parameter_list|(
name|where
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|I286
argument_list|)
operator|||
name|defined
argument_list|(
name|atarist
argument_list|)
operator|)
if|if
condition|(
name|debug
operator|&
literal|128
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"0x%x: (%05d) free\n"
argument_list|,
name|where
argument_list|,
name|an
operator|++
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|debug
operator|&
literal|128
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"0x%lx: (%05d) free\n"
argument_list|,
name|where
argument_list|,
name|an
operator|++
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|where
condition|)
block|{
comment|/*SUPPRESS 701*/
name|free
argument_list|(
name|where
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !safemalloc */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LEAKTEST
end_ifdef

begin_define
define|#
directive|define
name|ALIGN
value|sizeof(long)
end_define

begin_function
name|char
modifier|*
name|safexmalloc
parameter_list|(
name|x
parameter_list|,
name|size
parameter_list|)
name|int
name|x
decl_stmt|;
name|MEM_SIZE
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|where
decl_stmt|;
name|where
operator|=
name|safemalloc
argument_list|(
name|size
operator|+
name|ALIGN
argument_list|)
expr_stmt|;
name|xcount
index|[
name|x
index|]
operator|++
expr_stmt|;
name|where
index|[
literal|0
index|]
operator|=
name|x
operator|%
literal|100
expr_stmt|;
name|where
index|[
literal|1
index|]
operator|=
name|x
operator|/
literal|100
expr_stmt|;
return|return
name|where
operator|+
name|ALIGN
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|safexrealloc
parameter_list|(
name|where
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
name|MEM_SIZE
name|size
decl_stmt|;
block|{
return|return
name|saferealloc
argument_list|(
name|where
operator|-
name|ALIGN
argument_list|,
name|size
operator|+
name|ALIGN
argument_list|)
operator|+
name|ALIGN
return|;
block|}
end_function

begin_function
name|void
name|safexfree
parameter_list|(
name|where
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
operator|!
name|where
condition|)
return|return;
name|where
operator|-=
name|ALIGN
expr_stmt|;
name|x
operator|=
name|where
index|[
literal|0
index|]
operator|+
literal|100
operator|*
name|where
index|[
literal|1
index|]
expr_stmt|;
name|xcount
index|[
name|x
index|]
operator|--
expr_stmt|;
name|safefree
argument_list|(
name|where
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xstat
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXXCOUNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xcount
index|[
name|i
index|]
operator|>
name|lastxcount
index|[
name|i
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%2d %2d\t%ld\n"
argument_list|,
name|i
operator|/
literal|100
argument_list|,
name|i
operator|%
literal|100
argument_list|,
name|xcount
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|lastxcount
index|[
name|i
index|]
operator|=
name|xcount
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LEAKTEST */
end_comment

begin_comment
comment|/* copy a string up to some (non-backslashed) delimiter, if any */
end_comment

begin_function
name|char
modifier|*
name|cpytill
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|fromend
parameter_list|,
name|delim
parameter_list|,
name|retlen
parameter_list|)
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
specifier|register
name|char
modifier|*
name|from
decl_stmt|;
specifier|register
name|char
modifier|*
name|fromend
decl_stmt|;
specifier|register
name|int
name|delim
decl_stmt|;
name|int
modifier|*
name|retlen
decl_stmt|;
block|{
name|char
modifier|*
name|origto
init|=
name|to
decl_stmt|;
for|for
control|(
init|;
name|from
operator|<
name|fromend
condition|;
name|from
operator|++
operator|,
name|to
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|from
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|from
index|[
literal|1
index|]
operator|==
name|delim
condition|)
name|from
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|from
index|[
literal|1
index|]
operator|==
literal|'\\'
condition|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|from
operator|==
name|delim
condition|)
break|break;
operator|*
name|to
operator|=
operator|*
name|from
expr_stmt|;
block|}
operator|*
name|to
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|retlen
operator|=
name|to
operator|-
name|origto
expr_stmt|;
return|return
name|from
return|;
block|}
end_function

begin_comment
comment|/* return ptr to little string in big string, NULL if not found */
end_comment

begin_comment
comment|/* This routine was donated by Corey Satten. */
end_comment

begin_function
name|char
modifier|*
name|instr
parameter_list|(
name|big
parameter_list|,
name|little
parameter_list|)
specifier|register
name|char
modifier|*
name|big
decl_stmt|;
specifier|register
name|char
modifier|*
name|little
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|x
decl_stmt|;
specifier|register
name|int
name|first
decl_stmt|;
if|if
condition|(
operator|!
name|little
condition|)
return|return
name|big
return|;
name|first
operator|=
operator|*
name|little
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
return|return
name|big
return|;
while|while
condition|(
operator|*
name|big
condition|)
block|{
if|if
condition|(
operator|*
name|big
operator|++
operator|!=
name|first
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
name|big
operator|,
name|s
operator|=
name|little
init|;
operator|*
name|s
condition|;
comment|/**/
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|x
condition|)
return|return
name|Nullch
return|;
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
operator|*
name|x
operator|++
condition|)
block|{
name|s
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|s
condition|)
return|return
name|big
operator|-
literal|1
return|;
block|}
return|return
name|Nullch
return|;
block|}
end_function

begin_comment
comment|/* same as instr but allow embedded nulls */
end_comment

begin_function
name|char
modifier|*
name|ninstr
parameter_list|(
name|big
parameter_list|,
name|bigend
parameter_list|,
name|little
parameter_list|,
name|lend
parameter_list|)
specifier|register
name|char
modifier|*
name|big
decl_stmt|;
specifier|register
name|char
modifier|*
name|bigend
decl_stmt|;
name|char
modifier|*
name|little
decl_stmt|;
name|char
modifier|*
name|lend
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|x
decl_stmt|;
specifier|register
name|int
name|first
init|=
operator|*
name|little
decl_stmt|;
specifier|register
name|char
modifier|*
name|littleend
init|=
name|lend
decl_stmt|;
if|if
condition|(
operator|!
name|first
operator|&&
name|little
operator|>
name|littleend
condition|)
return|return
name|big
return|;
if|if
condition|(
name|bigend
operator|-
name|big
operator|<
name|littleend
operator|-
name|little
condition|)
return|return
name|Nullch
return|;
name|bigend
operator|-=
name|littleend
operator|-
name|little
operator|++
expr_stmt|;
while|while
condition|(
name|big
operator|<=
name|bigend
condition|)
block|{
if|if
condition|(
operator|*
name|big
operator|++
operator|!=
name|first
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
name|big
operator|,
name|s
operator|=
name|little
init|;
name|s
operator|<
name|littleend
condition|;
comment|/**/
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
operator|*
name|x
operator|++
condition|)
block|{
name|s
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|s
operator|>=
name|littleend
condition|)
return|return
name|big
operator|-
literal|1
return|;
block|}
return|return
name|Nullch
return|;
block|}
end_function

begin_comment
comment|/* reverse of the above--find last substring */
end_comment

begin_function
name|char
modifier|*
name|rninstr
parameter_list|(
name|big
parameter_list|,
name|bigend
parameter_list|,
name|little
parameter_list|,
name|lend
parameter_list|)
specifier|register
name|char
modifier|*
name|big
decl_stmt|;
name|char
modifier|*
name|bigend
decl_stmt|;
name|char
modifier|*
name|little
decl_stmt|;
name|char
modifier|*
name|lend
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bigbeg
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|x
decl_stmt|;
specifier|register
name|int
name|first
init|=
operator|*
name|little
decl_stmt|;
specifier|register
name|char
modifier|*
name|littleend
init|=
name|lend
decl_stmt|;
if|if
condition|(
operator|!
name|first
operator|&&
name|little
operator|>
name|littleend
condition|)
return|return
name|bigend
return|;
name|bigbeg
operator|=
name|big
expr_stmt|;
name|big
operator|=
name|bigend
operator|-
operator|(
name|littleend
operator|-
name|little
operator|++
operator|)
expr_stmt|;
while|while
condition|(
name|big
operator|>=
name|bigbeg
condition|)
block|{
if|if
condition|(
operator|*
name|big
operator|--
operator|!=
name|first
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
name|big
operator|+
literal|2
operator|,
name|s
operator|=
name|little
init|;
name|s
operator|<
name|littleend
condition|;
comment|/**/
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
operator|*
name|x
operator|++
condition|)
block|{
name|s
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|s
operator|>=
name|littleend
condition|)
return|return
name|big
operator|+
literal|1
return|;
block|}
return|return
name|Nullch
return|;
block|}
end_function

begin_decl_stmt
name|unsigned
name|char
name|fold
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
literal|62
block|,
literal|63
block|,
literal|64
block|,
literal|'a'
block|,
literal|'b'
block|,
literal|'c'
block|,
literal|'d'
block|,
literal|'e'
block|,
literal|'f'
block|,
literal|'g'
block|,
literal|'h'
block|,
literal|'i'
block|,
literal|'j'
block|,
literal|'k'
block|,
literal|'l'
block|,
literal|'m'
block|,
literal|'n'
block|,
literal|'o'
block|,
literal|'p'
block|,
literal|'q'
block|,
literal|'r'
block|,
literal|'s'
block|,
literal|'t'
block|,
literal|'u'
block|,
literal|'v'
block|,
literal|'w'
block|,
literal|'x'
block|,
literal|'y'
block|,
literal|'z'
block|,
literal|91
block|,
literal|92
block|,
literal|93
block|,
literal|94
block|,
literal|95
block|,
literal|96
block|,
literal|'A'
block|,
literal|'B'
block|,
literal|'C'
block|,
literal|'D'
block|,
literal|'E'
block|,
literal|'F'
block|,
literal|'G'
block|,
literal|'H'
block|,
literal|'I'
block|,
literal|'J'
block|,
literal|'K'
block|,
literal|'L'
block|,
literal|'M'
block|,
literal|'N'
block|,
literal|'O'
block|,
literal|'P'
block|,
literal|'Q'
block|,
literal|'R'
block|,
literal|'S'
block|,
literal|'T'
block|,
literal|'U'
block|,
literal|'V'
block|,
literal|'W'
block|,
literal|'X'
block|,
literal|'Y'
block|,
literal|'Z'
block|,
literal|123
block|,
literal|124
block|,
literal|125
block|,
literal|126
block|,
literal|127
block|,
literal|128
block|,
literal|129
block|,
literal|130
block|,
literal|131
block|,
literal|132
block|,
literal|133
block|,
literal|134
block|,
literal|135
block|,
literal|136
block|,
literal|137
block|,
literal|138
block|,
literal|139
block|,
literal|140
block|,
literal|141
block|,
literal|142
block|,
literal|143
block|,
literal|144
block|,
literal|145
block|,
literal|146
block|,
literal|147
block|,
literal|148
block|,
literal|149
block|,
literal|150
block|,
literal|151
block|,
literal|152
block|,
literal|153
block|,
literal|154
block|,
literal|155
block|,
literal|156
block|,
literal|157
block|,
literal|158
block|,
literal|159
block|,
literal|160
block|,
literal|161
block|,
literal|162
block|,
literal|163
block|,
literal|164
block|,
literal|165
block|,
literal|166
block|,
literal|167
block|,
literal|168
block|,
literal|169
block|,
literal|170
block|,
literal|171
block|,
literal|172
block|,
literal|173
block|,
literal|174
block|,
literal|175
block|,
literal|176
block|,
literal|177
block|,
literal|178
block|,
literal|179
block|,
literal|180
block|,
literal|181
block|,
literal|182
block|,
literal|183
block|,
literal|184
block|,
literal|185
block|,
literal|186
block|,
literal|187
block|,
literal|188
block|,
literal|189
block|,
literal|190
block|,
literal|191
block|,
literal|192
block|,
literal|193
block|,
literal|194
block|,
literal|195
block|,
literal|196
block|,
literal|197
block|,
literal|198
block|,
literal|199
block|,
literal|200
block|,
literal|201
block|,
literal|202
block|,
literal|203
block|,
literal|204
block|,
literal|205
block|,
literal|206
block|,
literal|207
block|,
literal|208
block|,
literal|209
block|,
literal|210
block|,
literal|211
block|,
literal|212
block|,
literal|213
block|,
literal|214
block|,
literal|215
block|,
literal|216
block|,
literal|217
block|,
literal|218
block|,
literal|219
block|,
literal|220
block|,
literal|221
block|,
literal|222
block|,
literal|223
block|,
literal|224
block|,
literal|225
block|,
literal|226
block|,
literal|227
block|,
literal|228
block|,
literal|229
block|,
literal|230
block|,
literal|231
block|,
literal|232
block|,
literal|233
block|,
literal|234
block|,
literal|235
block|,
literal|236
block|,
literal|237
block|,
literal|238
block|,
literal|239
block|,
literal|240
block|,
literal|241
block|,
literal|242
block|,
literal|243
block|,
literal|244
block|,
literal|245
block|,
literal|246
block|,
literal|247
block|,
literal|248
block|,
literal|249
block|,
literal|250
block|,
literal|251
block|,
literal|252
block|,
literal|253
block|,
literal|254
block|,
literal|255
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|freq
index|[]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|84
block|,
literal|151
block|,
literal|154
block|,
literal|155
block|,
literal|156
block|,
literal|157
block|,
literal|165
block|,
literal|246
block|,
literal|250
block|,
literal|3
block|,
literal|158
block|,
literal|7
block|,
literal|18
block|,
literal|29
block|,
literal|40
block|,
literal|51
block|,
literal|62
block|,
literal|73
block|,
literal|85
block|,
literal|96
block|,
literal|107
block|,
literal|118
block|,
literal|129
block|,
literal|140
block|,
literal|147
block|,
literal|148
block|,
literal|149
block|,
literal|150
block|,
literal|152
block|,
literal|153
block|,
literal|255
block|,
literal|182
block|,
literal|224
block|,
literal|205
block|,
literal|174
block|,
literal|176
block|,
literal|180
block|,
literal|217
block|,
literal|233
block|,
literal|232
block|,
literal|236
block|,
literal|187
block|,
literal|235
block|,
literal|228
block|,
literal|234
block|,
literal|226
block|,
literal|222
block|,
literal|219
block|,
literal|211
block|,
literal|195
block|,
literal|188
block|,
literal|193
block|,
literal|185
block|,
literal|184
block|,
literal|191
block|,
literal|183
block|,
literal|201
block|,
literal|229
block|,
literal|181
block|,
literal|220
block|,
literal|194
block|,
literal|162
block|,
literal|163
block|,
literal|208
block|,
literal|186
block|,
literal|202
block|,
literal|200
block|,
literal|218
block|,
literal|198
block|,
literal|179
block|,
literal|178
block|,
literal|214
block|,
literal|166
block|,
literal|170
block|,
literal|207
block|,
literal|199
block|,
literal|209
block|,
literal|206
block|,
literal|204
block|,
literal|160
block|,
literal|212
block|,
literal|216
block|,
literal|215
block|,
literal|192
block|,
literal|175
block|,
literal|173
block|,
literal|243
block|,
literal|172
block|,
literal|161
block|,
literal|190
block|,
literal|203
block|,
literal|189
block|,
literal|164
block|,
literal|230
block|,
literal|167
block|,
literal|248
block|,
literal|227
block|,
literal|244
block|,
literal|242
block|,
literal|255
block|,
literal|241
block|,
literal|231
block|,
literal|240
block|,
literal|253
block|,
literal|169
block|,
literal|210
block|,
literal|245
block|,
literal|237
block|,
literal|249
block|,
literal|247
block|,
literal|239
block|,
literal|168
block|,
literal|252
block|,
literal|251
block|,
literal|254
block|,
literal|238
block|,
literal|223
block|,
literal|221
block|,
literal|213
block|,
literal|225
block|,
literal|177
block|,
literal|197
block|,
literal|171
block|,
literal|196
block|,
literal|159
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|33
block|,
literal|34
block|,
literal|35
block|,
literal|36
block|,
literal|37
block|,
literal|38
block|,
literal|39
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|44
block|,
literal|45
block|,
literal|46
block|,
literal|47
block|,
literal|48
block|,
literal|49
block|,
literal|50
block|,
literal|52
block|,
literal|53
block|,
literal|54
block|,
literal|55
block|,
literal|56
block|,
literal|57
block|,
literal|58
block|,
literal|59
block|,
literal|60
block|,
literal|61
block|,
literal|63
block|,
literal|64
block|,
literal|65
block|,
literal|66
block|,
literal|67
block|,
literal|68
block|,
literal|69
block|,
literal|70
block|,
literal|71
block|,
literal|72
block|,
literal|74
block|,
literal|75
block|,
literal|76
block|,
literal|77
block|,
literal|78
block|,
literal|79
block|,
literal|80
block|,
literal|81
block|,
literal|82
block|,
literal|83
block|,
literal|86
block|,
literal|87
block|,
literal|88
block|,
literal|89
block|,
literal|90
block|,
literal|91
block|,
literal|92
block|,
literal|93
block|,
literal|94
block|,
literal|95
block|,
literal|97
block|,
literal|98
block|,
literal|99
block|,
literal|100
block|,
literal|101
block|,
literal|102
block|,
literal|103
block|,
literal|104
block|,
literal|105
block|,
literal|106
block|,
literal|108
block|,
literal|109
block|,
literal|110
block|,
literal|111
block|,
literal|112
block|,
literal|113
block|,
literal|114
block|,
literal|115
block|,
literal|116
block|,
literal|117
block|,
literal|119
block|,
literal|120
block|,
literal|121
block|,
literal|122
block|,
literal|123
block|,
literal|124
block|,
literal|125
block|,
literal|126
block|,
literal|127
block|,
literal|128
block|,
literal|130
block|,
literal|131
block|,
literal|132
block|,
literal|133
block|,
literal|134
block|,
literal|135
block|,
literal|136
block|,
literal|137
block|,
literal|138
block|,
literal|139
block|,
literal|141
block|,
literal|142
block|,
literal|143
block|,
literal|144
block|,
literal|145
block|,
literal|146
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|fbmcompile
parameter_list|(
name|str
parameter_list|,
name|iflag
parameter_list|)
name|STR
modifier|*
name|str
decl_stmt|;
name|int
name|iflag
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|table
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
specifier|register
name|unsigned
name|int
name|len
init|=
name|str
operator|->
name|str_cur
decl_stmt|;
name|int
name|rarest
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|frequency
init|=
literal|256
decl_stmt|;
name|Str_Grow
argument_list|(
name|str
argument_list|,
name|len
operator|+
literal|258
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|table
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|str
operator|->
name|str_ptr
operator|+
name|len
operator|+
literal|1
operator|)
expr_stmt|;
else|#
directive|else
name|table
operator|=
name|Null
argument_list|(
argument|unsigned char*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|table
operator|-
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|table
index|[
name|i
index|]
operator|=
name|len
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
while|while
condition|(
name|s
operator|>=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|str
operator|->
name|str_ptr
operator|)
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|table
index|[
operator|*
name|s
index|]
operator|==
name|len
condition|)
block|{
ifndef|#
directive|ifndef
name|pdp11
if|if
condition|(
name|iflag
condition|)
name|table
index|[
operator|*
name|s
index|]
operator|=
name|table
index|[
name|fold
index|[
operator|*
name|s
index|]
index|]
operator|=
name|i
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|iflag
condition|)
block|{
name|int
name|j
decl_stmt|;
name|j
operator|=
name|fold
index|[
operator|*
name|s
index|]
expr_stmt|;
name|table
index|[
name|j
index|]
operator|=
name|i
expr_stmt|;
name|table
index|[
operator|*
name|s
index|]
operator|=
name|i
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* pdp11 */
else|else
name|table
index|[
operator|*
name|s
index|]
operator|=
name|i
expr_stmt|;
block|}
name|s
operator|--
operator|,
name|i
operator|++
expr_stmt|;
block|}
name|str
operator|->
name|str_pok
operator||=
name|SP_FBM
expr_stmt|;
comment|/* deep magic */
ifndef|#
directive|ifndef
name|lint
name|s
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|str
operator|->
name|str_ptr
operator|)
expr_stmt|;
comment|/* deeper magic */
else|#
directive|else
name|s
operator|=
name|Null
argument_list|(
argument|unsigned char*
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|iflag
condition|)
block|{
specifier|register
name|unsigned
name|int
name|tmp
decl_stmt|,
name|foldtmp
decl_stmt|;
name|str
operator|->
name|str_pok
operator||=
name|SP_CASEFOLD
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|tmp
operator|=
name|freq
index|[
name|s
index|[
name|i
index|]
index|]
expr_stmt|;
name|foldtmp
operator|=
name|freq
index|[
name|fold
index|[
name|s
index|[
name|i
index|]
index|]
index|]
expr_stmt|;
if|if
condition|(
name|tmp
operator|<
name|frequency
operator|&&
name|foldtmp
operator|<
name|frequency
condition|)
block|{
name|rarest
operator|=
name|i
expr_stmt|;
comment|/* choose most frequent among the two */
name|frequency
operator|=
operator|(
name|tmp
operator|>
name|foldtmp
operator|)
condition|?
name|tmp
else|:
name|foldtmp
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|freq
index|[
name|s
index|[
name|i
index|]
index|]
operator|<
name|frequency
condition|)
block|{
name|rarest
operator|=
name|i
expr_stmt|;
name|frequency
operator|=
name|freq
index|[
name|s
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
block|}
block|}
name|str
operator|->
name|str_rare
operator|=
name|s
index|[
name|rarest
index|]
expr_stmt|;
name|str
operator|->
name|str_state
operator|=
name|rarest
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|512
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rarest char %c at %d\n"
argument_list|,
name|str
operator|->
name|str_rare
argument_list|,
name|str
operator|->
name|str_state
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|char
modifier|*
name|fbminstr
parameter_list|(
name|big
parameter_list|,
name|bigend
parameter_list|,
name|littlestr
parameter_list|)
name|unsigned
name|char
modifier|*
name|big
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|bigend
decl_stmt|;
name|STR
modifier|*
name|littlestr
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|tmp
decl_stmt|;
specifier|register
name|int
name|littlelen
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|little
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|table
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|olds
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|oldlittle
decl_stmt|;
ifndef|#
directive|ifndef
name|lint
if|if
condition|(
operator|!
operator|(
name|littlestr
operator|->
name|str_pok
operator|&
name|SP_FBM
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|littlestr
operator|->
name|str_ptr
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|big
return|;
return|return
name|ninstr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|big
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bigend
argument_list|,
name|littlestr
operator|->
name|str_ptr
argument_list|,
name|littlestr
operator|->
name|str_ptr
operator|+
name|littlestr
operator|->
name|str_cur
argument_list|)
return|;
block|}
endif|#
directive|endif
name|littlelen
operator|=
name|littlestr
operator|->
name|str_cur
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
if|if
condition|(
name|littlestr
operator|->
name|str_pok
operator|&
name|SP_TAIL
operator|&&
operator|!
name|multiline
condition|)
block|{
comment|/* tail anchored? */
if|if
condition|(
name|littlelen
operator|>
name|bigend
operator|-
name|big
condition|)
return|return
name|Nullch
return|;
name|little
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|littlestr
operator|->
name|str_ptr
expr_stmt|;
if|if
condition|(
name|littlestr
operator|->
name|str_pok
operator|&
name|SP_CASEFOLD
condition|)
block|{
comment|/* oops, fake it */
name|big
operator|=
name|bigend
operator|-
name|littlelen
expr_stmt|;
comment|/* just start near end */
if|if
condition|(
name|bigend
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|&&
name|little
index|[
name|littlelen
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|big
operator|--
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|bigend
operator|-
name|littlelen
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
operator|*
name|little
operator|&&
name|bcmp
argument_list|(
name|s
argument_list|,
name|little
argument_list|,
name|littlelen
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
comment|/* how sweet it is */
elseif|else
if|if
condition|(
name|bigend
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|&&
name|little
index|[
name|littlelen
operator|-
literal|1
index|]
operator|!=
literal|'\n'
operator|&&
name|s
operator|>
name|big
condition|)
block|{
name|s
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
operator|*
name|little
operator|&&
name|bcmp
argument_list|(
name|s
argument_list|,
name|little
argument_list|,
name|littlelen
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
return|return
name|Nullch
return|;
block|}
block|}
name|table
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|littlestr
operator|->
name|str_ptr
operator|+
name|littlelen
operator|+
literal|1
operator|)
expr_stmt|;
else|#
directive|else
name|table
operator|=
name|Null
argument_list|(
argument|unsigned char*
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|--
name|littlelen
operator|>=
name|bigend
operator|-
name|big
condition|)
return|return
name|Nullch
return|;
name|s
operator|=
name|big
operator|+
name|littlelen
expr_stmt|;
name|oldlittle
operator|=
name|little
operator|=
name|table
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|littlestr
operator|->
name|str_pok
operator|&
name|SP_CASEFOLD
condition|)
block|{
comment|/* case insensitive? */
if|if
condition|(
name|s
operator|<
name|bigend
condition|)
block|{
name|top1
label|:
comment|/*SUPPRESS 560*/
if|if
condition|(
name|tmp
operator|=
name|table
index|[
operator|*
name|s
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|POINTERRIGOR
if|if
condition|(
name|bigend
operator|-
name|s
operator|>
name|tmp
condition|)
block|{
name|s
operator|+=
name|tmp
expr_stmt|;
goto|goto
name|top1
goto|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|s
operator|+=
name|tmp
operator|)
operator|<
name|bigend
condition|)
goto|goto
name|top1
goto|;
endif|#
directive|endif
return|return
name|Nullch
return|;
block|}
else|else
block|{
name|tmp
operator|=
name|littlelen
expr_stmt|;
comment|/* less expensive than calling strncmp() */
name|olds
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|tmp
operator|--
condition|)
block|{
if|if
condition|(
operator|*
operator|--
name|s
operator|==
operator|*
operator|--
name|little
operator|||
name|fold
index|[
operator|*
name|s
index|]
operator|==
operator|*
name|little
condition|)
continue|continue;
name|s
operator|=
name|olds
operator|+
literal|1
expr_stmt|;
comment|/* here we pay the price for failure */
name|little
operator|=
name|oldlittle
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|bigend
condition|)
comment|/* fake up continue to outer loop */
goto|goto
name|top1
goto|;
return|return
name|Nullch
return|;
block|}
ifndef|#
directive|ifndef
name|lint
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
endif|#
directive|endif
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|s
operator|<
name|bigend
condition|)
block|{
name|top2
label|:
comment|/*SUPPRESS 560*/
if|if
condition|(
name|tmp
operator|=
name|table
index|[
operator|*
name|s
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|POINTERRIGOR
if|if
condition|(
name|bigend
operator|-
name|s
operator|>
name|tmp
condition|)
block|{
name|s
operator|+=
name|tmp
expr_stmt|;
goto|goto
name|top2
goto|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|s
operator|+=
name|tmp
operator|)
operator|<
name|bigend
condition|)
goto|goto
name|top2
goto|;
endif|#
directive|endif
return|return
name|Nullch
return|;
block|}
else|else
block|{
name|tmp
operator|=
name|littlelen
expr_stmt|;
comment|/* less expensive than calling strncmp() */
name|olds
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|tmp
operator|--
condition|)
block|{
if|if
condition|(
operator|*
operator|--
name|s
operator|==
operator|*
operator|--
name|little
condition|)
continue|continue;
name|s
operator|=
name|olds
operator|+
literal|1
expr_stmt|;
comment|/* here we pay the price for failure */
name|little
operator|=
name|oldlittle
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|bigend
condition|)
comment|/* fake up continue to outer loop */
goto|goto
name|top2
goto|;
return|return
name|Nullch
return|;
block|}
ifndef|#
directive|ifndef
name|lint
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
endif|#
directive|endif
block|}
block|}
block|}
return|return
name|Nullch
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|screaminstr
parameter_list|(
name|bigstr
parameter_list|,
name|littlestr
parameter_list|)
name|STR
modifier|*
name|bigstr
decl_stmt|;
name|STR
modifier|*
name|littlestr
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|x
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|big
decl_stmt|;
specifier|register
name|int
name|pos
decl_stmt|;
specifier|register
name|int
name|previous
decl_stmt|;
specifier|register
name|int
name|first
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|little
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|bigend
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|littleend
decl_stmt|;
if|if
condition|(
operator|(
name|pos
operator|=
name|screamfirst
index|[
name|littlestr
operator|->
name|str_rare
index|]
operator|)
operator|<
literal|0
condition|)
return|return
name|Nullch
return|;
ifndef|#
directive|ifndef
name|lint
name|little
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|littlestr
operator|->
name|str_ptr
operator|)
expr_stmt|;
else|#
directive|else
name|little
operator|=
name|Null
argument_list|(
argument|unsigned char *
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|littleend
operator|=
name|little
operator|+
name|littlestr
operator|->
name|str_cur
expr_stmt|;
name|first
operator|=
operator|*
name|little
operator|++
expr_stmt|;
name|previous
operator|=
name|littlestr
operator|->
name|str_state
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|big
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|bigstr
operator|->
name|str_ptr
operator|)
expr_stmt|;
else|#
directive|else
name|big
operator|=
name|Null
argument_list|(
argument|unsigned char*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bigend
operator|=
name|big
operator|+
name|bigstr
operator|->
name|str_cur
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|previous
condition|)
block|{
ifndef|#
directive|ifndef
name|lint
if|if
condition|(
operator|!
operator|(
name|pos
operator|+=
name|screamnext
index|[
name|pos
index|]
operator|)
condition|)
endif|#
directive|endif
return|return
name|Nullch
return|;
block|}
ifdef|#
directive|ifdef
name|POINTERRIGOR
if|if
condition|(
name|littlestr
operator|->
name|str_pok
operator|&
name|SP_CASEFOLD
condition|)
block|{
comment|/* case insignificant? */
do|do
block|{
if|if
condition|(
name|big
index|[
name|pos
operator|-
name|previous
index|]
operator|!=
name|first
operator|&&
name|big
index|[
name|pos
operator|-
name|previous
index|]
operator|!=
name|fold
index|[
name|first
index|]
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
name|big
operator|+
name|pos
operator|+
literal|1
operator|-
name|previous
operator|,
name|s
operator|=
name|little
init|;
name|s
operator|<
name|littleend
condition|;
comment|/**/
control|)
block|{
if|if
condition|(
name|x
operator|>=
name|bigend
condition|)
return|return
name|Nullch
return|;
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
operator|*
name|x
operator|++
operator|&&
name|fold
index|[
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
index|]
operator|!=
operator|*
operator|(
name|x
operator|-
literal|1
operator|)
condition|)
block|{
name|s
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|s
operator|==
name|littleend
condition|)
ifndef|#
directive|ifndef
name|lint
return|return
operator|(
name|char
operator|*
operator|)
operator|(
name|big
operator|+
name|pos
operator|-
name|previous
operator|)
return|;
else|#
directive|else
return|return
name|Nullch
return|;
endif|#
directive|endif
block|}
do|while
condition|(
ifndef|#
directive|ifndef
name|lint
name|pos
operator|+=
name|screamnext
index|[
name|pos
index|]
comment|/* does this goof up anywhere? */
else|#
directive|else
name|pos
operator|+=
name|screamnext
index|[
literal|0
index|]
endif|#
directive|endif
condition|)
do|;
block|}
else|else
block|{
do|do
block|{
if|if
condition|(
name|big
index|[
name|pos
operator|-
name|previous
index|]
operator|!=
name|first
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
name|big
operator|+
name|pos
operator|+
literal|1
operator|-
name|previous
operator|,
name|s
operator|=
name|little
init|;
name|s
operator|<
name|littleend
condition|;
comment|/**/
control|)
block|{
if|if
condition|(
name|x
operator|>=
name|bigend
condition|)
return|return
name|Nullch
return|;
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
operator|*
name|x
operator|++
condition|)
block|{
name|s
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|s
operator|==
name|littleend
condition|)
ifndef|#
directive|ifndef
name|lint
return|return
operator|(
name|char
operator|*
operator|)
operator|(
name|big
operator|+
name|pos
operator|-
name|previous
operator|)
return|;
else|#
directive|else
return|return
name|Nullch
return|;
endif|#
directive|endif
block|}
do|while
condition|(
ifndef|#
directive|ifndef
name|lint
name|pos
operator|+=
name|screamnext
index|[
name|pos
index|]
else|#
directive|else
name|pos
operator|+=
name|screamnext
index|[
literal|0
index|]
endif|#
directive|endif
condition|)
do|;
block|}
else|#
directive|else
comment|/* !POINTERRIGOR */
name|big
operator|-=
name|previous
expr_stmt|;
if|if
condition|(
name|littlestr
operator|->
name|str_pok
operator|&
name|SP_CASEFOLD
condition|)
block|{
comment|/* case insignificant? */
do|do
block|{
if|if
condition|(
name|big
index|[
name|pos
index|]
operator|!=
name|first
operator|&&
name|big
index|[
name|pos
index|]
operator|!=
name|fold
index|[
name|first
index|]
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
name|big
operator|+
name|pos
operator|+
literal|1
operator|,
name|s
operator|=
name|little
init|;
name|s
operator|<
name|littleend
condition|;
comment|/**/
control|)
block|{
if|if
condition|(
name|x
operator|>=
name|bigend
condition|)
return|return
name|Nullch
return|;
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
operator|*
name|x
operator|++
operator|&&
name|fold
index|[
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
index|]
operator|!=
operator|*
operator|(
name|x
operator|-
literal|1
operator|)
condition|)
block|{
name|s
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|s
operator|==
name|littleend
condition|)
ifndef|#
directive|ifndef
name|lint
return|return
operator|(
name|char
operator|*
operator|)
operator|(
name|big
operator|+
name|pos
operator|)
return|;
else|#
directive|else
return|return
name|Nullch
return|;
endif|#
directive|endif
block|}
do|while
condition|(
ifndef|#
directive|ifndef
name|lint
name|pos
operator|+=
name|screamnext
index|[
name|pos
index|]
comment|/* does this goof up anywhere? */
else|#
directive|else
name|pos
operator|+=
name|screamnext
index|[
literal|0
index|]
endif|#
directive|endif
condition|)
do|;
block|}
else|else
block|{
do|do
block|{
if|if
condition|(
name|big
index|[
name|pos
index|]
operator|!=
name|first
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
name|big
operator|+
name|pos
operator|+
literal|1
operator|,
name|s
operator|=
name|little
init|;
name|s
operator|<
name|littleend
condition|;
comment|/**/
control|)
block|{
if|if
condition|(
name|x
operator|>=
name|bigend
condition|)
return|return
name|Nullch
return|;
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
operator|*
name|x
operator|++
condition|)
block|{
name|s
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|s
operator|==
name|littleend
condition|)
ifndef|#
directive|ifndef
name|lint
return|return
operator|(
name|char
operator|*
operator|)
operator|(
name|big
operator|+
name|pos
operator|)
return|;
else|#
directive|else
return|return
name|Nullch
return|;
endif|#
directive|endif
block|}
do|while
condition|(
ifndef|#
directive|ifndef
name|lint
name|pos
operator|+=
name|screamnext
index|[
name|pos
index|]
else|#
directive|else
name|pos
operator|+=
name|screamnext
index|[
literal|0
index|]
endif|#
directive|endif
condition|)
do|;
block|}
endif|#
directive|endif
comment|/* POINTERRIGOR */
return|return
name|Nullch
return|;
block|}
end_function

begin_comment
comment|/* copy a string to a safe spot */
end_comment

begin_function
name|char
modifier|*
name|savestr
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|newaddr
decl_stmt|;
name|New
argument_list|(
literal|902
argument_list|,
name|newaddr
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|newaddr
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|newaddr
return|;
block|}
end_function

begin_comment
comment|/* same thing but with a known length */
end_comment

begin_function
name|char
modifier|*
name|nsavestr
parameter_list|(
name|str
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|newaddr
decl_stmt|;
name|New
argument_list|(
literal|903
argument_list|,
name|newaddr
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|str
argument_list|,
name|newaddr
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
comment|/* might not be null terminated */
name|newaddr
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* is now */
return|return
name|newaddr
return|;
block|}
end_function

begin_comment
comment|/* grow a static string to at least a certain length */
end_comment

begin_function
name|void
name|growstr
parameter_list|(
name|strptr
parameter_list|,
name|curlen
parameter_list|,
name|newlen
parameter_list|)
name|char
modifier|*
modifier|*
name|strptr
decl_stmt|;
name|int
modifier|*
name|curlen
decl_stmt|;
name|int
name|newlen
decl_stmt|;
block|{
if|if
condition|(
name|newlen
operator|>
operator|*
name|curlen
condition|)
block|{
comment|/* need more room? */
if|if
condition|(
operator|*
name|curlen
condition|)
name|Renew
argument_list|(
operator|*
name|strptr
argument_list|,
name|newlen
argument_list|,
name|char
argument_list|)
expr_stmt|;
else|else
name|New
argument_list|(
literal|905
argument_list|,
operator|*
name|strptr
argument_list|,
name|newlen
argument_list|,
name|char
argument_list|)
expr_stmt|;
operator|*
name|curlen
operator|=
name|newlen
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|I_VARARGS
end_ifndef

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
name|char
modifier|*
name|mess
parameter_list|(
name|pat
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|,
name|a3
parameter_list|,
name|a4
parameter_list|)
name|char
modifier|*
name|pat
decl_stmt|;
name|long
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|,
name|a4
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|usermess
init|=
name|strEQ
argument_list|(
name|pat
argument_list|,
literal|"%s"
argument_list|)
decl_stmt|;
name|STR
modifier|*
name|tmpstr
decl_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|usermess
condition|)
block|{
name|tmpstr
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_undef
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|tmpstr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|a1
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
name|tmpstr
operator|->
name|str_ptr
index|[
name|tmpstr
operator|->
name|str_cur
operator|-
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|s
argument_list|,
name|pat
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|curcmd
operator|->
name|c_line
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|s
argument_list|,
literal|" at %s line %ld"
argument_list|,
name|stab_val
argument_list|(
name|curcmd
operator|->
name|c_filestab
argument_list|)
operator|->
name|str_ptr
argument_list|,
operator|(
name|long
operator|)
name|curcmd
operator|->
name|c_line
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last_in_stab
operator|&&
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|&&
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|->
name|lines
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|s
argument_list|,
literal|",<%s> line %ld"
argument_list|,
name|last_in_stab
operator|==
name|argvstab
condition|?
literal|""
else|:
name|stab_ename
argument_list|(
name|last_in_stab
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|->
name|lines
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|s
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usermess
condition|)
name|str_cat
argument_list|(
name|tmpstr
argument_list|,
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usermess
condition|)
return|return
name|tmpstr
operator|->
name|str_ptr
return|;
else|else
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
name|void
name|fatal
parameter_list|(
name|pat
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|,
name|a3
parameter_list|,
name|a4
parameter_list|)
name|char
modifier|*
name|pat
decl_stmt|;
name|long
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|,
name|a4
decl_stmt|;
block|{
specifier|extern
name|FILE
modifier|*
name|e_fp
decl_stmt|;
specifier|extern
name|char
modifier|*
name|e_tmpname
decl_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
name|message
operator|=
name|mess
argument_list|(
name|pat
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_eval
condition|)
block|{
name|str_set
argument_list|(
name|stab_val
argument_list|(
name|stabent
argument_list|(
literal|"@"
argument_list|,
name|TRUE
argument_list|)
argument_list|)
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|tmps
operator|=
literal|"_EVAL_"
expr_stmt|;
while|while
condition|(
name|loop_ptr
operator|>=
literal|0
operator|&&
operator|(
operator|!
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_label
operator|||
name|strNE
argument_list|(
name|tmps
argument_list|,
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_label
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|4
condition|)
block|{
name|deb
argument_list|(
literal|"(Skipping label #%d %s)\n"
argument_list|,
name|loop_ptr
argument_list|,
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_label
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|loop_ptr
operator|--
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|4
condition|)
block|{
name|deb
argument_list|(
literal|"(Found label #%d %s)\n"
argument_list|,
name|loop_ptr
argument_list|,
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_label
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|loop_ptr
operator|<
literal|0
condition|)
block|{
name|in_eval
operator|=
literal|0
expr_stmt|;
name|fatal
argument_list|(
literal|"Bad label: %s"
argument_list|,
name|tmps
argument_list|)
expr_stmt|;
block|}
name|longjmp
argument_list|(
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
name|message
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_fp
condition|)
operator|(
name|void
operator|)
name|UNLINK
argument_list|(
name|e_tmpname
argument_list|)
expr_stmt|;
name|statusvalue
operator|>>=
literal|8
expr_stmt|;
name|exit
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
name|errno
operator|&
literal|255
operator|)
condition|?
name|errno
else|:
operator|(
operator|(
name|statusvalue
operator|&
literal|255
operator|)
condition|?
name|statusvalue
else|:
literal|255
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
name|void
name|warn
parameter_list|(
name|pat
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|,
name|a3
parameter_list|,
name|a4
parameter_list|)
name|char
modifier|*
name|pat
decl_stmt|;
name|long
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|,
name|a4
decl_stmt|;
block|{
name|char
modifier|*
name|message
decl_stmt|;
name|message
operator|=
name|mess
argument_list|(
name|pat
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|message
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAKTEST
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|4096
condition|)
name|xstat
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*VARARGS0*/
end_comment

begin_function
name|char
modifier|*
name|mess
parameter_list|(
name|args
parameter_list|)
name|va_list
name|args
decl_stmt|;
block|{
name|char
modifier|*
name|pat
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|STR
modifier|*
name|tmpstr
decl_stmt|;
name|int
name|usermess
decl_stmt|;
name|size_t
name|l
decl_stmt|;
ifndef|#
directive|ifndef
name|HAS_VPRINTF
ifdef|#
directive|ifdef
name|CHARVSPRINTF
name|char
modifier|*
name|vsprintf
parameter_list|()
function_decl|;
else|#
directive|else
name|int
name|vsprintf
parameter_list|()
function_decl|;
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|lint
name|pat
operator|=
name|Nullch
expr_stmt|;
else|#
directive|else
name|pat
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|buf
expr_stmt|;
name|usermess
operator|=
name|strEQ
argument_list|(
name|pat
argument_list|,
literal|"%s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usermess
condition|)
block|{
name|tmpstr
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_undef
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|tmpstr
argument_list|,
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|s
operator|++
operator|=
name|tmpstr
operator|->
name|str_ptr
index|[
name|tmpstr
operator|->
name|str_cur
operator|-
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|vsnprintf
argument_list|(
name|s
argument_list|,
sizeof|sizeof
name|buf
operator|-
operator|(
name|s
operator|-
name|buf
operator|)
argument_list|,
name|pat
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|curcmd
operator|->
name|c_line
condition|)
block|{
name|l
operator|=
name|s
operator|-
name|buf
operator|>=
sizeof|sizeof
name|buf
operator|-
literal|1
condition|?
literal|1
else|:
sizeof|sizeof
name|buf
operator|-
operator|(
name|s
operator|-
name|buf
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|s
argument_list|,
name|l
argument_list|,
literal|" at %s line %ld"
argument_list|,
name|stab_val
argument_list|(
name|curcmd
operator|->
name|c_filestab
argument_list|)
operator|->
name|str_ptr
argument_list|,
operator|(
name|long
operator|)
name|curcmd
operator|->
name|c_line
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|last_in_stab
operator|&&
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|&&
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|->
name|lines
condition|)
block|{
name|l
operator|=
name|s
operator|-
name|buf
operator|>=
sizeof|sizeof
name|buf
operator|-
literal|1
condition|?
literal|1
else|:
sizeof|sizeof
name|buf
operator|-
operator|(
name|s
operator|-
name|buf
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|s
argument_list|,
name|l
argument_list|,
literal|",<%s> line %ld"
argument_list|,
name|last_in_stab
operator|==
name|argvstab
condition|?
literal|""
else|:
name|last_in_stab
operator|->
name|str_magic
operator|->
name|str_ptr
argument_list|,
operator|(
name|long
operator|)
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|->
name|lines
argument_list|)
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|-
name|buf
operator|>
sizeof|sizeof
name|buf
operator|-
literal|3
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|s
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usermess
condition|)
name|str_cat
argument_list|(
name|tmpstr
argument_list|,
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usermess
condition|)
return|return
name|tmpstr
operator|->
name|str_ptr
return|;
else|else
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/*VARARGS0*/
end_comment

begin_function
name|void
name|fatal
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
specifier|extern
name|FILE
modifier|*
name|e_fp
decl_stmt|;
specifier|extern
name|char
modifier|*
name|e_tmpname
decl_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
ifndef|#
directive|ifndef
name|lint
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
else|#
directive|else
name|args
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|message
operator|=
name|mess
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_eval
condition|)
block|{
name|str_set
argument_list|(
name|stab_val
argument_list|(
name|stabent
argument_list|(
literal|"@"
argument_list|,
name|TRUE
argument_list|)
argument_list|)
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|tmps
operator|=
literal|"_EVAL_"
expr_stmt|;
while|while
condition|(
name|loop_ptr
operator|>=
literal|0
operator|&&
operator|(
operator|!
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_label
operator|||
name|strNE
argument_list|(
name|tmps
argument_list|,
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_label
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|4
condition|)
block|{
name|deb
argument_list|(
literal|"(Skipping label #%d %s)\n"
argument_list|,
name|loop_ptr
argument_list|,
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_label
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|loop_ptr
operator|--
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|4
condition|)
block|{
name|deb
argument_list|(
literal|"(Found label #%d %s)\n"
argument_list|,
name|loop_ptr
argument_list|,
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_label
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|loop_ptr
operator|<
literal|0
condition|)
block|{
name|in_eval
operator|=
literal|0
expr_stmt|;
name|fatal
argument_list|(
literal|"Bad label: %s"
argument_list|,
name|tmps
argument_list|)
expr_stmt|;
block|}
name|longjmp
argument_list|(
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
name|message
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_fp
condition|)
operator|(
name|void
operator|)
name|UNLINK
argument_list|(
name|e_tmpname
argument_list|)
expr_stmt|;
name|statusvalue
operator|>>=
literal|8
expr_stmt|;
name|exit
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
name|errno
operator|&
literal|255
operator|)
condition|?
name|errno
else|:
operator|(
operator|(
name|statusvalue
operator|&
literal|255
operator|)
condition|?
name|statusvalue
else|:
literal|255
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*VARARGS0*/
end_comment

begin_function
name|void
name|warn
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|message
decl_stmt|;
ifndef|#
directive|ifndef
name|lint
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
else|#
directive|else
name|args
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|message
operator|=
name|mess
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|message
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAKTEST
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|4096
condition|)
name|xstat
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|my_setenv
parameter_list|(
name|nam
parameter_list|,
name|val
parameter_list|)
name|char
modifier|*
name|nam
decl_stmt|,
decl|*
name|val
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
init|=
name|envix
argument_list|(
name|nam
argument_list|)
decl_stmt|;
comment|/* where does it go? */
if|if
condition|(
name|environ
operator|==
name|origenviron
condition|)
block|{
comment|/* need we copy environment? */
name|int
name|j
decl_stmt|;
name|int
name|max
decl_stmt|;
name|char
modifier|*
modifier|*
name|tmpenv
decl_stmt|;
comment|/*SUPPRESS 530*/
for|for
control|(
name|max
operator|=
name|i
init|;
name|environ
index|[
name|max
index|]
condition|;
name|max
operator|++
control|)
empty_stmt|;
name|New
argument_list|(
literal|901
argument_list|,
name|tmpenv
argument_list|,
name|max
operator|+
literal|2
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|max
condition|;
name|j
operator|++
control|)
comment|/* copy environment */
name|tmpenv
index|[
name|j
index|]
operator|=
name|savestr
argument_list|(
name|environ
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|tmpenv
index|[
name|max
index|]
operator|=
name|Nullch
expr_stmt|;
name|environ
operator|=
name|tmpenv
expr_stmt|;
comment|/* tell exec where it is now */
block|}
if|if
condition|(
operator|!
name|val
condition|)
block|{
while|while
condition|(
name|environ
index|[
name|i
index|]
condition|)
block|{
name|environ
index|[
name|i
index|]
operator|=
name|environ
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|!
name|environ
index|[
name|i
index|]
condition|)
block|{
comment|/* does not exist yet */
name|Renew
argument_list|(
name|environ
argument_list|,
name|i
operator|+
literal|2
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* just expand it a bit */
name|environ
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|Nullch
expr_stmt|;
comment|/* make sure it's null terminated */
block|}
else|else
name|Safefree
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|904
argument_list|,
name|environ
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|nam
argument_list|)
operator|+
name|strlen
argument_list|(
name|val
argument_list|)
operator|+
literal|2
argument_list|,
name|char
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|,
literal|"%s=%s"
argument_list|,
name|nam
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* all that work just for this */
else|#
directive|else
comment|/* MS-DOS requires environment variable names to be in uppercase */
comment|/* [Tom Dinger, 27 August 1990: Well, it doesn't _require_ it, but      * some utilities and applications may break because they only look      * for upper case strings. (Fixed strupr() bug here.)]      */
name|strcpy
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|,
name|nam
argument_list|)
expr_stmt|;
name|strupr
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|environ
index|[
name|i
index|]
operator|+
name|strlen
argument_list|(
name|nam
argument_list|)
argument_list|,
literal|"=%s"
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
block|}
end_block

begin_function
name|int
name|envix
parameter_list|(
name|nam
parameter_list|)
name|char
modifier|*
name|nam
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|len
init|=
name|strlen
argument_list|(
name|nam
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|environ
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strnEQ
argument_list|(
name|environ
index|[
name|i
index|]
argument_list|,
name|nam
argument_list|,
name|len
argument_list|)
operator|&&
name|environ
index|[
name|i
index|]
index|[
name|len
index|]
operator|==
literal|'='
condition|)
break|break;
comment|/* strnEQ must come first to avoid */
block|}
comment|/* potential SEGV's */
return|return
name|i
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|EUNICE
end_ifdef

begin_function
name|int
name|unlnk
parameter_list|(
name|f
parameter_list|)
comment|/* unlink all versions of a file */
name|char
modifier|*
name|f
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|unlink
argument_list|(
name|f
argument_list|)
operator|>=
literal|0
condition|;
name|i
operator|++
control|)
empty_stmt|;
return|return
name|i
condition|?
literal|0
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_BCOPY
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|SAFE_BCOPY
argument_list|)
end_if

begin_function
name|char
modifier|*
name|my_bcopy
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|from
decl_stmt|;
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|retval
init|=
name|to
decl_stmt|;
if|if
condition|(
name|from
operator|-
name|to
operator|>=
literal|0
condition|)
block|{
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
block|}
else|else
block|{
name|to
operator|+=
name|len
expr_stmt|;
name|from
operator|+=
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
operator|*
operator|(
operator|--
name|to
operator|)
operator|=
operator|*
operator|(
operator|--
name|from
operator|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_BZERO
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAS_MEMSET
argument_list|)
end_if

begin_function
name|char
modifier|*
name|my_bzero
parameter_list|(
name|loc
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|loc
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|retval
init|=
name|loc
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
operator|*
name|loc
operator|++
operator|=
literal|0
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_MEMCMP
end_ifndef

begin_function
name|int
name|my_memcmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|len
parameter_list|)
specifier|register
name|unsigned
name|char
modifier|*
name|s1
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|s2
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|int
name|tmp
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
if|if
condition|(
name|tmp
operator|=
operator|*
name|s1
operator|++
operator|-
operator|*
name|s2
operator|++
condition|)
return|return
name|tmp
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAS_MEMCMP */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|I_VARARGS
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_VPRINTF
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|CHARVSPRINTF
end_ifdef

begin_function
name|char
modifier|*
else|#
directive|else
name|int
endif|#
directive|endif
name|vsprintf
parameter_list|(
name|dest
parameter_list|,
name|pat
parameter_list|,
name|args
parameter_list|)
name|char
modifier|*
name|dest
decl_stmt|,
decl|*
name|pat
decl_stmt|,
modifier|*
name|args
decl_stmt|;
end_function

begin_block
block|{
name|FILE
name|fakebuf
decl_stmt|;
name|fakebuf
operator|.
name|_ptr
operator|=
name|dest
expr_stmt|;
name|fakebuf
operator|.
name|_cnt
operator|=
literal|32767
expr_stmt|;
ifndef|#
directive|ifndef
name|_IOSTRG
define|#
directive|define
name|_IOSTRG
value|0
endif|#
directive|endif
name|fakebuf
operator|.
name|_flag
operator|=
name|_IOWRT
operator||
name|_IOSTRG
expr_stmt|;
name|_doprnt
argument_list|(
name|pat
argument_list|,
name|args
argument_list|,
operator|&
name|fakebuf
argument_list|)
expr_stmt|;
comment|/* what a kludge */
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\0'
argument_list|,
operator|&
name|fakebuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CHARVSPRINTF
return|return
operator|(
name|dest
operator|)
return|;
else|#
directive|else
return|return
literal|0
return|;
comment|/* perl doesn't use return value */
endif|#
directive|endif
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING
end_ifdef

begin_function
name|int
name|vfprintf
parameter_list|(
name|fd
parameter_list|,
name|pat
parameter_list|,
name|args
parameter_list|)
name|FILE
modifier|*
name|fd
decl_stmt|;
name|char
modifier|*
name|pat
decl_stmt|,
decl|*
name|args
decl_stmt|;
end_function

begin_block
block|{
name|_doprnt
argument_list|(
name|pat
argument_list|,
name|args
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* wrong, but perl doesn't use the return value */
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAS_VPRINTF */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* I_VARARGS */
end_comment

begin_comment
comment|/*  * I think my_swap(), htonl() and ntohl() have never been used.  * perl.h contains last-chance references to my_swap(), my_htonl()  * and my_ntohl().  I presume these are the intended functions;  * but htonl() and ntohl() have the wrong names.  There are no  * functions my_htonl() and my_ntohl() defined anywhere.  * -DWS  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MYSWAP
end_ifdef

begin_if
if|#
directive|if
name|BYTEORDER
operator|!=
literal|0x4321
end_if

begin_function
name|short
name|my_swap
parameter_list|(
name|s
parameter_list|)
name|short
name|s
decl_stmt|;
block|{
if|#
directive|if
operator|(
name|BYTEORDER
operator|&
literal|1
operator|)
operator|==
literal|0
name|short
name|result
decl_stmt|;
name|result
operator|=
operator|(
operator|(
name|s
operator|&
literal|255
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|s
operator|>>
literal|8
operator|)
operator|&
literal|255
operator|)
expr_stmt|;
return|return
name|result
return|;
else|#
directive|else
return|return
name|s
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|long
name|htonl
parameter_list|(
name|l
parameter_list|)
specifier|register
name|long
name|l
decl_stmt|;
block|{
union|union
block|{
name|long
name|result
decl_stmt|;
name|char
name|c
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
decl_stmt|;
block|}
name|u
union|;
if|#
directive|if
name|BYTEORDER
operator|==
literal|0x1234
name|u
operator|.
name|c
index|[
literal|0
index|]
operator|=
operator|(
name|l
operator|>>
literal|24
operator|)
operator|&
literal|255
expr_stmt|;
name|u
operator|.
name|c
index|[
literal|1
index|]
operator|=
operator|(
name|l
operator|>>
literal|16
operator|)
operator|&
literal|255
expr_stmt|;
name|u
operator|.
name|c
index|[
literal|2
index|]
operator|=
operator|(
name|l
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
name|u
operator|.
name|c
index|[
literal|3
index|]
operator|=
name|l
operator|&
literal|255
expr_stmt|;
return|return
name|u
operator|.
name|result
return|;
else|#
directive|else
if|#
directive|if
operator|(
operator|(
name|BYTEORDER
operator|-
literal|0x1111
operator|)
operator|&
literal|0x444
operator|)
operator|||
operator|!
operator|(
name|BYTEORDER
operator|&
literal|0xf
operator|)
name|fatal
argument_list|(
literal|"Unknown BYTEORDER\n"
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|register
name|int
name|o
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
for|for
control|(
name|o
operator|=
name|BYTEORDER
operator|-
literal|0x1111
operator|,
name|s
operator|=
literal|0
init|;
name|s
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
literal|8
operator|)
condition|;
name|o
operator|>>=
literal|4
operator|,
name|s
operator|+=
literal|8
control|)
block|{
name|u
operator|.
name|c
index|[
name|o
operator|&
literal|0xf
index|]
operator|=
operator|(
name|l
operator|>>
name|s
operator|)
operator|&
literal|255
expr_stmt|;
block|}
return|return
name|u
operator|.
name|result
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_function
name|long
name|ntohl
parameter_list|(
name|l
parameter_list|)
specifier|register
name|long
name|l
decl_stmt|;
block|{
union|union
block|{
name|long
name|l
decl_stmt|;
name|char
name|c
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
decl_stmt|;
block|}
name|u
union|;
if|#
directive|if
name|BYTEORDER
operator|==
literal|0x1234
name|u
operator|.
name|c
index|[
literal|0
index|]
operator|=
operator|(
name|l
operator|>>
literal|24
operator|)
operator|&
literal|255
expr_stmt|;
name|u
operator|.
name|c
index|[
literal|1
index|]
operator|=
operator|(
name|l
operator|>>
literal|16
operator|)
operator|&
literal|255
expr_stmt|;
name|u
operator|.
name|c
index|[
literal|2
index|]
operator|=
operator|(
name|l
operator|>>
literal|8
operator|)
operator|&
literal|255
expr_stmt|;
name|u
operator|.
name|c
index|[
literal|3
index|]
operator|=
name|l
operator|&
literal|255
expr_stmt|;
return|return
name|u
operator|.
name|l
return|;
else|#
directive|else
if|#
directive|if
operator|(
operator|(
name|BYTEORDER
operator|-
literal|0x1111
operator|)
operator|&
literal|0x444
operator|)
operator|||
operator|!
operator|(
name|BYTEORDER
operator|&
literal|0xf
operator|)
name|fatal
argument_list|(
literal|"Unknown BYTEORDER\n"
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|register
name|int
name|o
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|u
operator|.
name|l
operator|=
name|l
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|o
operator|=
name|BYTEORDER
operator|-
literal|0x1111
operator|,
name|s
operator|=
literal|0
init|;
name|s
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
literal|8
operator|)
condition|;
name|o
operator|>>=
literal|4
operator|,
name|s
operator|+=
literal|8
control|)
block|{
name|l
operator||=
operator|(
name|u
operator|.
name|c
index|[
name|o
operator|&
literal|0xf
index|]
operator|&
literal|255
operator|)
operator|<<
name|s
expr_stmt|;
block|}
return|return
name|l
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BYTEORDER != 0x4321 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MYSWAP */
end_comment

begin_comment
comment|/*  * Little-endian byte order functions - 'v' for 'VAX', or 'reVerse'.  * If these functions are defined,  * the BYTEORDER is neither 0x1234 nor 0x4321.  * However, this is not assumed.  * -DWS  */
end_comment

begin_define
define|#
directive|define
name|HTOV
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
define|\
value|type							\ 	name (n)						\ 	register type n;					\ 	{							\ 	    union {						\ 		type value;					\ 		char c[sizeof(type)];				\ 	    } u;						\ 	    register int i;					\ 	    register int s;					\ 	    for (i = 0, s = 0; i< sizeof(u.c); i++, s += 8) {	\ 		u.c[i] = (n>> s)& 0xFF;			\ 	    }							\ 	    return u.value;					\ 	}
end_define

begin_define
define|#
directive|define
name|VTOH
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
define|\
value|type							\ 	name (n)						\ 	register type n;					\ 	{							\ 	    union {						\ 		type value;					\ 		char c[sizeof(type)];				\ 	    } u;						\ 	    register int i;					\ 	    register int s;					\ 	    u.value = n;					\ 	    n = 0;						\ 	    for (i = 0, s = 0; i< sizeof(u.c); i++, s += 8) {	\ 		n += (u.c[i]& 0xFF)<< s;			\ 	    }							\ 	    return n;						\ 	}
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_HTOVS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|htovs
argument_list|)
end_if

begin_macro
name|HTOV
argument_list|(
argument|htovs
argument_list|,
argument|short
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_HTOVL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|htovl
argument_list|)
end_if

begin_macro
name|HTOV
argument_list|(
argument|htovl
argument_list|,
argument|long
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_VTOHS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|vtohs
argument_list|)
end_if

begin_macro
name|VTOH
argument_list|(
argument|vtohs
argument_list|,
argument|short
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAS_VTOHL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|vtohl
argument_list|)
end_if

begin_macro
name|VTOH
argument_list|(
argument|vtohl
argument_list|,
argument|long
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DOSISH
end_ifndef

begin_function
name|FILE
modifier|*
name|mypopen
parameter_list|(
name|cmd
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
name|char
modifier|*
name|mode
decl_stmt|;
block|{
name|int
name|p
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|int
name|this
decl_stmt|,
name|that
decl_stmt|;
specifier|register
name|int
name|pid
decl_stmt|;
name|STR
modifier|*
name|str
decl_stmt|;
name|int
name|doexec
init|=
name|strNE
argument_list|(
name|cmd
argument_list|,
literal|"-"
argument_list|)
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
return|return
name|Nullfp
return|;
name|this
operator|=
operator|(
operator|*
name|mode
operator|==
literal|'w'
operator|)
expr_stmt|;
name|that
operator|=
operator|!
name|this
expr_stmt|;
ifdef|#
directive|ifdef
name|TAINT
if|if
condition|(
name|doexec
condition|)
block|{
name|taintenv
argument_list|()
expr_stmt|;
name|taintproper
argument_list|(
literal|"Insecure dependency in exec"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
operator|(
name|pid
operator|=
operator|(
name|doexec
condition|?
name|vfork
argument_list|()
else|:
name|fork
argument_list|()
operator|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EAGAIN
condition|)
block|{
name|close
argument_list|(
name|p
index|[
name|this
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|doexec
condition|)
name|fatal
argument_list|(
literal|"Can't fork"
argument_list|)
expr_stmt|;
return|return
name|Nullfp
return|;
block|}
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
define|#
directive|define
name|THIS
value|that
define|#
directive|define
name|THAT
value|this
name|close
argument_list|(
name|p
index|[
name|THAT
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
name|THIS
index|]
operator|!=
operator|(
operator|*
name|mode
operator|==
literal|'r'
operator|)
condition|)
block|{
name|dup2
argument_list|(
name|p
index|[
name|THIS
index|]
argument_list|,
operator|*
name|mode
operator|==
literal|'r'
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
index|[
name|THIS
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doexec
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|F_SETFD
argument_list|)
name|int
name|fd
decl_stmt|;
ifndef|#
directive|ifndef
name|NOFILE
define|#
directive|define
name|NOFILE
value|20
endif|#
directive|endif
for|for
control|(
name|fd
operator|=
name|maxsysfd
operator|+
literal|1
init|;
name|fd
operator|<
name|NOFILE
condition|;
name|fd
operator|++
control|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|do_exec
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|/* may or may not use the shell */
name|warn
argument_list|(
literal|"Can't exec \"%s\": %s"
argument_list|,
name|cmd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*SUPPRESS 560*/
if|if
condition|(
name|tmpstab
operator|=
name|stabent
argument_list|(
literal|"$"
argument_list|,
name|allstabs
argument_list|)
condition|)
name|str_numset
argument_list|(
name|STAB_STR
argument_list|(
name|tmpstab
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|forkprocess
operator|=
literal|0
expr_stmt|;
name|hclear
argument_list|(
name|pidstatus
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* we have no children */
return|return
name|Nullfp
return|;
undef|#
directive|undef
name|THIS
undef|#
directive|undef
name|THAT
block|}
name|do_execfree
argument_list|()
expr_stmt|;
comment|/* free any memory malloced by child on vfork */
name|close
argument_list|(
name|p
index|[
name|that
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
name|that
index|]
operator|<
name|p
index|[
name|this
index|]
condition|)
block|{
name|dup2
argument_list|(
name|p
index|[
name|this
index|]
argument_list|,
name|p
index|[
name|that
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
index|[
name|this
index|]
argument_list|)
expr_stmt|;
name|p
index|[
name|this
index|]
operator|=
name|p
index|[
name|that
index|]
expr_stmt|;
block|}
name|str
operator|=
name|afetch
argument_list|(
name|fdpid
argument_list|,
name|p
index|[
name|this
index|]
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_u
operator|.
name|str_useful
operator|=
name|pid
expr_stmt|;
name|forkprocess
operator|=
name|pid
expr_stmt|;
return|return
name|fdopen
argument_list|(
name|p
index|[
name|this
index|]
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|atarist
end_ifdef

begin_function_decl
name|FILE
modifier|*
name|popen
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|FILE
modifier|*
name|mypopen
parameter_list|(
name|cmd
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
name|char
modifier|*
name|mode
decl_stmt|;
block|{
return|return
name|popen
argument_list|(
name|cmd
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DOSISH */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NOTDEF
end_ifdef

begin_macro
name|dumpfds
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|stat
name|tmpstatbuf
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|fd
operator|=
literal|0
init|;
name|fd
operator|<
literal|32
condition|;
name|fd
operator|++
control|)
block|{
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|tmpstatbuf
argument_list|)
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %d"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_DUP2
end_ifndef

begin_macro
name|dup2
argument_list|(
argument|oldfd
argument_list|,
argument|newfd
argument_list|)
end_macro

begin_decl_stmt
name|int
name|oldfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|newfd
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAS_FCNTL
argument_list|)
operator|&&
name|defined
argument_list|(
name|F_DUPFD
argument_list|)
name|close
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|oldfd
argument_list|,
name|F_DUPFD
argument_list|,
name|newfd
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|fdtmp
index|[
literal|256
index|]
decl_stmt|;
name|int
name|fdx
init|=
literal|0
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|oldfd
operator|==
name|newfd
condition|)
return|return
literal|0
return|;
name|close
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|fd
operator|=
name|dup
argument_list|(
name|oldfd
argument_list|)
operator|)
operator|!=
name|newfd
condition|)
comment|/* good enough for low fd's */
name|fdtmp
index|[
name|fdx
operator|++
index|]
operator|=
name|fd
expr_stmt|;
while|while
condition|(
name|fdx
operator|>
literal|0
condition|)
name|close
argument_list|(
name|fdtmp
index|[
operator|--
name|fdx
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DOSISH
end_ifndef

begin_function
name|int
name|mypclose
parameter_list|(
name|ptr
parameter_list|)
name|FILE
modifier|*
name|ptr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|VOIDSIG
name|void
argument_list|(
operator|*
name|hstat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|istat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|qstat
argument_list|)
argument_list|()
decl_stmt|;
else|#
directive|else
name|int
argument_list|(
operator|*
name|hstat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|istat
argument_list|)
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|qstat
argument_list|)
argument_list|()
decl_stmt|;
endif|#
directive|endif
name|int
name|status
decl_stmt|;
name|STR
modifier|*
name|str
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|str
operator|=
name|afetch
argument_list|(
name|fdpid
argument_list|,
name|fileno
argument_list|(
name|ptr
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|pid
operator|=
operator|(
name|int
operator|)
name|str
operator|->
name|str_u
operator|.
name|str_useful
expr_stmt|;
name|astore
argument_list|(
name|fdpid
argument_list|,
name|fileno
argument_list|(
name|ptr
argument_list|)
argument_list|,
name|Nullstr
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UTS
if|if
condition|(
name|kill
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|pid
operator|)
return|;
block|}
comment|/* HOM 12/23/91 */
endif|#
directive|endif
name|hstat
operator|=
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|istat
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|qstat
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|pid
operator|=
name|wait4pid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|hstat
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|istat
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qstat
argument_list|)
expr_stmt|;
return|return
operator|(
name|pid
operator|<
literal|0
condition|?
name|pid
else|:
name|status
operator|)
return|;
block|}
end_function

begin_function
name|int
name|wait4pid
parameter_list|(
name|pid
parameter_list|,
name|statusp
parameter_list|,
name|flags
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|statusp
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_WAIT4
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAS_WAITPID
argument_list|)
name|int
name|result
decl_stmt|;
name|STR
modifier|*
name|str
decl_stmt|;
name|char
name|spid
index|[
literal|16
index|]
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|pid
condition|)
return|return
operator|-
literal|1
return|;
ifdef|#
directive|ifdef
name|HAS_WAIT4
return|return
name|wait4
argument_list|(
operator|(
name|pid
operator|==
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
name|pid
argument_list|,
name|statusp
argument_list|,
name|flags
argument_list|,
name|Null
argument_list|(
expr|struct
name|rusage
operator|*
argument_list|)
argument_list|)
return|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_WAITPID
return|return
name|waitpid
argument_list|(
name|pid
argument_list|,
name|statusp
argument_list|,
name|flags
argument_list|)
return|;
else|#
directive|else
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|spid
argument_list|,
literal|"%d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|str
operator|=
name|hfetch
argument_list|(
name|pidstatus
argument_list|,
name|spid
argument_list|,
name|strlen
argument_list|(
name|spid
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|!=
operator|&
name|str_undef
condition|)
block|{
operator|*
name|statusp
operator|=
operator|(
name|int
operator|)
name|str
operator|->
name|str_u
operator|.
name|str_useful
expr_stmt|;
name|hdelete
argument_list|(
name|pidstatus
argument_list|,
name|spid
argument_list|,
name|strlen
argument_list|(
name|spid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pid
return|;
block|}
block|}
else|else
block|{
name|HENT
modifier|*
name|entry
decl_stmt|;
name|hiterinit
argument_list|(
name|pidstatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|=
name|hiternext
argument_list|(
name|pidstatus
argument_list|)
condition|)
block|{
name|pid
operator|=
name|atoi
argument_list|(
name|hiterkey
argument_list|(
name|entry
argument_list|,
name|statusp
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|=
name|hiterval
argument_list|(
name|pidstatus
argument_list|,
name|entry
argument_list|)
expr_stmt|;
operator|*
name|statusp
operator|=
operator|(
name|int
operator|)
name|str
operator|->
name|str_u
operator|.
name|str_useful
expr_stmt|;
name|sprintf
argument_list|(
name|spid
argument_list|,
literal|"%d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|hdelete
argument_list|(
name|pidstatus
argument_list|,
name|spid
argument_list|,
name|strlen
argument_list|(
name|spid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pid
return|;
block|}
block|}
if|if
condition|(
name|flags
condition|)
name|fatal
argument_list|(
literal|"Can't do waitpid with flags"
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|(
name|result
operator|=
name|wait
argument_list|(
name|statusp
argument_list|)
operator|)
operator|!=
name|pid
operator|&&
name|pid
operator|>
literal|0
operator|&&
name|result
operator|>=
literal|0
condition|)
name|pidgone
argument_list|(
name|result
argument_list|,
operator|*
name|statusp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
operator|*
name|statusp
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DOSISH */
end_comment

begin_function
name|void
comment|/*SUPPRESS 590*/
name|pidgone
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAS_WAIT4
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_WAITPID
argument_list|)
else|#
directive|else
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
name|char
name|spid
index|[
literal|16
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|spid
argument_list|,
literal|"%d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|str
operator|=
name|hfetch
argument_list|(
name|pidstatus
argument_list|,
name|spid
argument_list|,
name|strlen
argument_list|(
name|spid
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_u
operator|.
name|str_useful
operator|=
name|status
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|atarist
end_ifdef

begin_function_decl
name|int
name|pclose
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|mypclose
parameter_list|(
name|ptr
parameter_list|)
name|FILE
modifier|*
name|ptr
decl_stmt|;
block|{
return|return
name|pclose
argument_list|(
name|ptr
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|repeatcpy
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|len
parameter_list|,
name|count
parameter_list|)
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
specifier|register
name|char
modifier|*
name|from
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
block|{
specifier|register
name|int
name|todo
decl_stmt|;
specifier|register
name|char
modifier|*
name|frombase
init|=
name|from
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
name|todo
operator|=
operator|*
name|from
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
operator|*
name|to
operator|++
operator|=
name|todo
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|todo
operator|=
name|len
init|;
name|todo
operator|>
literal|0
condition|;
name|todo
operator|--
control|)
block|{
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
block|}
name|from
operator|=
name|frombase
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|CASTNEGFLOAT
end_ifndef

begin_function
name|unsigned
name|long
name|castulong
parameter_list|(
name|f
parameter_list|)
name|double
name|f
decl_stmt|;
block|{
name|long
name|along
decl_stmt|;
if|#
directive|if
name|CASTFLAGS
operator|&
literal|2
define|#
directive|define
name|BIGDOUBLE
value|2147483648.0
if|if
condition|(
name|f
operator|>=
name|BIGDOUBLE
condition|)
return|return
call|(
name|unsigned
name|long
call|)
argument_list|(
name|f
operator|-
call|(
name|long
call|)
argument_list|(
name|f
operator|/
name|BIGDOUBLE
argument_list|)
operator|*
name|BIGDOUBLE
argument_list|)
operator||
literal|0x80000000
return|;
endif|#
directive|endif
if|if
condition|(
name|f
operator|>=
literal|0.0
condition|)
return|return
operator|(
name|unsigned
name|long
operator|)
name|f
return|;
name|along
operator|=
operator|(
name|long
operator|)
name|f
expr_stmt|;
return|return
operator|(
name|unsigned
name|long
operator|)
name|along
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HAS_RENAME
end_ifndef

begin_function
name|int
name|same_dirent
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|char
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
block|{
name|char
modifier|*
name|fa
init|=
name|rindex
argument_list|(
name|a
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|fb
init|=
name|rindex
argument_list|(
name|b
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|struct
name|stat
name|tmpstatbuf1
decl_stmt|;
name|struct
name|stat
name|tmpstatbuf2
decl_stmt|;
ifndef|#
directive|ifndef
name|MAXPATHLEN
define|#
directive|define
name|MAXPATHLEN
value|1024
endif|#
directive|endif
name|char
name|tmpbuf
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|fa
condition|)
name|fa
operator|++
expr_stmt|;
else|else
name|fa
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|fb
condition|)
name|fb
operator|++
expr_stmt|;
else|else
name|fb
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|strNE
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fa
operator|==
name|a
condition|)
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
else|else
name|strncpy
argument_list|(
name|tmpbuf
argument_list|,
name|a
argument_list|,
name|fa
operator|-
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|tmpbuf
argument_list|,
operator|&
name|tmpstatbuf1
argument_list|)
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|fb
operator|==
name|b
condition|)
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
else|else
name|strncpy
argument_list|(
name|tmpbuf
argument_list|,
name|b
argument_list|,
name|fb
operator|-
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|tmpbuf
argument_list|,
operator|&
name|tmpstatbuf2
argument_list|)
operator|<
literal|0
condition|)
return|return
name|FALSE
return|;
return|return
name|tmpstatbuf1
operator|.
name|st_dev
operator|==
name|tmpstatbuf2
operator|.
name|st_dev
operator|&&
name|tmpstatbuf1
operator|.
name|st_ino
operator|==
name|tmpstatbuf2
operator|.
name|st_ino
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAS_RENAME */
end_comment

begin_function
name|unsigned
name|long
name|scanoct
parameter_list|(
name|start
parameter_list|,
name|len
parameter_list|,
name|retlen
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
modifier|*
name|retlen
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|start
decl_stmt|;
specifier|register
name|unsigned
name|long
name|retval
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|--
operator|&&
operator|*
name|s
operator|>=
literal|'0'
operator|&&
operator|*
name|s
operator|<=
literal|'7'
condition|)
block|{
name|retval
operator|<<=
literal|3
expr_stmt|;
name|retval
operator||=
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
operator|*
name|retlen
operator|=
name|s
operator|-
name|start
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|scanhex
parameter_list|(
name|start
parameter_list|,
name|len
parameter_list|,
name|retlen
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
modifier|*
name|retlen
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|start
decl_stmt|;
specifier|register
name|unsigned
name|long
name|retval
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
while|while
condition|(
name|len
operator|--
operator|&&
operator|*
name|s
operator|&&
operator|(
name|tmp
operator|=
name|index
argument_list|(
name|hexdigit
argument_list|,
operator|*
name|s
argument_list|)
operator|)
condition|)
block|{
name|retval
operator|<<=
literal|4
expr_stmt|;
name|retval
operator||=
operator|(
name|tmp
operator|-
name|hexdigit
operator|)
operator|&
literal|15
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|retlen
operator|=
name|s
operator|-
name|start
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

end_unit

