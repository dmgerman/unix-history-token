begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $RCSfile: str.c,v $$Revision: 1.2.6.1 $$Date: 1997/08/08 20:54:50 $  *  *    Copyright (c) 1991, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  * $Log: str.c,v $  * Revision 1.2.6.1  1997/08/08 20:54:50  joerg  * MFC: fix buffer overflow condition.  *  * Revision 1.2  1995/05/30 05:03:21  rgrimes  * Remove trailing whitespace.  *  * Revision 1.1.1.1  1994/09/10  06:27:33  gclarkii  * Initial import of Perl 4.046 bmaked  *  * Revision 1.1.1.1  1993/08/23  21:29:39  nate  * PERL!  *  * Revision 4.0.1.7  1993/02/05  19:43:47  lwall  * patch36: the non-std stdio input code wasn't null-proof  *  * Revision 4.0.1.6  92/06/11  21:14:21  lwall  * patch34: quotes containing subscripts containing variables didn't parse right  *  * Revision 4.0.1.5  92/06/08  15:40:43  lwall  * patch20: removed implicit int declarations on functions  * patch20: Perl now distinguishes overlapped copies from non-overlapped  * patch20: paragraph mode now skips extra newlines automatically  * patch20: fixed memory leak in doube-quote interpretation  * patch20: made /\$$foo/ look for literal '$foo'  * patch20: "$var{$foo'bar}" didn't scan subscript correctly  * patch20: a splice on non-existent array elements could dump core  * patch20: running taintperl explicitly now does checks even if $< == $>  *  * Revision 4.0.1.4  91/11/05  18:40:51  lwall  * patch11: $foo .=<BAR> could overrun malloced memory  * patch11: \$ didn't always make it through double-quoter to regexp routines  * patch11: prepared for ctype implementations that don't define isascii()  *  * Revision 4.0.1.3  91/06/10  01:27:54  lwall  * patch10: $) and $| incorrectly handled in run-time patterns  *  * Revision 4.0.1.2  91/06/07  11:58:13  lwall  * patch4: new copyright notice  * patch4: taint check on undefined string could cause core dump  *  * Revision 4.0.1.1  91/04/12  09:15:30  lwall  * patch1: fixed undefined environ problem  * patch1: substr($ENV{"PATH"},0,0) = "/foo:" didn't modify environment  * patch1: $foo .=<BAR> could cause core dump for certain lengths of $foo  *  * Revision 4.0  91/03/20  01:39:55  lwall  * 4.0 baseline.  *  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_include
include|#
directive|include
file|"perly.h"
end_include

begin_function_decl
specifier|static
name|void
name|ucase
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lcase
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|str_get
end_ifndef

begin_function
name|char
modifier|*
name|str_get
parameter_list|(
name|str
parameter_list|)
name|STR
modifier|*
name|str
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TAINT
name|tainted
operator||=
name|str
operator|->
name|str_tainted
expr_stmt|;
endif|#
directive|endif
return|return
name|str
operator|->
name|str_pok
condition|?
name|str
operator|->
name|str_ptr
else|:
name|str_2ptr
argument_list|(
name|str
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* dlb ... guess we have a "crippled cc".  * dlb the following functions are usually macros.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|str_true
end_ifndef

begin_function
name|int
name|str_true
parameter_list|(
name|Str
parameter_list|)
name|STR
modifier|*
name|Str
decl_stmt|;
block|{
if|if
condition|(
name|Str
operator|->
name|str_pok
condition|)
block|{
if|if
condition|(
operator|*
name|Str
operator|->
name|str_ptr
operator|>
literal|'0'
operator|||
name|Str
operator|->
name|str_cur
operator|>
literal|1
operator|||
operator|(
name|Str
operator|->
name|str_cur
operator|&&
operator|*
name|Str
operator|->
name|str_ptr
operator|!=
literal|'0'
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|Str
operator|->
name|str_nok
condition|)
return|return
operator|(
name|Str
operator|->
name|str_u
operator|.
name|str_nval
operator|!=
literal|0.0
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* str_true */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|str_gnum
end_ifndef

begin_function
name|double
name|str_gnum
parameter_list|(
name|Str
parameter_list|)
name|STR
modifier|*
name|Str
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TAINT
name|tainted
operator||=
name|Str
operator|->
name|str_tainted
expr_stmt|;
endif|#
directive|endif
comment|/* TAINT*/
if|if
condition|(
name|Str
operator|->
name|str_nok
condition|)
return|return
name|Str
operator|->
name|str_u
operator|.
name|str_nval
return|;
return|return
name|str_2num
argument_list|(
name|Str
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* str_gnum */
end_comment

begin_comment
comment|/* dlb ... end of crutch */
end_comment

begin_function
name|char
modifier|*
name|str_grow
parameter_list|(
name|str
parameter_list|,
name|newlen
parameter_list|)
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
ifndef|#
directive|ifndef
name|DOSISH
specifier|register
name|int
name|newlen
decl_stmt|;
else|#
directive|else
name|unsigned
name|long
name|newlen
decl_stmt|;
endif|#
directive|endif
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|str
operator|->
name|str_ptr
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOS
if|if
condition|(
name|newlen
operator|>=
literal|0x10000
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Allocation too large: %lx\n"
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MSDOS */
if|if
condition|(
name|str
operator|->
name|str_state
operator|==
name|SS_INCR
condition|)
block|{
comment|/* data before str_ptr? */
name|str
operator|->
name|str_len
operator|+=
name|str
operator|->
name|str_u
operator|.
name|str_useful
expr_stmt|;
name|str
operator|->
name|str_ptr
operator|-=
name|str
operator|->
name|str_u
operator|.
name|str_useful
expr_stmt|;
name|str
operator|->
name|str_u
operator|.
name|str_useful
operator|=
literal|0L
expr_stmt|;
name|Move
argument_list|(
name|s
argument_list|,
name|str
operator|->
name|str_ptr
argument_list|,
name|str
operator|->
name|str_cur
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|s
operator|=
name|str
operator|->
name|str_ptr
expr_stmt|;
name|str
operator|->
name|str_state
operator|=
name|SS_NORM
expr_stmt|;
comment|/* normal again */
if|if
condition|(
name|newlen
operator|>
name|str
operator|->
name|str_len
condition|)
name|newlen
operator|+=
literal|10
operator|*
operator|(
name|newlen
operator|-
name|str
operator|->
name|str_cur
operator|)
expr_stmt|;
comment|/* avoid copy each time */
block|}
if|if
condition|(
name|newlen
operator|>
name|str
operator|->
name|str_len
condition|)
block|{
comment|/* need more room? */
if|if
condition|(
name|str
operator|->
name|str_len
condition|)
name|Renew
argument_list|(
name|s
argument_list|,
name|newlen
argument_list|,
name|char
argument_list|)
expr_stmt|;
else|else
name|New
argument_list|(
literal|703
argument_list|,
name|s
argument_list|,
name|newlen
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_ptr
operator|=
name|s
expr_stmt|;
name|str
operator|->
name|str_len
operator|=
name|newlen
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
name|void
name|str_numset
parameter_list|(
name|str
parameter_list|,
name|num
parameter_list|)
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
name|double
name|num
decl_stmt|;
block|{
if|if
condition|(
name|str
operator|->
name|str_pok
condition|)
block|{
name|str
operator|->
name|str_pok
operator|=
literal|0
expr_stmt|;
comment|/* invalidate pointer */
if|if
condition|(
name|str
operator|->
name|str_state
operator|==
name|SS_INCR
condition|)
name|Str_Grow
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|str
operator|->
name|str_u
operator|.
name|str_nval
operator|=
name|num
expr_stmt|;
name|str
operator|->
name|str_state
operator|=
name|SS_NORM
expr_stmt|;
name|str
operator|->
name|str_nok
operator|=
literal|1
expr_stmt|;
comment|/* validate number */
ifdef|#
directive|ifdef
name|TAINT
name|str
operator|->
name|str_tainted
operator|=
name|tainted
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|char
modifier|*
name|str_2ptr
parameter_list|(
name|str
parameter_list|)
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|olderrno
decl_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
return|return
literal|""
return|;
if|if
condition|(
name|str
operator|->
name|str_nok
condition|)
block|{
name|STR_GROW
argument_list|(
name|str
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|s
operator|=
name|str
operator|->
name|str_ptr
expr_stmt|;
name|olderrno
operator|=
name|errno
expr_stmt|;
comment|/* some Xenix systems wipe out errno here */
if|#
directive|if
name|defined
argument_list|(
name|scs
argument_list|)
operator|&&
name|defined
argument_list|(
name|ns32000
argument_list|)
name|gcvt
argument_list|(
name|str
operator|->
name|str_u
operator|.
name|str_nval
argument_list|,
literal|20
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|apollo
if|if
condition|(
name|str
operator|->
name|str_u
operator|.
name|str_nval
operator|==
literal|0.0
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|s
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/*apollo*/
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%.20g"
argument_list|,
name|str
operator|->
name|str_u
operator|.
name|str_nval
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*scs*/
name|errno
operator|=
name|olderrno
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|hcx
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|s
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|str
operator|==
operator|&
name|str_undef
condition|)
return|return
name|No
return|;
if|if
condition|(
name|dowarn
condition|)
name|warn
argument_list|(
literal|"Use of uninitialized variable"
argument_list|)
expr_stmt|;
name|STR_GROW
argument_list|(
name|str
argument_list|,
literal|30
argument_list|)
expr_stmt|;
name|s
operator|=
name|str
operator|->
name|str_ptr
expr_stmt|;
block|}
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|str
operator|->
name|str_cur
operator|=
name|s
operator|-
name|str
operator|->
name|str_ptr
expr_stmt|;
name|str
operator|->
name|str_pok
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|32
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"0x%lx ptr(%s)\n"
argument_list|,
name|str
argument_list|,
name|str
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|str
operator|->
name|str_ptr
return|;
block|}
end_function

begin_function
name|double
name|str_2num
parameter_list|(
name|str
parameter_list|)
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|str
condition|)
return|return
literal|0.0
return|;
if|if
condition|(
name|str
operator|->
name|str_state
operator|==
name|SS_INCR
condition|)
name|Str_Grow
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* just force copy down */
name|str
operator|->
name|str_state
operator|=
name|SS_NORM
expr_stmt|;
if|if
condition|(
name|str
operator|->
name|str_len
operator|&&
name|str
operator|->
name|str_pok
condition|)
name|str
operator|->
name|str_u
operator|.
name|str_nval
operator|=
name|atof
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|str
operator|==
operator|&
name|str_undef
condition|)
return|return
literal|0.0
return|;
if|if
condition|(
name|dowarn
condition|)
name|warn
argument_list|(
literal|"Use of uninitialized variable"
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_u
operator|.
name|str_nval
operator|=
literal|0.0
expr_stmt|;
block|}
name|str
operator|->
name|str_nok
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|32
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"0x%lx num(%g)\n"
argument_list|,
name|str
argument_list|,
name|str
operator|->
name|str_u
operator|.
name|str_nval
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|str
operator|->
name|str_u
operator|.
name|str_nval
return|;
block|}
end_function

begin_comment
comment|/* Note: str_sset() should not be called with a source string that needs  * be reused, since it may destroy the source string if it is marked  * as temporary.  */
end_comment

begin_function
name|void
name|str_sset
parameter_list|(
name|dstr
parameter_list|,
name|sstr
parameter_list|)
name|STR
modifier|*
name|dstr
decl_stmt|;
specifier|register
name|STR
modifier|*
name|sstr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TAINT
if|if
condition|(
name|sstr
condition|)
name|tainted
operator||=
name|sstr
operator|->
name|str_tainted
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sstr
operator|==
name|dstr
operator|||
name|dstr
operator|==
operator|&
name|str_undef
condition|)
return|return;
if|if
condition|(
operator|!
name|sstr
condition|)
name|dstr
operator|->
name|str_pok
operator|=
name|dstr
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sstr
operator|->
name|str_pok
condition|)
block|{
comment|/* 	 * Check to see if we can just swipe the string.  If so, it's a 	 * possible small lose on short strings, but a big win on long ones. 	 * It might even be a win on short strings if dstr->str_ptr 	 * has to be allocated and sstr->str_ptr has to be freed. 	 */
if|if
condition|(
name|sstr
operator|->
name|str_pok
operator|&
name|SP_TEMP
condition|)
block|{
comment|/* slated for free anyway? */
if|if
condition|(
name|dstr
operator|->
name|str_ptr
condition|)
block|{
if|if
condition|(
name|dstr
operator|->
name|str_state
operator|==
name|SS_INCR
condition|)
name|dstr
operator|->
name|str_ptr
operator|-=
name|dstr
operator|->
name|str_u
operator|.
name|str_useful
expr_stmt|;
name|Safefree
argument_list|(
name|dstr
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
block|}
name|dstr
operator|->
name|str_ptr
operator|=
name|sstr
operator|->
name|str_ptr
expr_stmt|;
name|dstr
operator|->
name|str_len
operator|=
name|sstr
operator|->
name|str_len
expr_stmt|;
name|dstr
operator|->
name|str_cur
operator|=
name|sstr
operator|->
name|str_cur
expr_stmt|;
name|dstr
operator|->
name|str_state
operator|=
name|sstr
operator|->
name|str_state
expr_stmt|;
name|dstr
operator|->
name|str_pok
operator|=
name|sstr
operator|->
name|str_pok
operator|&
operator|~
name|SP_TEMP
expr_stmt|;
ifdef|#
directive|ifdef
name|TAINT
name|dstr
operator|->
name|str_tainted
operator|=
name|sstr
operator|->
name|str_tainted
expr_stmt|;
endif|#
directive|endif
name|sstr
operator|->
name|str_ptr
operator|=
name|Nullch
expr_stmt|;
name|sstr
operator|->
name|str_len
operator|=
literal|0
expr_stmt|;
name|sstr
operator|->
name|str_pok
operator|=
literal|0
expr_stmt|;
comment|/* wipe out any weird flags */
name|sstr
operator|->
name|str_state
operator|=
literal|0
expr_stmt|;
comment|/* so sstr frees uneventfully */
block|}
else|else
block|{
comment|/* have to copy actual string */
if|if
condition|(
name|dstr
operator|->
name|str_ptr
condition|)
block|{
if|if
condition|(
name|dstr
operator|->
name|str_state
operator|==
name|SS_INCR
condition|)
block|{
name|Str_Grow
argument_list|(
name|dstr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|str_nset
argument_list|(
name|dstr
argument_list|,
name|sstr
operator|->
name|str_ptr
argument_list|,
name|sstr
operator|->
name|str_cur
argument_list|)
expr_stmt|;
block|}
comment|/*SUPPRESS 560*/
if|if
condition|(
name|dstr
operator|->
name|str_nok
operator|=
name|sstr
operator|->
name|str_nok
condition|)
name|dstr
operator|->
name|str_u
operator|.
name|str_nval
operator|=
name|sstr
operator|->
name|str_u
operator|.
name|str_nval
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|STRUCTCOPY
name|dstr
operator|->
name|str_u
operator|=
name|sstr
operator|->
name|str_u
expr_stmt|;
else|#
directive|else
name|dstr
operator|->
name|str_u
operator|.
name|str_nval
operator|=
name|sstr
operator|->
name|str_u
operator|.
name|str_nval
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dstr
operator|->
name|str_cur
operator|==
sizeof|sizeof
argument_list|(
name|STBP
argument_list|)
condition|)
block|{
name|char
modifier|*
name|tmps
init|=
name|dstr
operator|->
name|str_ptr
decl_stmt|;
if|if
condition|(
operator|*
name|tmps
operator|==
literal|'S'
operator|&&
name|bcmp
argument_list|(
name|tmps
argument_list|,
literal|"StB"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dstr
operator|->
name|str_magic
operator|&&
name|dstr
operator|->
name|str_magic
operator|->
name|str_rare
operator|==
literal|'X'
condition|)
block|{
name|str_free
argument_list|(
name|dstr
operator|->
name|str_magic
argument_list|)
expr_stmt|;
name|dstr
operator|->
name|str_magic
operator|=
name|Nullstr
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dstr
operator|->
name|str_magic
condition|)
block|{
name|dstr
operator|->
name|str_magic
operator|=
name|str_smake
argument_list|(
name|sstr
operator|->
name|str_magic
argument_list|)
expr_stmt|;
name|dstr
operator|->
name|str_magic
operator|->
name|str_rare
operator|=
literal|'X'
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|sstr
operator|->
name|str_nok
condition|)
name|str_numset
argument_list|(
name|dstr
argument_list|,
name|sstr
operator|->
name|str_u
operator|.
name|str_nval
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|dstr
operator|->
name|str_state
operator|==
name|SS_INCR
condition|)
name|Str_Grow
argument_list|(
name|dstr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* just force copy down */
ifdef|#
directive|ifdef
name|STRUCTCOPY
name|dstr
operator|->
name|str_u
operator|=
name|sstr
operator|->
name|str_u
expr_stmt|;
else|#
directive|else
name|dstr
operator|->
name|str_u
operator|.
name|str_nval
operator|=
name|sstr
operator|->
name|str_u
operator|.
name|str_nval
expr_stmt|;
endif|#
directive|endif
name|dstr
operator|->
name|str_pok
operator|=
name|dstr
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|str_nset
parameter_list|(
name|str
parameter_list|,
name|ptr
parameter_list|,
name|len
parameter_list|)
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|STRLEN
name|len
decl_stmt|;
block|{
if|if
condition|(
name|str
operator|==
operator|&
name|str_undef
condition|)
return|return;
name|STR_GROW
argument_list|(
name|str
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|Move
argument_list|(
name|ptr
argument_list|,
name|str
operator|->
name|str_ptr
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_cur
operator|=
name|len
expr_stmt|;
operator|*
operator|(
name|str
operator|->
name|str_ptr
operator|+
name|str
operator|->
name|str_cur
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|str
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
comment|/* invalidate number */
name|str
operator|->
name|str_pok
operator|=
literal|1
expr_stmt|;
comment|/* validate pointer */
ifdef|#
directive|ifdef
name|TAINT
name|str
operator|->
name|str_tainted
operator|=
name|tainted
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|str_set
parameter_list|(
name|str
parameter_list|,
name|ptr
parameter_list|)
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
block|{
specifier|register
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
name|str
operator|==
operator|&
name|str_undef
condition|)
return|return;
if|if
condition|(
operator|!
name|ptr
condition|)
name|ptr
operator|=
literal|""
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|STR_GROW
argument_list|(
name|str
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Move
argument_list|(
name|ptr
argument_list|,
name|str
operator|->
name|str_ptr
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_cur
operator|=
name|len
expr_stmt|;
name|str
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
comment|/* invalidate number */
name|str
operator|->
name|str_pok
operator|=
literal|1
expr_stmt|;
comment|/* validate pointer */
ifdef|#
directive|ifdef
name|TAINT
name|str
operator|->
name|str_tainted
operator|=
name|tainted
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|str_chop
parameter_list|(
name|str
parameter_list|,
name|ptr
parameter_list|)
comment|/* like set but assuming ptr is in str */
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
block|{
specifier|register
name|STRLEN
name|delta
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
operator|||
operator|!
operator|(
name|str
operator|->
name|str_pok
operator|)
condition|)
return|return;
name|delta
operator|=
name|ptr
operator|-
name|str
operator|->
name|str_ptr
expr_stmt|;
name|str
operator|->
name|str_len
operator|-=
name|delta
expr_stmt|;
name|str
operator|->
name|str_cur
operator|-=
name|delta
expr_stmt|;
name|str
operator|->
name|str_ptr
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|str
operator|->
name|str_state
operator|==
name|SS_INCR
condition|)
name|str
operator|->
name|str_u
operator|.
name|str_useful
operator|+=
name|delta
expr_stmt|;
else|else
block|{
name|str
operator|->
name|str_u
operator|.
name|str_useful
operator|=
name|delta
expr_stmt|;
name|str
operator|->
name|str_state
operator|=
name|SS_INCR
expr_stmt|;
block|}
name|str
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
comment|/* invalidate number */
name|str
operator|->
name|str_pok
operator|=
literal|1
expr_stmt|;
comment|/* validate pointer (and unstudy str) */
block|}
end_function

begin_function
name|void
name|str_ncat
parameter_list|(
name|str
parameter_list|,
name|ptr
parameter_list|,
name|len
parameter_list|)
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|STRLEN
name|len
decl_stmt|;
block|{
if|if
condition|(
name|str
operator|==
operator|&
name|str_undef
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|str
operator|->
name|str_pok
operator|)
condition|)
operator|(
name|void
operator|)
name|str_2ptr
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|STR_GROW
argument_list|(
name|str
argument_list|,
name|str
operator|->
name|str_cur
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Move
argument_list|(
name|ptr
argument_list|,
name|str
operator|->
name|str_ptr
operator|+
name|str
operator|->
name|str_cur
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_cur
operator|+=
name|len
expr_stmt|;
operator|*
operator|(
name|str
operator|->
name|str_ptr
operator|+
name|str
operator|->
name|str_cur
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|str
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
comment|/* invalidate number */
name|str
operator|->
name|str_pok
operator|=
literal|1
expr_stmt|;
comment|/* validate pointer */
ifdef|#
directive|ifdef
name|TAINT
name|str
operator|->
name|str_tainted
operator||=
name|tainted
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|str_scat
parameter_list|(
name|dstr
parameter_list|,
name|sstr
parameter_list|)
name|STR
modifier|*
name|dstr
decl_stmt|;
specifier|register
name|STR
modifier|*
name|sstr
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|sstr
condition|)
return|return;
ifdef|#
directive|ifdef
name|TAINT
name|tainted
operator||=
name|sstr
operator|->
name|str_tainted
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|sstr
operator|->
name|str_pok
operator|)
condition|)
operator|(
name|void
operator|)
name|str_2ptr
argument_list|(
name|sstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sstr
condition|)
name|str_ncat
argument_list|(
name|dstr
argument_list|,
name|sstr
operator|->
name|str_ptr
argument_list|,
name|sstr
operator|->
name|str_cur
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|str_cat
parameter_list|(
name|str
parameter_list|,
name|ptr
parameter_list|)
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
block|{
specifier|register
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
name|str
operator|==
operator|&
name|str_undef
condition|)
return|return;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|str
operator|->
name|str_pok
operator|)
condition|)
operator|(
name|void
operator|)
name|str_2ptr
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|STR_GROW
argument_list|(
name|str
argument_list|,
name|str
operator|->
name|str_cur
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Move
argument_list|(
name|ptr
argument_list|,
name|str
operator|->
name|str_ptr
operator|+
name|str
operator|->
name|str_cur
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_cur
operator|+=
name|len
expr_stmt|;
name|str
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
comment|/* invalidate number */
name|str
operator|->
name|str_pok
operator|=
literal|1
expr_stmt|;
comment|/* validate pointer */
ifdef|#
directive|ifdef
name|TAINT
name|str
operator|->
name|str_tainted
operator||=
name|tainted
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|char
modifier|*
name|str_append_till
parameter_list|(
name|str
parameter_list|,
name|from
parameter_list|,
name|fromend
parameter_list|,
name|delim
parameter_list|,
name|keeplist
parameter_list|)
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
specifier|register
name|char
modifier|*
name|from
decl_stmt|;
specifier|register
name|char
modifier|*
name|fromend
decl_stmt|;
specifier|register
name|int
name|delim
decl_stmt|;
name|char
modifier|*
name|keeplist
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
specifier|register
name|STRLEN
name|len
decl_stmt|;
if|if
condition|(
name|str
operator|==
operator|&
name|str_undef
condition|)
return|return
name|Nullch
return|;
if|if
condition|(
operator|!
name|from
condition|)
return|return
name|Nullch
return|;
name|len
operator|=
name|fromend
operator|-
name|from
expr_stmt|;
name|STR_GROW
argument_list|(
name|str
argument_list|,
name|str
operator|->
name|str_cur
operator|+
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
comment|/* invalidate number */
name|str
operator|->
name|str_pok
operator|=
literal|1
expr_stmt|;
comment|/* validate pointer */
name|to
operator|=
name|str
operator|->
name|str_ptr
operator|+
name|str
operator|->
name|str_cur
expr_stmt|;
for|for
control|(
init|;
name|from
operator|<
name|fromend
condition|;
name|from
operator|++
operator|,
name|to
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|from
operator|==
literal|'\\'
operator|&&
name|from
operator|+
literal|1
operator|<
name|fromend
operator|&&
name|delim
operator|!=
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|!
name|keeplist
condition|)
block|{
if|if
condition|(
name|from
index|[
literal|1
index|]
operator|==
name|delim
operator|||
name|from
index|[
literal|1
index|]
operator|==
literal|'\\'
condition|)
name|from
operator|++
expr_stmt|;
else|else
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from
index|[
literal|1
index|]
operator|&&
name|index
argument_list|(
name|keeplist
argument_list|,
name|from
index|[
literal|1
index|]
argument_list|)
condition|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
else|else
name|from
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|from
operator|==
name|delim
condition|)
break|break;
operator|*
name|to
operator|=
operator|*
name|from
expr_stmt|;
block|}
operator|*
name|to
operator|=
literal|'\0'
expr_stmt|;
name|str
operator|->
name|str_cur
operator|=
name|to
operator|-
name|str
operator|->
name|str_ptr
expr_stmt|;
return|return
name|from
return|;
block|}
end_function

begin_function
name|STR
modifier|*
ifdef|#
directive|ifdef
name|LEAKTEST
name|str_new
parameter_list|(
name|x
parameter_list|,
name|len
parameter_list|)
name|int
name|x
decl_stmt|;
else|#
directive|else
function|str_new
parameter_list|(
name|len
parameter_list|)
endif|#
directive|endif
name|STRLEN
name|len
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|freestrroot
condition|)
block|{
name|str
operator|=
name|freestrroot
expr_stmt|;
name|freestrroot
operator|=
name|str
operator|->
name|str_magic
expr_stmt|;
name|str
operator|->
name|str_magic
operator|=
name|Nullstr
expr_stmt|;
name|str
operator|->
name|str_state
operator|=
name|SS_NORM
expr_stmt|;
block|}
else|else
block|{
name|Newz
argument_list|(
literal|700
operator|+
name|x
argument_list|,
name|str
argument_list|,
literal|1
argument_list|,
name|STR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
name|STR_GROW
argument_list|(
name|str
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_function
name|void
name|str_magic
parameter_list|(
name|str
parameter_list|,
name|stab
parameter_list|,
name|how
parameter_list|,
name|name
parameter_list|,
name|namlen
parameter_list|)
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
name|STAB
modifier|*
name|stab
decl_stmt|;
name|int
name|how
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|STRLEN
name|namlen
decl_stmt|;
block|{
if|if
condition|(
name|str
operator|==
operator|&
name|str_undef
operator|||
name|str
operator|->
name|str_magic
condition|)
return|return;
name|str
operator|->
name|str_magic
operator|=
name|Str_new
argument_list|(
literal|75
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
name|str
operator|=
name|str
operator|->
name|str_magic
expr_stmt|;
name|str
operator|->
name|str_u
operator|.
name|str_stab
operator|=
name|stab
expr_stmt|;
name|str
operator|->
name|str_rare
operator|=
name|how
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|str_nset
argument_list|(
name|str
argument_list|,
name|name
argument_list|,
name|namlen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|str_insert
parameter_list|(
name|bigstr
parameter_list|,
name|offset
parameter_list|,
name|len
parameter_list|,
name|little
parameter_list|,
name|littlelen
parameter_list|)
name|STR
modifier|*
name|bigstr
decl_stmt|;
name|STRLEN
name|offset
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
name|char
modifier|*
name|little
decl_stmt|;
name|STRLEN
name|littlelen
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|big
decl_stmt|;
specifier|register
name|char
modifier|*
name|mid
decl_stmt|;
specifier|register
name|char
modifier|*
name|midend
decl_stmt|;
specifier|register
name|char
modifier|*
name|bigend
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bigstr
operator|==
operator|&
name|str_undef
condition|)
return|return;
name|bigstr
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
name|bigstr
operator|->
name|str_pok
operator|=
name|SP_VALID
expr_stmt|;
comment|/* disable possible screamer */
name|i
operator|=
name|littlelen
operator|-
name|len
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
comment|/* string might grow */
name|STR_GROW
argument_list|(
name|bigstr
argument_list|,
name|bigstr
operator|->
name|str_cur
operator|+
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|big
operator|=
name|bigstr
operator|->
name|str_ptr
expr_stmt|;
name|mid
operator|=
name|big
operator|+
name|offset
operator|+
name|len
expr_stmt|;
name|midend
operator|=
name|bigend
operator|=
name|big
operator|+
name|bigstr
operator|->
name|str_cur
expr_stmt|;
name|bigend
operator|+=
name|i
expr_stmt|;
operator|*
name|bigend
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|midend
operator|>
name|mid
condition|)
comment|/* shove everything down */
operator|*
operator|--
name|bigend
operator|=
operator|*
operator|--
name|midend
expr_stmt|;
name|Move
argument_list|(
name|little
argument_list|,
name|big
operator|+
name|offset
argument_list|,
name|littlelen
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|bigstr
operator|->
name|str_cur
operator|+=
name|i
expr_stmt|;
name|STABSET
argument_list|(
name|bigstr
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|Move
argument_list|(
name|little
argument_list|,
name|bigstr
operator|->
name|str_ptr
operator|+
name|offset
argument_list|,
name|len
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|bigstr
argument_list|)
expr_stmt|;
return|return;
block|}
name|big
operator|=
name|bigstr
operator|->
name|str_ptr
expr_stmt|;
name|mid
operator|=
name|big
operator|+
name|offset
expr_stmt|;
name|midend
operator|=
name|mid
operator|+
name|len
expr_stmt|;
name|bigend
operator|=
name|big
operator|+
name|bigstr
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
name|midend
operator|>
name|bigend
condition|)
name|fatal
argument_list|(
literal|"panic: str_insert"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mid
operator|-
name|big
operator|>
name|bigend
operator|-
name|midend
condition|)
block|{
comment|/* faster to shorten from end */
if|if
condition|(
name|littlelen
condition|)
block|{
name|Move
argument_list|(
name|little
argument_list|,
name|mid
argument_list|,
name|littlelen
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|mid
operator|+=
name|littlelen
expr_stmt|;
block|}
name|i
operator|=
name|bigend
operator|-
name|midend
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|Move
argument_list|(
name|midend
argument_list|,
name|mid
argument_list|,
name|i
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|mid
operator|+=
name|i
expr_stmt|;
block|}
operator|*
name|mid
operator|=
literal|'\0'
expr_stmt|;
name|bigstr
operator|->
name|str_cur
operator|=
name|mid
operator|-
name|big
expr_stmt|;
block|}
comment|/*SUPPRESS 560*/
elseif|else
if|if
condition|(
name|i
operator|=
name|mid
operator|-
name|big
condition|)
block|{
comment|/* faster from front */
name|midend
operator|-=
name|littlelen
expr_stmt|;
name|mid
operator|=
name|midend
expr_stmt|;
name|str_chop
argument_list|(
name|bigstr
argument_list|,
name|midend
operator|-
name|i
argument_list|)
expr_stmt|;
name|big
operator|+=
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
operator|*
operator|--
name|midend
operator|=
operator|*
operator|--
name|big
expr_stmt|;
if|if
condition|(
name|littlelen
condition|)
name|Move
argument_list|(
name|little
argument_list|,
name|mid
argument_list|,
name|littlelen
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|littlelen
condition|)
block|{
name|midend
operator|-=
name|littlelen
expr_stmt|;
name|str_chop
argument_list|(
name|bigstr
argument_list|,
name|midend
argument_list|)
expr_stmt|;
name|Move
argument_list|(
name|little
argument_list|,
name|midend
argument_list|,
name|littlelen
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|str_chop
argument_list|(
name|bigstr
argument_list|,
name|midend
argument_list|)
expr_stmt|;
block|}
name|STABSET
argument_list|(
name|bigstr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* make str point to what nstr did */
end_comment

begin_function
name|void
name|str_replace
parameter_list|(
name|str
parameter_list|,
name|nstr
parameter_list|)
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
specifier|register
name|STR
modifier|*
name|nstr
decl_stmt|;
block|{
if|if
condition|(
name|str
operator|==
operator|&
name|str_undef
condition|)
return|return;
if|if
condition|(
name|str
operator|->
name|str_state
operator|==
name|SS_INCR
condition|)
name|Str_Grow
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* just force copy down */
if|if
condition|(
name|nstr
operator|->
name|str_state
operator|==
name|SS_INCR
condition|)
name|Str_Grow
argument_list|(
name|nstr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|->
name|str_ptr
condition|)
name|Safefree
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_ptr
operator|=
name|nstr
operator|->
name|str_ptr
expr_stmt|;
name|str
operator|->
name|str_len
operator|=
name|nstr
operator|->
name|str_len
expr_stmt|;
name|str
operator|->
name|str_cur
operator|=
name|nstr
operator|->
name|str_cur
expr_stmt|;
name|str
operator|->
name|str_pok
operator|=
name|nstr
operator|->
name|str_pok
expr_stmt|;
name|str
operator|->
name|str_nok
operator|=
name|nstr
operator|->
name|str_nok
expr_stmt|;
ifdef|#
directive|ifdef
name|STRUCTCOPY
name|str
operator|->
name|str_u
operator|=
name|nstr
operator|->
name|str_u
expr_stmt|;
else|#
directive|else
name|str
operator|->
name|str_u
operator|.
name|str_nval
operator|=
name|nstr
operator|->
name|str_u
operator|.
name|str_nval
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TAINT
name|str
operator|->
name|str_tainted
operator|=
name|nstr
operator|->
name|str_tainted
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nstr
operator|->
name|str_magic
condition|)
name|str_free
argument_list|(
name|nstr
operator|->
name|str_magic
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|nstr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|str_free
parameter_list|(
name|str
parameter_list|)
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|str
operator|||
name|str
operator|==
operator|&
name|str_undef
condition|)
return|return;
if|if
condition|(
name|str
operator|->
name|str_state
condition|)
block|{
if|if
condition|(
name|str
operator|->
name|str_state
operator|==
name|SS_FREE
condition|)
comment|/* already freed */
return|return;
if|if
condition|(
name|str
operator|->
name|str_state
operator|==
name|SS_INCR
operator|&&
operator|!
operator|(
name|str
operator|->
name|str_pok
operator|&
literal|2
operator|)
condition|)
block|{
name|str
operator|->
name|str_ptr
operator|-=
name|str
operator|->
name|str_u
operator|.
name|str_useful
expr_stmt|;
name|str
operator|->
name|str_len
operator|+=
name|str
operator|->
name|str_u
operator|.
name|str_useful
expr_stmt|;
block|}
block|}
if|if
condition|(
name|str
operator|->
name|str_magic
condition|)
name|str_free
argument_list|(
name|str
operator|->
name|str_magic
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_magic
operator|=
name|freestrroot
expr_stmt|;
ifdef|#
directive|ifdef
name|LEAKTEST
if|if
condition|(
name|str
operator|->
name|str_len
condition|)
block|{
name|Safefree
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_ptr
operator|=
name|Nullch
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|str
operator|->
name|str_pok
operator|&
name|SP_INTRP
operator|)
operator|&&
name|str
operator|->
name|str_u
operator|.
name|str_args
condition|)
name|arg_free
argument_list|(
name|str
operator|->
name|str_u
operator|.
name|str_args
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|str
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* LEAKTEST */
if|if
condition|(
name|str
operator|->
name|str_len
condition|)
block|{
if|if
condition|(
name|str
operator|->
name|str_len
operator|>
literal|127
condition|)
block|{
comment|/* next user not likely to want more */
name|Safefree
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
comment|/* so give it back to malloc */
name|str
operator|->
name|str_ptr
operator|=
name|Nullch
expr_stmt|;
name|str
operator|->
name|str_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|str
operator|->
name|str_ptr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|str
operator|->
name|str_pok
operator|&
name|SP_INTRP
operator|)
operator|&&
name|str
operator|->
name|str_u
operator|.
name|str_args
condition|)
name|arg_free
argument_list|(
name|str
operator|->
name|str_u
operator|.
name|str_args
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_cur
operator|=
literal|0
expr_stmt|;
name|str
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
name|str
operator|->
name|str_pok
operator|=
literal|0
expr_stmt|;
name|str
operator|->
name|str_state
operator|=
name|SS_FREE
expr_stmt|;
ifdef|#
directive|ifdef
name|TAINT
name|str
operator|->
name|str_tainted
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|freestrroot
operator|=
name|str
expr_stmt|;
endif|#
directive|endif
comment|/* LEAKTEST */
block|}
end_function

begin_function
name|STRLEN
name|str_len
parameter_list|(
name|str
parameter_list|)
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|str
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|str
operator|->
name|str_pok
operator|)
condition|)
operator|(
name|void
operator|)
name|str_2ptr
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|->
name|str_ptr
condition|)
return|return
name|str
operator|->
name|str_cur
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|str_eq
parameter_list|(
name|str1
parameter_list|,
name|str2
parameter_list|)
specifier|register
name|STR
modifier|*
name|str1
decl_stmt|;
specifier|register
name|STR
modifier|*
name|str2
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|str1
operator|||
name|str1
operator|==
operator|&
name|str_undef
condition|)
return|return
operator|(
name|str2
operator|==
name|Nullstr
operator|||
name|str2
operator|==
operator|&
name|str_undef
operator|||
operator|!
name|str2
operator|->
name|str_cur
operator|)
return|;
if|if
condition|(
operator|!
name|str2
operator|||
name|str2
operator|==
operator|&
name|str_undef
condition|)
return|return
operator|!
name|str1
operator|->
name|str_cur
return|;
if|if
condition|(
operator|!
name|str1
operator|->
name|str_pok
condition|)
operator|(
name|void
operator|)
name|str_2ptr
argument_list|(
name|str1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str2
operator|->
name|str_pok
condition|)
operator|(
name|void
operator|)
name|str_2ptr
argument_list|(
name|str2
argument_list|)
expr_stmt|;
if|if
condition|(
name|str1
operator|->
name|str_cur
operator|!=
name|str2
operator|->
name|str_cur
condition|)
return|return
literal|0
return|;
return|return
operator|!
name|bcmp
argument_list|(
name|str1
operator|->
name|str_ptr
argument_list|,
name|str2
operator|->
name|str_ptr
argument_list|,
name|str1
operator|->
name|str_cur
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|str_cmp
parameter_list|(
name|str1
parameter_list|,
name|str2
parameter_list|)
specifier|register
name|STR
modifier|*
name|str1
decl_stmt|;
specifier|register
name|STR
modifier|*
name|str2
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
if|if
condition|(
operator|!
name|str1
operator|||
name|str1
operator|==
operator|&
name|str_undef
condition|)
return|return
operator|(
name|str2
operator|==
name|Nullstr
operator|||
name|str2
operator|==
operator|&
name|str_undef
operator|||
operator|!
name|str2
operator|->
name|str_cur
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|str2
operator|||
name|str2
operator|==
operator|&
name|str_undef
condition|)
return|return
name|str1
operator|->
name|str_cur
operator|!=
literal|0
return|;
if|if
condition|(
operator|!
name|str1
operator|->
name|str_pok
condition|)
operator|(
name|void
operator|)
name|str_2ptr
argument_list|(
name|str1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str2
operator|->
name|str_pok
condition|)
operator|(
name|void
operator|)
name|str_2ptr
argument_list|(
name|str2
argument_list|)
expr_stmt|;
if|if
condition|(
name|str1
operator|->
name|str_cur
operator|<
name|str2
operator|->
name|str_cur
condition|)
block|{
comment|/*SUPPRESS 560*/
if|if
condition|(
name|retval
operator|=
name|memcmp
argument_list|(
name|str1
operator|->
name|str_ptr
argument_list|,
name|str2
operator|->
name|str_ptr
argument_list|,
name|str1
operator|->
name|str_cur
argument_list|)
condition|)
return|return
name|retval
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
comment|/*SUPPRESS 560*/
elseif|else
if|if
condition|(
name|retval
operator|=
name|memcmp
argument_list|(
name|str1
operator|->
name|str_ptr
argument_list|,
name|str2
operator|->
name|str_ptr
argument_list|,
name|str2
operator|->
name|str_cur
argument_list|)
condition|)
return|return
name|retval
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
return|;
elseif|else
if|if
condition|(
name|str1
operator|->
name|str_cur
operator|==
name|str2
operator|->
name|str_cur
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|str_gets
parameter_list|(
name|str
parameter_list|,
name|fp
parameter_list|,
name|append
parameter_list|)
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|append
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
comment|/* we're going to steal some values */
specifier|register
name|int
name|cnt
decl_stmt|;
comment|/*  from the stdio struct and put EVERYTHING */
specifier|register
name|STDCHAR
modifier|*
name|ptr
decl_stmt|;
comment|/*   in the innermost loop into registers */
specifier|register
name|int
name|newline
init|=
name|rschar
decl_stmt|;
comment|/* (assuming>= 6 registers) */
name|int
name|i
decl_stmt|;
name|STRLEN
name|bpx
decl_stmt|;
name|int
name|shortbuffered
decl_stmt|;
if|if
condition|(
name|str
operator|==
operator|&
name|str_undef
condition|)
return|return
name|Nullch
return|;
if|if
condition|(
name|rspara
condition|)
block|{
comment|/* have to do this both before and after */
do|do
block|{
comment|/* to make sure file boundaries work right */
name|i
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|'\n'
condition|)
block|{
name|ungetc
argument_list|(
name|i
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|i
operator|!=
name|EOF
condition|)
do|;
block|}
ifdef|#
directive|ifdef
name|STDSTDIO
comment|/* Here is some breathtakingly efficient cheating */
name|cnt
operator|=
name|fp
operator|->
name|_cnt
expr_stmt|;
comment|/* get count into register */
name|str
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
comment|/* invalidate number */
name|str
operator|->
name|str_pok
operator|=
literal|1
expr_stmt|;
comment|/* validate pointer */
if|if
condition|(
name|str
operator|->
name|str_len
operator|-
name|append
operator|<=
name|cnt
operator|+
literal|1
condition|)
block|{
comment|/* make sure we have the room */
if|if
condition|(
name|cnt
operator|>
literal|80
operator|&&
name|str
operator|->
name|str_len
operator|>
name|append
condition|)
block|{
name|shortbuffered
operator|=
name|cnt
operator|-
name|str
operator|->
name|str_len
operator|+
name|append
operator|+
literal|1
expr_stmt|;
name|cnt
operator|-=
name|shortbuffered
expr_stmt|;
block|}
else|else
block|{
name|shortbuffered
operator|=
literal|0
expr_stmt|;
name|STR_GROW
argument_list|(
name|str
argument_list|,
name|append
operator|+
name|cnt
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* (remembering cnt can be -1) */
block|}
block|}
else|else
name|shortbuffered
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|str
operator|->
name|str_ptr
operator|+
name|append
expr_stmt|;
comment|/* move these two too to registers */
name|ptr
operator|=
name|fp
operator|->
name|_ptr
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|screamer
label|:
while|while
condition|(
operator|--
name|cnt
operator|>=
literal|0
condition|)
block|{
comment|/* this */
comment|/* eat */
if|if
condition|(
operator|(
operator|*
name|bp
operator|++
operator|=
operator|*
name|ptr
operator|++
operator|)
operator|==
name|newline
condition|)
comment|/* really */
comment|/* dust */
goto|goto
name|thats_all_folks
goto|;
comment|/* screams */
comment|/* sed :-) */
block|}
if|if
condition|(
name|shortbuffered
condition|)
block|{
comment|/* oh well, must extend */
name|cnt
operator|=
name|shortbuffered
expr_stmt|;
name|shortbuffered
operator|=
literal|0
expr_stmt|;
name|bpx
operator|=
name|bp
operator|-
name|str
operator|->
name|str_ptr
expr_stmt|;
comment|/* prepare for possible relocation */
name|str
operator|->
name|str_cur
operator|=
name|bpx
expr_stmt|;
name|STR_GROW
argument_list|(
name|str
argument_list|,
name|str
operator|->
name|str_len
operator|+
name|append
operator|+
name|cnt
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bp
operator|=
name|str
operator|->
name|str_ptr
operator|+
name|bpx
expr_stmt|;
comment|/* reconstitute our pointer */
continue|continue;
block|}
name|fp
operator|->
name|_cnt
operator|=
name|cnt
expr_stmt|;
comment|/* deregisterize cnt and ptr */
name|fp
operator|->
name|_ptr
operator|=
name|ptr
expr_stmt|;
name|i
operator|=
name|_filbuf
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* get more characters */
name|cnt
operator|=
name|fp
operator|->
name|_cnt
expr_stmt|;
name|ptr
operator|=
name|fp
operator|->
name|_ptr
expr_stmt|;
comment|/* reregisterize cnt and ptr */
name|bpx
operator|=
name|bp
operator|-
name|str
operator|->
name|str_ptr
expr_stmt|;
comment|/* prepare for possible relocation */
name|str
operator|->
name|str_cur
operator|=
name|bpx
expr_stmt|;
name|STR_GROW
argument_list|(
name|str
argument_list|,
name|bpx
operator|+
name|cnt
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bp
operator|=
name|str
operator|->
name|str_ptr
operator|+
name|bpx
expr_stmt|;
comment|/* reconstitute our pointer */
if|if
condition|(
name|i
operator|==
name|newline
condition|)
block|{
comment|/* all done for now? */
operator|*
name|bp
operator|++
operator|=
name|i
expr_stmt|;
goto|goto
name|thats_all_folks
goto|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|EOF
condition|)
comment|/* all done for ever? */
goto|goto
name|thats_really_all_folks
goto|;
operator|*
name|bp
operator|++
operator|=
name|i
expr_stmt|;
comment|/* now go back to screaming loop */
block|}
name|thats_all_folks
label|:
if|if
condition|(
name|rslen
operator|>
literal|1
operator|&&
operator|(
name|bp
operator|-
name|str
operator|->
name|str_ptr
operator|<
name|rslen
operator|||
name|bcmp
argument_list|(
name|bp
operator|-
name|rslen
argument_list|,
name|rs
argument_list|,
name|rslen
argument_list|)
operator|)
condition|)
goto|goto
name|screamer
goto|;
comment|/* go back to the fray */
name|thats_really_all_folks
label|:
if|if
condition|(
name|shortbuffered
condition|)
name|cnt
operator|+=
name|shortbuffered
expr_stmt|;
name|fp
operator|->
name|_cnt
operator|=
name|cnt
expr_stmt|;
comment|/* put these back or we're in trouble */
name|fp
operator|->
name|_ptr
operator|=
name|ptr
expr_stmt|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|str
operator|->
name|str_cur
operator|=
name|bp
operator|-
name|str
operator|->
name|str_ptr
expr_stmt|;
comment|/* set length */
else|#
directive|else
comment|/* !STDSTDIO */
comment|/* The big, slow, and stupid way */
block|{
specifier|static
name|char
name|buf
index|[
literal|8192
index|]
decl_stmt|;
name|char
modifier|*
name|bpe
init|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|3
decl_stmt|;
name|screamer
label|:
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
operator|(
operator|*
name|bp
operator|++
operator|=
name|i
operator|)
operator|!=
name|newline
operator|&&
name|bp
operator|<
name|bpe
condition|)
empty_stmt|;
if|if
condition|(
name|append
condition|)
name|str_ncat
argument_list|(
name|str
argument_list|,
name|buf
argument_list|,
name|bp
operator|-
name|buf
argument_list|)
expr_stmt|;
else|else
name|str_nset
argument_list|(
name|str
argument_list|,
name|buf
argument_list|,
name|bp
operator|-
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|EOF
comment|/* joy */
operator|&&
operator|(
name|i
operator|!=
name|newline
operator|||
operator|(
name|rslen
operator|>
literal|1
operator|&&
operator|(
name|str
operator|->
name|str_cur
operator|<
name|rslen
operator|||
name|bcmp
argument_list|(
name|str
operator|->
name|str_ptr
operator|+
name|str
operator|->
name|str_cur
operator|-
name|rslen
argument_list|,
name|rs
argument_list|,
name|rslen
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
name|append
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|screamer
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* STDSTDIO */
if|if
condition|(
name|rspara
condition|)
block|{
while|while
condition|(
name|i
operator|!=
name|EOF
condition|)
block|{
name|i
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|'\n'
condition|)
block|{
name|ungetc
argument_list|(
name|i
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|str
operator|->
name|str_cur
operator|-
name|append
condition|?
name|str
operator|->
name|str_ptr
else|:
name|Nullch
return|;
block|}
end_function

begin_function
name|ARG
modifier|*
name|parselist
parameter_list|(
name|str
parameter_list|)
name|STR
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|CMD
modifier|*
name|cmd
decl_stmt|;
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
name|CMD
modifier|*
name|oldcurcmd
init|=
name|curcmd
decl_stmt|;
name|int
name|oldperldb
init|=
name|perldb
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|perldb
operator|=
literal|0
expr_stmt|;
name|str_sset
argument_list|(
name|linestr
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|in_eval
operator|++
expr_stmt|;
name|oldoldbufptr
operator|=
name|oldbufptr
operator|=
name|bufptr
operator|=
name|str_get
argument_list|(
name|linestr
argument_list|)
expr_stmt|;
name|bufend
operator|=
name|bufptr
operator|+
name|linestr
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
operator|++
name|loop_ptr
operator|>=
name|loop_max
condition|)
block|{
name|loop_max
operator|+=
literal|128
expr_stmt|;
name|Renew
argument_list|(
name|loop_stack
argument_list|,
name|loop_max
argument_list|,
expr|struct
name|loop
argument_list|)
expr_stmt|;
block|}
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_label
operator|=
literal|"_EVAL_"
expr_stmt|;
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_sp
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|4
condition|)
block|{
name|deb
argument_list|(
literal|"(Pushing label #%d _EVAL_)\n"
argument_list|,
name|loop_ptr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|setjmp
argument_list|(
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_env
argument_list|)
condition|)
block|{
name|in_eval
operator|--
expr_stmt|;
name|loop_ptr
operator|--
expr_stmt|;
name|perldb
operator|=
name|oldperldb
expr_stmt|;
name|fatal
argument_list|(
literal|"%s\n"
argument_list|,
name|stab_val
argument_list|(
name|stabent
argument_list|(
literal|"@"
argument_list|,
name|TRUE
argument_list|)
argument_list|)
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|4
condition|)
block|{
name|char
modifier|*
name|tmps
init|=
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_label
decl_stmt|;
name|deb
argument_list|(
literal|"(Popping label #%d %s)\n"
argument_list|,
name|loop_ptr
argument_list|,
name|tmps
condition|?
name|tmps
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|loop_ptr
operator|--
expr_stmt|;
name|error_count
operator|=
literal|0
expr_stmt|;
name|curcmd
operator|=
operator|&
name|compiling
expr_stmt|;
name|curcmd
operator|->
name|c_line
operator|=
name|oldcurcmd
operator|->
name|c_line
expr_stmt|;
name|retval
operator|=
name|yyparse
argument_list|()
expr_stmt|;
name|curcmd
operator|=
name|oldcurcmd
expr_stmt|;
name|perldb
operator|=
name|oldperldb
expr_stmt|;
name|in_eval
operator|--
expr_stmt|;
if|if
condition|(
name|retval
operator|||
name|error_count
condition|)
name|fatal
argument_list|(
literal|"Invalid component in string or format"
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|eval_root
expr_stmt|;
name|arg
operator|=
name|cmd
operator|->
name|c_expr
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|c_type
operator|!=
name|C_EXPR
operator|||
name|cmd
operator|->
name|c_next
operator|||
name|arg
operator|->
name|arg_type
operator|!=
name|O_LIST
condition|)
name|fatal
argument_list|(
literal|"panic: error in parselist %d %x %d"
argument_list|,
name|cmd
operator|->
name|c_type
argument_list|,
name|cmd
operator|->
name|c_next
argument_list|,
name|arg
condition|?
name|arg
operator|->
name|arg_type
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|c_expr
operator|=
name|Nullarg
expr_stmt|;
name|cmd_free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|eval_root
operator|=
name|Nullcmd
expr_stmt|;
return|return
name|arg
return|;
block|}
end_function

begin_function
name|void
name|intrpcompile
parameter_list|(
name|src
parameter_list|)
name|STR
modifier|*
name|src
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|str_get
argument_list|(
name|src
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|send
init|=
name|s
operator|+
name|src
operator|->
name|str_cur
decl_stmt|;
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
name|STR
modifier|*
name|toparse
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
specifier|register
name|int
name|brackets
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
name|STAB
modifier|*
name|stab
decl_stmt|;
name|char
modifier|*
name|checkpoint
decl_stmt|;
name|int
name|sawcase
init|=
literal|0
decl_stmt|;
name|toparse
operator|=
name|Str_new
argument_list|(
literal|76
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str
operator|=
name|Str_new
argument_list|(
literal|77
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str_nset
argument_list|(
name|str
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str_nset
argument_list|(
name|toparse
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
operator|&&
name|s
index|[
literal|1
index|]
operator|&&
name|index
argument_list|(
literal|"$@[{\\]}lLuUE"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|str_ncat
argument_list|(
name|str
argument_list|,
name|t
argument_list|,
name|s
operator|-
name|t
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|isALPHA
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|str_ncat
argument_list|(
name|str
argument_list|,
literal|"$c"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sawcase
operator|=
operator|(
operator|*
name|s
operator|!=
literal|'E'
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|nointrp
condition|)
block|{
comment|/* in a regular expression */
if|if
condition|(
operator|*
name|s
operator|==
literal|'@'
condition|)
comment|/* always strip \@ */
comment|/*SUPPRESS 530*/
empty_stmt|;
else|else
comment|/* don't strip \\, \[, \{ etc. */
name|str_ncat
argument_list|(
name|str
argument_list|,
name|s
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|str_ncat
argument_list|(
name|str
argument_list|,
literal|"$b"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|str_ncat
argument_list|(
name|str
argument_list|,
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|++
name|s
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
operator|&&
name|s
operator|+
literal|1
operator|<
name|send
operator|&&
operator|*
name|nointrp
operator|&&
name|index
argument_list|(
name|nointrp
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|str_ncat
argument_list|(
name|str
argument_list|,
name|t
argument_list|,
name|s
operator|-
name|t
argument_list|)
expr_stmt|;
name|str_ncat
argument_list|(
name|str
argument_list|,
literal|"$b"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|str_ncat
argument_list|(
name|str
argument_list|,
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'@'
operator|||
operator|*
name|s
operator|==
literal|'$'
operator|)
operator|&&
name|s
operator|+
literal|1
operator|<
name|send
condition|)
block|{
name|str_ncat
argument_list|(
name|str
argument_list|,
name|t
argument_list|,
name|s
operator|-
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'#'
operator|&&
operator|(
name|isALPHA
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
operator|||
name|s
index|[
literal|2
index|]
operator|==
literal|'_'
operator|)
condition|)
name|s
operator|++
expr_stmt|;
name|s
operator|=
name|scanident
argument_list|(
name|s
argument_list|,
name|send
argument_list|,
name|tokenbuf
argument_list|,
sizeof|sizeof
name|tokenbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'@'
operator|&&
operator|(
operator|!
operator|(
name|stab
operator|=
name|stabent
argument_list|(
name|tokenbuf
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|||
operator|(
operator|*
name|s
operator|==
literal|'{'
condition|?
operator|!
name|stab_xhash
argument_list|(
name|stab
argument_list|)
else|:
operator|!
name|stab_xarray
argument_list|(
name|stab
argument_list|)
operator|)
operator|)
condition|)
block|{
name|str_ncat
argument_list|(
name|str
argument_list|,
literal|"@"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
operator|++
name|t
expr_stmt|;
continue|continue;
comment|/* grandfather @ from old scripts */
block|}
name|str_ncat
argument_list|(
name|str
argument_list|,
literal|"$a"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|str_ncat
argument_list|(
name|toparse
argument_list|,
literal|","
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
index|[
literal|1
index|]
operator|!=
literal|'{'
operator|&&
operator|(
operator|*
name|s
operator|==
literal|'['
operator|||
operator|*
name|s
operator|==
literal|'{'
comment|/* }} */
operator|)
operator|&&
operator|(
name|stab
operator|=
name|stabent
argument_list|(
name|tokenbuf
argument_list|,
name|FALSE
argument_list|)
operator|)
operator|&&
operator|(
operator|(
operator|*
name|s
operator|==
literal|'['
operator|)
condition|?
operator|(
name|stab_xarray
argument_list|(
name|stab
argument_list|)
operator|!=
literal|0
operator|)
else|:
operator|(
name|stab_xhash
argument_list|(
name|stab
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|brackets
operator|=
literal|0
expr_stmt|;
name|checkpoint
operator|=
name|s
expr_stmt|;
do|do
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'['
case|:
name|brackets
operator|++
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|brackets
operator|++
expr_stmt|;
break|break;
case|case
literal|']'
case|:
name|brackets
operator|--
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|brackets
operator|--
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
case|case
literal|'%'
case|:
case|case
literal|'@'
case|:
case|case
literal|'&'
case|:
case|case
literal|'*'
case|:
name|s
operator|=
name|scanident
argument_list|(
name|s
argument_list|,
name|send
argument_list|,
name|tokenbuf
argument_list|,
sizeof|sizeof
name|tokenbuf
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
comment|/*SUPPRESS 68*/
name|s
operator|=
name|cpytill
argument_list|(
name|tokenbuf
argument_list|,
name|s
operator|+
literal|1
argument_list|,
name|send
argument_list|,
operator|*
name|s
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>=
name|send
condition|)
name|fatal
argument_list|(
literal|"Unterminated string"
argument_list|)
expr_stmt|;
break|break;
block|}
name|s
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|brackets
operator|>
literal|0
operator|&&
name|s
operator|<
name|send
condition|)
do|;
if|if
condition|(
name|s
operator|>
name|send
condition|)
name|fatal
argument_list|(
literal|"Unmatched brackets in string"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|nointrp
condition|)
block|{
comment|/* we're in a regular expression */
name|d
operator|=
name|checkpoint
expr_stmt|;
if|if
condition|(
operator|*
name|d
operator|==
literal|'{'
operator|&&
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'}'
condition|)
block|{
comment|/* maybe {n,m} */
operator|++
name|d
expr_stmt|;
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|d
argument_list|)
condition|)
block|{
comment|/* matches /^{\d,?\d*}$/ */
if|if
condition|(
operator|*
operator|++
name|d
operator|==
literal|','
condition|)
operator|++
name|d
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|d
operator|++
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|s
operator|-
literal|1
condition|)
name|s
operator|=
name|checkpoint
expr_stmt|;
comment|/* Is {n,m}! Backoff! */
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'['
operator|&&
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|']'
condition|)
block|{
comment|/* char class? */
name|int
name|weight
init|=
literal|2
decl_stmt|;
comment|/* let's weigh the evidence */
name|char
name|seen
index|[
literal|256
index|]
decl_stmt|;
name|unsigned
name|char
name|un_char
init|=
literal|0
decl_stmt|,
name|last_un_char
decl_stmt|;
name|Zero
argument_list|(
name|seen
argument_list|,
literal|256
argument_list|,
name|char
argument_list|)
expr_stmt|;
operator|*
operator|--
name|s
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|==
literal|'^'
condition|)
name|weight
operator|+=
literal|150
expr_stmt|;
elseif|else
if|if
condition|(
name|d
index|[
literal|1
index|]
operator|==
literal|'$'
condition|)
name|weight
operator|-=
literal|3
expr_stmt|;
if|if
condition|(
name|isDIGIT
argument_list|(
name|d
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|d
index|[
literal|2
index|]
condition|)
block|{
if|if
condition|(
name|isDIGIT
argument_list|(
name|d
index|[
literal|2
index|]
argument_list|)
operator|&&
operator|!
name|d
index|[
literal|3
index|]
condition|)
name|weight
operator|-=
literal|10
expr_stmt|;
block|}
else|else
name|weight
operator|-=
literal|100
expr_stmt|;
block|}
for|for
control|(
name|d
operator|++
init|;
name|d
operator|<
name|s
condition|;
name|d
operator|++
control|)
block|{
name|last_un_char
operator|=
name|un_char
expr_stmt|;
name|un_char
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|d
expr_stmt|;
switch|switch
condition|(
operator|*
name|d
condition|)
block|{
case|case
literal|'&'
case|:
case|case
literal|'$'
case|:
name|weight
operator|-=
name|seen
index|[
name|un_char
index|]
operator|*
literal|10
expr_stmt|;
if|if
condition|(
name|isALNUM
argument_list|(
name|d
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|d
operator|=
name|scanident
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
name|tokenbuf
argument_list|,
sizeof|sizeof
name|tokenbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|stabent
argument_list|(
name|tokenbuf
argument_list|,
name|FALSE
argument_list|)
condition|)
name|weight
operator|-=
literal|100
expr_stmt|;
else|else
name|weight
operator|-=
literal|10
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|d
operator|==
literal|'$'
operator|&&
name|d
index|[
literal|1
index|]
operator|&&
name|index
argument_list|(
literal|"[#!%*<>()-="
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|d
index|[
literal|2
index|]
operator|||
comment|/*{*/
name|index
argument_list|(
literal|"])} ="
argument_list|,
name|d
index|[
literal|2
index|]
argument_list|)
condition|)
name|weight
operator|-=
literal|10
expr_stmt|;
else|else
name|weight
operator|-=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'\\'
case|:
name|un_char
operator|=
literal|254
expr_stmt|;
if|if
condition|(
name|d
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
literal|"wds"
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|)
condition|)
name|weight
operator|+=
literal|100
expr_stmt|;
elseif|else
if|if
condition|(
name|seen
index|[
literal|'\''
index|]
operator|||
name|seen
index|[
literal|'"'
index|]
condition|)
name|weight
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|index
argument_list|(
literal|"rnftb"
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|)
condition|)
name|weight
operator|+=
literal|40
expr_stmt|;
elseif|else
if|if
condition|(
name|isDIGIT
argument_list|(
name|d
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|weight
operator|+=
literal|40
expr_stmt|;
while|while
condition|(
name|d
index|[
literal|1
index|]
operator|&&
name|isDIGIT
argument_list|(
name|d
index|[
literal|1
index|]
argument_list|)
condition|)
name|d
operator|++
expr_stmt|;
block|}
block|}
else|else
name|weight
operator|+=
literal|100
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
name|last_un_char
operator|<
operator|(
name|unsigned
name|char
operator|)
name|d
index|[
literal|1
index|]
operator|||
name|d
index|[
literal|1
index|]
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
literal|"aA01! "
argument_list|,
name|last_un_char
argument_list|)
condition|)
name|weight
operator|+=
literal|30
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
literal|"zZ79~"
argument_list|,
name|d
index|[
literal|1
index|]
argument_list|)
condition|)
name|weight
operator|+=
literal|30
expr_stmt|;
block|}
else|else
name|weight
operator|-=
literal|1
expr_stmt|;
default|default:
if|if
condition|(
name|isALPHA
argument_list|(
operator|*
name|d
argument_list|)
operator|&&
name|d
index|[
literal|1
index|]
operator|&&
name|isALPHA
argument_list|(
name|d
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|bufptr
operator|=
name|d
expr_stmt|;
if|if
condition|(
name|yylex
argument_list|()
operator|!=
name|WORD
condition|)
name|weight
operator|-=
literal|150
expr_stmt|;
name|d
operator|=
name|bufptr
expr_stmt|;
block|}
if|if
condition|(
name|un_char
operator|==
name|last_un_char
operator|+
literal|1
condition|)
name|weight
operator|+=
literal|5
expr_stmt|;
name|weight
operator|-=
name|seen
index|[
name|un_char
index|]
expr_stmt|;
break|break;
block|}
name|seen
index|[
name|un_char
index|]
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|512
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[%s] weight %d\n"
argument_list|,
name|checkpoint
operator|+
literal|1
argument_list|,
name|weight
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|s
operator|++
operator|=
literal|']'
expr_stmt|;
if|if
condition|(
name|weight
operator|>=
literal|0
condition|)
comment|/* probably a character class */
name|s
operator|=
name|checkpoint
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|*
name|t
operator|==
literal|'@'
condition|)
name|str_ncat
argument_list|(
name|toparse
argument_list|,
literal|"join($\","
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
index|[
literal|1
index|]
operator|==
literal|'{'
operator|&&
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'}'
condition|)
block|{
name|str_ncat
argument_list|(
name|toparse
argument_list|,
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|str_ncat
argument_list|(
name|toparse
argument_list|,
name|t
operator|+
literal|2
argument_list|,
name|s
operator|-
name|t
operator|-
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
name|str_ncat
argument_list|(
name|toparse
argument_list|,
name|t
argument_list|,
name|s
operator|-
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'@'
condition|)
name|str_ncat
argument_list|(
name|toparse
argument_list|,
literal|")"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
block|}
else|else
name|s
operator|++
expr_stmt|;
block|}
name|str_ncat
argument_list|(
name|str
argument_list|,
name|t
argument_list|,
name|s
operator|-
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|sawcase
condition|)
name|str_ncat
argument_list|(
name|str
argument_list|,
literal|"$cE"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|toparse
operator|->
name|str_ptr
operator|&&
operator|*
name|toparse
operator|->
name|str_ptr
operator|==
literal|','
condition|)
block|{
operator|*
name|toparse
operator|->
name|str_ptr
operator|=
literal|'('
expr_stmt|;
name|str_ncat
argument_list|(
name|toparse
argument_list|,
literal|",$$);"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_u
operator|.
name|str_args
operator|=
name|parselist
argument_list|(
name|toparse
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_u
operator|.
name|str_args
operator|->
name|arg_len
operator|--
expr_stmt|;
comment|/* ignore $$ reference */
block|}
else|else
name|str
operator|->
name|str_u
operator|.
name|str_args
operator|=
name|Nullarg
expr_stmt|;
name|str_free
argument_list|(
name|toparse
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_pok
operator||=
name|SP_INTRP
expr_stmt|;
name|str
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
name|str_replace
argument_list|(
name|src
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STR
modifier|*
name|interp
parameter_list|(
name|str
parameter_list|,
name|src
parameter_list|,
name|sp
parameter_list|)
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
name|STR
modifier|*
name|src
decl_stmt|;
name|int
name|sp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|send
decl_stmt|;
specifier|register
name|STR
modifier|*
modifier|*
name|elem
decl_stmt|;
name|int
name|docase
init|=
literal|0
decl_stmt|;
name|int
name|l
init|=
literal|0
decl_stmt|;
name|int
name|u
init|=
literal|0
decl_stmt|;
name|int
name|L
init|=
literal|0
decl_stmt|;
name|int
name|U
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|str
operator|==
operator|&
name|str_undef
condition|)
return|return
name|Nullstr
return|;
if|if
condition|(
operator|!
operator|(
name|src
operator|->
name|str_pok
operator|&
name|SP_INTRP
operator|)
condition|)
block|{
name|int
name|oldsave
init|=
name|savestack
operator|->
name|ary_fill
decl_stmt|;
operator|(
name|void
operator|)
name|savehptr
argument_list|(
operator|&
name|curstash
argument_list|)
expr_stmt|;
name|curstash
operator|=
name|curcmd
operator|->
name|c_stash
expr_stmt|;
comment|/* so stabent knows right package */
name|intrpcompile
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|restorelist
argument_list|(
name|oldsave
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|src
operator|->
name|str_ptr
expr_stmt|;
comment|/* assumed valid since str_pok set */
name|t
operator|=
name|s
expr_stmt|;
name|send
operator|=
name|s
operator|+
name|src
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|str_u
operator|.
name|str_args
condition|)
block|{
operator|(
name|void
operator|)
name|eval
argument_list|(
name|src
operator|->
name|str_u
operator|.
name|str_args
argument_list|,
name|G_ARRAY
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* Assuming we have correct # of args */
name|elem
operator|=
name|stack
operator|->
name|ary_array
operator|+
name|sp
expr_stmt|;
block|}
name|str_nset
argument_list|(
name|str
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'$'
operator|&&
name|s
operator|+
literal|1
operator|<
name|send
condition|)
block|{
if|if
condition|(
name|s
operator|-
name|t
operator|>
literal|0
condition|)
name|str_ncat
argument_list|(
name|str
argument_list|,
name|t
argument_list|,
name|s
operator|-
name|t
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
operator|++
name|s
condition|)
block|{
default|default:
name|fatal
argument_list|(
literal|"panic: unknown interp cookie\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|str_scat
argument_list|(
name|str
argument_list|,
operator|*
operator|++
name|elem
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|str_ncat
argument_list|(
name|str
argument_list|,
operator|++
name|s
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|docase
operator|&&
name|str
operator|->
name|str_cur
operator|>=
name|docase
condition|)
block|{
name|char
modifier|*
name|b
init|=
name|str
operator|->
name|str_ptr
operator|+
operator|--
name|docase
decl_stmt|;
if|if
condition|(
name|L
condition|)
name|lcase
argument_list|(
name|b
argument_list|,
name|str
operator|->
name|str_ptr
operator|+
name|str
operator|->
name|str_cur
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|U
condition|)
name|ucase
argument_list|(
name|b
argument_list|,
name|str
operator|->
name|str_ptr
operator|+
name|str
operator|->
name|str_cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
condition|)
comment|/* note that l& u are independent of L& U */
name|ucase
argument_list|(
name|b
argument_list|,
name|b
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|l
condition|)
name|lcase
argument_list|(
name|b
argument_list|,
name|b
operator|+
literal|1
argument_list|)
expr_stmt|;
name|l
operator|=
name|u
operator|=
literal|0
expr_stmt|;
block|}
name|docase
operator|=
name|str
operator|->
name|str_cur
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
operator|*
operator|++
name|s
condition|)
block|{
case|case
literal|'u'
case|:
name|u
operator|=
literal|1
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|U
operator|=
literal|1
expr_stmt|;
name|L
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|l
operator|=
literal|1
expr_stmt|;
name|u
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|L
operator|=
literal|1
expr_stmt|;
name|U
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|docase
operator|=
name|L
operator|=
name|U
operator|=
name|l
operator|=
name|u
operator|=
literal|0
expr_stmt|;
break|break;
block|}
break|break;
block|}
name|t
operator|=
operator|++
name|s
expr_stmt|;
block|}
else|else
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|-
name|t
operator|>
literal|0
condition|)
name|str_ncat
argument_list|(
name|str
argument_list|,
name|t
argument_list|,
name|s
operator|-
name|t
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ucase
parameter_list|(
name|s
parameter_list|,
name|send
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|send
decl_stmt|;
block|{
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
if|if
condition|(
name|isLOWER
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|s
operator|=
name|toupper
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lcase
parameter_list|(
name|s
parameter_list|,
name|send
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|send
decl_stmt|;
block|{
while|while
condition|(
name|s
operator|<
name|send
condition|)
block|{
if|if
condition|(
name|isUPPER
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|s
operator|=
name|tolower
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|str_inc
parameter_list|(
name|str
parameter_list|)
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
if|if
condition|(
operator|!
name|str
operator|||
name|str
operator|==
operator|&
name|str_undef
condition|)
return|return;
if|if
condition|(
name|str
operator|->
name|str_nok
condition|)
block|{
name|str
operator|->
name|str_u
operator|.
name|str_nval
operator|+=
literal|1.0
expr_stmt|;
name|str
operator|->
name|str_pok
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|str
operator|->
name|str_pok
operator|||
operator|!
operator|*
name|str
operator|->
name|str_ptr
condition|)
block|{
name|str
operator|->
name|str_u
operator|.
name|str_nval
operator|=
literal|1.0
expr_stmt|;
name|str
operator|->
name|str_nok
operator|=
literal|1
expr_stmt|;
name|str
operator|->
name|str_pok
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|d
operator|=
name|str
operator|->
name|str_ptr
expr_stmt|;
while|while
condition|(
name|isALPHA
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|d
operator|++
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|d
argument_list|)
condition|)
name|d
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|d
condition|)
block|{
name|str_numset
argument_list|(
name|str
argument_list|,
name|atof
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|)
operator|+
literal|1.0
argument_list|)
expr_stmt|;
comment|/* punt */
return|return;
block|}
name|d
operator|--
expr_stmt|;
while|while
condition|(
name|d
operator|>=
name|str
operator|->
name|str_ptr
condition|)
block|{
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|d
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
operator|*
name|d
operator|<=
literal|'9'
condition|)
return|return;
operator|*
operator|(
name|d
operator|--
operator|)
operator|=
literal|'0'
expr_stmt|;
block|}
else|else
block|{
operator|++
operator|*
name|d
expr_stmt|;
if|if
condition|(
name|isALPHA
argument_list|(
operator|*
name|d
argument_list|)
condition|)
return|return;
operator|*
operator|(
name|d
operator|--
operator|)
operator|-=
literal|'z'
operator|-
literal|'a'
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* oh,oh, the number grew */
name|STR_GROW
argument_list|(
name|str
argument_list|,
name|str
operator|->
name|str_cur
operator|+
literal|2
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_cur
operator|++
expr_stmt|;
for|for
control|(
name|d
operator|=
name|str
operator|->
name|str_ptr
operator|+
name|str
operator|->
name|str_cur
init|;
name|d
operator|>
name|str
operator|->
name|str_ptr
condition|;
name|d
operator|--
control|)
operator|*
name|d
operator|=
name|d
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|isDIGIT
argument_list|(
name|d
index|[
literal|1
index|]
argument_list|)
condition|)
operator|*
name|d
operator|=
literal|'1'
expr_stmt|;
else|else
operator|*
name|d
operator|=
name|d
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_function
name|void
name|str_dec
parameter_list|(
name|str
parameter_list|)
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|str
operator|||
name|str
operator|==
operator|&
name|str_undef
condition|)
return|return;
if|if
condition|(
name|str
operator|->
name|str_nok
condition|)
block|{
name|str
operator|->
name|str_u
operator|.
name|str_nval
operator|-=
literal|1.0
expr_stmt|;
name|str
operator|->
name|str_pok
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|str
operator|->
name|str_pok
condition|)
block|{
name|str
operator|->
name|str_u
operator|.
name|str_nval
operator|=
operator|-
literal|1.0
expr_stmt|;
name|str
operator|->
name|str_nok
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|str_numset
argument_list|(
name|str
argument_list|,
name|atof
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|)
operator|-
literal|1.0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make a string that will exist for the duration of the expression  * evaluation.  Actually, it may have to last longer than that, but  * hopefully cmd_exec won't free it until it has been assigned to a  * permanent location. */
end_comment

begin_decl_stmt
specifier|static
name|long
name|tmps_size
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|STR
modifier|*
name|str_mortal
parameter_list|(
name|oldstr
parameter_list|)
name|STR
modifier|*
name|oldstr
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
name|str
init|=
name|Str_new
argument_list|(
literal|78
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|str_sset
argument_list|(
name|str
argument_list|,
name|oldstr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|tmps_max
operator|>
name|tmps_size
condition|)
block|{
name|tmps_size
operator|=
name|tmps_max
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmps_size
operator|&
literal|127
operator|)
condition|)
block|{
if|if
condition|(
name|tmps_size
condition|)
name|Renew
argument_list|(
name|tmps_list
argument_list|,
name|tmps_size
operator|+
literal|128
argument_list|,
name|STR
operator|*
argument_list|)
expr_stmt|;
else|else
name|New
argument_list|(
literal|702
argument_list|,
name|tmps_list
argument_list|,
literal|128
argument_list|,
name|STR
operator|*
argument_list|)
expr_stmt|;
block|}
block|}
name|tmps_list
index|[
name|tmps_max
index|]
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|str
operator|->
name|str_pok
condition|)
name|str
operator|->
name|str_pok
operator||=
name|SP_TEMP
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* same thing without the copying */
end_comment

begin_function
name|STR
modifier|*
name|str_2mortal
parameter_list|(
name|str
parameter_list|)
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|str
operator|||
name|str
operator|==
operator|&
name|str_undef
condition|)
return|return
name|str
return|;
if|if
condition|(
operator|++
name|tmps_max
operator|>
name|tmps_size
condition|)
block|{
name|tmps_size
operator|=
name|tmps_max
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmps_size
operator|&
literal|127
operator|)
condition|)
block|{
if|if
condition|(
name|tmps_size
condition|)
name|Renew
argument_list|(
name|tmps_list
argument_list|,
name|tmps_size
operator|+
literal|128
argument_list|,
name|STR
operator|*
argument_list|)
expr_stmt|;
else|else
name|New
argument_list|(
literal|704
argument_list|,
name|tmps_list
argument_list|,
literal|128
argument_list|,
name|STR
operator|*
argument_list|)
expr_stmt|;
block|}
block|}
name|tmps_list
index|[
name|tmps_max
index|]
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|str
operator|->
name|str_pok
condition|)
name|str
operator|->
name|str_pok
operator||=
name|SP_TEMP
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_function
name|STR
modifier|*
name|str_make
parameter_list|(
name|s
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|STRLEN
name|len
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
name|str
init|=
name|Str_new
argument_list|(
literal|79
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|str_nset
argument_list|(
name|str
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_function
name|STR
modifier|*
name|str_nmake
parameter_list|(
name|n
parameter_list|)
name|double
name|n
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
name|str
init|=
name|Str_new
argument_list|(
literal|80
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|str_numset
argument_list|(
name|str
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* make an exact duplicate of old */
end_comment

begin_function
name|STR
modifier|*
name|str_smake
parameter_list|(
name|old
parameter_list|)
specifier|register
name|STR
modifier|*
name|old
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
name|new
init|=
name|Str_new
argument_list|(
literal|81
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|old
condition|)
return|return
name|Nullstr
return|;
if|if
condition|(
name|old
operator|->
name|str_state
operator|==
name|SS_FREE
condition|)
block|{
name|warn
argument_list|(
literal|"semi-panic: attempt to dup freed string"
argument_list|)
expr_stmt|;
return|return
name|Nullstr
return|;
block|}
if|if
condition|(
name|old
operator|->
name|str_state
operator|==
name|SS_INCR
operator|&&
operator|!
operator|(
name|old
operator|->
name|str_pok
operator|&
literal|2
operator|)
condition|)
name|Str_Grow
argument_list|(
name|old
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|str_ptr
condition|)
name|Safefree
argument_list|(
name|new
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
name|StructCopy
argument_list|(
name|old
argument_list|,
name|new
argument_list|,
name|STR
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|->
name|str_ptr
condition|)
block|{
name|new
operator|->
name|str_ptr
operator|=
name|nsavestr
argument_list|(
name|old
operator|->
name|str_ptr
argument_list|,
name|old
operator|->
name|str_len
argument_list|)
expr_stmt|;
name|new
operator|->
name|str_pok
operator|&=
operator|~
name|SP_TEMP
expr_stmt|;
block|}
return|return
name|new
return|;
block|}
end_function

begin_function
name|void
name|str_reset
parameter_list|(
name|s
parameter_list|,
name|stash
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|HASH
modifier|*
name|stash
decl_stmt|;
block|{
specifier|register
name|HENT
modifier|*
name|entry
decl_stmt|;
specifier|register
name|STAB
modifier|*
name|stab
decl_stmt|;
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|SPAT
modifier|*
name|spat
decl_stmt|;
specifier|register
name|int
name|max
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
block|{
comment|/* reset ?? searches */
for|for
control|(
name|spat
operator|=
name|stash
operator|->
name|tbl_spatroot
init|;
name|spat
operator|!=
name|Nullspat
condition|;
name|spat
operator|=
name|spat
operator|->
name|spat_next
control|)
block|{
name|spat
operator|->
name|spat_flags
operator|&=
operator|~
name|SPAT_USED
expr_stmt|;
block|}
return|return;
block|}
comment|/* reset variables */
if|if
condition|(
operator|!
name|stash
operator|->
name|tbl_array
condition|)
return|return;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|i
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|s
operator|+=
literal|2
expr_stmt|;
block|}
name|max
operator|=
operator|*
name|s
operator|++
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|entry
operator|=
name|stash
operator|->
name|tbl_array
index|[
name|i
index|]
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|hent_next
control|)
block|{
name|stab
operator|=
operator|(
name|STAB
operator|*
operator|)
name|entry
operator|->
name|hent_val
expr_stmt|;
name|str
operator|=
name|stab_val
argument_list|(
name|stab
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_cur
operator|=
literal|0
expr_stmt|;
name|str
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TAINT
name|str
operator|->
name|str_tainted
operator|=
name|tainted
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|str
operator|->
name|str_ptr
operator|!=
name|Nullch
condition|)
name|str
operator|->
name|str_ptr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stab_xarray
argument_list|(
name|stab
argument_list|)
condition|)
block|{
name|aclear
argument_list|(
name|stab_xarray
argument_list|(
name|stab
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stab_xhash
argument_list|(
name|stab
argument_list|)
condition|)
block|{
name|hclear
argument_list|(
name|stab_xhash
argument_list|(
name|stab
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|stab
operator|==
name|envstab
condition|)
name|environ
index|[
literal|0
index|]
operator|=
name|Nullch
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TAINT
end_ifdef

begin_function
name|void
name|taintproper
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|2048
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %d %d %d\n"
argument_list|,
name|s
argument_list|,
name|tainted
argument_list|,
name|uid
argument_list|,
name|euid
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tainted
operator|&&
operator|(
operator|!
name|euid
operator|||
name|euid
operator|!=
name|uid
operator|||
name|egid
operator|!=
name|gid
operator|||
name|taintanyway
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|unsafe
condition|)
name|fatal
argument_list|(
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dowarn
condition|)
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|taintenv
parameter_list|()
block|{
specifier|register
name|STR
modifier|*
name|envstr
decl_stmt|;
name|envstr
operator|=
name|hfetch
argument_list|(
name|stab_hash
argument_list|(
name|envstab
argument_list|)
argument_list|,
literal|"PATH"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|envstr
operator|==
operator|&
name|str_undef
operator|||
name|envstr
operator|->
name|str_tainted
condition|)
block|{
name|tainted
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|envstr
operator|->
name|str_tainted
operator|==
literal|2
condition|)
name|taintproper
argument_list|(
literal|"Insecure directory in PATH"
argument_list|)
expr_stmt|;
else|else
name|taintproper
argument_list|(
literal|"Insecure PATH"
argument_list|)
expr_stmt|;
block|}
name|envstr
operator|=
name|hfetch
argument_list|(
name|stab_hash
argument_list|(
name|envstab
argument_list|)
argument_list|,
literal|"IFS"
argument_list|,
literal|3
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|envstr
operator|!=
operator|&
name|str_undef
operator|&&
name|envstr
operator|->
name|str_tainted
condition|)
block|{
name|tainted
operator|=
literal|1
expr_stmt|;
name|taintproper
argument_list|(
literal|"Insecure IFS"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TAINT */
end_comment

end_unit

