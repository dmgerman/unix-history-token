begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $RCSfile: cmd.c,v $$Revision: 1.2 $$Date: 1995/05/30 05:02:52 $  *  *    Copyright (c) 1991, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  * $Log: cmd.c,v $  * Revision 1.2  1995/05/30 05:02:52  rgrimes  * Remove trailing whitespace.  *  * Revision 1.1.1.1  1994/09/10  06:27:32  gclarkii  * Initial import of Perl 4.046 bmaked  *  * Revision 1.1.1.1  1993/08/23  21:29:35  nate  * PERL!  *  * Revision 4.0.1.5  92/06/08  12:00:39  lwall  * patch20: the switch optimizer didn't do anything in subroutines  * patch20: removed implicit int declarations on funcions  *  * Revision 4.0.1.4  91/11/11  16:29:33  lwall  * patch19: do {$foo ne "bar";} returned wrong value  * patch19: some earlier patches weren't propagated to alternate 286 code  *  * Revision 4.0.1.3  91/11/05  16:07:43  lwall  * patch11: random cleanup  * patch11: "foo\0" eq "foo" was sometimes optimized to true  * patch11: foreach on null list could spring memory leak  *  * Revision 4.0.1.2  91/06/07  10:26:45  lwall  * patch4: new copyright notice  * patch4: made some allowances for "semi-standard" C  *  * Revision 4.0.1.1  91/04/11  17:36:16  lwall  * patch1: you may now use "die" and "caller" in a signal handler  *  * Revision 4.0  91/03/20  01:04:18  lwall  * 4.0 baseline.  *  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|I_VARARGS
end_ifdef

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|STR
name|strchop
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|grow_dlevel
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* do longjmps() clobber register variables? */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|cray
argument_list|)
operator|||
name|defined
argument_list|(
name|STANDARD_C
argument_list|)
end_if

begin_define
define|#
directive|define
name|JMPCLOBBER
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is the main command loop.  We try to spend as much time in this loop  * as possible, so lots of optimizations do their activities in here.  This  * means things get a little sloppy.  */
end_comment

begin_function
name|int
name|cmd_exec
parameter_list|(
name|cmdparm
parameter_list|,
name|gimme
parameter_list|,
name|sp
parameter_list|)
name|CMD
modifier|*
name|VOLATILE
name|cmdparm
decl_stmt|;
name|VOLATILE
name|int
name|gimme
decl_stmt|;
name|VOLATILE
name|int
name|sp
decl_stmt|;
block|{
specifier|register
name|CMD
modifier|*
name|cmd
init|=
name|cmdparm
decl_stmt|;
name|SPAT
modifier|*
name|VOLATILE
name|oldspat
decl_stmt|;
name|VOLATILE
name|int
name|firstsave
init|=
name|savestack
operator|->
name|ary_fill
decl_stmt|;
name|VOLATILE
name|int
name|oldsave
decl_stmt|;
name|VOLATILE
name|int
name|aryoptsave
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|VOLATILE
name|int
name|olddlevel
decl_stmt|;
name|VOLATILE
name|int
name|entdlevel
decl_stmt|;
endif|#
directive|endif
specifier|register
name|STR
modifier|*
name|retstr
init|=
operator|&
name|str_undef
decl_stmt|;
specifier|register
name|char
modifier|*
name|tmps
decl_stmt|;
specifier|register
name|int
name|cmdflags
decl_stmt|;
specifier|register
name|int
name|match
decl_stmt|;
specifier|register
name|char
modifier|*
name|go_to
init|=
name|goto_targ
decl_stmt|;
specifier|register
name|int
name|newsp
init|=
operator|-
literal|2
decl_stmt|;
specifier|register
name|STR
modifier|*
modifier|*
name|st
init|=
name|stack
operator|->
name|ary_array
decl_stmt|;
name|FILE
modifier|*
name|VOLATILE
name|fp
decl_stmt|;
name|ARRAY
modifier|*
name|VOLATILE
name|ar
decl_stmt|;
name|lastsize
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|entdlevel
operator|=
name|dlevel
expr_stmt|;
endif|#
directive|endif
name|tail_recursion_entry
label|:
ifdef|#
directive|ifdef
name|DEBUGGING
name|dlevel
operator|=
name|entdlevel
expr_stmt|;
if|if
condition|(
name|debug
operator|&
literal|4
condition|)
name|deb
argument_list|(
literal|"mortals = (%d/%d) stack, = (%d/%d)\n"
argument_list|,
name|tmps_max
argument_list|,
name|tmps_base
argument_list|,
name|savestack
operator|->
name|ary_fill
argument_list|,
name|firstsave
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TAINT
name|tainted
operator|=
literal|0
expr_stmt|;
comment|/* Each statement is presumed innocent */
endif|#
directive|endif
if|if
condition|(
name|cmd
operator|==
name|Nullcmd
condition|)
block|{
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
operator|&&
name|newsp
operator|>
operator|-
literal|2
condition|)
return|return
name|newsp
return|;
else|else
block|{
name|st
index|[
operator|++
name|sp
index|]
operator|=
name|retstr
expr_stmt|;
return|return
name|sp
return|;
block|}
block|}
name|cmdflags
operator|=
name|cmd
operator|->
name|c_flags
expr_stmt|;
comment|/* hopefully load register */
if|if
condition|(
name|go_to
condition|)
block|{
if|if
condition|(
name|cmd
operator|->
name|c_label
operator|&&
name|strEQ
argument_list|(
name|go_to
argument_list|,
name|cmd
operator|->
name|c_label
argument_list|)
condition|)
name|goto_targ
operator|=
name|go_to
operator|=
name|Nullch
expr_stmt|;
comment|/* here at last */
else|else
block|{
switch|switch
condition|(
name|cmd
operator|->
name|c_type
condition|)
block|{
case|case
name|C_IF
case|:
name|oldspat
operator|=
name|curspat
expr_stmt|;
name|oldsave
operator|=
name|savestack
operator|->
name|ary_fill
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|olddlevel
operator|=
name|dlevel
expr_stmt|;
endif|#
directive|endif
name|retstr
operator|=
operator|&
name|str_yes
expr_stmt|;
name|newsp
operator|=
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
block|{
name|debname
index|[
name|dlevel
index|]
operator|=
literal|'t'
expr_stmt|;
name|debdelim
index|[
name|dlevel
index|]
operator|=
literal|'_'
expr_stmt|;
if|if
condition|(
operator|++
name|dlevel
operator|>=
name|dlmax
condition|)
name|grow_dlevel
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|newsp
operator|=
name|cmd_exec
argument_list|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
argument_list|,
name|gimme
operator|&&
operator|(
name|cmdflags
operator|&
name|CF_TERM
operator|)
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
comment|/* possibly reallocated */
name|retstr
operator|=
name|st
index|[
name|newsp
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|goto_targ
condition|)
name|go_to
operator|=
name|Nullch
expr_stmt|;
name|curspat
operator|=
name|oldspat
expr_stmt|;
if|if
condition|(
name|savestack
operator|->
name|ary_fill
operator|>
name|oldsave
condition|)
name|restorelist
argument_list|(
name|oldsave
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|dlevel
operator|=
name|olddlevel
expr_stmt|;
endif|#
directive|endif
name|cmd
operator|=
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
expr_stmt|;
goto|goto
name|tail_recursion_entry
goto|;
case|case
name|C_ELSE
case|:
name|oldspat
operator|=
name|curspat
expr_stmt|;
name|oldsave
operator|=
name|savestack
operator|->
name|ary_fill
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|olddlevel
operator|=
name|dlevel
expr_stmt|;
endif|#
directive|endif
name|retstr
operator|=
operator|&
name|str_undef
expr_stmt|;
name|newsp
operator|=
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
block|{
name|debname
index|[
name|dlevel
index|]
operator|=
literal|'e'
expr_stmt|;
name|debdelim
index|[
name|dlevel
index|]
operator|=
literal|'_'
expr_stmt|;
if|if
condition|(
operator|++
name|dlevel
operator|>=
name|dlmax
condition|)
name|grow_dlevel
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|newsp
operator|=
name|cmd_exec
argument_list|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
argument_list|,
name|gimme
operator|&&
operator|(
name|cmdflags
operator|&
name|CF_TERM
operator|)
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
comment|/* possibly reallocated */
name|retstr
operator|=
name|st
index|[
name|newsp
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|goto_targ
condition|)
name|go_to
operator|=
name|Nullch
expr_stmt|;
name|curspat
operator|=
name|oldspat
expr_stmt|;
if|if
condition|(
name|savestack
operator|->
name|ary_fill
operator|>
name|oldsave
condition|)
name|restorelist
argument_list|(
name|oldsave
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|dlevel
operator|=
name|olddlevel
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|C_BLOCK
case|:
case|case
name|C_WHILE
case|:
if|if
condition|(
operator|!
operator|(
name|cmdflags
operator|&
name|CF_ONCE
operator|)
condition|)
block|{
name|cmdflags
operator||=
name|CF_ONCE
expr_stmt|;
if|if
condition|(
operator|++
name|loop_ptr
operator|>=
name|loop_max
condition|)
block|{
name|loop_max
operator|+=
literal|128
expr_stmt|;
name|Renew
argument_list|(
name|loop_stack
argument_list|,
name|loop_max
argument_list|,
expr|struct
name|loop
argument_list|)
expr_stmt|;
block|}
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_label
operator|=
name|cmd
operator|->
name|c_label
expr_stmt|;
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_sp
operator|=
name|sp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|4
condition|)
block|{
name|deb
argument_list|(
literal|"(Pushing label #%d %s)\n"
argument_list|,
name|loop_ptr
argument_list|,
name|cmd
operator|->
name|c_label
condition|?
name|cmd
operator|->
name|c_label
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|JMPCLOBBER
name|cmdparm
operator|=
name|cmd
expr_stmt|;
endif|#
directive|endif
name|match
operator|=
name|setjmp
argument_list|(
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_env
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
condition|)
block|{
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
comment|/* possibly reallocated */
ifdef|#
directive|ifdef
name|JMPCLOBBER
name|cmd
operator|=
name|cmdparm
expr_stmt|;
name|cmdflags
operator|=
name|cmd
operator|->
name|c_flags
operator||
name|CF_ONCE
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|savestack
operator|->
name|ary_fill
operator|>
name|oldsave
condition|)
name|restorelist
argument_list|(
name|oldsave
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|match
condition|)
block|{
default|default:
name|fatal
argument_list|(
literal|"longjmp returned bad value (%d)"
argument_list|,
name|match
argument_list|)
expr_stmt|;
case|case
name|O_LAST
case|:
comment|/* not done unless go_to found */
name|go_to
operator|=
name|Nullch
expr_stmt|;
if|if
condition|(
name|lastretstr
condition|)
block|{
name|retstr
operator|=
name|lastretstr
expr_stmt|;
name|newsp
operator|=
operator|-
literal|2
expr_stmt|;
block|}
else|else
block|{
name|newsp
operator|=
name|sp
operator|+
name|lastsize
expr_stmt|;
name|retstr
operator|=
name|st
index|[
name|newsp
index|]
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
name|olddlevel
operator|=
name|dlevel
expr_stmt|;
endif|#
directive|endif
name|curspat
operator|=
name|oldspat
expr_stmt|;
goto|goto
name|next_cmd
goto|;
case|case
name|O_NEXT
case|:
comment|/* not done unless go_to found */
name|go_to
operator|=
name|Nullch
expr_stmt|;
ifdef|#
directive|ifdef
name|JMPCLOBBER
name|newsp
operator|=
operator|-
literal|2
expr_stmt|;
name|retstr
operator|=
operator|&
name|str_undef
expr_stmt|;
endif|#
directive|endif
goto|goto
name|next_iter
goto|;
case|case
name|O_REDO
case|:
comment|/* not done unless go_to found */
name|go_to
operator|=
name|Nullch
expr_stmt|;
ifdef|#
directive|ifdef
name|JMPCLOBBER
name|newsp
operator|=
operator|-
literal|2
expr_stmt|;
name|retstr
operator|=
operator|&
name|str_undef
expr_stmt|;
endif|#
directive|endif
goto|goto
name|doit
goto|;
block|}
block|}
name|oldspat
operator|=
name|curspat
expr_stmt|;
name|oldsave
operator|=
name|savestack
operator|->
name|ary_fill
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|olddlevel
operator|=
name|dlevel
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
block|{
name|debname
index|[
name|dlevel
index|]
operator|=
literal|'t'
expr_stmt|;
name|debdelim
index|[
name|dlevel
index|]
operator|=
literal|'_'
expr_stmt|;
if|if
condition|(
operator|++
name|dlevel
operator|>=
name|dlmax
condition|)
name|grow_dlevel
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|newsp
operator|=
name|cmd_exec
argument_list|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
argument_list|,
name|gimme
operator|&&
operator|(
name|cmdflags
operator|&
name|CF_TERM
operator|)
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
comment|/* possibly reallocated */
if|if
condition|(
name|newsp
operator|>=
literal|0
condition|)
name|retstr
operator|=
name|st
index|[
name|newsp
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|goto_targ
condition|)
block|{
name|go_to
operator|=
name|Nullch
expr_stmt|;
goto|goto
name|next_iter
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
name|dlevel
operator|=
name|olddlevel
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
block|{
name|debname
index|[
name|dlevel
index|]
operator|=
literal|'a'
expr_stmt|;
name|debdelim
index|[
name|dlevel
index|]
operator|=
literal|'_'
expr_stmt|;
if|if
condition|(
operator|++
name|dlevel
operator|>=
name|dlmax
condition|)
name|grow_dlevel
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|newsp
operator|=
name|cmd_exec
argument_list|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
argument_list|,
name|gimme
operator|&&
operator|(
name|cmdflags
operator|&
name|CF_TERM
operator|)
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
comment|/* possibly reallocated */
if|if
condition|(
name|newsp
operator|>=
literal|0
condition|)
name|retstr
operator|=
name|st
index|[
name|newsp
index|]
expr_stmt|;
block|}
if|if
condition|(
name|goto_targ
condition|)
break|break;
name|go_to
operator|=
name|Nullch
expr_stmt|;
goto|goto
name|finish_while
goto|;
block|}
name|cmd
operator|=
name|cmd
operator|->
name|c_next
expr_stmt|;
if|if
condition|(
name|cmd
operator|&&
name|cmd
operator|->
name|c_head
operator|==
name|cmd
condition|)
comment|/* reached end of while loop */
return|return
name|sp
return|;
comment|/* targ isn't in this block */
if|if
condition|(
name|cmdflags
operator|&
name|CF_ONCE
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|4
condition|)
block|{
name|tmps
operator|=
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_label
expr_stmt|;
name|deb
argument_list|(
literal|"(Popping label #%d %s)\n"
argument_list|,
name|loop_ptr
argument_list|,
name|tmps
condition|?
name|tmps
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|loop_ptr
operator|--
expr_stmt|;
block|}
goto|goto
name|tail_recursion_entry
goto|;
block|}
block|}
name|until_loop
label|:
comment|/* Set line number so run-time errors can be located */
name|curcmd
operator|=
name|cmd
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
block|{
if|if
condition|(
name|debug
operator|&
literal|2
condition|)
block|{
name|deb
argument_list|(
literal|"%s	(%lx)	r%lx	t%lx	a%lx	n%lx	cs%lx\n"
argument_list|,
name|cmdname
index|[
name|cmd
operator|->
name|c_type
index|]
argument_list|,
name|cmd
argument_list|,
name|cmd
operator|->
name|c_expr
argument_list|,
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
argument_list|,
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
argument_list|,
name|cmd
operator|->
name|c_next
argument_list|,
name|curspat
argument_list|)
expr_stmt|;
block|}
name|debname
index|[
name|dlevel
index|]
operator|=
name|cmdname
index|[
name|cmd
operator|->
name|c_type
index|]
index|[
literal|0
index|]
expr_stmt|;
name|debdelim
index|[
name|dlevel
index|]
operator|=
literal|'!'
expr_stmt|;
if|if
condition|(
operator|++
name|dlevel
operator|>=
name|dlmax
condition|)
name|grow_dlevel
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Here is some common optimization */
if|if
condition|(
name|cmdflags
operator|&
name|CF_COND
condition|)
block|{
switch|switch
condition|(
name|cmdflags
operator|&
name|CF_OPTIMIZE
condition|)
block|{
case|case
name|CFT_FALSE
case|:
name|retstr
operator|=
name|cmd
operator|->
name|c_short
expr_stmt|;
name|newsp
operator|=
operator|-
literal|2
expr_stmt|;
name|match
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|cmdflags
operator|&
name|CF_NESURE
condition|)
goto|goto
name|maybe
goto|;
break|break;
case|case
name|CFT_TRUE
case|:
name|retstr
operator|=
name|cmd
operator|->
name|c_short
expr_stmt|;
name|newsp
operator|=
operator|-
literal|2
expr_stmt|;
name|match
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|cmdflags
operator|&
name|CF_EQSURE
condition|)
goto|goto
name|flipmaybe
goto|;
break|break;
case|case
name|CFT_REG
case|:
name|retstr
operator|=
name|STAB_STR
argument_list|(
name|cmd
operator|->
name|c_stab
argument_list|)
expr_stmt|;
name|newsp
operator|=
operator|-
literal|2
expr_stmt|;
name|match
operator|=
name|str_true
argument_list|(
name|retstr
argument_list|)
expr_stmt|;
comment|/* => retstr = retstr, c2 should fix */
if|if
condition|(
name|cmdflags
operator|&
operator|(
name|match
condition|?
name|CF_EQSURE
else|:
name|CF_NESURE
operator|)
condition|)
goto|goto
name|flipmaybe
goto|;
break|break;
case|case
name|CFT_ANCHOR
case|:
comment|/* /^pat/ optimization */
if|if
condition|(
name|multiline
condition|)
block|{
if|if
condition|(
operator|*
name|cmd
operator|->
name|c_short
operator|->
name|str_ptr
operator|&&
operator|!
operator|(
name|cmdflags
operator|&
name|CF_EQSURE
operator|)
condition|)
goto|goto
name|scanner
goto|;
comment|/* just unanchor it */
else|else
break|break;
comment|/* must evaluate */
block|}
name|match
operator|=
literal|0
expr_stmt|;
goto|goto
name|strop
goto|;
case|case
name|CFT_STROP
case|:
comment|/* string op optimization */
name|match
operator|=
literal|1
expr_stmt|;
name|strop
label|:
name|retstr
operator|=
name|STAB_STR
argument_list|(
name|cmd
operator|->
name|c_stab
argument_list|)
expr_stmt|;
name|newsp
operator|=
operator|-
literal|2
expr_stmt|;
ifndef|#
directive|ifndef
name|I286
if|if
condition|(
operator|*
name|cmd
operator|->
name|c_short
operator|->
name|str_ptr
operator|==
operator|*
name|str_get
argument_list|(
name|retstr
argument_list|)
operator|&&
operator|(
name|match
condition|?
name|retstr
operator|->
name|str_cur
operator|==
name|cmd
operator|->
name|c_slen
operator|-
literal|1
else|:
name|retstr
operator|->
name|str_cur
operator|>=
name|cmd
operator|->
name|c_slen
operator|)
operator|&&
name|bcmp
argument_list|(
name|cmd
operator|->
name|c_short
operator|->
name|str_ptr
argument_list|,
name|str_get
argument_list|(
name|retstr
argument_list|)
argument_list|,
name|cmd
operator|->
name|c_slen
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cmdflags
operator|&
name|CF_EQSURE
condition|)
block|{
if|if
condition|(
name|sawampersand
operator|&&
operator|(
name|cmdflags
operator|&
name|CF_OPTIMIZE
operator|)
operator|!=
name|CFT_STROP
condition|)
block|{
name|curspat
operator|=
name|Nullspat
expr_stmt|;
if|if
condition|(
name|leftstab
condition|)
name|str_nset
argument_list|(
name|stab_val
argument_list|(
name|leftstab
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|amperstab
condition|)
name|str_sset
argument_list|(
name|stab_val
argument_list|(
name|amperstab
argument_list|)
argument_list|,
name|cmd
operator|->
name|c_short
argument_list|)
expr_stmt|;
if|if
condition|(
name|rightstab
condition|)
name|str_nset
argument_list|(
name|stab_val
argument_list|(
name|rightstab
argument_list|)
argument_list|,
name|retstr
operator|->
name|str_ptr
operator|+
name|cmd
operator|->
name|c_slen
argument_list|,
name|retstr
operator|->
name|str_cur
operator|-
name|cmd
operator|->
name|c_slen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|->
name|c_spat
condition|)
name|lastspat
operator|=
name|cmd
operator|->
name|c_spat
expr_stmt|;
name|match
operator|=
operator|!
operator|(
name|cmdflags
operator|&
name|CF_FIRSTNEG
operator|)
expr_stmt|;
name|retstr
operator|=
name|match
condition|?
operator|&
name|str_yes
else|:
operator|&
name|str_no
expr_stmt|;
goto|goto
name|flipmaybe
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|cmdflags
operator|&
name|CF_NESURE
condition|)
block|{
name|match
operator|=
name|cmdflags
operator|&
name|CF_FIRSTNEG
expr_stmt|;
name|retstr
operator|=
name|match
condition|?
operator|&
name|str_yes
else|:
operator|&
name|str_no
expr_stmt|;
goto|goto
name|flipmaybe
goto|;
block|}
else|#
directive|else
block|{
name|char
modifier|*
name|zap1
decl_stmt|,
modifier|*
name|zap2
decl_stmt|,
name|zap1c
decl_stmt|,
name|zap2c
decl_stmt|;
name|int
name|zaplen
decl_stmt|;
name|int
name|lenok
decl_stmt|;
name|zap1
operator|=
name|cmd
operator|->
name|c_short
operator|->
name|str_ptr
expr_stmt|;
name|zap2
operator|=
name|str_get
argument_list|(
name|retstr
argument_list|)
expr_stmt|;
name|zap1c
operator|=
operator|*
name|zap1
expr_stmt|;
name|zap2c
operator|=
operator|*
name|zap2
expr_stmt|;
name|zaplen
operator|=
name|cmd
operator|->
name|c_slen
expr_stmt|;
if|if
condition|(
name|match
condition|)
name|lenok
operator|=
operator|(
name|retstr
operator|->
name|str_cur
operator|==
name|cmd
operator|->
name|c_slen
operator|-
literal|1
operator|)
expr_stmt|;
else|else
name|lenok
operator|=
operator|(
name|retstr
operator|->
name|str_cur
operator|>=
name|cmd
operator|->
name|c_slen
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|zap1c
operator|==
name|zap2c
operator|)
operator|&&
name|lenok
operator|&&
operator|(
name|bcmp
argument_list|(
name|zap1
argument_list|,
name|zap2
argument_list|,
name|zaplen
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|cmdflags
operator|&
name|CF_EQSURE
condition|)
block|{
if|if
condition|(
name|sawampersand
operator|&&
operator|(
name|cmdflags
operator|&
name|CF_OPTIMIZE
operator|)
operator|!=
name|CFT_STROP
condition|)
block|{
name|curspat
operator|=
name|Nullspat
expr_stmt|;
if|if
condition|(
name|leftstab
condition|)
name|str_nset
argument_list|(
name|stab_val
argument_list|(
name|leftstab
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|amperstab
condition|)
name|str_sset
argument_list|(
name|stab_val
argument_list|(
name|amperstab
argument_list|)
argument_list|,
name|cmd
operator|->
name|c_short
argument_list|)
expr_stmt|;
if|if
condition|(
name|rightstab
condition|)
name|str_nset
argument_list|(
name|stab_val
argument_list|(
name|rightstab
argument_list|)
argument_list|,
name|retstr
operator|->
name|str_ptr
operator|+
name|cmd
operator|->
name|c_slen
argument_list|,
name|retstr
operator|->
name|str_cur
operator|-
name|cmd
operator|->
name|c_slen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|->
name|c_spat
condition|)
name|lastspat
operator|=
name|cmd
operator|->
name|c_spat
expr_stmt|;
name|match
operator|=
operator|!
operator|(
name|cmdflags
operator|&
name|CF_FIRSTNEG
operator|)
expr_stmt|;
name|retstr
operator|=
name|match
condition|?
operator|&
name|str_yes
else|:
operator|&
name|str_no
expr_stmt|;
goto|goto
name|flipmaybe
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|cmdflags
operator|&
name|CF_NESURE
condition|)
block|{
name|match
operator|=
name|cmdflags
operator|&
name|CF_FIRSTNEG
expr_stmt|;
name|retstr
operator|=
name|match
condition|?
operator|&
name|str_yes
else|:
operator|&
name|str_no
expr_stmt|;
goto|goto
name|flipmaybe
goto|;
block|}
block|}
endif|#
directive|endif
break|break;
comment|/* must evaluate */
case|case
name|CFT_SCAN
case|:
comment|/* non-anchored search */
name|scanner
label|:
name|retstr
operator|=
name|STAB_STR
argument_list|(
name|cmd
operator|->
name|c_stab
argument_list|)
expr_stmt|;
name|newsp
operator|=
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|retstr
operator|->
name|str_pok
operator|&
name|SP_STUDIED
condition|)
if|if
condition|(
name|screamfirst
index|[
name|cmd
operator|->
name|c_short
operator|->
name|str_rare
index|]
operator|>=
literal|0
condition|)
name|tmps
operator|=
name|screaminstr
argument_list|(
name|retstr
argument_list|,
name|cmd
operator|->
name|c_short
argument_list|)
expr_stmt|;
else|else
name|tmps
operator|=
name|Nullch
expr_stmt|;
else|else
block|{
name|tmps
operator|=
name|str_get
argument_list|(
name|retstr
argument_list|)
expr_stmt|;
comment|/* make sure it's pok */
ifndef|#
directive|ifndef
name|lint
name|tmps
operator|=
name|fbminstr
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tmps
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tmps
operator|+
name|retstr
operator|->
name|str_cur
argument_list|,
name|cmd
operator|->
name|c_short
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|tmps
condition|)
block|{
if|if
condition|(
name|cmdflags
operator|&
name|CF_EQSURE
condition|)
block|{
operator|++
name|cmd
operator|->
name|c_short
operator|->
name|str_u
operator|.
name|str_useful
expr_stmt|;
if|if
condition|(
name|sawampersand
condition|)
block|{
name|curspat
operator|=
name|Nullspat
expr_stmt|;
if|if
condition|(
name|leftstab
condition|)
name|str_nset
argument_list|(
name|stab_val
argument_list|(
name|leftstab
argument_list|)
argument_list|,
name|retstr
operator|->
name|str_ptr
argument_list|,
name|tmps
operator|-
name|retstr
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|amperstab
condition|)
name|str_nset
argument_list|(
name|stab_val
argument_list|(
name|amperstab
argument_list|)
argument_list|,
name|tmps
argument_list|,
name|cmd
operator|->
name|c_short
operator|->
name|str_cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|rightstab
condition|)
name|str_nset
argument_list|(
name|stab_val
argument_list|(
name|rightstab
argument_list|)
argument_list|,
name|tmps
operator|+
name|cmd
operator|->
name|c_short
operator|->
name|str_cur
argument_list|,
name|retstr
operator|->
name|str_cur
operator|-
operator|(
name|tmps
operator|-
name|retstr
operator|->
name|str_ptr
operator|)
operator|-
name|cmd
operator|->
name|c_short
operator|->
name|str_cur
argument_list|)
expr_stmt|;
block|}
name|lastspat
operator|=
name|cmd
operator|->
name|c_spat
expr_stmt|;
name|match
operator|=
operator|!
operator|(
name|cmdflags
operator|&
name|CF_FIRSTNEG
operator|)
expr_stmt|;
name|retstr
operator|=
name|match
condition|?
operator|&
name|str_yes
else|:
operator|&
name|str_no
expr_stmt|;
goto|goto
name|flipmaybe
goto|;
block|}
else|else
name|hint
operator|=
name|tmps
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cmdflags
operator|&
name|CF_NESURE
condition|)
block|{
operator|++
name|cmd
operator|->
name|c_short
operator|->
name|str_u
operator|.
name|str_useful
expr_stmt|;
name|match
operator|=
name|cmdflags
operator|&
name|CF_FIRSTNEG
expr_stmt|;
name|retstr
operator|=
name|match
condition|?
operator|&
name|str_yes
else|:
operator|&
name|str_no
expr_stmt|;
goto|goto
name|flipmaybe
goto|;
block|}
block|}
if|if
condition|(
operator|--
name|cmd
operator|->
name|c_short
operator|->
name|str_u
operator|.
name|str_useful
operator|<
literal|0
condition|)
block|{
name|cmdflags
operator|&=
operator|~
name|CF_OPTIMIZE
expr_stmt|;
name|cmdflags
operator||=
name|CFT_EVAL
expr_stmt|;
comment|/* never try this optimization again */
name|cmd
operator|->
name|c_flags
operator|=
operator|(
name|cmdflags
operator|&
operator|~
name|CF_ONCE
operator|)
expr_stmt|;
block|}
break|break;
comment|/* must evaluate */
case|case
name|CFT_NUMOP
case|:
comment|/* numeric op optimization */
name|retstr
operator|=
name|STAB_STR
argument_list|(
name|cmd
operator|->
name|c_stab
argument_list|)
expr_stmt|;
name|newsp
operator|=
operator|-
literal|2
expr_stmt|;
switch|switch
condition|(
name|cmd
operator|->
name|c_slen
condition|)
block|{
case|case
name|O_EQ
case|:
if|if
condition|(
name|dowarn
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|retstr
operator|->
name|str_nok
operator|&&
operator|!
name|looks_like_number
argument_list|(
name|retstr
argument_list|)
operator|)
condition|)
name|warn
argument_list|(
literal|"Possible use of == on string value"
argument_list|)
expr_stmt|;
block|}
name|match
operator|=
operator|(
name|str_gnum
argument_list|(
name|retstr
argument_list|)
operator|==
name|cmd
operator|->
name|c_short
operator|->
name|str_u
operator|.
name|str_nval
operator|)
expr_stmt|;
break|break;
case|case
name|O_NE
case|:
name|match
operator|=
operator|(
name|str_gnum
argument_list|(
name|retstr
argument_list|)
operator|!=
name|cmd
operator|->
name|c_short
operator|->
name|str_u
operator|.
name|str_nval
operator|)
expr_stmt|;
break|break;
case|case
name|O_LT
case|:
name|match
operator|=
operator|(
name|str_gnum
argument_list|(
name|retstr
argument_list|)
operator|<
name|cmd
operator|->
name|c_short
operator|->
name|str_u
operator|.
name|str_nval
operator|)
expr_stmt|;
break|break;
case|case
name|O_LE
case|:
name|match
operator|=
operator|(
name|str_gnum
argument_list|(
name|retstr
argument_list|)
operator|<=
name|cmd
operator|->
name|c_short
operator|->
name|str_u
operator|.
name|str_nval
operator|)
expr_stmt|;
break|break;
case|case
name|O_GT
case|:
name|match
operator|=
operator|(
name|str_gnum
argument_list|(
name|retstr
argument_list|)
operator|>
name|cmd
operator|->
name|c_short
operator|->
name|str_u
operator|.
name|str_nval
operator|)
expr_stmt|;
break|break;
case|case
name|O_GE
case|:
name|match
operator|=
operator|(
name|str_gnum
argument_list|(
name|retstr
argument_list|)
operator|>=
name|cmd
operator|->
name|c_short
operator|->
name|str_u
operator|.
name|str_nval
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|match
condition|)
block|{
if|if
condition|(
name|cmdflags
operator|&
name|CF_EQSURE
condition|)
block|{
name|retstr
operator|=
operator|&
name|str_yes
expr_stmt|;
goto|goto
name|flipmaybe
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|cmdflags
operator|&
name|CF_NESURE
condition|)
block|{
name|retstr
operator|=
operator|&
name|str_no
expr_stmt|;
goto|goto
name|flipmaybe
goto|;
block|}
break|break;
comment|/* must evaluate */
case|case
name|CFT_INDGETS
case|:
comment|/* while (<$foo>) */
name|last_in_stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|STAB_STR
argument_list|(
name|cmd
operator|->
name|c_stab
argument_list|)
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
condition|)
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|=
name|stio_new
argument_list|()
expr_stmt|;
goto|goto
name|dogets
goto|;
case|case
name|CFT_GETS
case|:
comment|/* really a while (<file>) */
name|last_in_stab
operator|=
name|cmd
operator|->
name|c_stab
expr_stmt|;
name|dogets
label|:
name|fp
operator|=
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|->
name|ifp
expr_stmt|;
name|retstr
operator|=
name|stab_val
argument_list|(
name|defstab
argument_list|)
expr_stmt|;
name|newsp
operator|=
operator|-
literal|2
expr_stmt|;
name|keepgoing
label|:
if|if
condition|(
name|fp
operator|&&
name|str_gets
argument_list|(
name|retstr
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|retstr
operator|->
name|str_ptr
operator|==
literal|'0'
operator|&&
name|retstr
operator|->
name|str_cur
operator|==
literal|1
condition|)
name|match
operator|=
name|FALSE
expr_stmt|;
else|else
name|match
operator|=
name|TRUE
expr_stmt|;
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|->
name|lines
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|->
name|flags
operator|&
name|IOF_ARGV
condition|)
block|{
if|if
condition|(
operator|!
name|fp
condition|)
goto|goto
name|doeval
goto|;
comment|/* first time through */
name|fp
operator|=
name|nextargv
argument_list|(
name|last_in_stab
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
condition|)
goto|goto
name|keepgoing
goto|;
operator|(
name|void
operator|)
name|do_close
argument_list|(
name|last_in_stab
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|->
name|flags
operator||=
name|IOF_START
expr_stmt|;
name|retstr
operator|=
operator|&
name|str_undef
expr_stmt|;
name|match
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|retstr
operator|=
operator|&
name|str_undef
expr_stmt|;
name|match
operator|=
name|FALSE
expr_stmt|;
block|}
goto|goto
name|flipmaybe
goto|;
case|case
name|CFT_EVAL
case|:
break|break;
case|case
name|CFT_UNFLIP
case|:
while|while
condition|(
name|tmps_max
operator|>
name|tmps_base
condition|)
block|{
comment|/* clean up after last eval */
name|str_free
argument_list|(
name|tmps_list
index|[
name|tmps_max
index|]
argument_list|)
expr_stmt|;
name|tmps_list
index|[
name|tmps_max
operator|--
index|]
operator|=
name|Nullstr
expr_stmt|;
block|}
name|newsp
operator|=
name|eval
argument_list|(
name|cmd
operator|->
name|c_expr
argument_list|,
name|gimme
operator|&&
operator|(
name|cmdflags
operator|&
name|CF_TERM
operator|)
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
comment|/* possibly reallocated */
name|retstr
operator|=
name|st
index|[
name|newsp
index|]
expr_stmt|;
name|match
operator|=
name|str_true
argument_list|(
name|retstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|c_expr
operator|->
name|arg_type
operator|==
name|O_FLIP
condition|)
comment|/* undid itself? */
name|cmdflags
operator|=
name|copyopt
argument_list|(
name|cmd
argument_list|,
name|cmd
operator|->
name|c_expr
index|[
literal|3
index|]
operator|.
name|arg_ptr
operator|.
name|arg_cmd
argument_list|)
expr_stmt|;
goto|goto
name|maybe
goto|;
case|case
name|CFT_CHOP
case|:
name|retstr
operator|=
name|stab_val
argument_list|(
name|cmd
operator|->
name|c_stab
argument_list|)
expr_stmt|;
name|newsp
operator|=
operator|-
literal|2
expr_stmt|;
name|match
operator|=
operator|(
name|retstr
operator|->
name|str_cur
operator|!=
literal|0
operator|)
expr_stmt|;
name|tmps
operator|=
name|str_get
argument_list|(
name|retstr
argument_list|)
expr_stmt|;
name|tmps
operator|+=
name|retstr
operator|->
name|str_cur
operator|-
name|match
expr_stmt|;
name|str_nset
argument_list|(
operator|&
name|strchop
argument_list|,
name|tmps
argument_list|,
name|match
argument_list|)
expr_stmt|;
operator|*
name|tmps
operator|=
literal|'\0'
expr_stmt|;
name|retstr
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
name|retstr
operator|->
name|str_cur
operator|=
name|tmps
operator|-
name|retstr
operator|->
name|str_ptr
expr_stmt|;
name|STABSET
argument_list|(
name|retstr
argument_list|)
expr_stmt|;
name|retstr
operator|=
operator|&
name|strchop
expr_stmt|;
goto|goto
name|flipmaybe
goto|;
case|case
name|CFT_ARRAY
case|:
name|match
operator|=
name|cmd
operator|->
name|c_short
operator|->
name|str_u
operator|.
name|str_useful
expr_stmt|;
comment|/* just to get register */
if|if
condition|(
name|match
operator|<
literal|0
condition|)
block|{
comment|/* first time through here? */
name|ar
operator|=
name|stab_array
argument_list|(
name|cmd
operator|->
name|c_expr
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
expr_stmt|;
name|aryoptsave
operator|=
name|savestack
operator|->
name|ary_fill
expr_stmt|;
name|savesptr
argument_list|(
operator|&
name|stab_val
argument_list|(
name|cmd
operator|->
name|c_stab
argument_list|)
argument_list|)
expr_stmt|;
name|savelong
argument_list|(
operator|&
name|cmd
operator|->
name|c_short
operator|->
name|str_u
operator|.
name|str_useful
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ar
operator|=
name|stab_xarray
argument_list|(
name|cmd
operator|->
name|c_expr
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|c_type
operator|!=
name|C_WHILE
operator|&&
name|savestack
operator|->
name|ary_fill
operator|>
name|firstsave
condition|)
name|restorelist
argument_list|(
name|firstsave
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|match
operator|>=
name|ar
operator|->
name|ary_fill
condition|)
block|{
comment|/* we're in LAST, probably */
if|if
condition|(
name|match
operator|<
literal|0
operator|&&
comment|/* er, probably not... */
name|savestack
operator|->
name|ary_fill
operator|>
name|aryoptsave
condition|)
name|restorelist
argument_list|(
name|aryoptsave
argument_list|)
expr_stmt|;
name|retstr
operator|=
operator|&
name|str_undef
expr_stmt|;
name|cmd
operator|->
name|c_short
operator|->
name|str_u
operator|.
name|str_useful
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* actually redundant */
name|match
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|match
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|retstr
operator|=
name|ar
operator|->
name|ary_array
index|[
name|match
index|]
operator|)
condition|)
name|retstr
operator|=
name|afetch
argument_list|(
name|ar
argument_list|,
name|match
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|stab_val
argument_list|(
name|cmd
operator|->
name|c_stab
argument_list|)
operator|=
name|retstr
expr_stmt|;
name|cmd
operator|->
name|c_short
operator|->
name|str_u
operator|.
name|str_useful
operator|=
name|match
expr_stmt|;
name|match
operator|=
name|TRUE
expr_stmt|;
block|}
name|newsp
operator|=
operator|-
literal|2
expr_stmt|;
goto|goto
name|maybe
goto|;
case|case
name|CFT_D1
case|:
break|break;
case|case
name|CFT_D0
case|:
if|if
condition|(
name|DBsingle
operator|->
name|str_u
operator|.
name|str_nval
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|DBsignal
operator|->
name|str_u
operator|.
name|str_nval
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|DBtrace
operator|->
name|str_u
operator|.
name|str_nval
operator|!=
literal|0
condition|)
break|break;
goto|goto
name|next_cmd
goto|;
block|}
comment|/* we have tried to make this normal case as abnormal as possible */
name|doeval
label|:
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
block|{
name|lastretstr
operator|=
name|Nullstr
expr_stmt|;
name|lastspbase
operator|=
name|sp
expr_stmt|;
name|lastsize
operator|=
name|newsp
operator|-
name|sp
expr_stmt|;
if|if
condition|(
name|lastsize
operator|<
literal|0
condition|)
name|lastsize
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|lastretstr
operator|=
name|retstr
expr_stmt|;
while|while
condition|(
name|tmps_max
operator|>
name|tmps_base
condition|)
block|{
comment|/* clean up after last eval */
name|str_free
argument_list|(
name|tmps_list
index|[
name|tmps_max
index|]
argument_list|)
expr_stmt|;
name|tmps_list
index|[
name|tmps_max
operator|--
index|]
operator|=
name|Nullstr
expr_stmt|;
block|}
name|newsp
operator|=
name|eval
argument_list|(
name|cmd
operator|->
name|c_expr
argument_list|,
name|gimme
operator|&&
operator|(
name|cmdflags
operator|&
name|CF_TERM
operator|)
operator|&&
name|cmd
operator|->
name|c_type
operator|==
name|C_EXPR
operator|&&
operator|!
name|cmd
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
comment|/* possibly reallocated */
name|retstr
operator|=
name|st
index|[
name|newsp
index|]
expr_stmt|;
if|if
condition|(
name|newsp
operator|>
name|sp
operator|&&
name|retstr
condition|)
name|match
operator|=
name|str_true
argument_list|(
name|retstr
argument_list|)
expr_stmt|;
else|else
name|match
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|maybe
goto|;
comment|/* if flipflop was true, flop it */
name|flipmaybe
label|:
if|if
condition|(
name|match
operator|&&
name|cmdflags
operator|&
name|CF_FLIP
condition|)
block|{
while|while
condition|(
name|tmps_max
operator|>
name|tmps_base
condition|)
block|{
comment|/* clean up after last eval */
name|str_free
argument_list|(
name|tmps_list
index|[
name|tmps_max
index|]
argument_list|)
expr_stmt|;
name|tmps_list
index|[
name|tmps_max
operator|--
index|]
operator|=
name|Nullstr
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|->
name|c_expr
operator|->
name|arg_type
operator|==
name|O_FLOP
condition|)
block|{
comment|/* currently toggled? */
name|newsp
operator|=
name|eval
argument_list|(
name|cmd
operator|->
name|c_expr
argument_list|,
name|G_SCALAR
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/*let eval undo it*/
name|cmdflags
operator|=
name|copyopt
argument_list|(
name|cmd
argument_list|,
name|cmd
operator|->
name|c_expr
index|[
literal|3
index|]
operator|.
name|arg_ptr
operator|.
name|arg_cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newsp
operator|=
name|eval
argument_list|(
name|cmd
operator|->
name|c_expr
argument_list|,
name|G_SCALAR
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* let eval do it */
if|if
condition|(
name|cmd
operator|->
name|c_expr
operator|->
name|arg_type
operator|==
name|O_FLOP
condition|)
comment|/* still toggled? */
name|cmdflags
operator|=
name|copyopt
argument_list|(
name|cmd
argument_list|,
name|cmd
operator|->
name|c_expr
index|[
literal|4
index|]
operator|.
name|arg_ptr
operator|.
name|arg_cmd
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cmdflags
operator|&
name|CF_FLIP
condition|)
block|{
if|if
condition|(
name|cmd
operator|->
name|c_expr
operator|->
name|arg_type
operator|==
name|O_FLOP
condition|)
block|{
comment|/* currently toggled? */
name|match
operator|=
name|TRUE
expr_stmt|;
comment|/* force on */
block|}
block|}
comment|/* at this point, match says whether our expression was true */
name|maybe
label|:
if|if
condition|(
name|cmdflags
operator|&
name|CF_INVERT
condition|)
name|match
operator|=
operator|!
name|match
expr_stmt|;
if|if
condition|(
operator|!
name|match
condition|)
goto|goto
name|next_cmd
goto|;
block|}
ifdef|#
directive|ifdef
name|TAINT
name|tainted
operator|=
literal|0
expr_stmt|;
comment|/* modifier doesn't affect regular expression */
endif|#
directive|endif
comment|/* now to do the actual command, if any */
switch|switch
condition|(
name|cmd
operator|->
name|c_type
condition|)
block|{
case|case
name|C_NULL
case|:
name|fatal
argument_list|(
literal|"panic: cmd_exec"
argument_list|)
expr_stmt|;
case|case
name|C_EXPR
case|:
comment|/* evaluated for side effects */
if|if
condition|(
name|cmd
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
condition|)
block|{
comment|/* more to do? */
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
block|{
name|lastretstr
operator|=
name|Nullstr
expr_stmt|;
name|lastspbase
operator|=
name|sp
expr_stmt|;
name|lastsize
operator|=
name|newsp
operator|-
name|sp
expr_stmt|;
if|if
condition|(
name|lastsize
operator|<
literal|0
condition|)
name|lastsize
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|lastretstr
operator|=
name|retstr
expr_stmt|;
while|while
condition|(
name|tmps_max
operator|>
name|tmps_base
condition|)
block|{
comment|/* clean up after last eval */
name|str_free
argument_list|(
name|tmps_list
index|[
name|tmps_max
index|]
argument_list|)
expr_stmt|;
name|tmps_list
index|[
name|tmps_max
operator|--
index|]
operator|=
name|Nullstr
expr_stmt|;
block|}
name|newsp
operator|=
name|eval
argument_list|(
name|cmd
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
argument_list|,
name|gimme
operator|&&
operator|(
name|cmdflags
operator|&
name|CF_TERM
operator|)
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
comment|/* possibly reallocated */
name|retstr
operator|=
name|st
index|[
name|newsp
index|]
expr_stmt|;
block|}
break|break;
case|case
name|C_NSWITCH
case|:
block|{
name|double
name|value
init|=
name|str_gnum
argument_list|(
name|STAB_STR
argument_list|(
name|cmd
operator|->
name|c_stab
argument_list|)
argument_list|)
decl_stmt|;
name|match
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0.0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|double
operator|)
name|match
operator|)
operator|>
name|value
condition|)
operator|--
name|match
expr_stmt|;
comment|/* was fractional--truncate other way */
block|}
block|}
goto|goto
name|doswitch
goto|;
case|case
name|C_CSWITCH
case|:
if|if
condition|(
name|multiline
condition|)
block|{
name|cmd
operator|=
name|cmd
operator|->
name|c_next
expr_stmt|;
comment|/* can't assume anything */
goto|goto
name|tail_recursion_entry
goto|;
block|}
name|match
operator|=
operator|*
operator|(
name|str_get
argument_list|(
name|STAB_STR
argument_list|(
name|cmd
operator|->
name|c_stab
argument_list|)
argument_list|)
operator|)
operator|&
literal|255
expr_stmt|;
name|doswitch
label|:
name|match
operator|-=
name|cmd
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_offset
expr_stmt|;
if|if
condition|(
name|match
operator|<
literal|0
condition|)
name|match
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|match
operator|>
name|cmd
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_max
condition|)
name|match
operator|=
name|cmd
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_max
expr_stmt|;
name|cmd
operator|=
name|cmd
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_next
index|[
name|match
index|]
expr_stmt|;
goto|goto
name|tail_recursion_entry
goto|;
case|case
name|C_NEXT
case|:
name|cmd
operator|=
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
expr_stmt|;
goto|goto
name|tail_recursion_entry
goto|;
case|case
name|C_ELSIF
case|:
name|fatal
argument_list|(
literal|"panic: ELSIF"
argument_list|)
expr_stmt|;
case|case
name|C_IF
case|:
name|oldspat
operator|=
name|curspat
expr_stmt|;
name|oldsave
operator|=
name|savestack
operator|->
name|ary_fill
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|olddlevel
operator|=
name|dlevel
expr_stmt|;
endif|#
directive|endif
name|retstr
operator|=
operator|&
name|str_yes
expr_stmt|;
name|newsp
operator|=
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
block|{
name|debname
index|[
name|dlevel
index|]
operator|=
literal|'t'
expr_stmt|;
name|debdelim
index|[
name|dlevel
index|]
operator|=
literal|'_'
expr_stmt|;
if|if
condition|(
operator|++
name|dlevel
operator|>=
name|dlmax
condition|)
name|grow_dlevel
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|newsp
operator|=
name|cmd_exec
argument_list|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
argument_list|,
name|gimme
operator|&&
operator|(
name|cmdflags
operator|&
name|CF_TERM
operator|)
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
comment|/* possibly reallocated */
name|retstr
operator|=
name|st
index|[
name|newsp
index|]
expr_stmt|;
block|}
name|curspat
operator|=
name|oldspat
expr_stmt|;
if|if
condition|(
name|savestack
operator|->
name|ary_fill
operator|>
name|oldsave
condition|)
name|restorelist
argument_list|(
name|oldsave
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|dlevel
operator|=
name|olddlevel
expr_stmt|;
endif|#
directive|endif
name|cmd
operator|=
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
expr_stmt|;
goto|goto
name|tail_recursion_entry
goto|;
case|case
name|C_ELSE
case|:
name|oldspat
operator|=
name|curspat
expr_stmt|;
name|oldsave
operator|=
name|savestack
operator|->
name|ary_fill
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|olddlevel
operator|=
name|dlevel
expr_stmt|;
endif|#
directive|endif
name|retstr
operator|=
operator|&
name|str_undef
expr_stmt|;
name|newsp
operator|=
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
block|{
name|debname
index|[
name|dlevel
index|]
operator|=
literal|'e'
expr_stmt|;
name|debdelim
index|[
name|dlevel
index|]
operator|=
literal|'_'
expr_stmt|;
if|if
condition|(
operator|++
name|dlevel
operator|>=
name|dlmax
condition|)
name|grow_dlevel
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|newsp
operator|=
name|cmd_exec
argument_list|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
argument_list|,
name|gimme
operator|&&
operator|(
name|cmdflags
operator|&
name|CF_TERM
operator|)
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
comment|/* possibly reallocated */
name|retstr
operator|=
name|st
index|[
name|newsp
index|]
expr_stmt|;
block|}
name|curspat
operator|=
name|oldspat
expr_stmt|;
if|if
condition|(
name|savestack
operator|->
name|ary_fill
operator|>
name|oldsave
condition|)
name|restorelist
argument_list|(
name|oldsave
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|dlevel
operator|=
name|olddlevel
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|C_BLOCK
case|:
case|case
name|C_WHILE
case|:
if|if
condition|(
operator|!
operator|(
name|cmdflags
operator|&
name|CF_ONCE
operator|)
condition|)
block|{
comment|/* first time through here? */
name|cmdflags
operator||=
name|CF_ONCE
expr_stmt|;
if|if
condition|(
operator|++
name|loop_ptr
operator|>=
name|loop_max
condition|)
block|{
name|loop_max
operator|+=
literal|128
expr_stmt|;
name|Renew
argument_list|(
name|loop_stack
argument_list|,
name|loop_max
argument_list|,
expr|struct
name|loop
argument_list|)
expr_stmt|;
block|}
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_label
operator|=
name|cmd
operator|->
name|c_label
expr_stmt|;
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_sp
operator|=
name|sp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|4
condition|)
block|{
name|deb
argument_list|(
literal|"(Pushing label #%d %s)\n"
argument_list|,
name|loop_ptr
argument_list|,
name|cmd
operator|->
name|c_label
condition|?
name|cmd
operator|->
name|c_label
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|JMPCLOBBER
name|cmdparm
operator|=
name|cmd
expr_stmt|;
endif|#
directive|endif
name|match
operator|=
name|setjmp
argument_list|(
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_env
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
condition|)
block|{
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
comment|/* possibly reallocated */
ifdef|#
directive|ifdef
name|JMPCLOBBER
name|cmd
operator|=
name|cmdparm
expr_stmt|;
name|cmdflags
operator|=
name|cmd
operator|->
name|c_flags
operator||
name|CF_ONCE
expr_stmt|;
name|go_to
operator|=
name|goto_targ
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|savestack
operator|->
name|ary_fill
operator|>
name|oldsave
condition|)
name|restorelist
argument_list|(
name|oldsave
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|match
condition|)
block|{
default|default:
name|fatal
argument_list|(
literal|"longjmp returned bad value (%d)"
argument_list|,
name|match
argument_list|)
expr_stmt|;
case|case
name|O_LAST
case|:
if|if
condition|(
name|lastretstr
condition|)
block|{
name|retstr
operator|=
name|lastretstr
expr_stmt|;
name|newsp
operator|=
operator|-
literal|2
expr_stmt|;
block|}
else|else
block|{
name|newsp
operator|=
name|sp
operator|+
name|lastsize
expr_stmt|;
name|retstr
operator|=
name|st
index|[
name|newsp
index|]
expr_stmt|;
block|}
name|curspat
operator|=
name|oldspat
expr_stmt|;
goto|goto
name|next_cmd
goto|;
case|case
name|O_NEXT
case|:
ifdef|#
directive|ifdef
name|JMPCLOBBER
name|newsp
operator|=
operator|-
literal|2
expr_stmt|;
name|retstr
operator|=
operator|&
name|str_undef
expr_stmt|;
endif|#
directive|endif
goto|goto
name|next_iter
goto|;
case|case
name|O_REDO
case|:
ifdef|#
directive|ifdef
name|DEBUGGING
name|dlevel
operator|=
name|olddlevel
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|JMPCLOBBER
name|newsp
operator|=
operator|-
literal|2
expr_stmt|;
name|retstr
operator|=
operator|&
name|str_undef
expr_stmt|;
endif|#
directive|endif
goto|goto
name|doit
goto|;
block|}
block|}
name|oldspat
operator|=
name|curspat
expr_stmt|;
name|oldsave
operator|=
name|savestack
operator|->
name|ary_fill
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|olddlevel
operator|=
name|dlevel
expr_stmt|;
endif|#
directive|endif
name|doit
label|:
if|if
condition|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
block|{
name|debname
index|[
name|dlevel
index|]
operator|=
literal|'t'
expr_stmt|;
name|debdelim
index|[
name|dlevel
index|]
operator|=
literal|'_'
expr_stmt|;
if|if
condition|(
operator|++
name|dlevel
operator|>=
name|dlmax
condition|)
name|grow_dlevel
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|newsp
operator|=
name|cmd_exec
argument_list|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
argument_list|,
name|gimme
operator|&&
operator|(
name|cmdflags
operator|&
name|CF_TERM
operator|)
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
comment|/* possibly reallocated */
name|retstr
operator|=
name|st
index|[
name|newsp
index|]
expr_stmt|;
block|}
comment|/* actually, this spot is rarely reached anymore since the above 	 * cmd_exec() returns through longjmp().  Hooray for structure. 	 */
name|next_iter
label|:
ifdef|#
directive|ifdef
name|DEBUGGING
name|dlevel
operator|=
name|olddlevel
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
block|{
name|debname
index|[
name|dlevel
index|]
operator|=
literal|'a'
expr_stmt|;
name|debdelim
index|[
name|dlevel
index|]
operator|=
literal|'_'
expr_stmt|;
if|if
condition|(
operator|++
name|dlevel
operator|>=
name|dlmax
condition|)
name|grow_dlevel
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|newsp
operator|=
name|cmd_exec
argument_list|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
argument_list|,
name|gimme
operator|&&
operator|(
name|cmdflags
operator|&
name|CF_TERM
operator|)
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
comment|/* possibly reallocated */
name|retstr
operator|=
name|st
index|[
name|newsp
index|]
expr_stmt|;
block|}
name|finish_while
label|:
name|curspat
operator|=
name|oldspat
expr_stmt|;
if|if
condition|(
name|savestack
operator|->
name|ary_fill
operator|>
name|oldsave
condition|)
block|{
if|if
condition|(
name|cmdflags
operator|&
name|CF_TERM
condition|)
block|{
for|for
control|(
name|match
operator|=
name|sp
operator|+
literal|1
init|;
name|match
operator|<=
name|newsp
condition|;
name|match
operator|++
control|)
name|st
index|[
name|match
index|]
operator|=
name|str_mortal
argument_list|(
name|st
index|[
name|match
index|]
argument_list|)
expr_stmt|;
name|retstr
operator|=
name|st
index|[
name|newsp
index|]
expr_stmt|;
block|}
name|restorelist
argument_list|(
name|oldsave
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
name|dlevel
operator|=
name|olddlevel
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cmd
operator|->
name|c_type
operator|!=
name|C_BLOCK
condition|)
goto|goto
name|until_loop
goto|;
comment|/* go back and evaluate conditional again */
block|}
if|if
condition|(
name|cmdflags
operator|&
name|CF_LOOP
condition|)
block|{
name|cmdflags
operator||=
name|CF_COND
expr_stmt|;
comment|/* now test the condition */
ifdef|#
directive|ifdef
name|DEBUGGING
name|dlevel
operator|=
name|entdlevel
expr_stmt|;
endif|#
directive|endif
goto|goto
name|until_loop
goto|;
block|}
name|next_cmd
label|:
if|if
condition|(
name|cmdflags
operator|&
name|CF_ONCE
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|4
condition|)
block|{
name|tmps
operator|=
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_label
expr_stmt|;
name|deb
argument_list|(
literal|"(Popping label #%d %s)\n"
argument_list|,
name|loop_ptr
argument_list|,
name|tmps
condition|?
name|tmps
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|loop_ptr
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|cmdflags
operator|&
name|CF_OPTIMIZE
operator|)
operator|==
name|CFT_ARRAY
operator|&&
name|savestack
operator|->
name|ary_fill
operator|>
name|aryoptsave
condition|)
name|restorelist
argument_list|(
name|aryoptsave
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|=
name|cmd
operator|->
name|c_next
expr_stmt|;
goto|goto
name|tail_recursion_entry
goto|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|I_VARARGS
end_ifndef

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
name|void
name|deb
parameter_list|(
name|pat
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|,
name|a3
parameter_list|,
name|a4
parameter_list|,
name|a5
parameter_list|,
name|a6
parameter_list|,
name|a7
parameter_list|,
name|a8
parameter_list|)
name|char
modifier|*
name|pat
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-4ld"
argument_list|,
operator|(
name|long
operator|)
name|curcmd
operator|->
name|c_line
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dlevel
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c%c "
argument_list|,
name|debname
index|[
name|i
index|]
argument_list|,
name|debdelim
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|pat
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
name|void
name|deb
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|pat
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%-4ld"
argument_list|,
operator|(
name|long
operator|)
name|curcmd
operator|->
name|c_line
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dlevel
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c%c "
argument_list|,
name|debname
index|[
name|i
index|]
argument_list|,
name|debdelim
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pat
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|pat
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|copyopt
parameter_list|(
name|cmd
parameter_list|,
name|which
parameter_list|)
specifier|register
name|CMD
modifier|*
name|cmd
decl_stmt|;
specifier|register
name|CMD
modifier|*
name|which
decl_stmt|;
block|{
name|cmd
operator|->
name|c_flags
operator|&=
name|CF_ONCE
operator||
name|CF_COND
operator||
name|CF_LOOP
expr_stmt|;
name|cmd
operator|->
name|c_flags
operator||=
name|which
operator|->
name|c_flags
expr_stmt|;
name|cmd
operator|->
name|c_short
operator|=
name|which
operator|->
name|c_short
expr_stmt|;
name|cmd
operator|->
name|c_slen
operator|=
name|which
operator|->
name|c_slen
expr_stmt|;
name|cmd
operator|->
name|c_stab
operator|=
name|which
operator|->
name|c_stab
expr_stmt|;
return|return
name|cmd
operator|->
name|c_flags
return|;
block|}
end_function

begin_function
name|ARRAY
modifier|*
name|saveary
parameter_list|(
name|stab
parameter_list|)
name|STAB
modifier|*
name|stab
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|Str_new
argument_list|(
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_state
operator|=
name|SS_SARY
expr_stmt|;
name|str
operator|->
name|str_u
operator|.
name|str_stab
operator|=
name|stab
expr_stmt|;
if|if
condition|(
name|str
operator|->
name|str_ptr
condition|)
block|{
name|Safefree
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_ptr
operator|=
name|Nullch
expr_stmt|;
name|str
operator|->
name|str_len
operator|=
literal|0
expr_stmt|;
block|}
name|str
operator|->
name|str_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|stab_array
argument_list|(
name|stab
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|apush
argument_list|(
name|savestack
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* save array ptr */
name|stab_xarray
argument_list|(
name|stab
argument_list|)
operator|=
name|Null
argument_list|(
name|ARRAY
operator|*
argument_list|)
expr_stmt|;
return|return
name|stab_xarray
argument_list|(
name|aadd
argument_list|(
name|stab
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|HASH
modifier|*
name|savehash
parameter_list|(
name|stab
parameter_list|)
name|STAB
modifier|*
name|stab
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|Str_new
argument_list|(
literal|11
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_state
operator|=
name|SS_SHASH
expr_stmt|;
name|str
operator|->
name|str_u
operator|.
name|str_stab
operator|=
name|stab
expr_stmt|;
if|if
condition|(
name|str
operator|->
name|str_ptr
condition|)
block|{
name|Safefree
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_ptr
operator|=
name|Nullch
expr_stmt|;
name|str
operator|->
name|str_len
operator|=
literal|0
expr_stmt|;
block|}
name|str
operator|->
name|str_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|stab_hash
argument_list|(
name|stab
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|apush
argument_list|(
name|savestack
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* save hash ptr */
name|stab_xhash
argument_list|(
name|stab
argument_list|)
operator|=
name|Null
argument_list|(
name|HASH
operator|*
argument_list|)
expr_stmt|;
return|return
name|stab_xhash
argument_list|(
name|hadd
argument_list|(
name|stab
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|saveitem
parameter_list|(
name|item
parameter_list|)
specifier|register
name|STR
modifier|*
name|item
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
operator|(
name|void
operator|)
name|apush
argument_list|(
name|savestack
argument_list|,
name|item
argument_list|)
expr_stmt|;
comment|/* remember the pointer */
name|str
operator|=
name|Str_new
argument_list|(
literal|12
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str_sset
argument_list|(
name|str
argument_list|,
name|item
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|apush
argument_list|(
name|savestack
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* remember the value */
block|}
end_function

begin_function
name|void
name|saveint
parameter_list|(
name|intp
parameter_list|)
name|int
modifier|*
name|intp
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|Str_new
argument_list|(
literal|13
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_state
operator|=
name|SS_SINT
expr_stmt|;
name|str
operator|->
name|str_u
operator|.
name|str_useful
operator|=
operator|(
name|long
operator|)
operator|*
name|intp
expr_stmt|;
comment|/* remember value */
if|if
condition|(
name|str
operator|->
name|str_ptr
condition|)
block|{
name|Safefree
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_len
operator|=
literal|0
expr_stmt|;
block|}
name|str
operator|->
name|str_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|intp
expr_stmt|;
comment|/* remember pointer */
operator|(
name|void
operator|)
name|apush
argument_list|(
name|savestack
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|savelong
parameter_list|(
name|longp
parameter_list|)
name|long
modifier|*
name|longp
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|Str_new
argument_list|(
literal|14
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_state
operator|=
name|SS_SLONG
expr_stmt|;
name|str
operator|->
name|str_u
operator|.
name|str_useful
operator|=
operator|*
name|longp
expr_stmt|;
comment|/* remember value */
if|if
condition|(
name|str
operator|->
name|str_ptr
condition|)
block|{
name|Safefree
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_len
operator|=
literal|0
expr_stmt|;
block|}
name|str
operator|->
name|str_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|longp
expr_stmt|;
comment|/* remember pointer */
operator|(
name|void
operator|)
name|apush
argument_list|(
name|savestack
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|savesptr
parameter_list|(
name|sptr
parameter_list|)
name|STR
modifier|*
modifier|*
name|sptr
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|Str_new
argument_list|(
literal|15
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_state
operator|=
name|SS_SSTRP
expr_stmt|;
name|str
operator|->
name|str_magic
operator|=
operator|*
name|sptr
expr_stmt|;
comment|/* remember value */
if|if
condition|(
name|str
operator|->
name|str_ptr
condition|)
block|{
name|Safefree
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_len
operator|=
literal|0
expr_stmt|;
block|}
name|str
operator|->
name|str_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|sptr
expr_stmt|;
comment|/* remember pointer */
operator|(
name|void
operator|)
name|apush
argument_list|(
name|savestack
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|savenostab
parameter_list|(
name|stab
parameter_list|)
name|STAB
modifier|*
name|stab
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|Str_new
argument_list|(
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_state
operator|=
name|SS_SNSTAB
expr_stmt|;
name|str
operator|->
name|str_magic
operator|=
operator|(
name|STR
operator|*
operator|)
name|stab
expr_stmt|;
comment|/* remember which stab to free */
operator|(
name|void
operator|)
name|apush
argument_list|(
name|savestack
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|savehptr
parameter_list|(
name|hptr
parameter_list|)
name|HASH
modifier|*
modifier|*
name|hptr
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|Str_new
argument_list|(
literal|17
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_state
operator|=
name|SS_SHPTR
expr_stmt|;
name|str
operator|->
name|str_u
operator|.
name|str_hash
operator|=
operator|*
name|hptr
expr_stmt|;
comment|/* remember value */
if|if
condition|(
name|str
operator|->
name|str_ptr
condition|)
block|{
name|Safefree
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_len
operator|=
literal|0
expr_stmt|;
block|}
name|str
operator|->
name|str_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|hptr
expr_stmt|;
comment|/* remember pointer */
operator|(
name|void
operator|)
name|apush
argument_list|(
name|savestack
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|saveaptr
parameter_list|(
name|aptr
parameter_list|)
name|ARRAY
modifier|*
modifier|*
name|aptr
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|Str_new
argument_list|(
literal|17
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_state
operator|=
name|SS_SAPTR
expr_stmt|;
name|str
operator|->
name|str_u
operator|.
name|str_array
operator|=
operator|*
name|aptr
expr_stmt|;
comment|/* remember value */
if|if
condition|(
name|str
operator|->
name|str_ptr
condition|)
block|{
name|Safefree
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_len
operator|=
literal|0
expr_stmt|;
block|}
name|str
operator|->
name|str_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|aptr
expr_stmt|;
comment|/* remember pointer */
operator|(
name|void
operator|)
name|apush
argument_list|(
name|savestack
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|savelist
parameter_list|(
name|sarg
parameter_list|,
name|maxsarg
parameter_list|)
specifier|register
name|STR
modifier|*
modifier|*
name|sarg
decl_stmt|;
name|int
name|maxsarg
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|maxsarg
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|apush
argument_list|(
name|savestack
argument_list|,
name|sarg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* remember the pointer */
name|str
operator|=
name|Str_new
argument_list|(
literal|18
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str_sset
argument_list|(
name|str
argument_list|,
name|sarg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|apush
argument_list|(
name|savestack
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* remember the value */
name|sarg
index|[
name|i
index|]
operator|->
name|str_u
operator|.
name|str_useful
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|restorelist
parameter_list|(
name|base
parameter_list|)
name|int
name|base
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
specifier|register
name|STR
modifier|*
name|value
decl_stmt|;
specifier|register
name|STAB
modifier|*
name|stab
decl_stmt|;
if|if
condition|(
name|base
operator|<
operator|-
literal|1
condition|)
name|fatal
argument_list|(
literal|"panic: corrupt saved stack index"
argument_list|)
expr_stmt|;
while|while
condition|(
name|savestack
operator|->
name|ary_fill
operator|>
name|base
condition|)
block|{
name|value
operator|=
name|apop
argument_list|(
name|savestack
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|value
operator|->
name|str_state
condition|)
block|{
case|case
name|SS_NORM
case|:
comment|/* normal string */
case|case
name|SS_INCR
case|:
name|str
operator|=
name|apop
argument_list|(
name|savestack
argument_list|)
expr_stmt|;
name|str_replace
argument_list|(
name|str
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|SS_SARY
case|:
comment|/* array reference */
name|stab
operator|=
name|value
operator|->
name|str_u
operator|.
name|str_stab
expr_stmt|;
name|afree
argument_list|(
name|stab_xarray
argument_list|(
name|stab
argument_list|)
argument_list|)
expr_stmt|;
name|stab_xarray
argument_list|(
name|stab
argument_list|)
operator|=
operator|(
name|ARRAY
operator|*
operator|)
name|value
operator|->
name|str_ptr
expr_stmt|;
name|value
operator|->
name|str_ptr
operator|=
name|Nullch
expr_stmt|;
name|str_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|SS_SHASH
case|:
comment|/* hash reference */
name|stab
operator|=
name|value
operator|->
name|str_u
operator|.
name|str_stab
expr_stmt|;
operator|(
name|void
operator|)
name|hfree
argument_list|(
name|stab_xhash
argument_list|(
name|stab
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|stab_xhash
argument_list|(
name|stab
argument_list|)
operator|=
operator|(
name|HASH
operator|*
operator|)
name|value
operator|->
name|str_ptr
expr_stmt|;
name|value
operator|->
name|str_ptr
operator|=
name|Nullch
expr_stmt|;
name|str_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|SS_SINT
case|:
comment|/* int reference */
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|value
operator|->
name|str_ptr
operator|)
operator|=
operator|(
name|int
operator|)
name|value
operator|->
name|str_u
operator|.
name|str_useful
expr_stmt|;
name|value
operator|->
name|str_ptr
operator|=
name|Nullch
expr_stmt|;
name|str_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|SS_SLONG
case|:
comment|/* long reference */
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
name|value
operator|->
name|str_ptr
operator|)
operator|=
name|value
operator|->
name|str_u
operator|.
name|str_useful
expr_stmt|;
name|value
operator|->
name|str_ptr
operator|=
name|Nullch
expr_stmt|;
name|str_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|SS_SSTRP
case|:
comment|/* STR* reference */
operator|*
operator|(
operator|(
name|STR
operator|*
operator|*
operator|)
name|value
operator|->
name|str_ptr
operator|)
operator|=
name|value
operator|->
name|str_magic
expr_stmt|;
name|value
operator|->
name|str_magic
operator|=
name|Nullstr
expr_stmt|;
name|value
operator|->
name|str_ptr
operator|=
name|Nullch
expr_stmt|;
name|str_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|SS_SHPTR
case|:
comment|/* HASH* reference */
operator|*
operator|(
operator|(
name|HASH
operator|*
operator|*
operator|)
name|value
operator|->
name|str_ptr
operator|)
operator|=
name|value
operator|->
name|str_u
operator|.
name|str_hash
expr_stmt|;
name|value
operator|->
name|str_ptr
operator|=
name|Nullch
expr_stmt|;
name|str_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|SS_SAPTR
case|:
comment|/* ARRAY* reference */
operator|*
operator|(
operator|(
name|ARRAY
operator|*
operator|*
operator|)
name|value
operator|->
name|str_ptr
operator|)
operator|=
name|value
operator|->
name|str_u
operator|.
name|str_array
expr_stmt|;
name|value
operator|->
name|str_ptr
operator|=
name|Nullch
expr_stmt|;
name|str_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|SS_SNSTAB
case|:
name|stab
operator|=
operator|(
name|STAB
operator|*
operator|)
name|value
operator|->
name|str_magic
expr_stmt|;
name|value
operator|->
name|str_magic
operator|=
name|Nullstr
expr_stmt|;
operator|(
name|void
operator|)
name|stab_clear
argument_list|(
name|stab
argument_list|)
expr_stmt|;
name|str_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|SS_SCSV
case|:
comment|/* callsave structure */
block|{
name|CSV
modifier|*
name|csv
init|=
operator|(
name|CSV
operator|*
operator|)
name|value
operator|->
name|str_ptr
decl_stmt|;
name|curcmd
operator|=
name|csv
operator|->
name|curcmd
expr_stmt|;
name|curcsv
operator|=
name|csv
operator|->
name|curcsv
expr_stmt|;
name|csv
operator|->
name|sub
operator|->
name|depth
operator|=
name|csv
operator|->
name|depth
expr_stmt|;
if|if
condition|(
name|csv
operator|->
name|hasargs
condition|)
block|{
comment|/* put back old @_ */
name|afree
argument_list|(
name|csv
operator|->
name|argarray
argument_list|)
expr_stmt|;
name|stab_xarray
argument_list|(
name|defstab
argument_list|)
operator|=
name|csv
operator|->
name|savearray
expr_stmt|;
block|}
name|str_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|fatal
argument_list|(
literal|"panic: restorelist inconsistency"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING
end_ifdef

begin_function
name|void
name|grow_dlevel
parameter_list|()
block|{
name|dlmax
operator|+=
literal|128
expr_stmt|;
name|Renew
argument_list|(
name|debname
argument_list|,
name|dlmax
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|Renew
argument_list|(
name|debdelim
argument_list|,
name|dlmax
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

