begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $RCSfile: eval.c,v $$Revision: 1.2 $$Date: 1995/05/30 05:03:03 $  *  *    Copyright (c) 1991, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  * $Log: eval.c,v $  * Revision 1.2  1995/05/30 05:03:03  rgrimes  * Remove trailing whitespace.  *  * Revision 1.1.1.1  1994/09/10  06:27:32  gclarkii  * Initial import of Perl 4.046 bmaked  *  * Revision 1.1.1.1  1993/08/23  21:29:36  nate  * PERL!  *  * Revision 4.0.1.4  92/06/08  13:20:20  lwall  * patch20: added explicit time_t support  * patch20: fixed confusion between a *var's real name and its effective name  * patch20: added Atari ST portability  * patch20: new warning for use of x with non-numeric right operand  * patch20: modulus with highest bit in left operand set didn't always work  * patch20: dbmclose(%array) didn't work  * patch20: added ... as variant on ..  * patch20: O_PIPE conflicted with Atari  *  * Revision 4.0.1.3  91/11/05  17:15:21  lwall  * patch11: prepared for ctype implementations that don't define isascii()  * patch11: various portability fixes  * patch11: added sort {} LIST  * patch11: added eval {}  * patch11: sysread() in socket was substituting recv()  * patch11: a last statement outside any block caused occasional core dumps  * patch11: missing arguments caused core dump in -D8 code  * patch11: eval 'stuff' now optimized to eval {stuff}  *  * Revision 4.0.1.2  91/06/07  11:07:23  lwall  * patch4: new copyright notice  * patch4: length($`), length($&), length($') now optimized to avoid string copy  * patch4: assignment wasn't correctly de-tainting the assigned variable.  * patch4: default top-of-form format is now FILEHANDLE_TOP  * patch4: added $^P variable to control calling of perldb routines  * patch4: taintchecks could improperly modify parent in vfork()  * patch4: many, many itty-bitty portability fixes  *  * Revision 4.0.1.1  91/04/11  17:43:48  lwall  * patch1: fixed failed fork to return undef as documented  * patch1: reduced maximum branch distance in eval.c  *  * Revision 4.0  91/03/20  01:16:48  lwall  * 4.0 baseline.  *  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NSIG
argument_list|)
operator|||
name|defined
argument_list|(
name|M_UNIX
argument_list|)
operator|||
name|defined
argument_list|(
name|M_XENIX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_FCNTL
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_comment
comment|/* I_FCNTL *MUST* not be defined for MS-DOS and OS/2    but fcntl.h is required for O_BINARY */
end_comment

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_SYS_FILE
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|I_VFORK
end_ifdef

begin_include
include|#
directive|include
file|<vfork.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VOIDSIG
end_ifdef

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|ihand
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|qhand
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|ihand
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|qhand
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|ARG
modifier|*
name|debarg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STR
name|str_args
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|STAB
modifier|*
name|stab2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|STIO
modifier|*
name|stio
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lstring
modifier|*
name|lstr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|old_rschar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|old_rslen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|sin
argument_list|()
decl_stmt|,
name|cos
argument_list|()
decl_stmt|,
name|atan2
argument_list|()
decl_stmt|,
name|pow
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|getlogin
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|eval
parameter_list|(
name|arg
parameter_list|,
name|gimme
parameter_list|,
name|sp
parameter_list|)
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
name|int
name|gimme
decl_stmt|;
specifier|register
name|int
name|sp
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
specifier|register
name|int
name|anum
decl_stmt|;
specifier|register
name|int
name|optype
decl_stmt|;
specifier|register
name|STR
modifier|*
modifier|*
name|st
decl_stmt|;
name|int
name|maxarg
decl_stmt|;
name|double
name|value
decl_stmt|;
specifier|register
name|char
modifier|*
name|tmps
decl_stmt|;
name|char
modifier|*
name|tmps2
decl_stmt|;
name|int
name|argflags
decl_stmt|;
name|int
name|argtype
decl_stmt|;
name|union
name|argptr
name|argptr
decl_stmt|;
name|int
name|arglast
index|[
literal|8
index|]
decl_stmt|;
comment|/* highest sp for arg--valid only for non-O_LIST args */
name|unsigned
name|long
name|tmpulong
decl_stmt|;
name|long
name|tmplong
decl_stmt|;
name|time_t
name|when
decl_stmt|;
name|STRLEN
name|tmplen
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|STR
modifier|*
name|tmpstr
decl_stmt|;
name|FCMD
modifier|*
name|form
decl_stmt|;
name|STAB
modifier|*
name|stab
decl_stmt|;
name|ARRAY
modifier|*
name|ary
decl_stmt|;
name|bool
name|assigning
init|=
name|FALSE
decl_stmt|;
name|double
name|exp
argument_list|()
decl_stmt|,
name|log
argument_list|()
decl_stmt|,
name|sqrt
argument_list|()
decl_stmt|,
name|modf
argument_list|()
decl_stmt|;
name|char
modifier|*
name|crypt
argument_list|()
decl_stmt|,
modifier|*
name|getenv
argument_list|()
decl_stmt|;
specifier|extern
name|void
name|grow_dlevel
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
name|arg
condition|)
goto|goto
name|say_undef
goto|;
name|optype
operator|=
name|arg
operator|->
name|arg_type
expr_stmt|;
name|maxarg
operator|=
name|arg
operator|->
name|arg_len
expr_stmt|;
name|arglast
index|[
literal|0
index|]
operator|=
name|sp
expr_stmt|;
name|str
operator|=
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
if|if
condition|(
name|sp
operator|+
name|maxarg
operator|>
name|stack
operator|->
name|ary_max
condition|)
name|astore
argument_list|(
name|stack
argument_list|,
name|sp
operator|+
name|maxarg
argument_list|,
name|Nullstr
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
block|{
if|if
condition|(
name|debug
operator|&
literal|8
condition|)
block|{
name|deb
argument_list|(
literal|"%s (%lx) %d args:\n"
argument_list|,
name|opname
index|[
name|optype
index|]
argument_list|,
name|arg
argument_list|,
name|maxarg
argument_list|)
expr_stmt|;
block|}
name|debname
index|[
name|dlevel
index|]
operator|=
name|opname
index|[
name|optype
index|]
index|[
literal|0
index|]
expr_stmt|;
name|debdelim
index|[
name|dlevel
index|]
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
operator|++
name|dlevel
operator|>=
name|dlmax
condition|)
name|grow_dlevel
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|anum
operator|=
literal|1
init|;
name|anum
operator|<=
name|maxarg
condition|;
name|anum
operator|++
control|)
block|{
name|argflags
operator|=
name|arg
index|[
name|anum
index|]
operator|.
name|arg_flags
expr_stmt|;
name|argtype
operator|=
name|arg
index|[
name|anum
index|]
operator|.
name|arg_type
expr_stmt|;
name|argptr
operator|=
name|arg
index|[
name|anum
index|]
operator|.
name|arg_ptr
expr_stmt|;
name|re_eval
label|:
switch|switch
condition|(
name|argtype
condition|)
block|{
default|default:
name|st
index|[
operator|++
name|sp
index|]
operator|=
operator|&
name|str_undef
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|tmps
operator|=
literal|"NULL"
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|A_EXPR
case|:
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|8
condition|)
block|{
name|tmps
operator|=
literal|"EXPR"
expr_stmt|;
name|deb
argument_list|(
literal|"%d.EXPR =>\n"
argument_list|,
name|anum
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sp
operator|=
name|eval
argument_list|(
name|argptr
operator|.
name|arg_arg
argument_list|,
operator|(
name|argflags
operator|&
name|AF_ARYOK
operator|)
condition|?
name|G_ARRAY
else|:
name|G_SCALAR
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|+
operator|(
name|maxarg
operator|-
name|anum
operator|)
operator|>
name|stack
operator|->
name|ary_max
condition|)
name|astore
argument_list|(
name|stack
argument_list|,
name|sp
operator|+
operator|(
name|maxarg
operator|-
name|anum
operator|)
argument_list|,
name|Nullstr
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
comment|/* possibly reallocated */
break|break;
case|case
name|A_CMD
case|:
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|8
condition|)
block|{
name|tmps
operator|=
literal|"CMD"
expr_stmt|;
name|deb
argument_list|(
literal|"%d.CMD (%lx) =>\n"
argument_list|,
name|anum
argument_list|,
name|argptr
operator|.
name|arg_cmd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sp
operator|=
name|cmd_exec
argument_list|(
name|argptr
operator|.
name|arg_cmd
argument_list|,
name|gimme
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|+
operator|(
name|maxarg
operator|-
name|anum
operator|)
operator|>
name|stack
operator|->
name|ary_max
condition|)
name|astore
argument_list|(
name|stack
argument_list|,
name|sp
operator|+
operator|(
name|maxarg
operator|-
name|anum
operator|)
argument_list|,
name|Nullstr
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
comment|/* possibly reallocated */
break|break;
case|case
name|A_LARYSTAB
case|:
operator|++
name|sp
expr_stmt|;
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|O_ITEM2
case|:
name|argtype
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|O_ITEM3
case|:
name|argtype
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|argtype
operator|=
name|anum
expr_stmt|;
break|break;
block|}
name|str
operator|=
name|afetch
argument_list|(
name|stab_array
argument_list|(
name|argptr
operator|.
name|arg_stab
argument_list|)
argument_list|,
name|arg
index|[
name|argtype
index|]
operator|.
name|arg_len
operator|-
name|arybase
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|8
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"LARYSTAB $%s[%d]"
argument_list|,
name|stab_name
argument_list|(
name|argptr
operator|.
name|arg_stab
argument_list|)
argument_list|,
name|arg
index|[
name|argtype
index|]
operator|.
name|arg_len
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|buf
expr_stmt|;
block|}
endif|#
directive|endif
goto|goto
name|do_crement
goto|;
case|case
name|A_ARYSTAB
case|:
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|O_ITEM2
case|:
name|argtype
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|O_ITEM3
case|:
name|argtype
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|argtype
operator|=
name|anum
expr_stmt|;
break|break;
block|}
name|st
index|[
operator|++
name|sp
index|]
operator|=
name|afetch
argument_list|(
name|stab_array
argument_list|(
name|argptr
operator|.
name|arg_stab
argument_list|)
argument_list|,
name|arg
index|[
name|argtype
index|]
operator|.
name|arg_len
operator|-
name|arybase
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|8
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"ARYSTAB $%s[%d]"
argument_list|,
name|stab_name
argument_list|(
name|argptr
operator|.
name|arg_stab
argument_list|)
argument_list|,
name|arg
index|[
name|argtype
index|]
operator|.
name|arg_len
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|buf
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|A_STAR
case|:
name|stab
operator|=
name|argptr
operator|.
name|arg_stab
expr_stmt|;
name|st
index|[
operator|++
name|sp
index|]
operator|=
operator|(
name|STR
operator|*
operator|)
name|stab
expr_stmt|;
if|if
condition|(
operator|!
name|stab_xarray
argument_list|(
name|stab
argument_list|)
condition|)
name|aadd
argument_list|(
name|stab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_xhash
argument_list|(
name|stab
argument_list|)
condition|)
name|hadd
argument_list|(
name|stab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_io
argument_list|(
name|stab
argument_list|)
condition|)
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|=
name|stio_new
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|8
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"STAR *%s -> *%s"
argument_list|,
name|stab_name
argument_list|(
name|argptr
operator|.
name|arg_stab
argument_list|)
argument_list|,
name|stab_ename
argument_list|(
name|argptr
operator|.
name|arg_stab
argument_list|)
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|buf
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|A_LSTAR
case|:
name|str
operator|=
name|st
index|[
operator|++
name|sp
index|]
operator|=
operator|(
name|STR
operator|*
operator|)
name|argptr
operator|.
name|arg_stab
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|8
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"LSTAR *%s -> *%s"
argument_list|,
name|stab_name
argument_list|(
name|argptr
operator|.
name|arg_stab
argument_list|)
argument_list|,
name|stab_ename
argument_list|(
name|argptr
operator|.
name|arg_stab
argument_list|)
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|buf
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|A_STAB
case|:
name|st
index|[
operator|++
name|sp
index|]
operator|=
name|STAB_STR
argument_list|(
name|argptr
operator|.
name|arg_stab
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|8
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"STAB $%s"
argument_list|,
name|stab_name
argument_list|(
name|argptr
operator|.
name|arg_stab
argument_list|)
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|buf
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|A_LENSTAB
case|:
name|str_numset
argument_list|(
name|str
argument_list|,
operator|(
name|double
operator|)
name|STAB_LEN
argument_list|(
name|argptr
operator|.
name|arg_stab
argument_list|)
argument_list|)
expr_stmt|;
name|st
index|[
operator|++
name|sp
index|]
operator|=
name|str
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|8
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"LENSTAB $%s"
argument_list|,
name|stab_name
argument_list|(
name|argptr
operator|.
name|arg_stab
argument_list|)
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|buf
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|A_LEXPR
case|:
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|8
condition|)
block|{
name|tmps
operator|=
literal|"LEXPR"
expr_stmt|;
name|deb
argument_list|(
literal|"%d.LEXPR =>\n"
argument_list|,
name|anum
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|argflags
operator|&
name|AF_ARYOK
condition|)
block|{
name|sp
operator|=
name|eval
argument_list|(
name|argptr
operator|.
name|arg_arg
argument_list|,
name|G_ARRAY
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|+
operator|(
name|maxarg
operator|-
name|anum
operator|)
operator|>
name|stack
operator|->
name|ary_max
condition|)
name|astore
argument_list|(
name|stack
argument_list|,
name|sp
operator|+
operator|(
name|maxarg
operator|-
name|anum
operator|)
argument_list|,
name|Nullstr
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
comment|/* possibly reallocated */
block|}
else|else
block|{
name|sp
operator|=
name|eval
argument_list|(
name|argptr
operator|.
name|arg_arg
argument_list|,
name|G_SCALAR
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
comment|/* possibly reallocated */
name|str
operator|=
name|st
index|[
name|sp
index|]
expr_stmt|;
goto|goto
name|do_crement
goto|;
block|}
break|break;
case|case
name|A_LVAL
case|:
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|8
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"LVAL $%s"
argument_list|,
name|stab_name
argument_list|(
name|argptr
operator|.
name|arg_stab
argument_list|)
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|buf
expr_stmt|;
block|}
endif|#
directive|endif
operator|++
name|sp
expr_stmt|;
name|str
operator|=
name|STAB_STR
argument_list|(
name|argptr
operator|.
name|arg_stab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
name|fatal
argument_list|(
literal|"panic: A_LVAL"
argument_list|)
expr_stmt|;
name|do_crement
label|:
name|assigning
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|argflags
operator|&
name|AF_PRE
condition|)
block|{
if|if
condition|(
name|argflags
operator|&
name|AF_UP
condition|)
name|str_inc
argument_list|(
name|str
argument_list|)
expr_stmt|;
else|else
name|str_dec
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|st
index|[
name|sp
index|]
operator|=
name|str
expr_stmt|;
name|str
operator|=
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argflags
operator|&
name|AF_POST
condition|)
block|{
name|st
index|[
name|sp
index|]
operator|=
name|str_mortal
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|argflags
operator|&
name|AF_UP
condition|)
name|str_inc
argument_list|(
name|str
argument_list|)
expr_stmt|;
else|else
name|str_dec
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
block|}
else|else
name|st
index|[
name|sp
index|]
operator|=
name|str
expr_stmt|;
break|break;
case|case
name|A_LARYLEN
case|:
operator|++
name|sp
expr_stmt|;
name|stab
operator|=
name|argptr
operator|.
name|arg_stab
expr_stmt|;
name|str
operator|=
name|stab_array
argument_list|(
name|argptr
operator|.
name|arg_stab
argument_list|)
operator|->
name|ary_magic
expr_stmt|;
if|if
condition|(
name|optype
operator|!=
name|O_SASSIGN
operator|||
name|argflags
operator|&
operator|(
name|AF_PRE
operator||
name|AF_POST
operator|)
condition|)
name|str_numset
argument_list|(
name|str
argument_list|,
call|(
name|double
call|)
argument_list|(
name|stab_array
argument_list|(
name|stab
argument_list|)
operator|->
name|ary_fill
operator|+
name|arybase
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|tmps
operator|=
literal|"LARYLEN"
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|str
condition|)
name|fatal
argument_list|(
literal|"panic: A_LEXPR"
argument_list|)
expr_stmt|;
goto|goto
name|do_crement
goto|;
case|case
name|A_ARYLEN
case|:
name|stab
operator|=
name|argptr
operator|.
name|arg_stab
expr_stmt|;
name|st
index|[
operator|++
name|sp
index|]
operator|=
name|stab_array
argument_list|(
name|stab
argument_list|)
operator|->
name|ary_magic
expr_stmt|;
name|str_numset
argument_list|(
name|st
index|[
name|sp
index|]
argument_list|,
call|(
name|double
call|)
argument_list|(
name|stab_array
argument_list|(
name|stab
argument_list|)
operator|->
name|ary_fill
operator|+
name|arybase
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|tmps
operator|=
literal|"ARYLEN"
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|A_SINGLE
case|:
name|st
index|[
operator|++
name|sp
index|]
operator|=
name|argptr
operator|.
name|arg_str
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|tmps
operator|=
literal|"SINGLE"
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|A_DOUBLE
case|:
operator|(
name|void
operator|)
name|interp
argument_list|(
name|str
argument_list|,
name|argptr
operator|.
name|arg_str
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
name|st
index|[
operator|++
name|sp
index|]
operator|=
name|str
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|tmps
operator|=
literal|"DOUBLE"
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|A_BACKTICK
case|:
name|tmps
operator|=
name|str_get
argument_list|(
name|interp
argument_list|(
name|str
argument_list|,
name|argptr
operator|.
name|arg_str
argument_list|,
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in ``"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fp
operator|=
name|mypopen
argument_list|(
name|tmps
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
condition|)
block|{
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
block|{
while|while
condition|(
name|str_gets
argument_list|(
name|str
argument_list|,
name|fp
argument_list|,
name|str
operator|->
name|str_cur
argument_list|)
operator|!=
name|Nullch
condition|)
comment|/*SUPPRESS 530*/
empty_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|++
name|sp
operator|>
name|stack
operator|->
name|ary_max
condition|)
block|{
name|astore
argument_list|(
name|stack
argument_list|,
name|sp
argument_list|,
name|Nullstr
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
block|}
name|str
operator|=
name|st
index|[
name|sp
index|]
operator|=
name|Str_new
argument_list|(
literal|56
argument_list|,
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_gets
argument_list|(
name|str
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
operator|==
name|Nullch
condition|)
block|{
name|sp
operator|--
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|str
operator|->
name|str_len
operator|-
name|str
operator|->
name|str_cur
operator|>
literal|20
condition|)
block|{
name|str
operator|->
name|str_len
operator|=
name|str
operator|->
name|str_cur
operator|+
literal|1
expr_stmt|;
name|Renew
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|,
name|str
operator|->
name|str_len
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
name|str_2mortal
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
name|statusvalue
operator|=
name|mypclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
name|statusvalue
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_SCALAR
condition|)
name|st
index|[
operator|++
name|sp
index|]
operator|=
name|str
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|tmps
operator|=
literal|"BACK"
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|A_WANTARRAY
case|:
block|{
if|if
condition|(
name|curcsv
operator|->
name|wantarray
operator|==
name|G_ARRAY
condition|)
name|st
index|[
operator|++
name|sp
index|]
operator|=
operator|&
name|str_yes
expr_stmt|;
else|else
name|st
index|[
operator|++
name|sp
index|]
operator|=
operator|&
name|str_no
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
name|tmps
operator|=
literal|"WANTARRAY"
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|A_INDREAD
case|:
name|last_in_stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|STAB_STR
argument_list|(
name|argptr
operator|.
name|arg_stab
argument_list|)
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|old_rschar
operator|=
name|rschar
expr_stmt|;
name|old_rslen
operator|=
name|rslen
expr_stmt|;
goto|goto
name|do_read
goto|;
case|case
name|A_GLOB
case|:
name|argflags
operator||=
name|AF_POST
expr_stmt|;
comment|/* enable newline chopping */
name|last_in_stab
operator|=
name|argptr
operator|.
name|arg_stab
expr_stmt|;
name|old_rschar
operator|=
name|rschar
expr_stmt|;
name|old_rslen
operator|=
name|rslen
expr_stmt|;
name|rslen
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DOSISH
name|rschar
operator|=
literal|0
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|CSH
name|rschar
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|rschar
operator|=
literal|'\n'
expr_stmt|;
endif|#
directive|endif
comment|/* !CSH */
endif|#
directive|endif
comment|/* !MSDOS */
goto|goto
name|do_read
goto|;
case|case
name|A_READ
case|:
name|last_in_stab
operator|=
name|argptr
operator|.
name|arg_stab
expr_stmt|;
name|old_rschar
operator|=
name|rschar
expr_stmt|;
name|old_rslen
operator|=
name|rslen
expr_stmt|;
name|do_read
label|:
if|if
condition|(
name|anum
operator|>
literal|1
condition|)
comment|/* assign to scalar */
name|gimme
operator|=
name|G_SCALAR
expr_stmt|;
comment|/* force context to scalar */
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
name|str
operator|=
name|Str_new
argument_list|(
literal|57
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|++
name|sp
expr_stmt|;
name|fp
operator|=
name|Nullfp
expr_stmt|;
if|if
condition|(
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
condition|)
block|{
name|fp
operator|=
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
if|if
condition|(
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|->
name|flags
operator|&
name|IOF_ARGV
condition|)
block|{
if|if
condition|(
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|->
name|flags
operator|&
name|IOF_START
condition|)
block|{
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|->
name|flags
operator|&=
operator|~
name|IOF_START
expr_stmt|;
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|->
name|lines
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|alen
argument_list|(
name|stab_array
argument_list|(
name|last_in_stab
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tmpstr
operator|=
name|str_make
argument_list|(
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* assume stdin */
operator|(
name|void
operator|)
name|apush
argument_list|(
name|stab_array
argument_list|(
name|last_in_stab
argument_list|)
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
block|}
block|}
name|fp
operator|=
name|nextargv
argument_list|(
name|last_in_stab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
comment|/* Note: fp != stab_io(last_in_stab)->ifp */
operator|(
name|void
operator|)
name|do_close
argument_list|(
name|last_in_stab
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* now it does*/
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|->
name|flags
operator||=
name|IOF_START
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|argtype
operator|==
name|A_GLOB
condition|)
block|{
operator|(
name|void
operator|)
name|interp
argument_list|(
name|str
argument_list|,
name|stab_val
argument_list|(
name|last_in_stab
argument_list|)
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
name|tmpstr
operator|=
name|Str_new
argument_list|(
literal|55
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DOSISH
name|str_set
argument_list|(
name|tmpstr
argument_list|,
literal|"perlglob "
argument_list|)
expr_stmt|;
name|str_scat
argument_list|(
name|tmpstr
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|tmpstr
argument_list|,
literal|" |"
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|CSH
name|str_nset
argument_list|(
name|tmpstr
argument_list|,
name|cshname
argument_list|,
name|cshlen
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|tmpstr
argument_list|,
literal|" -cf 'set nonomatch; glob "
argument_list|)
expr_stmt|;
name|str_scat
argument_list|(
name|tmpstr
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|tmpstr
argument_list|,
literal|"'|"
argument_list|)
expr_stmt|;
else|#
directive|else
name|str_set
argument_list|(
name|tmpstr
argument_list|,
literal|"echo "
argument_list|)
expr_stmt|;
name|str_scat
argument_list|(
name|tmpstr
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|tmpstr
argument_list|,
literal|"|tr -s ' \t\f\r' '\\012\\012\\012\\012'|"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !CSH */
endif|#
directive|endif
comment|/* !MSDOS */
operator|(
name|void
operator|)
name|do_open
argument_list|(
name|last_in_stab
argument_list|,
name|tmpstr
operator|->
name|str_ptr
argument_list|,
name|tmpstr
operator|->
name|str_cur
argument_list|)
expr_stmt|;
name|fp
operator|=
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|->
name|ifp
expr_stmt|;
name|str_free
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|fp
operator|&&
name|dowarn
condition|)
name|warn
argument_list|(
literal|"Read on closed filehandle<%s>"
argument_list|,
name|stab_ename
argument_list|(
name|last_in_stab
argument_list|)
argument_list|)
expr_stmt|;
name|tmplen
operator|=
name|str
operator|->
name|str_len
expr_stmt|;
comment|/* remember if already alloced */
if|if
condition|(
operator|!
name|tmplen
condition|)
name|Str_Grow
argument_list|(
name|str
argument_list|,
literal|80
argument_list|)
expr_stmt|;
comment|/* try short-buffering it */
name|keepgoing
label|:
if|if
condition|(
operator|!
name|fp
condition|)
name|st
index|[
name|sp
index|]
operator|=
operator|&
name|str_undef
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|str_gets
argument_list|(
name|str
argument_list|,
name|fp
argument_list|,
name|optype
operator|==
name|O_RCAT
condition|?
name|str
operator|->
name|str_cur
else|:
literal|0
argument_list|)
condition|)
block|{
name|clearerr
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|->
name|flags
operator|&
name|IOF_ARGV
condition|)
block|{
name|fp
operator|=
name|nextargv
argument_list|(
name|last_in_stab
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
condition|)
goto|goto
name|keepgoing
goto|;
operator|(
name|void
operator|)
name|do_close
argument_list|(
name|last_in_stab
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|->
name|flags
operator||=
name|IOF_START
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argflags
operator|&
name|AF_POST
condition|)
block|{
operator|(
name|void
operator|)
name|do_close
argument_list|(
name|last_in_stab
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|st
index|[
name|sp
index|]
operator|=
operator|&
name|str_undef
expr_stmt|;
name|rschar
operator|=
name|old_rschar
expr_stmt|;
name|rslen
operator|=
name|old_rslen
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
block|{
operator|--
name|sp
expr_stmt|;
name|str_2mortal
argument_list|(
name|str
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
block|}
break|break;
block|}
else|else
block|{
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|->
name|lines
operator|++
expr_stmt|;
name|st
index|[
name|sp
index|]
operator|=
name|str
expr_stmt|;
ifdef|#
directive|ifdef
name|TAINT
name|str
operator|->
name|str_tainted
operator|=
literal|1
expr_stmt|;
comment|/* Anything from the outside world...*/
endif|#
directive|endif
if|if
condition|(
name|argflags
operator|&
name|AF_POST
condition|)
block|{
if|if
condition|(
name|str
operator|->
name|str_cur
operator|>
literal|0
condition|)
name|str
operator|->
name|str_cur
operator|--
expr_stmt|;
if|if
condition|(
name|str
operator|->
name|str_ptr
index|[
name|str
operator|->
name|str_cur
index|]
operator|==
name|rschar
condition|)
name|str
operator|->
name|str_ptr
index|[
name|str
operator|->
name|str_cur
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|str
operator|->
name|str_cur
operator|++
expr_stmt|;
for|for
control|(
name|tmps
operator|=
name|str
operator|->
name|str_ptr
init|;
operator|*
name|tmps
condition|;
name|tmps
operator|++
control|)
if|if
condition|(
operator|!
name|isALPHA
argument_list|(
operator|*
name|tmps
argument_list|)
operator|&&
operator|!
name|isDIGIT
argument_list|(
operator|*
name|tmps
argument_list|)
operator|&&
name|index
argument_list|(
literal|"$&*(){}[]'\";\\|?<>~`"
argument_list|,
operator|*
name|tmps
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|tmps
operator|&&
name|stat
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|keepgoing
goto|;
comment|/* unmatched wildcard? */
block|}
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
block|{
if|if
condition|(
name|str
operator|->
name|str_len
operator|-
name|str
operator|->
name|str_cur
operator|>
literal|20
condition|)
block|{
name|str
operator|->
name|str_len
operator|=
name|str
operator|->
name|str_cur
operator|+
literal|1
expr_stmt|;
name|Renew
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|,
name|str
operator|->
name|str_len
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
name|str_2mortal
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|sp
operator|>
name|stack
operator|->
name|ary_max
condition|)
block|{
name|astore
argument_list|(
name|stack
argument_list|,
name|sp
argument_list|,
name|Nullstr
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
block|}
name|str
operator|=
name|Str_new
argument_list|(
literal|58
argument_list|,
literal|80
argument_list|)
expr_stmt|;
goto|goto
name|keepgoing
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|tmplen
operator|&&
name|str
operator|->
name|str_len
operator|-
name|str
operator|->
name|str_cur
operator|>
literal|80
condition|)
block|{
comment|/* try to reclaim a bit of scalar space on 1st alloc */
if|if
condition|(
name|str
operator|->
name|str_cur
operator|<
literal|60
condition|)
name|str
operator|->
name|str_len
operator|=
literal|80
expr_stmt|;
else|else
name|str
operator|->
name|str_len
operator|=
name|str
operator|->
name|str_cur
operator|+
literal|40
expr_stmt|;
comment|/* allow some slop */
name|Renew
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|,
name|str
operator|->
name|str_len
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
block|}
name|rschar
operator|=
name|old_rschar
expr_stmt|;
name|rslen
operator|=
name|old_rslen
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|tmps
operator|=
literal|"READ"
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|8
condition|)
name|deb
argument_list|(
literal|"%d.%s = '%s'\n"
argument_list|,
name|anum
argument_list|,
name|tmps
argument_list|,
name|str_peek
argument_list|(
name|st
index|[
name|sp
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|anum
operator|<
literal|8
condition|)
name|arglast
index|[
name|anum
index|]
operator|=
name|sp
expr_stmt|;
block|}
name|st
operator|+=
name|arglast
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|SMALLSWITCHES
if|if
condition|(
name|optype
operator|<
name|O_CHOWN
condition|)
endif|#
directive|endif
switch|switch
condition|(
name|optype
condition|)
block|{
case|case
name|O_RCAT
case|:
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_ITEM
case|:
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
goto|goto
name|array_return
goto|;
comment|/* FALL THROUGH */
case|case
name|O_SCALAR
case|:
name|STR_SSET
argument_list|(
name|str
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_ITEM2
case|:
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
goto|goto
name|array_return
goto|;
operator|--
name|anum
expr_stmt|;
name|STR_SSET
argument_list|(
name|str
argument_list|,
name|st
index|[
name|arglast
index|[
name|anum
index|]
operator|-
name|arglast
index|[
literal|0
index|]
index|]
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_ITEM3
case|:
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
goto|goto
name|array_return
goto|;
operator|--
name|anum
expr_stmt|;
name|STR_SSET
argument_list|(
name|str
argument_list|,
name|st
index|[
name|arglast
index|[
name|anum
index|]
operator|-
name|arglast
index|[
literal|0
index|]
index|]
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_CONCAT
case|:
name|STR_SSET
argument_list|(
name|str
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|str_scat
argument_list|(
name|str
argument_list|,
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_REPEAT
case|:
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
operator|&&
name|arg
index|[
literal|1
index|]
operator|.
name|arg_flags
operator|&
name|AF_ARYOK
condition|)
block|{
name|sp
operator|=
name|do_repeatary
argument_list|(
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
block|}
name|STR_SSET
argument_list|(
name|str
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|anum
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|anum
operator|>=
literal|1
condition|)
block|{
name|tmpstr
operator|=
name|Str_new
argument_list|(
literal|50
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|str_get
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|str_nset
argument_list|(
name|tmpstr
argument_list|,
name|tmps
argument_list|,
name|str
operator|->
name|str_cur
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|str_get
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
comment|/* force to be string */
name|STR_GROW
argument_list|(
name|str
argument_list|,
operator|(
name|anum
operator|*
name|str
operator|->
name|str_cur
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|repeatcpy
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|,
name|tmps
argument_list|,
name|tmpstr
operator|->
name|str_cur
argument_list|,
name|anum
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_cur
operator|*=
name|anum
expr_stmt|;
name|str
operator|->
name|str_ptr
index|[
name|str
operator|->
name|str_cur
index|]
operator|=
literal|'\0'
expr_stmt|;
name|str
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
name|str_free
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dowarn
operator|&&
name|st
index|[
literal|2
index|]
operator|->
name|str_pok
operator|&&
operator|!
name|looks_like_number
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
condition|)
name|warn
argument_list|(
literal|"Right operand of x is not numeric"
argument_list|)
expr_stmt|;
name|str_sset
argument_list|(
name|str
argument_list|,
operator|&
name|str_no
argument_list|)
expr_stmt|;
block|}
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_MATCH
case|:
name|sp
operator|=
name|do_match
argument_list|(
name|str
argument_list|,
name|arg
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
goto|goto
name|array_return
goto|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_NMATCH
case|:
name|sp
operator|=
name|do_match
argument_list|(
name|str
argument_list|,
name|arg
argument_list|,
name|G_SCALAR
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
name|str_sset
argument_list|(
name|str
argument_list|,
name|str_true
argument_list|(
name|str
argument_list|)
condition|?
operator|&
name|str_no
else|:
operator|&
name|str_yes
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_SUBST
case|:
name|sp
operator|=
name|do_subst
argument_list|(
name|str
argument_list|,
name|arg
argument_list|,
name|arglast
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_NSUBST
case|:
name|sp
operator|=
name|do_subst
argument_list|(
name|str
argument_list|,
name|arg
argument_list|,
name|arglast
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|str
operator|=
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
name|str_true
argument_list|(
name|str
argument_list|)
condition|?
name|No
else|:
name|Yes
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_ASSIGN
case|:
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_flags
operator|&
name|AF_ARYOK
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|arg_len
operator|==
literal|1
condition|)
block|{
name|arg
operator|->
name|arg_type
operator|=
name|O_LOCAL
expr_stmt|;
goto|goto
name|local
goto|;
block|}
else|else
block|{
name|arg
operator|->
name|arg_type
operator|=
name|O_AASSIGN
expr_stmt|;
goto|goto
name|aassign
goto|;
block|}
block|}
else|else
block|{
name|arg
operator|->
name|arg_type
operator|=
name|O_SASSIGN
expr_stmt|;
goto|goto
name|sassign
goto|;
block|}
case|case
name|O_LOCAL
case|:
name|local
label|:
name|arglast
index|[
literal|2
index|]
operator|=
name|arglast
index|[
literal|1
index|]
expr_stmt|;
comment|/* push a null array */
comment|/* FALL THROUGH */
case|case
name|O_AASSIGN
case|:
name|aassign
label|:
name|sp
operator|=
name|do_assign
argument_list|(
name|arg
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_SASSIGN
case|:
name|sassign
label|:
ifdef|#
directive|ifdef
name|TAINT
if|if
condition|(
name|tainted
operator|&&
operator|!
name|st
index|[
literal|2
index|]
operator|->
name|str_tainted
condition|)
name|tainted
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|STR_SSET
argument_list|(
name|str
argument_list|,
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_CHOP
case|:
name|st
operator|-=
name|arglast
index|[
literal|0
index|]
expr_stmt|;
name|str
operator|=
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|arglast
index|[
literal|0
index|]
operator|+
literal|1
init|;
name|sp
operator|<=
name|arglast
index|[
literal|1
index|]
condition|;
name|sp
operator|++
control|)
name|do_chop
argument_list|(
name|str
argument_list|,
name|st
index|[
name|sp
index|]
argument_list|)
expr_stmt|;
name|st
operator|+=
name|arglast
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|O_DEFINED
case|:
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_DONT
condition|)
block|{
name|sp
operator|=
name|do_defined
argument_list|(
name|str
argument_list|,
name|arg
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
block|}
elseif|else
if|if
condition|(
name|str
operator|->
name|str_pok
operator|||
name|str
operator|->
name|str_nok
condition|)
goto|goto
name|say_yes
goto|;
goto|goto
name|say_no
goto|;
case|case
name|O_UNDEF
case|:
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_DONT
condition|)
block|{
name|sp
operator|=
name|do_undef
argument_list|(
name|str
argument_list|,
name|arg
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
block|}
elseif|else
if|if
condition|(
name|str
operator|!=
name|stab_val
argument_list|(
name|defstab
argument_list|)
condition|)
block|{
if|if
condition|(
name|str
operator|->
name|str_len
condition|)
block|{
if|if
condition|(
name|str
operator|->
name|str_state
operator|==
name|SS_INCR
condition|)
name|Str_Grow
argument_list|(
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_ptr
operator|=
name|Nullch
expr_stmt|;
name|str
operator|->
name|str_len
operator|=
literal|0
expr_stmt|;
block|}
name|str
operator|->
name|str_pok
operator|=
name|str
operator|->
name|str_nok
operator|=
literal|0
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
goto|goto
name|say_undef
goto|;
case|case
name|O_STUDY
case|:
name|sp
operator|=
name|do_study
argument_list|(
name|str
argument_list|,
name|arg
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_POW
case|:
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|value
operator|=
name|pow
argument_list|(
name|value
argument_list|,
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_MULTIPLY
case|:
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|value
operator|*=
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_DIVIDE
case|:
if|if
condition|(
operator|(
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
operator|)
operator|==
literal|0.0
condition|)
name|fatal
argument_list|(
literal|"Illegal division by zero"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SLOPPYDIVIDE
comment|/* insure that 20./5. == 4. */
block|{
name|double
name|x
decl_stmt|;
name|int
name|k
decl_stmt|;
name|x
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|double
operator|)
operator|(
name|int
operator|)
name|x
operator|==
name|x
operator|&&
operator|(
name|double
operator|)
operator|(
name|int
operator|)
name|value
operator|==
name|value
operator|&&
operator|(
name|k
operator|=
operator|(
name|int
operator|)
name|x
operator|/
operator|(
name|int
operator|)
name|value
operator|)
operator|*
operator|(
name|int
operator|)
name|value
operator|==
operator|(
name|int
operator|)
name|x
condition|)
block|{
name|value
operator|=
name|k
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|x
operator|/
name|value
expr_stmt|;
block|}
block|}
else|#
directive|else
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
operator|/
name|value
expr_stmt|;
endif|#
directive|endif
goto|goto
name|donumset
goto|;
case|case
name|O_MODULO
case|:
name|tmpulong
operator|=
operator|(
name|unsigned
name|long
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpulong
operator|==
literal|0L
condition|)
name|fatal
argument_list|(
literal|"Illegal modulus zero"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|>=
literal|0.0
condition|)
name|value
operator|=
call|(
name|double
call|)
argument_list|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|value
operator|)
operator|%
name|tmpulong
argument_list|)
expr_stmt|;
else|else
block|{
name|tmplong
operator|=
operator|(
name|long
operator|)
name|value
expr_stmt|;
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|tmpulong
operator|-
operator|(
operator|(
operator|-
name|tmplong
operator|-
literal|1
operator|)
operator|%
name|tmpulong
operator|)
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
goto|goto
name|donumset
goto|;
case|case
name|O_ADD
case|:
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|value
operator|+=
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_SUBTRACT
case|:
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|value
operator|-=
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_LEFT_SHIFT
case|:
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|anum
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|U_L
argument_list|(
name|value
argument_list|)
operator|<<
name|anum
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|donumset
goto|;
case|case
name|O_RIGHT_SHIFT
case|:
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|anum
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|U_L
argument_list|(
name|value
argument_list|)
operator|>>
name|anum
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|donumset
goto|;
case|case
name|O_LT
case|:
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|<
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
operator|)
condition|?
literal|1.0
else|:
literal|0.0
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_GT
case|:
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|>
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
operator|)
condition|?
literal|1.0
else|:
literal|0.0
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_LE
case|:
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|<=
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
operator|)
condition|?
literal|1.0
else|:
literal|0.0
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_GE
case|:
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|>=
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
operator|)
condition|?
literal|1.0
else|:
literal|0.0
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_EQ
case|:
if|if
condition|(
name|dowarn
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|st
index|[
literal|1
index|]
operator|->
name|str_nok
operator|&&
operator|!
name|looks_like_number
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|st
index|[
literal|2
index|]
operator|->
name|str_nok
operator|&&
operator|!
name|looks_like_number
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
operator|)
condition|)
name|warn
argument_list|(
literal|"Possible use of == on string value"
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|==
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
operator|)
condition|?
literal|1.0
else|:
literal|0.0
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_NE
case|:
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|value
operator|!=
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
operator|)
condition|?
literal|1.0
else|:
literal|0.0
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_NCMP
case|:
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|value
operator|-=
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|>
literal|0.0
condition|)
name|value
operator|=
literal|1.0
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|<
literal|0.0
condition|)
name|value
operator|=
operator|-
literal|1.0
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_BIT_AND
case|:
if|if
condition|(
operator|!
name|sawvec
operator|||
name|st
index|[
literal|1
index|]
operator|->
name|str_nok
operator|||
name|st
index|[
literal|2
index|]
operator|->
name|str_nok
condition|)
block|{
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|U_L
argument_list|(
name|value
argument_list|)
operator|&
name|U_L
argument_list|(
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|donumset
goto|;
block|}
else|else
name|do_vop
argument_list|(
name|optype
argument_list|,
name|str
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|,
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_XOR
case|:
if|if
condition|(
operator|!
name|sawvec
operator|||
name|st
index|[
literal|1
index|]
operator|->
name|str_nok
operator|||
name|st
index|[
literal|2
index|]
operator|->
name|str_nok
condition|)
block|{
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|U_L
argument_list|(
name|value
argument_list|)
operator|^
name|U_L
argument_list|(
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|donumset
goto|;
block|}
else|else
name|do_vop
argument_list|(
name|optype
argument_list|,
name|str
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|,
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_BIT_OR
case|:
if|if
condition|(
operator|!
name|sawvec
operator|||
name|st
index|[
literal|1
index|]
operator|->
name|str_nok
operator|||
name|st
index|[
literal|2
index|]
operator|->
name|str_nok
condition|)
block|{
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|U_L
argument_list|(
name|value
argument_list|)
operator||
name|U_L
argument_list|(
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|donumset
goto|;
block|}
else|else
name|do_vop
argument_list|(
name|optype
argument_list|,
name|str
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|,
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
comment|/* use register in evaluating str_true() */
case|case
name|O_AND
case|:
if|if
condition|(
name|str_true
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|anum
operator|=
literal|2
expr_stmt|;
name|optype
operator|=
name|O_ITEM2
expr_stmt|;
name|argflags
operator|=
name|arg
index|[
name|anum
index|]
operator|.
name|arg_flags
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
name|argflags
operator||=
name|AF_ARYOK
expr_stmt|;
name|argtype
operator|=
name|arg
index|[
name|anum
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
expr_stmt|;
name|argptr
operator|=
name|arg
index|[
name|anum
index|]
operator|.
name|arg_ptr
expr_stmt|;
name|maxarg
operator|=
name|anum
operator|=
literal|1
expr_stmt|;
name|sp
operator|=
name|arglast
index|[
literal|0
index|]
expr_stmt|;
name|st
operator|-=
name|sp
expr_stmt|;
goto|goto
name|re_eval
goto|;
block|}
else|else
block|{
if|if
condition|(
name|assigning
condition|)
block|{
name|str_sset
argument_list|(
name|str
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
else|else
name|str
operator|=
name|st
index|[
literal|1
index|]
expr_stmt|;
break|break;
block|}
case|case
name|O_OR
case|:
if|if
condition|(
name|str_true
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|assigning
condition|)
block|{
name|str_sset
argument_list|(
name|str
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
else|else
name|str
operator|=
name|st
index|[
literal|1
index|]
expr_stmt|;
break|break;
block|}
else|else
block|{
name|anum
operator|=
literal|2
expr_stmt|;
name|optype
operator|=
name|O_ITEM2
expr_stmt|;
name|argflags
operator|=
name|arg
index|[
name|anum
index|]
operator|.
name|arg_flags
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
name|argflags
operator||=
name|AF_ARYOK
expr_stmt|;
name|argtype
operator|=
name|arg
index|[
name|anum
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
expr_stmt|;
name|argptr
operator|=
name|arg
index|[
name|anum
index|]
operator|.
name|arg_ptr
expr_stmt|;
name|maxarg
operator|=
name|anum
operator|=
literal|1
expr_stmt|;
name|sp
operator|=
name|arglast
index|[
literal|0
index|]
expr_stmt|;
name|st
operator|-=
name|sp
expr_stmt|;
goto|goto
name|re_eval
goto|;
block|}
case|case
name|O_COND_EXPR
case|:
name|anum
operator|=
operator|(
name|str_true
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
condition|?
literal|2
else|:
literal|3
operator|)
expr_stmt|;
name|optype
operator|=
operator|(
name|anum
operator|==
literal|2
condition|?
name|O_ITEM2
else|:
name|O_ITEM3
operator|)
expr_stmt|;
name|argflags
operator|=
name|arg
index|[
name|anum
index|]
operator|.
name|arg_flags
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
name|argflags
operator||=
name|AF_ARYOK
expr_stmt|;
name|argtype
operator|=
name|arg
index|[
name|anum
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
expr_stmt|;
name|argptr
operator|=
name|arg
index|[
name|anum
index|]
operator|.
name|arg_ptr
expr_stmt|;
name|maxarg
operator|=
name|anum
operator|=
literal|1
expr_stmt|;
name|sp
operator|=
name|arglast
index|[
literal|0
index|]
expr_stmt|;
name|st
operator|-=
name|sp
expr_stmt|;
goto|goto
name|re_eval
goto|;
case|case
name|O_COMMA
case|:
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
goto|goto
name|array_return
goto|;
name|str
operator|=
name|st
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|O_NEGATE
case|:
name|value
operator|=
operator|-
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_NOT
case|:
ifdef|#
directive|ifdef
name|NOTNOT
block|{
name|char
name|xxx
init|=
name|str_true
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|value
operator|=
operator|(
name|double
operator|)
operator|!
name|xxx
expr_stmt|;
block|}
else|#
directive|else
name|value
operator|=
operator|(
name|double
operator|)
operator|!
name|str_true
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|donumset
goto|;
case|case
name|O_COMPLEMENT
case|:
if|if
condition|(
operator|!
name|sawvec
operator|||
name|st
index|[
literal|1
index|]
operator|->
name|str_nok
condition|)
block|{
ifndef|#
directive|ifndef
name|lint
name|value
operator|=
operator|(
name|double
operator|)
operator|~
name|U_L
argument_list|(
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|donumset
goto|;
block|}
else|else
block|{
name|STR_SSET
argument_list|(
name|str
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|str_get
argument_list|(
name|str
argument_list|)
expr_stmt|;
for|for
control|(
name|anum
operator|=
name|str
operator|->
name|str_cur
init|;
name|anum
condition|;
name|anum
operator|--
operator|,
name|tmps
operator|++
control|)
operator|*
name|tmps
operator|=
operator|~
operator|*
name|tmps
expr_stmt|;
block|}
break|break;
case|case
name|O_SELECT
case|:
name|stab_efullname
argument_list|(
name|str
argument_list|,
name|defoutstab
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxarg
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|defoutstab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|defoutstab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_io
argument_list|(
name|defoutstab
argument_list|)
condition|)
name|stab_io
argument_list|(
name|defoutstab
argument_list|)
operator|=
name|stio_new
argument_list|()
expr_stmt|;
name|curoutstab
operator|=
name|defoutstab
expr_stmt|;
block|}
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_WRITE
case|:
if|if
condition|(
name|maxarg
operator|==
literal|0
condition|)
name|stab
operator|=
name|defoutstab
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
operator|)
condition|)
name|stab
operator|=
name|defoutstab
expr_stmt|;
block|}
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_io
argument_list|(
name|stab
argument_list|)
condition|)
block|{
name|str_set
argument_list|(
name|str
argument_list|,
name|No
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
block|}
name|curoutstab
operator|=
name|stab
expr_stmt|;
name|fp
operator|=
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|ofp
expr_stmt|;
name|debarg
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|fmt_stab
condition|)
name|form
operator|=
name|stab_form
argument_list|(
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|fmt_stab
argument_list|)
expr_stmt|;
else|else
name|form
operator|=
name|stab_form
argument_list|(
name|stab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|form
operator|||
operator|!
name|fp
condition|)
block|{
if|if
condition|(
name|dowarn
condition|)
block|{
if|if
condition|(
name|form
condition|)
name|warn
argument_list|(
literal|"No format for filehandle"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|ifp
condition|)
name|warn
argument_list|(
literal|"Filehandle only opened for input"
argument_list|)
expr_stmt|;
else|else
name|warn
argument_list|(
literal|"Write on closed filehandle"
argument_list|)
expr_stmt|;
block|}
block|}
name|str_set
argument_list|(
name|str
argument_list|,
name|No
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
block|}
name|format
argument_list|(
operator|&
name|outrec
argument_list|,
name|form
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|do_write
argument_list|(
operator|&
name|outrec
argument_list|,
name|stab
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|flags
operator|&
name|IOF_FLUSH
condition|)
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_DBMOPEN
case|:
ifdef|#
directive|ifdef
name|SOME_DBM
name|anum
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
expr_stmt|;
if|if
condition|(
name|anum
operator|==
name|A_WORD
operator|||
name|anum
operator|==
name|A_STAB
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
index|[
literal|3
index|]
operator|->
name|str_nok
operator|||
name|st
index|[
literal|3
index|]
operator|->
name|str_pok
condition|)
name|anum
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
else|else
name|anum
operator|=
operator|-
literal|1
expr_stmt|;
name|value
operator|=
operator|(
name|double
operator|)
name|hdbmopen
argument_list|(
name|stab_hash
argument_list|(
name|stab
argument_list|)
argument_list|,
name|str_get
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|anum
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
else|#
directive|else
name|fatal
argument_list|(
literal|"No dbm or ndbm on this machine"
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|O_DBMCLOSE
case|:
ifdef|#
directive|ifdef
name|SOME_DBM
name|anum
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
expr_stmt|;
if|if
condition|(
name|anum
operator|==
name|A_WORD
operator|||
name|anum
operator|==
name|A_STAB
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|hdbmclose
argument_list|(
name|stab_hash
argument_list|(
name|stab
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|say_yes
goto|;
else|#
directive|else
name|fatal
argument_list|(
literal|"No dbm or ndbm on this machine"
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|O_OPEN
case|:
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_open
argument_list|(
name|stab
argument_list|,
name|tmps
argument_list|,
name|st
index|[
literal|2
index|]
operator|->
name|str_cur
argument_list|)
condition|)
block|{
name|value
operator|=
operator|(
name|double
operator|)
name|forkprocess
expr_stmt|;
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|lines
operator|=
literal|0
expr_stmt|;
goto|goto
name|donumset
goto|;
block|}
elseif|else
if|if
condition|(
name|forkprocess
operator|==
literal|0
condition|)
comment|/* we are a new child */
goto|goto
name|say_zero
goto|;
else|else
goto|goto
name|say_undef
goto|;
comment|/* break; */
case|case
name|O_TRANS
case|:
name|value
operator|=
operator|(
name|double
operator|)
name|do_trans
argument_list|(
name|str
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|str
operator|=
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_NTRANS
case|:
name|str_set
argument_list|(
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
argument_list|,
name|do_trans
argument_list|(
name|str
argument_list|,
name|arg
argument_list|)
operator|==
literal|0
condition|?
name|Yes
else|:
name|No
argument_list|)
expr_stmt|;
name|str
operator|=
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
break|break;
case|case
name|O_CLOSE
case|:
if|if
condition|(
name|maxarg
operator|==
literal|0
condition|)
name|stab
operator|=
name|defoutstab
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
name|do_close
argument_list|(
name|stab
argument_list|,
name|TRUE
argument_list|)
condition|?
name|Yes
else|:
name|No
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_EACH
case|:
name|sp
operator|=
name|do_each
argument_list|(
name|str
argument_list|,
name|stab_hash
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_VALUES
case|:
case|case
name|O_KEYS
case|:
name|sp
operator|=
name|do_kv
argument_list|(
name|str
argument_list|,
name|stab_hash
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
argument_list|,
name|optype
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_LARRAY
case|:
name|str
operator|->
name|str_nok
operator|=
name|str
operator|->
name|str_pok
operator|=
literal|0
expr_stmt|;
name|str
operator|->
name|str_u
operator|.
name|str_stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
name|str
operator|->
name|str_state
operator|=
name|SS_ARY
expr_stmt|;
break|break;
case|case
name|O_ARRAY
case|:
name|ary
operator|=
name|stab_array
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
expr_stmt|;
name|maxarg
operator|=
name|ary
operator|->
name|ary_fill
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
block|{
comment|/* array wanted */
name|sp
operator|=
name|arglast
index|[
literal|0
index|]
expr_stmt|;
name|st
operator|-=
name|sp
expr_stmt|;
if|if
condition|(
name|maxarg
operator|>
literal|0
operator|&&
name|sp
operator|+
name|maxarg
operator|>
name|stack
operator|->
name|ary_max
condition|)
block|{
name|astore
argument_list|(
name|stack
argument_list|,
name|sp
operator|+
name|maxarg
argument_list|,
name|Nullstr
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
block|}
name|st
operator|+=
name|sp
expr_stmt|;
name|Copy
argument_list|(
name|ary
operator|->
name|ary_array
argument_list|,
operator|&
name|st
index|[
literal|1
index|]
argument_list|,
name|maxarg
argument_list|,
name|STR
operator|*
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|maxarg
expr_stmt|;
goto|goto
name|array_return
goto|;
block|}
else|else
block|{
name|value
operator|=
operator|(
name|double
operator|)
name|maxarg
expr_stmt|;
goto|goto
name|donumset
goto|;
block|}
case|case
name|O_AELEM
case|:
name|anum
operator|=
operator|(
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
operator|)
operator|-
name|arybase
expr_stmt|;
name|str
operator|=
name|afetch
argument_list|(
name|stab_array
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
argument_list|,
name|anum
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_DELETE
case|:
name|tmpstab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|str
operator|=
name|hdelete
argument_list|(
name|stab_hash
argument_list|(
name|tmpstab
argument_list|)
argument_list|,
name|tmps
argument_list|,
name|st
index|[
literal|2
index|]
operator|->
name|str_cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpstab
operator|==
name|envstab
condition|)
name|my_setenv
argument_list|(
name|tmps
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
goto|goto
name|say_undef
goto|;
break|break;
case|case
name|O_LHASH
case|:
name|str
operator|->
name|str_nok
operator|=
name|str
operator|->
name|str_pok
operator|=
literal|0
expr_stmt|;
name|str
operator|->
name|str_u
operator|.
name|str_stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
name|str
operator|->
name|str_state
operator|=
name|SS_HASH
expr_stmt|;
break|break;
case|case
name|O_HASH
case|:
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
block|{
comment|/* array wanted */
name|sp
operator|=
name|do_kv
argument_list|(
name|str
argument_list|,
name|stab_hash
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
argument_list|,
name|optype
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
block|}
else|else
block|{
name|tmpstab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
if|if
condition|(
operator|!
name|stab_hash
argument_list|(
name|tmpstab
argument_list|)
operator|->
name|tbl_fill
condition|)
goto|goto
name|say_zero
goto|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d/%d"
argument_list|,
name|stab_hash
argument_list|(
name|tmpstab
argument_list|)
operator|->
name|tbl_fill
argument_list|,
name|stab_hash
argument_list|(
name|tmpstab
argument_list|)
operator|->
name|tbl_max
operator|+
literal|1
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|O_HELEM
case|:
name|tmpstab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|str
operator|=
name|hfetch
argument_list|(
name|stab_hash
argument_list|(
name|tmpstab
argument_list|)
argument_list|,
name|tmps
argument_list|,
name|st
index|[
literal|2
index|]
operator|->
name|str_cur
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_LAELEM
case|:
name|anum
operator|=
operator|(
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
operator|)
operator|-
name|arybase
expr_stmt|;
name|str
operator|=
name|afetch
argument_list|(
name|stab_array
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
argument_list|,
name|anum
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
operator|||
name|str
operator|==
operator|&
name|str_undef
condition|)
name|fatal
argument_list|(
literal|"Assignment to non-creatable value, subscript %d"
argument_list|,
name|anum
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_LHELEM
case|:
name|tmpstab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|anum
operator|=
name|st
index|[
literal|2
index|]
operator|->
name|str_cur
expr_stmt|;
name|str
operator|=
name|hfetch
argument_list|(
name|stab_hash
argument_list|(
name|tmpstab
argument_list|)
argument_list|,
name|tmps
argument_list|,
name|anum
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
operator|||
name|str
operator|==
operator|&
name|str_undef
condition|)
name|fatal
argument_list|(
literal|"Assignment to non-creatable value, subscript \"%s\""
argument_list|,
name|tmps
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpstab
operator|==
name|envstab
condition|)
comment|/* heavy wizardry going on here */
name|str_magic
argument_list|(
name|str
argument_list|,
name|tmpstab
argument_list|,
literal|'E'
argument_list|,
name|tmps
argument_list|,
name|anum
argument_list|)
expr_stmt|;
comment|/* str is now magic */
comment|/* he threw the brick up into the air */
elseif|else
if|if
condition|(
name|tmpstab
operator|==
name|sigstab
condition|)
name|str_magic
argument_list|(
name|str
argument_list|,
name|tmpstab
argument_list|,
literal|'S'
argument_list|,
name|tmps
argument_list|,
name|anum
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOME_DBM
elseif|else
if|if
condition|(
name|stab_hash
argument_list|(
name|tmpstab
argument_list|)
operator|->
name|tbl_dbm
condition|)
name|str_magic
argument_list|(
name|str
argument_list|,
name|tmpstab
argument_list|,
literal|'D'
argument_list|,
name|tmps
argument_list|,
name|anum
argument_list|)
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|tmpstab
operator|==
name|DBline
condition|)
name|str_magic
argument_list|(
name|str
argument_list|,
name|tmpstab
argument_list|,
literal|'L'
argument_list|,
name|tmps
argument_list|,
name|anum
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_LSLICE
case|:
name|anum
operator|=
literal|2
expr_stmt|;
name|argtype
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|do_slice_already
goto|;
case|case
name|O_ASLICE
case|:
name|anum
operator|=
literal|1
expr_stmt|;
name|argtype
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|do_slice_already
goto|;
case|case
name|O_HSLICE
case|:
name|anum
operator|=
literal|0
expr_stmt|;
name|argtype
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|do_slice_already
goto|;
case|case
name|O_LASLICE
case|:
name|anum
operator|=
literal|1
expr_stmt|;
name|argtype
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|do_slice_already
goto|;
case|case
name|O_LHSLICE
case|:
name|anum
operator|=
literal|0
expr_stmt|;
name|argtype
operator|=
name|TRUE
expr_stmt|;
name|do_slice_already
label|:
name|sp
operator|=
name|do_slice
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|,
name|str
argument_list|,
name|anum
argument_list|,
name|argtype
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_SPLICE
case|:
name|sp
operator|=
name|do_splice
argument_list|(
name|stab_array
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_PUSH
case|:
if|if
condition|(
name|arglast
index|[
literal|2
index|]
operator|-
name|arglast
index|[
literal|1
index|]
operator|!=
literal|1
condition|)
name|str
operator|=
name|do_push
argument_list|(
name|stab_array
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
else|else
block|{
name|str
operator|=
name|Str_new
argument_list|(
literal|51
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* must copy the STR */
name|str_sset
argument_list|(
name|str
argument_list|,
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|apush
argument_list|(
name|stab_array
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|O_POP
case|:
name|str
operator|=
name|apop
argument_list|(
name|ary
operator|=
name|stab_array
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|staticalization
goto|;
case|case
name|O_SHIFT
case|:
name|str
operator|=
name|ashift
argument_list|(
name|ary
operator|=
name|stab_array
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
argument_list|)
expr_stmt|;
name|staticalization
label|:
if|if
condition|(
operator|!
name|str
condition|)
goto|goto
name|say_undef
goto|;
if|if
condition|(
name|ary
operator|->
name|ary_flags
operator|&
name|ARF_REAL
condition|)
operator|(
name|void
operator|)
name|str_2mortal
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_UNPACK
case|:
name|sp
operator|=
name|do_unpack
argument_list|(
name|str
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_SPLIT
case|:
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|sp
operator|=
name|do_split
argument_list|(
name|str
argument_list|,
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
argument_list|,
operator|(
name|int
operator|)
name|value
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_LENGTH
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
name|value
operator|=
operator|(
name|double
operator|)
name|str_len
argument_list|(
name|stab_val
argument_list|(
name|defstab
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
operator|(
name|double
operator|)
name|str_len
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_SPRINTF
case|:
name|do_sprintf
argument_list|(
name|str
argument_list|,
name|sp
operator|-
name|arglast
index|[
literal|0
index|]
argument_list|,
name|st
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_SUBSTR
case|:
name|anum
operator|=
operator|(
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
operator|)
operator|-
name|arybase
expr_stmt|;
comment|/* anum=where to start*/
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* force conversion to string */
comment|/*SUPPRESS 560*/
if|if
condition|(
name|argtype
operator|=
operator|(
name|str
operator|==
name|st
index|[
literal|1
index|]
operator|)
condition|)
name|str
operator|=
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
if|if
condition|(
name|anum
operator|<
literal|0
condition|)
name|anum
operator|+=
name|st
index|[
literal|1
index|]
operator|->
name|str_cur
operator|+
name|arybase
expr_stmt|;
if|if
condition|(
name|anum
operator|<
literal|0
operator|||
name|anum
operator|>
name|st
index|[
literal|1
index|]
operator|->
name|str_cur
condition|)
name|str_nset
argument_list|(
name|str
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|optype
operator|=
name|maxarg
operator|<
literal|3
condition|?
name|st
index|[
literal|1
index|]
operator|->
name|str_cur
else|:
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|optype
operator|<
literal|0
condition|)
name|optype
operator|=
literal|0
expr_stmt|;
name|tmps
operator|+=
name|anum
expr_stmt|;
name|anum
operator|=
name|st
index|[
literal|1
index|]
operator|->
name|str_cur
operator|-
name|anum
expr_stmt|;
comment|/* anum=how many bytes left*/
if|if
condition|(
name|anum
operator|>
name|optype
condition|)
name|anum
operator|=
name|optype
expr_stmt|;
name|str_nset
argument_list|(
name|str
argument_list|,
name|tmps
argument_list|,
name|anum
argument_list|)
expr_stmt|;
if|if
condition|(
name|argtype
condition|)
block|{
comment|/* it's an lvalue! */
name|lstr
operator|=
operator|(
expr|struct
name|lstring
operator|*
operator|)
name|str
expr_stmt|;
name|str
operator|->
name|str_magic
operator|=
name|st
index|[
literal|1
index|]
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|->
name|str_rare
operator|=
literal|'s'
expr_stmt|;
name|lstr
operator|->
name|lstr_offset
operator|=
name|tmps
operator|-
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|lstr
operator|->
name|lstr_len
operator|=
name|anum
expr_stmt|;
block|}
block|}
break|break;
case|case
name|O_PACK
case|:
comment|/*SUPPRESS 701*/
operator|(
name|void
operator|)
name|do_pack
argument_list|(
name|str
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_GREP
case|:
name|sp
operator|=
name|do_grep
argument_list|(
name|arg
argument_list|,
name|str
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_JOIN
case|:
name|do_join
argument_list|(
name|str
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_SLT
case|:
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|str_cmp
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|,
name|st
index|[
literal|2
index|]
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_SGT
case|:
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|str_cmp
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|,
name|st
index|[
literal|2
index|]
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_SLE
case|:
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|str_cmp
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|,
name|st
index|[
literal|2
index|]
argument_list|)
operator|<=
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_SGE
case|:
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|str_cmp
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|,
name|st
index|[
literal|2
index|]
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_SEQ
case|:
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|double
operator|)
name|str_eq
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|,
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_SNE
case|:
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|double
operator|)
operator|!
name|str_eq
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|,
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_SCMP
case|:
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|double
operator|)
name|str_cmp
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|,
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_SUBR
case|:
name|sp
operator|=
name|do_subr
argument_list|(
name|arg
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
operator|+
name|arglast
index|[
literal|0
index|]
expr_stmt|;
comment|/* maybe realloced */
goto|goto
name|array_return
goto|;
case|case
name|O_DBSUBR
case|:
name|sp
operator|=
name|do_subr
argument_list|(
name|arg
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
operator|+
name|arglast
index|[
literal|0
index|]
expr_stmt|;
comment|/* maybe realloced */
goto|goto
name|array_return
goto|;
case|case
name|O_CALLER
case|:
name|sp
operator|=
name|do_caller
argument_list|(
name|arg
argument_list|,
name|maxarg
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
operator|+
name|arglast
index|[
literal|0
index|]
expr_stmt|;
comment|/* maybe realloced */
goto|goto
name|array_return
goto|;
case|case
name|O_SORT
case|:
name|sp
operator|=
name|do_sort
argument_list|(
name|str
argument_list|,
name|arg
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_REVERSE
case|:
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
name|sp
operator|=
name|do_reverse
argument_list|(
name|arglast
argument_list|)
expr_stmt|;
else|else
name|sp
operator|=
name|do_sreverse
argument_list|(
name|str
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_WARN
case|:
if|if
condition|(
name|arglast
index|[
literal|2
index|]
operator|-
name|arglast
index|[
literal|1
index|]
operator|!=
literal|1
condition|)
block|{
name|do_join
argument_list|(
name|str
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|str_get
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|str
operator|=
name|st
index|[
literal|2
index|]
expr_stmt|;
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tmps
operator|||
operator|!
operator|*
name|tmps
condition|)
name|tmps
operator|=
literal|"Warning: something's wrong"
expr_stmt|;
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|tmps
argument_list|)
expr_stmt|;
goto|goto
name|say_yes
goto|;
case|case
name|O_DIE
case|:
if|if
condition|(
name|arglast
index|[
literal|2
index|]
operator|-
name|arglast
index|[
literal|1
index|]
operator|!=
literal|1
condition|)
block|{
name|do_join
argument_list|(
name|str
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|str_get
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|str
operator|=
name|st
index|[
literal|2
index|]
expr_stmt|;
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tmps
operator|||
operator|!
operator|*
name|tmps
condition|)
name|tmps
operator|=
literal|"Died"
expr_stmt|;
name|fatal
argument_list|(
literal|"%s"
argument_list|,
name|tmps
argument_list|)
expr_stmt|;
goto|goto
name|say_zero
goto|;
case|case
name|O_PRTF
case|:
case|case
name|O_PRINT
case|:
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab
condition|)
name|stab
operator|=
name|defoutstab
expr_stmt|;
if|if
condition|(
operator|!
name|stab_io
argument_list|(
name|stab
argument_list|)
condition|)
block|{
if|if
condition|(
name|dowarn
condition|)
name|warn
argument_list|(
literal|"Filehandle never opened"
argument_list|)
expr_stmt|;
goto|goto
name|say_zero
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|ofp
operator|)
condition|)
block|{
if|if
condition|(
name|dowarn
condition|)
block|{
if|if
condition|(
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|ifp
condition|)
name|warn
argument_list|(
literal|"Filehandle opened only for input"
argument_list|)
expr_stmt|;
else|else
name|warn
argument_list|(
literal|"Print on closed filehandle"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|say_zero
goto|;
block|}
else|else
block|{
if|if
condition|(
name|optype
operator|==
name|O_PRTF
operator|||
name|arglast
index|[
literal|2
index|]
operator|-
name|arglast
index|[
literal|1
index|]
operator|!=
literal|1
condition|)
name|value
operator|=
operator|(
name|double
operator|)
name|do_aprint
argument_list|(
name|arg
argument_list|,
name|fp
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
else|else
block|{
name|value
operator|=
operator|(
name|double
operator|)
name|do_print
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|orslen
operator|&&
name|optype
operator|==
name|O_PRINT
condition|)
if|if
condition|(
name|fwrite
argument_list|(
name|ors
argument_list|,
literal|1
argument_list|,
name|orslen
argument_list|,
name|fp
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|say_zero
goto|;
block|}
if|if
condition|(
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|flags
operator|&
name|IOF_FLUSH
condition|)
if|if
condition|(
name|fflush
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
goto|goto
name|say_zero
goto|;
block|}
goto|goto
name|donumset
goto|;
case|case
name|O_CHDIR
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
name|tmps
operator|=
name|Nullch
expr_stmt|;
else|else
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmps
operator|||
operator|!
operator|*
name|tmps
condition|)
block|{
name|tmpstr
operator|=
name|hfetch
argument_list|(
name|stab_hash
argument_list|(
name|envstab
argument_list|)
argument_list|,
literal|"HOME"
argument_list|,
literal|4
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|str_get
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tmps
operator|||
operator|!
operator|*
name|tmps
condition|)
block|{
name|tmpstr
operator|=
name|hfetch
argument_list|(
name|stab_hash
argument_list|(
name|envstab
argument_list|)
argument_list|,
literal|"LOGDIR"
argument_list|,
literal|6
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|str_get
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in chdir"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|chdir
argument_list|(
name|tmps
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_EXIT
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
name|anum
operator|=
literal|0
expr_stmt|;
else|else
name|anum
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|anum
argument_list|)
expr_stmt|;
goto|goto
name|say_zero
goto|;
case|case
name|O_RESET
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
name|tmps
operator|=
literal|""
expr_stmt|;
else|else
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|str_reset
argument_list|(
name|tmps
argument_list|,
name|curcmd
operator|->
name|c_stash
argument_list|)
expr_stmt|;
name|value
operator|=
literal|1.0
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_LIST
case|:
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
goto|goto
name|array_return
goto|;
if|if
condition|(
name|maxarg
operator|>
literal|0
condition|)
name|str
operator|=
name|st
index|[
name|sp
operator|-
name|arglast
index|[
literal|0
index|]
index|]
expr_stmt|;
comment|/* unwanted list, return last item */
else|else
name|str
operator|=
operator|&
name|str_undef
expr_stmt|;
break|break;
case|case
name|O_EOF
case|:
if|if
condition|(
name|maxarg
operator|<=
literal|0
condition|)
name|stab
operator|=
name|last_in_stab
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
name|do_eof
argument_list|(
name|stab
argument_list|)
condition|?
name|Yes
else|:
name|No
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_GETC
case|:
if|if
condition|(
name|maxarg
operator|<=
literal|0
condition|)
name|stab
operator|=
name|stdinstab
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab
condition|)
name|stab
operator|=
name|argvstab
expr_stmt|;
if|if
condition|(
operator|!
name|stab
operator|||
name|do_eof
argument_list|(
name|stab
argument_list|)
condition|)
comment|/* make sure we have fp with something */
goto|goto
name|say_undef
goto|;
else|else
block|{
ifdef|#
directive|ifdef
name|TAINT
name|tainted
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|str_set
argument_list|(
name|str
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
operator|*
name|str
operator|->
name|str_ptr
operator|=
name|getc
argument_list|(
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|ifp
argument_list|)
expr_stmt|;
comment|/* should never be EOF */
block|}
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_TELL
case|:
if|if
condition|(
name|maxarg
operator|<=
literal|0
condition|)
name|stab
operator|=
name|last_in_stab
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|value
operator|=
operator|(
name|double
operator|)
name|do_tell
argument_list|(
name|stab
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|do_tell
argument_list|(
name|stab
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|donumset
goto|;
case|case
name|O_RECV
case|:
case|case
name|O_READ
case|:
case|case
name|O_SYSREAD
case|:
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|anum
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|maxarg
operator|=
name|sp
operator|-
name|arglast
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|maxarg
operator|>
literal|4
condition|)
name|warn
argument_list|(
literal|"Too many args on read"
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxarg
operator|==
literal|4
condition|)
name|maxarg
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
else|else
name|maxarg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|||
operator|!
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|ifp
condition|)
goto|goto
name|say_undef
goto|;
ifdef|#
directive|ifdef
name|HAS_SOCKET
if|if
condition|(
name|optype
operator|==
name|O_RECV
condition|)
block|{
name|argtype
operator|=
sizeof|sizeof
name|buf
expr_stmt|;
name|STR_GROW
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|,
name|anum
operator|+
literal|1
argument_list|)
operator|,
operator|(
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
operator|)
expr_stmt|;
comment|/* sneaky */
name|anum
operator|=
name|recvfrom
argument_list|(
name|fileno
argument_list|(
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|ifp
argument_list|)
argument_list|,
name|tmps
argument_list|,
name|anum
argument_list|,
name|maxarg
argument_list|,
name|buf
argument_list|,
operator|&
name|argtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|anum
operator|>=
literal|0
condition|)
block|{
name|st
index|[
literal|2
index|]
operator|->
name|str_cur
operator|=
name|anum
expr_stmt|;
name|st
index|[
literal|2
index|]
operator|->
name|str_ptr
index|[
name|anum
index|]
operator|=
literal|'\0'
expr_stmt|;
name|str_nset
argument_list|(
name|str
argument_list|,
name|buf
argument_list|,
name|argtype
argument_list|)
expr_stmt|;
block|}
else|else
name|str_sset
argument_list|(
name|str
argument_list|,
operator|&
name|str_undef
argument_list|)
expr_stmt|;
break|break;
block|}
else|#
directive|else
if|if
condition|(
name|optype
operator|==
name|O_RECV
condition|)
goto|goto
name|badsock
goto|;
endif|#
directive|endif
name|STR_GROW
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|,
name|anum
operator|+
name|maxarg
operator|+
literal|1
argument_list|)
operator|,
operator|(
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
operator|)
expr_stmt|;
comment|/* sneaky */
if|if
condition|(
name|optype
operator|==
name|O_SYSREAD
condition|)
block|{
name|anum
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|ifp
argument_list|)
argument_list|,
name|tmps
operator|+
name|maxarg
argument_list|,
name|anum
argument_list|)
expr_stmt|;
block|}
elseif|else
ifdef|#
directive|ifdef
name|HAS_SOCKET
if|if
condition|(
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|type
operator|==
literal|'s'
condition|)
block|{
name|argtype
operator|=
sizeof|sizeof
name|buf
expr_stmt|;
name|anum
operator|=
name|recvfrom
argument_list|(
name|fileno
argument_list|(
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|ifp
argument_list|)
argument_list|,
name|tmps
operator|+
name|maxarg
argument_list|,
name|anum
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
operator|&
name|argtype
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|anum
operator|=
name|fread
argument_list|(
name|tmps
operator|+
name|maxarg
argument_list|,
literal|1
argument_list|,
name|anum
argument_list|,
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|anum
operator|<
literal|0
condition|)
goto|goto
name|say_undef
goto|;
name|st
index|[
literal|2
index|]
operator|->
name|str_cur
operator|=
name|anum
operator|+
name|maxarg
expr_stmt|;
name|st
index|[
literal|2
index|]
operator|->
name|str_ptr
index|[
name|anum
operator|+
name|maxarg
index|]
operator|=
literal|'\0'
expr_stmt|;
name|value
operator|=
operator|(
name|double
operator|)
name|anum
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_SYSWRITE
case|:
case|case
name|O_SEND
case|:
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|anum
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|stio
operator|=
name|stab_io
argument_list|(
name|stab
argument_list|)
expr_stmt|;
name|maxarg
operator|=
name|sp
operator|-
name|arglast
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|stio
operator|||
operator|!
name|stio
operator|->
name|ifp
condition|)
block|{
name|anum
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dowarn
condition|)
block|{
if|if
condition|(
name|optype
operator|==
name|O_SYSWRITE
condition|)
name|warn
argument_list|(
literal|"Syswrite on closed filehandle"
argument_list|)
expr_stmt|;
else|else
name|warn
argument_list|(
literal|"Send on closed socket"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|optype
operator|==
name|O_SYSWRITE
condition|)
block|{
if|if
condition|(
name|maxarg
operator|>
literal|4
condition|)
name|warn
argument_list|(
literal|"Too many args on syswrite"
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxarg
operator|==
literal|4
condition|)
name|optype
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
else|else
name|optype
operator|=
literal|0
expr_stmt|;
name|anum
operator|=
name|write
argument_list|(
name|fileno
argument_list|(
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|ifp
argument_list|)
argument_list|,
name|tmps
operator|+
name|optype
argument_list|,
name|anum
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAS_SOCKET
elseif|else
if|if
condition|(
name|maxarg
operator|>=
literal|4
condition|)
block|{
if|if
condition|(
name|maxarg
operator|>
literal|4
condition|)
name|warn
argument_list|(
literal|"Too many args on send"
argument_list|)
expr_stmt|;
name|tmps2
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|anum
operator|=
name|sendto
argument_list|(
name|fileno
argument_list|(
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|ifp
argument_list|)
argument_list|,
name|tmps
argument_list|,
name|st
index|[
literal|2
index|]
operator|->
name|str_cur
argument_list|,
name|anum
argument_list|,
name|tmps2
argument_list|,
name|st
index|[
literal|4
index|]
operator|->
name|str_cur
argument_list|)
expr_stmt|;
block|}
else|else
name|anum
operator|=
name|send
argument_list|(
name|fileno
argument_list|(
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|ifp
argument_list|)
argument_list|,
name|tmps
argument_list|,
name|st
index|[
literal|2
index|]
operator|->
name|str_cur
argument_list|,
name|anum
argument_list|)
expr_stmt|;
else|#
directive|else
else|else
goto|goto
name|badsock
goto|;
endif|#
directive|endif
if|if
condition|(
name|anum
operator|<
literal|0
condition|)
goto|goto
name|say_undef
goto|;
name|value
operator|=
operator|(
name|double
operator|)
name|anum
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_SEEK
case|:
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
name|do_seek
argument_list|(
name|stab
argument_list|,
operator|(
name|long
operator|)
name|value
argument_list|,
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|3
index|]
argument_list|)
argument_list|)
condition|?
name|Yes
else|:
name|No
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_RETURN
case|:
name|tmps
operator|=
literal|"_SUB_"
expr_stmt|;
comment|/* just fake up a "last _SUB_" */
name|optype
operator|=
name|O_LAST
expr_stmt|;
if|if
condition|(
name|curcsv
operator|&&
name|curcsv
operator|->
name|wantarray
operator|==
name|G_ARRAY
condition|)
block|{
name|lastretstr
operator|=
name|Nullstr
expr_stmt|;
name|lastspbase
operator|=
name|arglast
index|[
literal|1
index|]
expr_stmt|;
name|lastsize
operator|=
name|arglast
index|[
literal|2
index|]
operator|-
name|arglast
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
name|lastretstr
operator|=
name|str_mortal
argument_list|(
name|st
index|[
name|arglast
index|[
literal|2
index|]
operator|-
name|arglast
index|[
literal|0
index|]
index|]
argument_list|)
expr_stmt|;
goto|goto
name|dopop
goto|;
case|case
name|O_REDO
case|:
case|case
name|O_NEXT
case|:
case|case
name|O_LAST
case|:
name|tmps
operator|=
name|Nullch
expr_stmt|;
if|if
condition|(
name|maxarg
operator|>
literal|0
condition|)
block|{
name|tmps
operator|=
name|str_get
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
argument_list|)
expr_stmt|;
name|dopop
label|:
while|while
condition|(
name|loop_ptr
operator|>=
literal|0
operator|&&
operator|(
operator|!
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_label
operator|||
name|strNE
argument_list|(
name|tmps
argument_list|,
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_label
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|4
condition|)
block|{
name|deb
argument_list|(
literal|"(Skipping label #%d %s)\n"
argument_list|,
name|loop_ptr
argument_list|,
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_label
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|loop_ptr
operator|--
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|4
condition|)
block|{
name|deb
argument_list|(
literal|"(Found label #%d %s)\n"
argument_list|,
name|loop_ptr
argument_list|,
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_label
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|loop_ptr
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|tmps
operator|&&
name|strEQ
argument_list|(
name|tmps
argument_list|,
literal|"_SUB_"
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"Can't return outside a subroutine"
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"Bad label: %s"
argument_list|,
name|maxarg
operator|>
literal|0
condition|?
name|tmps
else|:
literal|"<null>"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lastretstr
operator|&&
name|optype
operator|==
name|O_LAST
operator|&&
name|lastsize
condition|)
block|{
name|st
operator|-=
name|arglast
index|[
literal|0
index|]
expr_stmt|;
name|st
operator|+=
name|lastspbase
operator|+
literal|1
expr_stmt|;
name|optype
operator|=
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_sp
operator|-
name|lastspbase
expr_stmt|;
comment|/* negative */
if|if
condition|(
name|optype
condition|)
block|{
for|for
control|(
name|anum
operator|=
name|lastsize
init|;
name|anum
operator|>
literal|0
condition|;
name|anum
operator|--
operator|,
name|st
operator|++
control|)
name|st
index|[
name|optype
index|]
operator|=
name|str_mortal
argument_list|(
name|st
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|longjmp
argument_list|(
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_env
argument_list|,
name|O_LAST
argument_list|)
expr_stmt|;
block|}
name|longjmp
argument_list|(
name|loop_stack
index|[
name|loop_ptr
index|]
operator|.
name|loop_env
argument_list|,
name|optype
argument_list|)
expr_stmt|;
case|case
name|O_DUMP
case|:
case|case
name|O_GOTO
case|:
comment|/* shudder */
name|goto_targ
operator|=
name|str_get
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|goto_targ
condition|)
name|goto_targ
operator|=
name|Nullch
expr_stmt|;
comment|/* just restart from top */
if|if
condition|(
name|optype
operator|==
name|O_DUMP
condition|)
block|{
name|do_undump
operator|=
literal|1
expr_stmt|;
name|my_unexec
argument_list|()
expr_stmt|;
block|}
name|longjmp
argument_list|(
name|top_env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
case|case
name|O_INDEX
case|:
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxarg
operator|<
literal|3
condition|)
name|anum
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|anum
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|3
index|]
argument_list|)
operator|-
name|arybase
expr_stmt|;
if|if
condition|(
name|anum
operator|<
literal|0
condition|)
name|anum
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|anum
operator|>
name|st
index|[
literal|1
index|]
operator|->
name|str_cur
condition|)
name|anum
operator|=
name|st
index|[
literal|1
index|]
operator|->
name|str_cur
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|lint
if|if
condition|(
operator|!
operator|(
name|tmps2
operator|=
name|fbminstr
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tmps
operator|+
name|anum
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|tmps
operator|+
name|st
index|[
literal|1
index|]
operator|->
name|str_cur
argument_list|,
name|st
index|[
literal|2
index|]
argument_list|)
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|tmps2
operator|=
name|fbminstr
argument_list|(
name|Null
argument_list|(
argument|unsigned char*
argument_list|)
argument_list|,
name|Null
argument_list|(
argument|unsigned char*
argument_list|)
argument_list|,
name|Nullstr
argument_list|)
condition|)
endif|#
directive|endif
name|value
operator|=
call|(
name|double
call|)
argument_list|(
operator|-
literal|1
operator|+
name|arybase
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|tmps2
operator|-
name|tmps
operator|+
name|arybase
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_RINDEX
case|:
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|tmps2
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxarg
operator|<
literal|3
condition|)
name|anum
operator|=
name|st
index|[
literal|1
index|]
operator|->
name|str_cur
expr_stmt|;
else|else
block|{
name|anum
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|3
index|]
argument_list|)
operator|-
name|arybase
operator|+
name|st
index|[
literal|2
index|]
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
name|anum
operator|<
literal|0
condition|)
name|anum
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|anum
operator|>
name|st
index|[
literal|1
index|]
operator|->
name|str_cur
condition|)
name|anum
operator|=
name|st
index|[
literal|1
index|]
operator|->
name|str_cur
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|lint
if|if
condition|(
operator|!
operator|(
name|tmps2
operator|=
name|rninstr
argument_list|(
name|tmps
argument_list|,
name|tmps
operator|+
name|anum
argument_list|,
name|tmps2
argument_list|,
name|tmps2
operator|+
name|st
index|[
literal|2
index|]
operator|->
name|str_cur
argument_list|)
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|tmps2
operator|=
name|rninstr
argument_list|(
name|Nullch
argument_list|,
name|Nullch
argument_list|,
name|Nullch
argument_list|,
name|Nullch
argument_list|)
condition|)
endif|#
directive|endif
name|value
operator|=
call|(
name|double
call|)
argument_list|(
operator|-
literal|1
operator|+
name|arybase
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|tmps2
operator|-
name|tmps
operator|+
name|arybase
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_TIME
case|:
ifndef|#
directive|ifndef
name|lint
name|value
operator|=
operator|(
name|double
operator|)
name|time
argument_list|(
name|Null
argument_list|(
name|long
operator|*
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|donumset
goto|;
case|case
name|O_TMS
case|:
name|sp
operator|=
name|do_tms
argument_list|(
name|str
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_LOCALTIME
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|when
argument_list|)
expr_stmt|;
else|else
name|when
operator|=
operator|(
name|time_t
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sp
operator|=
name|do_time
argument_list|(
name|str
argument_list|,
name|localtime
argument_list|(
operator|&
name|when
argument_list|)
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_GMTIME
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|when
argument_list|)
expr_stmt|;
else|else
name|when
operator|=
operator|(
name|time_t
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sp
operator|=
name|do_time
argument_list|(
name|str
argument_list|,
name|gmtime
argument_list|(
operator|&
name|when
argument_list|)
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_TRUNCATE
case|:
name|sp
operator|=
name|do_truncate
argument_list|(
name|str
argument_list|,
name|arg
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_LSTAT
case|:
case|case
name|O_STAT
case|:
name|sp
operator|=
name|do_stat
argument_list|(
name|str
argument_list|,
name|arg
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_CRYPT
case|:
ifdef|#
directive|ifdef
name|HAS_CRYPT
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FCRYPT
name|str_set
argument_list|(
name|str
argument_list|,
name|fcrypt
argument_list|(
name|tmps
argument_list|,
name|str_get
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|str_set
argument_list|(
name|str
argument_list|,
name|crypt
argument_list|(
name|tmps
argument_list|,
name|str_get
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|fatal
argument_list|(
literal|"The crypt() function is unimplemented due to excessive paranoia."
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|O_ATAN2
case|:
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|value
operator|=
name|atan2
argument_list|(
name|value
argument_list|,
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_SIN
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
name|value
operator|=
name|str_gnum
argument_list|(
name|stab_val
argument_list|(
name|defstab
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|value
operator|=
name|sin
argument_list|(
name|value
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_COS
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
name|value
operator|=
name|str_gnum
argument_list|(
name|stab_val
argument_list|(
name|defstab
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|value
operator|=
name|cos
argument_list|(
name|value
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_RAND
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
name|value
operator|=
literal|1.0
expr_stmt|;
else|else
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0.0
condition|)
name|value
operator|=
literal|1.0
expr_stmt|;
if|#
directive|if
name|RANDBITS
operator|==
literal|31
name|value
operator|=
name|rand
argument_list|()
operator|*
name|value
operator|/
literal|2147483648.0
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|RANDBITS
operator|==
literal|16
name|value
operator|=
name|rand
argument_list|()
operator|*
name|value
operator|/
literal|65536.0
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|RANDBITS
operator|==
literal|15
name|value
operator|=
name|rand
argument_list|()
operator|*
name|value
operator|/
literal|32768.0
expr_stmt|;
else|#
directive|else
name|value
operator|=
name|rand
argument_list|()
operator|*
name|value
operator|/
call|(
name|double
call|)
argument_list|(
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|)
operator|<<
name|RANDBITS
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
goto|goto
name|donumset
goto|;
case|case
name|O_SRAND
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|when
argument_list|)
expr_stmt|;
name|anum
operator|=
name|when
expr_stmt|;
block|}
else|else
name|anum
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|srand
argument_list|(
name|anum
argument_list|)
expr_stmt|;
goto|goto
name|say_yes
goto|;
case|case
name|O_EXP
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
name|value
operator|=
name|str_gnum
argument_list|(
name|stab_val
argument_list|(
name|defstab
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|value
operator|=
name|exp
argument_list|(
name|value
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_LOG
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
name|value
operator|=
name|str_gnum
argument_list|(
name|stab_val
argument_list|(
name|defstab
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|<=
literal|0.0
condition|)
name|fatal
argument_list|(
literal|"Can't take log of %g\n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|log
argument_list|(
name|value
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_SQRT
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
name|value
operator|=
name|str_gnum
argument_list|(
name|stab_val
argument_list|(
name|defstab
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|<
literal|0.0
condition|)
name|fatal
argument_list|(
literal|"Can't take sqrt of %g\n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|sqrt
argument_list|(
name|value
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_INT
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
name|value
operator|=
name|str_gnum
argument_list|(
name|stab_val
argument_list|(
name|defstab
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|>=
literal|0.0
condition|)
operator|(
name|void
operator|)
name|modf
argument_list|(
name|value
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|modf
argument_list|(
operator|-
name|value
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
operator|-
name|value
expr_stmt|;
block|}
goto|goto
name|donumset
goto|;
case|case
name|O_ORD
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
name|tmps
operator|=
name|str_get
argument_list|(
name|stab_val
argument_list|(
name|defstab
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|I286
name|value
operator|=
call|(
name|double
call|)
argument_list|(
operator|*
name|tmps
operator|&
literal|255
argument_list|)
expr_stmt|;
else|#
directive|else
name|anum
operator|=
operator|(
name|int
operator|)
operator|*
name|tmps
expr_stmt|;
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|anum
operator|&
literal|255
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|donumset
goto|;
case|case
name|O_ALARM
case|:
ifdef|#
directive|ifdef
name|HAS_ALARM
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
name|tmps
operator|=
name|str_get
argument_list|(
name|stab_val
argument_list|(
name|defstab
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmps
condition|)
name|tmps
operator|=
literal|"0"
expr_stmt|;
name|anum
operator|=
name|alarm
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|atoi
argument_list|(
name|tmps
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|anum
operator|<
literal|0
condition|)
goto|goto
name|say_undef
goto|;
name|value
operator|=
operator|(
name|double
operator|)
name|anum
expr_stmt|;
goto|goto
name|donumset
goto|;
else|#
directive|else
name|fatal
argument_list|(
literal|"Unsupported function alarm"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|O_SLEEP
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
name|tmps
operator|=
name|Nullch
expr_stmt|;
else|else
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|when
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmps
operator|||
operator|!
operator|*
name|tmps
condition|)
name|sleep
argument_list|(
operator|(
literal|32767
operator|<<
literal|16
operator|)
operator|+
literal|32767
argument_list|)
expr_stmt|;
else|else
name|sleep
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|atoi
argument_list|(
name|tmps
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|value
operator|=
operator|(
name|double
operator|)
name|when
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|when
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
operator|(
name|double
operator|)
name|when
operator|)
operator|-
name|value
expr_stmt|;
endif|#
directive|endif
goto|goto
name|donumset
goto|;
case|case
name|O_RANGE
case|:
name|sp
operator|=
name|do_range
argument_list|(
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_F_OR_R
case|:
if|if
condition|(
name|gimme
operator|==
name|G_ARRAY
condition|)
block|{
comment|/* it's a range */
comment|/* can we optimize to constant array? */
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_SINGLE
operator|&&
operator|(
name|arg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_SINGLE
condition|)
block|{
name|st
index|[
literal|2
index|]
operator|=
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
expr_stmt|;
name|sp
operator|=
name|do_range
argument_list|(
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
name|st
operator|=
name|stack
operator|->
name|ary_array
expr_stmt|;
name|maxarg
operator|=
name|sp
operator|-
name|arglast
index|[
literal|0
index|]
expr_stmt|;
name|str_free
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
argument_list|)
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
operator|=
name|Nullstr
expr_stmt|;
name|str_free
argument_list|(
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
argument_list|)
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
operator|=
name|Nullstr
expr_stmt|;
name|arg
operator|->
name|arg_type
operator|=
name|O_ARRAY
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
name|A_STAB
operator||
name|A_DONT
expr_stmt|;
name|arg
operator|->
name|arg_len
operator|=
literal|1
expr_stmt|;
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
operator|=
name|aadd
argument_list|(
name|genstab
argument_list|()
argument_list|)
expr_stmt|;
name|ary
operator|=
name|stab_array
argument_list|(
name|stab
argument_list|)
expr_stmt|;
name|afill
argument_list|(
name|ary
argument_list|,
name|maxarg
operator|-
literal|1
argument_list|)
expr_stmt|;
name|anum
operator|=
name|maxarg
expr_stmt|;
name|st
operator|+=
name|arglast
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|maxarg
operator|--
operator|>
literal|0
condition|)
name|ary
operator|->
name|ary_array
index|[
name|maxarg
index|]
operator|=
name|str_smake
argument_list|(
name|st
index|[
name|maxarg
index|]
argument_list|)
expr_stmt|;
name|st
operator|-=
name|arglast
index|[
literal|0
index|]
operator|+
literal|1
expr_stmt|;
goto|goto
name|array_return
goto|;
block|}
name|arg
operator|->
name|arg_type
operator|=
name|optype
operator|=
name|O_RANGE
expr_stmt|;
name|maxarg
operator|=
name|arg
operator|->
name|arg_len
operator|=
literal|2
expr_stmt|;
name|anum
operator|=
literal|2
expr_stmt|;
name|arg
index|[
name|anum
index|]
operator|.
name|arg_flags
operator|&=
operator|~
name|AF_ARYOK
expr_stmt|;
name|argflags
operator|=
name|arg
index|[
name|anum
index|]
operator|.
name|arg_flags
expr_stmt|;
name|argtype
operator|=
name|arg
index|[
name|anum
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
expr_stmt|;
name|arg
index|[
name|anum
index|]
operator|.
name|arg_type
operator|=
name|argtype
expr_stmt|;
name|argptr
operator|=
name|arg
index|[
name|anum
index|]
operator|.
name|arg_ptr
expr_stmt|;
name|sp
operator|=
name|arglast
index|[
literal|0
index|]
expr_stmt|;
name|st
operator|-=
name|sp
expr_stmt|;
name|sp
operator|++
expr_stmt|;
goto|goto
name|re_eval
goto|;
block|}
name|arg
operator|->
name|arg_type
operator|=
name|O_FLIP
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|O_FLIP
case|:
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_SINGLE
condition|?
name|last_in_stab
operator|&&
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
operator|==
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|->
name|lines
else|:
name|str_true
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|arg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|&=
operator|~
name|A_DONT
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator||=
name|A_DONT
expr_stmt|;
name|arg
operator|->
name|arg_type
operator|=
name|optype
operator|=
name|O_FLOP
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|arg_flags
operator|&
name|AF_COMMON
condition|)
block|{
name|str_numset
argument_list|(
name|str
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|anum
operator|=
literal|2
expr_stmt|;
name|argflags
operator|=
name|arg
index|[
literal|2
index|]
operator|.
name|arg_flags
expr_stmt|;
name|argtype
operator|=
name|arg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
expr_stmt|;
name|argptr
operator|=
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
expr_stmt|;
name|sp
operator|=
name|arglast
index|[
literal|0
index|]
expr_stmt|;
name|st
operator|-=
name|sp
operator|++
expr_stmt|;
goto|goto
name|re_eval
goto|;
block|}
else|else
block|{
name|str_numset
argument_list|(
name|str
argument_list|,
literal|1.0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|str_set
argument_list|(
name|str
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_FLOP
case|:
name|str_inc
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_SINGLE
condition|?
name|last_in_stab
operator|&&
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
operator|==
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|->
name|lines
else|:
name|str_true
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|arg
operator|->
name|arg_type
operator|=
name|O_FLIP
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&=
operator|~
name|A_DONT
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_type
operator||=
name|A_DONT
expr_stmt|;
name|str_cat
argument_list|(
name|str
argument_list|,
literal|"E0"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|O_FORK
case|:
ifdef|#
directive|ifdef
name|HAS_FORK
name|anum
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|anum
operator|<
literal|0
condition|)
goto|goto
name|say_undef
goto|;
if|if
condition|(
operator|!
name|anum
condition|)
block|{
comment|/*SUPPRESS 560*/
if|if
condition|(
name|tmpstab
operator|=
name|stabent
argument_list|(
literal|"$"
argument_list|,
name|allstabs
argument_list|)
condition|)
name|str_numset
argument_list|(
name|STAB_STR
argument_list|(
name|tmpstab
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|hclear
argument_list|(
name|pidstatus
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* no kids, so don't wait for 'em */
block|}
name|value
operator|=
operator|(
name|double
operator|)
name|anum
expr_stmt|;
goto|goto
name|donumset
goto|;
else|#
directive|else
name|fatal
argument_list|(
literal|"Unsupported function fork"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|O_WAIT
case|:
ifdef|#
directive|ifdef
name|HAS_WAIT
ifndef|#
directive|ifndef
name|lint
name|anum
operator|=
name|wait
argument_list|(
operator|&
name|argflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|anum
operator|>
literal|0
condition|)
name|pidgone
argument_list|(
name|anum
argument_list|,
name|argflags
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|double
operator|)
name|anum
expr_stmt|;
endif|#
directive|endif
name|statusvalue
operator|=
operator|(
name|unsigned
name|short
operator|)
name|argflags
expr_stmt|;
goto|goto
name|donumset
goto|;
else|#
directive|else
name|fatal
argument_list|(
literal|"Unsupported function wait"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|O_WAITPID
case|:
ifdef|#
directive|ifdef
name|HAS_WAIT
ifndef|#
directive|ifndef
name|lint
name|anum
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|optype
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|anum
operator|=
name|wait4pid
argument_list|(
name|anum
argument_list|,
operator|&
name|argflags
argument_list|,
name|optype
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|double
operator|)
name|anum
expr_stmt|;
endif|#
directive|endif
name|statusvalue
operator|=
operator|(
name|unsigned
name|short
operator|)
name|argflags
expr_stmt|;
goto|goto
name|donumset
goto|;
else|#
directive|else
name|fatal
argument_list|(
literal|"Unsupported function wait"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|O_SYSTEM
case|:
ifdef|#
directive|ifdef
name|HAS_FORK
ifdef|#
directive|ifdef
name|TAINT
if|if
condition|(
name|arglast
index|[
literal|2
index|]
operator|-
name|arglast
index|[
literal|1
index|]
operator|==
literal|1
condition|)
block|{
name|taintenv
argument_list|()
expr_stmt|;
name|tainted
operator||=
name|st
index|[
literal|2
index|]
operator|->
name|str_tainted
expr_stmt|;
name|taintproper
argument_list|(
literal|"Insecure dependency in system"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
operator|(
name|anum
operator|=
name|vfork
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EAGAIN
condition|)
block|{
name|value
operator|=
operator|-
literal|1.0
expr_stmt|;
goto|goto
name|donumset
goto|;
block|}
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|anum
operator|>
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|lint
name|ihand
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|qhand
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|argtype
operator|=
name|wait4pid
argument_list|(
name|anum
argument_list|,
operator|&
name|argflags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|ihand
operator|=
name|qhand
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|ihand
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|qhand
argument_list|)
expr_stmt|;
name|statusvalue
operator|=
operator|(
name|unsigned
name|short
operator|)
name|argflags
expr_stmt|;
if|if
condition|(
name|argtype
operator|<
literal|0
condition|)
name|value
operator|=
operator|-
literal|1.0
expr_stmt|;
else|else
block|{
name|value
operator|=
call|(
name|double
call|)
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|argflags
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
block|}
name|do_execfree
argument_list|()
expr_stmt|;
comment|/* free any memory child malloced on vfork */
goto|goto
name|donumset
goto|;
block|}
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_STAB
condition|)
name|value
operator|=
operator|(
name|double
operator|)
name|do_aexec
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arglast
index|[
literal|2
index|]
operator|-
name|arglast
index|[
literal|1
index|]
operator|!=
literal|1
condition|)
name|value
operator|=
operator|(
name|double
operator|)
name|do_aexec
argument_list|(
name|Nullstr
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
else|else
block|{
name|value
operator|=
operator|(
name|double
operator|)
name|do_exec
argument_list|(
name|str_get
argument_list|(
name|str_mortal
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! FORK */
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_STAB
condition|)
name|value
operator|=
operator|(
name|double
operator|)
name|do_aspawn
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arglast
index|[
literal|2
index|]
operator|-
name|arglast
index|[
literal|1
index|]
operator|!=
literal|1
condition|)
name|value
operator|=
operator|(
name|double
operator|)
name|do_aspawn
argument_list|(
name|Nullstr
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
else|else
block|{
name|value
operator|=
operator|(
name|double
operator|)
name|do_spawn
argument_list|(
name|str_get
argument_list|(
name|str_mortal
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
goto|goto
name|donumset
goto|;
endif|#
directive|endif
comment|/* FORK */
case|case
name|O_EXEC_OP
case|:
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_STAB
condition|)
name|value
operator|=
operator|(
name|double
operator|)
name|do_aexec
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arglast
index|[
literal|2
index|]
operator|-
name|arglast
index|[
literal|1
index|]
operator|!=
literal|1
condition|)
name|value
operator|=
operator|(
name|double
operator|)
name|do_aexec
argument_list|(
name|Nullstr
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|TAINT
name|taintenv
argument_list|()
expr_stmt|;
name|tainted
operator||=
name|st
index|[
literal|2
index|]
operator|->
name|str_tainted
expr_stmt|;
name|taintproper
argument_list|(
literal|"Insecure dependency in exec"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|value
operator|=
operator|(
name|double
operator|)
name|do_exec
argument_list|(
name|str_get
argument_list|(
name|str_mortal
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
goto|goto
name|donumset
goto|;
case|case
name|O_HEX
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
name|tmps
operator|=
name|str_get
argument_list|(
name|stab_val
argument_list|(
name|defstab
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|double
operator|)
name|scanhex
argument_list|(
name|tmps
argument_list|,
literal|99
argument_list|,
operator|&
name|argtype
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_OCT
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
name|tmps
operator|=
name|str_get
argument_list|(
name|stab_val
argument_list|(
name|defstab
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|tmps
operator|&&
operator|(
name|isSPACE
argument_list|(
operator|*
name|tmps
argument_list|)
operator|||
operator|*
name|tmps
operator|==
literal|'0'
operator|)
condition|)
name|tmps
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|tmps
operator|==
literal|'x'
condition|)
name|value
operator|=
operator|(
name|double
operator|)
name|scanhex
argument_list|(
operator|++
name|tmps
argument_list|,
literal|99
argument_list|,
operator|&
name|argtype
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
operator|(
name|double
operator|)
name|scanoct
argument_list|(
name|tmps
argument_list|,
literal|99
argument_list|,
operator|&
name|argtype
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
comment|/* These common exits are hidden here in the middle of the switches for the    benefit of those machines with limited branch addressing.  Sigh.  */
name|array_return
label|:
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
block|{
name|dlevel
operator|--
expr_stmt|;
if|if
condition|(
name|debug
operator|&
literal|8
condition|)
block|{
name|anum
operator|=
name|sp
operator|-
name|arglast
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|anum
condition|)
block|{
case|case
literal|0
case|:
name|deb
argument_list|(
literal|"%s RETURNS ()\n"
argument_list|,
name|opname
index|[
name|optype
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|deb
argument_list|(
literal|"%s RETURNS (\"%s\")\n"
argument_list|,
name|opname
index|[
name|optype
index|]
argument_list|,
name|st
index|[
literal|1
index|]
condition|?
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
default|default:
name|tmps
operator|=
name|st
index|[
literal|1
index|]
condition|?
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
else|:
literal|""
expr_stmt|;
name|deb
argument_list|(
literal|"%s RETURNS %d ARGS (\"%s\",%s\"%s\")\n"
argument_list|,
name|opname
index|[
name|optype
index|]
argument_list|,
name|anum
argument_list|,
name|tmps
argument_list|,
name|anum
operator|==
literal|2
condition|?
literal|""
else|:
literal|"...,"
argument_list|,
name|st
index|[
name|anum
index|]
condition|?
name|str_get
argument_list|(
name|st
index|[
name|anum
index|]
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
return|return
name|sp
return|;
name|say_yes
label|:
name|str
operator|=
operator|&
name|str_yes
expr_stmt|;
goto|goto
name|normal_return
goto|;
name|say_no
label|:
name|str
operator|=
operator|&
name|str_no
expr_stmt|;
goto|goto
name|normal_return
goto|;
name|say_undef
label|:
name|str
operator|=
operator|&
name|str_undef
expr_stmt|;
goto|goto
name|normal_return
goto|;
name|say_zero
label|:
name|value
operator|=
literal|0.0
expr_stmt|;
comment|/* FALL THROUGH */
name|donumset
label|:
name|str_numset
argument_list|(
name|str
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|st
index|[
literal|1
index|]
operator|=
name|str
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
block|{
name|dlevel
operator|--
expr_stmt|;
if|if
condition|(
name|debug
operator|&
literal|8
condition|)
name|deb
argument_list|(
literal|"%s RETURNS \"%f\"\n"
argument_list|,
name|opname
index|[
name|optype
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|arglast
index|[
literal|0
index|]
operator|+
literal|1
return|;
ifdef|#
directive|ifdef
name|SMALLSWITCHES
block|}
else|else
switch|switch
condition|(
name|optype
condition|)
block|{
endif|#
directive|endif
case|case
name|O_CHOWN
case|:
ifdef|#
directive|ifdef
name|HAS_CHOWN
name|value
operator|=
operator|(
name|double
operator|)
name|apply
argument_list|(
name|optype
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
else|#
directive|else
name|fatal
argument_list|(
literal|"Unsupported function chown"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|O_KILL
case|:
ifdef|#
directive|ifdef
name|HAS_KILL
name|value
operator|=
operator|(
name|double
operator|)
name|apply
argument_list|(
name|optype
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
else|#
directive|else
name|fatal
argument_list|(
literal|"Unsupported function kill"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|O_UNLINK
case|:
case|case
name|O_CHMOD
case|:
case|case
name|O_UTIME
case|:
name|value
operator|=
operator|(
name|double
operator|)
name|apply
argument_list|(
name|optype
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_UMASK
case|:
ifdef|#
directive|ifdef
name|HAS_UMASK
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
block|{
name|anum
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|anum
argument_list|)
expr_stmt|;
block|}
else|else
name|anum
operator|=
name|umask
argument_list|(
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|double
operator|)
name|anum
expr_stmt|;
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in umask"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|donumset
goto|;
else|#
directive|else
name|fatal
argument_list|(
literal|"Unsupported function umask"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAS_MSG
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SEM
argument_list|)
operator|||
name|defined
argument_list|(
name|HAS_SHM
argument_list|)
case|case
name|O_MSGGET
case|:
case|case
name|O_SHMGET
case|:
case|case
name|O_SEMGET
case|:
if|if
condition|(
operator|(
name|anum
operator|=
name|do_ipcget
argument_list|(
name|optype
argument_list|,
name|arglast
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|say_undef
goto|;
name|value
operator|=
operator|(
name|double
operator|)
name|anum
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_MSGCTL
case|:
case|case
name|O_SHMCTL
case|:
case|case
name|O_SEMCTL
case|:
name|anum
operator|=
name|do_ipcctl
argument_list|(
name|optype
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
if|if
condition|(
name|anum
operator|==
operator|-
literal|1
condition|)
goto|goto
name|say_undef
goto|;
if|if
condition|(
name|anum
operator|!=
literal|0
condition|)
block|{
name|value
operator|=
operator|(
name|double
operator|)
name|anum
expr_stmt|;
goto|goto
name|donumset
goto|;
block|}
name|str_set
argument_list|(
name|str
argument_list|,
literal|"0 but true"
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_MSGSND
case|:
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|do_msgsnd
argument_list|(
name|arglast
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_MSGRCV
case|:
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|do_msgrcv
argument_list|(
name|arglast
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_SEMOP
case|:
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|do_semop
argument_list|(
name|arglast
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_SHMREAD
case|:
case|case
name|O_SHMWRITE
case|:
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|do_shmio
argument_list|(
name|optype
argument_list|,
name|arglast
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
else|#
directive|else
comment|/* not SYSVIPC */
case|case
name|O_MSGGET
case|:
case|case
name|O_MSGCTL
case|:
case|case
name|O_MSGSND
case|:
case|case
name|O_MSGRCV
case|:
case|case
name|O_SEMGET
case|:
case|case
name|O_SEMCTL
case|:
case|case
name|O_SEMOP
case|:
case|case
name|O_SHMGET
case|:
case|case
name|O_SHMCTL
case|:
case|case
name|O_SHMREAD
case|:
case|case
name|O_SHMWRITE
case|:
name|fatal
argument_list|(
literal|"System V IPC is not implemented on this machine"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not SYSVIPC */
case|case
name|O_RENAME
case|:
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|tmps2
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in rename"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_RENAME
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|rename
argument_list|(
name|tmps
argument_list|,
name|tmps2
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|same_dirent
argument_list|(
name|tmps2
argument_list|,
name|tmps
argument_list|)
condition|)
comment|/* can always rename to same name */
name|anum
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|euid
operator|||
name|stat
argument_list|(
name|tmps2
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
operator|||
operator|!
name|S_ISDIR
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
operator|(
name|void
operator|)
name|UNLINK
argument_list|(
name|tmps2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|anum
operator|=
name|link
argument_list|(
name|tmps
argument_list|,
name|tmps2
argument_list|)
operator|)
condition|)
name|anum
operator|=
name|UNLINK
argument_list|(
name|tmps
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|anum
operator|>=
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|donumset
goto|;
case|case
name|O_LINK
case|:
ifdef|#
directive|ifdef
name|HAS_LINK
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|tmps2
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in link"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|link
argument_list|(
name|tmps
argument_list|,
name|tmps2
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
else|#
directive|else
name|fatal
argument_list|(
literal|"Unsupported function link"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|O_MKDIR
case|:
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|anum
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in mkdir"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_MKDIR
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|mkdir
argument_list|(
name|tmps
argument_list|,
name|anum
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
else|#
directive|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"mkdir "
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAS_MKDIR
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HAS_RMDIR
argument_list|)
name|one_liner
label|:
for|for
control|(
name|tmps2
operator|=
name|buf
operator|+
literal|6
init|;
operator|*
name|tmps
condition|;
control|)
block|{
operator|*
name|tmps2
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|tmps2
operator|++
operator|=
operator|*
name|tmps
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmps2
argument_list|,
literal|" 2>&1"
argument_list|)
expr_stmt|;
name|rsfp
operator|=
name|mypopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsfp
condition|)
block|{
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
name|tmps2
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|rsfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mypclose
argument_list|(
name|rsfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmps2
operator|!=
name|Nullch
condition|)
block|{
for|for
control|(
name|errno
operator|=
literal|1
init|;
name|errno
operator|<
name|sys_nerr
condition|;
name|errno
operator|++
control|)
block|{
if|if
condition|(
name|instr
argument_list|(
name|buf
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
condition|)
comment|/* you don't see this */
goto|goto
name|say_zero
goto|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|EACCES
define|#
directive|define
name|EACCES
value|EPERM
endif|#
directive|endif
if|if
condition|(
name|instr
argument_list|(
name|buf
argument_list|,
literal|"cannot make"
argument_list|)
condition|)
name|errno
operator|=
name|EEXIST
expr_stmt|;
elseif|else
if|if
condition|(
name|instr
argument_list|(
name|buf
argument_list|,
literal|"existing file"
argument_list|)
condition|)
name|errno
operator|=
name|EEXIST
expr_stmt|;
elseif|else
if|if
condition|(
name|instr
argument_list|(
name|buf
argument_list|,
literal|"ile exists"
argument_list|)
condition|)
name|errno
operator|=
name|EEXIST
expr_stmt|;
elseif|else
if|if
condition|(
name|instr
argument_list|(
name|buf
argument_list|,
literal|"non-exist"
argument_list|)
condition|)
name|errno
operator|=
name|ENOENT
expr_stmt|;
elseif|else
if|if
condition|(
name|instr
argument_list|(
name|buf
argument_list|,
literal|"does not exist"
argument_list|)
condition|)
name|errno
operator|=
name|ENOENT
expr_stmt|;
elseif|else
if|if
condition|(
name|instr
argument_list|(
name|buf
argument_list|,
literal|"not empty"
argument_list|)
condition|)
name|errno
operator|=
name|EBUSY
expr_stmt|;
elseif|else
if|if
condition|(
name|instr
argument_list|(
name|buf
argument_list|,
literal|"cannot access"
argument_list|)
condition|)
name|errno
operator|=
name|EACCES
expr_stmt|;
else|else
name|errno
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|say_zero
goto|;
block|}
else|else
block|{
comment|/* some mkdirs return no failure indication */
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|anum
operator|=
operator|(
name|stat
argument_list|(
name|tmps
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|optype
operator|==
name|O_RMDIR
condition|)
name|anum
operator|=
operator|!
name|anum
expr_stmt|;
if|if
condition|(
name|anum
condition|)
name|errno
operator|=
literal|0
expr_stmt|;
else|else
name|errno
operator|=
name|EACCES
expr_stmt|;
comment|/* a guess */
name|value
operator|=
operator|(
name|double
operator|)
name|anum
expr_stmt|;
block|}
goto|goto
name|donumset
goto|;
block|}
else|else
goto|goto
name|say_zero
goto|;
endif|#
directive|endif
case|case
name|O_RMDIR
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
name|tmps
operator|=
name|str_get
argument_list|(
name|stab_val
argument_list|(
name|defstab
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in rmdir"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAS_RMDIR
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|rmdir
argument_list|(
name|tmps
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
else|#
directive|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"rmdir "
argument_list|)
expr_stmt|;
goto|goto
name|one_liner
goto|;
comment|/* see above in HAS_MKDIR */
endif|#
directive|endif
case|case
name|O_GETPPID
case|:
ifdef|#
directive|ifdef
name|HAS_GETPPID
name|value
operator|=
operator|(
name|double
operator|)
name|getppid
argument_list|()
expr_stmt|;
goto|goto
name|donumset
goto|;
else|#
directive|else
name|fatal
argument_list|(
literal|"Unsupported function getppid"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|O_GETPGRP
case|:
ifdef|#
directive|ifdef
name|HAS_GETPGRP
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
name|anum
operator|=
literal|0
expr_stmt|;
else|else
name|anum
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_POSIX_SOURCE
if|if
condition|(
name|anum
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"POSIX getpgrp can't take an argument"
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|double
operator|)
name|getpgrp
argument_list|()
expr_stmt|;
else|#
directive|else
name|value
operator|=
operator|(
name|double
operator|)
name|getpgrp
argument_list|(
name|anum
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|donumset
goto|;
else|#
directive|else
name|fatal
argument_list|(
literal|"The getpgrp() function is unimplemented on this machine"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|O_SETPGRP
case|:
ifdef|#
directive|ifdef
name|HAS_SETPGRP
name|argtype
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|anum
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in setpgrp"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|setpgrp
argument_list|(
name|argtype
argument_list|,
name|anum
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
else|#
directive|else
name|fatal
argument_list|(
literal|"The setpgrp() function is unimplemented on this machine"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|O_GETPRIORITY
case|:
ifdef|#
directive|ifdef
name|HAS_GETPRIORITY
name|argtype
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|anum
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|double
operator|)
name|getpriority
argument_list|(
name|argtype
argument_list|,
name|anum
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
else|#
directive|else
name|fatal
argument_list|(
literal|"The getpriority() function is unimplemented on this machine"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|O_SETPRIORITY
case|:
ifdef|#
directive|ifdef
name|HAS_SETPRIORITY
name|argtype
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|anum
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|optype
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in setpriority"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|setpriority
argument_list|(
name|argtype
argument_list|,
name|anum
argument_list|,
name|optype
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
else|#
directive|else
name|fatal
argument_list|(
literal|"The setpriority() function is unimplemented on this machine"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|O_CHROOT
case|:
ifdef|#
directive|ifdef
name|HAS_CHROOT
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
name|tmps
operator|=
name|str_get
argument_list|(
name|stab_val
argument_list|(
name|defstab
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in chroot"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|chroot
argument_list|(
name|tmps
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
else|#
directive|else
name|fatal
argument_list|(
literal|"Unsupported function chroot"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|O_FCNTL
case|:
case|case
name|O_IOCTL
case|:
if|if
condition|(
name|maxarg
operator|<=
literal|0
condition|)
name|stab
operator|=
name|last_in_stab
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|argtype
operator|=
name|U_I
argument_list|(
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in ioctl"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|anum
operator|=
name|do_ctl
argument_list|(
name|optype
argument_list|,
name|stab
argument_list|,
name|argtype
argument_list|,
name|st
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|anum
operator|==
operator|-
literal|1
condition|)
goto|goto
name|say_undef
goto|;
if|if
condition|(
name|anum
operator|!=
literal|0
condition|)
block|{
name|value
operator|=
operator|(
name|double
operator|)
name|anum
expr_stmt|;
goto|goto
name|donumset
goto|;
block|}
name|str_set
argument_list|(
name|str
argument_list|,
literal|"0 but true"
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_FLOCK
case|:
ifdef|#
directive|ifdef
name|HAS_FLOCK
if|if
condition|(
name|maxarg
operator|<=
literal|0
condition|)
name|stab
operator|=
name|last_in_stab
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|stab
operator|&&
name|stab_io
argument_list|(
name|stab
argument_list|)
condition|)
name|fp
operator|=
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|ifp
expr_stmt|;
else|else
name|fp
operator|=
name|Nullfp
expr_stmt|;
if|if
condition|(
name|fp
condition|)
block|{
name|argtype
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|flock
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|argtype
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|value
operator|=
literal|0
expr_stmt|;
goto|goto
name|donumset
goto|;
else|#
directive|else
name|fatal
argument_list|(
literal|"The flock() function is unimplemented on this machine"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|O_UNSHIFT
case|:
name|ary
operator|=
name|stab_array
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
expr_stmt|;
if|if
condition|(
name|arglast
index|[
literal|2
index|]
operator|-
name|arglast
index|[
literal|1
index|]
operator|!=
literal|1
condition|)
name|do_unshift
argument_list|(
name|ary
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
else|else
block|{
name|STR
modifier|*
name|tmpstr
init|=
name|Str_new
argument_list|(
literal|52
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* must copy the STR */
name|str_sset
argument_list|(
name|tmpstr
argument_list|,
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|aunshift
argument_list|(
name|ary
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|astore
argument_list|(
name|ary
argument_list|,
literal|0
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|ary
operator|->
name|ary_fill
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_TRY
case|:
name|sp
operator|=
name|do_try
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_cmd
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_EVALONCE
case|:
name|sp
operator|=
name|do_eval
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|,
name|O_EVAL
argument_list|,
name|curcmd
operator|->
name|c_stash
argument_list|,
name|TRUE
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
if|if
condition|(
name|eval_root
condition|)
block|{
name|str_free
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
argument_list|)
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_cmd
operator|=
name|eval_root
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|=
operator|(
name|A_CMD
operator||
name|A_DONT
operator|)
expr_stmt|;
name|arg
index|[
literal|0
index|]
operator|.
name|arg_type
operator|=
name|O_TRY
expr_stmt|;
block|}
goto|goto
name|array_return
goto|;
case|case
name|O_REQUIRE
case|:
case|case
name|O_DOFILE
case|:
case|case
name|O_EVAL
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
name|tmpstr
operator|=
name|stab_val
argument_list|(
name|defstab
argument_list|)
expr_stmt|;
else|else
name|tmpstr
operator|=
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|!=
name|A_NULL
condition|?
name|st
index|[
literal|1
index|]
else|:
name|stab_val
argument_list|(
name|defstab
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TAINT
name|tainted
operator||=
name|tmpstr
operator|->
name|str_tainted
expr_stmt|;
name|taintproper
argument_list|(
literal|"Insecure dependency in eval"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sp
operator|=
name|do_eval
argument_list|(
name|tmpstr
argument_list|,
name|optype
argument_list|,
name|curcmd
operator|->
name|c_stash
argument_list|,
name|FALSE
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_FTRREAD
case|:
name|argtype
operator|=
literal|0
expr_stmt|;
name|anum
operator|=
name|S_IRUSR
expr_stmt|;
goto|goto
name|check_perm
goto|;
case|case
name|O_FTRWRITE
case|:
name|argtype
operator|=
literal|0
expr_stmt|;
name|anum
operator|=
name|S_IWUSR
expr_stmt|;
goto|goto
name|check_perm
goto|;
case|case
name|O_FTREXEC
case|:
name|argtype
operator|=
literal|0
expr_stmt|;
name|anum
operator|=
name|S_IXUSR
expr_stmt|;
goto|goto
name|check_perm
goto|;
case|case
name|O_FTEREAD
case|:
name|argtype
operator|=
literal|1
expr_stmt|;
name|anum
operator|=
name|S_IRUSR
expr_stmt|;
goto|goto
name|check_perm
goto|;
case|case
name|O_FTEWRITE
case|:
name|argtype
operator|=
literal|1
expr_stmt|;
name|anum
operator|=
name|S_IWUSR
expr_stmt|;
goto|goto
name|check_perm
goto|;
case|case
name|O_FTEEXEC
case|:
name|argtype
operator|=
literal|1
expr_stmt|;
name|anum
operator|=
name|S_IXUSR
expr_stmt|;
name|check_perm
label|:
if|if
condition|(
name|mystat
argument_list|(
name|arg
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|say_undef
goto|;
if|if
condition|(
name|cando
argument_list|(
name|anum
argument_list|,
name|argtype
argument_list|,
operator|&
name|statcache
argument_list|)
condition|)
goto|goto
name|say_yes
goto|;
goto|goto
name|say_no
goto|;
case|case
name|O_FTIS
case|:
if|if
condition|(
name|mystat
argument_list|(
name|arg
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|say_undef
goto|;
goto|goto
name|say_yes
goto|;
case|case
name|O_FTEOWNED
case|:
case|case
name|O_FTROWNED
case|:
if|if
condition|(
name|mystat
argument_list|(
name|arg
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|say_undef
goto|;
if|if
condition|(
name|statcache
operator|.
name|st_uid
operator|==
operator|(
name|optype
operator|==
name|O_FTEOWNED
condition|?
name|euid
else|:
name|uid
operator|)
condition|)
goto|goto
name|say_yes
goto|;
goto|goto
name|say_no
goto|;
case|case
name|O_FTZERO
case|:
if|if
condition|(
name|mystat
argument_list|(
name|arg
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|say_undef
goto|;
if|if
condition|(
operator|!
name|statcache
operator|.
name|st_size
condition|)
goto|goto
name|say_yes
goto|;
goto|goto
name|say_no
goto|;
case|case
name|O_FTSIZE
case|:
if|if
condition|(
name|mystat
argument_list|(
name|arg
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|say_undef
goto|;
name|value
operator|=
operator|(
name|double
operator|)
name|statcache
operator|.
name|st_size
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_FTMTIME
case|:
if|if
condition|(
name|mystat
argument_list|(
name|arg
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|say_undef
goto|;
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|basetime
operator|-
name|statcache
operator|.
name|st_mtime
argument_list|)
operator|/
literal|86400.0
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_FTATIME
case|:
if|if
condition|(
name|mystat
argument_list|(
name|arg
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|say_undef
goto|;
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|basetime
operator|-
name|statcache
operator|.
name|st_atime
argument_list|)
operator|/
literal|86400.0
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_FTCTIME
case|:
if|if
condition|(
name|mystat
argument_list|(
name|arg
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|say_undef
goto|;
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|basetime
operator|-
name|statcache
operator|.
name|st_ctime
argument_list|)
operator|/
literal|86400.0
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_FTSOCK
case|:
if|if
condition|(
name|mystat
argument_list|(
name|arg
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|say_undef
goto|;
if|if
condition|(
name|S_ISSOCK
argument_list|(
name|statcache
operator|.
name|st_mode
argument_list|)
condition|)
goto|goto
name|say_yes
goto|;
goto|goto
name|say_no
goto|;
case|case
name|O_FTCHR
case|:
if|if
condition|(
name|mystat
argument_list|(
name|arg
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|say_undef
goto|;
if|if
condition|(
name|S_ISCHR
argument_list|(
name|statcache
operator|.
name|st_mode
argument_list|)
condition|)
goto|goto
name|say_yes
goto|;
goto|goto
name|say_no
goto|;
case|case
name|O_FTBLK
case|:
if|if
condition|(
name|mystat
argument_list|(
name|arg
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|say_undef
goto|;
if|if
condition|(
name|S_ISBLK
argument_list|(
name|statcache
operator|.
name|st_mode
argument_list|)
condition|)
goto|goto
name|say_yes
goto|;
goto|goto
name|say_no
goto|;
case|case
name|O_FTFILE
case|:
if|if
condition|(
name|mystat
argument_list|(
name|arg
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|say_undef
goto|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|statcache
operator|.
name|st_mode
argument_list|)
condition|)
goto|goto
name|say_yes
goto|;
goto|goto
name|say_no
goto|;
case|case
name|O_FTDIR
case|:
if|if
condition|(
name|mystat
argument_list|(
name|arg
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|say_undef
goto|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|statcache
operator|.
name|st_mode
argument_list|)
condition|)
goto|goto
name|say_yes
goto|;
goto|goto
name|say_no
goto|;
case|case
name|O_FTPIPE
case|:
if|if
condition|(
name|mystat
argument_list|(
name|arg
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|say_undef
goto|;
if|if
condition|(
name|S_ISFIFO
argument_list|(
name|statcache
operator|.
name|st_mode
argument_list|)
condition|)
goto|goto
name|say_yes
goto|;
goto|goto
name|say_no
goto|;
case|case
name|O_FTLINK
case|:
if|if
condition|(
name|mylstat
argument_list|(
name|arg
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|say_undef
goto|;
if|if
condition|(
name|S_ISLNK
argument_list|(
name|statcache
operator|.
name|st_mode
argument_list|)
condition|)
goto|goto
name|say_yes
goto|;
goto|goto
name|say_no
goto|;
case|case
name|O_SYMLINK
case|:
ifdef|#
directive|ifdef
name|HAS_SYMLINK
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|tmps2
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TAINT
name|taintproper
argument_list|(
literal|"Insecure dependency in symlink"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|value
operator|=
call|(
name|double
call|)
argument_list|(
name|symlink
argument_list|(
name|tmps
argument_list|,
name|tmps2
argument_list|)
operator|>=
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
else|#
directive|else
name|fatal
argument_list|(
literal|"Unsupported function symlink"
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|O_READLINK
case|:
ifdef|#
directive|ifdef
name|HAS_SYMLINK
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
name|tmps
operator|=
name|str_get
argument_list|(
name|stab_val
argument_list|(
name|defstab
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|anum
operator|=
name|readlink
argument_list|(
name|tmps
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|anum
operator|<
literal|0
condition|)
goto|goto
name|say_undef
goto|;
name|str_nset
argument_list|(
name|str
argument_list|,
name|buf
argument_list|,
name|anum
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
goto|goto
name|say_undef
goto|;
comment|/* just pretend it's a normal file */
endif|#
directive|endif
case|case
name|O_FTSUID
case|:
ifdef|#
directive|ifdef
name|S_ISUID
name|anum
operator|=
name|S_ISUID
expr_stmt|;
goto|goto
name|check_xid
goto|;
else|#
directive|else
goto|goto
name|say_no
goto|;
endif|#
directive|endif
case|case
name|O_FTSGID
case|:
ifdef|#
directive|ifdef
name|S_ISGID
name|anum
operator|=
name|S_ISGID
expr_stmt|;
goto|goto
name|check_xid
goto|;
else|#
directive|else
goto|goto
name|say_no
goto|;
endif|#
directive|endif
case|case
name|O_FTSVTX
case|:
ifdef|#
directive|ifdef
name|S_ISVTX
name|anum
operator|=
name|S_ISVTX
expr_stmt|;
else|#
directive|else
goto|goto
name|say_no
goto|;
endif|#
directive|endif
name|check_xid
label|:
if|if
condition|(
name|mystat
argument_list|(
name|arg
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|say_undef
goto|;
if|if
condition|(
name|statcache
operator|.
name|st_mode
operator|&
name|anum
condition|)
goto|goto
name|say_yes
goto|;
goto|goto
name|say_no
goto|;
case|case
name|O_FTTTY
case|:
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_DONT
condition|)
block|{
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
name|tmps
operator|=
literal|""
expr_stmt|;
block|}
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|tmps
operator|=
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|stab
operator|&&
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|&&
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|ifp
condition|)
name|anum
operator|=
name|fileno
argument_list|(
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|->
name|ifp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|tmps
argument_list|)
condition|)
name|anum
operator|=
name|atoi
argument_list|(
name|tmps
argument_list|)
expr_stmt|;
else|else
goto|goto
name|say_undef
goto|;
if|if
condition|(
name|isatty
argument_list|(
name|anum
argument_list|)
condition|)
goto|goto
name|say_yes
goto|;
goto|goto
name|say_no
goto|;
case|case
name|O_FTTEXT
case|:
case|case
name|O_FTBINARY
case|:
name|str
operator|=
name|do_fttext
argument_list|(
name|arg
argument_list|,
name|st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAS_SOCKET
case|case
name|O_SOCKET
case|:
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|value
operator|=
operator|(
name|double
operator|)
name|do_socket
argument_list|(
name|stab
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|do_socket
argument_list|(
name|stab
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|donumset
goto|;
case|case
name|O_BIND
case|:
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|value
operator|=
operator|(
name|double
operator|)
name|do_bind
argument_list|(
name|stab
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|do_bind
argument_list|(
name|stab
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|donumset
goto|;
case|case
name|O_CONNECT
case|:
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|value
operator|=
operator|(
name|double
operator|)
name|do_connect
argument_list|(
name|stab
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|do_connect
argument_list|(
name|stab
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|donumset
goto|;
case|case
name|O_LISTEN
case|:
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|value
operator|=
operator|(
name|double
operator|)
name|do_listen
argument_list|(
name|stab
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|do_listen
argument_list|(
name|stab
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|donumset
goto|;
case|case
name|O_ACCEPT
case|:
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab2
operator|=
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab2
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|do_accept
argument_list|(
name|str
argument_list|,
name|stab
argument_list|,
name|stab2
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_GHBYNAME
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
goto|goto
name|say_undef
goto|;
case|case
name|O_GHBYADDR
case|:
case|case
name|O_GHOSTENT
case|:
name|sp
operator|=
name|do_ghent
argument_list|(
name|optype
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_GNBYNAME
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
goto|goto
name|say_undef
goto|;
case|case
name|O_GNBYADDR
case|:
case|case
name|O_GNETENT
case|:
name|sp
operator|=
name|do_gnent
argument_list|(
name|optype
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_GPBYNAME
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
goto|goto
name|say_undef
goto|;
case|case
name|O_GPBYNUMBER
case|:
case|case
name|O_GPROTOENT
case|:
name|sp
operator|=
name|do_gpent
argument_list|(
name|optype
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_GSBYNAME
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
goto|goto
name|say_undef
goto|;
case|case
name|O_GSBYPORT
case|:
case|case
name|O_GSERVENT
case|:
name|sp
operator|=
name|do_gsent
argument_list|(
name|optype
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_SHOSTENT
case|:
name|value
operator|=
operator|(
name|double
operator|)
name|sethostent
argument_list|(
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_SNETENT
case|:
name|value
operator|=
operator|(
name|double
operator|)
name|setnetent
argument_list|(
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_SPROTOENT
case|:
name|value
operator|=
operator|(
name|double
operator|)
name|setprotoent
argument_list|(
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_SSERVENT
case|:
name|value
operator|=
operator|(
name|double
operator|)
name|setservent
argument_list|(
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_EHOSTENT
case|:
name|value
operator|=
operator|(
name|double
operator|)
name|endhostent
argument_list|()
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_ENETENT
case|:
name|value
operator|=
operator|(
name|double
operator|)
name|endnetent
argument_list|()
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_EPROTOENT
case|:
name|value
operator|=
operator|(
name|double
operator|)
name|endprotoent
argument_list|()
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_ESERVENT
case|:
name|value
operator|=
operator|(
name|double
operator|)
name|endservent
argument_list|()
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_SOCKPAIR
case|:
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab2
operator|=
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab2
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|value
operator|=
operator|(
name|double
operator|)
name|do_spair
argument_list|(
name|stab
argument_list|,
name|stab2
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|do_spair
argument_list|(
name|stab
argument_list|,
name|stab2
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|donumset
goto|;
case|case
name|O_SHUTDOWN
case|:
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|value
operator|=
operator|(
name|double
operator|)
name|do_shutdown
argument_list|(
name|stab
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|do_shutdown
argument_list|(
name|stab
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|donumset
goto|;
case|case
name|O_GSOCKOPT
case|:
case|case
name|O_SSOCKOPT
case|:
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sp
operator|=
name|do_sopt
argument_list|(
name|optype
argument_list|,
name|stab
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_GETSOCKNAME
case|:
case|case
name|O_GETPEERNAME
case|:
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab
condition|)
goto|goto
name|say_undef
goto|;
name|sp
operator|=
name|do_getsockname
argument_list|(
name|optype
argument_list|,
name|stab
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
else|#
directive|else
comment|/* HAS_SOCKET not defined */
case|case
name|O_SOCKET
case|:
case|case
name|O_BIND
case|:
case|case
name|O_CONNECT
case|:
case|case
name|O_LISTEN
case|:
case|case
name|O_ACCEPT
case|:
case|case
name|O_SOCKPAIR
case|:
case|case
name|O_GHBYNAME
case|:
case|case
name|O_GHBYADDR
case|:
case|case
name|O_GHOSTENT
case|:
case|case
name|O_GNBYNAME
case|:
case|case
name|O_GNBYADDR
case|:
case|case
name|O_GNETENT
case|:
case|case
name|O_GPBYNAME
case|:
case|case
name|O_GPBYNUMBER
case|:
case|case
name|O_GPROTOENT
case|:
case|case
name|O_GSBYNAME
case|:
case|case
name|O_GSBYPORT
case|:
case|case
name|O_GSERVENT
case|:
case|case
name|O_SHOSTENT
case|:
case|case
name|O_SNETENT
case|:
case|case
name|O_SPROTOENT
case|:
case|case
name|O_SSERVENT
case|:
case|case
name|O_EHOSTENT
case|:
case|case
name|O_ENETENT
case|:
case|case
name|O_EPROTOENT
case|:
case|case
name|O_ESERVENT
case|:
case|case
name|O_SHUTDOWN
case|:
case|case
name|O_GSOCKOPT
case|:
case|case
name|O_SSOCKOPT
case|:
case|case
name|O_GETSOCKNAME
case|:
case|case
name|O_GETPEERNAME
case|:
name|badsock
label|:
name|fatal
argument_list|(
literal|"Unsupported socket function"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAS_SOCKET */
case|case
name|O_SSELECT
case|:
ifdef|#
directive|ifdef
name|HAS_SELECT
name|sp
operator|=
name|do_select
argument_list|(
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
else|#
directive|else
name|fatal
argument_list|(
literal|"select not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
case|case
name|O_FILENO
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
goto|goto
name|say_undef
goto|;
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab
operator|||
operator|!
operator|(
name|stio
operator|=
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|fp
operator|=
name|stio
operator|->
name|ifp
operator|)
condition|)
goto|goto
name|say_undef
goto|;
name|value
operator|=
name|fileno
argument_list|(
name|fp
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_BINMODE
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
goto|goto
name|say_undef
goto|;
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab
operator|||
operator|!
operator|(
name|stio
operator|=
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|)
operator|||
operator|!
operator|(
name|fp
operator|=
name|stio
operator|->
name|ifp
operator|)
condition|)
goto|goto
name|say_undef
goto|;
ifdef|#
directive|ifdef
name|DOSISH
ifdef|#
directive|ifdef
name|atarist
if|if
condition|(
name|fflush
argument_list|(
name|fp
argument_list|)
condition|)
name|str_set
argument_list|(
name|str
argument_list|,
name|No
argument_list|)
expr_stmt|;
else|else
block|{
name|fp
operator|->
name|_flag
operator||=
name|_IOBIN
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|str_set
argument_list|(
name|str
argument_list|,
operator|(
name|setmode
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|O_BINARY
argument_list|)
operator|!=
operator|-
literal|1
operator|)
condition|?
name|Yes
else|:
name|No
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|str_set
argument_list|(
name|str
argument_list|,
name|Yes
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
name|O_VEC
case|:
name|sp
operator|=
name|do_vec
argument_list|(
name|str
operator|==
name|st
index|[
literal|1
index|]
argument_list|,
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_GPWNAM
case|:
case|case
name|O_GPWUID
case|:
case|case
name|O_GPWENT
case|:
ifdef|#
directive|ifdef
name|HAS_PASSWD
name|sp
operator|=
name|do_gpwent
argument_list|(
name|optype
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_SPWENT
case|:
name|setpwent
argument_list|()
expr_stmt|;
goto|goto
name|say_yes
goto|;
case|case
name|O_EPWENT
case|:
name|endpwent
argument_list|()
expr_stmt|;
goto|goto
name|say_yes
goto|;
else|#
directive|else
case|case
name|O_EPWENT
case|:
case|case
name|O_SPWENT
case|:
name|fatal
argument_list|(
literal|"Unsupported password function"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|O_GGRNAM
case|:
case|case
name|O_GGRGID
case|:
case|case
name|O_GGRENT
case|:
ifdef|#
directive|ifdef
name|HAS_GROUP
name|sp
operator|=
name|do_ggrent
argument_list|(
name|optype
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_SGRENT
case|:
name|value
operator|=
operator|(
name|double
operator|)
name|setgrent
argument_list|()
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_EGRENT
case|:
name|value
operator|=
operator|(
name|double
operator|)
name|endgrent
argument_list|()
expr_stmt|;
goto|goto
name|donumset
goto|;
else|#
directive|else
case|case
name|O_EGRENT
case|:
case|case
name|O_SGRENT
case|:
name|fatal
argument_list|(
literal|"Unsupported group function"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|O_GETLOGIN
case|:
ifdef|#
directive|ifdef
name|HAS_GETLOGIN
if|if
condition|(
operator|!
operator|(
name|tmps
operator|=
name|getlogin
argument_list|()
operator|)
condition|)
goto|goto
name|say_undef
goto|;
name|str_set
argument_list|(
name|str
argument_list|,
name|tmps
argument_list|)
expr_stmt|;
else|#
directive|else
name|fatal
argument_list|(
literal|"Unsupported function getlogin"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|O_OPEN_DIR
case|:
case|case
name|O_READDIR
case|:
case|case
name|O_TELLDIR
case|:
case|case
name|O_SEEKDIR
case|:
case|case
name|O_REWINDDIR
case|:
case|case
name|O_CLOSEDIR
case|:
if|if
condition|(
name|maxarg
operator|<
literal|1
condition|)
goto|goto
name|say_undef
goto|;
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab
condition|)
goto|goto
name|say_undef
goto|;
name|sp
operator|=
name|do_dirop
argument_list|(
name|optype
argument_list|,
name|stab
argument_list|,
name|gimme
argument_list|,
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|array_return
goto|;
case|case
name|O_SYSCALL
case|:
name|value
operator|=
operator|(
name|double
operator|)
name|do_syscall
argument_list|(
name|arglast
argument_list|)
expr_stmt|;
goto|goto
name|donumset
goto|;
case|case
name|O_PIPE_OP
case|:
ifdef|#
directive|ifdef
name|HAS_PIPE
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_WORD
condition|)
name|stab2
operator|=
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
else|else
name|stab2
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|st
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|do_pipe
argument_list|(
name|str
argument_list|,
name|stab
argument_list|,
name|stab2
argument_list|)
expr_stmt|;
name|STABSET
argument_list|(
name|str
argument_list|)
expr_stmt|;
else|#
directive|else
name|fatal
argument_list|(
literal|"Unsupported function pipe"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|normal_return
label|:
name|st
index|[
literal|1
index|]
operator|=
name|str
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
condition|)
block|{
name|dlevel
operator|--
expr_stmt|;
if|if
condition|(
name|debug
operator|&
literal|8
condition|)
name|deb
argument_list|(
literal|"%s RETURNS \"%s\"\n"
argument_list|,
name|opname
index|[
name|optype
index|]
argument_list|,
name|str_get
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|arglast
index|[
literal|0
index|]
operator|+
literal|1
return|;
block|}
end_function

end_unit

