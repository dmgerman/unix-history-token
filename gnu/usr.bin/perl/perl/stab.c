begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $RCSfile: stab.c,v $$Revision: 1.2.6.1 $$Date: 1997/05/22 21:41:35 $  *  *    Copyright (c) 1991, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  * $Log: stab.c,v $  * Revision 1.2.6.1  1997/05/22 21:41:35  imp  * MFG->2.2: Fix buffer overflow  *  * Revision 1.2  1995/05/30 05:03:19  rgrimes  * Remove trailing whitespace.  *  * Revision 1.1.1.1  1994/09/10  06:27:33  gclarkii  * Initial import of Perl 4.046 bmaked  *  * Revision 1.1.1.1  1993/08/23  21:29:39  nate  * PERL!  *  * Revision 4.0.1.5  1993/02/05  19:42:47  lwall  * patch36: length returned wrong value on certain semi-magical variables  *  * Revision 4.0.1.4  92/06/08  15:32:19  lwall  * patch20: fixed confusion between a *var's real name and its effective name  * patch20: the debugger now warns you on lines that can't set a breakpoint  * patch20: the debugger made perl forget the last pattern used by //  * patch20: paragraph mode now skips extra newlines automatically  * patch20: ($<,$>) = ... didn't work on some architectures  *  * Revision 4.0.1.3  91/11/05  18:35:33  lwall  * patch11: length($x) was sometimes wrong for numeric $x  * patch11: perl now issues warning if $SIG{'ALARM'} is referenced  * patch11: *foo = undef coredumped  * patch11: solitary subroutine references no longer trigger typo warnings  * patch11: local(*FILEHANDLE) had a memory leak  *  * Revision 4.0.1.2  91/06/07  11:55:53  lwall  * patch4: new copyright notice  * patch4: added $^P variable to control calling of perldb routines  * patch4: added $^F variable to specify maximum system fd, default 2  * patch4: $` was busted inside s///  * patch4: default top-of-form format is now FILEHANDLE_TOP  * patch4: length($`), length($&), length($') now optimized to avoid string copy  * patch4: $^D |= 1024 now does syntax tree dump at run-time  *  * Revision 4.0.1.1  91/04/12  09:10:24  lwall  * patch1: Configure now differentiates getgroups() type from getgid() type  * patch1: you may now use "die" and "caller" in a signal handler  *  * Revision 4.0  91/03/20  01:39:41  lwall  * 4.0 baseline.  *  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NSIG
argument_list|)
operator|||
name|defined
argument_list|(
name|M_UNIX
argument_list|)
operator|||
name|defined
argument_list|(
name|M_XENIX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sig_name
index|[]
init|=
block|{
name|SIG_NAME
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|VOIDSIG
end_ifdef

begin_define
define|#
directive|define
name|handlertype
value|void
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|handlertype
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|handlertype
name|sighandler
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|origalen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|STR
modifier|*
name|stab_str
parameter_list|(
name|str
parameter_list|)
name|STR
modifier|*
name|str
decl_stmt|;
block|{
name|STAB
modifier|*
name|stab
init|=
name|str
operator|->
name|str_u
operator|.
name|str_stab
decl_stmt|;
specifier|register
name|int
name|paren
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|str
operator|->
name|str_rare
condition|)
return|return
name|stab_val
argument_list|(
name|stab
argument_list|)
return|;
switch|switch
condition|(
operator|*
name|stab
operator|->
name|str_magic
operator|->
name|str_ptr
condition|)
block|{
case|case
literal|'\004'
case|:
comment|/* ^D */
ifdef|#
directive|ifdef
name|DEBUGGING
name|str_numset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
call|(
name|double
call|)
argument_list|(
name|debug
operator|&
literal|32767
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'\006'
case|:
comment|/* ^F */
name|str_numset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|maxsysfd
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
comment|/* ^I */
if|if
condition|(
name|inplace
condition|)
name|str_set
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
name|inplace
argument_list|)
expr_stmt|;
else|else
name|str_sset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
operator|&
name|str_undef
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\020'
case|:
comment|/* ^P */
name|str_numset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|perldb
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\024'
case|:
comment|/* ^T */
name|str_numset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|basetime
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\027'
case|:
comment|/* ^W */
name|str_numset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|dowarn
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'&'
case|:
if|if
condition|(
name|curspat
condition|)
block|{
name|paren
operator|=
name|atoi
argument_list|(
name|stab_ename
argument_list|(
name|stab
argument_list|)
argument_list|)
expr_stmt|;
name|getparen
label|:
if|if
condition|(
name|curspat
operator|->
name|spat_regexp
operator|&&
name|paren
operator|<=
name|curspat
operator|->
name|spat_regexp
operator|->
name|nparens
operator|&&
operator|(
name|s
operator|=
name|curspat
operator|->
name|spat_regexp
operator|->
name|startp
index|[
name|paren
index|]
operator|)
condition|)
block|{
name|i
operator|=
name|curspat
operator|->
name|spat_regexp
operator|->
name|endp
index|[
name|paren
index|]
operator|-
name|s
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|str_nset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
name|s
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|str_sset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
operator|&
name|str_undef
argument_list|)
expr_stmt|;
block|}
else|else
name|str_sset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
operator|&
name|str_undef
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
name|curspat
condition|)
block|{
name|paren
operator|=
name|curspat
operator|->
name|spat_regexp
operator|->
name|lastparen
expr_stmt|;
goto|goto
name|getparen
goto|;
block|}
break|break;
case|case
literal|'`'
case|:
if|if
condition|(
name|curspat
condition|)
block|{
if|if
condition|(
name|curspat
operator|->
name|spat_regexp
operator|&&
operator|(
name|s
operator|=
name|curspat
operator|->
name|spat_regexp
operator|->
name|subbeg
operator|)
condition|)
block|{
name|i
operator|=
name|curspat
operator|->
name|spat_regexp
operator|->
name|startp
index|[
literal|0
index|]
operator|-
name|s
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|str_nset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
name|s
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|str_nset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|str_nset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\''
case|:
if|if
condition|(
name|curspat
condition|)
block|{
if|if
condition|(
name|curspat
operator|->
name|spat_regexp
operator|&&
operator|(
name|s
operator|=
name|curspat
operator|->
name|spat_regexp
operator|->
name|endp
index|[
literal|0
index|]
operator|)
condition|)
block|{
name|str_nset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
name|s
argument_list|,
name|curspat
operator|->
name|spat_regexp
operator|->
name|subend
operator|-
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|str_nset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'.'
case|:
ifndef|#
directive|ifndef
name|lint
if|if
condition|(
name|last_in_stab
operator|&&
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
condition|)
block|{
name|str_numset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|stab_io
argument_list|(
name|last_in_stab
argument_list|)
operator|->
name|lines
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
literal|'?'
case|:
name|str_numset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|statusvalue
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|s
operator|=
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|->
name|top_name
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|str_set
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
block|{
name|str_set
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
name|stab_ename
argument_list|(
name|curoutstab
argument_list|)
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
literal|"_TOP"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'~'
case|:
name|s
operator|=
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|->
name|fmt_name
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|s
operator|=
name|stab_ename
argument_list|(
name|curoutstab
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|lint
case|case
literal|'='
case|:
name|str_numset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|->
name|page_len
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|str_numset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|->
name|lines_left
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|str_numset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|->
name|page
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|':'
case|:
break|break;
case|case
literal|'/'
case|:
break|break;
case|case
literal|'['
case|:
name|str_numset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|arybase
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
if|if
condition|(
operator|!
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
condition|)
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|=
name|stio_new
argument_list|()
expr_stmt|;
name|str_numset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
call|(
name|double
call|)
argument_list|(
operator|(
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|->
name|flags
operator|&
name|IOF_FLUSH
operator|)
operator|!=
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|','
case|:
name|str_nset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
name|ofs
argument_list|,
name|ofslen
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|str_nset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
name|ors
argument_list|,
name|orslen
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|str_set
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
name|ofmt
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|str_numset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|errno
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
name|errno
condition|?
name|strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
name|stab_val
argument_list|(
name|stab
argument_list|)
operator|->
name|str_nok
operator|=
literal|1
expr_stmt|;
comment|/* what a wonderful hack! */
break|break;
case|case
literal|'<'
case|:
name|str_numset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|uid
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|str_numset
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
operator|(
name|double
operator|)
name|euid
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|s
operator|=
name|buf
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|gid
argument_list|)
expr_stmt|;
goto|goto
name|add_groups
goto|;
case|case
literal|')'
case|:
name|s
operator|=
name|buf
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|egid
argument_list|)
expr_stmt|;
name|add_groups
label|:
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_GETGROUPS
ifndef|#
directive|ifndef
name|NGROUPS
define|#
directive|define
name|NGROUPS
value|32
endif|#
directive|endif
block|{
name|GROUPSTYPE
name|gary
index|[
name|NGROUPS
index|]
decl_stmt|;
name|i
operator|=
name|getgroups
argument_list|(
name|NGROUPS
argument_list|,
name|gary
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|s
argument_list|,
literal|" %ld"
argument_list|,
operator|(
name|long
operator|)
name|gary
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|str_set
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
break|break;
case|case
literal|'0'
case|:
break|break;
default|default:
block|{
name|struct
name|ufuncs
modifier|*
name|uf
init|=
operator|(
expr|struct
name|ufuncs
operator|*
operator|)
name|str
operator|->
name|str_ptr
decl_stmt|;
if|if
condition|(
name|uf
operator|&&
name|uf
operator|->
name|uf_val
condition|)
call|(
modifier|*
name|uf
operator|->
name|uf_val
call|)
argument_list|(
name|uf
operator|->
name|uf_index
argument_list|,
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
name|stab_val
argument_list|(
name|stab
argument_list|)
return|;
block|}
end_function

begin_function
name|STRLEN
name|stab_len
parameter_list|(
name|str
parameter_list|)
name|STR
modifier|*
name|str
decl_stmt|;
block|{
name|STAB
modifier|*
name|stab
init|=
name|str
operator|->
name|str_u
operator|.
name|str_stab
decl_stmt|;
name|int
name|paren
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|str
operator|->
name|str_rare
condition|)
return|return
name|str_len
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|)
return|;
switch|switch
condition|(
operator|*
name|stab
operator|->
name|str_magic
operator|->
name|str_ptr
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'&'
case|:
if|if
condition|(
name|curspat
condition|)
block|{
name|paren
operator|=
name|atoi
argument_list|(
name|stab_ename
argument_list|(
name|stab
argument_list|)
argument_list|)
expr_stmt|;
name|getparen
label|:
if|if
condition|(
name|curspat
operator|->
name|spat_regexp
operator|&&
name|paren
operator|<=
name|curspat
operator|->
name|spat_regexp
operator|->
name|nparens
operator|&&
operator|(
name|s
operator|=
name|curspat
operator|->
name|spat_regexp
operator|->
name|startp
index|[
name|paren
index|]
operator|)
condition|)
block|{
name|i
operator|=
name|curspat
operator|->
name|spat_regexp
operator|->
name|endp
index|[
name|paren
index|]
operator|-
name|s
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
return|return
name|i
return|;
else|else
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
name|curspat
condition|)
block|{
name|paren
operator|=
name|curspat
operator|->
name|spat_regexp
operator|->
name|lastparen
expr_stmt|;
goto|goto
name|getparen
goto|;
block|}
break|break;
case|case
literal|'`'
case|:
if|if
condition|(
name|curspat
condition|)
block|{
if|if
condition|(
name|curspat
operator|->
name|spat_regexp
operator|&&
operator|(
name|s
operator|=
name|curspat
operator|->
name|spat_regexp
operator|->
name|subbeg
operator|)
condition|)
block|{
name|i
operator|=
name|curspat
operator|->
name|spat_regexp
operator|->
name|startp
index|[
literal|0
index|]
operator|-
name|s
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
return|return
name|i
return|;
else|else
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'\''
case|:
if|if
condition|(
name|curspat
condition|)
block|{
if|if
condition|(
name|curspat
operator|->
name|spat_regexp
operator|&&
operator|(
name|s
operator|=
name|curspat
operator|->
name|spat_regexp
operator|->
name|endp
index|[
literal|0
index|]
operator|)
condition|)
block|{
return|return
call|(
name|STRLEN
call|)
argument_list|(
name|curspat
operator|->
name|spat_regexp
operator|->
name|subend
operator|-
name|s
argument_list|)
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|','
case|:
return|return
operator|(
name|STRLEN
operator|)
name|ofslen
return|;
case|case
literal|'\\'
case|:
return|return
operator|(
name|STRLEN
operator|)
name|orslen
return|;
block|}
return|return
name|str_len
argument_list|(
name|stab_str
argument_list|(
name|str
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|stabset
parameter_list|(
name|mstr
parameter_list|,
name|str
parameter_list|)
specifier|register
name|STR
modifier|*
name|mstr
decl_stmt|;
name|STR
modifier|*
name|str
decl_stmt|;
block|{
name|STAB
modifier|*
name|stab
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|mstr
operator|->
name|str_rare
condition|)
block|{
case|case
literal|'E'
case|:
name|my_setenv
argument_list|(
name|mstr
operator|->
name|str_ptr
argument_list|,
name|str_get
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And you'll never guess what the dog had */
comment|/*   in its mouth... */
ifdef|#
directive|ifdef
name|TAINT
if|if
condition|(
name|strEQ
argument_list|(
name|mstr
operator|->
name|str_ptr
argument_list|,
literal|"PATH"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|strend
init|=
name|str
operator|->
name|str_ptr
operator|+
name|str
operator|->
name|str_cur
decl_stmt|;
name|s
operator|=
name|str
operator|->
name|str_ptr
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|strend
condition|)
block|{
name|s
operator|=
name|cpytill
argument_list|(
name|tokenbuf
argument_list|,
name|s
argument_list|,
name|strend
argument_list|,
literal|':'
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|tokenbuf
operator|!=
literal|'/'
operator|||
operator|(
name|stat
argument_list|(
name|tokenbuf
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|&&
operator|(
name|statbuf
operator|.
name|st_mode
operator|&
literal|2
operator|)
operator|)
condition|)
name|str
operator|->
name|str_tainted
operator|=
literal|2
expr_stmt|;
block|}
block|}
endif|#
directive|endif
break|break;
case|case
literal|'S'
case|:
name|s
operator|=
name|str_get
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|i
operator|=
name|whichsig
argument_list|(
name|mstr
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
comment|/* ...no, a brick */
if|if
condition|(
operator|!
name|i
operator|&&
operator|(
name|dowarn
operator|||
name|strEQ
argument_list|(
name|mstr
operator|->
name|str_ptr
argument_list|,
literal|"ALARM"
argument_list|)
operator|)
condition|)
name|warn
argument_list|(
literal|"No such signal: SIG%s"
argument_list|,
name|mstr
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|s
argument_list|,
literal|"IGNORE"
argument_list|)
condition|)
ifndef|#
directive|ifndef
name|lint
operator|(
name|void
operator|)
name|signal
argument_list|(
name|i
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
else|#
directive|else
empty_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|s
argument_list|,
literal|"DEFAULT"
argument_list|)
operator|||
operator|!
operator|*
name|s
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|i
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|i
argument_list|,
name|sighandler
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|index
argument_list|(
name|s
argument_list|,
literal|'\''
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|tokenbuf
argument_list|,
literal|"main'%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
name|tokenbuf
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|SOME_DBM
case|case
literal|'D'
case|:
name|stab
operator|=
name|mstr
operator|->
name|str_u
operator|.
name|str_stab
expr_stmt|;
name|hdbmstore
argument_list|(
name|stab_hash
argument_list|(
name|stab
argument_list|)
argument_list|,
name|mstr
operator|->
name|str_ptr
argument_list|,
name|mstr
operator|->
name|str_cur
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'L'
case|:
block|{
name|CMD
modifier|*
name|cmd
decl_stmt|;
name|stab
operator|=
name|mstr
operator|->
name|str_u
operator|.
name|str_stab
expr_stmt|;
name|i
operator|=
name|str_true
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
name|afetch
argument_list|(
name|stab_xarray
argument_list|(
name|stab
argument_list|)
argument_list|,
name|atoi
argument_list|(
name|mstr
operator|->
name|str_ptr
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|->
name|str_magic
operator|&&
operator|(
name|cmd
operator|=
name|str
operator|->
name|str_magic
operator|->
name|str_u
operator|.
name|str_cmd
operator|)
condition|)
block|{
name|cmd
operator|->
name|c_flags
operator|&=
operator|~
name|CF_OPTIMIZE
expr_stmt|;
name|cmd
operator|->
name|c_flags
operator||=
name|i
condition|?
name|CFT_D1
else|:
name|CFT_D0
expr_stmt|;
block|}
else|else
name|warn
argument_list|(
literal|"Can't break at that line\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'#'
case|:
name|stab
operator|=
name|mstr
operator|->
name|str_u
operator|.
name|str_stab
expr_stmt|;
name|afill
argument_list|(
name|stab_array
argument_list|(
name|stab
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|str
argument_list|)
operator|-
name|arybase
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* merely a copy of a * string */
break|break;
case|case
literal|'*'
case|:
name|s
operator|=
name|str
operator|->
name|str_pok
condition|?
name|str_get
argument_list|(
name|str
argument_list|)
else|:
literal|""
expr_stmt|;
if|if
condition|(
name|strNE
argument_list|(
name|s
argument_list|,
literal|"StB"
argument_list|)
operator|||
name|str
operator|->
name|str_cur
operator|!=
sizeof|sizeof
argument_list|(
name|STBP
argument_list|)
condition|)
block|{
name|stab
operator|=
name|mstr
operator|->
name|str_u
operator|.
name|str_stab
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
block|{
name|STBP
modifier|*
name|stbp
decl_stmt|;
comment|/*SUPPRESS 701*/
operator|(
name|void
operator|)
name|savenostab
argument_list|(
name|stab
argument_list|)
expr_stmt|;
comment|/* schedule a free of this stab */
if|if
condition|(
name|stab
operator|->
name|str_len
condition|)
name|Safefree
argument_list|(
name|stab
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
name|Newz
argument_list|(
literal|601
argument_list|,
name|stbp
argument_list|,
literal|1
argument_list|,
name|STBP
argument_list|)
expr_stmt|;
name|stab
operator|->
name|str_ptr
operator|=
name|stbp
expr_stmt|;
name|stab
operator|->
name|str_len
operator|=
name|stab
operator|->
name|str_cur
operator|=
sizeof|sizeof
argument_list|(
name|STBP
argument_list|)
expr_stmt|;
name|stab
operator|->
name|str_pok
operator|=
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|stab_magic
argument_list|(
name|stab
argument_list|)
argument_list|,
literal|"StB"
argument_list|)
expr_stmt|;
name|stab_val
argument_list|(
name|stab
argument_list|)
operator|=
name|Str_new
argument_list|(
literal|70
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stab_line
argument_list|(
name|stab
argument_list|)
operator|=
name|curcmd
operator|->
name|c_line
expr_stmt|;
name|stab_estab
argument_list|(
name|stab
argument_list|)
operator|=
name|stab
expr_stmt|;
block|}
else|else
block|{
name|stab
operator|=
name|stabent
argument_list|(
name|s
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_xarray
argument_list|(
name|stab
argument_list|)
condition|)
name|aadd
argument_list|(
name|stab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_xhash
argument_list|(
name|stab
argument_list|)
condition|)
name|hadd
argument_list|(
name|stab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stab_io
argument_list|(
name|stab
argument_list|)
condition|)
name|stab_io
argument_list|(
name|stab
argument_list|)
operator|=
name|stio_new
argument_list|()
expr_stmt|;
block|}
name|str_sset
argument_list|(
name|str
argument_list|,
operator|(
name|STR
operator|*
operator|)
name|stab
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
block|{
name|struct
name|lstring
modifier|*
name|lstr
init|=
operator|(
expr|struct
name|lstring
operator|*
operator|)
name|str
decl_stmt|;
name|char
modifier|*
name|tmps
decl_stmt|;
name|mstr
operator|->
name|str_rare
operator|=
literal|0
expr_stmt|;
name|str
operator|->
name|str_magic
operator|=
name|Nullstr
expr_stmt|;
name|tmps
operator|=
name|str_get
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|str_insert
argument_list|(
name|mstr
argument_list|,
name|lstr
operator|->
name|lstr_offset
argument_list|,
name|lstr
operator|->
name|lstr_len
argument_list|,
name|tmps
argument_list|,
name|str
operator|->
name|str_cur
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
name|do_vecset
argument_list|(
name|mstr
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/*SUPPRESS 560*/
if|if
condition|(
operator|!
operator|(
name|stab
operator|=
name|mstr
operator|->
name|str_u
operator|.
name|str_stab
operator|)
condition|)
break|break;
switch|switch
condition|(
operator|*
name|stab
operator|->
name|str_magic
operator|->
name|str_ptr
condition|)
block|{
case|case
literal|'\004'
case|:
comment|/* ^D */
ifdef|#
directive|ifdef
name|DEBUGGING
name|debug
operator|=
call|(
name|int
call|)
argument_list|(
name|str_gnum
argument_list|(
name|str
argument_list|)
argument_list|)
operator||
literal|32768
expr_stmt|;
if|if
condition|(
name|debug
operator|&
literal|1024
condition|)
name|dump_all
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'\006'
case|:
comment|/* ^F */
name|maxsysfd
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
comment|/* ^I */
if|if
condition|(
name|inplace
condition|)
name|Safefree
argument_list|(
name|inplace
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|->
name|str_pok
operator|||
name|str
operator|->
name|str_nok
condition|)
name|inplace
operator|=
name|savestr
argument_list|(
name|str_get
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|inplace
operator|=
name|Nullch
expr_stmt|;
break|break;
case|case
literal|'\020'
case|:
comment|/* ^P */
name|i
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|perldb
condition|)
block|{
specifier|static
name|SPAT
modifier|*
name|oldlastspat
decl_stmt|;
if|if
condition|(
name|perldb
condition|)
name|oldlastspat
operator|=
name|lastspat
expr_stmt|;
else|else
name|lastspat
operator|=
name|oldlastspat
expr_stmt|;
block|}
name|perldb
operator|=
name|i
expr_stmt|;
break|break;
case|case
literal|'\024'
case|:
comment|/* ^T */
name|basetime
operator|=
operator|(
name|time_t
operator|)
name|str_gnum
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\027'
case|:
comment|/* ^W */
name|dowarn
operator|=
operator|(
name|bool
operator|)
name|str_gnum
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
if|if
condition|(
name|localizing
condition|)
name|savesptr
argument_list|(
operator|(
name|STR
operator|*
operator|*
operator|)
operator|&
name|last_in_stab
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|Safefree
argument_list|(
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|->
name|top_name
argument_list|)
expr_stmt|;
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|->
name|top_name
operator|=
name|s
operator|=
name|savestr
argument_list|(
name|str_get
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|->
name|top_stab
operator|=
name|stabent
argument_list|(
name|s
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
name|Safefree
argument_list|(
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|->
name|fmt_name
argument_list|)
expr_stmt|;
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|->
name|fmt_name
operator|=
name|s
operator|=
name|savestr
argument_list|(
name|str_get
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|->
name|fmt_stab
operator|=
name|stabent
argument_list|(
name|s
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|->
name|page_len
operator|=
operator|(
name|long
operator|)
name|str_gnum
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|->
name|lines_left
operator|=
operator|(
name|long
operator|)
name|str_gnum
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|->
name|lines_left
operator|<
literal|0L
condition|)
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|->
name|lines_left
operator|=
literal|0L
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|->
name|page
operator|=
operator|(
name|long
operator|)
name|str_gnum
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
if|if
condition|(
operator|!
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
condition|)
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|=
name|stio_new
argument_list|()
expr_stmt|;
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|->
name|flags
operator|&=
operator|~
name|IOF_FLUSH
expr_stmt|;
if|if
condition|(
name|str_gnum
argument_list|(
name|str
argument_list|)
operator|!=
literal|0.0
condition|)
block|{
name|stab_io
argument_list|(
name|curoutstab
argument_list|)
operator|->
name|flags
operator||=
name|IOF_FLUSH
expr_stmt|;
block|}
break|break;
case|case
literal|'*'
case|:
name|i
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|multiline
operator|=
operator|(
name|i
operator|!=
literal|0
operator|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|str
operator|->
name|str_pok
condition|)
block|{
name|rs
operator|=
name|str_get
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|rslen
operator|=
name|str
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
name|rspara
operator|=
operator|!
name|rslen
condition|)
block|{
name|rs
operator|=
literal|"\n\n"
expr_stmt|;
name|rslen
operator|=
literal|2
expr_stmt|;
block|}
name|rschar
operator|=
name|rs
index|[
name|rslen
operator|-
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|rschar
operator|=
literal|0777
expr_stmt|;
comment|/* fake a non-existent char */
name|rslen
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
name|ors
condition|)
name|Safefree
argument_list|(
name|ors
argument_list|)
expr_stmt|;
name|ors
operator|=
name|savestr
argument_list|(
name|str_get
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|orslen
operator|=
name|str
operator|->
name|str_cur
expr_stmt|;
break|break;
case|case
literal|','
case|:
if|if
condition|(
name|ofs
condition|)
name|Safefree
argument_list|(
name|ofs
argument_list|)
expr_stmt|;
name|ofs
operator|=
name|savestr
argument_list|(
name|str_get
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|ofslen
operator|=
name|str
operator|->
name|str_cur
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
if|if
condition|(
name|ofmt
condition|)
name|Safefree
argument_list|(
name|ofmt
argument_list|)
expr_stmt|;
name|ofmt
operator|=
name|savestr
argument_list|(
name|str_get
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|arybase
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|statusvalue
operator|=
name|U_S
argument_list|(
name|str_gnum
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|errno
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* will anyone ever use this? */
break|break;
case|case
literal|'<'
case|:
name|uid
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|delaymagic
condition|)
block|{
name|delaymagic
operator||=
name|DM_RUID
expr_stmt|;
break|break;
comment|/* don't do magic till later */
block|}
ifdef|#
directive|ifdef
name|HAS_SETRUID
operator|(
name|void
operator|)
name|setruid
argument_list|(
operator|(
name|UIDTYPE
operator|)
name|uid
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETREUID
operator|(
name|void
operator|)
name|setreuid
argument_list|(
operator|(
name|UIDTYPE
operator|)
name|uid
argument_list|,
operator|(
name|UIDTYPE
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|uid
operator|==
name|euid
condition|)
comment|/* special case $< = $> */
operator|(
name|void
operator|)
name|setuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"setruid() not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|uid
operator|=
operator|(
name|int
operator|)
name|getuid
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|euid
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|delaymagic
condition|)
block|{
name|delaymagic
operator||=
name|DM_EUID
expr_stmt|;
break|break;
comment|/* don't do magic till later */
block|}
ifdef|#
directive|ifdef
name|HAS_SETEUID
operator|(
name|void
operator|)
name|seteuid
argument_list|(
operator|(
name|UIDTYPE
operator|)
name|euid
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETREUID
operator|(
name|void
operator|)
name|setreuid
argument_list|(
operator|(
name|UIDTYPE
operator|)
operator|-
literal|1
argument_list|,
operator|(
name|UIDTYPE
operator|)
name|euid
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|euid
operator|==
name|uid
condition|)
comment|/* special case $> = $< */
name|setuid
argument_list|(
name|euid
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"seteuid() not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|euid
operator|=
operator|(
name|int
operator|)
name|geteuid
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|gid
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|delaymagic
condition|)
block|{
name|delaymagic
operator||=
name|DM_RGID
expr_stmt|;
break|break;
comment|/* don't do magic till later */
block|}
ifdef|#
directive|ifdef
name|HAS_SETRGID
operator|(
name|void
operator|)
name|setrgid
argument_list|(
operator|(
name|GIDTYPE
operator|)
name|gid
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETREGID
operator|(
name|void
operator|)
name|setregid
argument_list|(
operator|(
name|GIDTYPE
operator|)
name|gid
argument_list|,
operator|(
name|GIDTYPE
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|gid
operator|==
name|egid
condition|)
comment|/* special case $( = $) */
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|gid
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"setrgid() not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|gid
operator|=
operator|(
name|int
operator|)
name|getgid
argument_list|()
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|egid
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|delaymagic
condition|)
block|{
name|delaymagic
operator||=
name|DM_EGID
expr_stmt|;
break|break;
comment|/* don't do magic till later */
block|}
ifdef|#
directive|ifdef
name|HAS_SETEGID
operator|(
name|void
operator|)
name|setegid
argument_list|(
operator|(
name|GIDTYPE
operator|)
name|egid
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|HAS_SETREGID
operator|(
name|void
operator|)
name|setregid
argument_list|(
operator|(
name|GIDTYPE
operator|)
operator|-
literal|1
argument_list|,
operator|(
name|GIDTYPE
operator|)
name|egid
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|egid
operator|==
name|gid
condition|)
comment|/* special case $) = $( */
operator|(
name|void
operator|)
name|setgid
argument_list|(
name|egid
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"setegid() not implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|egid
operator|=
operator|(
name|int
operator|)
name|getegid
argument_list|()
expr_stmt|;
break|break;
case|case
literal|':'
case|:
name|chopset
operator|=
name|str_get
argument_list|(
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
if|if
condition|(
operator|!
name|origalen
condition|)
block|{
name|s
operator|=
name|origargv
index|[
literal|0
index|]
expr_stmt|;
name|s
operator|+=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* See if all the arguments are contiguous in memory */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|origargc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|origargv
index|[
name|i
index|]
operator|==
name|s
operator|+
literal|1
condition|)
name|s
operator|+=
name|strlen
argument_list|(
operator|++
name|s
argument_list|)
expr_stmt|;
comment|/* this one is ok too */
block|}
if|if
condition|(
name|origenviron
index|[
literal|0
index|]
operator|==
name|s
operator|+
literal|1
condition|)
block|{
comment|/* can grab env area too? */
name|my_setenv
argument_list|(
literal|"NoNeSuCh"
argument_list|,
name|Nullch
argument_list|)
expr_stmt|;
comment|/* force copy of environment */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|origenviron
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|origenviron
index|[
name|i
index|]
operator|==
name|s
operator|+
literal|1
condition|)
name|s
operator|+=
name|strlen
argument_list|(
operator|++
name|s
argument_list|)
expr_stmt|;
block|}
name|origalen
operator|=
name|s
operator|-
name|origargv
index|[
literal|0
index|]
expr_stmt|;
block|}
name|s
operator|=
name|str_get
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|i
operator|=
name|str
operator|->
name|str_cur
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|origalen
condition|)
block|{
name|i
operator|=
name|origalen
expr_stmt|;
name|str
operator|->
name|str_cur
operator|=
name|i
expr_stmt|;
name|str
operator|->
name|str_ptr
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|Copy
argument_list|(
name|s
argument_list|,
name|origargv
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|char
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Copy
argument_list|(
name|s
argument_list|,
name|origargv
index|[
literal|0
index|]
argument_list|,
name|i
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|s
operator|=
name|origargv
index|[
literal|0
index|]
operator|+
name|i
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|++
name|i
operator|<
name|origalen
condition|)
operator|*
name|s
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|struct
name|ufuncs
modifier|*
name|uf
init|=
operator|(
expr|struct
name|ufuncs
operator|*
operator|)
name|str
operator|->
name|str_magic
operator|->
name|str_ptr
decl_stmt|;
if|if
condition|(
name|uf
operator|&&
name|uf
operator|->
name|uf_set
condition|)
call|(
modifier|*
name|uf
operator|->
name|uf_set
call|)
argument_list|(
name|uf
operator|->
name|uf_index
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
break|break;
block|}
block|}
end_function

begin_function
name|int
name|whichsig
parameter_list|(
name|sig
parameter_list|)
name|char
modifier|*
name|sig
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|sigv
decl_stmt|;
for|for
control|(
name|sigv
operator|=
name|sig_name
operator|+
literal|1
init|;
operator|*
name|sigv
condition|;
name|sigv
operator|++
control|)
if|if
condition|(
name|strEQ
argument_list|(
name|sig
argument_list|,
operator|*
name|sigv
argument_list|)
condition|)
return|return
name|sigv
operator|-
name|sig_name
return|;
ifdef|#
directive|ifdef
name|SIGCLD
if|if
condition|(
name|strEQ
argument_list|(
name|sig
argument_list|,
literal|"CHLD"
argument_list|)
condition|)
return|return
name|SIGCLD
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGCHLD
if|if
condition|(
name|strEQ
argument_list|(
name|sig
argument_list|,
literal|"CLD"
argument_list|)
condition|)
return|return
name|SIGCHLD
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|handlertype
name|sighandler
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|STAB
modifier|*
name|stab
decl_stmt|;
name|STR
modifier|*
name|str
decl_stmt|;
name|int
name|oldsave
init|=
name|savestack
operator|->
name|ary_fill
decl_stmt|;
name|int
name|oldtmps_base
init|=
name|tmps_base
decl_stmt|;
specifier|register
name|CSV
modifier|*
name|csv
decl_stmt|;
name|SUBR
modifier|*
name|sub
decl_stmt|;
ifdef|#
directive|ifdef
name|OS2
comment|/* or anybody else who requires SIG_ACK */
name|signal
argument_list|(
name|sig
argument_list|,
name|SIG_ACK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|hfetch
argument_list|(
name|stab_hash
argument_list|(
name|sigstab
argument_list|)
argument_list|,
name|sig_name
index|[
name|sig
index|]
argument_list|,
name|strlen
argument_list|(
name|sig_name
index|[
name|sig
index|]
argument_list|)
argument_list|,
name|TRUE
argument_list|)
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sub
operator|=
name|stab_sub
argument_list|(
name|stab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sub
operator|&&
operator|*
name|sig_name
index|[
name|sig
index|]
operator|==
literal|'C'
operator|&&
name|instr
argument_list|(
name|sig_name
index|[
name|sig
index|]
argument_list|,
literal|"LD"
argument_list|)
condition|)
block|{
if|if
condition|(
name|sig_name
index|[
name|sig
index|]
index|[
literal|1
index|]
operator|==
literal|'H'
condition|)
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|hfetch
argument_list|(
name|stab_hash
argument_list|(
name|sigstab
argument_list|)
argument_list|,
literal|"CLD"
argument_list|,
literal|3
argument_list|,
name|TRUE
argument_list|)
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|stab
operator|=
name|stabent
argument_list|(
name|str_get
argument_list|(
name|hfetch
argument_list|(
name|stab_hash
argument_list|(
name|sigstab
argument_list|)
argument_list|,
literal|"CHLD"
argument_list|,
literal|4
argument_list|,
name|TRUE
argument_list|)
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sub
operator|=
name|stab_sub
argument_list|(
name|stab
argument_list|)
expr_stmt|;
comment|/* gag */
block|}
if|if
condition|(
operator|!
name|sub
condition|)
block|{
if|if
condition|(
name|dowarn
condition|)
name|warn
argument_list|(
literal|"SIG%s handler \"%s\" not defined.\n"
argument_list|,
name|sig_name
index|[
name|sig
index|]
argument_list|,
name|stab_ename
argument_list|(
name|stab
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*SUPPRESS 701*/
name|saveaptr
argument_list|(
operator|&
name|stack
argument_list|)
expr_stmt|;
name|str
operator|=
name|Str_new
argument_list|(
literal|15
argument_list|,
sizeof|sizeof
argument_list|(
name|CSV
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_state
operator|=
name|SS_SCSV
expr_stmt|;
operator|(
name|void
operator|)
name|apush
argument_list|(
name|savestack
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|csv
operator|=
operator|(
name|CSV
operator|*
operator|)
name|str
operator|->
name|str_ptr
expr_stmt|;
name|csv
operator|->
name|sub
operator|=
name|sub
expr_stmt|;
name|csv
operator|->
name|stab
operator|=
name|stab
expr_stmt|;
name|csv
operator|->
name|curcsv
operator|=
name|curcsv
expr_stmt|;
name|csv
operator|->
name|curcmd
operator|=
name|curcmd
expr_stmt|;
name|csv
operator|->
name|depth
operator|=
name|sub
operator|->
name|depth
expr_stmt|;
name|csv
operator|->
name|wantarray
operator|=
name|G_SCALAR
expr_stmt|;
name|csv
operator|->
name|hasargs
operator|=
name|TRUE
expr_stmt|;
name|csv
operator|->
name|savearray
operator|=
name|stab_xarray
argument_list|(
name|defstab
argument_list|)
expr_stmt|;
name|csv
operator|->
name|argarray
operator|=
name|stab_xarray
argument_list|(
name|defstab
argument_list|)
operator|=
name|stack
operator|=
name|anew
argument_list|(
name|defstab
argument_list|)
expr_stmt|;
name|stack
operator|->
name|ary_flags
operator|=
literal|0
expr_stmt|;
name|curcsv
operator|=
name|csv
expr_stmt|;
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_undef
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
name|sig_name
index|[
name|sig
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|apush
argument_list|(
name|stab_xarray
argument_list|(
name|defstab
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|sub
operator|->
name|depth
operator|++
expr_stmt|;
if|if
condition|(
name|sub
operator|->
name|depth
operator|>=
literal|2
condition|)
block|{
comment|/* save temporaries on recursion? */
if|if
condition|(
name|sub
operator|->
name|depth
operator|==
literal|100
operator|&&
name|dowarn
condition|)
name|warn
argument_list|(
literal|"Deep recursion on subroutine \"%s\""
argument_list|,
name|stab_ename
argument_list|(
name|stab
argument_list|)
argument_list|)
expr_stmt|;
name|savelist
argument_list|(
name|sub
operator|->
name|tosave
operator|->
name|ary_array
argument_list|,
name|sub
operator|->
name|tosave
operator|->
name|ary_fill
argument_list|)
expr_stmt|;
block|}
name|tmps_base
operator|=
name|tmps_max
expr_stmt|;
comment|/* protect our mortal string */
operator|(
name|void
operator|)
name|cmd_exec
argument_list|(
name|sub
operator|->
name|cmd
argument_list|,
name|G_SCALAR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* so do it already */
name|tmps_base
operator|=
name|oldtmps_base
expr_stmt|;
name|restorelist
argument_list|(
name|oldsave
argument_list|)
expr_stmt|;
comment|/* put everything back */
block|}
end_function

begin_function
name|STAB
modifier|*
name|aadd
parameter_list|(
name|stab
parameter_list|)
specifier|register
name|STAB
modifier|*
name|stab
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|stab_xarray
argument_list|(
name|stab
argument_list|)
condition|)
name|stab_xarray
argument_list|(
name|stab
argument_list|)
operator|=
name|anew
argument_list|(
name|stab
argument_list|)
expr_stmt|;
return|return
name|stab
return|;
block|}
end_function

begin_function
name|STAB
modifier|*
name|hadd
parameter_list|(
name|stab
parameter_list|)
specifier|register
name|STAB
modifier|*
name|stab
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|stab_xhash
argument_list|(
name|stab
argument_list|)
condition|)
name|stab_xhash
argument_list|(
name|stab
argument_list|)
operator|=
name|hnew
argument_list|(
name|COEFFSIZE
argument_list|)
expr_stmt|;
return|return
name|stab
return|;
block|}
end_function

begin_function
name|STAB
modifier|*
name|fstab
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
name|tmpbuf
index|[
literal|1200
index|]
decl_stmt|;
name|STAB
modifier|*
name|stab
decl_stmt|;
name|snprintf
argument_list|(
name|tmpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
argument_list|,
literal|"'_<%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|stab
operator|=
name|stabent
argument_list|(
name|tmpbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|perldb
condition|)
operator|(
name|void
operator|)
name|hadd
argument_list|(
name|aadd
argument_list|(
name|stab
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|stab
return|;
block|}
end_function

begin_function
name|STAB
modifier|*
name|stabent
parameter_list|(
name|name
parameter_list|,
name|add
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|add
decl_stmt|;
block|{
specifier|register
name|STAB
modifier|*
name|stab
decl_stmt|;
specifier|register
name|STBP
modifier|*
name|stbp
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|namend
decl_stmt|;
name|HASH
modifier|*
name|stash
decl_stmt|;
name|char
modifier|*
name|sawquote
init|=
name|Nullch
decl_stmt|;
name|char
modifier|*
name|prevquote
init|=
name|Nullch
decl_stmt|;
name|bool
name|global
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|isUPPER
argument_list|(
operator|*
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|name
operator|>
literal|'I'
condition|)
block|{
if|if
condition|(
operator|*
name|name
operator|==
literal|'S'
operator|&&
operator|(
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"SIG"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"STDIN"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"STDOUT"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"STDERR"
argument_list|)
operator|)
condition|)
name|global
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|name
operator|>
literal|'E'
condition|)
block|{
if|if
condition|(
operator|*
name|name
operator|==
literal|'I'
operator|&&
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"INC"
argument_list|)
condition|)
name|global
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|name
operator|>
literal|'A'
condition|)
block|{
if|if
condition|(
operator|*
name|name
operator|==
literal|'E'
operator|&&
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"ENV"
argument_list|)
condition|)
name|global
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'A'
operator|&&
operator|(
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"ARGV"
argument_list|)
operator|||
name|strEQ
argument_list|(
name|name
argument_list|,
literal|"ARGVOUT"
argument_list|)
operator|)
condition|)
name|global
operator|=
name|TRUE
expr_stmt|;
block|}
for|for
control|(
name|namend
operator|=
name|name
init|;
operator|*
name|namend
condition|;
name|namend
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|namend
operator|==
literal|'\''
operator|&&
name|namend
index|[
literal|1
index|]
condition|)
name|prevquote
operator|=
name|sawquote
operator|,
name|sawquote
operator|=
name|namend
expr_stmt|;
block|}
if|if
condition|(
name|sawquote
operator|==
name|name
operator|&&
name|name
index|[
literal|1
index|]
condition|)
block|{
name|stash
operator|=
name|defstash
expr_stmt|;
name|sawquote
operator|=
name|Nullch
expr_stmt|;
name|name
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isALPHA
argument_list|(
operator|*
name|name
argument_list|)
operator|||
name|global
condition|)
name|stash
operator|=
name|defstash
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|CMD
operator|*
operator|)
name|curcmd
operator|==
operator|&
name|compiling
condition|)
name|stash
operator|=
name|curstash
expr_stmt|;
else|else
name|stash
operator|=
name|curcmd
operator|->
name|c_stash
expr_stmt|;
if|if
condition|(
name|sawquote
condition|)
block|{
name|char
name|tmpbuf
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
operator|*
name|sawquote
operator|=
literal|'\0'
expr_stmt|;
comment|/*SUPPRESS 560*/
if|if
condition|(
name|s
operator|=
name|prevquote
condition|)
block|{
name|strncpy
argument_list|(
name|tmpbuf
argument_list|,
name|name
argument_list|,
name|s
operator|-
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|=
name|tmpbuf
operator|+
operator|(
name|s
operator|-
name|name
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|'_'
expr_stmt|;
name|strcpy
argument_list|(
name|d
argument_list|,
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tmpbuf
operator|=
literal|'_'
expr_stmt|;
name|strcpy
argument_list|(
name|tmpbuf
operator|+
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|stab
operator|=
name|stabent
argument_list|(
name|tmpbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|stash
operator|=
name|stab_xhash
argument_list|(
name|stab
argument_list|)
operator|)
condition|)
name|stash
operator|=
name|stab_xhash
argument_list|(
name|stab
argument_list|)
operator|=
name|hnew
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stash
operator|->
name|tbl_name
condition|)
name|stash
operator|->
name|tbl_name
operator|=
name|savestr
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|sawquote
operator|+
literal|1
expr_stmt|;
operator|*
name|sawquote
operator|=
literal|'\''
expr_stmt|;
block|}
name|len
operator|=
name|namend
operator|-
name|name
expr_stmt|;
name|stab
operator|=
operator|(
name|STAB
operator|*
operator|)
name|hfetch
argument_list|(
name|stash
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
name|add
argument_list|)
expr_stmt|;
if|if
condition|(
name|stab
operator|==
operator|(
name|STAB
operator|*
operator|)
operator|&
name|str_undef
condition|)
return|return
name|Nullstab
return|;
if|if
condition|(
name|stab
operator|->
name|str_pok
condition|)
block|{
name|stab
operator|->
name|str_pok
operator||=
name|SP_MULTI
expr_stmt|;
return|return
name|stab
return|;
block|}
else|else
block|{
if|if
condition|(
name|stab
operator|->
name|str_len
condition|)
name|Safefree
argument_list|(
name|stab
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
name|Newz
argument_list|(
literal|602
argument_list|,
name|stbp
argument_list|,
literal|1
argument_list|,
name|STBP
argument_list|)
expr_stmt|;
name|stab
operator|->
name|str_ptr
operator|=
name|stbp
expr_stmt|;
name|stab
operator|->
name|str_len
operator|=
name|stab
operator|->
name|str_cur
operator|=
sizeof|sizeof
argument_list|(
name|STBP
argument_list|)
expr_stmt|;
name|stab
operator|->
name|str_pok
operator|=
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|stab_magic
argument_list|(
name|stab
argument_list|)
argument_list|,
literal|"StB"
argument_list|)
expr_stmt|;
name|stab_val
argument_list|(
name|stab
argument_list|)
operator|=
name|Str_new
argument_list|(
literal|72
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stab_line
argument_list|(
name|stab
argument_list|)
operator|=
name|curcmd
operator|->
name|c_line
expr_stmt|;
name|stab_estab
argument_list|(
name|stab
argument_list|)
operator|=
name|stab
expr_stmt|;
name|str_magic
argument_list|(
operator|(
name|STR
operator|*
operator|)
name|stab
argument_list|,
name|stab
argument_list|,
literal|'*'
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|stab_stash
argument_list|(
name|stab
argument_list|)
operator|=
name|stash
expr_stmt|;
if|if
condition|(
name|isDIGIT
argument_list|(
operator|*
name|name
argument_list|)
operator|&&
operator|*
name|name
operator|!=
literal|'0'
condition|)
block|{
name|stab_flags
argument_list|(
name|stab
argument_list|)
operator|=
name|SF_VMAGIC
expr_stmt|;
name|str_magic
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|,
name|stab
argument_list|,
literal|0
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|add
operator|&
literal|2
condition|)
name|stab
operator|->
name|str_pok
operator||=
name|SP_MULTI
expr_stmt|;
return|return
name|stab
return|;
block|}
block|}
end_function

begin_function
name|void
name|stab_fullname
parameter_list|(
name|str
parameter_list|,
name|stab
parameter_list|)
name|STR
modifier|*
name|str
decl_stmt|;
name|STAB
modifier|*
name|stab
decl_stmt|;
block|{
name|HASH
modifier|*
name|tb
init|=
name|stab_stash
argument_list|(
name|stab
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tb
condition|)
return|return;
name|str_set
argument_list|(
name|str
argument_list|,
name|tb
operator|->
name|tbl_name
argument_list|)
expr_stmt|;
name|str_ncat
argument_list|(
name|str
argument_list|,
literal|"'"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|str_scat
argument_list|(
name|str
argument_list|,
name|stab
operator|->
name|str_magic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|stab_efullname
parameter_list|(
name|str
parameter_list|,
name|stab
parameter_list|)
name|STR
modifier|*
name|str
decl_stmt|;
name|STAB
modifier|*
name|stab
decl_stmt|;
block|{
name|HASH
modifier|*
name|tb
init|=
name|stab_estash
argument_list|(
name|stab
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tb
condition|)
return|return;
name|str_set
argument_list|(
name|str
argument_list|,
name|tb
operator|->
name|tbl_name
argument_list|)
expr_stmt|;
name|str_ncat
argument_list|(
name|str
argument_list|,
literal|"'"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|str_scat
argument_list|(
name|str
argument_list|,
name|stab_estab
argument_list|(
name|stab
argument_list|)
operator|->
name|str_magic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|STIO
modifier|*
name|stio_new
parameter_list|()
block|{
name|STIO
modifier|*
name|stio
decl_stmt|;
name|Newz
argument_list|(
literal|603
argument_list|,
name|stio
argument_list|,
literal|1
argument_list|,
name|STIO
argument_list|)
expr_stmt|;
name|stio
operator|->
name|page_len
operator|=
literal|60
expr_stmt|;
return|return
name|stio
return|;
block|}
end_function

begin_function
name|void
name|stab_check
parameter_list|(
name|min
parameter_list|,
name|max
parameter_list|)
name|int
name|min
decl_stmt|;
specifier|register
name|int
name|max
decl_stmt|;
block|{
specifier|register
name|HENT
modifier|*
name|entry
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|STAB
modifier|*
name|stab
decl_stmt|;
for|for
control|(
name|i
operator|=
name|min
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|entry
operator|=
name|defstash
operator|->
name|tbl_array
index|[
name|i
index|]
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|hent_next
control|)
block|{
name|stab
operator|=
operator|(
name|STAB
operator|*
operator|)
name|entry
operator|->
name|hent_val
expr_stmt|;
if|if
condition|(
name|stab
operator|->
name|str_pok
operator|&
name|SP_MULTI
condition|)
continue|continue;
name|curcmd
operator|->
name|c_line
operator|=
name|stab_line
argument_list|(
name|stab
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"Possible typo: \"%s\""
argument_list|,
name|stab_name
argument_list|(
name|stab
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|gensym
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|STAB
modifier|*
name|genstab
parameter_list|()
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tokenbuf
argument_list|,
literal|"_GEN_%d"
argument_list|,
name|gensym
operator|++
argument_list|)
expr_stmt|;
return|return
name|stabent
argument_list|(
name|tokenbuf
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* hopefully this is only called on local symbol table entries */
end_comment

begin_function
name|void
name|stab_clear
parameter_list|(
name|stab
parameter_list|)
specifier|register
name|STAB
modifier|*
name|stab
decl_stmt|;
block|{
name|STIO
modifier|*
name|stio
decl_stmt|;
name|SUBR
modifier|*
name|sub
decl_stmt|;
if|if
condition|(
operator|!
name|stab
operator|||
operator|!
name|stab
operator|->
name|str_ptr
condition|)
return|return;
name|afree
argument_list|(
name|stab_xarray
argument_list|(
name|stab
argument_list|)
argument_list|)
expr_stmt|;
name|stab_xarray
argument_list|(
name|stab
argument_list|)
operator|=
name|Null
argument_list|(
name|ARRAY
operator|*
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|hfree
argument_list|(
name|stab_xhash
argument_list|(
name|stab
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|stab_xhash
argument_list|(
name|stab
argument_list|)
operator|=
name|Null
argument_list|(
name|HASH
operator|*
argument_list|)
expr_stmt|;
name|str_free
argument_list|(
name|stab_val
argument_list|(
name|stab
argument_list|)
argument_list|)
expr_stmt|;
name|stab_val
argument_list|(
name|stab
argument_list|)
operator|=
name|Nullstr
expr_stmt|;
comment|/*SUPPRESS 560*/
if|if
condition|(
name|stio
operator|=
name|stab_io
argument_list|(
name|stab
argument_list|)
condition|)
block|{
name|do_close
argument_list|(
name|stab
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|stio
operator|->
name|top_name
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|stio
operator|->
name|fmt_name
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|stio
argument_list|)
expr_stmt|;
block|}
comment|/*SUPPRESS 560*/
if|if
condition|(
name|sub
operator|=
name|stab_sub
argument_list|(
name|stab
argument_list|)
condition|)
block|{
name|afree
argument_list|(
name|sub
operator|->
name|tosave
argument_list|)
expr_stmt|;
name|cmd_free
argument_list|(
name|sub
operator|->
name|cmd
argument_list|)
expr_stmt|;
block|}
name|Safefree
argument_list|(
name|stab
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
name|stab
operator|->
name|str_ptr
operator|=
name|Null
argument_list|(
name|STBP
operator|*
argument_list|)
expr_stmt|;
name|stab
operator|->
name|str_len
operator|=
literal|0
expr_stmt|;
name|stab
operator|->
name|str_cur
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CRIPPLED_CC
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|iAPX286
argument_list|)
operator|||
name|defined
argument_list|(
name|M_I286
argument_list|)
operator|||
name|defined
argument_list|(
name|I80286
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|MICROPORT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MICROPORT
end_ifdef

begin_comment
comment|/* Microport 2.4 hack */
end_comment

begin_function
name|ARRAY
modifier|*
name|stab_array
parameter_list|(
name|stab
parameter_list|)
specifier|register
name|STAB
modifier|*
name|stab
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|(
name|STBP
operator|*
operator|)
operator|(
name|stab
operator|->
name|str_ptr
operator|)
operator|)
operator|->
name|stbp_array
condition|)
return|return
operator|(
operator|(
name|STBP
operator|*
operator|)
operator|(
name|stab
operator|->
name|str_ptr
operator|)
operator|)
operator|->
name|stbp_array
return|;
else|else
return|return
operator|(
operator|(
name|STBP
operator|*
operator|)
operator|(
name|aadd
argument_list|(
name|stab
argument_list|)
operator|->
name|str_ptr
operator|)
operator|)
operator|->
name|stbp_array
return|;
block|}
end_function

begin_function
name|HASH
modifier|*
name|stab_hash
parameter_list|(
name|stab
parameter_list|)
specifier|register
name|STAB
modifier|*
name|stab
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|(
name|STBP
operator|*
operator|)
operator|(
name|stab
operator|->
name|str_ptr
operator|)
operator|)
operator|->
name|stbp_hash
condition|)
return|return
operator|(
operator|(
name|STBP
operator|*
operator|)
operator|(
name|stab
operator|->
name|str_ptr
operator|)
operator|)
operator|->
name|stbp_hash
return|;
else|else
return|return
operator|(
operator|(
name|STBP
operator|*
operator|)
operator|(
name|hadd
argument_list|(
name|stab
argument_list|)
operator|->
name|str_ptr
operator|)
operator|)
operator|->
name|stbp_hash
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Microport 2.4 hack */
end_comment

end_unit

