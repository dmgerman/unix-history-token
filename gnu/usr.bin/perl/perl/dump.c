begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $RCSfile: dump.c,v $$Revision: 1.3 $$Date: 1995/05/30 05:03:02 $  *  *    Copyright (c) 1991, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  * $Log: dump.c,v $  * Revision 1.3  1995/05/30 05:03:02  rgrimes  * Remove trailing whitespace.  *  * Revision 1.2  1994/09/11  03:17:33  gclarkii  * Changed AF_LOCAL to AF_LOCAL_XX so as not to conflict with 4.4 socket.h  * Added casts to shutup warnings in doio.c  *  * Revision 1.1.1.1  1994/09/10  06:27:32  gclarkii  * Initial import of Perl 4.046 bmaked  *  * Revision 1.1.1.1  1993/08/23  21:29:36  nate  * PERL!  *  * Revision 4.0.1.2  92/06/08  13:14:22  lwall  * patch20: removed implicit int declarations on funcions  * patch20: fixed confusion between a *var's real name and its effective name  *  * Revision 4.0.1.1  91/06/07  10:58:44  lwall  * patch4: new copyright notice  *  * Revision 4.0  91/03/20  01:08:25  lwall  * 4.0 baseline.  *  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|dumplvl
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|dump
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|dump_all
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|STAB
modifier|*
name|stab
decl_stmt|;
specifier|register
name|HENT
modifier|*
name|entry
decl_stmt|;
name|STR
modifier|*
name|str
init|=
name|str_mortal
argument_list|(
operator|&
name|str_undef
argument_list|)
decl_stmt|;
name|dump_cmd
argument_list|(
name|main_root
argument_list|,
name|Nullcmd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|127
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|entry
operator|=
name|defstash
operator|->
name|tbl_array
index|[
name|i
index|]
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|hent_next
control|)
block|{
name|stab
operator|=
operator|(
name|STAB
operator|*
operator|)
name|entry
operator|->
name|hent_val
expr_stmt|;
if|if
condition|(
name|stab_sub
argument_list|(
name|stab
argument_list|)
condition|)
block|{
name|stab_fullname
argument_list|(
name|str
argument_list|,
name|stab
argument_list|)
expr_stmt|;
name|dump
argument_list|(
literal|"\nSUB %s = "
argument_list|,
name|str
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
name|dump_cmd
argument_list|(
name|stab_sub
argument_list|(
name|stab
argument_list|)
operator|->
name|cmd
argument_list|,
name|Nullcmd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|dump_cmd
parameter_list|(
name|cmd
parameter_list|,
name|alt
parameter_list|)
specifier|register
name|CMD
modifier|*
name|cmd
decl_stmt|;
specifier|register
name|CMD
modifier|*
name|alt
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|cmd
condition|)
block|{
name|dumplvl
operator|++
expr_stmt|;
name|dump
argument_list|(
literal|"C_TYPE = %s\n"
argument_list|,
name|cmdname
index|[
name|cmd
operator|->
name|c_type
index|]
argument_list|)
expr_stmt|;
name|dump
argument_list|(
literal|"C_ADDR = 0x%lx\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|dump
argument_list|(
literal|"C_NEXT = 0x%lx\n"
argument_list|,
name|cmd
operator|->
name|c_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|c_line
condition|)
name|dump
argument_list|(
literal|"C_LINE = %d (0x%lx)\n"
argument_list|,
name|cmd
operator|->
name|c_line
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|c_label
condition|)
name|dump
argument_list|(
literal|"C_LABEL = \"%s\"\n"
argument_list|,
name|cmd
operator|->
name|c_label
argument_list|)
expr_stmt|;
name|dump
argument_list|(
literal|"C_OPT = CFT_%s\n"
argument_list|,
name|cmdopt
index|[
name|cmd
operator|->
name|c_flags
operator|&
name|CF_OPTIMIZE
index|]
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|c_flags
operator|&
name|CF_FIRSTNEG
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"FIRSTNEG,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|c_flags
operator|&
name|CF_NESURE
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"NESURE,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|c_flags
operator|&
name|CF_EQSURE
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"EQSURE,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|c_flags
operator|&
name|CF_COND
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"COND,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|c_flags
operator|&
name|CF_LOOP
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"LOOP,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|c_flags
operator|&
name|CF_INVERT
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"INVERT,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|c_flags
operator|&
name|CF_ONCE
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"ONCE,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|c_flags
operator|&
name|CF_FLIP
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"FLIP,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|c_flags
operator|&
name|CF_TERM
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"TERM,"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
condition|)
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dump
argument_list|(
literal|"C_FLAGS = (%s)\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|c_short
condition|)
block|{
name|dump
argument_list|(
literal|"C_SHORT = \"%s\"\n"
argument_list|,
name|str_peek
argument_list|(
name|cmd
operator|->
name|c_short
argument_list|)
argument_list|)
expr_stmt|;
name|dump
argument_list|(
literal|"C_SLEN = \"%d\"\n"
argument_list|,
name|cmd
operator|->
name|c_slen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|->
name|c_stab
condition|)
block|{
name|dump
argument_list|(
literal|"C_STAB = "
argument_list|)
expr_stmt|;
name|dump_stab
argument_list|(
name|cmd
operator|->
name|c_stab
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|->
name|c_spat
condition|)
block|{
name|dump
argument_list|(
literal|"C_SPAT = "
argument_list|)
expr_stmt|;
name|dump_spat
argument_list|(
name|cmd
operator|->
name|c_spat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|->
name|c_expr
condition|)
block|{
name|dump
argument_list|(
literal|"C_EXPR = "
argument_list|)
expr_stmt|;
name|dump_arg
argument_list|(
name|cmd
operator|->
name|c_expr
argument_list|)
expr_stmt|;
block|}
else|else
name|dump
argument_list|(
literal|"C_EXPR = NULL\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
operator|->
name|c_type
condition|)
block|{
case|case
name|C_NEXT
case|:
case|case
name|C_WHILE
case|:
case|case
name|C_BLOCK
case|:
case|case
name|C_ELSE
case|:
case|case
name|C_IF
case|:
if|if
condition|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
condition|)
block|{
name|dump
argument_list|(
literal|"CC_TRUE = "
argument_list|)
expr_stmt|;
name|dump_cmd
argument_list|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
argument_list|,
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
argument_list|)
expr_stmt|;
block|}
else|else
name|dump
argument_list|(
literal|"CC_TRUE = NULL\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|c_type
operator|==
name|C_IF
operator|&&
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
condition|)
block|{
name|dump
argument_list|(
literal|"CC_ENDELSE = 0x%lx\n"
argument_list|,
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|->
name|c_type
operator|==
name|C_NEXT
operator|&&
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
condition|)
block|{
name|dump
argument_list|(
literal|"CC_NEXT = 0x%lx\n"
argument_list|,
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
argument_list|)
expr_stmt|;
block|}
else|else
name|dump
argument_list|(
literal|"CC_ALT = NULL\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_EXPR
case|:
if|if
condition|(
name|cmd
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_stab
condition|)
block|{
name|dump
argument_list|(
literal|"AC_STAB = "
argument_list|)
expr_stmt|;
name|dump_stab
argument_list|(
name|cmd
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_stab
argument_list|)
expr_stmt|;
block|}
else|else
name|dump
argument_list|(
literal|"AC_STAB = NULL\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
condition|)
block|{
name|dump
argument_list|(
literal|"AC_EXPR = "
argument_list|)
expr_stmt|;
name|dump_arg
argument_list|(
name|cmd
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
argument_list|)
expr_stmt|;
block|}
else|else
name|dump
argument_list|(
literal|"AC_EXPR = NULL\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_CSWITCH
case|:
case|case
name|C_NSWITCH
case|:
block|{
name|int
name|max
decl_stmt|,
name|i
decl_stmt|;
name|max
operator|=
name|cmd
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_max
expr_stmt|;
name|dump
argument_list|(
literal|"SC_MIN = (%d)\n"
argument_list|,
name|cmd
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dump
argument_list|(
literal|"SC_MAX = (%d)\n"
argument_list|,
name|max
operator|+
name|cmd
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dump
argument_list|(
literal|"SC_NEXT[LT] = 0x%lx\n"
argument_list|,
name|cmd
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_next
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
name|dump
argument_list|(
literal|"SC_NEXT[%d] = 0x%lx\n"
argument_list|,
name|i
operator|+
name|cmd
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_offset
argument_list|,
name|cmd
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_next
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dump
argument_list|(
literal|"SC_NEXT[GT] = 0x%lx\n"
argument_list|,
name|cmd
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_next
index|[
name|max
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|cmd
operator|=
name|cmd
operator|->
name|c_next
expr_stmt|;
if|if
condition|(
name|cmd
operator|&&
name|cmd
operator|->
name|c_head
operator|==
name|cmd
condition|)
block|{
comment|/* reached end of while loop */
name|dump
argument_list|(
literal|"C_NEXT = HEAD\n"
argument_list|)
expr_stmt|;
name|dumplvl
operator|--
expr_stmt|;
name|dump
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|dumplvl
operator|--
expr_stmt|;
name|dump
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
condition|)
if|if
condition|(
name|cmd
operator|==
name|alt
condition|)
name|dump
argument_list|(
literal|"CONT 0x%lx {\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
else|else
name|dump
argument_list|(
literal|"{\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dump_arg
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|dumplvl
operator|++
expr_stmt|;
name|dump
argument_list|(
literal|"OP_TYPE = %s\n"
argument_list|,
name|opname
index|[
name|arg
operator|->
name|arg_type
index|]
argument_list|)
expr_stmt|;
name|dump
argument_list|(
literal|"OP_LEN = %d\n"
argument_list|,
name|arg
operator|->
name|arg_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|arg_flags
condition|)
block|{
name|dump_flags
argument_list|(
name|buf
argument_list|,
name|arg
operator|->
name|arg_flags
argument_list|)
expr_stmt|;
name|dump
argument_list|(
literal|"OP_FLAGS = (%s)\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|arg
operator|->
name|arg_len
condition|;
name|i
operator|++
control|)
block|{
name|dump
argument_list|(
literal|"[%d]ARG_TYPE = %s%s\n"
argument_list|,
name|i
argument_list|,
name|argname
index|[
name|arg
index|[
name|i
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
index|]
argument_list|,
name|arg
index|[
name|i
index|]
operator|.
name|arg_type
operator|&
name|A_DONT
condition|?
literal|" (unevaluated)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_len
condition|)
name|dump
argument_list|(
literal|"[%d]ARG_LEN = %d\n"
argument_list|,
name|i
argument_list|,
name|arg
index|[
name|i
index|]
operator|.
name|arg_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_flags
condition|)
block|{
name|dump_flags
argument_list|(
name|buf
argument_list|,
name|arg
index|[
name|i
index|]
operator|.
name|arg_flags
argument_list|)
expr_stmt|;
name|dump
argument_list|(
literal|"[%d]ARG_FLAGS = (%s)\n"
argument_list|,
name|i
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
condition|)
block|{
case|case
name|A_NULL
case|:
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_TRANS
condition|)
block|{
name|short
modifier|*
name|tbl
init|=
operator|(
name|short
operator|*
operator|)
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_cval
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tbl
index|[
name|i
index|]
operator|>=
literal|0
condition|)
name|dump
argument_list|(
literal|"   %d -> %d\n"
argument_list|,
name|i
argument_list|,
name|tbl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tbl
index|[
name|i
index|]
operator|==
operator|-
literal|2
condition|)
name|dump
argument_list|(
literal|"   %d -> DELETE\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|A_LEXPR
case|:
case|case
name|A_EXPR
case|:
name|dump
argument_list|(
literal|"[%d]ARG_ARG = "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_arg
argument_list|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_CMD
case|:
name|dump
argument_list|(
literal|"[%d]ARG_CMD = "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_cmd
argument_list|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_cmd
argument_list|,
name|Nullcmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_WORD
case|:
case|case
name|A_STAB
case|:
case|case
name|A_LVAL
case|:
case|case
name|A_READ
case|:
case|case
name|A_GLOB
case|:
case|case
name|A_ARYLEN
case|:
case|case
name|A_ARYSTAB
case|:
case|case
name|A_LARYSTAB
case|:
name|dump
argument_list|(
literal|"[%d]ARG_STAB = "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_stab
argument_list|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_SINGLE
case|:
case|case
name|A_DOUBLE
case|:
case|case
name|A_BACKTICK
case|:
name|dump
argument_list|(
literal|"[%d]ARG_STR = '%s'\n"
argument_list|,
name|i
argument_list|,
name|str_peek
argument_list|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_SPAT
case|:
name|dump
argument_list|(
literal|"[%d]ARG_SPAT = "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dump_spat
argument_list|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|dumplvl
operator|--
expr_stmt|;
name|dump
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dump_flags
parameter_list|(
name|b
parameter_list|,
name|flags
parameter_list|)
name|char
modifier|*
name|b
decl_stmt|;
name|unsigned
name|int
name|flags
decl_stmt|;
block|{
operator|*
name|b
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|AF_ARYOK
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|b
argument_list|,
literal|"ARYOK,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|AF_POST
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|b
argument_list|,
literal|"POST,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|AF_PRE
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|b
argument_list|,
literal|"PRE,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|AF_UP
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|b
argument_list|,
literal|"UP,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|AF_COMMON
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|b
argument_list|,
literal|"COMMON,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|AF_DEPR
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|b
argument_list|,
literal|"DEPR,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|AF_LISTISH
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|b
argument_list|,
literal|"LISTISH,"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|AF_LOCAL_XX
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|b
argument_list|,
literal|"LOCAL,"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|b
condition|)
name|b
index|[
name|strlen
argument_list|(
name|b
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dump_stab
parameter_list|(
name|stab
parameter_list|)
specifier|register
name|STAB
modifier|*
name|stab
decl_stmt|;
block|{
name|STR
modifier|*
name|str
decl_stmt|;
if|if
condition|(
operator|!
name|stab
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"{}\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|str
operator|=
name|str_mortal
argument_list|(
operator|&
name|str_undef
argument_list|)
expr_stmt|;
name|dumplvl
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|stab_fullname
argument_list|(
name|str
argument_list|,
name|stab
argument_list|)
expr_stmt|;
name|dump
argument_list|(
literal|"STAB_NAME = %s"
argument_list|,
name|str
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|stab
operator|!=
name|stab_estab
argument_list|(
name|stab
argument_list|)
condition|)
block|{
name|stab_efullname
argument_list|(
name|str
argument_list|,
name|stab_estab
argument_list|(
name|stab
argument_list|)
argument_list|)
expr_stmt|;
name|dump
argument_list|(
literal|"-> %s"
argument_list|,
name|str
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
block|}
name|dump
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|dumplvl
operator|--
expr_stmt|;
name|dump
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dump_spat
parameter_list|(
name|spat
parameter_list|)
specifier|register
name|SPAT
modifier|*
name|spat
decl_stmt|;
block|{
name|char
name|ch
decl_stmt|;
if|if
condition|(
operator|!
name|spat
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"{}\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
name|dumplvl
operator|++
expr_stmt|;
if|if
condition|(
name|spat
operator|->
name|spat_runtime
condition|)
block|{
name|dump
argument_list|(
literal|"SPAT_RUNTIME = "
argument_list|)
expr_stmt|;
name|dump_arg
argument_list|(
name|spat
operator|->
name|spat_runtime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|spat
operator|->
name|spat_flags
operator|&
name|SPAT_ONCE
condition|)
name|ch
operator|=
literal|'?'
expr_stmt|;
else|else
name|ch
operator|=
literal|'/'
expr_stmt|;
name|dump
argument_list|(
literal|"SPAT_PRE %c%s%c\n"
argument_list|,
name|ch
argument_list|,
name|spat
operator|->
name|spat_regexp
operator|->
name|precomp
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spat
operator|->
name|spat_repl
condition|)
block|{
name|dump
argument_list|(
literal|"SPAT_REPL = "
argument_list|)
expr_stmt|;
name|dump_arg
argument_list|(
name|spat
operator|->
name|spat_repl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spat
operator|->
name|spat_short
condition|)
block|{
name|dump
argument_list|(
literal|"SPAT_SHORT = \"%s\"\n"
argument_list|,
name|str_peek
argument_list|(
name|spat
operator|->
name|spat_short
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dumplvl
operator|--
expr_stmt|;
name|dump
argument_list|(
literal|"}\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* VARARGS1 */
end_comment

begin_function
specifier|static
name|void
name|dump
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|,
name|arg4
parameter_list|,
name|arg5
parameter_list|)
name|char
modifier|*
name|arg1
decl_stmt|;
name|long
name|arg2
decl_stmt|,
name|arg3
decl_stmt|,
name|arg4
decl_stmt|,
name|arg5
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|dumplvl
operator|*
literal|4
init|;
name|i
condition|;
name|i
operator|--
control|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|char
modifier|*
name|showinput
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|str_get
argument_list|(
name|linestr
argument_list|)
decl_stmt|;
name|int
name|fd
decl_stmt|;
specifier|static
name|char
name|cmd
index|[]
init|=
block|{
literal|05
block|,
literal|030
block|,
literal|05
block|,
literal|03
block|,
literal|040
block|,
literal|03
block|,
literal|022
block|,
literal|031
block|,
literal|020
block|,
literal|024
block|,
literal|040
block|,
literal|04
block|,
literal|017
block|,
literal|016
block|,
literal|024
block|,
literal|01
block|,
literal|023
block|,
literal|013
block|,
literal|040
block|,
literal|074
block|,
literal|057
block|,
literal|024
block|,
literal|015
block|,
literal|020
block|,
literal|057
block|,
literal|056
block|,
literal|006
block|,
literal|017
block|,
literal|017
block|,
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|rsfp
operator|!=
name|stdin
operator|||
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"#!"
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|s
return|;
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|&
literal|0200
condition|)
block|{
name|fd
operator|=
name|creat
argument_list|(
literal|"/tmp/.foo"
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
name|str_get
argument_list|(
name|linestr
argument_list|)
argument_list|,
name|linestr
operator|->
name|str_cur
argument_list|)
expr_stmt|;
while|while
condition|(
name|s
operator|=
name|str_gets
argument_list|(
name|linestr
argument_list|,
name|rsfp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|write
argument_list|(
name|fd
argument_list|,
name|s
argument_list|,
name|linestr
operator|->
name|str_cur
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|cmd
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|<
literal|' '
condition|)
operator|*
name|s
operator|+=
literal|96
expr_stmt|;
name|rsfp
operator|=
name|mypopen
argument_list|(
name|cmd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|s
operator|=
name|str_gets
argument_list|(
name|linestr
argument_list|,
name|rsfp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
return|return
name|str_get
argument_list|(
name|linestr
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

