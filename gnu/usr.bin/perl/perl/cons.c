begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $RCSfile: cons.c,v $$Revision: 1.2 $$Date: 1995/05/30 05:02:56 $  *  *    Copyright (c) 1991, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  * $Log: cons.c,v $  * Revision 1.2  1995/05/30 05:02:56  rgrimes  * Remove trailing whitespace.  *  * Revision 1.1.1.1  1994/09/10  06:27:32  gclarkii  * Initial import of Perl 4.046 bmaked  *  * Revision 1.1.1.1  1993/08/23  21:29:35  nate  * PERL!  *  * Revision 4.0.1.4  1993/02/05  19:30:15  lwall  * patch36: fixed various little coredump bugs  *  * Revision 4.0.1.3  92/06/08  12:18:35  lwall  * patch20: removed implicit int declarations on funcions  * patch20: deleted some minor memory leaks  * patch20: fixed double debug break in foreach with implicit array assignment  * patch20: fixed confusion between a *var's real name and its effective name  * patch20: Perl now distinguishes overlapped copies from non-overlapped  * patch20: debugger sometimes displayed wrong source line  * patch20: various error messages have been clarified  * patch20: an eval block containing a null block or statement could dump core  *  * Revision 4.0.1.2  91/11/05  16:15:13  lwall  * patch11: debugger got confused over nested subroutine definitions  * patch11: prepared for ctype implementations that don't define isascii()  *  * Revision 4.0.1.1  91/06/07  10:31:15  lwall  * patch4: new copyright notice  * patch4: added global modifier for pattern matches  *  * Revision 4.0  91/03/20  01:05:51  lwall  * 4.0 baseline.  *  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_include
include|#
directive|include
file|"perly.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tokename
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|yychar
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|cmd_tosave
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arg_tosave
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spat_tosave
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_cswitch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_nswitch
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|bool
name|saw_return
decl_stmt|;
end_decl_stmt

begin_function
name|SUBR
modifier|*
name|make_sub
parameter_list|(
name|name
parameter_list|,
name|cmd
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|CMD
modifier|*
name|cmd
decl_stmt|;
block|{
specifier|register
name|SUBR
modifier|*
name|sub
decl_stmt|;
name|STAB
modifier|*
name|stab
init|=
name|stabent
argument_list|(
name|name
argument_list|,
name|TRUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|sub
operator|=
name|stab_sub
argument_list|(
name|stab
argument_list|)
condition|)
block|{
if|if
condition|(
name|dowarn
condition|)
block|{
name|CMD
modifier|*
name|oldcurcmd
init|=
name|curcmd
decl_stmt|;
if|if
condition|(
name|cmd
condition|)
name|curcmd
operator|=
name|cmd
expr_stmt|;
name|warn
argument_list|(
literal|"Subroutine %s redefined"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|curcmd
operator|=
name|oldcurcmd
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sub
operator|->
name|usersub
operator|&&
name|sub
operator|->
name|cmd
condition|)
block|{
name|cmd_free
argument_list|(
name|sub
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|sub
operator|->
name|cmd
operator|=
name|Nullcmd
expr_stmt|;
name|afree
argument_list|(
name|sub
operator|->
name|tosave
argument_list|)
expr_stmt|;
block|}
name|Safefree
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
name|Newz
argument_list|(
literal|101
argument_list|,
name|sub
argument_list|,
literal|1
argument_list|,
name|SUBR
argument_list|)
expr_stmt|;
name|stab_sub
argument_list|(
name|stab
argument_list|)
operator|=
name|sub
expr_stmt|;
name|sub
operator|->
name|filestab
operator|=
name|curcmd
operator|->
name|c_filestab
expr_stmt|;
name|saw_return
operator|=
name|FALSE
expr_stmt|;
name|tosave
operator|=
name|anew
argument_list|(
name|Nullstab
argument_list|)
expr_stmt|;
name|tosave
operator|->
name|ary_fill
operator|=
literal|0
expr_stmt|;
comment|/* make 1 based */
operator|(
name|void
operator|)
name|cmd_tosave
argument_list|(
name|cmd
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* this builds the tosave array */
name|sub
operator|->
name|tosave
operator|=
name|tosave
expr_stmt|;
if|if
condition|(
name|saw_return
condition|)
block|{
name|struct
name|compcmd
name|mycompblock
decl_stmt|;
name|mycompblock
operator|.
name|comp_true
operator|=
name|cmd
expr_stmt|;
name|mycompblock
operator|.
name|comp_alt
operator|=
name|Nullcmd
expr_stmt|;
name|cmd
operator|=
name|add_label
argument_list|(
name|savestr
argument_list|(
literal|"_SUB_"
argument_list|)
argument_list|,
name|make_ccmd
argument_list|(
name|C_BLOCK
argument_list|,
literal|0
argument_list|,
name|Nullarg
argument_list|,
name|mycompblock
argument_list|)
argument_list|)
expr_stmt|;
name|saw_return
operator|=
name|FALSE
expr_stmt|;
name|cmd
operator|->
name|c_flags
operator||=
name|CF_TERM
expr_stmt|;
name|cmd
operator|->
name|c_head
operator|=
name|cmd
expr_stmt|;
block|}
name|sub
operator|->
name|cmd
operator|=
name|cmd
expr_stmt|;
if|if
condition|(
name|perldb
condition|)
block|{
name|STR
modifier|*
name|str
decl_stmt|;
name|STR
modifier|*
name|tmpstr
init|=
name|str_mortal
argument_list|(
operator|&
name|str_undef
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s:%ld"
argument_list|,
name|stab_val
argument_list|(
name|curcmd
operator|->
name|c_filestab
argument_list|)
operator|->
name|str_ptr
argument_list|,
name|subline
argument_list|)
expr_stmt|;
name|str
operator|=
name|str_make
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|str
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|curcmd
operator|->
name|c_line
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|str
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|stab_efullname
argument_list|(
name|tmpstr
argument_list|,
name|stab
argument_list|)
expr_stmt|;
name|hstore
argument_list|(
name|stab_xhash
argument_list|(
name|DBsub
argument_list|)
argument_list|,
name|tmpstr
operator|->
name|str_ptr
argument_list|,
name|tmpstr
operator|->
name|str_cur
argument_list|,
name|str
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|Safefree
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|sub
return|;
block|}
end_function

begin_decl_stmt
name|SUBR
modifier|*
name|make_usub
argument_list|(
name|name
argument_list|,
name|ix
argument_list|,
name|subaddr
argument_list|,
name|filename
argument_list|)
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ix
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|subaddr
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|SUBR
modifier|*
name|sub
decl_stmt|;
name|STAB
modifier|*
name|stab
init|=
name|stabent
argument_list|(
name|name
argument_list|,
name|allstabs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|stab
condition|)
comment|/* unused function */
return|return
name|Null
argument_list|(
name|SUBR
operator|*
argument_list|)
return|;
if|if
condition|(
name|sub
operator|=
name|stab_sub
argument_list|(
name|stab
argument_list|)
condition|)
block|{
if|if
condition|(
name|dowarn
condition|)
name|warn
argument_list|(
literal|"Subroutine %s redefined"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sub
operator|->
name|usersub
operator|&&
name|sub
operator|->
name|cmd
condition|)
block|{
name|cmd_free
argument_list|(
name|sub
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|sub
operator|->
name|cmd
operator|=
name|Nullcmd
expr_stmt|;
name|afree
argument_list|(
name|sub
operator|->
name|tosave
argument_list|)
expr_stmt|;
block|}
name|Safefree
argument_list|(
name|sub
argument_list|)
expr_stmt|;
block|}
name|Newz
argument_list|(
literal|101
argument_list|,
name|sub
argument_list|,
literal|1
argument_list|,
name|SUBR
argument_list|)
expr_stmt|;
name|stab_sub
argument_list|(
name|stab
argument_list|)
operator|=
name|sub
expr_stmt|;
name|sub
operator|->
name|filestab
operator|=
name|fstab
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|sub
operator|->
name|usersub
operator|=
name|subaddr
expr_stmt|;
name|sub
operator|->
name|userindex
operator|=
name|ix
expr_stmt|;
return|return
name|sub
return|;
block|}
end_block

begin_function
name|void
name|make_form
parameter_list|(
name|stab
parameter_list|,
name|fcmd
parameter_list|)
name|STAB
modifier|*
name|stab
decl_stmt|;
name|FCMD
modifier|*
name|fcmd
decl_stmt|;
block|{
if|if
condition|(
name|stab_form
argument_list|(
name|stab
argument_list|)
condition|)
block|{
name|FCMD
modifier|*
name|tmpfcmd
decl_stmt|;
name|FCMD
modifier|*
name|nextfcmd
decl_stmt|;
for|for
control|(
name|tmpfcmd
operator|=
name|stab_form
argument_list|(
name|stab
argument_list|)
init|;
name|tmpfcmd
condition|;
name|tmpfcmd
operator|=
name|nextfcmd
control|)
block|{
name|nextfcmd
operator|=
name|tmpfcmd
operator|->
name|f_next
expr_stmt|;
if|if
condition|(
name|tmpfcmd
operator|->
name|f_expr
condition|)
name|arg_free
argument_list|(
name|tmpfcmd
operator|->
name|f_expr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpfcmd
operator|->
name|f_unparsed
condition|)
name|str_free
argument_list|(
name|tmpfcmd
operator|->
name|f_unparsed
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpfcmd
operator|->
name|f_pre
condition|)
name|Safefree
argument_list|(
name|tmpfcmd
operator|->
name|f_pre
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|tmpfcmd
argument_list|)
expr_stmt|;
block|}
block|}
name|stab_form
argument_list|(
name|stab
argument_list|)
operator|=
name|fcmd
expr_stmt|;
block|}
end_function

begin_function
name|CMD
modifier|*
name|block_head
parameter_list|(
name|tail
parameter_list|)
specifier|register
name|CMD
modifier|*
name|tail
decl_stmt|;
block|{
name|CMD
modifier|*
name|head
decl_stmt|;
specifier|register
name|int
name|opt
decl_stmt|;
specifier|register
name|int
name|last_opt
init|=
literal|0
decl_stmt|;
specifier|register
name|STAB
modifier|*
name|last_stab
init|=
name|Nullstab
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|register
name|CMD
modifier|*
name|switchbeg
init|=
name|Nullcmd
decl_stmt|;
if|if
condition|(
name|tail
operator|==
name|Nullcmd
condition|)
block|{
return|return
name|tail
return|;
block|}
name|head
operator|=
name|tail
operator|->
name|c_head
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|head
init|;
name|tail
condition|;
name|tail
operator|=
name|tail
operator|->
name|c_next
control|)
block|{
comment|/* save one measly dereference at runtime */
if|if
condition|(
name|tail
operator|->
name|c_type
operator|==
name|C_IF
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|tail
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
operator|=
name|tail
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
operator|->
name|c_next
operator|)
condition|)
name|tail
operator|->
name|c_flags
operator||=
name|CF_TERM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tail
operator|->
name|c_type
operator|==
name|C_EXPR
condition|)
block|{
name|ARG
modifier|*
name|arg
decl_stmt|;
if|if
condition|(
name|tail
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
condition|)
name|arg
operator|=
name|tail
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
expr_stmt|;
else|else
name|arg
operator|=
name|tail
operator|->
name|c_expr
expr_stmt|;
if|if
condition|(
name|arg
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_RETURN
condition|)
name|tail
operator|->
name|c_flags
operator||=
name|CF_TERM
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_ITEM
operator|&&
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_CMD
condition|)
name|tail
operator|->
name|c_flags
operator||=
name|CF_TERM
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|tail
operator|->
name|c_next
condition|)
name|tail
operator|->
name|c_flags
operator||=
name|CF_TERM
expr_stmt|;
if|if
condition|(
name|tail
operator|->
name|c_expr
operator|&&
operator|(
name|tail
operator|->
name|c_flags
operator|&
name|CF_OPTIMIZE
operator|)
operator|==
name|CFT_FALSE
condition|)
name|opt_arg
argument_list|(
name|tail
argument_list|,
literal|1
argument_list|,
name|tail
operator|->
name|c_type
operator|==
name|C_EXPR
argument_list|)
expr_stmt|;
comment|/* now do a little optimization on case-ish structures */
switch|switch
condition|(
name|tail
operator|->
name|c_flags
operator|&
operator|(
name|CF_OPTIMIZE
operator||
name|CF_FIRSTNEG
operator||
name|CF_INVERT
operator|)
condition|)
block|{
case|case
name|CFT_ANCHOR
case|:
case|case
name|CFT_STROP
case|:
name|opt
operator|=
operator|(
name|tail
operator|->
name|c_flags
operator|&
name|CF_NESURE
operator|)
condition|?
name|CFT_STROP
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|CFT_CCLASS
case|:
name|opt
operator|=
name|CFT_STROP
expr_stmt|;
break|break;
case|case
name|CFT_NUMOP
case|:
name|opt
operator|=
operator|(
name|tail
operator|->
name|c_slen
operator|==
name|O_NE
condition|?
literal|0
else|:
name|CFT_NUMOP
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|tail
operator|->
name|c_flags
operator|&
operator|(
name|CF_NESURE
operator||
name|CF_EQSURE
operator|)
operator|)
operator|!=
operator|(
name|CF_NESURE
operator||
name|CF_EQSURE
operator|)
condition|)
name|opt
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|opt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|opt
operator|&&
name|opt
operator|==
name|last_opt
operator|&&
name|tail
operator|->
name|c_stab
operator|==
name|last_stab
condition|)
name|count
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|count
operator|>=
literal|3
condition|)
block|{
comment|/* is this the breakeven point? */
if|if
condition|(
name|last_opt
operator|==
name|CFT_NUMOP
condition|)
name|make_nswitch
argument_list|(
name|switchbeg
argument_list|,
name|count
argument_list|)
expr_stmt|;
else|else
name|make_cswitch
argument_list|(
name|switchbeg
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opt
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|switchbeg
operator|=
name|tail
expr_stmt|;
block|}
else|else
name|count
operator|=
literal|0
expr_stmt|;
block|}
name|last_opt
operator|=
name|opt
expr_stmt|;
name|last_stab
operator|=
name|tail
operator|->
name|c_stab
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>=
literal|3
condition|)
block|{
comment|/* is this the breakeven point? */
if|if
condition|(
name|last_opt
operator|==
name|CFT_NUMOP
condition|)
name|make_nswitch
argument_list|(
name|switchbeg
argument_list|,
name|count
argument_list|)
expr_stmt|;
else|else
name|make_cswitch
argument_list|(
name|switchbeg
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
return|return
name|head
return|;
block|}
end_function

begin_comment
comment|/* We've spotted a sequence of CMDs that all test the value of the same  * spat.  Thus we can insert a SWITCH in front and jump directly  * to the correct one.  */
end_comment

begin_function
specifier|static
name|void
name|make_cswitch
parameter_list|(
name|head
parameter_list|,
name|count
parameter_list|)
specifier|register
name|CMD
modifier|*
name|head
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
specifier|register
name|CMD
modifier|*
name|cur
decl_stmt|;
specifier|register
name|CMD
modifier|*
modifier|*
name|loc
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|min
init|=
literal|255
decl_stmt|;
specifier|register
name|int
name|max
init|=
literal|0
decl_stmt|;
comment|/* make a new head in the exact same spot */
name|New
argument_list|(
literal|102
argument_list|,
name|cur
argument_list|,
literal|1
argument_list|,
name|CMD
argument_list|)
expr_stmt|;
name|StructCopy
argument_list|(
name|head
argument_list|,
name|cur
argument_list|,
name|CMD
argument_list|)
expr_stmt|;
name|Zero
argument_list|(
name|head
argument_list|,
literal|1
argument_list|,
name|CMD
argument_list|)
expr_stmt|;
name|head
operator|->
name|c_head
operator|=
name|cur
operator|->
name|c_head
expr_stmt|;
name|head
operator|->
name|c_type
operator|=
name|C_CSWITCH
expr_stmt|;
name|head
operator|->
name|c_next
operator|=
name|cur
expr_stmt|;
comment|/* insert new cmd at front of list */
name|head
operator|->
name|c_stab
operator|=
name|cur
operator|->
name|c_stab
expr_stmt|;
name|Newz
argument_list|(
literal|103
argument_list|,
name|loc
argument_list|,
literal|258
argument_list|,
name|CMD
operator|*
argument_list|)
expr_stmt|;
name|loc
operator|++
expr_stmt|;
comment|/* lie a little */
while|while
condition|(
name|count
operator|--
condition|)
block|{
if|if
condition|(
operator|(
name|cur
operator|->
name|c_flags
operator|&
name|CF_OPTIMIZE
operator|)
operator|==
name|CFT_CCLASS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|255
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|loc
index|[
name|i
index|]
operator|&&
name|cur
operator|->
name|c_short
operator|->
name|str_ptr
index|[
name|i
operator|>>
literal|3
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|&
literal|7
operator|)
operator|)
condition|)
block|{
name|loc
index|[
name|i
index|]
operator|=
name|cur
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|min
condition|)
name|min
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|max
condition|)
name|max
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|i
operator|=
operator|*
name|cur
operator|->
name|c_short
operator|->
name|str_ptr
operator|&
literal|255
expr_stmt|;
if|if
condition|(
operator|!
name|loc
index|[
name|i
index|]
condition|)
block|{
name|loc
index|[
name|i
index|]
operator|=
name|cur
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|min
condition|)
name|min
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|max
condition|)
name|max
operator|=
name|i
expr_stmt|;
block|}
block|}
name|cur
operator|=
name|cur
operator|->
name|c_next
expr_stmt|;
block|}
name|max
operator|++
expr_stmt|;
if|if
condition|(
name|min
operator|>
literal|0
condition|)
name|Move
argument_list|(
operator|&
name|loc
index|[
name|min
index|]
argument_list|,
operator|&
name|loc
index|[
literal|0
index|]
argument_list|,
name|max
operator|-
name|min
argument_list|,
name|CMD
operator|*
argument_list|)
expr_stmt|;
name|loc
operator|--
expr_stmt|;
name|min
operator|--
expr_stmt|;
name|max
operator|-=
name|min
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|loc
index|[
name|i
index|]
condition|)
name|loc
index|[
name|i
index|]
operator|=
name|cur
expr_stmt|;
name|Renew
argument_list|(
name|loc
argument_list|,
name|max
operator|+
literal|1
argument_list|,
name|CMD
operator|*
argument_list|)
expr_stmt|;
comment|/* chop it down to size */
name|head
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_offset
operator|=
name|min
expr_stmt|;
name|head
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_max
operator|=
name|max
expr_stmt|;
name|head
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_next
operator|=
name|loc
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_nswitch
parameter_list|(
name|head
parameter_list|,
name|count
parameter_list|)
specifier|register
name|CMD
modifier|*
name|head
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
specifier|register
name|CMD
modifier|*
name|cur
init|=
name|head
decl_stmt|;
specifier|register
name|CMD
modifier|*
modifier|*
name|loc
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|min
init|=
literal|32767
decl_stmt|;
specifier|register
name|int
name|max
init|=
operator|-
literal|32768
decl_stmt|;
name|int
name|origcount
init|=
name|count
decl_stmt|;
name|double
name|value
decl_stmt|;
comment|/* or your money back! */
name|short
name|changed
decl_stmt|;
comment|/* so triple your money back! */
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|i
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|cur
operator|->
name|c_short
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|double
operator|)
name|i
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|cur
operator|->
name|c_short
operator|->
name|str_u
operator|.
name|str_nval
condition|)
return|return;
comment|/* fractional values--just forget it */
name|changed
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|changed
operator|!=
name|i
condition|)
return|return;
comment|/* too big for a short */
if|if
condition|(
name|cur
operator|->
name|c_slen
operator|==
name|O_LE
condition|)
name|i
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|cur
operator|->
name|c_slen
operator|==
name|O_GE
condition|)
comment|/* we only do< or> here */
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|min
condition|)
name|min
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|max
condition|)
name|max
operator|=
name|i
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|c_next
expr_stmt|;
block|}
name|count
operator|=
name|origcount
expr_stmt|;
if|if
condition|(
name|max
operator|-
name|min
operator|>
name|count
operator|*
literal|2
operator|+
literal|10
condition|)
comment|/* too sparse? */
return|return;
comment|/* now make a new head in the exact same spot */
name|New
argument_list|(
literal|104
argument_list|,
name|cur
argument_list|,
literal|1
argument_list|,
name|CMD
argument_list|)
expr_stmt|;
name|StructCopy
argument_list|(
name|head
argument_list|,
name|cur
argument_list|,
name|CMD
argument_list|)
expr_stmt|;
name|Zero
argument_list|(
name|head
argument_list|,
literal|1
argument_list|,
name|CMD
argument_list|)
expr_stmt|;
name|head
operator|->
name|c_head
operator|=
name|cur
operator|->
name|c_head
expr_stmt|;
name|head
operator|->
name|c_type
operator|=
name|C_NSWITCH
expr_stmt|;
name|head
operator|->
name|c_next
operator|=
name|cur
expr_stmt|;
comment|/* insert new cmd at front of list */
name|head
operator|->
name|c_stab
operator|=
name|cur
operator|->
name|c_stab
expr_stmt|;
name|Newz
argument_list|(
literal|105
argument_list|,
name|loc
argument_list|,
name|max
operator|-
name|min
operator|+
literal|3
argument_list|,
name|CMD
operator|*
argument_list|)
expr_stmt|;
name|loc
operator|++
expr_stmt|;
name|max
operator|-=
name|min
expr_stmt|;
name|max
operator|++
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|i
operator|=
operator|(
name|int
operator|)
name|str_gnum
argument_list|(
name|cur
operator|->
name|c_short
argument_list|)
expr_stmt|;
name|i
operator|-=
name|min
expr_stmt|;
switch|switch
condition|(
name|cur
operator|->
name|c_slen
condition|)
block|{
case|case
name|O_LE
case|:
name|i
operator|++
expr_stmt|;
case|case
name|O_LT
case|:
for|for
control|(
name|i
operator|--
init|;
name|i
operator|>=
operator|-
literal|1
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|loc
index|[
name|i
index|]
condition|)
name|loc
index|[
name|i
index|]
operator|=
name|cur
expr_stmt|;
break|break;
case|case
name|O_GE
case|:
name|i
operator|--
expr_stmt|;
case|case
name|O_GT
case|:
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|loc
index|[
name|i
index|]
condition|)
name|loc
index|[
name|i
index|]
operator|=
name|cur
expr_stmt|;
break|break;
case|case
name|O_EQ
case|:
if|if
condition|(
operator|!
name|loc
index|[
name|i
index|]
condition|)
name|loc
index|[
name|i
index|]
operator|=
name|cur
expr_stmt|;
break|break;
block|}
name|cur
operator|=
name|cur
operator|->
name|c_next
expr_stmt|;
block|}
name|loc
operator|--
expr_stmt|;
name|min
operator|--
expr_stmt|;
name|max
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|loc
index|[
name|i
index|]
condition|)
name|loc
index|[
name|i
index|]
operator|=
name|cur
expr_stmt|;
name|head
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_offset
operator|=
name|min
expr_stmt|;
name|head
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_max
operator|=
name|max
expr_stmt|;
name|head
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_next
operator|=
name|loc
expr_stmt|;
block|}
end_function

begin_function
name|CMD
modifier|*
name|append_line
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|)
specifier|register
name|CMD
modifier|*
name|head
decl_stmt|;
specifier|register
name|CMD
modifier|*
name|tail
decl_stmt|;
block|{
if|if
condition|(
name|tail
operator|==
name|Nullcmd
condition|)
return|return
name|head
return|;
if|if
condition|(
operator|!
name|tail
operator|->
name|c_head
condition|)
comment|/* make sure tail is well formed */
name|tail
operator|->
name|c_head
operator|=
name|tail
expr_stmt|;
if|if
condition|(
name|head
operator|!=
name|Nullcmd
condition|)
block|{
name|tail
operator|=
name|tail
operator|->
name|c_head
expr_stmt|;
comment|/* get to start of tail list */
if|if
condition|(
operator|!
name|head
operator|->
name|c_head
condition|)
name|head
operator|->
name|c_head
operator|=
name|head
expr_stmt|;
comment|/* start a new head list */
while|while
condition|(
name|head
operator|->
name|c_next
condition|)
block|{
name|head
operator|->
name|c_next
operator|->
name|c_head
operator|=
name|head
operator|->
name|c_head
expr_stmt|;
name|head
operator|=
name|head
operator|->
name|c_next
expr_stmt|;
comment|/* get to end of head list */
block|}
name|head
operator|->
name|c_next
operator|=
name|tail
expr_stmt|;
comment|/* link to end of old list */
name|tail
operator|->
name|c_head
operator|=
name|head
operator|->
name|c_head
expr_stmt|;
comment|/* propagate head pointer */
block|}
while|while
condition|(
name|tail
operator|->
name|c_next
condition|)
block|{
name|tail
operator|->
name|c_next
operator|->
name|c_head
operator|=
name|tail
operator|->
name|c_head
expr_stmt|;
name|tail
operator|=
name|tail
operator|->
name|c_next
expr_stmt|;
block|}
return|return
name|tail
return|;
block|}
end_function

begin_function
name|CMD
modifier|*
name|dodb
parameter_list|(
name|cur
parameter_list|)
name|CMD
modifier|*
name|cur
decl_stmt|;
block|{
specifier|register
name|CMD
modifier|*
name|cmd
decl_stmt|;
specifier|register
name|CMD
modifier|*
name|head
init|=
name|cur
operator|->
name|c_head
decl_stmt|;
name|STR
modifier|*
name|str
decl_stmt|;
if|if
condition|(
operator|!
name|head
condition|)
name|head
operator|=
name|cur
expr_stmt|;
if|if
condition|(
operator|!
name|head
operator|->
name|c_line
condition|)
return|return
name|cur
return|;
name|str
operator|=
name|afetch
argument_list|(
name|stab_xarray
argument_list|(
name|curcmd
operator|->
name|c_filestab
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|head
operator|->
name|c_line
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
operator|&
name|str_undef
operator|||
name|str
operator|->
name|str_nok
condition|)
return|return
name|cur
return|;
name|str
operator|->
name|str_u
operator|.
name|str_nval
operator|=
operator|(
name|double
operator|)
name|head
operator|->
name|c_line
expr_stmt|;
name|str
operator|->
name|str_nok
operator|=
literal|1
expr_stmt|;
name|Newz
argument_list|(
literal|106
argument_list|,
name|cmd
argument_list|,
literal|1
argument_list|,
name|CMD
argument_list|)
expr_stmt|;
name|str_magic
argument_list|(
name|str
argument_list|,
name|curcmd
operator|->
name|c_filestab
argument_list|,
literal|0
argument_list|,
name|Nullch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|str
operator|->
name|str_magic
operator|->
name|str_u
operator|.
name|str_cmd
operator|=
name|cmd
expr_stmt|;
name|cmd
operator|->
name|c_type
operator|=
name|C_EXPR
expr_stmt|;
name|cmd
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_stab
operator|=
name|Nullstab
expr_stmt|;
name|cmd
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
operator|=
name|Nullarg
expr_stmt|;
name|cmd
operator|->
name|c_expr
operator|=
name|make_op
argument_list|(
name|O_SUBR
argument_list|,
literal|2
argument_list|,
name|stab2arg
argument_list|(
name|A_WORD
argument_list|,
name|DBstab
argument_list|)
argument_list|,
name|Nullarg
argument_list|,
name|Nullarg
argument_list|)
expr_stmt|;
comment|/*SUPPRESS 53*/
name|cmd
operator|->
name|c_flags
operator||=
name|CF_COND
operator||
name|CF_DBSUB
operator||
name|CFT_D0
expr_stmt|;
name|cmd
operator|->
name|c_line
operator|=
name|head
operator|->
name|c_line
expr_stmt|;
name|cmd
operator|->
name|c_label
operator|=
name|head
operator|->
name|c_label
expr_stmt|;
name|cmd
operator|->
name|c_filestab
operator|=
name|curcmd
operator|->
name|c_filestab
expr_stmt|;
name|cmd
operator|->
name|c_stash
operator|=
name|curstash
expr_stmt|;
return|return
name|append_line
argument_list|(
name|cmd
argument_list|,
name|cur
argument_list|)
return|;
block|}
end_function

begin_function
name|CMD
modifier|*
name|make_acmd
parameter_list|(
name|type
parameter_list|,
name|stab
parameter_list|,
name|cond
parameter_list|,
name|arg
parameter_list|)
name|int
name|type
decl_stmt|;
name|STAB
modifier|*
name|stab
decl_stmt|;
name|ARG
modifier|*
name|cond
decl_stmt|;
name|ARG
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|CMD
modifier|*
name|cmd
decl_stmt|;
name|Newz
argument_list|(
literal|107
argument_list|,
name|cmd
argument_list|,
literal|1
argument_list|,
name|CMD
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|c_type
operator|=
name|type
expr_stmt|;
name|cmd
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_stab
operator|=
name|stab
expr_stmt|;
name|cmd
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
operator|=
name|arg
expr_stmt|;
name|cmd
operator|->
name|c_expr
operator|=
name|cond
expr_stmt|;
if|if
condition|(
name|cond
condition|)
name|cmd
operator|->
name|c_flags
operator||=
name|CF_COND
expr_stmt|;
if|if
condition|(
name|cmdline
operator|==
name|NOLINE
condition|)
name|cmd
operator|->
name|c_line
operator|=
name|curcmd
operator|->
name|c_line
expr_stmt|;
else|else
block|{
name|cmd
operator|->
name|c_line
operator|=
name|cmdline
expr_stmt|;
name|cmdline
operator|=
name|NOLINE
expr_stmt|;
block|}
name|cmd
operator|->
name|c_filestab
operator|=
name|curcmd
operator|->
name|c_filestab
expr_stmt|;
name|cmd
operator|->
name|c_stash
operator|=
name|curstash
expr_stmt|;
if|if
condition|(
name|perldb
condition|)
name|cmd
operator|=
name|dodb
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
name|cmd
return|;
block|}
end_function

begin_function
name|CMD
modifier|*
name|make_ccmd
parameter_list|(
name|type
parameter_list|,
name|debuggable
parameter_list|,
name|arg
parameter_list|,
name|cblock
parameter_list|)
name|int
name|type
decl_stmt|;
name|int
name|debuggable
decl_stmt|;
name|ARG
modifier|*
name|arg
decl_stmt|;
name|struct
name|compcmd
name|cblock
decl_stmt|;
block|{
specifier|register
name|CMD
modifier|*
name|cmd
decl_stmt|;
name|Newz
argument_list|(
literal|108
argument_list|,
name|cmd
argument_list|,
literal|1
argument_list|,
name|CMD
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|c_type
operator|=
name|type
expr_stmt|;
name|cmd
operator|->
name|c_expr
operator|=
name|arg
expr_stmt|;
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
operator|=
name|cblock
operator|.
name|comp_true
expr_stmt|;
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
operator|=
name|cblock
operator|.
name|comp_alt
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|cmd
operator|->
name|c_flags
operator||=
name|CF_COND
expr_stmt|;
if|if
condition|(
name|cmdline
operator|==
name|NOLINE
condition|)
name|cmd
operator|->
name|c_line
operator|=
name|curcmd
operator|->
name|c_line
expr_stmt|;
else|else
block|{
name|cmd
operator|->
name|c_line
operator|=
name|cmdline
expr_stmt|;
name|cmdline
operator|=
name|NOLINE
expr_stmt|;
block|}
name|cmd
operator|->
name|c_filestab
operator|=
name|curcmd
operator|->
name|c_filestab
expr_stmt|;
name|cmd
operator|->
name|c_stash
operator|=
name|curstash
expr_stmt|;
if|if
condition|(
name|perldb
operator|&&
name|debuggable
condition|)
name|cmd
operator|=
name|dodb
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
name|cmd
return|;
block|}
end_function

begin_function
name|CMD
modifier|*
name|make_icmd
parameter_list|(
name|type
parameter_list|,
name|arg
parameter_list|,
name|cblock
parameter_list|)
name|int
name|type
decl_stmt|;
name|ARG
modifier|*
name|arg
decl_stmt|;
name|struct
name|compcmd
name|cblock
decl_stmt|;
block|{
specifier|register
name|CMD
modifier|*
name|cmd
decl_stmt|;
specifier|register
name|CMD
modifier|*
name|alt
decl_stmt|;
specifier|register
name|CMD
modifier|*
name|cur
decl_stmt|;
specifier|register
name|CMD
modifier|*
name|head
decl_stmt|;
name|struct
name|compcmd
name|ncblock
decl_stmt|;
name|Newz
argument_list|(
literal|109
argument_list|,
name|cmd
argument_list|,
literal|1
argument_list|,
name|CMD
argument_list|)
expr_stmt|;
name|head
operator|=
name|cmd
expr_stmt|;
name|cmd
operator|->
name|c_type
operator|=
name|type
expr_stmt|;
name|cmd
operator|->
name|c_expr
operator|=
name|arg
expr_stmt|;
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
operator|=
name|cblock
operator|.
name|comp_true
expr_stmt|;
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
operator|=
name|cblock
operator|.
name|comp_alt
expr_stmt|;
if|if
condition|(
name|arg
condition|)
name|cmd
operator|->
name|c_flags
operator||=
name|CF_COND
expr_stmt|;
if|if
condition|(
name|cmdline
operator|==
name|NOLINE
condition|)
name|cmd
operator|->
name|c_line
operator|=
name|curcmd
operator|->
name|c_line
expr_stmt|;
else|else
block|{
name|cmd
operator|->
name|c_line
operator|=
name|cmdline
expr_stmt|;
name|cmdline
operator|=
name|NOLINE
expr_stmt|;
block|}
name|cmd
operator|->
name|c_filestab
operator|=
name|curcmd
operator|->
name|c_filestab
expr_stmt|;
name|cmd
operator|->
name|c_stash
operator|=
name|curstash
expr_stmt|;
name|cur
operator|=
name|cmd
expr_stmt|;
name|alt
operator|=
name|cblock
operator|.
name|comp_alt
expr_stmt|;
while|while
condition|(
name|alt
operator|&&
name|alt
operator|->
name|c_type
operator|==
name|C_ELSIF
condition|)
block|{
name|cur
operator|=
name|alt
expr_stmt|;
name|alt
operator|=
name|alt
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
expr_stmt|;
block|}
if|if
condition|(
name|alt
condition|)
block|{
comment|/* a real life ELSE at the end? */
name|ncblock
operator|.
name|comp_true
operator|=
name|alt
expr_stmt|;
name|ncblock
operator|.
name|comp_alt
operator|=
name|Nullcmd
expr_stmt|;
name|alt
operator|=
name|append_line
argument_list|(
name|cur
argument_list|,
name|make_ccmd
argument_list|(
name|C_ELSE
argument_list|,
literal|1
argument_list|,
name|Nullarg
argument_list|,
name|ncblock
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
operator|=
name|alt
expr_stmt|;
block|}
else|else
name|alt
operator|=
name|cur
expr_stmt|;
comment|/* no ELSE, so cur is proxy ELSE */
name|cur
operator|=
name|cmd
expr_stmt|;
while|while
condition|(
name|cmd
condition|)
block|{
comment|/* now point everyone at the ELSE */
name|cur
operator|=
name|cmd
expr_stmt|;
name|cmd
operator|=
name|cur
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
expr_stmt|;
name|cur
operator|->
name|c_head
operator|=
name|head
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|c_type
operator|==
name|C_ELSIF
condition|)
name|cur
operator|->
name|c_type
operator|=
name|C_IF
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|c_type
operator|==
name|C_IF
condition|)
name|cur
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
operator|=
name|alt
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|alt
condition|)
break|break;
name|cur
operator|->
name|c_next
operator|=
name|cmd
expr_stmt|;
block|}
if|if
condition|(
name|perldb
condition|)
name|cur
operator|=
name|dodb
argument_list|(
name|cur
argument_list|)
expr_stmt|;
return|return
name|cur
return|;
block|}
end_function

begin_function
name|void
name|opt_arg
parameter_list|(
name|cmd
parameter_list|,
name|fliporflop
parameter_list|,
name|acmd
parameter_list|)
specifier|register
name|CMD
modifier|*
name|cmd
decl_stmt|;
name|int
name|fliporflop
decl_stmt|;
name|int
name|acmd
decl_stmt|;
block|{
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
name|int
name|opt
init|=
name|CFT_EVAL
decl_stmt|;
name|int
name|sure
init|=
literal|0
decl_stmt|;
name|ARG
modifier|*
name|arg2
decl_stmt|;
name|int
name|context
init|=
literal|0
decl_stmt|;
comment|/* 0 = normal, 1 = before&&, 2 = before || */
name|int
name|flp
init|=
name|fliporflop
decl_stmt|;
if|if
condition|(
operator|!
name|cmd
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|arg
operator|=
name|cmd
operator|->
name|c_expr
operator|)
condition|)
block|{
name|cmd
operator|->
name|c_flags
operator|&=
operator|~
name|CF_COND
expr_stmt|;
return|return;
block|}
comment|/* Can we turn&& and || into if and unless? */
if|if
condition|(
name|acmd
operator|&&
operator|!
name|cmd
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
operator|&&
operator|!
operator|(
name|cmd
operator|->
name|c_flags
operator|&
name|CF_TERM
operator|)
operator|&&
operator|(
name|arg
operator|->
name|arg_type
operator|==
name|O_AND
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_OR
operator|)
condition|)
block|{
name|dehoist
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|&=
name|A_MASK
expr_stmt|;
comment|/* don't suppress eval */
name|dehoist
argument_list|(
name|arg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
operator|=
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
expr_stmt|;
name|cmd
operator|->
name|c_expr
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_OR
condition|)
name|cmd
operator|->
name|c_flags
operator|^=
name|CF_INVERT
expr_stmt|;
comment|/* || is like unless */
name|arg
operator|->
name|arg_len
operator|=
literal|0
expr_stmt|;
name|free_arg
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|cmd
operator|->
name|c_expr
expr_stmt|;
block|}
comment|/* Turn "if (!expr)" into "unless (expr)" */
if|if
condition|(
operator|!
operator|(
name|cmd
operator|->
name|c_flags
operator|&
name|CF_TERM
operator|)
condition|)
block|{
comment|/* unless return value wanted */
while|while
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_NOT
condition|)
block|{
name|dehoist
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|c_flags
operator|^=
name|CF_INVERT
expr_stmt|;
comment|/* flip sense of cmd */
name|cmd
operator|->
name|c_expr
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
expr_stmt|;
comment|/* hoist the rest of expr */
name|free_arg
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|arg
operator|=
name|cmd
operator|->
name|c_expr
expr_stmt|;
comment|/* here we go again */
block|}
block|}
if|if
condition|(
operator|!
name|arg
operator|->
name|arg_len
condition|)
block|{
comment|/* sanity check */
name|cmd
operator|->
name|c_flags
operator||=
name|opt
expr_stmt|;
return|return;
block|}
comment|/* for "cond .. cond" we set up for the initial check */
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_FLIP
condition|)
name|context
operator||=
literal|4
expr_stmt|;
comment|/* for "cond&& expr" and "cond || expr" we can ignore expr, sort of */
name|morecontext
label|:
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_AND
condition|)
name|context
operator||=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_OR
condition|)
name|context
operator||=
literal|2
expr_stmt|;
if|if
condition|(
name|context
operator|&&
operator|(
name|arg
index|[
name|flp
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_EXPR
condition|)
block|{
name|arg
operator|=
name|arg
index|[
name|flp
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
expr_stmt|;
name|flp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_AND
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_OR
condition|)
goto|goto
name|morecontext
goto|;
block|}
if|if
condition|(
operator|(
name|context
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
return|return;
if|if
condition|(
name|arg
index|[
name|flp
index|]
operator|.
name|arg_flags
operator|&
operator|(
name|AF_PRE
operator||
name|AF_POST
operator|)
condition|)
block|{
name|cmd
operator|->
name|c_flags
operator||=
name|opt
expr_stmt|;
if|if
condition|(
name|acmd
operator|&&
operator|!
name|cmd
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
operator|&&
operator|!
operator|(
name|cmd
operator|->
name|c_flags
operator|&
name|CF_TERM
operator|)
operator|&&
name|cmd
operator|->
name|c_expr
operator|->
name|arg_type
operator|==
name|O_ITEM
condition|)
block|{
name|arg
index|[
name|flp
index|]
operator|.
name|arg_flags
operator|&=
operator|~
name|AF_POST
expr_stmt|;
comment|/* prefer ++$foo to $foo++ */
name|arg
index|[
name|flp
index|]
operator|.
name|arg_flags
operator||=
name|AF_PRE
expr_stmt|;
comment|/*  if value not wanted */
block|}
return|return;
comment|/* side effect, can't optimize */
block|}
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_ITEM
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_FLIP
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_AND
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_OR
condition|)
block|{
if|if
condition|(
operator|(
name|arg
index|[
name|flp
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_SINGLE
condition|)
block|{
name|opt
operator|=
operator|(
name|str_true
argument_list|(
name|arg
index|[
name|flp
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
argument_list|)
condition|?
name|CFT_TRUE
else|:
name|CFT_FALSE
operator|)
expr_stmt|;
name|cmd
operator|->
name|c_short
operator|=
name|str_smake
argument_list|(
name|arg
index|[
name|flp
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
argument_list|)
expr_stmt|;
goto|goto
name|literal
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|arg
index|[
name|flp
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_STAB
operator|||
operator|(
name|arg
index|[
name|flp
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_LVAL
condition|)
block|{
name|cmd
operator|->
name|c_stab
operator|=
name|arg
index|[
name|flp
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
name|arg
index|[
name|flp
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
operator|=
name|Nullstab
expr_stmt|;
name|opt
operator|=
name|CFT_REG
expr_stmt|;
name|literal
label|:
if|if
condition|(
operator|!
name|context
condition|)
block|{
comment|/* no&& or ||? */
name|arg_free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|c_expr
operator|=
name|Nullarg
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|context
operator|&
literal|1
operator|)
condition|)
name|cmd
operator|->
name|c_flags
operator||=
name|CF_EQSURE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|context
operator|&
literal|2
operator|)
condition|)
name|cmd
operator|->
name|c_flags
operator||=
name|CF_NESURE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_MATCH
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_SUBST
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_NMATCH
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_NSUBST
condition|)
block|{
if|if
condition|(
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_STAB
operator|||
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_LVAL
operator|)
operator|&&
operator|(
name|arg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
operator|)
operator|==
name|A_SPAT
operator|&&
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
operator|->
name|spat_short
operator|&&
operator|(
name|arg
operator|->
name|arg_type
operator|==
name|O_SUBST
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_NSUBST
operator|||
operator|(
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
operator|->
name|spat_flags
operator|&
name|SPAT_GLOBAL
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|cmd
operator|->
name|c_stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
name|cmd
operator|->
name|c_short
operator|=
name|str_smake
argument_list|(
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
operator|->
name|spat_short
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|c_slen
operator|=
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
operator|->
name|spat_slen
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
operator|->
name|spat_flags
operator|&
name|SPAT_ALL
operator|&&
operator|!
operator|(
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
operator|->
name|spat_flags
operator|&
name|SPAT_ONCE
operator|)
operator|&&
operator|(
name|arg
operator|->
name|arg_type
operator|==
name|O_MATCH
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_NMATCH
operator|)
condition|)
name|sure
operator||=
name|CF_EQSURE
expr_stmt|;
comment|/* (SUBST must be forced even */
comment|/* if we know it will work.) */
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|!=
name|O_SUBST
condition|)
block|{
name|str_free
argument_list|(
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
operator|->
name|spat_short
argument_list|)
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
operator|->
name|spat_short
operator|=
name|Nullstr
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
operator|->
name|spat_slen
operator|=
literal|0
expr_stmt|;
comment|/* only one chk */
block|}
name|sure
operator||=
name|CF_NESURE
expr_stmt|;
comment|/* normally only sure if it fails */
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_NMATCH
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_NSUBST
condition|)
name|cmd
operator|->
name|c_flags
operator||=
name|CF_FIRSTNEG
expr_stmt|;
if|if
condition|(
name|context
operator|&
literal|1
condition|)
block|{
comment|/* only sure if thing is false */
if|if
condition|(
name|cmd
operator|->
name|c_flags
operator|&
name|CF_FIRSTNEG
condition|)
name|sure
operator|&=
operator|~
name|CF_NESURE
expr_stmt|;
else|else
name|sure
operator|&=
operator|~
name|CF_EQSURE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|context
operator|&
literal|2
condition|)
block|{
comment|/* only sure if thing is true */
if|if
condition|(
name|cmd
operator|->
name|c_flags
operator|&
name|CF_FIRSTNEG
condition|)
name|sure
operator|&=
operator|~
name|CF_EQSURE
expr_stmt|;
else|else
name|sure
operator|&=
operator|~
name|CF_NESURE
expr_stmt|;
block|}
if|if
condition|(
name|sure
operator|&
operator|(
name|CF_EQSURE
operator||
name|CF_NESURE
operator|)
condition|)
block|{
comment|/* if we know anything*/
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
operator|->
name|spat_flags
operator|&
name|SPAT_SCANFIRST
condition|)
name|opt
operator|=
name|CFT_SCAN
expr_stmt|;
else|else
name|opt
operator|=
name|CFT_ANCHOR
expr_stmt|;
if|if
condition|(
name|sure
operator|==
operator|(
name|CF_EQSURE
operator||
name|CF_NESURE
operator|)
comment|/* really sure? */
operator|&&
name|arg
operator|->
name|arg_type
operator|==
name|O_MATCH
operator|&&
name|context
operator|&
literal|4
operator|&&
name|fliporflop
operator|==
literal|1
condition|)
block|{
name|spat_free
argument_list|(
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
argument_list|)
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
operator|=
name|Nullspat
expr_stmt|;
comment|/* don't do twice */
block|}
else|else
name|cmd
operator|->
name|c_spat
operator|=
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
expr_stmt|;
name|cmd
operator|->
name|c_flags
operator||=
name|sure
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_SEQ
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_SNE
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_SLT
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_SGT
condition|)
block|{
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_STAB
operator|||
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_LVAL
condition|)
block|{
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|==
name|A_SINGLE
condition|)
block|{
comment|/*SUPPRESS 594*/
name|char
modifier|*
name|junk
init|=
name|str_get
argument_list|(
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
argument_list|)
decl_stmt|;
name|cmd
operator|->
name|c_stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
name|cmd
operator|->
name|c_short
operator|=
name|str_smake
argument_list|(
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|c_slen
operator|=
name|cmd
operator|->
name|c_short
operator|->
name|str_cur
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|arg
operator|->
name|arg_type
condition|)
block|{
case|case
name|O_SLT
case|:
case|case
name|O_SGT
case|:
name|sure
operator||=
name|CF_EQSURE
expr_stmt|;
name|cmd
operator|->
name|c_flags
operator||=
name|CF_FIRSTNEG
expr_stmt|;
break|break;
case|case
name|O_SNE
case|:
name|cmd
operator|->
name|c_flags
operator||=
name|CF_FIRSTNEG
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|O_SEQ
case|:
name|sure
operator||=
name|CF_NESURE
operator||
name|CF_EQSURE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|context
operator|&
literal|1
condition|)
block|{
comment|/* only sure if thing is false */
if|if
condition|(
name|cmd
operator|->
name|c_flags
operator|&
name|CF_FIRSTNEG
condition|)
name|sure
operator|&=
operator|~
name|CF_NESURE
expr_stmt|;
else|else
name|sure
operator|&=
operator|~
name|CF_EQSURE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|context
operator|&
literal|2
condition|)
block|{
comment|/* only sure if thing is true */
if|if
condition|(
name|cmd
operator|->
name|c_flags
operator|&
name|CF_FIRSTNEG
condition|)
name|sure
operator|&=
operator|~
name|CF_EQSURE
expr_stmt|;
else|else
name|sure
operator|&=
operator|~
name|CF_NESURE
expr_stmt|;
block|}
if|if
condition|(
name|sure
operator|&
operator|(
name|CF_EQSURE
operator||
name|CF_NESURE
operator|)
condition|)
block|{
name|opt
operator|=
name|CFT_STROP
expr_stmt|;
name|cmd
operator|->
name|c_flags
operator||=
name|sure
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_EQ
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_NE
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_LE
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_GE
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_LT
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_GT
condition|)
block|{
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_STAB
operator|||
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_LVAL
condition|)
block|{
if|if
condition|(
name|arg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|==
name|A_SINGLE
condition|)
block|{
name|cmd
operator|->
name|c_stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
if|if
condition|(
name|dowarn
condition|)
block|{
name|STR
modifier|*
name|str
init|=
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|str
operator|->
name|str_nok
operator|&&
operator|!
name|looks_like_number
argument_list|(
name|str
argument_list|)
operator|)
condition|)
name|warn
argument_list|(
literal|"Possible use of == on string value"
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|->
name|c_short
operator|=
name|str_nmake
argument_list|(
name|str_gnum
argument_list|(
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|c_slen
operator|=
name|arg
operator|->
name|arg_type
expr_stmt|;
name|sure
operator||=
name|CF_NESURE
operator||
name|CF_EQSURE
expr_stmt|;
if|if
condition|(
name|context
operator|&
literal|1
condition|)
block|{
comment|/* only sure if thing is false */
name|sure
operator|&=
operator|~
name|CF_EQSURE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|context
operator|&
literal|2
condition|)
block|{
comment|/* only sure if thing is true */
name|sure
operator|&=
operator|~
name|CF_NESURE
expr_stmt|;
block|}
if|if
condition|(
name|sure
operator|&
operator|(
name|CF_EQSURE
operator||
name|CF_NESURE
operator|)
condition|)
block|{
name|opt
operator|=
name|CFT_NUMOP
expr_stmt|;
name|cmd
operator|->
name|c_flags
operator||=
name|sure
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_ASSIGN
operator|&&
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_STAB
operator|||
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_LVAL
operator|)
operator|&&
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
operator|==
name|defstab
operator|&&
name|arg
index|[
literal|2
index|]
operator|.
name|arg_type
operator|==
name|A_EXPR
condition|)
block|{
name|arg2
operator|=
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
expr_stmt|;
if|if
condition|(
name|arg2
operator|->
name|arg_type
operator|==
name|O_ITEM
operator|&&
name|arg2
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_READ
condition|)
block|{
name|opt
operator|=
name|CFT_GETS
expr_stmt|;
name|cmd
operator|->
name|c_stab
operator|=
name|arg2
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|stab_io
argument_list|(
name|arg2
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
operator|->
name|flags
operator|&
name|IOF_ARGV
operator|)
condition|)
block|{
name|free_arg
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|=
name|Nullarg
expr_stmt|;
name|free_arg
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|c_expr
operator|=
name|Nullarg
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_CHOP
operator|&&
operator|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_STAB
operator|||
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_LVAL
operator|)
condition|)
block|{
name|opt
operator|=
name|CFT_CHOP
expr_stmt|;
name|cmd
operator|->
name|c_stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
name|free_arg
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|c_expr
operator|=
name|Nullarg
expr_stmt|;
block|}
if|if
condition|(
name|context
operator|&
literal|4
condition|)
name|opt
operator||=
name|CF_FLIP
expr_stmt|;
name|cmd
operator|->
name|c_flags
operator||=
name|opt
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|c_flags
operator|&
name|CF_FLIP
condition|)
block|{
if|if
condition|(
name|fliporflop
operator|==
literal|1
condition|)
block|{
name|arg
operator|=
name|cmd
operator|->
name|c_expr
expr_stmt|;
comment|/* get back to O_FLIP arg */
name|New
argument_list|(
literal|110
argument_list|,
name|arg
index|[
literal|3
index|]
operator|.
name|arg_ptr
operator|.
name|arg_cmd
argument_list|,
literal|1
argument_list|,
name|CMD
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|cmd
argument_list|,
name|arg
index|[
literal|3
index|]
operator|.
name|arg_ptr
operator|.
name|arg_cmd
argument_list|,
literal|1
argument_list|,
name|CMD
argument_list|)
expr_stmt|;
name|New
argument_list|(
literal|111
argument_list|,
name|arg
index|[
literal|4
index|]
operator|.
name|arg_ptr
operator|.
name|arg_cmd
argument_list|,
literal|1
argument_list|,
name|CMD
argument_list|)
expr_stmt|;
name|Copy
argument_list|(
name|cmd
argument_list|,
name|arg
index|[
literal|4
index|]
operator|.
name|arg_ptr
operator|.
name|arg_cmd
argument_list|,
literal|1
argument_list|,
name|CMD
argument_list|)
expr_stmt|;
name|opt_arg
argument_list|(
name|arg
index|[
literal|4
index|]
operator|.
name|arg_ptr
operator|.
name|arg_cmd
argument_list|,
literal|2
argument_list|,
name|acmd
argument_list|)
expr_stmt|;
name|arg
operator|->
name|arg_len
operator|=
literal|2
expr_stmt|;
comment|/* this is a lie */
block|}
else|else
block|{
if|if
condition|(
operator|(
name|opt
operator|&
name|CF_OPTIMIZE
operator|)
operator|==
name|CFT_EVAL
condition|)
name|cmd
operator|->
name|c_flags
operator|=
operator|(
name|cmd
operator|->
name|c_flags
operator|&
operator|~
name|CF_OPTIMIZE
operator|)
operator||
name|CFT_UNFLIP
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|CMD
modifier|*
name|add_label
parameter_list|(
name|lbl
parameter_list|,
name|cmd
parameter_list|)
name|char
modifier|*
name|lbl
decl_stmt|;
specifier|register
name|CMD
modifier|*
name|cmd
decl_stmt|;
block|{
if|if
condition|(
name|cmd
condition|)
name|cmd
operator|->
name|c_label
operator|=
name|lbl
expr_stmt|;
return|return
name|cmd
return|;
block|}
end_function

begin_function
name|CMD
modifier|*
name|addcond
parameter_list|(
name|cmd
parameter_list|,
name|arg
parameter_list|)
specifier|register
name|CMD
modifier|*
name|cmd
decl_stmt|;
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
block|{
name|cmd
operator|->
name|c_expr
operator|=
name|arg
expr_stmt|;
name|cmd
operator|->
name|c_flags
operator||=
name|CF_COND
expr_stmt|;
return|return
name|cmd
return|;
block|}
end_function

begin_function
name|CMD
modifier|*
name|addloop
parameter_list|(
name|cmd
parameter_list|,
name|arg
parameter_list|)
specifier|register
name|CMD
modifier|*
name|cmd
decl_stmt|;
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
block|{
name|void
name|while_io
parameter_list|()
function_decl|;
name|cmd
operator|->
name|c_expr
operator|=
name|arg
expr_stmt|;
name|cmd
operator|->
name|c_flags
operator||=
name|CF_COND
operator||
name|CF_LOOP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cmd
operator|->
name|c_flags
operator|&
name|CF_INVERT
operator|)
condition|)
name|while_io
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|/* add $_ =, if necessary */
if|if
condition|(
name|cmd
operator|->
name|c_type
operator|==
name|C_BLOCK
condition|)
name|cmd
operator|->
name|c_flags
operator|&=
operator|~
name|CF_COND
expr_stmt|;
else|else
block|{
name|arg
operator|=
name|cmd
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
expr_stmt|;
if|if
condition|(
name|arg
operator|&&
name|arg
operator|->
name|arg_type
operator|==
name|O_ITEM
operator|&&
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_CMD
condition|)
name|cmd
operator|->
name|c_flags
operator|&=
operator|~
name|CF_COND
expr_stmt|;
comment|/* "do {} while" happens at least once */
if|if
condition|(
name|arg
operator|&&
operator|(
name|arg
operator|->
name|arg_flags
operator|&
name|AF_DEPR
operator|)
operator|&&
operator|(
name|arg
operator|->
name|arg_type
operator|==
name|O_SUBR
operator|||
name|arg
operator|->
name|arg_type
operator|==
name|O_DBSUBR
operator|)
condition|)
name|cmd
operator|->
name|c_flags
operator|&=
operator|~
name|CF_COND
expr_stmt|;
comment|/* likewise for "do subr() while" */
block|}
return|return
name|cmd
return|;
block|}
end_function

begin_function
name|CMD
modifier|*
name|invert
parameter_list|(
name|cmd
parameter_list|)
name|CMD
modifier|*
name|cmd
decl_stmt|;
block|{
specifier|register
name|CMD
modifier|*
name|targ
init|=
name|cmd
decl_stmt|;
if|if
condition|(
name|targ
operator|->
name|c_head
condition|)
name|targ
operator|=
name|targ
operator|->
name|c_head
expr_stmt|;
if|if
condition|(
name|targ
operator|->
name|c_flags
operator|&
name|CF_DBSUB
condition|)
name|targ
operator|=
name|targ
operator|->
name|c_next
expr_stmt|;
name|targ
operator|->
name|c_flags
operator|^=
name|CF_INVERT
expr_stmt|;
return|return
name|cmd
return|;
block|}
end_function

begin_function
name|void
name|cpy7bit
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|l
parameter_list|)
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|l
decl_stmt|;
block|{
while|while
condition|(
name|l
operator|--
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
operator|&
literal|127
expr_stmt|;
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
name|int
name|yyerror
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
name|tmpbuf
index|[
literal|258
index|]
decl_stmt|;
name|char
name|tmp2buf
index|[
literal|258
index|]
decl_stmt|;
name|char
modifier|*
name|tname
init|=
name|tmpbuf
decl_stmt|;
if|if
condition|(
name|bufptr
operator|>
name|oldoldbufptr
operator|&&
name|bufptr
operator|-
name|oldoldbufptr
operator|<
literal|200
operator|&&
name|oldoldbufptr
operator|!=
name|oldbufptr
operator|&&
name|oldbufptr
operator|!=
name|bufptr
condition|)
block|{
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|oldoldbufptr
argument_list|)
condition|)
name|oldoldbufptr
operator|++
expr_stmt|;
name|cpy7bit
argument_list|(
name|tmp2buf
argument_list|,
name|oldoldbufptr
argument_list|,
name|bufptr
operator|-
name|oldoldbufptr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tname
argument_list|,
literal|"next 2 tokens \"%s\""
argument_list|,
name|tmp2buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bufptr
operator|>
name|oldbufptr
operator|&&
name|bufptr
operator|-
name|oldbufptr
operator|<
literal|200
operator|&&
name|oldbufptr
operator|!=
name|bufptr
condition|)
block|{
while|while
condition|(
name|isSPACE
argument_list|(
operator|*
name|oldbufptr
argument_list|)
condition|)
name|oldbufptr
operator|++
expr_stmt|;
name|cpy7bit
argument_list|(
name|tmp2buf
argument_list|,
name|oldbufptr
argument_list|,
name|bufptr
operator|-
name|oldbufptr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tname
argument_list|,
literal|"next token \"%s\""
argument_list|,
name|tmp2buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|yychar
operator|>
literal|256
condition|)
name|tname
operator|=
literal|"next token ???"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|yychar
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tname
argument_list|,
literal|"at EOF"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|yychar
operator|<
literal|32
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tname
argument_list|,
literal|"next char ^%c"
argument_list|,
name|yychar
operator|+
literal|64
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|yychar
operator|==
literal|127
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tname
argument_list|,
literal|"at EOF"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tname
argument_list|,
literal|"next char %c"
argument_list|,
name|yychar
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s in file %s at line %d, %s\n"
argument_list|,
name|s
argument_list|,
name|stab_val
argument_list|(
name|curcmd
operator|->
name|c_filestab
argument_list|)
operator|->
name|str_ptr
argument_list|,
name|curcmd
operator|->
name|c_line
argument_list|,
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|curcmd
operator|->
name|c_line
operator|==
name|multi_end
operator|&&
name|multi_start
operator|<
name|multi_end
condition|)
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"  (Might be a runaway multi-line %c%c string starting on line %d)\n"
argument_list|,
name|multi_open
argument_list|,
name|multi_close
argument_list|,
name|multi_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_eval
condition|)
name|str_cat
argument_list|(
name|stab_val
argument_list|(
name|stabent
argument_list|(
literal|"@"
argument_list|,
name|TRUE
argument_list|)
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
name|buf
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|error_count
operator|>=
literal|10
condition|)
name|fatal
argument_list|(
literal|"%s has too many errors.\n"
argument_list|,
name|stab_val
argument_list|(
name|curcmd
operator|->
name|c_filestab
argument_list|)
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|while_io
parameter_list|(
name|cmd
parameter_list|)
specifier|register
name|CMD
modifier|*
name|cmd
decl_stmt|;
block|{
specifier|register
name|ARG
modifier|*
name|arg
init|=
name|cmd
operator|->
name|c_expr
decl_stmt|;
name|STAB
modifier|*
name|asgnstab
decl_stmt|;
comment|/* hoist "while (<channel>)" up into command block */
if|if
condition|(
name|arg
operator|&&
name|arg
operator|->
name|arg_type
operator|==
name|O_ITEM
operator|&&
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_READ
condition|)
block|{
name|cmd
operator|->
name|c_flags
operator|&=
operator|~
name|CF_OPTIMIZE
expr_stmt|;
comment|/* clear optimization type */
name|cmd
operator|->
name|c_flags
operator||=
name|CFT_GETS
expr_stmt|;
comment|/* and set it to do the input */
name|cmd
operator|->
name|c_stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
if|if
condition|(
name|stab_io
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
operator|->
name|flags
operator|&
name|IOF_ARGV
condition|)
block|{
name|cmd
operator|->
name|c_expr
operator|=
name|l
argument_list|(
name|make_op
argument_list|(
name|O_ASSIGN
argument_list|,
literal|2
argument_list|,
comment|/* fake up "$_ =" */
name|stab2arg
argument_list|(
name|A_LVAL
argument_list|,
name|defstab
argument_list|)
argument_list|,
name|arg
argument_list|,
name|Nullarg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free_arg
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|c_expr
operator|=
name|Nullarg
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|arg
operator|&&
name|arg
operator|->
name|arg_type
operator|==
name|O_ITEM
operator|&&
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_INDREAD
condition|)
block|{
name|cmd
operator|->
name|c_flags
operator|&=
operator|~
name|CF_OPTIMIZE
expr_stmt|;
comment|/* clear optimization type */
name|cmd
operator|->
name|c_flags
operator||=
name|CFT_INDGETS
expr_stmt|;
comment|/* and set it to do the input */
name|cmd
operator|->
name|c_stab
operator|=
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
expr_stmt|;
name|free_arg
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|c_expr
operator|=
name|Nullarg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|&&
name|arg
operator|->
name|arg_type
operator|==
name|O_ITEM
operator|&&
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_GLOB
condition|)
block|{
if|if
condition|(
operator|(
name|cmd
operator|->
name|c_flags
operator|&
name|CF_OPTIMIZE
operator|)
operator|==
name|CFT_ARRAY
condition|)
name|asgnstab
operator|=
name|cmd
operator|->
name|c_stab
expr_stmt|;
else|else
name|asgnstab
operator|=
name|defstab
expr_stmt|;
name|cmd
operator|->
name|c_expr
operator|=
name|l
argument_list|(
name|make_op
argument_list|(
name|O_ASSIGN
argument_list|,
literal|2
argument_list|,
comment|/* fake up "$foo =" */
name|stab2arg
argument_list|(
name|A_LVAL
argument_list|,
name|asgnstab
argument_list|)
argument_list|,
name|arg
argument_list|,
name|Nullarg
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|c_flags
operator|&=
operator|~
name|CF_OPTIMIZE
expr_stmt|;
comment|/* clear optimization type */
block|}
block|}
end_function

begin_function
name|CMD
modifier|*
name|wopt
parameter_list|(
name|cmd
parameter_list|)
specifier|register
name|CMD
modifier|*
name|cmd
decl_stmt|;
block|{
specifier|register
name|CMD
modifier|*
name|tail
decl_stmt|;
name|CMD
modifier|*
name|newtail
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cmd
operator|->
name|c_expr
operator|&&
operator|(
name|cmd
operator|->
name|c_flags
operator|&
name|CF_OPTIMIZE
operator|)
operator|==
name|CFT_FALSE
condition|)
name|opt_arg
argument_list|(
name|cmd
argument_list|,
literal|1
argument_list|,
name|cmd
operator|->
name|c_type
operator|==
name|C_EXPR
argument_list|)
expr_stmt|;
name|while_io
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|/* add $_ =, if necessary */
comment|/* First find the end of the true list */
name|tail
operator|=
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|Nullcmd
condition|)
return|return
name|cmd
return|;
name|New
argument_list|(
literal|112
argument_list|,
name|newtail
argument_list|,
literal|1
argument_list|,
name|CMD
argument_list|)
expr_stmt|;
comment|/* guaranteed continue */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* optimize "next" to point directly to continue block */
if|if
condition|(
name|tail
operator|->
name|c_type
operator|==
name|C_EXPR
operator|&&
name|tail
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
operator|&&
name|tail
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
operator|->
name|arg_type
operator|==
name|O_NEXT
operator|&&
operator|(
name|tail
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
operator|->
name|arg_len
operator|==
literal|0
operator|||
operator|(
name|cmd
operator|->
name|c_label
operator|&&
name|strEQ
argument_list|(
name|cmd
operator|->
name|c_label
argument_list|,
name|tail
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
operator|->
name|str_ptr
argument_list|)
operator|)
operator|)
condition|)
block|{
name|arg_free
argument_list|(
name|tail
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
argument_list|)
expr_stmt|;
name|tail
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
operator|=
name|Nullarg
expr_stmt|;
name|tail
operator|->
name|c_type
operator|=
name|C_NEXT
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
operator|!=
name|Nullcmd
condition|)
name|tail
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
operator|=
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
expr_stmt|;
else|else
name|tail
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
operator|=
name|newtail
expr_stmt|;
name|tail
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
operator|=
name|Nullcmd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tail
operator|->
name|c_type
operator|==
name|C_IF
operator|&&
operator|!
name|tail
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
condition|)
block|{
if|if
condition|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
operator|!=
name|Nullcmd
condition|)
name|tail
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
operator|=
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
expr_stmt|;
else|else
name|tail
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
operator|=
name|newtail
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tail
operator|->
name|c_type
operator|==
name|C_CSWITCH
operator|||
name|tail
operator|->
name|c_type
operator|==
name|C_NSWITCH
condition|)
block|{
if|if
condition|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
operator|!=
name|Nullcmd
condition|)
block|{
for|for
control|(
name|i
operator|=
name|tail
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_max
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|tail
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_next
index|[
name|i
index|]
condition|)
name|tail
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_next
index|[
name|i
index|]
operator|=
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|tail
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_max
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|tail
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_next
index|[
name|i
index|]
condition|)
name|tail
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_next
index|[
name|i
index|]
operator|=
name|newtail
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|tail
operator|->
name|c_next
condition|)
break|break;
name|tail
operator|=
name|tail
operator|->
name|c_next
expr_stmt|;
block|}
comment|/* if there's a continue block, link it to true block and find end */
if|if
condition|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
operator|!=
name|Nullcmd
condition|)
block|{
name|tail
operator|->
name|c_next
operator|=
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
expr_stmt|;
name|tail
operator|=
name|tail
operator|->
name|c_next
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* optimize "next" to point directly to continue block */
if|if
condition|(
name|tail
operator|->
name|c_type
operator|==
name|C_EXPR
operator|&&
name|tail
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
operator|&&
name|tail
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
operator|->
name|arg_type
operator|==
name|O_NEXT
operator|&&
operator|(
name|tail
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
operator|->
name|arg_len
operator|==
literal|0
operator|||
operator|(
name|cmd
operator|->
name|c_label
operator|&&
name|strEQ
argument_list|(
name|cmd
operator|->
name|c_label
argument_list|,
name|tail
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
operator|->
name|str_ptr
argument_list|)
operator|)
operator|)
condition|)
block|{
name|arg_free
argument_list|(
name|tail
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
argument_list|)
expr_stmt|;
name|tail
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
operator|=
name|Nullarg
expr_stmt|;
name|tail
operator|->
name|c_type
operator|=
name|C_NEXT
expr_stmt|;
name|tail
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
operator|=
name|newtail
expr_stmt|;
name|tail
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
operator|=
name|Nullcmd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tail
operator|->
name|c_type
operator|==
name|C_IF
operator|&&
operator|!
name|tail
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
condition|)
block|{
name|tail
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
operator|=
name|newtail
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tail
operator|->
name|c_type
operator|==
name|C_CSWITCH
operator|||
name|tail
operator|->
name|c_type
operator|==
name|C_NSWITCH
condition|)
block|{
for|for
control|(
name|i
operator|=
name|tail
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_max
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
operator|!
name|tail
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_next
index|[
name|i
index|]
condition|)
name|tail
operator|->
name|ucmd
operator|.
name|scmd
operator|.
name|sc_next
index|[
name|i
index|]
operator|=
name|newtail
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tail
operator|->
name|c_next
condition|)
break|break;
name|tail
operator|=
name|tail
operator|->
name|c_next
expr_stmt|;
block|}
comment|/*SUPPRESS 530*/
for|for
control|(
init|;
name|tail
operator|->
name|c_next
condition|;
name|tail
operator|=
name|tail
operator|->
name|c_next
control|)
empty_stmt|;
block|}
comment|/* Here's the real trick: link the end of the list back to the beginning,      * inserting a "last" block to break out of the loop.  This saves one or      * two procedure calls every time through the loop, because of how cmd_exec      * does tail recursion.      */
name|tail
operator|->
name|c_next
operator|=
name|newtail
expr_stmt|;
name|tail
operator|=
name|newtail
expr_stmt|;
if|if
condition|(
operator|!
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
condition|)
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_alt
operator|=
name|tail
expr_stmt|;
comment|/* every loop has a continue now */
ifndef|#
directive|ifndef
name|lint
name|Copy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cmd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tail
argument_list|,
literal|1
argument_list|,
name|CMD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tail
operator|->
name|c_type
operator|=
name|C_EXPR
expr_stmt|;
name|tail
operator|->
name|c_flags
operator|^=
name|CF_INVERT
expr_stmt|;
comment|/* turn into "last unless" */
name|tail
operator|->
name|c_next
operator|=
name|tail
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
expr_stmt|;
comment|/* loop directly back to top */
name|tail
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
operator|=
name|make_op
argument_list|(
name|O_LAST
argument_list|,
literal|0
argument_list|,
name|Nullarg
argument_list|,
name|Nullarg
argument_list|,
name|Nullarg
argument_list|)
expr_stmt|;
name|tail
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_stab
operator|=
name|Nullstab
expr_stmt|;
return|return
name|cmd
return|;
block|}
end_function

begin_function
name|CMD
modifier|*
name|over
parameter_list|(
name|eachstab
parameter_list|,
name|cmd
parameter_list|)
name|STAB
modifier|*
name|eachstab
decl_stmt|;
specifier|register
name|CMD
modifier|*
name|cmd
decl_stmt|;
block|{
comment|/* hoist "for $foo (@bar)" up into command block */
name|cmd
operator|->
name|c_flags
operator|&=
operator|~
name|CF_OPTIMIZE
expr_stmt|;
comment|/* clear optimization type */
name|cmd
operator|->
name|c_flags
operator||=
name|CFT_ARRAY
expr_stmt|;
comment|/* and set it to do the iteration */
name|cmd
operator|->
name|c_stab
operator|=
name|eachstab
expr_stmt|;
name|cmd
operator|->
name|c_short
operator|=
name|Str_new
argument_list|(
literal|23
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* just to save a field in struct cmd */
name|cmd
operator|->
name|c_short
operator|->
name|str_u
operator|.
name|str_useful
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|cmd
return|;
block|}
end_function

begin_function
name|void
name|cmd_free
parameter_list|(
name|cmd
parameter_list|)
specifier|register
name|CMD
modifier|*
name|cmd
decl_stmt|;
block|{
specifier|register
name|CMD
modifier|*
name|tofree
decl_stmt|;
specifier|register
name|CMD
modifier|*
name|head
init|=
name|cmd
decl_stmt|;
if|if
condition|(
operator|!
name|cmd
condition|)
return|return;
if|if
condition|(
name|cmd
operator|->
name|c_head
operator|!=
name|cmd
condition|)
name|warn
argument_list|(
literal|"Malformed cmd links\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|cmd
condition|)
block|{
if|if
condition|(
name|cmd
operator|->
name|c_type
operator|!=
name|C_WHILE
condition|)
block|{
comment|/* WHILE block is duplicated */
if|if
condition|(
name|cmd
operator|->
name|c_label
condition|)
block|{
name|Safefree
argument_list|(
name|cmd
operator|->
name|c_label
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|c_label
operator|=
name|Nullch
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|->
name|c_short
condition|)
block|{
name|str_free
argument_list|(
name|cmd
operator|->
name|c_short
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|c_short
operator|=
name|Nullstr
expr_stmt|;
block|}
if|if
condition|(
name|cmd
operator|->
name|c_expr
condition|)
block|{
name|arg_free
argument_list|(
name|cmd
operator|->
name|c_expr
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|c_expr
operator|=
name|Nullarg
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|cmd
operator|->
name|c_type
condition|)
block|{
case|case
name|C_WHILE
case|:
case|case
name|C_BLOCK
case|:
case|case
name|C_ELSE
case|:
case|case
name|C_IF
case|:
if|if
condition|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
condition|)
block|{
name|cmd_free
argument_list|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
operator|=
name|Nullcmd
expr_stmt|;
block|}
break|break;
case|case
name|C_EXPR
case|:
if|if
condition|(
name|cmd
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
condition|)
block|{
name|arg_free
argument_list|(
name|cmd
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
operator|=
name|Nullarg
expr_stmt|;
block|}
break|break;
block|}
name|tofree
operator|=
name|cmd
expr_stmt|;
name|cmd
operator|=
name|cmd
operator|->
name|c_next
expr_stmt|;
if|if
condition|(
name|tofree
operator|!=
name|head
condition|)
comment|/* to get Saber to shut up */
name|Safefree
argument_list|(
name|tofree
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|&&
name|cmd
operator|==
name|head
condition|)
comment|/* reached end of while loop */
break|break;
block|}
name|Safefree
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arg_free
parameter_list|(
name|arg
parameter_list|)
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|arg
operator|->
name|arg_len
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
condition|)
block|{
case|case
name|A_NULL
case|:
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_TRANS
condition|)
block|{
name|Safefree
argument_list|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_cval
argument_list|)
expr_stmt|;
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_cval
operator|=
name|Nullch
expr_stmt|;
block|}
break|break;
case|case
name|A_LEXPR
case|:
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_AASSIGN
operator|&&
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|->
name|arg_type
operator|==
name|O_LARRAY
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|stab_name
argument_list|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
decl_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
literal|"_GEN_"
argument_list|,
name|name
argument_list|,
literal|5
argument_list|)
condition|)
comment|/* array for foreach */
name|hdelete
argument_list|(
name|defstash
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* FALL THROUGH */
case|case
name|A_EXPR
case|:
name|arg_free
argument_list|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
argument_list|)
expr_stmt|;
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|=
name|Nullarg
expr_stmt|;
break|break;
case|case
name|A_CMD
case|:
name|cmd_free
argument_list|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_cmd
argument_list|)
expr_stmt|;
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_cmd
operator|=
name|Nullcmd
expr_stmt|;
break|break;
case|case
name|A_WORD
case|:
case|case
name|A_STAB
case|:
case|case
name|A_LVAL
case|:
case|case
name|A_READ
case|:
case|case
name|A_GLOB
case|:
case|case
name|A_ARYLEN
case|:
case|case
name|A_LARYLEN
case|:
case|case
name|A_ARYSTAB
case|:
case|case
name|A_LARYSTAB
case|:
break|break;
case|case
name|A_SINGLE
case|:
case|case
name|A_DOUBLE
case|:
case|case
name|A_BACKTICK
case|:
name|str_free
argument_list|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
argument_list|)
expr_stmt|;
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_str
operator|=
name|Nullstr
expr_stmt|;
break|break;
case|case
name|A_SPAT
case|:
name|spat_free
argument_list|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
argument_list|)
expr_stmt|;
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
operator|=
name|Nullspat
expr_stmt|;
break|break;
block|}
block|}
name|free_arg
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spat_free
parameter_list|(
name|spat
parameter_list|)
specifier|register
name|SPAT
modifier|*
name|spat
decl_stmt|;
block|{
specifier|register
name|SPAT
modifier|*
name|sp
decl_stmt|;
name|HENT
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
operator|!
name|spat
condition|)
return|return;
if|if
condition|(
name|spat
operator|->
name|spat_runtime
condition|)
block|{
name|arg_free
argument_list|(
name|spat
operator|->
name|spat_runtime
argument_list|)
expr_stmt|;
name|spat
operator|->
name|spat_runtime
operator|=
name|Nullarg
expr_stmt|;
block|}
if|if
condition|(
name|spat
operator|->
name|spat_repl
condition|)
block|{
name|arg_free
argument_list|(
name|spat
operator|->
name|spat_repl
argument_list|)
expr_stmt|;
name|spat
operator|->
name|spat_repl
operator|=
name|Nullarg
expr_stmt|;
block|}
if|if
condition|(
name|spat
operator|->
name|spat_short
condition|)
block|{
name|str_free
argument_list|(
name|spat
operator|->
name|spat_short
argument_list|)
expr_stmt|;
name|spat
operator|->
name|spat_short
operator|=
name|Nullstr
expr_stmt|;
block|}
if|if
condition|(
name|spat
operator|->
name|spat_regexp
condition|)
block|{
name|regfree
argument_list|(
name|spat
operator|->
name|spat_regexp
argument_list|)
expr_stmt|;
name|spat
operator|->
name|spat_regexp
operator|=
name|Null
argument_list|(
name|REGEXP
operator|*
argument_list|)
expr_stmt|;
block|}
comment|/* now unlink from spat list */
for|for
control|(
name|entry
operator|=
name|defstash
operator|->
name|tbl_array
index|[
literal|'_'
index|]
init|;
name|entry
condition|;
name|entry
operator|=
name|entry
operator|->
name|hent_next
control|)
block|{
specifier|register
name|HASH
modifier|*
name|stash
decl_stmt|;
name|STAB
modifier|*
name|stab
init|=
operator|(
name|STAB
operator|*
operator|)
name|entry
operator|->
name|hent_val
decl_stmt|;
if|if
condition|(
operator|!
name|stab
condition|)
continue|continue;
name|stash
operator|=
name|stab_hash
argument_list|(
name|stab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stash
operator|||
name|stash
operator|->
name|tbl_spatroot
operator|==
name|Null
argument_list|(
name|SPAT
operator|*
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|stash
operator|->
name|tbl_spatroot
operator|==
name|spat
condition|)
name|stash
operator|->
name|tbl_spatroot
operator|=
name|spat
operator|->
name|spat_next
expr_stmt|;
else|else
block|{
for|for
control|(
name|sp
operator|=
name|stash
operator|->
name|tbl_spatroot
init|;
name|sp
operator|&&
name|sp
operator|->
name|spat_next
operator|!=
name|spat
condition|;
name|sp
operator|=
name|sp
operator|->
name|spat_next
control|)
comment|/*SUPPRESS 530*/
empty_stmt|;
if|if
condition|(
name|sp
condition|)
name|sp
operator|->
name|spat_next
operator|=
name|spat
operator|->
name|spat_next
expr_stmt|;
block|}
block|}
name|Safefree
argument_list|(
name|spat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Recursively descend a command sequence and push the address of any string  * that needs saving on recursion onto the tosave array.  */
end_comment

begin_function
specifier|static
name|int
name|cmd_tosave
parameter_list|(
name|cmd
parameter_list|,
name|willsave
parameter_list|)
specifier|register
name|CMD
modifier|*
name|cmd
decl_stmt|;
name|int
name|willsave
decl_stmt|;
comment|/* willsave passes down the tree */
block|{
specifier|register
name|CMD
modifier|*
name|head
init|=
name|cmd
decl_stmt|;
name|int
name|shouldsave
init|=
name|FALSE
decl_stmt|;
comment|/* shouldsave passes up the tree */
name|int
name|tmpsave
decl_stmt|;
specifier|register
name|CMD
modifier|*
name|lastcmd
init|=
name|Nullcmd
decl_stmt|;
while|while
condition|(
name|cmd
condition|)
block|{
if|if
condition|(
name|cmd
operator|->
name|c_expr
condition|)
name|shouldsave
operator||=
name|arg_tosave
argument_list|(
name|cmd
operator|->
name|c_expr
argument_list|,
name|willsave
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
operator|->
name|c_type
condition|)
block|{
case|case
name|C_WHILE
case|:
if|if
condition|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
condition|)
block|{
name|tmpsave
operator|=
name|cmd_tosave
argument_list|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
argument_list|,
name|willsave
argument_list|)
expr_stmt|;
comment|/* Here we check to see if the temporary array generated for 		 * a foreach needs to be localized because of recursion. 		 */
if|if
condition|(
name|tmpsave
operator|&&
operator|(
name|cmd
operator|->
name|c_flags
operator|&
name|CF_OPTIMIZE
operator|)
operator|==
name|CFT_ARRAY
condition|)
block|{
if|if
condition|(
name|lastcmd
operator|&&
name|lastcmd
operator|->
name|c_type
operator|==
name|C_EXPR
operator|&&
name|lastcmd
operator|->
name|c_expr
condition|)
block|{
name|ARG
modifier|*
name|arg
init|=
name|lastcmd
operator|->
name|c_expr
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|arg_type
operator|==
name|O_ASSIGN
operator|&&
name|arg
index|[
literal|1
index|]
operator|.
name|arg_type
operator|==
name|A_LEXPR
operator|&&
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
operator|->
name|arg_type
operator|==
name|O_LARRAY
operator|&&
name|strnEQ
argument_list|(
literal|"_GEN_"
argument_list|,
name|stab_name
argument_list|(
name|arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
index|[
literal|1
index|]
operator|.
name|arg_ptr
operator|.
name|arg_stab
argument_list|)
argument_list|,
literal|5
argument_list|)
condition|)
block|{
comment|/* array generated for foreach */
operator|(
name|void
operator|)
name|localize
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* in any event, save the iterator */
if|if
condition|(
name|cmd
operator|->
name|c_short
condition|)
comment|/* Better safe than sorry */
operator|(
name|void
operator|)
name|apush
argument_list|(
name|tosave
argument_list|,
name|cmd
operator|->
name|c_short
argument_list|)
expr_stmt|;
block|}
name|shouldsave
operator||=
name|tmpsave
expr_stmt|;
block|}
break|break;
case|case
name|C_BLOCK
case|:
case|case
name|C_ELSE
case|:
case|case
name|C_IF
case|:
if|if
condition|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
condition|)
name|shouldsave
operator||=
name|cmd_tosave
argument_list|(
name|cmd
operator|->
name|ucmd
operator|.
name|ccmd
operator|.
name|cc_true
argument_list|,
name|willsave
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_EXPR
case|:
if|if
condition|(
name|cmd
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
condition|)
name|shouldsave
operator||=
name|arg_tosave
argument_list|(
name|cmd
operator|->
name|ucmd
operator|.
name|acmd
operator|.
name|ac_expr
argument_list|,
name|willsave
argument_list|)
expr_stmt|;
break|break;
block|}
name|lastcmd
operator|=
name|cmd
expr_stmt|;
name|cmd
operator|=
name|cmd
operator|->
name|c_next
expr_stmt|;
if|if
condition|(
name|cmd
operator|&&
name|cmd
operator|==
name|head
condition|)
comment|/* reached end of while loop */
break|break;
block|}
return|return
name|shouldsave
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arg_tosave
parameter_list|(
name|arg
parameter_list|,
name|willsave
parameter_list|)
specifier|register
name|ARG
modifier|*
name|arg
decl_stmt|;
name|int
name|willsave
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|shouldsave
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|i
operator|=
name|arg
operator|->
name|arg_len
init|;
name|i
operator|>=
literal|1
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_type
operator|&
name|A_MASK
condition|)
block|{
case|case
name|A_NULL
case|:
break|break;
case|case
name|A_LEXPR
case|:
case|case
name|A_EXPR
case|:
name|shouldsave
operator||=
name|arg_tosave
argument_list|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_arg
argument_list|,
name|shouldsave
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_CMD
case|:
name|shouldsave
operator||=
name|cmd_tosave
argument_list|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_cmd
argument_list|,
name|shouldsave
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_WORD
case|:
case|case
name|A_STAB
case|:
case|case
name|A_LVAL
case|:
case|case
name|A_READ
case|:
case|case
name|A_GLOB
case|:
case|case
name|A_ARYLEN
case|:
case|case
name|A_SINGLE
case|:
case|case
name|A_DOUBLE
case|:
case|case
name|A_BACKTICK
case|:
break|break;
case|case
name|A_SPAT
case|:
name|shouldsave
operator||=
name|spat_tosave
argument_list|(
name|arg
index|[
name|i
index|]
operator|.
name|arg_ptr
operator|.
name|arg_spat
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|arg
operator|->
name|arg_type
condition|)
block|{
case|case
name|O_RETURN
case|:
name|saw_return
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|O_EVAL
case|:
case|case
name|O_SUBR
case|:
name|shouldsave
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|willsave
operator|&&
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
condition|)
operator|(
name|void
operator|)
name|apush
argument_list|(
name|tosave
argument_list|,
name|arg
operator|->
name|arg_ptr
operator|.
name|arg_str
argument_list|)
expr_stmt|;
return|return
name|shouldsave
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spat_tosave
parameter_list|(
name|spat
parameter_list|)
specifier|register
name|SPAT
modifier|*
name|spat
decl_stmt|;
block|{
name|int
name|shouldsave
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|spat
operator|->
name|spat_runtime
condition|)
name|shouldsave
operator||=
name|arg_tosave
argument_list|(
name|spat
operator|->
name|spat_runtime
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|spat
operator|->
name|spat_repl
condition|)
block|{
name|shouldsave
operator||=
name|arg_tosave
argument_list|(
name|spat
operator|->
name|spat_repl
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return
name|shouldsave
return|;
block|}
end_function

end_unit

