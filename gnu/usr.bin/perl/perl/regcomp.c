begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* NOTE: this is derived from Henry Spencer's regexp code, and should not  * confused with the original package (see point 3 below).  Thanks, Henry!  */
end_comment

begin_comment
comment|/* Additional note: this code is very heavily munged from Henry's version  * in places.  In some spots I've traded clarity for efficiency, so don't  * blame Henry for some of the lack of readability.  */
end_comment

begin_comment
comment|/* $RCSfile: regcomp.c,v $$Revision: 1.2 $$Date: 1995/05/30 05:03:14 $  *  * $Log: regcomp.c,v $  * Revision 1.2  1995/05/30 05:03:14  rgrimes  * Remove trailing whitespace.  *  * Revision 1.1.1.1  1994/09/10  06:27:33  gclarkii  * Initial import of Perl 4.046 bmaked  *  * Revision 1.1.1.1  1993/08/23  21:29:39  nate  * PERL!  *  * Revision 4.0.1.5  92/06/08  15:23:36  lwall  * patch20: Perl now distinguishes overlapped copies from non-overlapped  * patch20: /^stuff/ wrongly assumed an implicit $* == 1  * patch20: /x{0}/ was wrongly interpreted as /x{0,}/  * patch20: added \W, \S and \D inside /[...]/  *  * Revision 4.0.1.4  91/11/05  22:55:14  lwall  * patch11: Erratum  *  * Revision 4.0.1.3  91/11/05  18:22:28  lwall  * patch11: minimum match length calculation in regexp is now cumulative  * patch11: initial .* in pattern had dependency on value of $*  * patch11: certain patterns made use of garbage pointers from uncleared memory  * patch11: prepared for ctype implementations that don't define isascii()  *  * Revision 4.0.1.2  91/06/07  11:48:24  lwall  * patch4: new copyright notice  * patch4: /(x+) \1/ incorrectly optimized to not match "xxx xx"  * patch4: // wouldn't use previous pattern if it started with a null character  *  * Revision 4.0.1.1  91/04/12  09:04:45  lwall  * patch1: random cleanup in cpp namespace  *  * Revision 4.0  91/03/20  01:39:01  lwall  * 4.0 baseline.  *  */
end_comment

begin_comment
comment|/*SUPPRESS 112*/
end_comment

begin_comment
comment|/*  * regcomp and regexec -- regsub and regerror are not used in perl  *  *	Copyright (c) 1986 by University of Toronto.  *	Written by Henry Spencer.  Not derived from licensed software.  *  *	Permission is granted to anyone to use this software for any  *	purpose on any computer system, and to redistribute it freely,  *	subject to the following restrictions:  *  *	1. The author is not responsible for the consequences of use of  *		this software, no matter how awful, even if they arise  *		from defects in it.  *  *	2. The origin of this software must not be misrepresented, either  *		by explicit claim or by omission.  *  *	3. Altered versions must be plainly marked as such, and must not  *		be misrepresented as being the original software.  *  *  ****    Alterations to Henry's code are...  ****  ****    Copyright (c) 1991, Larry Wall  ****  ****    You may distribute under the terms of either the GNU General Public  ****    License or the Artistic License, as specified in the README file.   *  * Beware that some of this code is subtly aware of the way operator  * precedence is structured in regular expressions.  Serious changes in  * regular-expression syntax might require a total rethink.  */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"perl.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"regcomp.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BUGGY_MSC6
argument_list|)
end_if

begin_comment
comment|/* MSC 6.00A breaks on op/regexp.t test 85 unless we turn this off */
end_comment

begin_pragma
pragma|#
directive|pragma
name|optimize
name|(
literal|"a"
name|,
name|off
name|)
end_pragma

begin_comment
comment|/* But MSC 6.00A is happy with 'w', for aliases only across function calls*/
end_comment

begin_pragma
pragma|#
directive|pragma
name|optimize
name|(
literal|"w"
name|,
name|on
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BUGGY_MSC6 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STATIC
end_ifndef

begin_define
define|#
directive|define
name|STATIC
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ISMULT1
parameter_list|(
name|c
parameter_list|)
value|((c) == '*' || (c) == '+' || (c) == '?')
end_define

begin_define
define|#
directive|define
name|ISMULT2
parameter_list|(
name|s
parameter_list|)
value|((*s) == '*' || (*s) == '+' || (*s) == '?' || \ 	((*s) == '{'&& regcurly(s)))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|atarist
end_ifdef

begin_define
define|#
directive|define
name|PERL_META
value|"^$.[()|?+*\\"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|META
value|"^$.[()|?+*\\"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SPSTART
end_ifdef

begin_undef
undef|#
directive|undef
name|SPSTART
end_undef

begin_comment
comment|/* dratted cpp namespace... */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Flags to be passed up and down.  */
end_comment

begin_define
define|#
directive|define
name|HASWIDTH
value|01
end_define

begin_comment
comment|/* Known never to match null string. */
end_comment

begin_define
define|#
directive|define
name|SIMPLE
value|02
end_define

begin_comment
comment|/* Simple enough to be STAR/PLUS operand. */
end_comment

begin_define
define|#
directive|define
name|SPSTART
value|04
end_define

begin_comment
comment|/* Starts with * or +. */
end_comment

begin_define
define|#
directive|define
name|WORST
value|0
end_define

begin_comment
comment|/* Worst case. */
end_comment

begin_comment
comment|/*  * Global work variables for regcomp().  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|regprecomp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* uncompiled string. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|regparse
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Input-scan pointer. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|regxend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* End of input for compile */
end_comment

begin_decl_stmt
specifier|static
name|int
name|regnpar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* () count. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|regcode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Code-emit pointer;&regdummy = don't. */
end_comment

begin_decl_stmt
specifier|static
name|long
name|regsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Code size. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|regfold
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|regsawbracket
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Did we do {d,d} trick? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|regsawback
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Did we see \1, ...? */
end_comment

begin_comment
comment|/*  * Forward declarations for regcomp()'s friends.  */
end_comment

begin_function_decl
name|STATIC
name|int
name|regcurly
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|char
modifier|*
name|reg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|char
modifier|*
name|regbranch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|char
modifier|*
name|regpiece
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|char
modifier|*
name|regatom
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|char
modifier|*
name|regclass
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|char
modifier|*
name|regnode
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|char
modifier|*
name|reganode
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|regc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|reginsert
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|regtail
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|regoptail
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  - regcomp - compile a regular expression into internal code  *  * We can't allocate space until we know how big the compiled form will be,  * but we can't compile it (and thus know how big it is) until we've got a  * place to put the code.  So we cheat:  we compile it twice, once with code  * generation turned off and size counting turned on, and once "for real".  * This also means that we don't allocate space until we are sure that the  * thing really will compile successfully, and we never have to move the  * code and thus invalidate pointers into it.  (Note that it has to be in  * one piece because free() must be able to free it all.) [NB: not true in perl]  *  * Beware that the optimization-preparation code in here knows about some  * of the structure of the compiled regexp.  [I'll say.]  */
end_comment

begin_function
name|regexp
modifier|*
name|regcomp
parameter_list|(
name|exp
parameter_list|,
name|xend
parameter_list|,
name|fold
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
name|char
modifier|*
name|xend
decl_stmt|;
name|int
name|fold
decl_stmt|;
block|{
specifier|register
name|regexp
modifier|*
name|r
decl_stmt|;
specifier|register
name|char
modifier|*
name|scan
decl_stmt|;
specifier|register
name|STR
modifier|*
name|longish
decl_stmt|;
name|STR
modifier|*
name|longest
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|first
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|backish
decl_stmt|;
name|int
name|backest
decl_stmt|;
name|int
name|curback
decl_stmt|;
name|int
name|minlen
decl_stmt|;
name|int
name|sawplus
init|=
literal|0
decl_stmt|;
name|int
name|sawopen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|exp
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"NULL regexp argument"
argument_list|)
expr_stmt|;
comment|/* First pass: determine size, legality. */
name|regfold
operator|=
name|fold
expr_stmt|;
name|regparse
operator|=
name|exp
expr_stmt|;
name|regxend
operator|=
name|xend
expr_stmt|;
name|regprecomp
operator|=
name|nsavestr
argument_list|(
name|exp
argument_list|,
name|xend
operator|-
name|exp
argument_list|)
expr_stmt|;
name|regsawbracket
operator|=
literal|0
expr_stmt|;
name|regsawback
operator|=
literal|0
expr_stmt|;
name|regnpar
operator|=
literal|1
expr_stmt|;
name|regsize
operator|=
literal|0L
expr_stmt|;
name|regcode
operator|=
operator|&
name|regdummy
expr_stmt|;
name|regc
argument_list|(
operator|(
name|char
operator|)
name|MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
argument_list|(
literal|0
argument_list|,
operator|&
name|flags
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|Safefree
argument_list|(
name|regprecomp
argument_list|)
expr_stmt|;
name|regprecomp
operator|=
name|Nullch
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Small enough for pointer-storage convention? */
if|if
condition|(
name|regsize
operator|>=
literal|32767L
condition|)
comment|/* Probably could be 65535L. */
name|FAIL
argument_list|(
literal|"regexp too big"
argument_list|)
expr_stmt|;
comment|/* Allocate space. */
name|Newc
argument_list|(
literal|1001
argument_list|,
name|r
argument_list|,
sizeof|sizeof
argument_list|(
name|regexp
argument_list|)
operator|+
operator|(
name|unsigned
operator|)
name|regsize
argument_list|,
name|char
argument_list|,
name|regexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
name|FAIL
argument_list|(
literal|"regexp out of space"
argument_list|)
expr_stmt|;
comment|/* Second pass: emit code. */
if|if
condition|(
name|regsawbracket
condition|)
name|Copy
argument_list|(
name|regprecomp
argument_list|,
name|exp
argument_list|,
name|xend
operator|-
name|exp
argument_list|,
name|char
argument_list|)
expr_stmt|;
name|r
operator|->
name|prelen
operator|=
name|xend
operator|-
name|exp
expr_stmt|;
name|r
operator|->
name|precomp
operator|=
name|regprecomp
expr_stmt|;
name|r
operator|->
name|subbeg
operator|=
name|r
operator|->
name|subbase
operator|=
name|NULL
expr_stmt|;
name|regparse
operator|=
name|exp
expr_stmt|;
name|regnpar
operator|=
literal|1
expr_stmt|;
name|regcode
operator|=
name|r
operator|->
name|program
expr_stmt|;
name|regc
argument_list|(
operator|(
name|char
operator|)
name|MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
argument_list|(
literal|0
argument_list|,
operator|&
name|flags
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Dig out information for optimizations. */
name|r
operator|->
name|regstart
operator|=
name|Nullstr
expr_stmt|;
comment|/* Worst-case defaults. */
name|r
operator|->
name|reganch
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|regmust
operator|=
name|Nullstr
expr_stmt|;
name|r
operator|->
name|regback
operator|=
operator|-
literal|1
expr_stmt|;
name|r
operator|->
name|regstclass
operator|=
name|Nullch
expr_stmt|;
name|scan
operator|=
name|r
operator|->
name|program
operator|+
literal|1
expr_stmt|;
comment|/* First BRANCH. */
if|if
condition|(
name|OP
argument_list|(
name|regnext
argument_list|(
name|scan
argument_list|)
argument_list|)
operator|==
name|END
condition|)
block|{
comment|/* Only one top-level choice. */
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|first
operator|=
name|scan
expr_stmt|;
while|while
condition|(
operator|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|OPEN
operator|&&
operator|(
name|sawopen
operator|=
literal|1
operator|)
operator|)
operator|||
operator|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|BRANCH
operator|&&
name|OP
argument_list|(
name|regnext
argument_list|(
name|first
argument_list|)
argument_list|)
operator|!=
name|BRANCH
operator|)
operator|||
operator|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|PLUS
operator|)
operator|||
operator|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|CURLY
operator|&&
name|ARG1
argument_list|(
name|first
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|PLUS
condition|)
name|sawplus
operator|=
literal|1
expr_stmt|;
else|else
name|first
operator|+=
name|regarglen
index|[
name|OP
argument_list|(
name|first
argument_list|)
index|]
expr_stmt|;
name|first
operator|=
name|NEXTOPER
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
comment|/* Starting-point info. */
name|again
label|:
if|if
condition|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|EXACTLY
condition|)
block|{
name|r
operator|->
name|regstart
operator|=
name|str_make
argument_list|(
name|OPERAND
argument_list|(
name|first
argument_list|)
operator|+
literal|1
argument_list|,
operator|*
name|OPERAND
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|regstart
operator|->
name|str_cur
operator|>
operator|!
operator|(
name|sawstudy
operator||
name|fold
operator|)
condition|)
name|fbmcompile
argument_list|(
name|r
operator|->
name|regstart
argument_list|,
name|fold
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|exp
operator|=
name|index
argument_list|(
name|simple
argument_list|,
name|OP
argument_list|(
name|first
argument_list|)
argument_list|)
operator|)
operator|&&
name|exp
operator|>
name|simple
condition|)
name|r
operator|->
name|regstclass
operator|=
name|first
expr_stmt|;
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|BOUND
operator|||
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|NBOUND
condition|)
name|r
operator|->
name|regstclass
operator|=
name|first
expr_stmt|;
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|BOL
condition|)
block|{
name|r
operator|->
name|reganch
operator|=
name|ROPT_ANCH
expr_stmt|;
name|first
operator|=
name|NEXTOPER
argument_list|(
name|first
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|STAR
operator|&&
name|OP
argument_list|(
name|NEXTOPER
argument_list|(
name|first
argument_list|)
argument_list|)
operator|==
name|ANY
operator|)
operator|&&
operator|!
operator|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_ANCH
operator|)
condition|)
block|{
comment|/* turn .* into ^.* with an implied $*=1 */
name|r
operator|->
name|reganch
operator|=
name|ROPT_ANCH
operator||
name|ROPT_IMPLICIT
expr_stmt|;
name|first
operator|=
name|NEXTOPER
argument_list|(
name|first
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|sawplus
operator|&&
operator|(
operator|!
name|sawopen
operator|||
operator|!
name|regsawback
operator|)
condition|)
name|r
operator|->
name|reganch
operator||=
name|ROPT_SKIP
expr_stmt|;
comment|/* x+ must match 1st of run */
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|512
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"first %d next %d offset %d\n"
argument_list|,
name|OP
argument_list|(
name|first
argument_list|)
argument_list|,
name|OP
argument_list|(
name|NEXTOPER
argument_list|(
name|first
argument_list|)
argument_list|)
argument_list|,
name|first
operator|-
name|scan
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * If there's something expensive in the r.e., find the 		 * longest literal string that must appear and make it the 		 * regmust.  Resolve ties in favor of later strings, since 		 * the regstart check works with the beginning of the r.e. 		 * and avoiding duplication strengthens checking.  Not a 		 * strong reason, but sufficient in the absence of others. 		 * [Now we resolve ties in favor of the earlier string if 		 * it happens that curback has been invalidated, since the 		 * earlier string may buy us something the later one won't.] 		 */
name|longish
operator|=
name|str_make
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|longest
operator|=
name|str_make
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|minlen
operator|=
literal|0
expr_stmt|;
name|curback
operator|=
literal|0
expr_stmt|;
name|backish
operator|=
literal|0
expr_stmt|;
name|backest
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|!=
name|END
condition|)
block|{
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|BRANCH
condition|)
block|{
if|if
condition|(
name|OP
argument_list|(
name|regnext
argument_list|(
name|scan
argument_list|)
argument_list|)
operator|==
name|BRANCH
condition|)
block|{
name|curback
operator|=
operator|-
literal|30000
expr_stmt|;
while|while
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|BRANCH
condition|)
name|scan
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* single branch is ok */
name|scan
operator|=
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|EXACTLY
condition|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|first
operator|=
name|scan
expr_stmt|;
while|while
condition|(
name|OP
argument_list|(
name|t
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
argument_list|)
operator|==
name|CLOSE
condition|)
name|scan
operator|=
name|t
expr_stmt|;
name|minlen
operator|+=
operator|*
name|OPERAND
argument_list|(
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
name|curback
operator|-
name|backish
operator|==
name|len
condition|)
block|{
name|str_ncat
argument_list|(
name|longish
argument_list|,
name|OPERAND
argument_list|(
name|first
argument_list|)
operator|+
literal|1
argument_list|,
operator|*
name|OPERAND
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|+=
operator|*
name|OPERAND
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|curback
operator|+=
operator|*
name|OPERAND
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|first
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|OPERAND
argument_list|(
name|first
argument_list|)
operator|>=
name|len
operator|+
operator|(
name|curback
operator|>=
literal|0
operator|)
condition|)
block|{
name|len
operator|=
operator|*
name|OPERAND
argument_list|(
name|first
argument_list|)
expr_stmt|;
name|str_nset
argument_list|(
name|longish
argument_list|,
name|OPERAND
argument_list|(
name|first
argument_list|)
operator|+
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|backish
operator|=
name|curback
expr_stmt|;
name|curback
operator|+=
name|len
expr_stmt|;
name|first
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
block|}
else|else
name|curback
operator|+=
operator|*
name|OPERAND
argument_list|(
name|first
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|index
argument_list|(
name|varies
argument_list|,
name|OP
argument_list|(
name|scan
argument_list|)
argument_list|)
condition|)
block|{
name|curback
operator|=
operator|-
literal|30000
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|longish
operator|->
name|str_cur
operator|>
name|longest
operator|->
name|str_cur
condition|)
block|{
name|str_sset
argument_list|(
name|longest
argument_list|,
name|longish
argument_list|)
expr_stmt|;
name|backest
operator|=
name|backish
expr_stmt|;
block|}
name|str_nset
argument_list|(
name|longish
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|PLUS
operator|&&
name|index
argument_list|(
name|simple
argument_list|,
name|OP
argument_list|(
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
argument_list|)
argument_list|)
condition|)
name|minlen
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|CURLY
operator|&&
name|index
argument_list|(
name|simple
argument_list|,
name|OP
argument_list|(
name|NEXTOPER
argument_list|(
name|scan
argument_list|)
operator|+
literal|4
argument_list|)
argument_list|)
condition|)
name|minlen
operator|+=
name|ARG1
argument_list|(
name|scan
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|index
argument_list|(
name|simple
argument_list|,
name|OP
argument_list|(
name|scan
argument_list|)
argument_list|)
condition|)
block|{
name|curback
operator|++
expr_stmt|;
name|minlen
operator|++
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|longish
operator|->
name|str_cur
operator|>
name|longest
operator|->
name|str_cur
condition|)
block|{
name|str_sset
argument_list|(
name|longest
argument_list|,
name|longish
argument_list|)
expr_stmt|;
name|backest
operator|=
name|backish
expr_stmt|;
block|}
name|str_nset
argument_list|(
name|longish
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|scan
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
block|}
comment|/* Prefer earlier on tie, unless we can tail match latter */
if|if
condition|(
name|longish
operator|->
name|str_cur
operator|+
operator|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|EOL
operator|)
operator|>
name|longest
operator|->
name|str_cur
condition|)
block|{
name|str_sset
argument_list|(
name|longest
argument_list|,
name|longish
argument_list|)
expr_stmt|;
name|backest
operator|=
name|backish
expr_stmt|;
block|}
else|else
name|str_nset
argument_list|(
name|longish
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|longest
operator|->
name|str_cur
operator|&&
operator|(
operator|!
name|r
operator|->
name|regstart
operator|||
operator|!
name|fbminstr
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|r
operator|->
name|regstart
operator|->
name|str_ptr
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|r
operator|->
name|regstart
operator|->
name|str_ptr
operator|+
name|r
operator|->
name|regstart
operator|->
name|str_cur
argument_list|,
name|longest
argument_list|)
operator|)
condition|)
block|{
name|r
operator|->
name|regmust
operator|=
name|longest
expr_stmt|;
if|if
condition|(
name|backest
operator|<
literal|0
condition|)
name|backest
operator|=
operator|-
literal|1
expr_stmt|;
name|r
operator|->
name|regback
operator|=
name|backest
expr_stmt|;
if|if
condition|(
name|longest
operator|->
name|str_cur
operator|>
operator|!
operator|(
name|sawstudy
operator|||
name|fold
operator|||
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|EOL
operator|)
condition|)
name|fbmcompile
argument_list|(
name|r
operator|->
name|regmust
argument_list|,
name|fold
argument_list|)
expr_stmt|;
name|r
operator|->
name|regmust
operator|->
name|str_u
operator|.
name|str_useful
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|first
argument_list|)
operator|==
name|EOL
operator|&&
name|longish
operator|->
name|str_cur
condition|)
name|r
operator|->
name|regmust
operator|->
name|str_pok
operator||=
name|SP_TAIL
expr_stmt|;
block|}
else|else
block|{
name|str_free
argument_list|(
name|longest
argument_list|)
expr_stmt|;
name|longest
operator|=
name|Nullstr
expr_stmt|;
block|}
name|str_free
argument_list|(
name|longish
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|do_folding
operator|=
name|fold
expr_stmt|;
name|r
operator|->
name|nparens
operator|=
name|regnpar
operator|-
literal|1
expr_stmt|;
name|r
operator|->
name|minlen
operator|=
name|minlen
expr_stmt|;
name|Newz
argument_list|(
literal|1002
argument_list|,
name|r
operator|->
name|startp
argument_list|,
name|regnpar
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|Newz
argument_list|(
literal|1002
argument_list|,
name|r
operator|->
name|endp
argument_list|,
name|regnpar
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|512
condition|)
name|regdump
argument_list|(
name|r
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - reg - regular expression, i.e. main body or parenthesized thing  *  * Caller must absorb opening parenthesis.  *  * Combining parenthesis handling with the base level of regular expression  * is a trifle forced, but the need to tie the tails of the branches to what  * follows makes it hard to avoid.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|reg
parameter_list|(
name|paren
parameter_list|,
name|flagp
parameter_list|)
name|int
name|paren
decl_stmt|;
comment|/* Parenthesized? */
name|int
modifier|*
name|flagp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ret
decl_stmt|;
specifier|register
name|char
modifier|*
name|br
decl_stmt|;
specifier|register
name|char
modifier|*
name|ender
decl_stmt|;
specifier|register
name|int
name|parno
decl_stmt|;
name|int
name|flags
decl_stmt|;
operator|*
name|flagp
operator|=
name|HASWIDTH
expr_stmt|;
comment|/* Tentatively. */
comment|/* Make an OPEN node, if parenthesized. */
if|if
condition|(
name|paren
condition|)
block|{
name|parno
operator|=
name|regnpar
expr_stmt|;
name|regnpar
operator|++
expr_stmt|;
name|ret
operator|=
name|reganode
argument_list|(
name|OPEN
argument_list|,
name|parno
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|NULL
expr_stmt|;
comment|/* Pick up the branches, linking them together. */
name|br
operator|=
name|regbranch
argument_list|(
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|br
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
name|regtail
argument_list|(
name|ret
argument_list|,
name|br
argument_list|)
expr_stmt|;
comment|/* OPEN -> first. */
else|else
name|ret
operator|=
name|br
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|HASWIDTH
operator|)
condition|)
operator|*
name|flagp
operator|&=
operator|~
name|HASWIDTH
expr_stmt|;
operator|*
name|flagp
operator||=
name|flags
operator|&
name|SPSTART
expr_stmt|;
while|while
condition|(
operator|*
name|regparse
operator|==
literal|'|'
condition|)
block|{
name|regparse
operator|++
expr_stmt|;
name|br
operator|=
name|regbranch
argument_list|(
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|br
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|regtail
argument_list|(
name|ret
argument_list|,
name|br
argument_list|)
expr_stmt|;
comment|/* BRANCH -> BRANCH. */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|HASWIDTH
operator|)
condition|)
operator|*
name|flagp
operator|&=
operator|~
name|HASWIDTH
expr_stmt|;
operator|*
name|flagp
operator||=
name|flags
operator|&
name|SPSTART
expr_stmt|;
block|}
comment|/* Make a closing node, and hook it on the end. */
if|if
condition|(
name|paren
condition|)
name|ender
operator|=
name|reganode
argument_list|(
name|CLOSE
argument_list|,
name|parno
argument_list|)
expr_stmt|;
else|else
name|ender
operator|=
name|regnode
argument_list|(
name|END
argument_list|)
expr_stmt|;
name|regtail
argument_list|(
name|ret
argument_list|,
name|ender
argument_list|)
expr_stmt|;
comment|/* Hook the tails of the branches to the closing node. */
for|for
control|(
name|br
operator|=
name|ret
init|;
name|br
operator|!=
name|NULL
condition|;
name|br
operator|=
name|regnext
argument_list|(
name|br
argument_list|)
control|)
name|regoptail
argument_list|(
name|br
argument_list|,
name|ender
argument_list|)
expr_stmt|;
comment|/* Check for proper termination. */
if|if
condition|(
name|paren
operator|&&
operator|*
name|regparse
operator|++
operator|!=
literal|')'
condition|)
block|{
name|FAIL
argument_list|(
literal|"unmatched () in regexp"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|paren
operator|&&
name|regparse
operator|<
name|regxend
condition|)
block|{
if|if
condition|(
operator|*
name|regparse
operator|==
literal|')'
condition|)
block|{
name|FAIL
argument_list|(
literal|"unmatched () in regexp"
argument_list|)
expr_stmt|;
block|}
else|else
name|FAIL
argument_list|(
literal|"junk on end of regexp"
argument_list|)
expr_stmt|;
comment|/* "Can't happen". */
comment|/* NOTREACHED */
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regbranch - one alternative of an | operator  *  * Implements the concatenation operator.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|regbranch
parameter_list|(
name|flagp
parameter_list|)
name|int
modifier|*
name|flagp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ret
decl_stmt|;
specifier|register
name|char
modifier|*
name|chain
decl_stmt|;
specifier|register
name|char
modifier|*
name|latest
decl_stmt|;
name|int
name|flags
decl_stmt|;
operator|*
name|flagp
operator|=
name|WORST
expr_stmt|;
comment|/* Tentatively. */
name|ret
operator|=
name|regnode
argument_list|(
name|BRANCH
argument_list|)
expr_stmt|;
name|chain
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|regparse
operator|<
name|regxend
operator|&&
operator|*
name|regparse
operator|!=
literal|'|'
operator|&&
operator|*
name|regparse
operator|!=
literal|')'
condition|)
block|{
name|latest
operator|=
name|regpiece
argument_list|(
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|latest
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|*
name|flagp
operator||=
name|flags
operator|&
name|HASWIDTH
expr_stmt|;
if|if
condition|(
name|chain
operator|==
name|NULL
condition|)
comment|/* First piece. */
operator|*
name|flagp
operator||=
name|flags
operator|&
name|SPSTART
expr_stmt|;
else|else
name|regtail
argument_list|(
name|chain
argument_list|,
name|latest
argument_list|)
expr_stmt|;
name|chain
operator|=
name|latest
expr_stmt|;
block|}
if|if
condition|(
name|chain
operator|==
name|NULL
condition|)
comment|/* Loop ran zero times. */
operator|(
name|void
operator|)
name|regnode
argument_list|(
name|NOTHING
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regpiece - something followed by possible [*+?]  *  * Note that the branching code sequences used for ? and the general cases  * of * and + are somewhat optimized:  they use the same NOTHING node as  * both the endmarker for their branch list and the body of the last branch.  * It might seem that this node could be dispensed with entirely, but the  * endmarker role is not redundant.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|regpiece
parameter_list|(
name|flagp
parameter_list|)
name|int
modifier|*
name|flagp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ret
decl_stmt|;
specifier|register
name|char
name|op
decl_stmt|;
specifier|register
name|char
modifier|*
name|next
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|char
modifier|*
name|origparse
init|=
name|regparse
decl_stmt|;
name|int
name|orignpar
init|=
name|regnpar
decl_stmt|;
name|char
modifier|*
name|max
decl_stmt|;
name|int
name|iter
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|ret
operator|=
name|regatom
argument_list|(
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|op
operator|=
operator|*
name|regparse
expr_stmt|;
comment|/* Here's a total kludge: if after the atom there's a {\d+,?\d*} 	 * then we decrement the first number by one and reset our 	 * parsing back to the beginning of the same atom.  If the first number 	 * is down to 0, decrement the second number instead and fake up 	 * a ? after it.  Given the way this compiler doesn't keep track 	 * of offsets on the first pass, this is the only way to replicate 	 * a piece of code.  Sigh. 	 */
if|if
condition|(
name|op
operator|==
literal|'{'
operator|&&
name|regcurly
argument_list|(
name|regparse
argument_list|)
condition|)
block|{
name|next
operator|=
name|regparse
operator|+
literal|1
expr_stmt|;
name|max
operator|=
name|Nullch
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|next
argument_list|)
operator|||
operator|*
name|next
operator|==
literal|','
condition|)
block|{
if|if
condition|(
operator|*
name|next
operator|==
literal|','
condition|)
block|{
if|if
condition|(
name|max
condition|)
break|break;
else|else
name|max
operator|=
name|next
expr_stmt|;
block|}
name|next
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|next
operator|==
literal|'}'
condition|)
block|{
comment|/* got one */
if|if
condition|(
operator|!
name|max
condition|)
name|max
operator|=
name|next
expr_stmt|;
name|regparse
operator|++
expr_stmt|;
name|iter
operator|=
name|atoi
argument_list|(
name|regparse
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SIMPLE
condition|)
block|{
comment|/* we can do it right after all */
name|int
name|tmp
decl_stmt|;
name|reginsert
argument_list|(
name|CURLY
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|iter
operator|>
literal|0
condition|)
operator|*
name|flagp
operator|=
operator|(
name|WORST
operator||
name|HASWIDTH
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|max
operator|==
literal|','
condition|)
name|max
operator|++
expr_stmt|;
else|else
name|max
operator|=
name|regparse
expr_stmt|;
name|tmp
operator|=
name|atoi
argument_list|(
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
operator|&&
operator|*
name|max
operator|!=
literal|'0'
condition|)
name|tmp
operator|=
literal|32767
expr_stmt|;
comment|/* meaning "infinity" */
if|if
condition|(
name|tmp
operator|&&
name|tmp
operator|<
name|iter
condition|)
name|fatal
argument_list|(
literal|"Can't do {n,m} with n> m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|regcode
operator|!=
operator|&
name|regdummy
condition|)
block|{
ifdef|#
directive|ifdef
name|REGALIGN
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|ret
operator|+
literal|3
operator|)
operator|=
name|iter
expr_stmt|;
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|ret
operator|+
literal|5
operator|)
operator|=
name|tmp
expr_stmt|;
else|#
directive|else
name|ret
index|[
literal|3
index|]
operator|=
name|iter
operator|>>
literal|8
expr_stmt|;
name|ret
index|[
literal|4
index|]
operator|=
name|iter
operator|&
literal|0377
expr_stmt|;
name|ret
index|[
literal|5
index|]
operator|=
name|tmp
operator|>>
literal|8
expr_stmt|;
name|ret
index|[
literal|6
index|]
operator|=
name|tmp
operator|&
literal|0377
expr_stmt|;
endif|#
directive|endif
block|}
name|regparse
operator|=
name|next
expr_stmt|;
goto|goto
name|nest_check
goto|;
block|}
name|regsawbracket
operator|++
expr_stmt|;
comment|/* remember we clobbered exp */
if|if
condition|(
name|iter
operator|>
literal|0
condition|)
block|{
name|ch
operator|=
operator|*
name|max
expr_stmt|;
name|sprintf
argument_list|(
name|regparse
argument_list|,
literal|"%.*d"
argument_list|,
name|max
operator|-
name|regparse
argument_list|,
name|iter
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|max
operator|=
name|ch
expr_stmt|;
if|if
condition|(
operator|*
name|max
operator|==
literal|','
operator|&&
name|max
index|[
literal|1
index|]
operator|!=
literal|'}'
condition|)
block|{
if|if
condition|(
name|atoi
argument_list|(
name|max
operator|+
literal|1
argument_list|)
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
literal|"Can't do {n,m} with n> m"
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|*
name|next
expr_stmt|;
name|sprintf
argument_list|(
name|max
operator|+
literal|1
argument_list|,
literal|"%.*d"
argument_list|,
name|next
operator|-
operator|(
name|max
operator|+
literal|1
operator|)
argument_list|,
name|atoi
argument_list|(
name|max
operator|+
literal|1
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|next
operator|=
name|ch
expr_stmt|;
block|}
if|if
condition|(
name|iter
operator|!=
literal|1
operator|||
operator|*
name|max
operator|==
literal|','
condition|)
block|{
name|regparse
operator|=
name|origparse
expr_stmt|;
comment|/* back up input pointer */
name|regnpar
operator|=
name|orignpar
expr_stmt|;
comment|/* don't make more parens */
block|}
else|else
block|{
name|regparse
operator|=
name|next
expr_stmt|;
goto|goto
name|nest_check
goto|;
block|}
operator|*
name|flagp
operator|=
name|flags
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
operator|*
name|max
operator|==
literal|','
condition|)
block|{
name|max
operator|++
expr_stmt|;
name|iter
operator|=
name|atoi
argument_list|(
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|max
operator|==
name|next
condition|)
block|{
comment|/* any number more? */
name|regparse
operator|=
name|next
expr_stmt|;
name|op
operator|=
literal|'*'
expr_stmt|;
comment|/* fake up one with a star */
block|}
elseif|else
if|if
condition|(
name|iter
operator|>
literal|0
condition|)
block|{
name|op
operator|=
literal|'?'
expr_stmt|;
comment|/* fake up optional atom */
name|ch
operator|=
operator|*
name|next
expr_stmt|;
name|sprintf
argument_list|(
name|max
argument_list|,
literal|"%.*d"
argument_list|,
name|next
operator|-
name|max
argument_list|,
name|iter
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|next
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|iter
operator|==
literal|1
condition|)
name|regparse
operator|=
name|next
expr_stmt|;
else|else
block|{
name|regparse
operator|=
name|origparse
operator|-
literal|1
expr_stmt|;
comment|/* offset ++ below */
name|regnpar
operator|=
name|orignpar
expr_stmt|;
block|}
block|}
else|else
name|fatal
argument_list|(
literal|"Can't do {n,0}"
argument_list|)
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
literal|"Can't do {0}"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ISMULT1
argument_list|(
name|op
argument_list|)
condition|)
block|{
operator|*
name|flagp
operator|=
name|flags
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|HASWIDTH
operator|)
operator|&&
name|op
operator|!=
literal|'?'
condition|)
name|FAIL
argument_list|(
literal|"regexp *+ operand could be empty"
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator|=
operator|(
name|op
operator|!=
literal|'+'
operator|)
condition|?
operator|(
name|WORST
operator||
name|SPSTART
operator|)
else|:
operator|(
name|WORST
operator||
name|HASWIDTH
operator|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|'*'
operator|&&
operator|(
name|flags
operator|&
name|SIMPLE
operator|)
condition|)
name|reginsert
argument_list|(
name|STAR
argument_list|,
name|ret
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
literal|'*'
condition|)
block|{
comment|/* Emit x* as (x&|), where& means "self". */
name|reginsert
argument_list|(
name|BRANCH
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* Either x */
name|regoptail
argument_list|(
name|ret
argument_list|,
name|regnode
argument_list|(
name|BACK
argument_list|)
argument_list|)
expr_stmt|;
comment|/* and loop */
name|regoptail
argument_list|(
name|ret
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* back */
name|regtail
argument_list|(
name|ret
argument_list|,
name|regnode
argument_list|(
name|BRANCH
argument_list|)
argument_list|)
expr_stmt|;
comment|/* or */
name|regtail
argument_list|(
name|ret
argument_list|,
name|regnode
argument_list|(
name|NOTHING
argument_list|)
argument_list|)
expr_stmt|;
comment|/* null. */
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|'+'
operator|&&
operator|(
name|flags
operator|&
name|SIMPLE
operator|)
condition|)
name|reginsert
argument_list|(
name|PLUS
argument_list|,
name|ret
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
literal|'+'
condition|)
block|{
comment|/* Emit x+ as x(&|), where& means "self". */
name|next
operator|=
name|regnode
argument_list|(
name|BRANCH
argument_list|)
expr_stmt|;
comment|/* Either */
name|regtail
argument_list|(
name|ret
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|regtail
argument_list|(
name|regnode
argument_list|(
name|BACK
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* loop back */
name|regtail
argument_list|(
name|next
argument_list|,
name|regnode
argument_list|(
name|BRANCH
argument_list|)
argument_list|)
expr_stmt|;
comment|/* or */
name|regtail
argument_list|(
name|ret
argument_list|,
name|regnode
argument_list|(
name|NOTHING
argument_list|)
argument_list|)
expr_stmt|;
comment|/* null. */
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|'?'
condition|)
block|{
comment|/* Emit x? as (x|) */
name|reginsert
argument_list|(
name|BRANCH
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* Either x */
name|regtail
argument_list|(
name|ret
argument_list|,
name|regnode
argument_list|(
name|BRANCH
argument_list|)
argument_list|)
expr_stmt|;
comment|/* or */
name|next
operator|=
name|regnode
argument_list|(
name|NOTHING
argument_list|)
expr_stmt|;
comment|/* null. */
name|regtail
argument_list|(
name|ret
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|regoptail
argument_list|(
name|ret
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
name|nest_check
label|:
name|regparse
operator|++
expr_stmt|;
if|if
condition|(
name|ISMULT2
argument_list|(
name|regparse
argument_list|)
condition|)
name|FAIL
argument_list|(
literal|"nested *?+ in regexp"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regatom - the lowest level  *  * Optimization:  gobbles an entire sequence of ordinary characters so that  * it can turn them into a single node, which is smaller to store and  * faster to run.  Backslashed characters are exceptions, each becoming a  * separate node; the code is simpler that way and it's not worth fixing.  *  * [Yes, it is worth fixing, some scripts can run twice the speed.]  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|regatom
parameter_list|(
name|flagp
parameter_list|)
name|int
modifier|*
name|flagp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ret
decl_stmt|;
name|int
name|flags
decl_stmt|;
operator|*
name|flagp
operator|=
name|WORST
expr_stmt|;
comment|/* Tentatively. */
switch|switch
condition|(
operator|*
name|regparse
operator|++
condition|)
block|{
case|case
literal|'^'
case|:
name|ret
operator|=
name|regnode
argument_list|(
name|BOL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
name|ret
operator|=
name|regnode
argument_list|(
name|EOL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|ret
operator|=
name|regnode
argument_list|(
name|ANY
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|ret
operator|=
name|regclass
argument_list|()
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|ret
operator|=
name|reg
argument_list|(
literal|1
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|*
name|flagp
operator||=
name|flags
operator|&
operator|(
name|HASWIDTH
operator||
name|SPSTART
operator|)
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
case|case
literal|')'
case|:
name|FAIL
argument_list|(
literal|"internal urp in regexp"
argument_list|)
expr_stmt|;
comment|/* Supposed to be caught earlier. */
break|break;
case|case
literal|'?'
case|:
case|case
literal|'+'
case|:
case|case
literal|'*'
case|:
name|FAIL
argument_list|(
literal|"?+* follows nothing in regexp"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
switch|switch
condition|(
operator|*
name|regparse
condition|)
block|{
case|case
literal|'w'
case|:
name|ret
operator|=
name|regnode
argument_list|(
name|ALNUM
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
name|regparse
operator|++
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|ret
operator|=
name|regnode
argument_list|(
name|NALNUM
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
name|regparse
operator|++
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|ret
operator|=
name|regnode
argument_list|(
name|BOUND
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|SIMPLE
expr_stmt|;
name|regparse
operator|++
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|ret
operator|=
name|regnode
argument_list|(
name|NBOUND
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|SIMPLE
expr_stmt|;
name|regparse
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|ret
operator|=
name|regnode
argument_list|(
name|SPACE
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
name|regparse
operator|++
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|ret
operator|=
name|regnode
argument_list|(
name|NSPACE
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
name|regparse
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|ret
operator|=
name|regnode
argument_list|(
name|DIGIT
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
name|regparse
operator|++
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|ret
operator|=
name|regnode
argument_list|(
name|NDIGIT
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
name|regparse
operator|++
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'r'
case|:
case|case
literal|'t'
case|:
case|case
literal|'f'
case|:
case|case
literal|'e'
case|:
case|case
literal|'a'
case|:
case|case
literal|'x'
case|:
case|case
literal|'c'
case|:
case|case
literal|'0'
case|:
goto|goto
name|defchar
goto|;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
name|int
name|num
init|=
name|atoi
argument_list|(
name|regparse
argument_list|)
decl_stmt|;
if|if
condition|(
name|num
operator|>
literal|9
operator|&&
name|num
operator|>=
name|regnpar
condition|)
goto|goto
name|defchar
goto|;
else|else
block|{
name|regsawback
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|reganode
argument_list|(
name|REF
argument_list|,
name|num
argument_list|)
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|regparse
argument_list|)
condition|)
name|regparse
operator|++
expr_stmt|;
operator|*
name|flagp
operator||=
name|SIMPLE
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'\0'
case|:
if|if
condition|(
name|regparse
operator|>=
name|regxend
condition|)
name|FAIL
argument_list|(
literal|"trailing \\ in regexp"
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
default|default:
goto|goto
name|defchar
goto|;
block|}
break|break;
default|default:
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
name|ender
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|oldp
decl_stmt|;
name|int
name|numlen
decl_stmt|;
name|defchar
label|:
name|ret
operator|=
name|regnode
argument_list|(
name|EXACTLY
argument_list|)
expr_stmt|;
name|regc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* save spot for len */
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|p
operator|=
name|regparse
operator|-
literal|1
init|;
name|len
operator|<
literal|127
operator|&&
name|p
operator|<
name|regxend
condition|;
name|len
operator|++
control|)
block|{
name|oldp
operator|=
name|p
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'^'
case|:
case|case
literal|'$'
case|:
case|case
literal|'.'
case|:
case|case
literal|'['
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'|'
case|:
goto|goto
name|loopdone
goto|;
case|case
literal|'\\'
case|:
switch|switch
condition|(
operator|*
operator|++
name|p
condition|)
block|{
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
operator|--
name|p
expr_stmt|;
goto|goto
name|loopdone
goto|;
case|case
literal|'n'
case|:
name|ender
operator|=
literal|'\n'
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|ender
operator|=
literal|'\r'
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|ender
operator|=
literal|'\t'
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|ender
operator|=
literal|'\f'
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|ender
operator|=
literal|'\033'
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|ender
operator|=
literal|'\007'
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|ender
operator|=
name|scanhex
argument_list|(
operator|++
name|p
argument_list|,
literal|2
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|numlen
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|p
operator|++
expr_stmt|;
name|ender
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|isLOWER
argument_list|(
name|ender
argument_list|)
condition|)
name|ender
operator|=
name|toupper
argument_list|(
name|ender
argument_list|)
expr_stmt|;
name|ender
operator|^=
literal|64
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
operator|*
name|p
operator|==
literal|'0'
operator|||
operator|(
name|isDIGIT
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|&&
name|atoi
argument_list|(
name|p
argument_list|)
operator|>=
name|regnpar
operator|)
condition|)
block|{
name|ender
operator|=
name|scanoct
argument_list|(
name|p
argument_list|,
literal|3
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|numlen
expr_stmt|;
block|}
else|else
block|{
operator|--
name|p
expr_stmt|;
goto|goto
name|loopdone
goto|;
block|}
break|break;
case|case
literal|'\0'
case|:
if|if
condition|(
name|p
operator|>=
name|regxend
condition|)
name|FAIL
argument_list|(
literal|"trailing \\ in regexp"
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
default|default:
name|ender
operator|=
operator|*
name|p
operator|++
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|ender
operator|=
operator|*
name|p
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|regfold
operator|&&
name|isUPPER
argument_list|(
name|ender
argument_list|)
condition|)
name|ender
operator|=
name|tolower
argument_list|(
name|ender
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISMULT2
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|/* Back off on ?+*. */
if|if
condition|(
name|len
condition|)
name|p
operator|=
name|oldp
expr_stmt|;
else|else
block|{
name|len
operator|++
expr_stmt|;
name|regc
argument_list|(
name|ender
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|regc
argument_list|(
name|ender
argument_list|)
expr_stmt|;
block|}
name|loopdone
label|:
name|regparse
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
name|FAIL
argument_list|(
literal|"internal disaster in regexp"
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
operator|*
name|flagp
operator||=
name|SIMPLE
expr_stmt|;
if|if
condition|(
name|regcode
operator|!=
operator|&
name|regdummy
condition|)
operator|*
name|OPERAND
argument_list|(
name|ret
argument_list|)
operator|=
name|len
expr_stmt|;
name|regc
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|regset
parameter_list|(
name|bits
parameter_list|,
name|def
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|bits
decl_stmt|;
name|int
name|def
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|regcode
operator|==
operator|&
name|regdummy
condition|)
return|return;
name|c
operator|&=
literal|255
expr_stmt|;
if|if
condition|(
name|def
condition|)
name|bits
index|[
name|c
operator|>>
literal|3
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
else|else
name|bits
index|[
name|c
operator|>>
literal|3
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|regclass
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|bits
decl_stmt|;
specifier|register
name|int
name|class
decl_stmt|;
specifier|register
name|int
name|lastclass
decl_stmt|;
specifier|register
name|int
name|range
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|ret
decl_stmt|;
specifier|register
name|int
name|def
decl_stmt|;
name|int
name|numlen
decl_stmt|;
name|ret
operator|=
name|regnode
argument_list|(
name|ANYOF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|regparse
operator|==
literal|'^'
condition|)
block|{
comment|/* Complement of range. */
name|regparse
operator|++
expr_stmt|;
name|def
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|def
operator|=
literal|255
expr_stmt|;
block|}
name|bits
operator|=
name|regcode
expr_stmt|;
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
literal|32
condition|;
name|class
operator|++
control|)
name|regc
argument_list|(
name|def
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|regparse
operator|==
literal|']'
operator|||
operator|*
name|regparse
operator|==
literal|'-'
condition|)
goto|goto
name|skipcond
goto|;
comment|/* allow 1st char to be ] or - */
while|while
condition|(
name|regparse
operator|<
name|regxend
operator|&&
operator|*
name|regparse
operator|!=
literal|']'
condition|)
block|{
name|skipcond
label|:
name|class
operator|=
name|UCHARAT
argument_list|(
name|regparse
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
literal|'\\'
condition|)
block|{
name|class
operator|=
name|UCHARAT
argument_list|(
name|regparse
operator|++
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
literal|'w'
case|:
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
literal|256
condition|;
name|class
operator|++
control|)
if|if
condition|(
name|isALNUM
argument_list|(
name|class
argument_list|)
condition|)
name|regset
argument_list|(
name|bits
argument_list|,
name|def
argument_list|,
name|class
argument_list|)
expr_stmt|;
name|lastclass
operator|=
literal|1234
expr_stmt|;
continue|continue;
case|case
literal|'W'
case|:
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
literal|256
condition|;
name|class
operator|++
control|)
if|if
condition|(
operator|!
name|isALNUM
argument_list|(
name|class
argument_list|)
condition|)
name|regset
argument_list|(
name|bits
argument_list|,
name|def
argument_list|,
name|class
argument_list|)
expr_stmt|;
name|lastclass
operator|=
literal|1234
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
literal|256
condition|;
name|class
operator|++
control|)
if|if
condition|(
name|isSPACE
argument_list|(
name|class
argument_list|)
condition|)
name|regset
argument_list|(
name|bits
argument_list|,
name|def
argument_list|,
name|class
argument_list|)
expr_stmt|;
name|lastclass
operator|=
literal|1234
expr_stmt|;
continue|continue;
case|case
literal|'S'
case|:
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
literal|256
condition|;
name|class
operator|++
control|)
if|if
condition|(
operator|!
name|isSPACE
argument_list|(
name|class
argument_list|)
condition|)
name|regset
argument_list|(
name|bits
argument_list|,
name|def
argument_list|,
name|class
argument_list|)
expr_stmt|;
name|lastclass
operator|=
literal|1234
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
for|for
control|(
name|class
operator|=
literal|'0'
init|;
name|class
operator|<=
literal|'9'
condition|;
name|class
operator|++
control|)
name|regset
argument_list|(
name|bits
argument_list|,
name|def
argument_list|,
name|class
argument_list|)
expr_stmt|;
name|lastclass
operator|=
literal|1234
expr_stmt|;
continue|continue;
case|case
literal|'D'
case|:
for|for
control|(
name|class
operator|=
literal|0
init|;
name|class
operator|<
literal|'0'
condition|;
name|class
operator|++
control|)
name|regset
argument_list|(
name|bits
argument_list|,
name|def
argument_list|,
name|class
argument_list|)
expr_stmt|;
for|for
control|(
name|class
operator|=
literal|'9'
operator|+
literal|1
init|;
name|class
operator|<
literal|256
condition|;
name|class
operator|++
control|)
name|regset
argument_list|(
name|bits
argument_list|,
name|def
argument_list|,
name|class
argument_list|)
expr_stmt|;
name|lastclass
operator|=
literal|1234
expr_stmt|;
continue|continue;
case|case
literal|'n'
case|:
name|class
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|class
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|class
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|class
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|class
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|class
operator|=
literal|'\033'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|class
operator|=
literal|'\007'
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|class
operator|=
name|scanhex
argument_list|(
name|regparse
argument_list|,
literal|2
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|regparse
operator|+=
name|numlen
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|class
operator|=
operator|*
name|regparse
operator|++
expr_stmt|;
if|if
condition|(
name|isLOWER
argument_list|(
name|class
argument_list|)
condition|)
name|class
operator|=
name|toupper
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|class
operator|^=
literal|64
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|class
operator|=
name|scanoct
argument_list|(
operator|--
name|regparse
argument_list|,
literal|3
argument_list|,
operator|&
name|numlen
argument_list|)
expr_stmt|;
name|regparse
operator|+=
name|numlen
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|range
condition|)
block|{
if|if
condition|(
name|lastclass
operator|>
name|class
condition|)
name|FAIL
argument_list|(
literal|"invalid [] range in regexp"
argument_list|)
expr_stmt|;
name|range
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|lastclass
operator|=
name|class
expr_stmt|;
if|if
condition|(
operator|*
name|regparse
operator|==
literal|'-'
operator|&&
name|regparse
operator|+
literal|1
operator|<
name|regxend
operator|&&
name|regparse
index|[
literal|1
index|]
operator|!=
literal|']'
condition|)
block|{
name|regparse
operator|++
expr_stmt|;
name|range
operator|=
literal|1
expr_stmt|;
continue|continue;
comment|/* do it next time */
block|}
block|}
for|for
control|(
init|;
name|lastclass
operator|<=
name|class
condition|;
name|lastclass
operator|++
control|)
block|{
name|regset
argument_list|(
name|bits
argument_list|,
name|def
argument_list|,
name|lastclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|regfold
operator|&&
name|isUPPER
argument_list|(
name|lastclass
argument_list|)
condition|)
name|regset
argument_list|(
name|bits
argument_list|,
name|def
argument_list|,
name|tolower
argument_list|(
name|lastclass
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lastclass
operator|=
name|class
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|regparse
operator|!=
literal|']'
condition|)
name|FAIL
argument_list|(
literal|"unmatched [] in regexp"
argument_list|)
expr_stmt|;
name|regparse
operator|++
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  - regnode - emit a node  */
end_comment

begin_function
specifier|static
name|char
modifier|*
comment|/* Location. */
name|regnode
parameter_list|(
name|op
parameter_list|)
name|char
name|op
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ret
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
name|ret
operator|=
name|regcode
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|&
name|regdummy
condition|)
block|{
ifdef|#
directive|ifdef
name|REGALIGN
if|if
condition|(
operator|!
operator|(
name|regsize
operator|&
literal|1
operator|)
condition|)
name|regsize
operator|++
expr_stmt|;
endif|#
directive|endif
name|regsize
operator|+=
literal|3
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|REGALIGN
ifndef|#
directive|ifndef
name|lint
if|if
condition|(
operator|!
operator|(
operator|(
name|long
operator|)
name|ret
operator|&
literal|1
operator|)
condition|)
operator|*
name|ret
operator|++
operator|=
literal|127
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|ptr
operator|=
name|ret
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|op
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Null "next" pointer. */
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|regcode
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - reganode - emit a node with an argument  */
end_comment

begin_function
specifier|static
name|char
modifier|*
comment|/* Location. */
name|reganode
parameter_list|(
name|op
parameter_list|,
name|arg
parameter_list|)
name|char
name|op
decl_stmt|;
name|unsigned
name|short
name|arg
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ret
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
name|ret
operator|=
name|regcode
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|&
name|regdummy
condition|)
block|{
ifdef|#
directive|ifdef
name|REGALIGN
if|if
condition|(
operator|!
operator|(
name|regsize
operator|&
literal|1
operator|)
condition|)
name|regsize
operator|++
expr_stmt|;
endif|#
directive|endif
name|regsize
operator|+=
literal|5
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|REGALIGN
ifndef|#
directive|ifndef
name|lint
if|if
condition|(
operator|!
operator|(
operator|(
name|long
operator|)
name|ret
operator|&
literal|1
operator|)
condition|)
operator|*
name|ret
operator|++
operator|=
literal|127
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|ptr
operator|=
name|ret
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|op
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Null "next" pointer. */
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|REGALIGN
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|ret
operator|+
literal|3
operator|)
operator|=
name|arg
expr_stmt|;
else|#
directive|else
name|ret
index|[
literal|3
index|]
operator|=
name|arg
operator|>>
literal|8
expr_stmt|;
name|ret
index|[
literal|4
index|]
operator|=
name|arg
operator|&
literal|0377
expr_stmt|;
endif|#
directive|endif
name|ptr
operator|+=
literal|2
expr_stmt|;
name|regcode
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regc - emit (if appropriate) a byte of code  */
end_comment

begin_function
specifier|static
name|void
name|regc
parameter_list|(
name|b
parameter_list|)
name|char
name|b
decl_stmt|;
block|{
if|if
condition|(
name|regcode
operator|!=
operator|&
name|regdummy
condition|)
operator|*
name|regcode
operator|++
operator|=
name|b
expr_stmt|;
else|else
name|regsize
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - reginsert - insert an operator in front of already-emitted operand  *  * Means relocating the operand.  */
end_comment

begin_function
specifier|static
name|void
name|reginsert
parameter_list|(
name|op
parameter_list|,
name|opnd
parameter_list|)
name|char
name|op
decl_stmt|;
name|char
modifier|*
name|opnd
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|src
decl_stmt|;
specifier|register
name|char
modifier|*
name|dst
decl_stmt|;
specifier|register
name|char
modifier|*
name|place
decl_stmt|;
specifier|register
name|offset
operator|=
operator|(
name|op
operator|==
name|CURLY
condition|?
literal|4
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|regcode
operator|==
operator|&
name|regdummy
condition|)
block|{
ifdef|#
directive|ifdef
name|REGALIGN
name|regsize
operator|+=
literal|4
operator|+
name|offset
expr_stmt|;
else|#
directive|else
name|regsize
operator|+=
literal|3
operator|+
name|offset
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|src
operator|=
name|regcode
expr_stmt|;
ifdef|#
directive|ifdef
name|REGALIGN
name|regcode
operator|+=
literal|4
operator|+
name|offset
expr_stmt|;
else|#
directive|else
name|regcode
operator|+=
literal|3
operator|+
name|offset
expr_stmt|;
endif|#
directive|endif
name|dst
operator|=
name|regcode
expr_stmt|;
while|while
condition|(
name|src
operator|>
name|opnd
condition|)
operator|*
operator|--
name|dst
operator|=
operator|*
operator|--
name|src
expr_stmt|;
name|place
operator|=
name|opnd
expr_stmt|;
comment|/* Op node, where operand used to be. */
operator|*
name|place
operator|++
operator|=
name|op
expr_stmt|;
operator|*
name|place
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|place
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|offset
operator|--
operator|>
literal|0
condition|)
operator|*
name|place
operator|++
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|REGALIGN
operator|*
name|place
operator|++
operator|=
literal|'\177'
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  - regtail - set the next-pointer at the end of a node chain  */
end_comment

begin_function
specifier|static
name|void
name|regtail
parameter_list|(
name|p
parameter_list|,
name|val
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|scan
decl_stmt|;
specifier|register
name|char
modifier|*
name|temp
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|p
operator|==
operator|&
name|regdummy
condition|)
return|return;
comment|/* Find last node. */
name|scan
operator|=
name|p
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|temp
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
break|break;
name|scan
operator|=
name|temp
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|REGALIGN
name|offset
operator|=
name|val
operator|-
name|scan
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
operator|*
operator|(
name|short
operator|*
operator|)
operator|(
name|scan
operator|+
literal|1
operator|)
operator|=
name|offset
expr_stmt|;
else|#
directive|else
name|offset
operator|=
name|offset
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|BACK
condition|)
name|offset
operator|=
name|scan
operator|-
name|val
expr_stmt|;
else|else
name|offset
operator|=
name|val
operator|-
name|scan
expr_stmt|;
operator|*
operator|(
name|scan
operator|+
literal|1
operator|)
operator|=
operator|(
name|offset
operator|>>
literal|8
operator|)
operator|&
literal|0377
expr_stmt|;
operator|*
operator|(
name|scan
operator|+
literal|2
operator|)
operator|=
name|offset
operator|&
literal|0377
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  - regoptail - regtail on operand of first argument; nop if operandless  */
end_comment

begin_function
specifier|static
name|void
name|regoptail
parameter_list|(
name|p
parameter_list|,
name|val
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
block|{
comment|/* "Operandless" and "op != BRANCH" are synonymous in practice. */
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|==
operator|&
name|regdummy
operator|||
name|OP
argument_list|(
name|p
argument_list|)
operator|!=
name|BRANCH
condition|)
return|return;
name|regtail
argument_list|(
name|NEXTOPER
argument_list|(
name|p
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - regcurly - a little FSA that accepts {\d+,?\d*}  */
end_comment

begin_function
name|STATIC
name|int
name|regcurly
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
literal|'{'
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return
name|FALSE
return|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|isDIGIT
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'}'
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING
end_ifdef

begin_comment
comment|/*  - regdump - dump a regexp onto stderr in vaguely comprehensible form  */
end_comment

begin_function
name|void
name|regdump
parameter_list|(
name|r
parameter_list|)
name|regexp
modifier|*
name|r
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
name|op
init|=
name|EXACTLY
decl_stmt|;
comment|/* Arbitrary non-END op. */
specifier|register
name|char
modifier|*
name|next
decl_stmt|;
name|s
operator|=
name|r
operator|->
name|program
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|op
operator|!=
name|END
condition|)
block|{
comment|/* While that wasn't END last time... */
ifdef|#
directive|ifdef
name|REGALIGN
if|if
condition|(
operator|!
operator|(
operator|(
name|long
operator|)
name|s
operator|&
literal|1
operator|)
condition|)
name|s
operator|++
expr_stmt|;
endif|#
directive|endif
name|op
operator|=
name|OP
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%2d%s"
argument_list|,
name|s
operator|-
name|r
operator|->
name|program
argument_list|,
name|regprop
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Where, what. */
name|next
operator|=
name|regnext
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|+=
name|regarglen
index|[
name|op
index|]
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
comment|/* Next ptr. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(0)"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(%d)"
argument_list|,
operator|(
name|s
operator|-
name|r
operator|->
name|program
operator|)
operator|+
operator|(
name|next
operator|-
name|s
operator|)
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|ANYOF
condition|)
block|{
name|s
operator|+=
literal|32
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|==
name|EXACTLY
condition|)
block|{
comment|/* Literal string, where present. */
name|s
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|putchar
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
comment|/* Header fields of interest. */
if|if
condition|(
name|r
operator|->
name|regstart
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"start `%s' "
argument_list|,
name|r
operator|->
name|regstart
operator|->
name|str_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|regstclass
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"stclass `%s' "
argument_list|,
name|regprop
argument_list|(
name|r
operator|->
name|regstclass
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_ANCH
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"anchored "
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_SKIP
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"plus "
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|reganch
operator|&
name|ROPT_IMPLICIT
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"implicit "
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|regmust
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"must have \"%s\" back %d "
argument_list|,
name|r
operator|->
name|regmust
operator|->
name|str_ptr
argument_list|,
name|r
operator|->
name|regback
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"minlen %d "
argument_list|,
name|r
operator|->
name|minlen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - regprop - printable representation of opcode  */
end_comment

begin_function
name|char
modifier|*
name|regprop
parameter_list|(
name|op
parameter_list|)
name|char
modifier|*
name|op
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|OP
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|BOL
case|:
name|p
operator|=
literal|"BOL"
expr_stmt|;
break|break;
case|case
name|EOL
case|:
name|p
operator|=
literal|"EOL"
expr_stmt|;
break|break;
case|case
name|ANY
case|:
name|p
operator|=
literal|"ANY"
expr_stmt|;
break|break;
case|case
name|ANYOF
case|:
name|p
operator|=
literal|"ANYOF"
expr_stmt|;
break|break;
case|case
name|BRANCH
case|:
name|p
operator|=
literal|"BRANCH"
expr_stmt|;
break|break;
case|case
name|EXACTLY
case|:
name|p
operator|=
literal|"EXACTLY"
expr_stmt|;
break|break;
case|case
name|NOTHING
case|:
name|p
operator|=
literal|"NOTHING"
expr_stmt|;
break|break;
case|case
name|BACK
case|:
name|p
operator|=
literal|"BACK"
expr_stmt|;
break|break;
case|case
name|END
case|:
name|p
operator|=
literal|"END"
expr_stmt|;
break|break;
case|case
name|ALNUM
case|:
name|p
operator|=
literal|"ALNUM"
expr_stmt|;
break|break;
case|case
name|NALNUM
case|:
name|p
operator|=
literal|"NALNUM"
expr_stmt|;
break|break;
case|case
name|BOUND
case|:
name|p
operator|=
literal|"BOUND"
expr_stmt|;
break|break;
case|case
name|NBOUND
case|:
name|p
operator|=
literal|"NBOUND"
expr_stmt|;
break|break;
case|case
name|SPACE
case|:
name|p
operator|=
literal|"SPACE"
expr_stmt|;
break|break;
case|case
name|NSPACE
case|:
name|p
operator|=
literal|"NSPACE"
expr_stmt|;
break|break;
case|case
name|DIGIT
case|:
name|p
operator|=
literal|"DIGIT"
expr_stmt|;
break|break;
case|case
name|NDIGIT
case|:
name|p
operator|=
literal|"NDIGIT"
expr_stmt|;
break|break;
case|case
name|CURLY
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"CURLY {%d,%d}"
argument_list|,
name|ARG1
argument_list|(
name|op
argument_list|)
argument_list|,
name|ARG2
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|REF
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"REF%d"
argument_list|,
name|ARG1
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|OPEN
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"OPEN%d"
argument_list|,
name|ARG1
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|CLOSE
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"CLOSE%d"
argument_list|,
name|ARG1
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|STAR
case|:
name|p
operator|=
literal|"STAR"
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|p
operator|=
literal|"PLUS"
expr_stmt|;
break|break;
default|default:
name|FAIL
argument_list|(
literal|"corrupted regexp opcode"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUGGING */
end_comment

begin_function
name|void
name|regfree
parameter_list|(
name|r
parameter_list|)
name|struct
name|regexp
modifier|*
name|r
decl_stmt|;
block|{
if|if
condition|(
name|r
operator|->
name|precomp
condition|)
block|{
name|Safefree
argument_list|(
name|r
operator|->
name|precomp
argument_list|)
expr_stmt|;
name|r
operator|->
name|precomp
operator|=
name|Nullch
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|subbase
condition|)
block|{
name|Safefree
argument_list|(
name|r
operator|->
name|subbase
argument_list|)
expr_stmt|;
name|r
operator|->
name|subbase
operator|=
name|Nullch
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|regmust
condition|)
block|{
name|str_free
argument_list|(
name|r
operator|->
name|regmust
argument_list|)
expr_stmt|;
name|r
operator|->
name|regmust
operator|=
name|Nullstr
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|regstart
condition|)
block|{
name|str_free
argument_list|(
name|r
operator|->
name|regstart
argument_list|)
expr_stmt|;
name|r
operator|->
name|regstart
operator|=
name|Nullstr
expr_stmt|;
block|}
name|Safefree
argument_list|(
name|r
operator|->
name|startp
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|r
operator|->
name|endp
argument_list|)
expr_stmt|;
name|Safefree
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

