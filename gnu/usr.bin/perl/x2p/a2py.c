begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $RCSfile: a2py.c,v $$Revision: 1.2 $$Date: 1995/05/30 05:03:38 $  *  *    Copyright (c) 1991, Larry Wall  *  *    You may distribute under the terms of either the GNU General Public  *    License or the Artistic License, as specified in the README file.  *  * $Log: a2py.c,v $  * Revision 1.2  1995/05/30 05:03:38  rgrimes  * Remove trailing whitespace.  *  * Revision 1.1.1.1  1994/09/10  06:27:53  gclarkii  * Initial import of Perl 4.046 bmaked  *  * Revision 1.1.1.1  1993/08/23  21:30:10  nate  * PERL!  *  * Revision 4.0.1.2  92/06/08  16:15:16  lwall  * patch20: in a2p, now warns about spurious backslashes  * patch20: in a2p, now allows [ to be backslashed in pattern  * patch20: in a2p, now allows numbers of the form 2.  *  * Revision 4.0.1.1  91/06/07  12:12:59  lwall  * patch4: new copyright notice  *  * Revision 4.0  91/03/20  01:57:26  lwall  * 4.0 baseline.  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OS2
end_ifdef

begin_include
include|#
directive|include
file|"../patchlevel.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_function_decl
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|myname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|checkers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|STR
modifier|*
name|walk
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|OS2
end_ifdef

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"\nThis is the AWK to PERL translator, version 4.0, patchlevel %d\n"
argument_list|,
name|PATCHLEVEL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nUsage: %s [-D<number>] [-F<char>] [-n<fieldlist>] [-<number>] filename\n"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n  -D<number>      sets debugging flags."
literal|"\n  -F<character>   the awk script to translate is always invoked with"
literal|"\n                  this -F switch."
literal|"\n  -n<fieldlist>   specifies the names of the input fields if input does"
literal|"\n                  not have to be split into an array."
literal|"\n  -<number>       causes a2p to assume that input will always have that"
literal|"\n                  many fields.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|env
parameter_list|)
specifier|register
name|int
name|argc
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
specifier|register
name|STR
modifier|*
name|str
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|STR
modifier|*
name|tmpstr
decl_stmt|;
name|myname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|linestr
operator|=
name|str_new
argument_list|(
literal|80
argument_list|)
expr_stmt|;
name|str
operator|=
name|str_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* first used for -I flags */
for|for
control|(
name|argc
operator|--
operator|,
name|argv
operator|++
init|;
name|argc
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
operator|!
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
break|break;
name|reswitch
label|:
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGGING
case|case
literal|'D'
case|:
name|debug
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|0
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|YYDEBUG
name|yydebug
operator|=
operator|(
name|debug
operator|&
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
break|break;
endif|#
directive|endif
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|maxfld
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
name|absmaxfld
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|fswitch
operator|=
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|namelist
operator|=
name|savestr
argument_list|(
name|argv
index|[
literal|0
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
goto|goto
name|switch_end
goto|;
case|case
literal|0
case|:
break|break;
default|default:
name|fatal
argument_list|(
literal|"Unrecognized switch: %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OS2
name|usage
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|switch_end
label|:
comment|/* open script */
if|if
condition|(
name|argv
index|[
literal|0
index|]
operator|==
name|Nullch
condition|)
block|{
ifdef|#
directive|ifdef
name|OS2
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
name|usage
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|argv
index|[
literal|0
index|]
operator|=
literal|"-"
expr_stmt|;
block|}
name|filename
operator|=
name|savestr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|filename
operator|=
name|savestr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
condition|)
name|argv
index|[
literal|0
index|]
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|argv
index|[
literal|0
index|]
condition|)
name|rsfp
operator|=
name|stdin
expr_stmt|;
else|else
name|rsfp
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsfp
operator|==
name|Nullfp
condition|)
name|fatal
argument_list|(
literal|"Awk script \"%s\" doesn't seem to exist.\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* init tokener */
name|bufptr
operator|=
name|str_get
argument_list|(
name|linestr
argument_list|)
expr_stmt|;
name|symtab
operator|=
name|hnew
argument_list|()
expr_stmt|;
name|curarghash
operator|=
name|hnew
argument_list|()
expr_stmt|;
comment|/* now parse the report spec */
if|if
condition|(
name|yyparse
argument_list|()
condition|)
name|fatal
argument_list|(
literal|"Translation aborted due to syntax errors.\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|2
condition|)
block|{
name|int
name|type
decl_stmt|,
name|len
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|mop
condition|;
control|)
block|{
name|type
operator|=
name|ops
index|[
name|i
index|]
operator|.
name|ival
expr_stmt|;
name|len
operator|=
name|type
operator|>>
literal|8
expr_stmt|;
name|type
operator|&=
literal|255
expr_stmt|;
name|printf
argument_list|(
literal|"%d\t%d\t%d\t%-10s"
argument_list|,
name|i
operator|++
argument_list|,
name|type
argument_list|,
name|len
argument_list|,
name|opname
index|[
name|type
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OSTRING
condition|)
name|printf
argument_list|(
literal|"\t\"%s\"\n"
argument_list|,
name|ops
index|[
name|i
index|]
operator|.
name|cval
argument_list|)
operator|,
name|i
operator|++
expr_stmt|;
else|else
block|{
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|printf
argument_list|(
literal|"\t%d"
argument_list|,
name|ops
index|[
name|i
index|]
operator|.
name|ival
argument_list|)
operator|,
name|i
operator|++
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|debug
operator|&
literal|8
condition|)
name|dump
argument_list|(
name|root
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* first pass to look for numeric variables */
name|prewalk
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|root
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
comment|/* second pass to produce new program */
name|tmpstr
operator|=
name|walk
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|root
argument_list|,
operator|&
name|i
argument_list|,
name|P_MIN
argument_list|)
expr_stmt|;
name|str
operator|=
name|str_make
argument_list|(
literal|"#!"
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|str
argument_list|,
name|BIN
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|str
argument_list|,
literal|"/perl\neval \"exec "
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|str
argument_list|,
name|BIN
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|str
argument_list|,
literal|"/perl -S $0 $*\"\n\     if $running_under_some_shell;\n\ 			# this emulates #! processing on NIH machines.\n\ 			# (remove #! line above if indigestible)\n\n"
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|str
argument_list|,
literal|"eval '$'.$1.'$2;' while $ARGV[0] =~ /^([A-Za-z_]+=)(.*)/&& shift;\n"
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|str
argument_list|,
literal|"			# process any FOO=bar switches\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_opens
operator|&&
name|opens
condition|)
block|{
name|str_scat
argument_list|(
name|str
argument_list|,
name|opens
argument_list|)
expr_stmt|;
name|str_free
argument_list|(
name|opens
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|str
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|str_scat
argument_list|(
name|str
argument_list|,
name|tmpstr
argument_list|)
expr_stmt|;
name|str_free
argument_list|(
name|tmpstr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
operator|!
operator|(
name|debug
operator|&
literal|16
operator|)
condition|)
endif|#
directive|endif
name|fixup
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|putlines
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|checkers
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Please check my work on the %d line%s I've marked with \"#???\".\n"
argument_list|,
name|checkers
argument_list|,
name|checkers
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"The operation I've selected may be wrong for the operand types.\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|RETURN
parameter_list|(
name|retval
parameter_list|)
value|return (bufptr = s,retval)
end_define

begin_define
define|#
directive|define
name|XTERM
parameter_list|(
name|retval
parameter_list|)
value|return (expectterm = TRUE,bufptr = s,retval)
end_define

begin_define
define|#
directive|define
name|XOP
parameter_list|(
name|retval
parameter_list|)
value|return (expectterm = FALSE,bufptr = s,retval)
end_define

begin_define
define|#
directive|define
name|ID
parameter_list|(
name|x
parameter_list|)
value|return (yylval=string(x,0),expectterm = FALSE,bufptr = s,idtype)
end_define

begin_decl_stmt
name|int
name|idtype
decl_stmt|;
end_decl_stmt

begin_macro
name|yylex
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|bufptr
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|int
name|tmp
decl_stmt|;
name|retry
label|:
ifdef|#
directive|ifdef
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
if|if
condition|(
name|index
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tokener at %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Tokener at %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unrecognized character %c in file %s line %d--ignoring.\n"
argument_list|,
operator|*
name|s
operator|++
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
literal|'\\'
case|:
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
condition|)
block|{
name|yyerror
argument_list|(
literal|"Ignoring spurious backslash"
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
comment|/*FALLSTHROUGH*/
case|case
literal|0
case|:
name|s
operator|=
name|str_get
argument_list|(
name|linestr
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|rsfp
condition|)
name|RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|line
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|str_gets
argument_list|(
name|linestr
argument_list|,
name|rsfp
argument_list|)
operator|)
operator|==
name|Nullch
condition|)
block|{
if|if
condition|(
name|rsfp
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|rsfp
argument_list|)
expr_stmt|;
name|rsfp
operator|=
name|Nullfp
expr_stmt|;
name|s
operator|=
name|str_get
argument_list|(
name|linestr
argument_list|)
expr_stmt|;
name|RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
goto|goto
name|retry
goto|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
name|s
operator|++
expr_stmt|;
goto|goto
name|retry
goto|;
case|case
literal|'\n'
case|:
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|XTERM
argument_list|(
name|NEWLINE
argument_list|)
expr_stmt|;
case|case
literal|'#'
case|:
name|yylval
operator|=
name|string
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|XTERM
argument_list|(
name|COMMENT
argument_list|)
expr_stmt|;
case|case
literal|';'
case|:
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|XTERM
argument_list|(
name|SEMINEW
argument_list|)
expr_stmt|;
block|}
name|XTERM
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
case|case
literal|'('
case|:
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|XTERM
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
case|case
literal|'{'
case|:
case|case
literal|'['
case|:
case|case
literal|')'
case|:
case|case
literal|']'
case|:
case|case
literal|'?'
case|:
case|case
literal|':'
case|:
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|XOP
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
case|case
literal|127
case|:
name|s
operator|++
expr_stmt|;
name|XTERM
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
case|case
literal|'}'
case|:
for|for
control|(
name|d
operator|=
name|s
operator|+
literal|1
init|;
name|isspace
argument_list|(
operator|*
name|d
argument_list|)
condition|;
name|d
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|d
condition|)
name|s
operator|=
name|d
operator|-
literal|1
expr_stmt|;
operator|*
name|s
operator|=
literal|127
expr_stmt|;
name|XTERM
argument_list|(
literal|';'
argument_list|)
expr_stmt|;
case|case
literal|','
case|:
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|XTERM
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
case|case
literal|'~'
case|:
name|s
operator|++
expr_stmt|;
name|yylval
operator|=
name|string
argument_list|(
literal|"~"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XTERM
argument_list|(
name|MATCHOP
argument_list|)
expr_stmt|;
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
operator|*
name|s
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'+'
condition|)
name|XTERM
argument_list|(
name|INCR
argument_list|)
expr_stmt|;
else|else
name|XTERM
argument_list|(
name|DECR
argument_list|)
expr_stmt|;
block|}
comment|/* FALL THROUGH */
case|case
literal|'*'
case|:
case|case
literal|'%'
case|:
case|case
literal|'^'
case|:
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
condition|)
block|{
if|if
condition|(
name|tmp
operator|==
literal|'^'
condition|)
name|yylval
operator|=
name|string
argument_list|(
literal|"**="
argument_list|,
literal|3
argument_list|)
expr_stmt|;
else|else
name|yylval
operator|=
name|string
argument_list|(
name|s
operator|-
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|XTERM
argument_list|(
name|ASGNOP
argument_list|)
expr_stmt|;
block|}
name|XTERM
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
case|case
literal|'&'
case|:
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'&'
condition|)
name|XTERM
argument_list|(
name|ANDAND
argument_list|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
name|XTERM
argument_list|(
literal|'&'
argument_list|)
expr_stmt|;
case|case
literal|'|'
case|:
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'|'
condition|)
name|XTERM
argument_list|(
name|OROR
argument_list|)
expr_stmt|;
name|s
operator|--
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"getline"
argument_list|,
literal|7
argument_list|)
condition|)
name|XTERM
argument_list|(
literal|'p'
argument_list|)
expr_stmt|;
else|else
name|XTERM
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
case|case
literal|'='
case|:
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'='
condition|)
block|{
name|yylval
operator|=
name|string
argument_list|(
literal|"=="
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|XTERM
argument_list|(
name|RELOP
argument_list|)
expr_stmt|;
block|}
name|s
operator|--
expr_stmt|;
name|yylval
operator|=
name|string
argument_list|(
literal|"="
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|XTERM
argument_list|(
name|ASGNOP
argument_list|)
expr_stmt|;
case|case
literal|'!'
case|:
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'='
condition|)
block|{
name|yylval
operator|=
name|string
argument_list|(
literal|"!="
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|XTERM
argument_list|(
name|RELOP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|==
literal|'~'
condition|)
block|{
name|yylval
operator|=
name|string
argument_list|(
literal|"!~"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|XTERM
argument_list|(
name|MATCHOP
argument_list|)
expr_stmt|;
block|}
name|s
operator|--
expr_stmt|;
name|XTERM
argument_list|(
name|NOT
argument_list|)
expr_stmt|;
case|case
literal|'<'
case|:
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'='
condition|)
block|{
name|yylval
operator|=
name|string
argument_list|(
literal|"<="
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|XTERM
argument_list|(
name|RELOP
argument_list|)
expr_stmt|;
block|}
name|s
operator|--
expr_stmt|;
name|XTERM
argument_list|(
literal|'<'
argument_list|)
expr_stmt|;
case|case
literal|'>'
case|:
name|s
operator|++
expr_stmt|;
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|'>'
condition|)
block|{
name|yylval
operator|=
name|string
argument_list|(
literal|">>"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|XTERM
argument_list|(
name|GRGR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|==
literal|'='
condition|)
block|{
name|yylval
operator|=
name|string
argument_list|(
literal|">="
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|XTERM
argument_list|(
name|RELOP
argument_list|)
expr_stmt|;
block|}
name|s
operator|--
expr_stmt|;
name|XTERM
argument_list|(
literal|'>'
argument_list|)
expr_stmt|;
define|#
directive|define
name|SNARFWORD
define|\
value|d = tokenbuf; \ 	while (isalpha(*s) || isdigit(*s) || *s == '_') \ 	    *d++ = *s++; \ 	*d = '\0'; \ 	d = tokenbuf; \ 	if (*s == '(') \ 	    idtype = USERFUN; \ 	else \ 	    idtype = VAR;
case|case
literal|'$'
case|:
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'0'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|do_chop
operator|=
name|TRUE
expr_stmt|;
name|need_entire
operator|=
name|TRUE
expr_stmt|;
name|idtype
operator|=
name|VAR
expr_stmt|;
name|ID
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
block|}
name|do_split
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
for|for
control|(
name|d
operator|=
name|s
init|;
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
name|yylval
operator|=
name|string
argument_list|(
name|d
argument_list|,
name|s
operator|-
name|d
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|atoi
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
name|maxfld
condition|)
name|maxfld
operator|=
name|tmp
expr_stmt|;
name|XOP
argument_list|(
name|FIELD
argument_list|)
expr_stmt|;
block|}
name|split_to_array
operator|=
name|set_array_base
operator|=
name|TRUE
expr_stmt|;
name|XOP
argument_list|(
name|VFIELD
argument_list|)
expr_stmt|;
case|case
literal|'/'
case|:
comment|/* may either be division or pattern */
if|if
condition|(
name|expectterm
condition|)
block|{
name|s
operator|=
name|scanpat
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|XTERM
argument_list|(
name|REGEX
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
condition|)
block|{
name|yylval
operator|=
name|string
argument_list|(
literal|"/="
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|XTERM
argument_list|(
name|ASGNOP
argument_list|)
expr_stmt|;
block|}
name|XTERM
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'.'
case|:
name|s
operator|=
name|scannum
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|XOP
argument_list|(
name|NUMBER
argument_list|)
expr_stmt|;
case|case
literal|'"'
case|:
name|s
operator|++
expr_stmt|;
name|s
operator|=
name|cpy2
argument_list|(
name|tokenbuf
argument_list|,
name|s
argument_list|,
name|s
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
name|fatal
argument_list|(
literal|"String not terminated:\n%s"
argument_list|,
name|str_get
argument_list|(
name|linestr
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|yylval
operator|=
name|string
argument_list|(
name|tokenbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|XOP
argument_list|(
name|STRING
argument_list|)
expr_stmt|;
case|case
literal|'a'
case|:
case|case
literal|'A'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ARGC"
argument_list|)
condition|)
name|set_array_base
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ARGV"
argument_list|)
condition|)
block|{
name|yylval
operator|=
name|numary
argument_list|(
name|string
argument_list|(
literal|"ARGV"
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|XOP
argument_list|(
name|VAR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"atan2"
argument_list|)
condition|)
block|{
name|yylval
operator|=
name|OATAN2
expr_stmt|;
name|XTERM
argument_list|(
name|FUNN
argument_list|)
expr_stmt|;
block|}
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"break"
argument_list|)
condition|)
name|XTERM
argument_list|(
name|BREAK
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"BEGIN"
argument_list|)
condition|)
name|XTERM
argument_list|(
name|BEGIN
argument_list|)
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'c'
case|:
case|case
literal|'C'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"continue"
argument_list|)
condition|)
name|XTERM
argument_list|(
name|CONTINUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"cos"
argument_list|)
condition|)
block|{
name|yylval
operator|=
name|OCOS
expr_stmt|;
name|XTERM
argument_list|(
name|FUN1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"close"
argument_list|)
condition|)
block|{
name|do_fancy_opens
operator|=
literal|1
expr_stmt|;
name|yylval
operator|=
name|OCLOSE
expr_stmt|;
name|XTERM
argument_list|(
name|FUN1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"chdir"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"crypt"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"chop"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"chmod"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"chown"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"do"
argument_list|)
condition|)
name|XTERM
argument_list|(
name|DO
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"delete"
argument_list|)
condition|)
name|XTERM
argument_list|(
name|DELETE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"die"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"END"
argument_list|)
condition|)
name|XTERM
argument_list|(
name|END
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"else"
argument_list|)
condition|)
name|XTERM
argument_list|(
name|ELSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"exit"
argument_list|)
condition|)
block|{
name|saw_line_op
operator|=
name|TRUE
expr_stmt|;
name|XTERM
argument_list|(
name|EXIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"exp"
argument_list|)
condition|)
block|{
name|yylval
operator|=
name|OEXP
expr_stmt|;
name|XTERM
argument_list|(
name|FUN1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"elsif"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"eq"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"eval"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"eof"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"each"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"exec"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"FS"
argument_list|)
condition|)
block|{
name|saw_FS
operator|++
expr_stmt|;
if|if
condition|(
name|saw_FS
operator|==
literal|1
operator|&&
name|in_begin
condition|)
block|{
for|for
control|(
name|d
operator|=
name|s
init|;
operator|*
name|d
operator|&&
name|isspace
argument_list|(
operator|*
name|d
argument_list|)
condition|;
name|d
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|d
operator|==
literal|'='
condition|)
block|{
for|for
control|(
name|d
operator|++
init|;
operator|*
name|d
operator|&&
name|isspace
argument_list|(
operator|*
name|d
argument_list|)
condition|;
name|d
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|d
operator|==
literal|'"'
operator|&&
name|d
index|[
literal|2
index|]
operator|==
literal|'"'
condition|)
name|const_FS
operator|=
name|d
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
name|ID
argument_list|(
name|tokenbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"for"
argument_list|)
condition|)
name|XTERM
argument_list|(
name|FOR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"function"
argument_list|)
condition|)
name|XTERM
argument_list|(
name|FUNCTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"FILENAME"
argument_list|)
condition|)
name|d
operator|=
literal|"ARGV"
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"foreach"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"format"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"fork"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"fh"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"getline"
argument_list|)
condition|)
name|XTERM
argument_list|(
name|GETLINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"gsub"
argument_list|)
condition|)
name|XTERM
argument_list|(
name|GSUB
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ge"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"gt"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"goto"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"gmtime"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"hex"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"if"
argument_list|)
condition|)
name|XTERM
argument_list|(
name|IF
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"in"
argument_list|)
condition|)
name|XTERM
argument_list|(
name|IN
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"index"
argument_list|)
condition|)
block|{
name|set_array_base
operator|=
name|TRUE
expr_stmt|;
name|XTERM
argument_list|(
name|INDEX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"int"
argument_list|)
condition|)
block|{
name|yylval
operator|=
name|OINT
expr_stmt|;
name|XTERM
argument_list|(
name|FUN1
argument_list|)
expr_stmt|;
block|}
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'j'
case|:
case|case
literal|'J'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"join"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'k'
case|:
case|case
literal|'K'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"keys"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"kill"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"length"
argument_list|)
condition|)
block|{
name|yylval
operator|=
name|OLENGTH
expr_stmt|;
name|XTERM
argument_list|(
name|FUN1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"log"
argument_list|)
condition|)
block|{
name|yylval
operator|=
name|OLOG
expr_stmt|;
name|XTERM
argument_list|(
name|FUN1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"last"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"local"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"lt"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"le"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"locatime"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"link"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"match"
argument_list|)
condition|)
block|{
name|set_array_base
operator|=
name|TRUE
expr_stmt|;
name|XTERM
argument_list|(
name|MATCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"m"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"NF"
argument_list|)
condition|)
name|do_chop
operator|=
name|do_split
operator|=
name|split_to_array
operator|=
name|set_array_base
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"next"
argument_list|)
condition|)
block|{
name|saw_line_op
operator|=
name|TRUE
expr_stmt|;
name|XTERM
argument_list|(
name|NEXT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ne"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'o'
case|:
case|case
literal|'O'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ORS"
argument_list|)
condition|)
block|{
name|saw_ORS
operator|=
name|TRUE
expr_stmt|;
name|d
operator|=
literal|"\\"
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"OFS"
argument_list|)
condition|)
block|{
name|saw_OFS
operator|=
name|TRUE
expr_stmt|;
name|d
operator|=
literal|","
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"OFMT"
argument_list|)
condition|)
block|{
name|d
operator|=
literal|"#"
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"open"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"ord"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"oct"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"print"
argument_list|)
condition|)
block|{
name|XTERM
argument_list|(
name|PRINT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"printf"
argument_list|)
condition|)
block|{
name|XTERM
argument_list|(
name|PRINTF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"push"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"pop"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
name|SNARFWORD
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"RS"
argument_list|)
condition|)
block|{
name|d
operator|=
literal|"/"
expr_stmt|;
name|saw_RS
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"rand"
argument_list|)
condition|)
block|{
name|yylval
operator|=
name|ORAND
expr_stmt|;
name|XTERM
argument_list|(
name|FUN1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"return"
argument_list|)
condition|)
name|XTERM
argument_list|(
name|RET
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"reset"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"redo"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"rename"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"split"
argument_list|)
condition|)
block|{
name|set_array_base
operator|=
name|TRUE
expr_stmt|;
name|XOP
argument_list|(
name|SPLIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"substr"
argument_list|)
condition|)
block|{
name|set_array_base
operator|=
name|TRUE
expr_stmt|;
name|XTERM
argument_list|(
name|SUBSTR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sub"
argument_list|)
condition|)
name|XTERM
argument_list|(
name|SUB
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sprintf"
argument_list|)
condition|)
name|XTERM
argument_list|(
name|SPRINTF
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sqrt"
argument_list|)
condition|)
block|{
name|yylval
operator|=
name|OSQRT
expr_stmt|;
name|XTERM
argument_list|(
name|FUN1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"SUBSEP"
argument_list|)
condition|)
block|{
name|d
operator|=
literal|";"
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sin"
argument_list|)
condition|)
block|{
name|yylval
operator|=
name|OSIN
expr_stmt|;
name|XTERM
argument_list|(
name|FUN1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"srand"
argument_list|)
condition|)
block|{
name|yylval
operator|=
name|OSRAND
expr_stmt|;
name|XTERM
argument_list|(
name|FUN1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"system"
argument_list|)
condition|)
block|{
name|yylval
operator|=
name|OSYSTEM
expr_stmt|;
name|XTERM
argument_list|(
name|FUN1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"s"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"shift"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"select"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"seek"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"stat"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"study"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sleep"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"symlink"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"sort"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'t'
case|:
case|case
literal|'T'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"tr"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"tell"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"time"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"times"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"until"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"unless"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"umask"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"unshift"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"unlink"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"utime"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"values"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"while"
argument_list|)
condition|)
name|XTERM
argument_list|(
name|WHILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"write"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"wait"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"x"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'y'
case|:
case|case
literal|'Y'
case|:
name|SNARFWORD
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|d
argument_list|,
literal|"y"
argument_list|)
condition|)
operator|*
name|d
operator|=
name|toupper
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
case|case
literal|'z'
case|:
case|case
literal|'Z'
case|:
name|SNARFWORD
expr_stmt|;
name|ID
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|scanpat
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'/'
case|:
break|break;
default|default:
name|fatal
argument_list|(
literal|"Search pattern not found:\n%s"
argument_list|,
name|str_get
argument_list|(
name|linestr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|d
operator|=
name|tokenbuf
expr_stmt|;
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
operator|,
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'\\'
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'['
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'['
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\\'
operator|&&
name|s
index|[
literal|1
index|]
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'/'
operator|||
operator|(
operator|*
name|s
operator|==
literal|'-'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|']'
operator|)
condition|)
operator|*
name|d
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|']'
condition|)
do|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'/'
condition|)
break|break;
operator|*
name|d
operator|=
operator|*
name|s
expr_stmt|;
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
name|fatal
argument_list|(
literal|"Search pattern not terminated:\n%s"
argument_list|,
name|str_get
argument_list|(
name|linestr
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|yylval
operator|=
name|string
argument_list|(
name|tokenbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_macro
name|yyerror
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s in file %s at line %d\n"
argument_list|,
name|s
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|scannum
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'0'
case|:
case|case
literal|'.'
case|:
name|d
operator|=
name|tokenbuf
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
block|}
else|else
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|index
argument_list|(
literal|"eE"
argument_list|,
operator|*
name|s
argument_list|)
operator|&&
name|index
argument_list|(
literal|"+-0123456789"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
operator|||
operator|*
name|s
operator|==
literal|'-'
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|yylval
operator|=
name|string
argument_list|(
name|tokenbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|s
return|;
block|}
end_function

begin_macro
name|string
argument_list|(
argument|ptr
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|retval
init|=
name|mop
decl_stmt|;
name|ops
index|[
name|mop
operator|++
index|]
operator|.
name|ival
operator|=
name|OSTRING
operator|+
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ops
index|[
name|mop
index|]
operator|.
name|cval
operator|=
name|safemalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ops
index|[
name|mop
index|]
operator|.
name|cval
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ops
index|[
name|mop
operator|++
index|]
operator|.
name|cval
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|mop
operator|>=
name|OPSMAX
condition|)
name|fatal
argument_list|(
literal|"Recompile a2p with larger OPSMAX\n"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_block

begin_macro
name|oper0
argument_list|(
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|retval
init|=
name|mop
decl_stmt|;
if|if
condition|(
name|type
operator|>
literal|255
condition|)
name|fatal
argument_list|(
literal|"type> 255 (%d)\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ops
index|[
name|mop
operator|++
index|]
operator|.
name|ival
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|mop
operator|>=
name|OPSMAX
condition|)
name|fatal
argument_list|(
literal|"Recompile a2p with larger OPSMAX\n"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_block

begin_macro
name|oper1
argument_list|(
argument|type
argument_list|,
argument|arg1
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg1
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|retval
init|=
name|mop
decl_stmt|;
if|if
condition|(
name|type
operator|>
literal|255
condition|)
name|fatal
argument_list|(
literal|"type> 255 (%d)\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ops
index|[
name|mop
operator|++
index|]
operator|.
name|ival
operator|=
name|type
operator|+
operator|(
literal|1
operator|<<
literal|8
operator|)
expr_stmt|;
name|ops
index|[
name|mop
operator|++
index|]
operator|.
name|ival
operator|=
name|arg1
expr_stmt|;
if|if
condition|(
name|mop
operator|>=
name|OPSMAX
condition|)
name|fatal
argument_list|(
literal|"Recompile a2p with larger OPSMAX\n"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_block

begin_macro
name|oper2
argument_list|(
argument|type
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|retval
init|=
name|mop
decl_stmt|;
if|if
condition|(
name|type
operator|>
literal|255
condition|)
name|fatal
argument_list|(
literal|"type> 255 (%d)\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ops
index|[
name|mop
operator|++
index|]
operator|.
name|ival
operator|=
name|type
operator|+
operator|(
literal|2
operator|<<
literal|8
operator|)
expr_stmt|;
name|ops
index|[
name|mop
operator|++
index|]
operator|.
name|ival
operator|=
name|arg1
expr_stmt|;
name|ops
index|[
name|mop
operator|++
index|]
operator|.
name|ival
operator|=
name|arg2
expr_stmt|;
if|if
condition|(
name|mop
operator|>=
name|OPSMAX
condition|)
name|fatal
argument_list|(
literal|"Recompile a2p with larger OPSMAX\n"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_block

begin_macro
name|oper3
argument_list|(
argument|type
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg3
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|retval
init|=
name|mop
decl_stmt|;
if|if
condition|(
name|type
operator|>
literal|255
condition|)
name|fatal
argument_list|(
literal|"type> 255 (%d)\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ops
index|[
name|mop
operator|++
index|]
operator|.
name|ival
operator|=
name|type
operator|+
operator|(
literal|3
operator|<<
literal|8
operator|)
expr_stmt|;
name|ops
index|[
name|mop
operator|++
index|]
operator|.
name|ival
operator|=
name|arg1
expr_stmt|;
name|ops
index|[
name|mop
operator|++
index|]
operator|.
name|ival
operator|=
name|arg2
expr_stmt|;
name|ops
index|[
name|mop
operator|++
index|]
operator|.
name|ival
operator|=
name|arg3
expr_stmt|;
if|if
condition|(
name|mop
operator|>=
name|OPSMAX
condition|)
name|fatal
argument_list|(
literal|"Recompile a2p with larger OPSMAX\n"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_block

begin_macro
name|oper4
argument_list|(
argument|type
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|,
argument|arg4
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg4
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|retval
init|=
name|mop
decl_stmt|;
if|if
condition|(
name|type
operator|>
literal|255
condition|)
name|fatal
argument_list|(
literal|"type> 255 (%d)\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ops
index|[
name|mop
operator|++
index|]
operator|.
name|ival
operator|=
name|type
operator|+
operator|(
literal|4
operator|<<
literal|8
operator|)
expr_stmt|;
name|ops
index|[
name|mop
operator|++
index|]
operator|.
name|ival
operator|=
name|arg1
expr_stmt|;
name|ops
index|[
name|mop
operator|++
index|]
operator|.
name|ival
operator|=
name|arg2
expr_stmt|;
name|ops
index|[
name|mop
operator|++
index|]
operator|.
name|ival
operator|=
name|arg3
expr_stmt|;
name|ops
index|[
name|mop
operator|++
index|]
operator|.
name|ival
operator|=
name|arg4
expr_stmt|;
if|if
condition|(
name|mop
operator|>=
name|OPSMAX
condition|)
name|fatal
argument_list|(
literal|"Recompile a2p with larger OPSMAX\n"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_block

begin_macro
name|oper5
argument_list|(
argument|type
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|,
argument|arg4
argument_list|,
argument|arg5
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg5
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|retval
init|=
name|mop
decl_stmt|;
if|if
condition|(
name|type
operator|>
literal|255
condition|)
name|fatal
argument_list|(
literal|"type> 255 (%d)\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ops
index|[
name|mop
operator|++
index|]
operator|.
name|ival
operator|=
name|type
operator|+
operator|(
literal|5
operator|<<
literal|8
operator|)
expr_stmt|;
name|ops
index|[
name|mop
operator|++
index|]
operator|.
name|ival
operator|=
name|arg1
expr_stmt|;
name|ops
index|[
name|mop
operator|++
index|]
operator|.
name|ival
operator|=
name|arg2
expr_stmt|;
name|ops
index|[
name|mop
operator|++
index|]
operator|.
name|ival
operator|=
name|arg3
expr_stmt|;
name|ops
index|[
name|mop
operator|++
index|]
operator|.
name|ival
operator|=
name|arg4
expr_stmt|;
name|ops
index|[
name|mop
operator|++
index|]
operator|.
name|ival
operator|=
name|arg5
expr_stmt|;
if|if
condition|(
name|mop
operator|>=
name|OPSMAX
condition|)
name|fatal
argument_list|(
literal|"Recompile a2p with larger OPSMAX\n"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_block

begin_decl_stmt
name|int
name|depth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|dump
argument_list|(
argument|branch
argument_list|)
end_macro

begin_decl_stmt
name|int
name|branch
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|type
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|type
operator|=
name|ops
index|[
name|branch
index|]
operator|.
name|ival
expr_stmt|;
name|len
operator|=
name|type
operator|>>
literal|8
expr_stmt|;
name|type
operator|&=
literal|255
expr_stmt|;
for|for
control|(
name|i
operator|=
name|depth
init|;
name|i
condition|;
name|i
operator|--
control|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OSTRING
condition|)
block|{
name|printf
argument_list|(
literal|"%-5d\"%s\"\n"
argument_list|,
name|branch
argument_list|,
name|ops
index|[
name|branch
operator|+
literal|1
index|]
operator|.
name|cval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"(%-5d%s %d\n"
argument_list|,
name|branch
argument_list|,
name|opname
index|[
name|type
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|depth
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|len
condition|;
name|i
operator|++
control|)
name|dump
argument_list|(
name|ops
index|[
name|branch
operator|+
name|i
index|]
operator|.
name|ival
argument_list|)
expr_stmt|;
name|depth
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
name|depth
init|;
name|i
condition|;
name|i
operator|--
control|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|bl
argument_list|(
argument|arg
argument_list|,
argument|maybe
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maybe
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|arg
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
name|ops
index|[
name|arg
index|]
operator|.
name|ival
operator|&
literal|255
operator|)
operator|!=
name|OBLOCK
condition|)
return|return
name|oper2
argument_list|(
name|OBLOCK
argument_list|,
name|arg
argument_list|,
name|maybe
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
name|ops
index|[
name|arg
index|]
operator|.
name|ival
operator|>>
literal|8
operator|)
operator|<
literal|2
condition|)
return|return
name|oper2
argument_list|(
name|OBLOCK
argument_list|,
name|ops
index|[
name|arg
operator|+
literal|1
index|]
operator|.
name|ival
argument_list|,
name|maybe
argument_list|)
return|;
else|else
return|return
name|arg
return|;
block|}
end_block

begin_macro
name|fixup
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|STR
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|s
operator|=
name|str
operator|->
name|str_ptr
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|';'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|' '
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
block|{
name|strcpy
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|s
operator|+
literal|2
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
condition|)
block|{
for|for
control|(
name|t
operator|=
name|s
operator|+
literal|1
init|;
name|isspace
argument_list|(
operator|*
name|t
operator|&
literal|127
argument_list|)
condition|;
name|t
operator|++
control|)
empty_stmt|;
name|t
operator|--
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|t
operator|&
literal|127
argument_list|)
operator|&&
operator|*
name|t
operator|!=
literal|'\n'
condition|)
name|t
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'\n'
operator|&&
name|t
operator|-
name|s
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'{'
condition|)
name|s
operator|--
expr_stmt|;
name|strcpy
argument_list|(
name|s
operator|+
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|putlines
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|STR
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|d
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|e
decl_stmt|;
specifier|register
name|int
name|pos
decl_stmt|,
name|newpos
decl_stmt|;
name|d
operator|=
name|tokenbuf
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s
operator|=
name|str
operator|->
name|str_ptr
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
expr_stmt|;
name|pos
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|d
operator|=
name|tokenbuf
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
name|putone
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|pos
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|pos
operator|>
literal|78
condition|)
block|{
comment|/* split a long line? */
operator|*
name|d
operator|--
operator|=
literal|'\0'
expr_stmt|;
name|newpos
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|tokenbuf
init|;
name|isspace
argument_list|(
operator|*
name|t
operator|&
literal|127
argument_list|)
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|t
operator|==
literal|'\t'
condition|)
name|newpos
operator|+=
literal|8
expr_stmt|;
else|else
name|newpos
operator|+=
literal|1
expr_stmt|;
block|}
name|e
operator|=
name|d
expr_stmt|;
while|while
condition|(
name|d
operator|>
name|tokenbuf
operator|&&
operator|(
operator|*
name|d
operator|!=
literal|' '
operator|||
name|d
index|[
operator|-
literal|1
index|]
operator|!=
literal|';'
operator|)
condition|)
name|d
operator|--
expr_stmt|;
if|if
condition|(
name|d
operator|<
name|t
operator|+
literal|10
condition|)
block|{
name|d
operator|=
name|e
expr_stmt|;
while|while
condition|(
name|d
operator|>
name|tokenbuf
operator|&&
operator|(
operator|*
name|d
operator|!=
literal|' '
operator|||
name|d
index|[
operator|-
literal|1
index|]
operator|!=
literal|'|'
operator|||
name|d
index|[
operator|-
literal|2
index|]
operator|!=
literal|'|'
operator|)
condition|)
name|d
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|<
name|t
operator|+
literal|10
condition|)
block|{
name|d
operator|=
name|e
expr_stmt|;
while|while
condition|(
name|d
operator|>
name|tokenbuf
operator|&&
operator|(
operator|*
name|d
operator|!=
literal|' '
operator|||
name|d
index|[
operator|-
literal|1
index|]
operator|!=
literal|'&'
operator|||
name|d
index|[
operator|-
literal|2
index|]
operator|!=
literal|'&'
operator|)
condition|)
name|d
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|<
name|t
operator|+
literal|10
condition|)
block|{
name|d
operator|=
name|e
expr_stmt|;
while|while
condition|(
name|d
operator|>
name|tokenbuf
operator|&&
operator|(
operator|*
name|d
operator|!=
literal|' '
operator|||
name|d
index|[
operator|-
literal|1
index|]
operator|!=
literal|','
operator|)
condition|)
name|d
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|<
name|t
operator|+
literal|10
condition|)
block|{
name|d
operator|=
name|e
expr_stmt|;
while|while
condition|(
name|d
operator|>
name|tokenbuf
operator|&&
operator|*
name|d
operator|!=
literal|' '
condition|)
name|d
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|>
name|t
operator|+
literal|3
condition|)
block|{
name|char
name|save
index|[
literal|2048
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|save
argument_list|,
name|d
argument_list|)
expr_stmt|;
operator|*
name|d
operator|=
literal|'\n'
expr_stmt|;
name|d
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|putone
argument_list|()
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
index|[
operator|-
literal|1
index|]
operator|!=
literal|';'
operator|&&
operator|!
operator|(
name|newpos
operator|%
literal|4
operator|)
condition|)
block|{
operator|*
name|t
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|' '
expr_stmt|;
name|newpos
operator|+=
literal|2
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|t
argument_list|,
name|save
operator|+
literal|1
argument_list|)
expr_stmt|;
name|newpos
operator|+=
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|d
operator|=
name|t
operator|+
name|strlen
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|pos
operator|=
name|newpos
expr_stmt|;
block|}
else|else
name|d
operator|=
name|e
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|putone
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|tokenbuf
init|;
operator|*
name|t
condition|;
name|t
operator|++
control|)
block|{
operator|*
name|t
operator|&=
literal|127
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|127
condition|)
block|{
operator|*
name|t
operator|=
literal|' '
expr_stmt|;
name|strcpy
argument_list|(
name|t
operator|+
name|strlen
argument_list|(
name|t
argument_list|)
operator|-
literal|1
argument_list|,
literal|"\t#???\n"
argument_list|)
expr_stmt|;
name|checkers
operator|++
expr_stmt|;
block|}
block|}
name|t
operator|=
name|tokenbuf
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
name|strnEQ
argument_list|(
name|t
argument_list|,
literal|"#!/bin/awk"
argument_list|,
literal|10
argument_list|)
operator|||
name|strnEQ
argument_list|(
name|t
argument_list|,
literal|"#! /bin/awk"
argument_list|,
literal|11
argument_list|)
condition|)
return|return;
if|if
condition|(
name|strnEQ
argument_list|(
name|t
argument_list|,
literal|"#!/usr/bin/awk"
argument_list|,
literal|14
argument_list|)
operator|||
name|strnEQ
argument_list|(
name|t
argument_list|,
literal|"#! /usr/bin/awk"
argument_list|,
literal|15
argument_list|)
condition|)
return|return;
block|}
name|fputs
argument_list|(
name|tokenbuf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|numary
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|STR
modifier|*
name|key
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|key
operator|=
name|walk
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|arg
argument_list|,
operator|&
name|dummy
argument_list|,
name|P_MIN
argument_list|)
expr_stmt|;
name|str_cat
argument_list|(
name|key
argument_list|,
literal|"[]"
argument_list|)
expr_stmt|;
name|hstore
argument_list|(
name|symtab
argument_list|,
name|key
operator|->
name|str_ptr
argument_list|,
name|str_make
argument_list|(
literal|"1"
argument_list|)
argument_list|)
expr_stmt|;
name|str_free
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|set_array_base
operator|=
name|TRUE
expr_stmt|;
return|return
name|arg
return|;
block|}
end_block

begin_macro
name|rememberargs
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|type
decl_stmt|;
name|STR
modifier|*
name|str
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
return|return
name|arg
return|;
name|type
operator|=
name|ops
index|[
name|arg
index|]
operator|.
name|ival
operator|&
literal|255
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OCOMMA
condition|)
block|{
name|rememberargs
argument_list|(
name|ops
index|[
name|arg
operator|+
literal|1
index|]
operator|.
name|ival
argument_list|)
expr_stmt|;
name|rememberargs
argument_list|(
name|ops
index|[
name|arg
operator|+
literal|3
index|]
operator|.
name|ival
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|OVAR
condition|)
block|{
name|str
operator|=
name|str_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hstore
argument_list|(
name|curarghash
argument_list|,
name|ops
index|[
name|ops
index|[
name|arg
operator|+
literal|1
index|]
operator|.
name|ival
operator|+
literal|1
index|]
operator|.
name|cval
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
literal|"panic: unknown argument type %d, line %d\n"
argument_list|,
name|type
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
block|}
end_block

begin_macro
name|aryrefarg
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|type
init|=
name|ops
index|[
name|arg
index|]
operator|.
name|ival
operator|&
literal|255
decl_stmt|;
name|STR
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|OSTRING
condition|)
name|fatal
argument_list|(
literal|"panic: aryrefarg %d, line %d\n"
argument_list|,
name|type
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|str
operator|=
name|hfetch
argument_list|(
name|curarghash
argument_list|,
name|ops
index|[
name|arg
operator|+
literal|1
index|]
operator|.
name|cval
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
condition|)
name|str_set
argument_list|(
name|str
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
return|return
name|arg
return|;
block|}
end_block

begin_macro
name|fixfargs
argument_list|(
argument|name
argument_list|,
argument|arg
argument_list|,
argument|prevargs
argument_list|)
end_macro

begin_decl_stmt
name|int
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prevargs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|type
decl_stmt|;
name|STR
modifier|*
name|str
decl_stmt|;
name|int
name|numargs
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
return|return
name|prevargs
return|;
name|type
operator|=
name|ops
index|[
name|arg
index|]
operator|.
name|ival
operator|&
literal|255
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OCOMMA
condition|)
block|{
name|numargs
operator|=
name|fixfargs
argument_list|(
name|name
argument_list|,
name|ops
index|[
name|arg
operator|+
literal|1
index|]
operator|.
name|ival
argument_list|,
name|prevargs
argument_list|)
expr_stmt|;
name|numargs
operator|=
name|fixfargs
argument_list|(
name|name
argument_list|,
name|ops
index|[
name|arg
operator|+
literal|3
index|]
operator|.
name|ival
argument_list|,
name|numargs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|OVAR
condition|)
block|{
name|str
operator|=
name|hfetch
argument_list|(
name|curarghash
argument_list|,
name|ops
index|[
name|ops
index|[
name|arg
operator|+
literal|1
index|]
operator|.
name|ival
operator|+
literal|1
index|]
operator|.
name|cval
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|str_get
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"*"
argument_list|)
condition|)
block|{
name|char
name|tmpbuf
index|[
literal|128
index|]
decl_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* in case another routine has this */
name|ops
index|[
name|arg
index|]
operator|.
name|ival
operator|&=
operator|~
literal|255
expr_stmt|;
name|ops
index|[
name|arg
index|]
operator|.
name|ival
operator||=
name|OSTAR
expr_stmt|;
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%s:%d"
argument_list|,
name|ops
index|[
name|name
operator|+
literal|1
index|]
operator|.
name|cval
argument_list|,
name|prevargs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Adding %s\n"
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
name|str
operator|=
name|str_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|str_set
argument_list|(
name|str
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|hstore
argument_list|(
name|curarghash
argument_list|,
name|tmpbuf
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|numargs
operator|=
name|prevargs
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
literal|"panic: unknown argument type %d, arg %d, line %d\n"
argument_list|,
name|type
argument_list|,
name|prevargs
operator|+
literal|1
argument_list|,
name|line
argument_list|)
expr_stmt|;
return|return
name|numargs
return|;
block|}
end_block

begin_macro
name|fixrargs
argument_list|(
argument|name
argument_list|,
argument|arg
argument_list|,
argument|prevargs
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prevargs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|type
decl_stmt|;
name|STR
modifier|*
name|str
decl_stmt|;
name|int
name|numargs
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
return|return
name|prevargs
return|;
name|type
operator|=
name|ops
index|[
name|arg
index|]
operator|.
name|ival
operator|&
literal|255
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|OCOMMA
condition|)
block|{
name|numargs
operator|=
name|fixrargs
argument_list|(
name|name
argument_list|,
name|ops
index|[
name|arg
operator|+
literal|1
index|]
operator|.
name|ival
argument_list|,
name|prevargs
argument_list|)
expr_stmt|;
name|numargs
operator|=
name|fixrargs
argument_list|(
name|name
argument_list|,
name|ops
index|[
name|arg
operator|+
literal|3
index|]
operator|.
name|ival
argument_list|,
name|numargs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|tmpbuf
index|[
literal|128
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"%s:%d"
argument_list|,
name|name
argument_list|,
name|prevargs
argument_list|)
expr_stmt|;
name|str
operator|=
name|hfetch
argument_list|(
name|curarghash
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|&&
name|strEQ
argument_list|(
name|str
operator|->
name|str_ptr
argument_list|,
literal|"*"
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|OVAR
operator|||
name|type
operator|==
name|OSTAR
condition|)
block|{
name|ops
index|[
name|arg
index|]
operator|.
name|ival
operator|&=
operator|~
literal|255
expr_stmt|;
name|ops
index|[
name|arg
index|]
operator|.
name|ival
operator||=
name|OSTAR
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
literal|"Can't pass expression by reference as arg %d of %s\n"
argument_list|,
name|prevargs
operator|+
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|numargs
operator|=
name|prevargs
operator|+
literal|1
expr_stmt|;
block|}
return|return
name|numargs
return|;
block|}
end_block

end_unit

