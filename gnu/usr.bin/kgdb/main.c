begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  * Modified 1990 by Van Jacobson at Lawrence Berkeley Laboratory.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)main.c	6.6 (Berkeley) 5/13/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Top level for GDB, the GNU debugger.    Copyright (C) 1986, 1987, 1988, 1989 Free Software Foundation, Inc.  This file is part of GDB.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SET_STACK_LIMIT_HUGE
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_decl_stmt
name|int
name|original_stack_limit
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If this definition isn't overridden by the header files, assume    that isatty and fileno exist on this system.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ISATTY
end_ifndef

begin_define
define|#
directive|define
name|ISATTY
parameter_list|(
name|FP
parameter_list|)
value|(isatty (fileno (FP)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|void
name|free
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Version number of GDB, as a string.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Declare all cmd_list_element's  */
end_comment

begin_comment
comment|/* Chain containing all defined commands.  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|cmdlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined info subcommands.  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|infolist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined enable subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|enablelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined disable subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|disablelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined delete subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|deletelist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined "enable breakpoint" subcommands. */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|enablebreaklist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined set subcommands */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|setlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined \"set history\".  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|sethistlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain containing all defined \"unset history\".  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|unsethistlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stdio stream that command input is being read from.  */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|instream
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current working directory.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|current_directory
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The directory name is actually stored here (usually).  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|dirbuf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|KERNELDEBUG
end_ifdef

begin_comment
comment|/* Nonzero if we're debugging /dev/mem or a kernel crash dump */
end_comment

begin_decl_stmt
name|int
name|kernel_debugging
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero to inhibit confirmation of quitting or restarting     a stopped inferior. */
end_comment

begin_decl_stmt
name|int
name|inhibit_confirm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we can write in text or core file */
end_comment

begin_decl_stmt
name|int
name|writeable_text
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of lines on a page, and the number of spaces    in a line.  */
end_comment

begin_decl_stmt
name|int
name|linesize
decl_stmt|,
name|pagesize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we should refrain from using an X window.  */
end_comment

begin_decl_stmt
name|int
name|inhibit_windows
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function to call before reading a command, if nonzero.    The function receives two args: an input stream,    and a prompt string.  */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|window_hook
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|frame_file_full_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xgdb_verbose
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|execute_command
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|free_command_lines
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|gdb_readline
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|command_line_input
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initialize_main
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initialize_cmd_lists
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|command_loop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|source_command
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_gdb_version
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|float_handler
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cd_command
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* gdb prints this when reading a command interactively */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer used for reading command lines, and the size    allocated for it so far.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|linesize
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* This is how `error' returns to command level.  */
end_comment

begin_decl_stmt
name|jmp_buf
name|to_top_level
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|return_to_top_level
parameter_list|()
block|{
name|quit_flag
operator|=
literal|0
expr_stmt|;
name|immediate_quit
operator|=
literal|0
expr_stmt|;
name|clear_breakpoint_commands
argument_list|()
expr_stmt|;
name|clear_momentary_breakpoints
argument_list|()
expr_stmt|;
name|disable_current_display
argument_list|()
expr_stmt|;
name|do_cleanups
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|to_top_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call FUNC with arg ARG, catching any errors.    If there is no error, return the value returned by FUNC.    If there is an error, return zero after printing ERRSTRING     (which is in addition to the specific error message already printed).  */
end_comment

begin_decl_stmt
name|int
name|catch_errors
argument_list|(
name|func
argument_list|,
name|arg
argument_list|,
name|errstring
argument_list|)
name|int
argument_list|(
operator|*
name|func
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|errstring
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|jmp_buf
name|saved
decl_stmt|;
name|int
name|val
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|saved_cleanup_chain
decl_stmt|;
name|saved_cleanup_chain
operator|=
name|save_cleanups
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
name|to_top_level
argument_list|,
name|saved
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|to_top_level
argument_list|)
operator|==
literal|0
condition|)
name|val
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|errstring
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
name|restore_cleanups
argument_list|(
name|saved_cleanup_chain
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|saved
argument_list|,
name|to_top_level
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_buf
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_comment
comment|/* Handler for SIGHUP.  */
end_comment

begin_function
specifier|static
name|void
name|disconnect
parameter_list|()
block|{
name|kill_inferior_fast
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Clean up on error during a "source" command (or execution of a    user-defined command).    Close the file opened by the command    and restore the previous input stream.  */
end_comment

begin_function
specifier|static
name|void
name|source_cleanup
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
comment|/* Instream may be 0; set to it when executing user-defined command. */
if|if
condition|(
name|instream
condition|)
name|fclose
argument_list|(
name|instream
argument_list|)
expr_stmt|;
name|instream
operator|=
name|stream
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Source $HOME/.gdbinit and $cwd/.gdbinit.  * If X is enabled, also $HOME/.xgdbinit and $cwd/.xgdbinit.source  */
end_comment

begin_function
name|void
name|source_init_files
parameter_list|()
block|{
name|char
modifier|*
name|homedir
decl_stmt|,
name|initfile
index|[
literal|256
index|]
decl_stmt|;
name|int
name|samedir
init|=
literal|0
decl_stmt|;
comment|/* Read init file, if it exists in home directory  */
name|homedir
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|homedir
condition|)
block|{
name|struct
name|stat
name|homebuf
decl_stmt|,
name|cwdbuf
decl_stmt|;
name|sprintf
argument_list|(
name|initfile
argument_list|,
literal|"%s/.gdbinit"
argument_list|,
name|homedir
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|initfile
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|to_top_level
argument_list|)
condition|)
name|source_command
argument_list|(
name|initfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inhibit_windows
condition|)
block|{
name|sprintf
argument_list|(
name|initfile
argument_list|,
literal|"%s/.xgdbinit"
argument_list|,
name|homedir
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|initfile
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|to_top_level
argument_list|)
condition|)
name|source_command
argument_list|(
name|initfile
argument_list|)
expr_stmt|;
block|}
comment|/* Determine if current directory is the same as the home 		   directory, so we don't source the same file twice. */
name|bzero
argument_list|(
operator|&
name|homebuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|cwdbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|homedir
argument_list|,
operator|&
name|homebuf
argument_list|)
expr_stmt|;
name|stat
argument_list|(
literal|"."
argument_list|,
operator|&
name|cwdbuf
argument_list|)
expr_stmt|;
name|samedir
operator|=
name|bcmp
argument_list|(
operator|&
name|homebuf
argument_list|,
operator|&
name|cwdbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stat
argument_list|)
argument_list|)
operator|==
literal|0
expr_stmt|;
block|}
comment|/* Read the input file in the current directory, *if* it isn't 	   the same file (it should exist, also).  */
if|if
condition|(
operator|!
name|samedir
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
literal|".gdbinit"
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|to_top_level
argument_list|)
condition|)
name|source_command
argument_list|(
literal|".gdbinit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
literal|".xgdbinit"
argument_list|,
name|R_OK
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|to_top_level
argument_list|)
condition|)
name|source_command
argument_list|(
literal|".xgdbinit"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|envp
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
name|int
name|inhibit_gdbinit
init|=
literal|0
decl_stmt|;
name|int
name|quiet
init|=
literal|1
decl_stmt|;
name|int
name|batch
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* XXX Windows only for xgdb. */
name|char
modifier|*
name|strrchr
parameter_list|()
function_decl|;
if|if
condition|(
name|cp
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
condition|)
operator|++
name|cp
expr_stmt|;
else|else
name|cp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'x'
condition|)
name|inhibit_windows
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ALIGN_STACK_ON_STARTUP
argument_list|)
name|i
operator|=
operator|(
name|int
operator|)
operator|&
name|count
operator|&
literal|0x3
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|alloca
argument_list|(
literal|4
operator|-
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|quit_flag
operator|=
literal|0
expr_stmt|;
name|linesize
operator|=
literal|100
expr_stmt|;
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|linesize
argument_list|)
expr_stmt|;
operator|*
name|line
operator|=
literal|0
expr_stmt|;
name|instream
operator|=
name|stdin
expr_stmt|;
name|getwd
argument_list|(
name|dirbuf
argument_list|)
expr_stmt|;
name|current_directory
operator|=
name|dirbuf
expr_stmt|;
ifdef|#
directive|ifdef
name|SET_STACK_LIMIT_HUGE
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
comment|/* Set the stack limit huge so that alloca (particularly stringtab      * in dbxread.c) does not fail. */
name|getrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
name|original_stack_limit
operator|=
name|rlim
operator|.
name|rlim_cur
expr_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
name|rlim
operator|.
name|rlim_max
expr_stmt|;
name|setrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SET_STACK_LIMIT_HUGE */
comment|/* Look for flag arguments.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-q"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-quiet"
argument_list|)
condition|)
name|quiet
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-nx"
argument_list|)
condition|)
name|inhibit_gdbinit
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-nw"
argument_list|)
condition|)
name|inhibit_windows
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-batch"
argument_list|)
condition|)
name|batch
operator|=
literal|1
operator|,
name|quiet
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-fullname"
argument_list|)
condition|)
name|frame_file_full_name
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-xgdb_verbose"
argument_list|)
condition|)
name|xgdb_verbose
operator|=
literal|1
expr_stmt|;
comment|/* -help: print a summary of command line switches.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-help"
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
literal|"\ This is GDB, the GNU debugger.  Use the command\n\     gdb [options] [executable [core-file]]\n\ to enter the debugger.\n\ \n\ Options available are:\n\   -help             Print this message.\n\   -quiet            Do not print version number on startup.\n\   -fullname         Output information used by emacs-GDB interface.\n\   -batch            Exit after processing options.\n\   -nx               Do not read .gdbinit file.\n\   -tty TTY          Use TTY for input/output by the program being debugged.\n\   -cd DIR           Change current directory to DIR.\n\   -directory DIR    Search for source files in DIR.\n\   -command FILE     Execute GDB commands from FILE.\n\   -symbols SYMFILE  Read symbols from SYMFILE.\n\   -exec EXECFILE    Use EXECFILE as the executable.\n\   -se FILE          Use FILE as symbol file and executable file.\n\   -core COREFILE    Analyze the core dump COREFILE.\n\   -k                Kernel debugging.\n\   -w                Writeable text.\n\   -v                Print GNU message and version number on startup.\n\   -nc               Don't confirm quit or run commands.\n\ \n\ For more information, type \"help\" from within GDB, or consult the\n\ GDB manual (available as on-line info or a printed manual).\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
comment|/* Exiting after printing this message seems like 	     the most useful thing to do.  */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KERNELDEBUG
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-k"
argument_list|)
condition|)
name|kernel_debugging
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-w"
argument_list|)
condition|)
name|writeable_text
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-v"
argument_list|)
condition|)
name|quiet
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-nc"
argument_list|)
condition|)
name|inhibit_confirm
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
comment|/* Other options take arguments, so don't confuse an 	   argument with an option.  */
name|i
operator|++
expr_stmt|;
block|}
comment|/* Run the init function of each source file */
name|initialize_cmd_lists
argument_list|()
expr_stmt|;
comment|/* This needs to be done first */
name|initialize_all_files
argument_list|()
expr_stmt|;
name|initialize_main
argument_list|()
expr_stmt|;
comment|/* But that omits this file!  Do it now */
name|initialize_signals
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|print_gdb_version
argument_list|()
expr_stmt|;
comment|/* Process the command line arguments.  */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
specifier|extern
name|void
name|exec_file_command
argument_list|()
decl_stmt|,
name|symbol_file_command
argument_list|()
decl_stmt|;
specifier|extern
name|void
name|core_file_command
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|arg
init|=
name|argv
index|[
name|i
index|]
decl_stmt|;
comment|/* Args starting with - say what to do with the following arg 	 as a filename.  */
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
specifier|extern
name|void
name|tty_command
argument_list|()
decl_stmt|,
name|directory_command
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-q"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-nx"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-quiet"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-batch"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-fullname"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-nw"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-xgdb_verbose"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-help"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-k"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-w"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-v"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-nc"
argument_list|)
condition|)
comment|/* Already processed above */
continue|continue;
if|if
condition|(
operator|++
name|i
operator|==
name|argc
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No argument follows \"%s\".\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|to_top_level
argument_list|)
condition|)
block|{
comment|/* -s foo: get syms from foo.  -e foo: execute foo. 		 -se foo: do both with foo.  -c foo: use foo as core dump.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-se"
argument_list|)
condition|)
block|{
name|exec_file_command
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
name|symbol_file_command
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-s"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-symbols"
argument_list|)
condition|)
name|symbol_file_command
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-e"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-exec"
argument_list|)
condition|)
name|exec_file_command
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-c"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-core"
argument_list|)
condition|)
name|core_file_command
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
comment|/* -x foo: execute commands from foo.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-x"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-command"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-commands"
argument_list|)
condition|)
name|source_command
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* -d foo: add directory `foo' to source-file directory 		         search-list */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-d"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-dir"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-directory"
argument_list|)
condition|)
name|directory_command
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* -cd FOO: specify current directory as FOO. 		 GDB remembers the precise string FOO as the dirname.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-cd"
argument_list|)
condition|)
block|{
name|cd_command
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_source_path
argument_list|()
expr_stmt|;
block|}
comment|/* -t /def/ttyp1: use /dev/ttyp1 for inferior I/O.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-t"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"-tty"
argument_list|)
condition|)
name|tty_command
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Unknown command-line switch: \"%s\"\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Args not thus accounted for 	     are treated as, first, the symbol/executable file 	     and, second, the core dump file.  */
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|to_top_level
argument_list|)
condition|)
switch|switch
condition|(
name|count
condition|)
block|{
case|case
literal|1
case|:
name|exec_file_command
argument_list|(
name|arg
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
name|symbol_file_command
argument_list|(
name|arg
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|core_file_command
argument_list|(
name|arg
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Excess command line args ignored. (%s%s)\n"
argument_list|,
name|arg
argument_list|,
operator|(
name|i
operator|==
name|argc
operator|-
literal|1
operator|)
condition|?
literal|""
else|:
literal|" ..."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|inhibit_gdbinit
condition|)
name|source_init_files
argument_list|()
expr_stmt|;
if|if
condition|(
name|batch
condition|)
block|{
if|#
directive|if
literal|0
block|fatal ("Attempt to read commands from stdin in batch mode.");
endif|#
directive|endif
comment|/* We have hit the end of the batch file.  */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Type \"help\" for a list of commands.\n"
argument_list|)
expr_stmt|;
comment|/* The command loop.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|to_top_level
argument_list|)
condition|)
name|command_loop
argument_list|()
expr_stmt|;
if|if
condition|(
name|ISATTY
argument_list|(
name|stdin
argument_list|)
condition|)
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
comment|/* Don't get hung if C-d is typed.  */
elseif|else
if|if
condition|(
name|feof
argument_list|(
name|instream
argument_list|)
condition|)
comment|/* Avoid endless loops for redirected stdin */
break|break;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_nothing
parameter_list|()
block|{ }
end_function

begin_comment
comment|/* Read commands from `instream' and execute them    until end of file.  */
end_comment

begin_function
name|void
name|command_loop
parameter_list|()
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
specifier|register
name|int
name|toplevel
init|=
operator|(
name|instream
operator|==
name|stdin
operator|)
decl_stmt|;
specifier|register
name|int
name|interactive
init|=
operator|(
name|toplevel
operator|&&
name|ISATTY
argument_list|(
name|stdin
argument_list|)
operator|)
decl_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|instream
argument_list|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|cmd_line
decl_stmt|;
name|quit_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|interactive
condition|)
name|reinitialize_more_filter
argument_list|()
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|do_nothing
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cmd_line
operator|=
name|command_line_input
argument_list|(
name|prompt
argument_list|,
name|toplevel
argument_list|)
expr_stmt|;
name|execute_command
argument_list|(
name|cmd_line
argument_list|,
name|toplevel
argument_list|)
expr_stmt|;
comment|/* Do any commands attached to breakpoint we stopped at.  */
name|do_breakpoint_commands
argument_list|()
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Commands call this if they do not want to be repeated by null lines.  */
end_comment

begin_function
name|void
name|dont_repeat
parameter_list|()
block|{
comment|/* If we aren't reading from standard input, we are saving the last      thing read from stdin in line and don't want to delete it.  Null lines      won't repeat here in any case.  */
if|if
condition|(
name|instream
operator|==
name|stdin
condition|)
operator|*
name|line
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read a line from the stream "instream" without command line editing.     It prints PROMPT once at the start.    Action is compatible with "readline" (i.e., space for typing is    malloced& should be freed by caller). */
end_comment

begin_function
name|char
modifier|*
name|gdb_readline
parameter_list|(
name|prompt
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|input_index
init|=
literal|0
decl_stmt|;
name|int
name|result_size
init|=
literal|80
decl_stmt|;
if|if
condition|(
name|prompt
condition|)
block|{
name|printf
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|result_size
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|fgetc
argument_list|(
name|instream
condition|?
name|instream
else|:
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
name|result
index|[
name|input_index
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|input_index
operator|>=
name|result_size
condition|)
block|{
name|result_size
operator|<=
literal|1
expr_stmt|;
name|result
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|result
argument_list|,
name|result_size
argument_list|)
expr_stmt|;
block|}
block|}
name|result
index|[
name|input_index
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Declaration for fancy readline with command line editing.  */
end_comment

begin_function_decl
name|char
modifier|*
name|readline
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Variables which control command line editing and history    substitution.  These variables are given default values at the end    of this file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|command_editing_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|history_expansion_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|write_history_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|history_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|history_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables which are necessary for fancy command line editing.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|gdb_completer_word_break_characters
init|=
literal|" \t\n!@#$%^&*()-+=|~`}{[]\"';:?/>.<,"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Functions that are used as part of the fancy command line editing.  */
end_comment

begin_comment
comment|/* Generate symbol names one by one for the completer.  If STATE is    zero, then we need to initialize, otherwise the initialization has    already taken place.  TEXT is what we expect the symbol to start    with.  RL_LINE_BUFFER is available to be looked at; it contains the    entire text of the line.  RL_POINT is the offset in that line of    the cursor.  You should pretend that the line ends at RL_POINT.  */
end_comment

begin_function
name|char
modifier|*
name|symbol_completion_function
parameter_list|(
name|text
parameter_list|,
name|state
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
name|int
name|state
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|make_symbol_completion_list
parameter_list|()
function_decl|;
specifier|static
name|char
modifier|*
modifier|*
name|list
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|static
name|int
name|index
decl_stmt|;
name|char
modifier|*
name|output
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rl_line_buffer
decl_stmt|;
specifier|extern
name|int
name|rl_point
decl_stmt|;
name|char
modifier|*
name|tmp_command
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|,
modifier|*
name|result_list
decl_stmt|;
if|if
condition|(
operator|!
name|state
condition|)
block|{
comment|/* Free the storage used by LIST, but not by the strings inside.  This is 	 because rl_complete_internal () frees the strings. */
if|if
condition|(
name|list
condition|)
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
literal|0
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
comment|/* Decide whether to complete on a list of gdb commands or on 	 symbols.  */
name|tmp_command
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|rl_point
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|tmp_command
expr_stmt|;
name|strncpy
argument_list|(
name|tmp_command
argument_list|,
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|)
expr_stmt|;
name|tmp_command
index|[
name|rl_point
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rl_point
operator|==
literal|0
condition|)
block|{
comment|/* An empty line we want to consider ambiguous; that is, 	     it could be any command.  */
name|c
operator|=
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
name|result_list
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|c
operator|=
name|lookup_cmd_1
argument_list|(
operator|&
name|p
argument_list|,
name|cmdlist
argument_list|,
operator|&
name|result_list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Move p up to the next interesting thing.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
comment|/* He's typed something unrecognizable.  Sigh.  */
name|list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|p
operator|+
name|strlen
argument_list|(
name|text
argument_list|)
operator|!=
name|tmp_command
operator|+
name|rl_point
condition|)
name|error
argument_list|(
literal|"Unrecognized command."
argument_list|)
expr_stmt|;
comment|/* He's typed something ambiguous.  This is easier.  */
if|if
condition|(
name|result_list
condition|)
name|list
operator|=
name|complete_on_cmdlist
argument_list|(
operator|*
name|result_list
operator|->
name|prefixlist
argument_list|,
name|text
argument_list|)
expr_stmt|;
else|else
name|list
operator|=
name|complete_on_cmdlist
argument_list|(
name|cmdlist
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If we've gotten this far, gdb has recognized a full 	     command.  There are several possibilities:  	     1) We need to complete on the command. 	     2) We need to complete on the possibilities coming after 	     the command. 	     2) We need to complete the text of what comes after the 	     command.   */
if|if
condition|(
operator|!
operator|*
name|p
operator|&&
operator|*
name|text
condition|)
comment|/* Always (might be longer versions of thie command).  */
name|list
operator|=
name|complete_on_cmdlist
argument_list|(
name|result_list
argument_list|,
name|text
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|*
name|p
operator|&&
operator|!
operator|*
name|text
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|prefixlist
condition|)
name|list
operator|=
name|complete_on_cmdlist
argument_list|(
operator|*
name|c
operator|->
name|prefixlist
argument_list|,
literal|""
argument_list|)
expr_stmt|;
else|else
name|list
operator|=
name|make_symbol_completion_list
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|->
name|prefixlist
operator|&&
operator|!
name|c
operator|->
name|allow_unknown
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\" command requires a subcommand."
argument_list|,
name|tmp_command
argument_list|)
expr_stmt|;
block|}
else|else
name|list
operator|=
name|make_symbol_completion_list
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If the debugged program wasn't compiled with symbols, or if we're      clearly completing on a command and no command matches, return      NULL.  */
if|if
condition|(
operator|!
name|list
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
name|output
operator|=
name|list
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|output
condition|)
name|index
operator|++
expr_stmt|;
return|return
operator|(
name|output
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|print_prompt
parameter_list|()
block|{
if|if
condition|(
name|prompt
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TERMIO
end_ifdef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|termio
name|norm_tty
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|suspend_sig
parameter_list|()
block|{
name|int
name|tty
init|=
name|fileno
argument_list|(
name|stdin
argument_list|)
decl_stmt|;
name|struct
name|termio
name|cur_tty
decl_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|cur_tty
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|norm_tty
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
comment|/* 	 * we've just been resumed -- current tty params become new 	 * 'normal' params (in case tset/stty was done while we were 	 * suspended).  Merge values that readline might have changed 	 * into new params, then restore term mode. 	 */
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|norm_tty
argument_list|)
expr_stmt|;
name|cur_tty
operator|.
name|c_lflag
operator|=
operator|(
name|cur_tty
operator|.
name|c_lflag
operator|&
operator|(
name|ICANON
operator||
name|ECHO
operator||
name|ISIG
operator|)
operator|)
operator||
operator|(
name|norm_tty
operator|.
name|c_lflag
operator|&
operator|~
operator|(
name|ICANON
operator||
name|ECHO
operator||
name|ISIG
operator|)
operator|)
expr_stmt|;
name|cur_tty
operator|.
name|c_iflag
operator|=
operator|(
name|cur_tty
operator|.
name|c_iflag
operator|&
operator|(
name|IXON
operator||
name|ISTRIP
operator||
name|INPCK
operator|)
operator|)
operator||
operator|(
name|norm_tty
operator|.
name|c_iflag
operator|&
operator|~
operator|(
name|IXON
operator||
name|ISTRIP
operator||
name|INPCK
operator|)
operator|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|cur_tty
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|suspend_sig
argument_list|)
expr_stmt|;
name|print_prompt
argument_list|()
expr_stmt|;
comment|/* 	 * Forget about any previous command -- null line now will do 	 * nothing. 	 */
name|dont_repeat
argument_list|()
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|sgttyb
name|norm_tty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tchars
name|norm_tchars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ltchars
name|norm_ltchars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|norm_lflags
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PASS8
end_ifdef

begin_define
define|#
directive|define
name|RL_TFLAGS
value|(RAW|CRMOD|ECHO|CBREAK|PASS8)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RL_TFLAGS
value|(RAW|CRMOD|ECHO|CBREAK)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|suspend_sig
parameter_list|()
block|{
name|int
name|tty
init|=
name|fileno
argument_list|(
name|stdin
argument_list|)
decl_stmt|;
name|struct
name|sgttyb
name|cur_tty
decl_stmt|;
name|struct
name|tchars
name|cur_tchars
decl_stmt|;
name|struct
name|ltchars
name|cur_ltchars
decl_stmt|;
name|int
name|cur_lflags
decl_stmt|;
name|int
name|cur_flags
decl_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|cur_tty
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|cur_tchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCLGET
argument_list|,
operator|&
name|cur_lflags
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|cur_ltchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|norm_tty
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|norm_tchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|norm_lflags
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|norm_ltchars
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
comment|/* 	 * we've just been resumed -- current tty params become new 	 * 'normal' params (in case tset/stty was done while we were 	 * suspended).  Merge values that readline might have changed 	 * into new params, then restore term mode. 	 */
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|norm_tty
argument_list|)
expr_stmt|;
name|cur_flags
operator|=
name|cur_tty
operator|.
name|sg_flags
expr_stmt|;
name|cur_tty
operator|=
name|norm_tty
expr_stmt|;
name|cur_tty
operator|.
name|sg_flags
operator|=
operator|(
name|cur_tty
operator|.
name|sg_flags
operator|&
operator|~
name|RL_TFLAGS
operator|)
operator||
operator|(
name|cur_flags
operator|&
name|RL_TFLAGS
operator|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCLGET
argument_list|,
operator|&
name|norm_lflags
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LPASS8
name|cur_lflags
operator|=
operator|(
name|cur_lflags
operator|&
operator|~
name|LPASS8
operator|)
operator||
operator|(
name|cur_flags
operator|&
name|LPASS8
operator|)
expr_stmt|;
endif|#
directive|endif
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|norm_tchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|norm_ltchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|cur_tty
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSETC
argument_list|,
operator|&
name|cur_tchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCLSET
argument_list|,
operator|&
name|cur_lflags
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|cur_ltchars
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|suspend_sig
argument_list|)
expr_stmt|;
name|print_prompt
argument_list|()
expr_stmt|;
comment|/* 	 * Forget about any previous command -- null line now will do 	 * nothing. 	 */
name|dont_repeat
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_TERMIO */
end_comment

begin_comment
comment|/* Initialize signal handlers. */
end_comment

begin_macro
name|initialize_signals
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|void
name|request_quit
parameter_list|()
function_decl|;
name|int
name|tty
init|=
name|fileno
argument_list|(
name|stdin
argument_list|)
decl_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|request_quit
argument_list|)
expr_stmt|;
comment|/* If we initialize SIGQUIT to SIG_IGN, then the SIG_IGN will get      passed to the inferior, which we don't want.  It would be      possible to do a "signal (SIGQUIT, SIG_DFL)" after we fork, but      on BSD4.3 systems using vfork, that will (apparently) affect the      GDB process as well as the inferior (the signal handling tables      being shared between the two, apparently).  Since we establish      a handler for SIGQUIT, when we call exec it will set the signal      to SIG_DFL for us.  */
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|do_nothing
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|do_nothing
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|disconnect
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|float_handler
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|norm_tty
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCLGET
argument_list|,
operator|&
name|norm_lflags
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGETC
argument_list|,
operator|&
name|norm_tchars
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|tty
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|norm_ltchars
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|suspend_sig
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|finish_command_input
parameter_list|(
name|inputline
parameter_list|,
name|repeat
parameter_list|,
name|interactive
parameter_list|)
specifier|register
name|char
modifier|*
name|inputline
decl_stmt|;
name|int
name|repeat
decl_stmt|;
name|int
name|interactive
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|do_free
decl_stmt|;
if|if
condition|(
name|do_free
condition|)
block|{
name|free
argument_list|(
name|do_free
argument_list|)
expr_stmt|;
name|do_free
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Do history expansion if that is wished.  */
if|if
condition|(
name|interactive
operator|&&
name|history_expansion_p
condition|)
block|{
name|int
name|expanded
decl_stmt|;
name|expanded
operator|=
name|history_expand
argument_list|(
name|inputline
argument_list|,
operator|&
name|do_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|expanded
condition|)
block|{
comment|/* Print the changes.  */
name|puts
argument_list|(
name|do_free
argument_list|)
expr_stmt|;
comment|/* An error acts like no input. */
if|if
condition|(
name|expanded
operator|<
literal|0
condition|)
block|{
operator|*
name|do_free
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|do_free
operator|)
return|;
block|}
block|}
name|inputline
operator|=
name|do_free
expr_stmt|;
block|}
comment|/* get rid of any leading whitespace */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|inputline
argument_list|)
condition|)
operator|++
name|inputline
expr_stmt|;
comment|/* 	 * If we just got an empty line, and that is supposed to repeat the 	 * previous command, return the value in the global buffer. 	 */
if|if
condition|(
operator|*
name|inputline
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|repeat
condition|)
return|return
operator|(
name|line
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|interactive
condition|)
name|add_history
argument_list|(
name|inputline
argument_list|)
expr_stmt|;
comment|/* 	 * If line is a comment, clear it out. 	 * Note:  comments are added to the command history. This is useful 	 * when you type a command, and then realize you don't want to 	 * execute it quite yet.  You can comment out the command and then 	 * later fetch it from the value history and remove the '#'. 	 */
if|if
condition|(
operator|*
name|inputline
operator|==
literal|'#'
condition|)
operator|*
name|inputline
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|repeat
condition|)
block|{
comment|/* Save into global buffer. */
specifier|register
name|int
name|i
init|=
name|strlen
argument_list|(
name|inputline
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|i
operator|>
name|linesize
condition|)
block|{
name|line
operator|=
name|xrealloc
argument_list|(
name|line
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|linesize
operator|=
name|i
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|line
argument_list|,
name|inputline
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|inputline
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_a_cmd_line
parameter_list|(
name|prompt
parameter_list|,
name|interactive
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
name|int
name|interactive
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Control-C quits instantly if typed while reading input. */
name|immediate_quit
operator|++
expr_stmt|;
if|if
condition|(
name|interactive
operator|&&
name|command_editing_p
condition|)
block|{
specifier|extern
name|void
function_decl|(
modifier|*
name|rl_event_hook
function_decl|)
parameter_list|()
function_decl|;
name|rl_event_hook
operator|=
name|window_hook
expr_stmt|;
name|cp
operator|=
name|readline
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|interactive
condition|)
block|{
if|if
condition|(
name|window_hook
condition|)
block|{
name|print_prompt
argument_list|()
expr_stmt|;
call|(
modifier|*
name|window_hook
call|)
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|prompt
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|gdb_readline
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
block|}
operator|--
name|immediate_quit
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read one line from the command input stream `instream'    Returns the address of the start of the line.     *If* the instream == stdin& stdin is a terminal, the line read    is copied into the file line saver (global var char *line,    length linesize) so that it can be duplicated.     This routine either uses fancy command line editing or    simple input as the user has requested.  */
end_comment

begin_function
name|char
modifier|*
name|command_line_input
parameter_list|(
name|prompt
parameter_list|,
name|repeat
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
name|int
name|repeat
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|do_free
decl_stmt|;
specifier|register
name|int
name|interactive
init|=
operator|(
name|instream
operator|==
name|stdin
operator|&&
name|ISATTY
argument_list|(
name|instream
argument_list|)
operator|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|do_free
condition|)
block|{
name|free
argument_list|(
name|do_free
argument_list|)
expr_stmt|;
name|do_free
operator|=
name|NULL
expr_stmt|;
block|}
name|cp
operator|=
name|get_a_cmd_line
argument_list|(
name|prompt
argument_list|,
name|interactive
argument_list|)
expr_stmt|;
comment|/* 	 * handle continued lines (this loop is not particularly 	 * efficient because it's rare). 	 */
while|while
condition|(
name|cp
operator|&&
name|cp
index|[
name|i
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
block|{
specifier|register
name|char
modifier|*
name|np
init|=
name|get_a_cmd_line
argument_list|(
name|prompt
argument_list|,
name|interactive
argument_list|)
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
name|cp
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|j
operator|=
name|strlen
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|cp
operator|=
name|xrealloc
argument_list|(
name|cp
argument_list|,
name|i
operator|+
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cp
operator|+
name|i
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|""
operator|)
return|;
name|do_free
operator|=
name|cp
expr_stmt|;
return|return
operator|(
name|finish_command_input
argument_list|(
name|cp
argument_list|,
name|repeat
argument_list|,
name|interactive
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|MAX_USER_ARGS
value|32
end_define

begin_struct
specifier|static
struct|struct
name|user_args
block|{
struct|struct
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|len
decl_stmt|;
block|}
name|a
index|[
literal|10
index|]
struct|;
block|}
name|uargs
index|[
name|MAX_USER_ARGS
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|user_args
modifier|*
name|user_arg
init|=
name|uargs
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|arg_cleanup
parameter_list|(
name|ap
parameter_list|)
name|struct
name|user_args
modifier|*
name|ap
decl_stmt|;
block|{
name|user_arg
operator|=
name|ap
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Bind arguments $arg0, $arg1, ..., for a user defined command. */
end_comment

begin_function
name|struct
name|cleanup
modifier|*
name|setup_user_args
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
name|arg_cleanup
argument_list|,
name|user_arg
argument_list|)
decl_stmt|;
if|if
condition|(
operator|++
name|user_arg
operator|>=
operator|&
name|uargs
index|[
name|MAX_USER_ARGS
index|]
condition|)
name|error
argument_list|(
literal|"user defined functions nested too deeply\n"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|user_arg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|user_arg
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|++
name|p
expr_stmt|;
name|user_arg
operator|->
name|a
index|[
name|i
index|]
operator|.
name|arg
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|++
name|p
expr_stmt|;
name|user_arg
operator|->
name|a
index|[
name|i
index|]
operator|.
name|len
operator|=
name|p
operator|-
name|user_arg
operator|->
name|a
index|[
name|i
index|]
operator|.
name|arg
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
return|return
operator|(
name|old_chain
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|findarg
parameter_list|(
name|str
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|str
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
while|while
condition|(
name|cp
operator|=
name|index
argument_list|(
name|cp
argument_list|,
literal|'$'
argument_list|)
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"$arg"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|&&
name|isdigit
argument_list|(
name|cp
index|[
literal|4
index|]
argument_list|)
condition|)
return|return
operator|(
name|cp
operator|)
return|;
operator|++
name|cp
expr_stmt|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/* expand arguments from "line" into "new" */
end_comment

begin_function
specifier|static
name|void
name|expand_args
parameter_list|(
name|line
parameter_list|,
name|new
parameter_list|)
specifier|register
name|char
modifier|*
name|line
decl_stmt|,
decl|*
name|new
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|findarg
argument_list|(
name|line
argument_list|)
decl_stmt|;
while|while
condition|(
name|cp
operator|=
name|findarg
argument_list|(
name|line
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|bcopy
argument_list|(
name|line
argument_list|,
name|new
argument_list|,
name|cp
operator|-
name|line
argument_list|)
expr_stmt|;
name|new
operator|+=
name|cp
operator|-
name|line
expr_stmt|;
name|i
operator|=
name|cp
index|[
literal|4
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|len
operator|=
name|user_arg
operator|->
name|a
index|[
name|i
index|]
operator|.
name|len
condition|)
block|{
name|bcopy
argument_list|(
name|user_arg
operator|->
name|a
index|[
name|i
index|]
operator|.
name|arg
argument_list|,
name|new
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|new
operator|+=
name|len
expr_stmt|;
block|}
name|line
operator|=
name|cp
operator|+
literal|5
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|new
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* expand any arguments in "line" then execute the result */
end_comment

begin_function
specifier|static
name|void
name|expand_and_execute
parameter_list|(
name|line
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|void
name|execute_command
parameter_list|()
function_decl|;
name|char
name|new
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|findarg
argument_list|(
name|line
argument_list|)
condition|)
block|{
name|execute_command
argument_list|(
name|line
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
return|return;
block|}
name|expand_args
argument_list|(
name|line
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|execute_command
argument_list|(
name|new
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|read_one_command_line
parameter_list|(
name|prompt
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|prompt
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
name|p
operator|=
name|command_line_input
argument_list|(
name|prompt
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
comment|/* Remove trailing blanks.  */
name|p1
operator|=
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|p1
operator|>
name|p
operator|&&
operator|(
operator|*
name|p1
operator|==
literal|' '
operator|||
operator|*
name|p1
operator|==
literal|'\t'
operator|)
condition|)
empty_stmt|;
operator|*
operator|++
name|p1
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|cmd_prompt
index|[]
init|=
literal|"> "
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|parse_control_structure
parameter_list|(
name|rootcmd
parameter_list|,
name|from_tty
parameter_list|,
name|level
parameter_list|)
name|struct
name|command_line
modifier|*
name|rootcmd
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|command_line
modifier|*
name|cmd
init|=
operator|(
expr|struct
name|command_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|prompt
decl_stmt|;
operator|++
name|level
expr_stmt|;
name|prompt
operator|=
name|from_tty
condition|?
operator|&
name|cmd_prompt
index|[
sizeof|sizeof
argument_list|(
name|cmd_prompt
argument_list|)
operator|-
literal|1
operator|-
literal|2
operator|*
name|level
index|]
else|:
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|rootcmd
operator|->
name|body
operator|=
name|cmd
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|read_one_command_line
argument_list|(
name|prompt
argument_list|,
name|from_tty
argument_list|)
decl_stmt|;
name|p
operator|=
name|savestring
argument_list|(
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|line
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"while "
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|cmd
operator|->
name|type
operator|=
name|CL_WHILE
expr_stmt|;
if|if
condition|(
name|parse_control_structure
argument_list|(
name|cmd
argument_list|,
name|from_tty
argument_list|,
name|level
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"if "
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|cmd
operator|->
name|type
operator|=
name|CL_IF
expr_stmt|;
if|if
condition|(
name|parse_control_structure
argument_list|(
name|cmd
argument_list|,
name|from_tty
argument_list|,
name|level
argument_list|)
condition|)
block|{
name|struct
name|command_line
modifier|*
name|tmp
decl_stmt|;
name|int
name|stat
decl_stmt|;
name|cmd
operator|->
name|elsebody
operator|=
name|cmd
operator|->
name|body
expr_stmt|;
name|stat
operator|=
name|parse_control_structure
argument_list|(
name|cmd
argument_list|,
name|from_tty
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|cmd
operator|->
name|elsebody
expr_stmt|;
name|cmd
operator|->
name|elsebody
operator|=
name|cmd
operator|->
name|body
expr_stmt|;
name|cmd
operator|->
name|body
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|stat
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"else"
argument_list|)
condition|)
block|{
name|cmd
operator|->
name|type
operator|=
name|CL_END
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"end"
argument_list|)
condition|)
block|{
name|cmd
operator|->
name|type
operator|=
name|CL_END
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"exitloop"
argument_list|)
condition|)
block|{
name|cmd
operator|->
name|type
operator|=
name|CL_EXITLOOP
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|->
name|type
operator|=
name|CL_NORMAL
expr_stmt|;
block|}
name|cmd
operator|->
name|next
operator|=
operator|(
expr|struct
name|command_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|cmd
operator|->
name|next
expr_stmt|;
name|bzero
argument_list|(
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|int
name|execute_control_structure
parameter_list|(
name|cmd
parameter_list|)
specifier|register
name|struct
name|command_line
modifier|*
name|cmd
decl_stmt|;
block|{
name|char
name|expn
index|[
literal|1024
index|]
decl_stmt|;
name|struct
name|expression
modifier|*
name|cond
decl_stmt|;
name|int
name|stat
decl_stmt|;
while|while
condition|(
name|cmd
condition|)
block|{
name|QUIT
expr_stmt|;
switch|switch
condition|(
name|cmd
operator|->
name|type
condition|)
block|{
case|case
name|CL_END
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CL_NORMAL
case|:
name|expand_and_execute
argument_list|(
name|cmd
operator|->
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CL_WHILE
case|:
name|expand_args
argument_list|(
name|cmd
operator|->
name|line
operator|+
literal|6
argument_list|,
name|expn
argument_list|)
expr_stmt|;
name|cond
operator|=
name|parse_c_expression
argument_list|(
name|expn
argument_list|)
expr_stmt|;
while|while
condition|(
name|breakpoint_cond_eval
argument_list|(
name|cond
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|execute_control_structure
argument_list|(
name|cmd
operator|->
name|body
argument_list|)
condition|)
break|break;
name|free
argument_list|(
name|cond
argument_list|)
expr_stmt|;
break|break;
case|case
name|CL_IF
case|:
name|expand_args
argument_list|(
name|cmd
operator|->
name|line
operator|+
literal|3
argument_list|,
name|expn
argument_list|)
expr_stmt|;
name|cond
operator|=
name|parse_c_expression
argument_list|(
name|expn
argument_list|)
expr_stmt|;
name|stat
operator|=
name|breakpoint_cond_eval
argument_list|(
name|cond
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cond
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|execute_control_structure
argument_list|(
name|cmd
operator|->
name|body
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|->
name|elsebody
condition|)
block|{
if|if
condition|(
name|execute_control_structure
argument_list|(
name|cmd
operator|->
name|elsebody
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|CL_EXITLOOP
case|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|cmd
operator|=
name|cmd
operator|->
name|next
expr_stmt|;
block|}
name|free_all_values
argument_list|()
expr_stmt|;
block|}
end_function

begin_macro
name|execute_command_lines
argument_list|(
argument|cmd
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|command_line
modifier|*
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
name|source_cleanup
argument_list|,
name|instream
argument_list|)
decl_stmt|;
comment|/* 	 * Set the instream to 0, indicating execution of a user-defined 	 * function.   	 */
operator|++
name|immediate_quit
expr_stmt|;
name|instream
operator|=
operator|(
name|FILE
operator|*
operator|)
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|execute_control_structure
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
operator|--
name|immediate_quit
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* do following command lines if expression true */
end_comment

begin_macro
name|if_command
argument_list|(
argument|p
argument_list|,
argument|from_tty
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|from_tty
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|command_line
modifier|*
name|cmd
init|=
operator|(
expr|struct
name|command_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"if %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_command_lines
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|type
operator|=
name|CL_IF
expr_stmt|;
name|cmd
operator|->
name|line
operator|=
name|savestring
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX cmd->line? */
if|if
condition|(
name|parse_control_structure
argument_list|(
name|cmd
argument_list|,
name|from_tty
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|struct
name|command_line
modifier|*
name|tmp
decl_stmt|;
name|cmd
operator|->
name|elsebody
operator|=
name|cmd
operator|->
name|body
expr_stmt|;
operator|(
name|void
operator|)
name|parse_control_structure
argument_list|(
name|cmd
argument_list|,
name|from_tty
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|cmd
operator|->
name|elsebody
expr_stmt|;
name|cmd
operator|->
name|elsebody
operator|=
name|cmd
operator|->
name|body
expr_stmt|;
name|cmd
operator|->
name|body
operator|=
name|tmp
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|execute_command_lines
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* do following command lines while expression true */
end_comment

begin_macro
name|while_command
argument_list|(
argument|p
argument_list|,
argument|from_tty
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|from_tty
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|command_line
modifier|*
name|cmd
init|=
operator|(
expr|struct
name|command_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"while %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_command_lines
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|type
operator|=
name|CL_WHILE
expr_stmt|;
name|cmd
operator|->
name|line
operator|=
name|savestring
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|parse_control_structure
argument_list|(
name|cmd
argument_list|,
name|from_tty
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|execute_command_lines
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Execute the line P as a command.  * Pass FROM_TTY as second argument to the defining function.  */
end_comment

begin_function
name|void
name|execute_command
parameter_list|(
name|p
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
specifier|register
name|struct
name|command_line
modifier|*
name|cmdlines
decl_stmt|;
name|free_all_values
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|c
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|p
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|function
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"That is not a command, just a help topic."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|class
operator|==
operator|(
name|int
operator|)
name|class_user
condition|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|setup_user_args
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|cmdlines
operator|=
operator|(
expr|struct
name|command_line
operator|*
operator|)
name|c
operator|->
name|function
expr_stmt|;
if|if
condition|(
name|cmdlines
condition|)
operator|(
name|void
operator|)
name|execute_command_lines
argument_list|(
name|cmdlines
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Pass null arg rather than an empty one.  */
call|(
modifier|*
name|c
operator|->
name|function
call|)
argument_list|(
operator|*
name|p
condition|?
name|p
else|:
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read lines from the input stream and accumulate them in a chain of struct  * command_line's which is then returned.    */
end_comment

begin_function
name|struct
name|command_line
modifier|*
name|read_command_lines
parameter_list|(
name|from_tty
parameter_list|)
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|command_line
modifier|*
name|cmd
init|=
operator|(
expr|struct
name|command_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|command_line
modifier|*
name|next
decl_stmt|;
name|bzero
argument_list|(
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_command_lines
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|type
operator|=
name|CL_NOP
expr_stmt|;
operator|(
name|void
operator|)
name|parse_control_structure
argument_list|(
name|cmd
argument_list|,
name|from_tty
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
name|next
operator|=
name|cmd
operator|->
name|body
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|next
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free a chain of struct command_line's.  */
end_comment

begin_function
name|void
name|free_command_lines
parameter_list|(
name|cmds
parameter_list|)
name|struct
name|command_line
modifier|*
name|cmds
decl_stmt|;
block|{
name|struct
name|command_line
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|cmds
condition|)
block|{
if|if
condition|(
name|cmds
operator|->
name|body
condition|)
name|free
argument_list|(
name|cmds
operator|->
name|body
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmds
operator|->
name|elsebody
condition|)
name|free
argument_list|(
name|cmds
operator|->
name|elsebody
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmds
operator|->
name|line
condition|)
name|free
argument_list|(
name|cmds
operator|->
name|line
argument_list|)
expr_stmt|;
name|next
operator|=
name|cmds
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|cmds
argument_list|)
expr_stmt|;
name|cmds
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add an element to the list of info subcommands.  */
end_comment

begin_decl_stmt
name|void
name|add_info
argument_list|(
name|name
argument_list|,
name|fun
argument_list|,
name|doc
argument_list|)
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|doc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|add_cmd
argument_list|(
name|name
argument_list|,
name|no_class
argument_list|,
name|fun
argument_list|,
name|doc
argument_list|,
operator|&
name|infolist
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Add an alias to the list of info subcommands.  */
end_comment

begin_function
name|void
name|add_info_alias
parameter_list|(
name|name
parameter_list|,
name|oldname
parameter_list|,
name|abbrev_flag
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|oldname
decl_stmt|;
name|int
name|abbrev_flag
decl_stmt|;
block|{
name|add_alias_cmd
argument_list|(
name|name
argument_list|,
name|oldname
argument_list|,
literal|0
argument_list|,
name|abbrev_flag
argument_list|,
operator|&
name|infolist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The "info" command is defined as a prefix, with allow_unknown = 0.    Therefore, its own definition is called only for "info" with no args.  */
end_comment

begin_function
specifier|static
name|void
name|info_command
parameter_list|()
block|{
name|printf
argument_list|(
literal|"\"info\" must be followed by the name of an info command.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|infolist
argument_list|,
literal|"info "
argument_list|,
operator|-
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add an element to the list of commands.  */
end_comment

begin_decl_stmt
name|void
name|add_com
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|fun
argument_list|,
name|doc
argument_list|)
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|class
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|fun
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|doc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|add_cmd
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|fun
argument_list|,
name|doc
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Add an alias or abbreviation command to the list of commands.  */
end_comment

begin_function
name|void
name|add_com_alias
parameter_list|(
name|name
parameter_list|,
name|oldname
parameter_list|,
name|class
parameter_list|,
name|abbrev_flag
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|oldname
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
name|abbrev_flag
decl_stmt|;
block|{
name|add_alias_cmd
argument_list|(
name|name
argument_list|,
name|oldname
argument_list|,
name|class
argument_list|,
name|abbrev_flag
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|error_no_arg
parameter_list|(
name|why
parameter_list|)
name|char
modifier|*
name|why
decl_stmt|;
block|{
name|error
argument_list|(
literal|"Argument required (%s)."
argument_list|,
name|why
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|help_command
parameter_list|(
name|command
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|command
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
comment|/* Ignored */
block|{
name|help_cmd
argument_list|(
name|command
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|validate_comname
parameter_list|(
name|comname
parameter_list|)
name|char
modifier|*
name|comname
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|comname
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"name of command to define"
argument_list|)
expr_stmt|;
name|p
operator|=
name|comname
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|>=
literal|'A'
operator|&&
operator|*
name|p
operator|<=
literal|'Z'
operator|)
operator|&&
operator|!
operator|(
operator|*
name|p
operator|>=
literal|'a'
operator|&&
operator|*
name|p
operator|<=
literal|'z'
operator|)
operator|&&
operator|!
operator|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
operator|)
operator|&&
operator|*
name|p
operator|!=
literal|'-'
condition|)
name|error
argument_list|(
literal|"Junk in argument list: \"%s\""
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|define_command
parameter_list|(
name|comname
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|comname
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|command_line
modifier|*
name|cmds
decl_stmt|;
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|char
modifier|*
name|tem
init|=
name|comname
decl_stmt|;
name|validate_comname
argument_list|(
name|comname
argument_list|)
expr_stmt|;
name|c
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|tem
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|class
operator|==
operator|(
name|int
operator|)
name|class_user
operator|||
name|c
operator|->
name|class
operator|==
operator|(
name|int
operator|)
name|class_alias
condition|)
name|tem
operator|=
literal|"Redefine command \"%s\"? "
expr_stmt|;
else|else
name|tem
operator|=
literal|"Really redefine built-in command \"%s\"? "
expr_stmt|;
if|if
condition|(
operator|!
name|query
argument_list|(
name|tem
argument_list|,
name|comname
argument_list|)
condition|)
name|error
argument_list|(
literal|"Command \"%s\" not redefined."
argument_list|,
name|comname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf
argument_list|(
literal|"Type commands for definition of \"%s\".\n\ End with a line saying just \"end\".\n"
argument_list|,
name|comname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|comname
operator|=
name|savestring
argument_list|(
name|comname
argument_list|,
name|strlen
argument_list|(
name|comname
argument_list|)
argument_list|)
expr_stmt|;
name|cmds
operator|=
name|read_command_lines
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&&
name|c
operator|->
name|class
operator|==
operator|(
name|int
operator|)
name|class_user
condition|)
name|free_command_lines
argument_list|(
name|c
operator|->
name|function
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
name|comname
argument_list|,
name|class_user
argument_list|,
name|cmds
argument_list|,
operator|(
name|c
operator|&&
name|c
operator|->
name|class
operator|==
operator|(
name|int
operator|)
name|class_user
operator|)
condition|?
name|c
operator|->
name|doc
else|:
name|savestring
argument_list|(
literal|"User-defined."
argument_list|,
literal|13
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|document_command
parameter_list|(
name|comname
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|comname
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|doc
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|comname
decl_stmt|;
name|validate_comname
argument_list|(
name|comname
argument_list|)
expr_stmt|;
name|c
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|tmp
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|class
operator|!=
operator|(
name|int
operator|)
name|class_user
condition|)
name|error
argument_list|(
literal|"Command \"%s\" is built-in."
argument_list|,
name|comname
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Type documentation for \"%s\".  \ End with a line saying just \"end\".\n"
argument_list|,
name|comname
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|=
name|read_one_command_line
argument_list|(
name|from_tty
condition|?
literal|"> "
else|:
literal|0
argument_list|,
name|from_tty
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"end"
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|doc
condition|)
block|{
name|doc
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|cp
operator|=
name|doc
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
init|=
name|cp
operator|-
name|doc
decl_stmt|;
name|doc
operator|=
name|xrealloc
argument_list|(
name|doc
argument_list|,
name|i
operator|+
name|len
argument_list|)
expr_stmt|;
name|cp
operator|=
name|doc
operator|+
name|i
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|cp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
expr_stmt|;
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
if|if
condition|(
name|doc
operator|&&
name|cp
operator|>
name|doc
condition|)
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|doc
condition|)
name|free
argument_list|(
name|c
operator|->
name|doc
argument_list|)
expr_stmt|;
name|c
operator|->
name|doc
operator|=
name|doc
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|print_gdb_version
parameter_list|()
block|{
name|printf
argument_list|(
literal|"GDB %s, Copyright (C) 1989 Free Software Foundation, Inc.\n\ There is ABSOLUTELY NO WARRANTY for GDB; type \"info warranty\" for details.\n\ GDB is free software and you are welcome to distribute copies of it\n\  under certain conditions; type \"info copying\" to see the conditions.\n"
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|version_info
parameter_list|()
block|{
name|immediate_quit
operator|++
expr_stmt|;
name|print_gdb_version
argument_list|()
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Command to specify a prompt string instead of "(gdb) ".  */
end_comment

begin_function
name|void
name|set_prompt_command
parameter_list|(
name|text
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|text
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"string to which to set prompt"
argument_list|)
expr_stmt|;
name|new
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|text
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|text
expr_stmt|;
name|q
operator|=
name|new
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
comment|/* \ at end of argument is used after spaces 	     so they won't be lost.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
break|break;
name|c
operator|=
name|parse_escape
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
comment|/* C loses */
elseif|else
if|if
condition|(
name|c
operator|>
literal|0
condition|)
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
block|}
else|else
operator|*
name|q
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|!=
literal|'\\'
condition|)
operator|*
name|q
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|new
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|new
argument_list|,
name|q
operator|-
name|new
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|prompt
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|quit_command
parameter_list|()
block|{
specifier|extern
name|void
name|exec_file_command
parameter_list|()
function_decl|;
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
block|{
if|if
condition|(
name|inhibit_confirm
operator|||
name|query
argument_list|(
literal|"The program is running.  Quit anyway? "
argument_list|)
condition|)
block|{
comment|/* Prevent any warning message from reopen_exec_file, in case 	     we have a core file that's inconsistent with the exec file.  */
name|exec_file_command
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kill_inferior
argument_list|()
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
block|}
comment|/* Save the history information if it is appropriate to do so.  */
if|if
condition|(
name|write_history_p
operator|&&
name|history_filename
condition|)
name|write_history
argument_list|(
name|history_filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|input_from_terminal_p
parameter_list|()
block|{
return|return
name|instream
operator|==
name|stdin
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|pwd_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|arg
condition|)
name|error
argument_list|(
literal|"The \"pwd\" command does not take an argument: %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|getwd
argument_list|(
name|dirbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|dirbuf
argument_list|,
name|current_directory
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Working directory %s\n (canonically %s).\n"
argument_list|,
name|current_directory
argument_list|,
name|dirbuf
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Working directory %s.\n"
argument_list|,
name|current_directory
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cd_command
parameter_list|(
name|dir
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|int
name|change
decl_stmt|;
if|if
condition|(
name|dir
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"new working directory"
argument_list|)
expr_stmt|;
name|dir
operator|=
name|tilde_expand
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|dir
operator|=
name|savestring
argument_list|(
name|dir
argument_list|,
name|len
operator|-
operator|(
name|len
operator|>
literal|1
operator|&&
name|dir
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|current_directory
operator|=
name|dir
expr_stmt|;
else|else
block|{
name|current_directory
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
comment|/* Now simplify any occurrences of `.' and `..' in the pathname.  */
name|change
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|change
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|change
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|current_directory
init|;
operator|*
name|p
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"/./"
argument_list|,
literal|2
argument_list|)
operator|&&
operator|(
name|p
index|[
literal|2
index|]
operator|==
literal|0
operator|||
name|p
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
condition|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"/.."
argument_list|,
literal|3
argument_list|)
operator|&&
operator|(
name|p
index|[
literal|3
index|]
operator|==
literal|0
operator|||
name|p
index|[
literal|3
index|]
operator|==
literal|'/'
operator|)
operator|&&
name|p
operator|!=
name|current_directory
condition|)
block|{
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
while|while
condition|(
name|q
operator|!=
name|current_directory
operator|&&
name|q
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|q
operator|--
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|current_directory
condition|)
block|{
name|strcpy
argument_list|(
name|q
operator|-
literal|1
argument_list|,
name|p
operator|+
literal|3
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
name|p
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|chdir
argument_list|(
name|dir
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|pwd_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|source_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|FILE
modifier|*
name|stream
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|arg
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
if|if
condition|(
name|file
operator|==
literal|0
condition|)
comment|/* Let source without arguments read .gdbinit.  */
name|file
operator|=
literal|".gdbinit"
expr_stmt|;
name|file
operator|=
name|tilde_expand
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|file
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KERNELDEBUG
if|if
condition|(
name|path
operator|=
name|getenv
argument_list|(
name|kernel_debugging
condition|?
literal|"KGDBPATH"
else|:
literal|"GDBPATH"
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|path
operator|=
name|getenv
argument_list|(
literal|"GDBPATH"
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|int
name|fd
init|=
name|openp
argument_list|(
name|path
argument_list|,
literal|1
argument_list|,
name|file
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|stream
operator|=
literal|0
expr_stmt|;
else|else
name|stream
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
else|else
name|stream
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|==
literal|0
condition|)
name|perror_with_name
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|cleanups
operator|=
name|make_cleanup
argument_list|(
name|source_cleanup
argument_list|,
name|instream
argument_list|)
expr_stmt|;
name|instream
operator|=
name|stream
expr_stmt|;
name|command_loop
argument_list|()
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|echo_command
parameter_list|(
name|text
parameter_list|)
name|char
modifier|*
name|text
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|text
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|text
condition|)
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
comment|/* \ at end of argument is used after spaces 	       so they won't be lost.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
return|return;
name|c
operator|=
name|parse_escape
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
name|fputc
argument_list|(
name|c
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|fputc
argument_list|(
name|c
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_me_command
parameter_list|()
block|{
if|if
condition|(
name|query
argument_list|(
literal|"Should GDB dump core? "
argument_list|)
condition|)
block|{
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGQUIT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|parse_binary_operation
parameter_list|(
name|caller
parameter_list|,
name|arg
parameter_list|)
name|char
modifier|*
name|caller
decl_stmt|,
decl|*
name|arg
decl_stmt|;
end_function

begin_block
block|{
name|int
name|length
decl_stmt|;
if|if
condition|(
operator|!
name|arg
operator|||
operator|!
operator|*
name|arg
condition|)
return|return
literal|1
return|;
name|length
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
while|while
condition|(
name|arg
index|[
name|length
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|arg
index|[
name|length
operator|-
literal|1
index|]
operator|==
literal|'\t'
condition|)
name|length
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"on"
argument_list|,
name|length
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"1"
argument_list|,
name|length
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"yes"
argument_list|,
name|length
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"off"
argument_list|,
name|length
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"0"
argument_list|,
name|length
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"no"
argument_list|,
name|length
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
name|error
argument_list|(
literal|"\"%s\" not given a binary valued argument."
argument_list|,
name|caller
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Functions to manipulate command line editing control variables.  */
end_comment

begin_function
specifier|static
name|void
name|set_editing
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|command_editing_p
operator|=
name|parse_binary_operation
argument_list|(
literal|"set command-editing"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Number of commands to print in each call to editing_info.  */
end_comment

begin_define
define|#
directive|define
name|Hist_print
value|10
end_define

begin_function
specifier|static
name|void
name|editing_info
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* Index for history commands.  Relative to history_base.  */
name|int
name|offset
decl_stmt|;
comment|/* Number of the history entry which we are planning to display next.      Relative to history_base.  */
specifier|static
name|int
name|num
init|=
literal|0
decl_stmt|;
comment|/* The first command in the history which doesn't exist (i.e. one more      than the number of the last command).  Relative to history_base.  */
name|int
name|hist_len
decl_stmt|;
struct|struct
name|_hist_entry
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
block|}
modifier|*
name|history_get
argument_list|()
struct|;
specifier|extern
name|int
name|history_base
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"Interactive command editing is %s.\n"
argument_list|,
name|command_editing_p
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"History expansion of command input is %s.\n"
argument_list|,
name|history_expansion_p
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Writing of a history record upon exit is %s.\n"
argument_list|,
name|write_history_p
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"The size of the history list (number of stored commands) is %d.\n"
argument_list|,
name|history_size
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"The name of the history record is \"%s\".\n\n"
argument_list|,
name|history_filename
condition|?
name|history_filename
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* Print out some of the commands from the command history.  */
comment|/* First determine the length of the history list.  */
name|hist_len
operator|=
name|history_size
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|history_size
condition|;
name|offset
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|history_get
argument_list|(
name|history_base
operator|+
name|offset
argument_list|)
condition|)
block|{
name|hist_len
operator|=
name|offset
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|arg
condition|)
block|{
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'+'
operator|&&
name|arg
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
comment|/* "info editing +" should print from the stored position.  */
empty_stmt|;
else|else
comment|/* "info editing<exp>" should print around command number<exp>.  */
name|num
operator|=
operator|(
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
operator|-
name|history_base
operator|)
operator|-
name|Hist_print
operator|/
literal|2
expr_stmt|;
block|}
comment|/* "info editing" means print the last Hist_print commands.  */
else|else
block|{
name|num
operator|=
name|hist_len
operator|-
name|Hist_print
expr_stmt|;
block|}
if|if
condition|(
name|num
operator|<
literal|0
condition|)
name|num
operator|=
literal|0
expr_stmt|;
comment|/* If there are at least Hist_print commands, we want to display the last      Hist_print rather than, say, the last 6.  */
if|if
condition|(
name|hist_len
operator|-
name|num
operator|<
name|Hist_print
condition|)
block|{
name|num
operator|=
name|hist_len
operator|-
name|Hist_print
expr_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
condition|)
name|num
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|num
operator|==
name|hist_len
operator|-
name|Hist_print
condition|)
name|printf_filtered
argument_list|(
literal|"The list of the last %d commands is:\n\n"
argument_list|,
name|Hist_print
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"Some of the stored commands are:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
name|num
init|;
name|offset
operator|<
name|num
operator|+
name|Hist_print
operator|&&
name|offset
operator|<
name|hist_len
condition|;
name|offset
operator|++
control|)
block|{
name|printf_filtered
argument_list|(
literal|"%5d  %s\n"
argument_list|,
name|history_base
operator|+
name|offset
argument_list|,
operator|(
name|history_get
argument_list|(
name|history_base
operator|+
name|offset
argument_list|)
operator|)
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
comment|/* The next command we want to display is the next one that we haven't      displayed yet.  */
name|num
operator|+=
name|Hist_print
expr_stmt|;
comment|/* If the user repeats this command with return, it should do what      "info editing +" does.  This is unnecessary if arg is null,      because "info editing +" is not useful after "info editing".  */
if|if
condition|(
name|from_tty
operator|&&
name|arg
condition|)
block|{
name|arg
index|[
literal|0
index|]
operator|=
literal|'+'
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_history_expansion
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|history_expansion_p
operator|=
name|parse_binary_operation
argument_list|(
literal|"set history expansion"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_history_write
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|write_history_p
operator|=
name|parse_binary_operation
argument_list|(
literal|"set history write"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_history
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"\"set history\" must be followed by the name of a history subcommand.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|sethistlist
argument_list|,
literal|"set history "
argument_list|,
operator|-
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_history_size
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|*
name|arg
condition|)
name|error_no_arg
argument_list|(
literal|"set history size"
argument_list|)
expr_stmt|;
name|history_size
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_history_filename
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|error_no_arg
argument_list|(
literal|"history file name"
argument_list|)
expr_stmt|;
name|arg
operator|=
name|tilde_expand
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
operator|-
literal|1
expr_stmt|;
name|free
argument_list|(
name|history_filename
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
operator|(
name|arg
index|[
name|i
index|]
operator|==
literal|' '
operator|||
name|arg
index|[
name|i
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|i
operator|--
expr_stmt|;
operator|++
name|i
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|arg
condition|)
name|history_filename
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
else|else
name|history_filename
operator|=
name|savestring
argument_list|(
name|arg
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|history_filename
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|info_verbose
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_verbose_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|info_verbose
operator|=
name|parse_binary_operation
argument_list|(
literal|"set verbose"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|verbose_info
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|arg
condition|)
name|error
argument_list|(
literal|"\"info verbose\" does not take any arguments.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Verbose printing of information is %s.\n"
argument_list|,
name|info_verbose
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|float_handler
parameter_list|()
block|{
name|error
argument_list|(
literal|"Invalid floating value encountered or computed."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|initialize_cmd_lists
parameter_list|()
block|{
name|cmdlist
operator|=
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
literal|0
expr_stmt|;
name|infolist
operator|=
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
literal|0
expr_stmt|;
name|enablelist
operator|=
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
literal|0
expr_stmt|;
name|disablelist
operator|=
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
literal|0
expr_stmt|;
name|deletelist
operator|=
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
literal|0
expr_stmt|;
name|enablebreaklist
operator|=
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
literal|0
expr_stmt|;
name|setlist
operator|=
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
literal|0
expr_stmt|;
name|sethistlist
operator|=
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
literal|0
expr_stmt|;
name|unsethistlist
operator|=
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|initialize_main
parameter_list|()
block|{
name|char
modifier|*
name|tmpenv
decl_stmt|;
comment|/* Command line editing externals.  */
specifier|extern
name|int
function_decl|(
modifier|*
name|rl_completion_entry_function
function_decl|)
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|rl_completer_word_break_characters
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rl_readline_name
decl_stmt|;
comment|/* Set default verbose mode on.  */
name|info_verbose
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|KERNELDEBUG
if|if
condition|(
name|kernel_debugging
condition|)
name|prompt
operator|=
name|savestring
argument_list|(
literal|"(kgdb) "
argument_list|,
literal|7
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|prompt
operator|=
name|savestring
argument_list|(
literal|"(gdb) "
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Set the important stuff up for command editing.  */
name|command_editing_p
operator|=
literal|1
expr_stmt|;
name|history_expansion_p
operator|=
literal|0
expr_stmt|;
name|write_history_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tmpenv
operator|=
name|getenv
argument_list|(
literal|"HISTSIZE"
argument_list|)
condition|)
name|history_size
operator|=
name|atoi
argument_list|(
name|tmpenv
argument_list|)
expr_stmt|;
else|else
name|history_size
operator|=
literal|256
expr_stmt|;
name|stifle_history
argument_list|(
name|history_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpenv
operator|=
name|getenv
argument_list|(
literal|"GDBHISTFILE"
argument_list|)
condition|)
name|history_filename
operator|=
name|savestring
argument_list|(
name|tmpenv
argument_list|,
name|strlen
argument_list|(
name|tmpenv
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* We include the current directory so that if the user changes        directories the file written will be the same as the one        that was read.  */
name|history_filename
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/.gdb_history"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|read_history
argument_list|(
name|history_filename
argument_list|)
expr_stmt|;
comment|/* Setup important stuff for command line editing.  */
name|rl_completion_entry_function
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|symbol_completion_function
expr_stmt|;
name|rl_completer_word_break_characters
operator|=
name|gdb_completer_word_break_characters
expr_stmt|;
name|rl_readline_name
operator|=
literal|"gdb"
expr_stmt|;
comment|/* Define the classes of commands.      They will appear in the help list in the reverse of this order.  */
name|add_cmd
argument_list|(
literal|"obscure"
argument_list|,
name|class_obscure
argument_list|,
literal|0
argument_list|,
literal|"Obscure features."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"alias"
argument_list|,
name|class_alias
argument_list|,
literal|0
argument_list|,
literal|"Aliases of other commands."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"user"
argument_list|,
name|class_user
argument_list|,
literal|0
argument_list|,
literal|"User-defined commands.\n\ The commands in this class are those defined by the user.\n\ Use the \"define\" command to define a command."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"support"
argument_list|,
name|class_support
argument_list|,
literal|0
argument_list|,
literal|"Support facilities."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"status"
argument_list|,
name|class_info
argument_list|,
literal|0
argument_list|,
literal|"Status inquiries."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"files"
argument_list|,
name|class_files
argument_list|,
literal|0
argument_list|,
literal|"Specifying and examining files."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"breakpoints"
argument_list|,
name|class_breakpoint
argument_list|,
literal|0
argument_list|,
literal|"Making program stop at certain points."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"data"
argument_list|,
name|class_vars
argument_list|,
literal|0
argument_list|,
literal|"Examining data."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"stack"
argument_list|,
name|class_stack
argument_list|,
literal|0
argument_list|,
literal|"Examining the stack.\n\ The stack is made up of stack frames.  Gdb assigns numbers to stack frames\n\ counting from zero for the innermost (currently executing) frame.\n\n\ At any time gdb identifies one frame as the \"selected\" frame.\n\ Variable lookups are done with respect to the selected frame.\n\ When the program being debugged stops, gdb selects the innermost frame.\n\ The commands below can be used to select other frames by number or address."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"running"
argument_list|,
name|class_run
argument_list|,
literal|0
argument_list|,
literal|"Running the program."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"pwd"
argument_list|,
name|class_files
argument_list|,
name|pwd_command
argument_list|,
literal|"Print working directory.  This is used for your program as well."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"cd"
argument_list|,
name|class_files
argument_list|,
name|cd_command
argument_list|,
literal|"Set working directory to DIR for debugger and program being debugged.\n\ The change does not take effect for the program being debugged\n\ until the next time it is started."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"prompt"
argument_list|,
name|class_support
argument_list|,
name|set_prompt_command
argument_list|,
literal|"Change gdb's prompt from the default of \"(gdb)\""
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"echo"
argument_list|,
name|class_support
argument_list|,
name|echo_command
argument_list|,
literal|"Print a constant string.  Give string as argument.\n\ C escape sequences may be used in the argument.\n\ No newline is added at the end of the argument;\n\ use \"\\n\" if you want a newline to be printed.\n\ Since leading and trailing whitespace are ignored in command arguments,\n\ if you want to print some you must use \"\\\" before leading whitespace\n\ to be printed or after trailing whitespace."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"document"
argument_list|,
name|class_support
argument_list|,
name|document_command
argument_list|,
literal|"Document a user-defined command.\n\ Give command name as argument.  Give documentation on following lines.\n\ End with a line of just \"end\"."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"define"
argument_list|,
name|class_support
argument_list|,
name|define_command
argument_list|,
literal|"Define a new command name.  Command name is argument.\n\ Definition appears on following lines, one command per line.\n\ End with a line of just \"end\".\n\ Use the \"document\" command to give documentation for the new command.\n\ Commands defined in this way do not take arguments."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"source"
argument_list|,
name|class_support
argument_list|,
name|source_command
argument_list|,
literal|"Read commands from a file named FILE.\n\ Note that the file \".gdbinit\" is read automatically in this way\n\ when gdb is started."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"quit"
argument_list|,
name|class_support
argument_list|,
name|quit_command
argument_list|,
literal|"Exit gdb."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"help"
argument_list|,
name|class_support
argument_list|,
name|help_command
argument_list|,
literal|"Print list of commands."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"q"
argument_list|,
literal|"quit"
argument_list|,
name|class_support
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"h"
argument_list|,
literal|"help"
argument_list|,
name|class_support
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"while"
argument_list|,
name|class_support
argument_list|,
name|while_command
argument_list|,
literal|"execute following commands while condition is true.\n\ Expression for condition follows \"while\" keyword."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"if"
argument_list|,
name|class_support
argument_list|,
name|if_command
argument_list|,
literal|"execute following commands if condition is true.\n\ Expression for condition follows \"if\" keyword."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"verbose"
argument_list|,
name|class_support
argument_list|,
name|set_verbose_command
argument_list|,
literal|"Change the number of informational messages gdb prints."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"verbose"
argument_list|,
name|verbose_info
argument_list|,
literal|"Status of gdb's verbose printing option.\n"
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"dump-me"
argument_list|,
name|class_obscure
argument_list|,
name|dump_me_command
argument_list|,
literal|"Get fatal error; make debugger dump its core."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"editing"
argument_list|,
name|class_support
argument_list|,
name|set_editing
argument_list|,
literal|"Enable or disable command line editing.\n\ Use \"on\" to enable to enable the editing, and \"off\" to disable it.\n\ Without an argument, command line editing is enabled."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"history"
argument_list|,
name|class_support
argument_list|,
name|set_history
argument_list|,
literal|"Generic command for setting command history parameters."
argument_list|,
operator|&
name|sethistlist
argument_list|,
literal|"set history "
argument_list|,
literal|0
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"expansion"
argument_list|,
name|no_class
argument_list|,
name|set_history_expansion
argument_list|,
literal|"Enable or disable history expansion on command input.\n\ Without an argument, history expansion is enabled."
argument_list|,
operator|&
name|sethistlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"write"
argument_list|,
name|no_class
argument_list|,
name|set_history_write
argument_list|,
literal|"Enable or disable saving of the history record on exit.\n\ Use \"on\" to enable to enable the saving, and \"off\" to disable it.\n\ Without an argument, saving is enabled."
argument_list|,
operator|&
name|sethistlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"size"
argument_list|,
name|no_class
argument_list|,
name|set_history_size
argument_list|,
literal|"Set the size of the command history, \n\ ie. the number of previous commands to keep a record of."
argument_list|,
operator|&
name|sethistlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"filename"
argument_list|,
name|no_class
argument_list|,
name|set_history_filename
argument_list|,
literal|"Set the filename in which to record the command history\n\  (the list of previous commands of which a record is kept)."
argument_list|,
operator|&
name|sethistlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"info"
argument_list|,
name|class_info
argument_list|,
name|info_command
argument_list|,
literal|"Generic command for printing status."
argument_list|,
operator|&
name|infolist
argument_list|,
literal|"info "
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"i"
argument_list|,
literal|"info"
argument_list|,
name|class_info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"editing"
argument_list|,
name|editing_info
argument_list|,
literal|"Status of command editor."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"version"
argument_list|,
name|version_info
argument_list|,
literal|"Report what version of GDB this is."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

