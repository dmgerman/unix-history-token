begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  * Modified 1990 by Van Jacobson at Lawrence Berkeley Laboratory.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)dbxread.c	6.3 (Berkeley) 5/8/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Read dbx symbol tables and convert to internal format, for GDB.    Copyright (C) 1986, 1987, 1988, 1989 Free Software Foundation, Inc.  This file is part of GDB.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Symbol read-in occurs in two phases:    1.  A scan (read_dbx_symtab()) of the entire executable, whose sole        purpose is to make a list of symbols (partial symbol table)        which will cause symbols        to be read in if referenced.  This scan happens when the        "symbol-file" command is given (symbol_file_command()).    2.  Full read-in of symbols.  (psymtab_to_symtab()).  This happens        when a symbol in a file for which symbols have not yet been        read in is referenced.    2a.  The "add-file" command.  Similar to #2.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|READ_DBX_FORMAT
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_define
define|#
directive|define
name|L_SET
value|0
end_define

begin_define
define|#
directive|define
name|L_INCR
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_ENCAPSULATE
end_ifdef

begin_include
include|#
directive|include
file|"a.out.encap.h"
end_include

begin_include
include|#
directive|include
file|"stab.gnu.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_GNU_STABS
end_ifndef

begin_comment
comment|/*  * Define specifically gnu symbols here.  */
end_comment

begin_comment
comment|/* The following type indicates the definition of a symbol as being    an indirect reference to another symbol.  The other symbol    appears as an undefined reference, immediately following this symbol.     Indirection is asymmetrical.  The other symbol's value will be used    to satisfy requests for the indirect symbol, but not vice versa.    If the other symbol does not have a definition, libraries will    be searched to find a definition.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_INDR
end_ifndef

begin_define
define|#
directive|define
name|N_INDR
value|0xa
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The following symbols refer to set elements.    All the N_SET[ATDB] symbols with the same name form one set.    Space is allocated for the set in the text section, and each set    element's value is stored into one word of the space.    The first word of the space is the length of the set (number of elements).     The address of the set is made into an N_SETV symbol    whose name is the same as the name of the set.    This symbol acts like a N_DATA global symbol    in that it can satisfy undefined external references.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_SETA
end_ifndef

begin_define
define|#
directive|define
name|N_SETA
value|0x14
end_define

begin_comment
comment|/* Absolute set element symbol */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is input to LD, in a .o file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_SETT
end_ifndef

begin_define
define|#
directive|define
name|N_SETT
value|0x16
end_define

begin_comment
comment|/* Text set element symbol */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is input to LD, in a .o file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_SETD
end_ifndef

begin_define
define|#
directive|define
name|N_SETD
value|0x18
end_define

begin_comment
comment|/* Data set element symbol */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is input to LD, in a .o file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_SETB
end_ifndef

begin_define
define|#
directive|define
name|N_SETB
value|0x1A
end_define

begin_comment
comment|/* Bss set element symbol */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is input to LD, in a .o file.  */
end_comment

begin_comment
comment|/* Macros dealing with the set element symbols defined in a.out.h */
end_comment

begin_define
define|#
directive|define
name|SET_ELEMENT_P
parameter_list|(
name|x
parameter_list|)
value|((x)>=N_SETA&&(x)<=(N_SETB|N_EXT))
end_define

begin_define
define|#
directive|define
name|TYPE_OF_SET_ELEMENT
parameter_list|(
name|x
parameter_list|)
value|((x)-N_SETA+N_ABS)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|N_SETV
end_ifndef

begin_define
define|#
directive|define
name|N_SETV
value|0x1C
end_define

begin_comment
comment|/* Pointer to set vector in data area.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is output from LD.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_WARNING
end_ifndef

begin_define
define|#
directive|define
name|N_WARNING
value|0x1E
end_define

begin_comment
comment|/* Warning message to print if file included */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is input to ld */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__GNU_STAB__
end_ifndef

begin_comment
comment|/* Line number for the data section.  This is to be used to describe    the source location of a variable declaration.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_DSLINE
end_ifndef

begin_define
define|#
directive|define
name|N_DSLINE
value|(N_SLINE+N_DATA-N_TEXT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Line number for the bss section.  This is to be used to describe    the source location of a variable declaration.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|N_BSLINE
end_ifndef

begin_define
define|#
directive|define
name|N_BSLINE
value|(N_SLINE+N_BSS-N_TEXT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __GNU_STAB__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_GNU_STABS */
end_comment

begin_include
include|#
directive|include
file|<obstack.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|COFF_FORMAT
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|AOUTHDR
end_ifndef

begin_define
define|#
directive|define
name|AOUTHDR
value|struct exec
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|add_symbol_to_list
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_dbx_symtab
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_one_symbol
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_all_psymbols
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|read_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|read_range_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|read_enum_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|read_struct_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|read_array_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|read_number
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_huge_number
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finish_block
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|blockvector
modifier|*
name|make_blockvector
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|define_symbol
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|start_subfile
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hashname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hash_symsegs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pending
modifier|*
name|copy_pending
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_common_block
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_undefined_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cleanup_undefined_types
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|symtab
modifier|*
name|read_symsegs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free_all_symtabs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free_all_psymtabs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|free_inclink_symtabs
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* C++ */
end_comment

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|read_args
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Macro to determine which symbols to ignore when reading the first symbol    of a file.  Some machines override this definition. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|N_NSYMS
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|IGNORE_SYMBOL
end_ifndef

begin_comment
comment|/* This code is used on Ultrix systems.  Ignore it */
end_comment

begin_define
define|#
directive|define
name|IGNORE_SYMBOL
parameter_list|(
name|type
parameter_list|)
value|(type == N_NSYMS)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|IGNORE_SYMBOL
end_ifndef

begin_comment
comment|/* Don't ignore any symbols. */
end_comment

begin_define
define|#
directive|define
name|IGNORE_SYMBOL
parameter_list|(
name|type
parameter_list|)
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not N_NSYMS */
end_comment

begin_comment
comment|/* Macro for number of symbol table entries (in usual a.out format).    Some machines override this definition.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NUMBER_OF_SYMBOLS
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|COFF_HEADER
end_ifdef

begin_define
define|#
directive|define
name|NUMBER_OF_SYMBOLS
define|\
value|((COFF_HEADER(hdr) ? hdr.coffhdr.filehdr.f_nsyms : hdr.a_syms) /	\    sizeof (struct nlist))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NUMBER_OF_SYMBOLS
value|(hdr.a_syms / sizeof (struct nlist))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macro for file-offset of symbol table (in usual a.out format).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYMBOL_TABLE_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|SYMBOL_TABLE_OFFSET
value|N_SYMOFF (hdr)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macro for file-offset of string table (in usual a.out format).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STRING_TABLE_OFFSET
end_ifndef

begin_define
define|#
directive|define
name|STRING_TABLE_OFFSET
value|(N_SYMOFF (hdr) + hdr.a_syms)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macro to store the length of the string table data in INTO.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|READ_STRING_TABLE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|READ_STRING_TABLE_SIZE
parameter_list|(
name|INTO
parameter_list|)
define|\
value|{ val = myread (desc,&INTO, sizeof INTO);	\   if (val< 0) perror_with_name (name); }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macro to declare variables to hold the file's header data.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DECLARE_FILE_HEADERS
end_ifndef

begin_define
define|#
directive|define
name|DECLARE_FILE_HEADERS
value|AOUTHDR hdr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macro to read the header data from descriptor DESC and validate it.    NAME is the file name, for error messages.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|READ_FILE_HEADERS
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|HEADER_SEEK_FD
end_ifdef

begin_define
define|#
directive|define
name|READ_FILE_HEADERS
parameter_list|(
name|DESC
parameter_list|,
name|NAME
parameter_list|)
define|\
value|{ HEADER_SEEK_FD (DESC);			\   val = myread (DESC,&hdr, sizeof hdr);	\   if (val< 0) perror_with_name (NAME);		\   if (N_BADMAG (hdr))				\     error ("File \"%s\" not in executable format.", NAME); }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|READ_FILE_HEADERS
parameter_list|(
name|DESC
parameter_list|,
name|NAME
parameter_list|)
define|\
value|{ val = myread (DESC,&hdr, sizeof hdr);	\   if (val< 0) perror_with_name (NAME);		\   if (N_BADMAG (hdr))				\     error ("File \"%s\" not in executable format.", NAME); }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Non-zero if this is an object (.o) file, rather than an executable.    Distinguishing between the two is rarely necessary (and seems like    a hack, but there is no other way to do ADDR_OF_TEXT_SEGMENT    right for SunOS).  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|IS_OBJECT_FILE
argument_list|)
end_if

begin_comment
comment|/* This will not work    if someone decides to make ld preserve relocation info.  */
end_comment

begin_define
define|#
directive|define
name|IS_OBJECT_FILE
value|(hdr.a_trsize != 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macro for size of text segment */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIZE_OF_TEXT_SEGMENT
end_ifndef

begin_define
define|#
directive|define
name|SIZE_OF_TEXT_SEGMENT
value|hdr.a_text
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Get the address in debugged memory of the start    of the text segment.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ADDR_OF_TEXT_SEGMENT
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|N_TXTADDR
argument_list|)
end_if

begin_define
define|#
directive|define
name|ADDR_OF_TEXT_SEGMENT
value|(IS_OBJECT_FILE ? 0 : N_TXTADDR (hdr))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* no N_TXTADDR */
end_comment

begin_define
define|#
directive|define
name|ADDR_OF_TEXT_SEGMENT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no N_TXTADDR */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no ADDR_OF_TEXT_SEGMENT */
end_comment

begin_comment
comment|/* Macro to get entry point from headers.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ENTRY_POINT
end_ifndef

begin_define
define|#
directive|define
name|ENTRY_POINT
value|hdr.a_entry
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macro for name of symbol to indicate a file compiled with gcc. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GCC_COMPILED_FLAG_SYMBOL
end_ifndef

begin_define
define|#
directive|define
name|GCC_COMPILED_FLAG_SYMBOL
value|"gcc_compiled."
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Convert stab register number (from `r' declaration) to a gdb REGNUM.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STAB_REG_TO_REGNUM
end_ifndef

begin_define
define|#
directive|define
name|STAB_REG_TO_REGNUM
parameter_list|(
name|VALUE
parameter_list|)
value|(VALUE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define this as 1 if a pcc declaration of a char or short argument    gives the correct address.  Otherwise assume pcc gives the    address of the corresponding int, which is not the same on a    big-endian machine.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BELIEVE_PCC_PROMOTION
end_ifndef

begin_define
define|#
directive|define
name|BELIEVE_PCC_PROMOTION
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Nonzero means give verbose info on gdb action.  From main.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|info_verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of symtabs made from reading the file's symsegs.    These symtabs do not go into symtab_list themselves,    but the information is copied from them when appropriate    to make the symtabs that will exist permanently.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symtab
modifier|*
name|symseg_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Symseg symbol table for the file whose data we are now processing.    It is one of those in symseg_chain.  Or 0, for a compilation that    has no symseg.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symtab
modifier|*
name|current_symseg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of source file whose symbol data we are now processing.    This comes from a symbol of type N_SO.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_source_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Core address of start of text of current source file.    This too comes from the N_SO symbol.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|last_source_start_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* End of the text segment of the executable file,    as found in the symbol _etext.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|end_of_text_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of sub-source-files within the current individual compilation.    Each file gets its own symtab with its own linetable and associated info,    but they all share one blockvector.  */
end_comment

begin_struct
struct|struct
name|subfile
block|{
name|struct
name|subfile
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|linetable
modifier|*
name|line_vector
decl_stmt|;
name|int
name|line_vector_length
decl_stmt|;
name|int
name|line_vector_index
decl_stmt|;
name|int
name|prev_line_number
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|subfile
modifier|*
name|subfiles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|subfile
modifier|*
name|current_subfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count symbols as they are processed, for error messages.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|symnum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector of types defined so far, indexed by their dbx type numbers.    (In newer sun systems, dbx uses a pair of numbers in parens,     as in "(SUBFILENUM,NUMWITHINSUBFILE)".  Then these numbers must be     translated through the type_translations hash table to get     the index into the type vector.)  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|typevector
modifier|*
name|type_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements allocated for type_vector currently.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|type_vector_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Vector of line number information.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|linetable
modifier|*
name|line_vector
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of next entry to go in line_vector_index.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|line_vector_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last line number recorded in the line vector.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prev_line_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements allocated for line_vector currently.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|line_vector_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash table of global symbols whose values are not known yet.    They are chained thru the SYMBOL_VALUE, since we don't    have the correct data for that slot yet.  */
end_comment

begin_comment
comment|/* The use of the LOC_BLOCK code in this chain is nonstandard--    it refers to a FORTRAN common block rather than the usual meaning.  */
end_comment

begin_define
define|#
directive|define
name|HASHSIZE
value|127
end_define

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|global_sym_chain
index|[
name|HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Record the symbols defined for each context in a list.    We don't create a struct block for the context until we    know how long to make it.  */
end_comment

begin_define
define|#
directive|define
name|PENDINGSIZE
value|100
end_define

begin_struct
struct|struct
name|pending
block|{
name|struct
name|pending
modifier|*
name|next
decl_stmt|;
name|int
name|nsyms
decl_stmt|;
name|struct
name|symbol
modifier|*
name|symbol
index|[
name|PENDINGSIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* List of free `struct pending' structures for reuse.  */
end_comment

begin_decl_stmt
name|struct
name|pending
modifier|*
name|free_pendings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Here are the three lists that symbols are put on.  */
end_comment

begin_decl_stmt
name|struct
name|pending
modifier|*
name|file_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static at top level, and types */
end_comment

begin_decl_stmt
name|struct
name|pending
modifier|*
name|global_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global functions and variables */
end_comment

begin_decl_stmt
name|struct
name|pending
modifier|*
name|local_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* everything local to lexical context */
end_comment

begin_comment
comment|/* List of symbols declared since the last BCOMM.  This list is a tail    of local_symbols.  When ECOMM is seen, the symbols on the list    are noted so their proper addresses can be filled in later,    using the common block base address gotten from the assembler    stabs.  */
end_comment

begin_decl_stmt
name|struct
name|pending
modifier|*
name|common_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|common_block_i
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stack representing unclosed lexical contexts    (that will become blocks, eventually).  */
end_comment

begin_struct
struct|struct
name|context_stack
block|{
name|struct
name|pending
modifier|*
name|locals
decl_stmt|;
name|struct
name|pending_block
modifier|*
name|old_blocks
decl_stmt|;
name|struct
name|symbol
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|start_addr
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|context_stack
modifier|*
name|context_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index of first unused entry in context stack.  */
end_comment

begin_decl_stmt
name|int
name|context_stack_depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Currently allocated size of context stack.  */
end_comment

begin_decl_stmt
name|int
name|context_stack_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if within a function (so symbols should be local,    if nothing says specifically).  */
end_comment

begin_decl_stmt
name|int
name|within_function
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of blocks already made (lexical contexts already closed).    This is used at the end to make the blockvector.  */
end_comment

begin_struct
struct|struct
name|pending_block
block|{
name|struct
name|pending_block
modifier|*
name|next
decl_stmt|;
name|struct
name|block
modifier|*
name|block
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|pending_block
modifier|*
name|pending_blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|startup_file_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From blockframe.c */
end_comment

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|startup_file_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From blockframe.c */
end_comment

begin_comment
comment|/* File name symbols were loaded from.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|symfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Low and high symbol values (inclusive) for the global variable    entries in the symbol file. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|first_global_sym
decl_stmt|,
name|last_global_sym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structures with which to manage partial symbol allocation.  */
end_comment

begin_decl_stmt
name|struct
name|psymbol_allocation_list
name|global_psymbols
decl_stmt|,
name|static_psymbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global variable which, when set, indicates that we are processing a    .o file compiled with gcc */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|processing_gcc_compilation
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make a list of forward references which haven't been defined.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|undef_types
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|undef_types_allocated
decl_stmt|,
name|undef_types_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Setup a define to deal cleanly with the underscore problem */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NAMES_HAVE_UNDERSCORE
end_ifdef

begin_define
define|#
directive|define
name|HASH_OFFSET
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HASH_OFFSET
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* I'm not sure why this is here.  To debug bugs which cause    an infinite loop of allocations, I suppose.  In any event,    dumping core when out of memory isn't usually right.  */
end_comment

begin_else
unit|static int xxmalloc (n) {   int v = malloc (n);   if (v == 0)     {       fprintf (stderr, "Virtual memory exhausted.\n");       abort ();     }   return v; }
else|#
directive|else
end_else

begin_comment
comment|/* not 0 */
end_comment

begin_define
define|#
directive|define
name|xxmalloc
value|xmalloc
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not 0 */
end_comment

begin_comment
comment|/* Make a copy of the string at PTR with SIZE characters in the symbol obstack    (and add a null character at the end in the copy).    Returns the address of the copy.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|obsavestring
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|/* Open-coded bcopy--saves function call time.      These strings are usually short.  */
block|{
specifier|register
name|char
modifier|*
name|p1
init|=
name|ptr
decl_stmt|;
specifier|register
name|char
modifier|*
name|p2
init|=
name|p
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|ptr
operator|+
name|size
decl_stmt|;
while|while
condition|(
name|p1
operator|!=
name|end
condition|)
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
block|}
name|p
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Concatenate strings S1, S2 and S3; return the new string.    Space is found in the symbol_obstack.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|obconcat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
operator|+
name|strlen
argument_list|(
name|s2
argument_list|)
operator|+
name|strlen
argument_list|(
name|s3
argument_list|)
operator|+
literal|1
decl_stmt|;
specifier|register
name|char
modifier|*
name|val
init|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|val
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|val
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|val
argument_list|,
name|s3
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Support for Sun changes to dbx symbol format */
end_comment

begin_comment
comment|/* For each identified header file, we have a table of types defined    in that header file.     header_files maps header file names to their type tables.    It is a vector of n_header_files elements.    Each element describes one header file.    It contains a vector of types.     Sometimes it can happen that the same header file produces    different results when included in different places.    This can result from conditionals or from different    things done before including the file.    When this happens, there are multiple entries for the file in this table,    one entry for each distinct set of results.    The entries are distinguished by the INSTANCE field.    The INSTANCE field appears in the N_BINCL and N_EXCL symbol table and is    used to match header-file references to their corresponding data.  */
end_comment

begin_struct
struct|struct
name|header_file
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of header file */
name|int
name|instance
decl_stmt|;
comment|/* Numeric code distinguishing instances 				   of one header file that produced 				   different results when included. 				   It comes from the N_BINCL or N_EXCL.  */
name|struct
name|type
modifier|*
modifier|*
name|vector
decl_stmt|;
comment|/* Pointer to vector of types */
name|int
name|length
decl_stmt|;
comment|/* Allocated length (# elts) of that vector */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|header_file
modifier|*
name|header_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_header_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_allocated_header_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* During initial symbol readin, we need to have a structure to keep    track of which psymtabs have which bincls in them.  This structure    is used during readin to setup the list of dependencies within each    partial symbol table. */
end_comment

begin_struct
struct|struct
name|header_file_location
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of header file */
name|int
name|instance
decl_stmt|;
comment|/* See above */
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
comment|/* Partial symtab that has the 				   BINCL/EINCL defs for this file */
block|}
struct|;
end_struct

begin_comment
comment|/* The actual list and controling variables */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|header_file_location
modifier|*
name|bincl_list
decl_stmt|,
modifier|*
name|next_bincl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bincls_allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Within each object file, various header files are assigned numbers.    A type is defined or referred to with a pair of numbers    (FILENUM,TYPENUM) where FILENUM is the number of the header file    and TYPENUM is the number within that header file.    TYPENUM is the index within the vector of types for that header file.     FILENUM == 1 is special; it refers to the main source of the object file,    and not to any header file.  FILENUM != 1 is interpreted by looking it up    in the following table, which contains indices in header_files.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|this_object_header_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_this_object_header_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_allocated_this_object_header_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When a header file is getting special overriding definitions    for one source file, record here the header_files index    of its normal definition vector.    At other times, this is -1.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|header_file_prev_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* At the start of reading dbx symbols, allocate our tables.  */
end_comment

begin_function
specifier|static
name|void
name|init_header_files
parameter_list|()
block|{
name|n_allocated_header_files
operator|=
literal|10
expr_stmt|;
name|header_files
operator|=
operator|(
expr|struct
name|header_file
operator|*
operator|)
name|xxmalloc
argument_list|(
literal|10
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|header_file
argument_list|)
argument_list|)
expr_stmt|;
name|n_header_files
operator|=
literal|0
expr_stmt|;
name|n_allocated_this_object_header_files
operator|=
literal|10
expr_stmt|;
name|this_object_header_files
operator|=
operator|(
name|int
operator|*
operator|)
name|xxmalloc
argument_list|(
literal|10
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* At the end of reading dbx symbols, free our tables.  */
end_comment

begin_function
specifier|static
name|void
name|free_header_files
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_header_files
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|header_files
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|header_files
condition|)
name|free
argument_list|(
name|header_files
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_object_header_files
condition|)
name|free
argument_list|(
name|this_object_header_files
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called at the start of each object file's symbols.    Clear out the mapping of header file numbers to header files.  */
end_comment

begin_function
specifier|static
name|void
name|new_object_header_files
parameter_list|()
block|{
comment|/* Leave FILENUM of 0 free for builtin types and this file's types.  */
name|n_this_object_header_files
operator|=
literal|1
expr_stmt|;
name|header_file_prev_index
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add header file number I for this object file    at the next successive FILENUM.  */
end_comment

begin_function
specifier|static
name|void
name|add_this_object_header_file
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
name|n_this_object_header_files
operator|==
name|n_allocated_this_object_header_files
condition|)
block|{
name|n_allocated_this_object_header_files
operator|*=
literal|2
expr_stmt|;
name|this_object_header_files
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
name|this_object_header_files
argument_list|,
name|n_allocated_this_object_header_files
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|this_object_header_files
index|[
name|n_this_object_header_files
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add to this file an "old" header file, one already seen in    a previous object file.  NAME is the header file's name.    INSTANCE is its instance code, to select among multiple    symbol tables for the same header file.  */
end_comment

begin_function
specifier|static
name|void
name|add_old_header_file
parameter_list|(
name|name
parameter_list|,
name|instance
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|instance
decl_stmt|;
block|{
specifier|register
name|struct
name|header_file
modifier|*
name|p
init|=
name|header_files
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_header_files
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|&&
name|instance
operator|==
name|p
index|[
name|i
index|]
operator|.
name|instance
condition|)
block|{
name|add_this_object_header_file
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
literal|"Invalid symbol data: \"repeated\" header file that hasn't been seen before, at symtab pos %d."
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add to this file a "new" header file: definitions for its types follow.    NAME is the header file's name.    Most often this happens only once for each distinct header file,    but not necessarily.  If it happens more than once, INSTANCE has    a different value each time, and references to the header file    use INSTANCE values to select among them.     dbx output contains "begin" and "end" markers for each new header file,    but at this level we just need to know which files there have been;    so we record the file when its "begin" is seen and ignore the "end".  */
end_comment

begin_function
specifier|static
name|void
name|add_new_header_file
parameter_list|(
name|name
parameter_list|,
name|instance
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|instance
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|header_file
modifier|*
name|p
init|=
name|header_files
decl_stmt|;
name|header_file_prev_index
operator|=
operator|-
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This code was used before I knew about the instance codes.      My first hypothesis is that it is not necessary now      that instance codes are handled.  */
comment|/* Has this header file a previous definition?      If so, make a new entry anyway so that this use in this source file      gets a separate entry.  Later source files get the old entry.      Record here the index of the old entry, so that any type indices      not previously defined can get defined in the old entry as      well as in the new one.  */
block|for (i = 0; i< n_header_files; i++)     if (!strcmp (p[i].name, name))       { 	header_file_prev_index = i;       }
endif|#
directive|endif
comment|/* Make sure there is room for one more header file.  */
if|if
condition|(
name|n_header_files
operator|==
name|n_allocated_header_files
condition|)
block|{
name|n_allocated_header_files
operator|*=
literal|2
expr_stmt|;
name|header_files
operator|=
operator|(
expr|struct
name|header_file
operator|*
operator|)
name|xrealloc
argument_list|(
name|header_files
argument_list|,
operator|(
name|n_allocated_header_files
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|header_file
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Create an entry for this header file.  */
name|i
operator|=
name|n_header_files
operator|++
expr_stmt|;
name|header_files
index|[
name|i
index|]
operator|.
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|header_files
index|[
name|i
index|]
operator|.
name|instance
operator|=
name|instance
expr_stmt|;
name|header_files
index|[
name|i
index|]
operator|.
name|length
operator|=
literal|10
expr_stmt|;
name|header_files
index|[
name|i
index|]
operator|.
name|vector
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xxmalloc
argument_list|(
literal|10
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|header_files
index|[
name|i
index|]
operator|.
name|vector
argument_list|,
literal|10
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|add_this_object_header_file
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look up a dbx type-number pair.  Return the address of the slot    where the type for that number-pair is stored.    The number-pair is in TYPENUMS.     This can be used for finding the type associated with that pair    or for associating a new type with the pair.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|dbx_lookup_type
parameter_list|(
name|typenums
parameter_list|)
name|int
name|typenums
index|[
literal|2
index|]
decl_stmt|;
block|{
specifier|register
name|int
name|filenum
init|=
name|typenums
index|[
literal|0
index|]
decl_stmt|,
name|index
init|=
name|typenums
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|filenum
operator|<
literal|0
operator|||
name|filenum
operator|>=
name|n_this_object_header_files
condition|)
name|error
argument_list|(
literal|"Invalid symbol data: type number (%d,%d) out of range at symtab pos %d."
argument_list|,
name|filenum
argument_list|,
name|index
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|filenum
operator|==
literal|0
condition|)
block|{
comment|/* Type is defined outside of header files. 	 Find it in this object file's type vector.  */
if|if
condition|(
name|index
operator|>=
name|type_vector_length
condition|)
block|{
name|type_vector_length
operator|*=
literal|2
expr_stmt|;
name|type_vector
operator|=
operator|(
expr|struct
name|typevector
operator|*
operator|)
name|xrealloc
argument_list|(
name|type_vector
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|typevector
argument_list|)
operator|+
name|type_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|type_vector
operator|->
name|type
index|[
name|type_vector_length
operator|/
literal|2
index|]
argument_list|,
name|type_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
operator|&
name|type_vector
operator|->
name|type
index|[
name|index
index|]
return|;
block|}
else|else
block|{
specifier|register
name|int
name|real_filenum
init|=
name|this_object_header_files
index|[
name|filenum
index|]
decl_stmt|;
specifier|register
name|struct
name|header_file
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|real_filenum
operator|>=
name|n_header_files
condition|)
name|abort
argument_list|()
expr_stmt|;
name|f
operator|=
operator|&
name|header_files
index|[
name|real_filenum
index|]
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|f
operator|->
name|length
condition|)
block|{
name|f
operator|->
name|length
operator|*=
literal|2
expr_stmt|;
name|f
operator|->
name|vector
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|f
operator|->
name|vector
argument_list|,
name|f
operator|->
name|length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|f
operator|->
name|vector
index|[
name|f
operator|->
name|length
operator|/
literal|2
index|]
argument_list|,
name|f
operator|->
name|length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
operator|&
name|f
operator|->
name|vector
index|[
name|index
index|]
return|;
block|}
block|}
end_function

begin_comment
comment|/* Create a type object.  Occaisionally used when you need a type    which isn't going to be given a type number.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|dbx_create_type
parameter_list|()
block|{
specifier|register
name|struct
name|type
modifier|*
name|type
init|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Make sure there is a type allocated for type numbers TYPENUMS    and return the type object.    This can create an empty (zeroed) type object.    TYPENUMS may be (-1, -1) to return a new type object that is not    put into the type vector, and so may not be referred to by number. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|dbx_alloc_type
parameter_list|(
name|typenums
parameter_list|)
name|int
name|typenums
index|[
literal|2
index|]
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
modifier|*
name|type_addr
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
if|if
condition|(
name|typenums
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|type_addr
operator|=
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
expr_stmt|;
name|type
operator|=
operator|*
name|type_addr
expr_stmt|;
block|}
else|else
block|{
name|type_addr
operator|=
literal|0
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If we are referring to a type not known at all yet,      allocate an empty type for it.      We will fill it in later if we find out how.  */
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|dbx_create_type
argument_list|()
expr_stmt|;
if|if
condition|(
name|type_addr
condition|)
operator|*
name|type_addr
operator|=
name|type
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static struct type ** explicit_lookup_type (real_filenum, index)      int real_filenum, index; {   register struct header_file *f =&header_files[real_filenum];    if (index>= f->length)     {       f->length *= 2;       f->vector = (struct type **) 	xrealloc (f->vector, f->length * sizeof (struct type *));       bzero (&f->vector[f->length / 2], 	     f->length * sizeof (struct type *) / 2);     }   return&f->vector[index]; }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* maintain the lists of symbols and blocks */
end_comment

begin_comment
comment|/* Add a symbol to one of the lists of symbols.  */
end_comment

begin_function
specifier|static
name|void
name|add_symbol_to_list
parameter_list|(
name|symbol
parameter_list|,
name|listhead
parameter_list|)
name|struct
name|symbol
modifier|*
name|symbol
decl_stmt|;
name|struct
name|pending
modifier|*
modifier|*
name|listhead
decl_stmt|;
block|{
comment|/* We keep PENDINGSIZE symbols in each link of the list.      If we don't have a link with room in it, add a new link.  */
if|if
condition|(
operator|*
name|listhead
operator|==
literal|0
operator|||
operator|(
operator|*
name|listhead
operator|)
operator|->
name|nsyms
operator|==
name|PENDINGSIZE
condition|)
block|{
specifier|register
name|struct
name|pending
modifier|*
name|link
decl_stmt|;
if|if
condition|(
name|free_pendings
condition|)
block|{
name|link
operator|=
name|free_pendings
expr_stmt|;
name|free_pendings
operator|=
name|link
operator|->
name|next
expr_stmt|;
block|}
else|else
name|link
operator|=
operator|(
expr|struct
name|pending
operator|*
operator|)
name|xxmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|->
name|next
operator|=
operator|*
name|listhead
expr_stmt|;
operator|*
name|listhead
operator|=
name|link
expr_stmt|;
name|link
operator|->
name|nsyms
operator|=
literal|0
expr_stmt|;
block|}
operator|(
operator|*
name|listhead
operator|)
operator|->
name|symbol
index|[
operator|(
operator|*
name|listhead
operator|)
operator|->
name|nsyms
operator|++
index|]
operator|=
name|symbol
expr_stmt|;
block|}
end_function

begin_comment
comment|/* At end of reading syms, or in case of quit,    really free as many `struct pending's as we can easily find.  */
end_comment

begin_function
specifier|static
name|void
name|really_free_pendings
parameter_list|()
block|{
name|struct
name|pending
modifier|*
name|next
decl_stmt|,
modifier|*
name|next1
decl_stmt|;
name|struct
name|pending_block
modifier|*
name|bnext
decl_stmt|,
modifier|*
name|bnext1
decl_stmt|;
for|for
control|(
name|next
operator|=
name|free_pendings
init|;
name|next
condition|;
name|next
operator|=
name|next1
control|)
block|{
name|next1
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
name|free_pendings
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bnext
operator|=
name|pending_blocks
init|;
name|bnext
condition|;
name|bnext
operator|=
name|bnext1
control|)
block|{
name|bnext1
operator|=
name|bnext
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|bnext
argument_list|)
expr_stmt|;
block|}
name|pending_blocks
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|next
operator|=
name|file_symbols
init|;
name|next
condition|;
name|next
operator|=
name|next1
control|)
block|{
name|next1
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|next
operator|=
name|global_symbols
init|;
name|next
condition|;
name|next
operator|=
name|next1
control|)
block|{
name|next1
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Take one of the lists of symbols and make a block from it.    Keep the order the symbols have in the list (reversed from the input file).    Put the block on the list of pending blocks.  */
end_comment

begin_function
specifier|static
name|void
name|finish_block
parameter_list|(
name|symbol
parameter_list|,
name|listhead
parameter_list|,
name|old_blocks
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
name|struct
name|symbol
modifier|*
name|symbol
decl_stmt|;
name|struct
name|pending
modifier|*
modifier|*
name|listhead
decl_stmt|;
name|struct
name|pending_block
modifier|*
name|old_blocks
decl_stmt|;
name|CORE_ADDR
name|start
decl_stmt|,
name|end
decl_stmt|;
block|{
specifier|register
name|struct
name|pending
modifier|*
name|next
decl_stmt|,
modifier|*
name|next1
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|block
decl_stmt|;
specifier|register
name|struct
name|pending_block
modifier|*
name|pblock
decl_stmt|;
name|struct
name|pending_block
modifier|*
name|opblock
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Count the length of the list of symbols.  */
for|for
control|(
name|next
operator|=
operator|*
name|listhead
operator|,
name|i
operator|=
literal|0
init|;
name|next
condition|;
name|i
operator|+=
name|next
operator|->
name|nsyms
operator|,
name|next
operator|=
name|next
operator|->
name|next
control|)
empty_stmt|;
name|block
operator|=
operator|(
expr|struct
name|block
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|block
argument_list|)
operator|+
operator|(
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Copy the symbols into the block.  */
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
operator|=
name|i
expr_stmt|;
for|for
control|(
name|next
operator|=
operator|*
name|listhead
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|next
operator|->
name|nsyms
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
operator|--
name|i
argument_list|)
operator|=
name|next
operator|->
name|symbol
index|[
name|j
index|]
expr_stmt|;
block|}
name|BLOCK_START
argument_list|(
name|block
argument_list|)
operator|=
name|start
expr_stmt|;
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|=
name|end
expr_stmt|;
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Filled in when containing block is made */
name|BLOCK_GCC_COMPILED
argument_list|(
name|block
argument_list|)
operator|=
name|processing_gcc_compilation
expr_stmt|;
comment|/* Put the block in as the value of the symbol that names it.  */
if|if
condition|(
name|symbol
condition|)
block|{
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|symbol
argument_list|)
operator|=
name|block
expr_stmt|;
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
operator|=
name|symbol
expr_stmt|;
block|}
else|else
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Now "free" the links of the list, and empty the list.  */
for|for
control|(
name|next
operator|=
operator|*
name|listhead
init|;
name|next
condition|;
name|next
operator|=
name|next1
control|)
block|{
name|next1
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|next
operator|->
name|next
operator|=
name|free_pendings
expr_stmt|;
name|free_pendings
operator|=
name|next
expr_stmt|;
block|}
operator|*
name|listhead
operator|=
literal|0
expr_stmt|;
comment|/* Install this block as the superblock      of all blocks made since the start of this scope      that don't have superblocks yet.  */
name|opblock
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pblock
operator|=
name|pending_blocks
init|;
name|pblock
operator|!=
name|old_blocks
condition|;
name|pblock
operator|=
name|pblock
operator|->
name|next
control|)
block|{
if|if
condition|(
name|BLOCK_SUPERBLOCK
argument_list|(
name|pblock
operator|->
name|block
argument_list|)
operator|==
literal|0
condition|)
name|BLOCK_SUPERBLOCK
argument_list|(
name|pblock
operator|->
name|block
argument_list|)
operator|=
name|block
expr_stmt|;
name|opblock
operator|=
name|pblock
expr_stmt|;
block|}
comment|/* Record this block on the list of all blocks in the file.      Put it after opblock, or at the beginning if opblock is 0.      This puts the block in the list after all its subblocks.  */
comment|/* Allocate in the symbol_obstack to save time.      It wastes a little space.  */
name|pblock
operator|=
operator|(
expr|struct
name|pending_block
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pending_block
argument_list|)
argument_list|)
expr_stmt|;
name|pblock
operator|->
name|block
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|opblock
condition|)
block|{
name|pblock
operator|->
name|next
operator|=
name|opblock
operator|->
name|next
expr_stmt|;
name|opblock
operator|->
name|next
operator|=
name|pblock
expr_stmt|;
block|}
else|else
block|{
name|pblock
operator|->
name|next
operator|=
name|pending_blocks
expr_stmt|;
name|pending_blocks
operator|=
name|pblock
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|blockvector
modifier|*
name|make_blockvector
parameter_list|()
block|{
specifier|register
name|struct
name|pending_block
modifier|*
name|next
decl_stmt|,
modifier|*
name|next1
decl_stmt|;
specifier|register
name|struct
name|blockvector
modifier|*
name|blockvector
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Count the length of the list of blocks.  */
for|for
control|(
name|next
operator|=
name|pending_blocks
operator|,
name|i
operator|=
literal|0
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
operator|,
name|i
operator|++
control|)
empty_stmt|;
name|blockvector
operator|=
operator|(
expr|struct
name|blockvector
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|blockvector
argument_list|)
operator|+
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|block
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Copy the blocks into the blockvector.      This is done in reverse order, which happens to put      the blocks into the proper order (ascending starting address).      finish_block has hair to insert each block into the list      after its subblocks in order to make sure this is true.  */
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|blockvector
argument_list|)
operator|=
name|i
expr_stmt|;
for|for
control|(
name|next
operator|=
name|pending_blocks
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
name|BLOCKVECTOR_BLOCK
argument_list|(
name|blockvector
argument_list|,
operator|--
name|i
argument_list|)
operator|=
name|next
operator|->
name|block
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Now we make the links in the obstack, so don't free them.  */
comment|/* Now free the links of the list, and empty the list.  */
block|for (next = pending_blocks; next; next = next1)     {       next1 = next->next;       free (next);     }
endif|#
directive|endif
name|pending_blocks
operator|=
literal|0
expr_stmt|;
return|return
name|blockvector
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Manage the vector of line numbers.  */
end_comment

begin_function
specifier|static
name|void
name|record_line
parameter_list|(
name|line
parameter_list|,
name|pc
parameter_list|)
name|int
name|line
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|struct
name|linetable_entry
modifier|*
name|e
decl_stmt|;
comment|/* Ignore the dummy line number in libg.o */
if|if
condition|(
name|line
operator|==
literal|0xffff
condition|)
return|return;
comment|/* Make sure line vector is big enough.  */
if|if
condition|(
name|line_vector_index
operator|+
literal|1
operator|>=
name|line_vector_length
condition|)
block|{
name|line_vector_length
operator|*=
literal|2
expr_stmt|;
name|line_vector
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xrealloc
argument_list|(
name|line_vector
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
name|line_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|current_subfile
operator|->
name|line_vector
operator|=
name|line_vector
expr_stmt|;
block|}
name|e
operator|=
name|line_vector
operator|->
name|item
operator|+
name|line_vector_index
operator|++
expr_stmt|;
name|e
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|e
operator|->
name|pc
operator|=
name|pc
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start a new symtab for a new source file.    This is called when a dbx symbol of type N_SO is seen;    it indicates the start of data for one original source file.  */
end_comment

begin_function
specifier|static
name|void
name|start_symtab
parameter_list|(
name|name
parameter_list|,
name|start_addr
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|start_addr
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|last_source_file
operator|=
name|name
expr_stmt|;
name|last_source_start_addr
operator|=
name|start_addr
expr_stmt|;
name|file_symbols
operator|=
literal|0
expr_stmt|;
name|global_symbols
operator|=
literal|0
expr_stmt|;
name|within_function
operator|=
literal|0
expr_stmt|;
comment|/* Context stack is initially empty, with room for 10 levels.  */
name|context_stack
operator|=
operator|(
expr|struct
name|context_stack
operator|*
operator|)
name|xxmalloc
argument_list|(
literal|10
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|context_stack
argument_list|)
argument_list|)
expr_stmt|;
name|context_stack_size
operator|=
literal|10
expr_stmt|;
name|context_stack_depth
operator|=
literal|0
expr_stmt|;
name|new_object_header_files
argument_list|()
expr_stmt|;
for|for
control|(
name|s
operator|=
name|symseg_chain
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|ldsymoff
operator|==
name|symnum
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
condition|)
break|break;
name|current_symseg
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|0
condition|)
return|return;
name|type_vector_length
operator|=
literal|160
expr_stmt|;
name|type_vector
operator|=
operator|(
expr|struct
name|typevector
operator|*
operator|)
name|xxmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|typevector
argument_list|)
operator|+
name|type_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|type_vector
operator|->
name|type
argument_list|,
name|type_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the list of sub source files with one entry      for this file (the top-level source file).  */
name|subfiles
operator|=
literal|0
expr_stmt|;
name|current_subfile
operator|=
literal|0
expr_stmt|;
name|start_subfile
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This is now set at the beginning of read_ofile_symtab */
comment|/* Set default for compiler to pcc; assume that we aren't processing      a gcc compiled file until proved otherwise.  */
block|processing_gcc_compilation = 0;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Handle an N_SOL symbol, which indicates the start of    code that came from an included (or otherwise merged-in)    source file with a different name.  */
end_comment

begin_function
specifier|static
name|void
name|start_subfile
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|subfile
modifier|*
name|subfile
decl_stmt|;
comment|/* Save the current subfile's line vector data.  */
if|if
condition|(
name|current_subfile
condition|)
block|{
name|current_subfile
operator|->
name|line_vector_index
operator|=
name|line_vector_index
expr_stmt|;
name|current_subfile
operator|->
name|line_vector_length
operator|=
name|line_vector_length
expr_stmt|;
name|current_subfile
operator|->
name|prev_line_number
operator|=
name|prev_line_number
expr_stmt|;
block|}
comment|/* See if this subfile is already known as a subfile of the      current main source file.  */
for|for
control|(
name|subfile
operator|=
name|subfiles
init|;
name|subfile
condition|;
name|subfile
operator|=
name|subfile
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|subfile
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|line_vector
operator|=
name|subfile
operator|->
name|line_vector
expr_stmt|;
name|line_vector_index
operator|=
name|subfile
operator|->
name|line_vector_index
expr_stmt|;
name|line_vector_length
operator|=
name|subfile
operator|->
name|line_vector_length
expr_stmt|;
name|prev_line_number
operator|=
name|subfile
operator|->
name|prev_line_number
expr_stmt|;
name|current_subfile
operator|=
name|subfile
expr_stmt|;
return|return;
block|}
block|}
comment|/* This subfile is not known.  Add an entry for it.  */
name|line_vector_index
operator|=
literal|0
expr_stmt|;
name|line_vector_length
operator|=
literal|1000
expr_stmt|;
name|prev_line_number
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* Force first line number to be explicit */
name|line_vector
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xxmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
name|line_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make an entry for this subfile in the list of all subfiles      of the current main source file.  */
name|subfile
operator|=
operator|(
expr|struct
name|subfile
operator|*
operator|)
name|xxmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|subfile
argument_list|)
argument_list|)
expr_stmt|;
name|subfile
operator|->
name|next
operator|=
name|subfiles
expr_stmt|;
name|subfile
operator|->
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|subfile
operator|->
name|line_vector
operator|=
name|line_vector
expr_stmt|;
name|subfiles
operator|=
name|subfile
expr_stmt|;
name|current_subfile
operator|=
name|subfile
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the symbol definitions for one main source file,    close off all the lexical contexts for that file    (creating struct block's for them), then make the struct symtab    for that file and put it in the list of all such.     END_ADDR is the address of the end of the file's text.  */
end_comment

begin_function
specifier|static
name|void
name|end_symtab
parameter_list|(
name|end_addr
parameter_list|)
name|CORE_ADDR
name|end_addr
decl_stmt|;
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
specifier|register
name|struct
name|blockvector
modifier|*
name|blockvector
decl_stmt|;
specifier|register
name|struct
name|subfile
modifier|*
name|subfile
decl_stmt|;
specifier|register
name|struct
name|linetable
modifier|*
name|lv
decl_stmt|;
name|struct
name|subfile
modifier|*
name|nextsub
decl_stmt|;
if|if
condition|(
name|current_symseg
operator|!=
literal|0
condition|)
block|{
name|last_source_file
operator|=
literal|0
expr_stmt|;
name|current_symseg
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Finish the lexical context of the last function in the file;      pop the context stack.  */
if|if
condition|(
name|context_stack_depth
operator|>
literal|0
condition|)
block|{
specifier|register
name|struct
name|context_stack
modifier|*
name|cstk
decl_stmt|;
name|context_stack_depth
operator|--
expr_stmt|;
name|cstk
operator|=
operator|&
name|context_stack
index|[
name|context_stack_depth
index|]
expr_stmt|;
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
name|cstk
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|cstk
operator|->
name|old_blocks
argument_list|,
name|cstk
operator|->
name|start_addr
argument_list|,
name|end_addr
argument_list|)
expr_stmt|;
block|}
comment|/* Cleanup any undefined types that have been left hanging around      (this needs to be done before the finish_blocks so that      file_symbols is still good).  */
name|cleanup_undefined_types
argument_list|()
expr_stmt|;
comment|/* Finish defining all the blocks of this symtab.  */
name|finish_block
argument_list|(
literal|0
argument_list|,
operator|&
name|file_symbols
argument_list|,
literal|0
argument_list|,
name|last_source_start_addr
argument_list|,
name|end_addr
argument_list|)
expr_stmt|;
name|finish_block
argument_list|(
literal|0
argument_list|,
operator|&
name|global_symbols
argument_list|,
literal|0
argument_list|,
name|last_source_start_addr
argument_list|,
name|end_addr
argument_list|)
expr_stmt|;
name|blockvector
operator|=
name|make_blockvector
argument_list|()
expr_stmt|;
name|current_subfile
operator|->
name|line_vector_index
operator|=
name|line_vector_index
expr_stmt|;
comment|/* Now create the symtab objects proper, one for each subfile.  */
comment|/* (The main file is one of them.)  */
for|for
control|(
name|subfile
operator|=
name|subfiles
init|;
name|subfile
condition|;
name|subfile
operator|=
name|nextsub
control|)
block|{
name|symtab
operator|=
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|xxmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab
argument_list|)
argument_list|)
expr_stmt|;
name|symtab
operator|->
name|free_ptr
operator|=
literal|0
expr_stmt|;
comment|/* Fill in its components.  */
name|symtab
operator|->
name|blockvector
operator|=
name|blockvector
expr_stmt|;
name|type_vector
operator|->
name|length
operator|=
name|type_vector_length
expr_stmt|;
name|symtab
operator|->
name|typevector
operator|=
name|type_vector
expr_stmt|;
name|symtab
operator|->
name|free_code
operator|=
name|free_linetable
expr_stmt|;
if|if
condition|(
name|subfile
operator|->
name|next
operator|==
literal|0
condition|)
name|symtab
operator|->
name|free_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|type_vector
expr_stmt|;
name|symtab
operator|->
name|filename
operator|=
name|subfile
operator|->
name|name
expr_stmt|;
name|lv
operator|=
name|subfile
operator|->
name|line_vector
expr_stmt|;
name|lv
operator|->
name|nitems
operator|=
name|subfile
operator|->
name|line_vector_index
expr_stmt|;
name|symtab
operator|->
name|linetable
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xrealloc
argument_list|(
name|lv
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
name|lv
operator|->
name|nitems
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|symtab
operator|->
name|nlines
operator|=
literal|0
expr_stmt|;
name|symtab
operator|->
name|line_charpos
operator|=
literal|0
expr_stmt|;
comment|/* Link the new symtab into the list of such.  */
name|symtab
operator|->
name|next
operator|=
name|symtab_list
expr_stmt|;
name|symtab_list
operator|=
name|symtab
expr_stmt|;
name|nextsub
operator|=
name|subfile
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|subfile
argument_list|)
expr_stmt|;
block|}
name|type_vector
operator|=
literal|0
expr_stmt|;
name|type_vector_length
operator|=
operator|-
literal|1
expr_stmt|;
name|line_vector
operator|=
literal|0
expr_stmt|;
name|line_vector_length
operator|=
operator|-
literal|1
expr_stmt|;
name|last_source_file
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|N_BINCL
end_ifdef

begin_comment
comment|/* Handle the N_BINCL and N_EINCL symbol types    that act like N_SOL for switching source files    (different subfiles, as we call them) within one object file,    but using a stack rather than in an arbitrary order.  */
end_comment

begin_struct
struct|struct
name|subfile_stack
block|{
name|struct
name|subfile_stack
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|prev_index
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|subfile_stack
modifier|*
name|subfile_stack
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|push_subfile
parameter_list|()
block|{
specifier|register
name|struct
name|subfile_stack
modifier|*
name|tem
init|=
operator|(
expr|struct
name|subfile_stack
operator|*
operator|)
name|xxmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|subfile_stack
argument_list|)
argument_list|)
decl_stmt|;
name|tem
operator|->
name|next
operator|=
name|subfile_stack
expr_stmt|;
name|subfile_stack
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|current_subfile
operator|==
literal|0
operator|||
name|current_subfile
operator|->
name|name
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|tem
operator|->
name|name
operator|=
name|current_subfile
operator|->
name|name
expr_stmt|;
name|tem
operator|->
name|prev_index
operator|=
name|header_file_prev_index
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|pop_subfile
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|struct
name|subfile_stack
modifier|*
name|link
init|=
name|subfile_stack
decl_stmt|;
if|if
condition|(
name|link
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|name
operator|=
name|link
operator|->
name|name
expr_stmt|;
name|subfile_stack
operator|=
name|link
operator|->
name|next
expr_stmt|;
name|header_file_prev_index
operator|=
name|link
operator|->
name|prev_index
expr_stmt|;
name|free
argument_list|(
name|link
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Have N_BINCL */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Accumulate the misc functions in bunches of 127.    At the end, copy them all into one newly allocated structure.  */
end_comment

begin_define
define|#
directive|define
name|MISC_BUNCH_SIZE
value|127
end_define

begin_struct
struct|struct
name|misc_bunch
block|{
name|struct
name|misc_bunch
modifier|*
name|next
decl_stmt|;
name|struct
name|misc_function
name|contents
index|[
name|MISC_BUNCH_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Bunch currently being filled up.    The next field points to chain of filled bunches.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|misc_bunch
modifier|*
name|misc_bunch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of slots filled in current bunch.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|misc_bunch_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of misc functions recorded so far.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|misc_count
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_misc_functions
parameter_list|()
block|{
name|misc_count
operator|=
literal|0
expr_stmt|;
name|misc_bunch
operator|=
literal|0
expr_stmt|;
name|misc_bunch_index
operator|=
name|MISC_BUNCH_SIZE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|record_misc_function
parameter_list|(
name|name
parameter_list|,
name|address
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|misc_bunch
modifier|*
name|new
decl_stmt|;
specifier|register
name|unsigned
name|char
name|mtype
decl_stmt|;
if|if
condition|(
name|misc_bunch_index
operator|==
name|MISC_BUNCH_SIZE
condition|)
block|{
name|new
operator|=
operator|(
expr|struct
name|misc_bunch
operator|*
operator|)
name|xxmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|misc_bunch
argument_list|)
argument_list|)
expr_stmt|;
name|misc_bunch_index
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|misc_bunch
expr_stmt|;
name|misc_bunch
operator|=
name|new
expr_stmt|;
block|}
name|misc_bunch
operator|->
name|contents
index|[
name|misc_bunch_index
index|]
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|misc_bunch
operator|->
name|contents
index|[
name|misc_bunch_index
index|]
operator|.
name|address
operator|=
name|address
expr_stmt|;
switch|switch
condition|(
name|type
operator|&
operator|~
name|N_EXT
condition|)
block|{
case|case
name|N_TEXT
case|:
name|mtype
operator|=
name|mf_text
expr_stmt|;
break|break;
case|case
name|N_DATA
case|:
name|mtype
operator|=
name|mf_data
expr_stmt|;
break|break;
case|case
name|N_BSS
case|:
name|mtype
operator|=
name|mf_bss
expr_stmt|;
break|break;
case|case
name|N_ABS
case|:
name|mtype
operator|=
name|mf_abs
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|N_SETV
case|case
name|N_SETV
case|:
name|mtype
operator|=
name|mf_data
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|mtype
operator|=
name|mf_unknown
expr_stmt|;
break|break;
block|}
name|misc_bunch
operator|->
name|contents
index|[
name|misc_bunch_index
index|]
operator|.
name|type
operator|=
name|mtype
expr_stmt|;
name|misc_bunch_index
operator|++
expr_stmt|;
name|misc_count
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|compare_misc_functions
parameter_list|(
name|fn1
parameter_list|,
name|fn2
parameter_list|)
name|struct
name|misc_function
modifier|*
name|fn1
decl_stmt|,
decl|*
name|fn2
decl_stmt|;
end_function

begin_block
block|{
comment|/* Return a signed result based on unsigned comparisons      so that we sort into unsigned numeric order.  */
if|if
condition|(
name|fn1
operator|->
name|address
operator|<
name|fn2
operator|->
name|address
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|fn1
operator|->
name|address
operator|>
name|fn2
operator|->
name|address
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|discard_misc_bunches
parameter_list|()
block|{
specifier|register
name|struct
name|misc_bunch
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|misc_bunch
condition|)
block|{
name|next
operator|=
name|misc_bunch
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|misc_bunch
argument_list|)
expr_stmt|;
name|misc_bunch
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* INCLINK nonzero means bunches are from an incrementally-linked file.    Add them to the existing bunches.    Otherwise INCLINK is zero, and we start from scratch. */
end_comment

begin_function
specifier|static
name|void
name|condense_misc_bunches
parameter_list|(
name|inclink
parameter_list|)
name|int
name|inclink
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|struct
name|misc_bunch
modifier|*
name|bunch
decl_stmt|;
ifdef|#
directive|ifdef
name|NAMES_HAVE_UNDERSCORE
name|int
name|offset
init|=
literal|1
decl_stmt|;
else|#
directive|else
name|int
name|offset
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|inclink
condition|)
block|{
name|misc_function_vector
operator|=
operator|(
expr|struct
name|misc_function
operator|*
operator|)
name|xrealloc
argument_list|(
name|misc_function_vector
argument_list|,
operator|(
name|misc_count
operator|+
name|misc_function_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|misc_function
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|=
name|misc_function_count
expr_stmt|;
block|}
else|else
block|{
name|misc_function_vector
operator|=
operator|(
expr|struct
name|misc_function
operator|*
operator|)
name|xxmalloc
argument_list|(
name|misc_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|misc_function
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
block|}
name|bunch
operator|=
name|misc_bunch
expr_stmt|;
while|while
condition|(
name|bunch
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|misc_bunch_index
condition|;
name|i
operator|++
control|)
block|{
name|misc_function_vector
index|[
name|j
index|]
operator|=
name|bunch
operator|->
name|contents
index|[
name|i
index|]
expr_stmt|;
name|misc_function_vector
index|[
name|j
index|]
operator|.
name|name
operator|=
name|obconcat
argument_list|(
name|misc_function_vector
index|[
name|j
index|]
operator|.
name|name
operator|+
operator|(
name|misc_function_vector
index|[
name|j
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|?
name|offset
else|:
literal|0
operator|)
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|bunch
operator|=
name|bunch
operator|->
name|next
expr_stmt|;
name|misc_bunch_index
operator|=
name|MISC_BUNCH_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|inclink
condition|)
name|misc_function_count
operator|+=
name|misc_count
expr_stmt|;
else|else
name|misc_function_count
operator|=
name|j
expr_stmt|;
comment|/* Sort the misc functions by address.  */
name|qsort
argument_list|(
name|misc_function_vector
argument_list|,
name|misc_function_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|misc_function
argument_list|)
argument_list|,
name|compare_misc_functions
argument_list|)
expr_stmt|;
comment|/* (re)build the hash table (positions changed during the sort) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MISC_FUNC_HASH_SIZE
condition|;
operator|++
name|i
control|)
name|misc_function_hash_tab
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|misc_function_count
condition|;
operator|++
name|i
control|)
block|{
name|j
operator|=
name|hash_symbol
argument_list|(
name|misc_function_vector
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|&
operator|(
name|MISC_FUNC_HASH_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|misc_function_vector
index|[
name|i
index|]
operator|.
name|next
operator|=
name|misc_function_hash_tab
index|[
name|j
index|]
expr_stmt|;
name|misc_function_hash_tab
index|[
name|j
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Call sort_syms to sort alphabetically    the symbols of each block of each symtab.  */
end_comment

begin_function
specifier|static
name|int
name|compare_symbols
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|struct
name|symbol
modifier|*
modifier|*
name|s1
decl_stmt|,
decl|*
modifier|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|namediff
decl_stmt|;
comment|/* Compare the initial characters.  */
name|namediff
operator|=
name|SYMBOL_NAME
argument_list|(
operator|*
name|s1
argument_list|)
index|[
literal|0
index|]
operator|-
name|SYMBOL_NAME
argument_list|(
operator|*
name|s2
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|namediff
operator|!=
literal|0
condition|)
return|return
name|namediff
return|;
comment|/* If they match, compare the rest of the names.  */
name|namediff
operator|=
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
operator|*
name|s1
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
operator|*
name|s2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|namediff
operator|!=
literal|0
condition|)
return|return
name|namediff
return|;
comment|/* For symbols of the same name, registers should come first.  */
return|return
operator|(
operator|(
name|SYMBOL_CLASS
argument_list|(
operator|*
name|s2
argument_list|)
operator|==
name|LOC_REGISTER
operator|)
operator|-
operator|(
name|SYMBOL_CLASS
argument_list|(
operator|*
name|s1
argument_list|)
operator|==
name|LOC_REGISTER
operator|)
operator|)
return|;
block|}
end_block

begin_function_decl
specifier|static
name|void
name|sort_symtab_syms
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|sort_syms
parameter_list|()
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|symtab_list
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
name|sort_symtab_syms
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sort_symtab_syms
parameter_list|(
name|s
parameter_list|)
specifier|register
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|struct
name|blockvector
modifier|*
name|bv
init|=
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|int
name|nbl
init|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
comment|/* Note that in the following sort, we always make sure that      register debug symbol declarations always come before regular      debug symbol declarations (as might happen when parameters are      then put into registers by the compiler).  We do this by a      correct compare in compare_symbols, and by the reversal of the      symbols if we don't sort.  This works as long as a register debug      symbol always comes after a parameter debug symbol. */
comment|/* This is no longer necessary; lookup_block_symbol now always      prefers some other declaration over a parameter declaration.  We      still sort the thing (that is necessary), but we don't reverse it      if we shouldn't sort it.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbl
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_SHOULD_SORT
argument_list|(
name|b
argument_list|)
condition|)
name|qsort
argument_list|(
operator|&
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
argument_list|,
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
argument_list|,
name|compare_symbols
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function_decl
specifier|extern
name|struct
name|symtab
modifier|*
name|psymtab_to_symtab
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The entry point.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|entry_point
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|symfile_string_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|symfile_string_table_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the symbol-file command.  Read the file, analyze its symbols,    and add a struct symtab to symtab_list.  */
end_comment

begin_function
name|void
name|symbol_file_command
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|int
name|desc
decl_stmt|;
name|DECLARE_FILE_HEADERS
expr_stmt|;
name|struct
name|nlist
modifier|*
name|nlist
decl_stmt|;
comment|/* The string table.  */
name|char
modifier|*
name|stringtab
decl_stmt|;
comment|/* The size of the string table (buffer is a bizarre name...).  */
name|long
name|buffer
decl_stmt|;
specifier|register
name|int
name|val
decl_stmt|;
specifier|extern
name|void
name|close
parameter_list|()
function_decl|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|symtab
modifier|*
name|symseg
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|symtab_list
operator|||
name|partial_symtab_list
operator|)
operator|&&
name|from_tty
operator|&&
operator|!
name|query
argument_list|(
literal|"Discard symbol table? "
argument_list|,
literal|0
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
if|if
condition|(
name|symfile
condition|)
name|free
argument_list|(
name|symfile
argument_list|)
expr_stmt|;
name|symfile
operator|=
literal|0
expr_stmt|;
name|free_all_symtabs
argument_list|()
expr_stmt|;
name|free_all_psymtabs
argument_list|()
expr_stmt|;
return|return;
block|}
name|name
operator|=
name|tilde_expand
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|symtab_list
operator|||
name|partial_symtab_list
operator|)
operator|&&
operator|!
name|query
argument_list|(
literal|"Load new symbol table from \"%s\"? "
argument_list|,
name|name
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|absolute_name
decl_stmt|;
name|desc
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|absolute_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|absolute_name
expr_stmt|;
block|}
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|close
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|READ_FILE_HEADERS
argument_list|(
name|desc
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|entry_point
operator|=
name|ENTRY_POINT
expr_stmt|;
if|if
condition|(
name|NUMBER_OF_SYMBOLS
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|symfile
condition|)
name|free
argument_list|(
name|symfile
argument_list|)
expr_stmt|;
name|symfile
operator|=
literal|0
expr_stmt|;
name|free_all_symtabs
argument_list|()
expr_stmt|;
name|free_all_psymtabs
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%s has no symbol-table; symbols discarded.\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"Reading symbol data from %s..."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Now read the string table, all at once.  */
name|val
operator|=
name|lseek
argument_list|(
name|desc
argument_list|,
name|STRING_TABLE_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|READ_STRING_TABLE_SIZE
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|>=
literal|0
operator|&&
name|buffer
operator|<
name|statbuf
operator|.
name|st_size
condition|)
block|{
comment|/* This should speed things up without consuming much 	 extra memory (because probably little of the space is going 	 to be reused anyway, whether in data or stack space).  	 A quick test (running GDB on itself and setting 9 breakpoints 	 in different files) showed that memory usage was almost 	 identical for the two cases.  */
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|BROKEN_LARGE_ALLOCA
block|stringtab = (char *) xmalloc (buffer);       make_cleanup (free, stringtab);
else|#
directive|else
block|stringtab = (char *) alloca (buffer);
endif|#
directive|endif
endif|#
directive|endif
name|stringtab
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|symfile_string_table
operator|=
name|stringtab
expr_stmt|;
name|symfile_string_table_size
operator|=
name|buffer
expr_stmt|;
block|}
else|else
name|stringtab
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stringtab
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"ridiculous string table size: %d bytes"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
comment|/* Usually READ_STRING_TABLE_SIZE will have shifted the file pointer.      Occaisionally, it won't.  */
name|val
operator|=
name|lseek
argument_list|(
name|desc
argument_list|,
name|STRING_TABLE_OFFSET
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|val
operator|=
name|myread
argument_list|(
name|desc
argument_list|,
name|stringtab
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Throw away the old symbol table.  */
if|if
condition|(
name|symfile
condition|)
name|free
argument_list|(
name|symfile
argument_list|)
expr_stmt|;
name|symfile
operator|=
literal|0
expr_stmt|;
name|free_all_symtabs
argument_list|()
expr_stmt|;
name|free_all_psymtabs
argument_list|()
expr_stmt|;
comment|/* Empty the hash table of global syms looking for values.  */
name|bzero
argument_list|(
name|global_sym_chain
argument_list|,
sizeof|sizeof
name|global_sym_chain
argument_list|)
expr_stmt|;
comment|/* Symsegs are no longer supported by GDB.  Setting symseg_chain to      0 is easier than finding all the symseg code and eliminating it.  */
name|symseg_chain
operator|=
literal|0
expr_stmt|;
comment|/* Position to read the symbol table.  Do not read it all at once. */
name|val
operator|=
name|lseek
argument_list|(
name|desc
argument_list|,
name|SYMBOL_TABLE_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Don't put these on the cleanup chain; they need to stick around      until the next call to symbol_file_command.  *Then* we'll free      them. */
name|free_header_files
argument_list|()
expr_stmt|;
name|init_header_files
argument_list|()
expr_stmt|;
name|init_misc_functions
argument_list|()
expr_stmt|;
name|make_cleanup
argument_list|(
name|discard_misc_bunches
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_pendings
operator|=
literal|0
expr_stmt|;
name|pending_blocks
operator|=
literal|0
expr_stmt|;
name|file_symbols
operator|=
literal|0
expr_stmt|;
name|global_symbols
operator|=
literal|0
expr_stmt|;
name|make_cleanup
argument_list|(
name|really_free_pendings
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now that the symbol table data of the executable file are all in core,      process them and define symbols accordingly.  Closes desc.  */
name|read_dbx_symtab
argument_list|(
name|desc
argument_list|,
name|stringtab
argument_list|,
name|buffer
argument_list|,
name|NUMBER_OF_SYMBOLS
argument_list|,
literal|0
argument_list|,
name|ADDR_OF_TEXT_SEGMENT
argument_list|,
name|SIZE_OF_TEXT_SEGMENT
argument_list|)
expr_stmt|;
comment|/* Go over the misc functions and install them in vector.  */
name|condense_misc_bunches
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't allow char * to have a typename (else would get caddr_t.)  */
name|TYPE_NAME
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_char
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Make a default for file to list.  */
name|symfile
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call to select_source_symtab used to be here; it was using too      much time.  I'll make sure that list_sources can handle the lack      of current_source_symtab */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
comment|/* Descriptor closed here */
comment|/* Free the symtabs made by read_symsegs, but not their contents,      which have been copied into symtabs on symtab_list.  */
while|while
condition|(
name|symseg_chain
condition|)
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
init|=
name|symseg_chain
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|symseg_chain
argument_list|)
expr_stmt|;
name|symseg_chain
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|partial_symtab_list
condition|)
name|printf
argument_list|(
literal|"\n(no debugging symbols found)..."
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return name of file symbols were loaded from, or 0 if none..  */
end_comment

begin_function
name|char
modifier|*
name|get_sym_file
parameter_list|()
block|{
return|return
name|symfile
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Buffer for reading the symbol table entries.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|nlist
name|symbuf
index|[
literal|4096
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|symbuf_idx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|symbuf_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* I/O descriptor for reading the symbol table.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|symtab_input_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The address of the string table    of the object file we are reading (as copied into core).  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stringtab_global
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Refill the symbol table input buffer    and set the variables that control fetching entries from it.    Reports an error if no data available.    This function can read past the end of the symbol table    (into the string table) but this does no harm.  */
end_comment

begin_function
specifier|static
name|int
name|fill_symbuf
parameter_list|()
block|{
name|int
name|nbytes
init|=
name|myread
argument_list|(
name|symtab_input_desc
argument_list|,
name|symbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|symbuf
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|nbytes
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"error or end of file reading symbol table"
argument_list|)
expr_stmt|;
name|symbuf_end
operator|=
name|nbytes
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
expr_stmt|;
name|symbuf_idx
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* dbx allows the text of a symbol name to be continued into the    next symbol name!  When such a continuation is encountered    (a \ at the end of the text of a name)    call this function to get the continuation.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|next_symbol_text
parameter_list|()
block|{
if|if
condition|(
name|symbuf_idx
operator|==
name|symbuf_end
condition|)
name|fill_symbuf
argument_list|()
expr_stmt|;
name|symnum
operator|++
expr_stmt|;
return|return
name|symbuf
index|[
name|symbuf_idx
operator|++
index|]
operator|.
name|n_un
operator|.
name|n_strx
operator|+
name|stringtab_global
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Initializes storage for all of the partial symbols that will be  * created by read_dbx_symtab and subsidiaries.  */
end_comment

begin_function
name|void
name|init_psymbol_list
parameter_list|(
name|total_symbols
parameter_list|)
name|int
name|total_symbols
decl_stmt|;
block|{
comment|/* Current best guess is that there are approximately a twentieth      of the total symbols (in a debugging file) are global or static      oriented symbols */
name|global_psymbols
operator|.
name|size
operator|=
name|total_symbols
operator|/
literal|10
expr_stmt|;
name|static_psymbols
operator|.
name|size
operator|=
name|total_symbols
operator|/
literal|10
expr_stmt|;
name|global_psymbols
operator|.
name|next
operator|=
name|global_psymbols
operator|.
name|list
operator|=
operator|(
expr|struct
name|partial_symbol
operator|*
operator|)
name|xmalloc
argument_list|(
name|global_psymbols
operator|.
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
argument_list|)
argument_list|)
expr_stmt|;
name|static_psymbols
operator|.
name|next
operator|=
name|static_psymbols
operator|.
name|list
operator|=
operator|(
expr|struct
name|partial_symbol
operator|*
operator|)
name|xmalloc
argument_list|(
name|static_psymbols
operator|.
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the list of bincls to contain none and have some  * allocated.  */
end_comment

begin_function
specifier|static
name|void
name|init_bincl_list
parameter_list|(
name|number
parameter_list|)
name|int
name|number
decl_stmt|;
block|{
name|bincls_allocated
operator|=
name|number
expr_stmt|;
name|next_bincl
operator|=
name|bincl_list
operator|=
operator|(
expr|struct
name|header_file_location
operator|*
operator|)
name|xmalloc
argument_list|(
name|bincls_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|header_file_location
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a bincl to the list.  */
end_comment

begin_function
specifier|static
name|void
name|add_bincl_to_list
parameter_list|(
name|pst
parameter_list|,
name|name
parameter_list|,
name|instance
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|instance
decl_stmt|;
block|{
if|if
condition|(
name|next_bincl
operator|>=
name|bincl_list
operator|+
name|bincls_allocated
condition|)
block|{
name|int
name|offset
init|=
name|next_bincl
operator|-
name|bincl_list
decl_stmt|;
name|bincls_allocated
operator|*=
literal|2
expr_stmt|;
name|bincl_list
operator|=
operator|(
expr|struct
name|header_file_location
operator|*
operator|)
name|xrealloc
argument_list|(
name|bincl_list
argument_list|,
name|bincls_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|header_file_location
argument_list|)
argument_list|)
expr_stmt|;
name|next_bincl
operator|=
name|bincl_list
operator|+
name|offset
expr_stmt|;
block|}
name|next_bincl
operator|->
name|pst
operator|=
name|pst
expr_stmt|;
name|next_bincl
operator|->
name|instance
operator|=
name|instance
expr_stmt|;
name|next_bincl
operator|++
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a name, value pair, find the corresponding  * bincl in the list.  Return the partial symtab associated  * with that header_file_location.  */
end_comment

begin_function
name|struct
name|partial_symtab
modifier|*
name|find_corresponding_bincl_psymtab
parameter_list|(
name|name
parameter_list|,
name|instance
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|instance
decl_stmt|;
block|{
name|struct
name|header_file_location
modifier|*
name|bincl
decl_stmt|;
for|for
control|(
name|bincl
operator|=
name|bincl_list
init|;
name|bincl
operator|<
name|next_bincl
condition|;
name|bincl
operator|++
control|)
if|if
condition|(
name|bincl
operator|->
name|instance
operator|==
name|instance
operator|&&
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|bincl
operator|->
name|name
argument_list|)
condition|)
return|return
name|bincl
operator|->
name|pst
return|;
return|return
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Free the storage allocated for the bincl list.  */
end_comment

begin_function
specifier|static
name|void
name|free_bincl_list
parameter_list|()
block|{
name|free
argument_list|(
name|bincl_list
argument_list|)
expr_stmt|;
name|bincls_allocated
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|struct
name|partial_symtab
modifier|*
name|start_psymtab
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_psymtab_dependency
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|end_psymtab
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|compare_psymbols
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
specifier|register
name|struct
name|partial_symbol
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|st1
init|=
name|SYMBOL_NAME
argument_list|(
name|s1
argument_list|)
decl_stmt|,
modifier|*
name|st2
init|=
name|SYMBOL_NAME
argument_list|(
name|s2
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|st1
index|[
literal|0
index|]
operator|-
name|st2
index|[
literal|0
index|]
condition|)
return|return
operator|(
name|st1
index|[
literal|0
index|]
operator|-
name|st2
index|[
literal|0
index|]
operator|)
return|;
if|if
condition|(
name|st1
index|[
literal|1
index|]
operator|-
name|st2
index|[
literal|1
index|]
condition|)
return|return
operator|(
name|st1
index|[
literal|1
index|]
operator|-
name|st2
index|[
literal|1
index|]
operator|)
return|;
if|if
condition|(
name|i
operator|=
name|strcmp
argument_list|(
name|st1
argument_list|,
name|st2
argument_list|)
condition|)
return|return
operator|(
name|i
operator|)
return|;
comment|/* Next comparison implements policy that used to be in lookup_symbol:    * it would search psymtabs in psymtab_list order (reverse order of    * declaration)& take first occurance of symbol it found.  So, we    * collate duplicate names in reverse psymtab order. */
return|return
operator|(
name|s2
operator|->
name|pst
operator|-
name|s1
operator|->
name|pst
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Given pointers to an a.out symbol table in core containing dbx    style data, setup partial_symtab's describing each source file for    which debugging information is available.  NLISTLEN is the number    of symbols in the symbol table.  All symbol names are given as    offsets relative to STRINGTAB.  STRINGTAB_SIZE is the size of    STRINGTAB.     I have no idea whether or not this routine should be setup to deal    with inclinks.  It seems reasonable to me that they be dealt with    standardly, so I am not going to make a strong effort to deal with    them here.    */
end_comment

begin_function
specifier|static
name|void
name|read_dbx_symtab
parameter_list|(
name|desc
parameter_list|,
name|stringtab
parameter_list|,
name|stringtab_size
parameter_list|,
name|nlistlen
parameter_list|,
name|inclink
parameter_list|,
name|text_addr
parameter_list|,
name|text_size
parameter_list|)
name|int
name|desc
decl_stmt|;
specifier|register
name|char
modifier|*
name|stringtab
decl_stmt|;
specifier|register
name|long
name|stringtab_size
decl_stmt|;
specifier|register
name|int
name|nlistlen
decl_stmt|;
name|int
name|inclink
decl_stmt|;
name|unsigned
name|text_addr
decl_stmt|;
name|int
name|text_size
decl_stmt|;
block|{
specifier|register
name|struct
name|nlist
modifier|*
name|bufp
decl_stmt|;
specifier|register
name|char
modifier|*
name|namestring
decl_stmt|;
specifier|register
name|struct
name|partial_symbol
modifier|*
name|psym
decl_stmt|;
specifier|register
name|struct
name|psymbol_allocation_list
modifier|*
name|psymbol_struct
decl_stmt|;
name|int
name|nsl
decl_stmt|;
name|int
name|past_first_source_file
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|last_o_file_start
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|last_o_file_name
init|=
literal|"*bogus*"
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|enum
name|namespace
name|ns
decl_stmt|;
name|enum
name|address_class
name|class
decl_stmt|;
ifdef|#
directive|ifdef
name|PROFILE_TYPES
name|int
name|i
decl_stmt|;
name|int
name|profile_types
index|[
literal|256
index|]
decl_stmt|;
name|int
name|strcmp_called
init|=
literal|0
decl_stmt|;
name|int
name|autovars
init|=
literal|0
decl_stmt|;
name|int
name|global_funs
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* Current partial symtab */
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
comment|/* List of current psymtab's include files */
name|char
modifier|*
modifier|*
name|psymtab_include_list
decl_stmt|;
name|int
name|includes_allocated
decl_stmt|;
name|int
name|includes_used
decl_stmt|;
comment|/* Index within current psymtab dependency list */
name|struct
name|partial_symtab
modifier|*
modifier|*
name|dependency_list
decl_stmt|;
name|int
name|dependencies_used
decl_stmt|,
name|dependencies_allocated
decl_stmt|;
ifdef|#
directive|ifdef
name|PROFILE_TYPES
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|profile_types
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|stringtab_global
operator|=
name|stringtab
expr_stmt|;
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|includes_allocated
operator|=
literal|30
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|psymtab_include_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|includes_allocated
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dependencies_allocated
operator|=
literal|30
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
name|dependency_list
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|dependencies_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_all_psymtabs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Init bincl list */
name|init_bincl_list
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free_bincl_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup global partial symbol list */
name|init_psymbol_list
argument_list|(
name|nlistlen
argument_list|)
expr_stmt|;
name|last_source_file
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|END_OF_TEXT_DEFAULT
name|end_of_text_addr
operator|=
name|END_OF_TEXT_DEFAULT
expr_stmt|;
else|#
directive|else
name|end_of_text_addr
operator|=
name|text_addr
operator|+
name|text_size
expr_stmt|;
endif|#
directive|endif
name|symtab_input_desc
operator|=
name|desc
expr_stmt|;
comment|/* This is needed for fill_symbuf below */
name|symbuf_end
operator|=
name|symbuf_idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|symnum
operator|=
literal|0
init|;
name|symnum
operator|<
name|nlistlen
condition|;
name|symnum
operator|++
control|)
block|{
comment|/* Get the symbol for this run and pull out some info */
name|QUIT
expr_stmt|;
comment|/* allow this to be interruptable */
if|if
condition|(
name|symbuf_idx
operator|==
name|symbuf_end
condition|)
name|fill_symbuf
argument_list|()
expr_stmt|;
name|bufp
operator|=
operator|&
name|symbuf
index|[
name|symbuf_idx
operator|++
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|PROFILE_TYPES
name|profile_types
index|[
name|bufp
operator|->
name|n_type
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/*        * Special case to speed up readin.        */
if|if
condition|(
name|bufp
operator|->
name|n_type
operator|==
name|N_SLINE
condition|)
continue|continue;
comment|/* Ok.  There is a lot of code duplicated in the rest of this          switch statiement (for efficiency reasons).  Since I don't          like duplicating code, I will do my penance here, and          describe the code which is duplicated:  	 *) The assignment to namestring. 	 *) The call to index. 	 *) The addition of a partial symbol the the two partial 	    symbol lists.  This last is a large section of code, so 	    I've imbedded it in the following macro. 	 */
comment|/* Set namestring based on bufp.  */
define|#
directive|define
name|SET_NAMESTRING
parameter_list|()
define|\
value|if (bufp->n_un.n_strx< 0 || bufp->n_un.n_strx>= stringtab_size)  \     error ("Invalid symbol data: bad string table offset: %d",       \ 	   bufp->n_un.n_strx);                                       \   namestring = bufp->n_un.n_strx + stringtab
define|#
directive|define
name|ADD_PSYMBOL_TO_LIST
parameter_list|(
name|NAME
parameter_list|,
name|NAMELENGTH
parameter_list|,
name|NAMESPACE
parameter_list|,
name|CLASS
parameter_list|,
name|LIST
parameter_list|,
name|VALUE
parameter_list|)
define|\
value|do {		        						\     if ((LIST).next>=							\ 	(LIST).list + (LIST).size)					\       {									\ 	(LIST).list = (struct partial_symbol *)				\ 	  xrealloc ((LIST).list,					\ 		    ((LIST).size * 2					\ 		     * sizeof (struct partial_symbol)));		\
comment|/* Next assumes we only went one over.  Should be good if	\ 	   program works correctly */
value|\ 	(LIST).next =							\ 	  (LIST).list + (LIST).size;					\ 	(LIST).size *= 2;						\       }									\     psym = (LIST).next++;						\ 									\     SYMBOL_NAME (psym) = (char *) obstack_alloc (psymbol_obstack,	\ 						 (NAMELENGTH) + 1);	\     strncpy (SYMBOL_NAME (psym), (NAME), (NAMELENGTH));			\     SYMBOL_NAME (psym)[(NAMELENGTH)] = '\0';				\     SYMBOL_NAMESPACE (psym) = (NAMESPACE);				\     SYMBOL_CLASS (psym) = (CLASS);					\     SYMBOL_VALUE (psym) = (VALUE); 					\   } while (0);
switch|switch
condition|(
name|bufp
operator|->
name|n_type
condition|)
block|{
comment|/* 	   * Standard, non-debugger, symbols 	   */
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
comment|/* Catch etext */
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
if|if
condition|(
name|namestring
index|[
literal|6
index|]
operator|==
literal|'\0'
operator|&&
name|namestring
index|[
literal|5
index|]
operator|==
literal|'t'
operator|&&
name|namestring
index|[
literal|4
index|]
operator|==
literal|'x'
operator|&&
name|namestring
index|[
literal|3
index|]
operator|==
literal|'e'
operator|&&
name|namestring
index|[
literal|2
index|]
operator|==
literal|'t'
operator|&&
name|namestring
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
name|namestring
index|[
literal|0
index|]
operator|==
literal|'_'
condition|)
name|end_of_text_addr
operator|=
name|bufp
operator|->
name|n_value
expr_stmt|;
comment|/* Figure out beginning and end of global linker symbol 	     section and put non-debugger specified symbols on 	     tmp_symchain */
name|last_global_sym
operator|=
name|symnum
expr_stmt|;
if|if
condition|(
operator|!
name|first_global_sym
condition|)
name|first_global_sym
operator|=
name|symnum
expr_stmt|;
name|record_misc_function
argument_list|(
name|namestring
argument_list|,
name|bufp
operator|->
name|n_value
argument_list|,
name|bufp
operator|->
name|n_type
argument_list|)
expr_stmt|;
comment|/* Always */
continue|continue;
ifdef|#
directive|ifdef
name|N_NBTEXT
case|case
name|N_NBTEXT
operator||
name|N_EXT
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|N_NBDATA
case|case
name|N_NBDATA
operator||
name|N_EXT
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|N_NBBSS
case|case
name|N_NBBSS
operator||
name|N_EXT
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|N_SETV
case|case
name|N_SETV
operator||
name|N_EXT
case|:
endif|#
directive|endif
case|case
name|N_ABS
operator||
name|N_EXT
case|:
case|case
name|N_DATA
operator||
name|N_EXT
case|:
case|case
name|N_BSS
operator||
name|N_EXT
case|:
comment|/* Figure out beginning and end of global linker symbol 	     section and put non-debugger specified symbols on 	     tmp_symchain */
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
name|last_global_sym
operator|=
name|symnum
expr_stmt|;
if|if
condition|(
operator|!
name|first_global_sym
condition|)
name|first_global_sym
operator|=
name|symnum
expr_stmt|;
comment|/* Not really a function here, but... */
name|record_misc_function
argument_list|(
name|namestring
argument_list|,
name|bufp
operator|->
name|n_value
argument_list|,
name|bufp
operator|->
name|n_type
argument_list|)
expr_stmt|;
comment|/* Always */
continue|continue;
ifdef|#
directive|ifdef
name|N_NBTEXT
case|case
name|N_NBTEXT
case|:
endif|#
directive|endif
comment|/* We need to be able to deal with both N_FN or N_TEXT, 	     because we have no way of knowing whether the sys-supplied ld 	     or GNU ld was used to make the executable.  */
if|#
directive|if
operator|!
operator|(
name|N_FN
operator|&
name|N_EXT
operator|)
case|case
name|N_FN
case|:
endif|#
directive|endif
case|case
name|N_FN
operator||
name|N_EXT
case|:
case|case
name|N_TEXT
case|:
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|namestring
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|namestring
index|[
literal|1
index|]
operator|==
literal|'l'
operator|)
operator|||
operator|(
name|namestring
index|[
operator|(
name|nsl
operator|=
name|strlen
argument_list|(
name|namestring
argument_list|)
operator|)
operator|-
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|namestring
index|[
name|nsl
operator|-
literal|2
index|]
operator|==
literal|'.'
operator|)
condition|)
block|{
if|if
condition|(
name|entry_point
operator|<
name|bufp
operator|->
name|n_value
operator|&&
name|entry_point
operator|>=
name|last_o_file_start
condition|)
block|{
name|startup_file_start
operator|=
name|last_o_file_start
expr_stmt|;
name|startup_file_end
operator|=
name|bufp
operator|->
name|n_value
expr_stmt|;
block|}
if|if
condition|(
name|past_first_source_file
operator|&&
name|pst
condition|)
block|{
name|end_psymtab
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
name|symnum
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
name|bufp
operator|->
name|n_value
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|,
name|global_psymbols
operator|.
name|next
argument_list|,
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|past_first_source_file
operator|=
literal|1
expr_stmt|;
name|last_o_file_start
operator|=
name|bufp
operator|->
name|n_value
expr_stmt|;
name|last_o_file_name
operator|=
name|namestring
expr_stmt|;
name|nsl
operator|=
name|strlen
argument_list|(
name|namestring
argument_list|)
expr_stmt|;
if|if
condition|(
name|namestring
index|[
name|nsl
operator|-
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|namestring
index|[
name|nsl
operator|-
literal|1
index|]
operator|==
literal|'o'
condition|)
name|namestring
index|[
name|nsl
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|namestring
argument_list|,
literal|"gcc_compiled."
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|namestring
operator|==
literal|'_'
condition|)
operator|++
name|namestring
expr_stmt|;
name|namestring
operator|=
name|obconcat
argument_list|(
name|last_o_file_name
argument_list|,
literal|":"
argument_list|,
name|namestring
argument_list|)
expr_stmt|;
name|last_global_sym
operator|=
name|symnum
expr_stmt|;
if|if
condition|(
operator|!
name|first_global_sym
condition|)
name|first_global_sym
operator|=
name|symnum
expr_stmt|;
name|record_misc_function
argument_list|(
name|namestring
argument_list|,
name|bufp
operator|->
name|n_value
argument_list|,
name|bufp
operator|->
name|n_type
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|N_ABS
case|:
case|case
name|N_DATA
case|:
case|case
name|N_BSS
case|:
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|namestring
operator|==
literal|'_'
condition|)
operator|++
name|namestring
expr_stmt|;
name|namestring
operator|=
name|obconcat
argument_list|(
name|last_o_file_name
argument_list|,
literal|":"
argument_list|,
name|namestring
argument_list|)
expr_stmt|;
name|last_global_sym
operator|=
name|symnum
expr_stmt|;
if|if
condition|(
operator|!
name|first_global_sym
condition|)
name|first_global_sym
operator|=
name|symnum
expr_stmt|;
name|record_misc_function
argument_list|(
name|namestring
argument_list|,
name|bufp
operator|->
name|n_value
argument_list|,
name|bufp
operator|->
name|n_type
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|N_UNDF
case|:
case|case
name|N_UNDF
operator||
name|N_EXT
case|:
ifdef|#
directive|ifdef
name|N_NBDATA
case|case
name|N_NBDATA
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|N_NBBSS
case|case
name|N_NBBSS
case|:
endif|#
directive|endif
comment|/* Keep going . . .*/
comment|/* 	   * Special symbol types for GNU 	   */
ifdef|#
directive|ifdef
name|N_INDR
case|case
name|N_INDR
case|:
case|case
name|N_INDR
operator||
name|N_EXT
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|N_SETA
case|case
name|N_SETA
case|:
case|case
name|N_SETA
operator||
name|N_EXT
case|:
case|case
name|N_SETT
case|:
case|case
name|N_SETT
operator||
name|N_EXT
case|:
case|case
name|N_SETD
case|:
case|case
name|N_SETD
operator||
name|N_EXT
case|:
case|case
name|N_SETB
case|:
case|case
name|N_SETB
operator||
name|N_EXT
case|:
case|case
name|N_SETV
case|:
endif|#
directive|endif
continue|continue;
comment|/* 	   * Debugger symbols 	   */
case|case
name|N_SO
case|:
comment|/* End the current partial symtab and start a new one */
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
if|if
condition|(
name|pst
operator|&&
name|past_first_source_file
condition|)
block|{
name|end_psymtab
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
name|symnum
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
name|bufp
operator|->
name|n_value
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|,
name|global_psymbols
operator|.
name|next
argument_list|,
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|past_first_source_file
operator|=
literal|1
expr_stmt|;
name|pst
operator|=
name|start_psymtab
argument_list|(
name|namestring
argument_list|,
name|bufp
operator|->
name|n_value
argument_list|,
name|symnum
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
name|global_psymbols
operator|.
name|next
argument_list|,
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
continue|continue;
ifdef|#
directive|ifdef
name|N_BINCL
case|case
name|N_BINCL
case|:
comment|/* Add this bincl to the bincl_list for future EXCLs.  No 	     need to save the string; it'll be around until 	     read_dbx_symtab function return */
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
name|add_bincl_to_list
argument_list|(
name|pst
argument_list|,
name|namestring
argument_list|,
name|bufp
operator|->
name|n_value
argument_list|)
expr_stmt|;
comment|/* Mark down an include file in the current psymtab */
name|psymtab_include_list
index|[
name|includes_used
operator|++
index|]
operator|=
name|namestring
expr_stmt|;
if|if
condition|(
name|includes_used
operator|>=
name|includes_allocated
condition|)
block|{
name|char
modifier|*
modifier|*
name|orig
init|=
name|psymtab_include_list
decl_stmt|;
name|psymtab_include_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|includes_allocated
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|orig
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
endif|#
directive|endif
case|case
name|N_SOL
case|:
comment|/* Mark down an include file in the current psymtab */
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
comment|/* In C++, one may expect the same filename to come round many 	     times, when code is coming alternately from the main file 	     and from inline functions in other files. So I check to see 	     if this is a file we've seen before.  	     This seems to be a lot of time to be spending on N_SOL, but 	     things like "break expread.y:435" need to work (I 	     suppose the psymtab_include_list could be hashed or put 	     in a binary tree, if profiling shows this is a major hog).  */
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|includes_used
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|namestring
argument_list|,
name|psymtab_include_list
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|i
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
continue|continue;
block|}
name|psymtab_include_list
index|[
name|includes_used
operator|++
index|]
operator|=
name|namestring
expr_stmt|;
if|if
condition|(
name|includes_used
operator|>=
name|includes_allocated
condition|)
block|{
name|char
modifier|*
modifier|*
name|orig
init|=
name|psymtab_include_list
decl_stmt|;
name|psymtab_include_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|includes_allocated
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|orig
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|N_LSYM
case|:
comment|/* Typedef or automatic variable. */
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|namestring
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
comment|/* Skip if there is no :.  */
if|if
condition|(
operator|!
name|p
condition|)
continue|continue;
switch|switch
condition|(
name|p
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'T'
case|:
name|ADD_PSYMBOL_TO_LIST
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
name|LOC_TYPEDEF
argument_list|,
name|static_psymbols
argument_list|,
name|bufp
operator|->
name|n_value
argument_list|)
expr_stmt|;
goto|goto
name|check_enum
goto|;
case|case
literal|'t'
case|:
name|ADD_PSYMBOL_TO_LIST
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_TYPEDEF
argument_list|,
name|static_psymbols
argument_list|,
name|bufp
operator|->
name|n_value
argument_list|)
expr_stmt|;
name|check_enum
label|:
comment|/* If this is an enumerated type, we need to 		 add all the enum constants to the partial symbol 		 table.  This does not cover enums without names, e.g. 		 "enum {a, b} c;" in C, but fortunately those are 		 rare.  There is no way for GDB to find those from the 		 enum type without spending too much time on it.  Thus 		 to solve this problem, the compiler needs to put out separate 		 constant symbols ('c' N_LSYMS) for enum constants in 		 enums without names.  */
comment|/* We are looking for something of the form<name> ":" ("t" | "T") [<number> "="] "e" 		 {<constant> ":"<value> ","} ";".  */
comment|/* Skip over the colon and the 't' or 'T'.  */
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* This type may be given a number.  Skip over it.  */
while|while
condition|(
operator|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
operator|)
operator|||
operator|*
name|p
operator|==
literal|'='
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'e'
condition|)
block|{
comment|/* We have found an enumerated type.  */
comment|/* According to comments in read_enum_type 		     a comma could end it instead of a semicolon. 		     I don't know where that happens. 		     Accept either.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|';'
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
comment|/* Check for and handle cretinous dbx symbol name 			 continuation!  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
name|p
operator|=
name|next_symbol_text
argument_list|()
expr_stmt|;
comment|/* Point to the character after the name 			 of the enum constant.  */
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|&&
operator|*
name|q
operator|!=
literal|':'
condition|;
name|q
operator|++
control|)
empty_stmt|;
comment|/* Note that the value doesn't matter for 			 enum constants in psymtabs, just in symtabs.  */
name|ADD_PSYMBOL_TO_LIST
argument_list|(
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_CONST
argument_list|,
name|static_psymbols
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Point past the name.  */
name|p
operator|=
name|q
expr_stmt|;
comment|/* Skip over the value.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Advance past the comma.  */
if|if
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
continue|continue;
case|case
literal|'c'
case|:
comment|/* Constant, e.g. from "const" in Pascal.  */
name|ADD_PSYMBOL_TO_LIST
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_CONST
argument_list|,
name|static_psymbols
argument_list|,
name|bufp
operator|->
name|n_value
argument_list|)
expr_stmt|;
continue|continue;
default|default:
ifdef|#
directive|ifdef
name|PROFILE_TYPES
if|if
condition|(
name|isalpha
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Funny...LSYM with a letter that isn't a type\n"
argument_list|)
expr_stmt|;
name|autovars
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* Skip if the thing following the : is 	         not a letter (which indicates declaration of a local 	         variable, which we aren't interested in).  */
continue|continue;
block|}
case|case
name|N_FUN
case|:
if|#
directive|if
literal|0
comment|/* This special-casing of N_FUN is just wrong; N_FUN 	     does not mean "function"; it means "text segment". 	     So N_FUN can go with 'V', etc. as well as 'f' or 'F'.  */
block|SET_NAMESTRING();  	  p = (char *) index (namestring, ':');  	  if (!p || p[1] == 'F') continue;
ifdef|#
directive|ifdef
name|PROFILE_TYPES
block|if (p[1] != 'f') 	    printf ("Funny...FUN with a letter that isn't 'F' or 'f'.\n"); 	  global_funs++;
endif|#
directive|endif
block|ADD_PSYMBOL_TO_LIST (namestring, p - namestring, 			       VAR_NAMESPACE, LOC_BLOCK, 			       static_psymbols, bufp->n_value);  	  continue;
endif|#
directive|endif
comment|/* 0 */
case|case
name|N_GSYM
case|:
comment|/* Global (extern) variable; can be 				   data or bss (sigh).  */
case|case
name|N_STSYM
case|:
comment|/* Data seg var -- static  */
case|case
name|N_LCSYM
case|:
comment|/* BSS      "  */
comment|/* Following may probably be ignored; I'll leave them here 	   for now (until I do Pascal and Modula 2 extensions).  */
case|case
name|N_PC
case|:
comment|/* I may or may not need this; I 				   suspect not.  */
ifdef|#
directive|ifdef
name|N_M2C
case|case
name|N_M2C
case|:
comment|/* I suspect that I can ignore this here. */
case|case
name|N_SCOPE
case|:
comment|/* Same.   */
endif|#
directive|endif
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|namestring
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
continue|continue;
comment|/* Not a debugging symbol.   */
name|process_symbol_for_psymtab
label|:
comment|/* Main processing section for debugging symbols which 	     the initial read through the symbol tables needs to worry 	     about.  If we reach this point, the symbol which we are 	     considering is definitely one we are interested in. 	     p must also contain the (valid) index into the namestring 	     which indicates the debugging type symbol.  */
switch|switch
condition|(
name|p
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'c'
case|:
name|ADD_PSYMBOL_TO_LIST
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_CONST
argument_list|,
name|static_psymbols
argument_list|,
name|bufp
operator|->
name|n_value
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'S'
case|:
name|ADD_PSYMBOL_TO_LIST
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_STATIC
argument_list|,
name|static_psymbols
argument_list|,
name|bufp
operator|->
name|n_value
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'G'
case|:
name|ADD_PSYMBOL_TO_LIST
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_EXTERNAL
argument_list|,
name|global_psymbols
argument_list|,
name|bufp
operator|->
name|n_value
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'t'
case|:
name|ADD_PSYMBOL_TO_LIST
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_TYPEDEF
argument_list|,
name|global_psymbols
argument_list|,
name|bufp
operator|->
name|n_value
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'f'
case|:
name|ADD_PSYMBOL_TO_LIST
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|,
name|static_psymbols
argument_list|,
name|bufp
operator|->
name|n_value
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Two things show up here (hopefully); static symbols of 		 local scope (static used inside braces) or extensions 		 of structure symbols.  We can ignore both.  */
case|case
literal|'V'
case|:
case|case
literal|'('
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* Global functions are ignored here.  I'm not 		 sure what psymtab they go into (or just the misc 		 function vector).  */
case|case
literal|'F'
case|:
continue|continue;
default|default:
name|fatal
argument_list|(
literal|"Internal error: Unexpected debugging symbol type '%c' at symnum %d.\n"
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|N_BINCL
case|case
name|N_EXCL
case|:
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
comment|/* Find the corresponding bincl and mark that psymtab on the 	     psymtab dependency list */
block|{
name|struct
name|partial_symtab
modifier|*
name|needed_pst
init|=
name|find_corresponding_bincl_psymtab
argument_list|(
name|namestring
argument_list|,
name|bufp
operator|->
name|n_value
argument_list|)
decl_stmt|;
comment|/* If this include file was defined earlier in this file, 	       leave it alone.  */
if|if
condition|(
name|needed_pst
operator|==
name|pst
condition|)
continue|continue;
if|if
condition|(
name|needed_pst
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dependencies_used
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dependency_list
index|[
name|i
index|]
operator|==
name|needed_pst
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* If it's already in the list, skip the rest.  */
if|if
condition|(
name|found
condition|)
continue|continue;
name|dependency_list
index|[
name|dependencies_used
operator|++
index|]
operator|=
name|needed_pst
expr_stmt|;
if|if
condition|(
name|dependencies_used
operator|>=
name|dependencies_allocated
condition|)
block|{
name|struct
name|partial_symtab
modifier|*
modifier|*
name|orig
init|=
name|dependency_list
decl_stmt|;
name|dependency_list
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|dependencies_allocated
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|orig
argument_list|,
name|dependency_list
argument_list|,
operator|(
name|dependencies_used
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_INFO
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Had to reallocate dependency list.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"New dependencies allocated: %d\n"
argument_list|,
name|dependencies_allocated
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
name|error
argument_list|(
literal|"Invalid symbol data: \"repeated\" header file not previously seen, at symtab pos %d."
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|N_EINCL
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|N_DSLINE
case|case
name|N_DSLINE
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|N_BSLINE
case|case
name|N_BSLINE
case|:
endif|#
directive|endif
case|case
name|N_SSYM
case|:
comment|/* Claim: Structure or union element. 				   Hopefully, I can ignore this.  */
case|case
name|N_ENTRY
case|:
comment|/* Alternate entry point; can ignore. */
ifdef|#
directive|ifdef
name|N_MAIN
case|case
name|N_MAIN
case|:
comment|/* Can definitely ignore this.   */
endif|#
directive|endif
case|case
name|N_LENG
case|:
case|case
name|N_BCOMM
case|:
case|case
name|N_ECOMM
case|:
case|case
name|N_ECOML
case|:
case|case
name|N_FNAME
case|:
case|case
name|N_SLINE
case|:
case|case
name|N_RSYM
case|:
case|case
name|N_PSYM
case|:
case|case
name|N_LBRAC
case|:
case|case
name|N_RBRAC
case|:
comment|/* These symbols aren't interesting; don't worry about them */
continue|continue;
default|default:
comment|/* If we haven't found it yet, we've got problems */
if|if
condition|(
name|IGNORE_SYMBOL
argument_list|(
name|bufp
operator|->
name|n_type
argument_list|)
condition|)
continue|continue;
name|fatal
argument_list|(
literal|"Bad symbol type 0x%x encountered in gdb scan"
argument_list|,
name|bufp
operator|->
name|n_type
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If there's stuff to be cleaned up, clean it up.  */
if|if
condition|(
name|entry_point
operator|<
name|bufp
operator|->
name|n_value
operator|&&
name|entry_point
operator|>=
name|last_o_file_start
condition|)
block|{
name|startup_file_start
operator|=
name|last_o_file_start
expr_stmt|;
name|startup_file_end
operator|=
name|bufp
operator|->
name|n_value
expr_stmt|;
block|}
if|if
condition|(
name|pst
condition|)
block|{
name|end_psymtab
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
name|symnum
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
name|end_of_text_addr
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|,
name|global_psymbols
operator|.
name|next
argument_list|,
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* sort the global& static symtab list so we can binary search them */
name|qsort
argument_list|(
name|global_psymbols
operator|.
name|list
argument_list|,
name|global_psymbols
operator|.
name|next
operator|-
name|global_psymbols
operator|.
name|list
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
argument_list|)
argument_list|,
name|compare_psymbols
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|static_psymbols
operator|.
name|list
argument_list|,
name|static_psymbols
operator|.
name|next
operator|-
name|static_psymbols
operator|.
name|list
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symbol
argument_list|)
argument_list|,
name|compare_psymbols
argument_list|)
expr_stmt|;
name|free_bincl_list
argument_list|()
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROFILE_TYPES
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
define|#
directive|define
name|__define_stab
parameter_list|(
name|SYM
parameter_list|,
name|NUMBER
parameter_list|,
name|NAME
parameter_list|)
value|{NUMBER, NAME},
specifier|static
struct|struct
name|xyzzy
block|{
name|unsigned
name|char
name|symnum
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|tmp_list
index|[]
init|=
block|{
include|#
directive|include
file|"stab.def"
block|{
literal|0x1
block|,
literal|"eREF"
block|}
block|,
block|{
literal|0x2
block|,
literal|"ABS"
block|}
block|,
block|{
literal|0x3
block|,
literal|"eABS"
block|}
block|,
block|{
literal|0x4
block|,
literal|"TEXT"
block|}
block|,
block|{
literal|0x5
block|,
literal|"eTEXT"
block|}
block|,
block|{
literal|0x6
block|,
literal|"DATA"
block|}
block|,
block|{
literal|0x7
block|,
literal|"eDATA"
block|}
block|,
block|{
literal|0x8
block|,
literal|"BSS"
block|}
block|,
block|{
literal|0x9
block|,
literal|"eBSS"
block|}
block|,
block|{
literal|0x12
block|,
literal|"COMM"
block|}
block|,
block|{
literal|0x13
block|,
literal|"eCOMM"
block|}
block|,
block|{
literal|0x1f
block|,
literal|"FN"
block|}
block|,
block|{
literal|0
block|,
literal|"Unknown"
block|}
block|, }
struct|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|tmp_list
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|xyzzy
argument_list|)
operator|)
operator|-
literal|1
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|tmp_list
index|[
name|j
index|]
operator|.
name|symnum
operator|==
name|i
condition|)
break|break;
name|printf
argument_list|(
literal|"Symbol \"%s\" (0x%x) occured %d times.\n"
argument_list|,
name|tmp_list
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|i
argument_list|,
name|profile_types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Auto vars (under LSYM): %d\n"
argument_list|,
name|autovars
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Global funs (under FUN): %d\n"
argument_list|,
name|global_funs
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Allocate and partially fill a partial symtab.  It will be  * completely filled at the end of the symbol list.  */
end_comment

begin_function
specifier|static
name|struct
name|partial_symtab
modifier|*
name|start_psymtab
parameter_list|(
name|filename
parameter_list|,
name|textlow
parameter_list|,
name|ldsymoff
parameter_list|,
name|global_syms
parameter_list|,
name|static_syms
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|textlow
decl_stmt|;
name|int
name|ldsymoff
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
name|global_syms
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
name|static_syms
decl_stmt|;
block|{
name|struct
name|partial_symtab
modifier|*
name|result
init|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|->
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|psymbol_obstack
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|->
name|filename
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|result
operator|->
name|textlow
operator|=
name|textlow
expr_stmt|;
name|result
operator|->
name|ldsymoff
operator|=
name|ldsymoff
expr_stmt|;
name|result
operator|->
name|readin
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|globals_offset
operator|=
name|global_syms
operator|-
name|global_psymbols
operator|.
name|list
expr_stmt|;
name|result
operator|->
name|statics_offset
operator|=
name|static_syms
operator|-
name|static_psymbols
operator|.
name|list
expr_stmt|;
name|result
operator|->
name|n_global_syms
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|n_static_syms
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Close off the current usage of a partial_symbol table entry.  This    involves setting the correct number of includes (with a realloc),    setting the high text mark, setting the symbol length in the    executable, and setting the length of the global and static lists    of psymbols.     The global symbols and static symbols are then seperately sorted.     Then the partial symtab is put on the global list.    *** List variables and peculiarities of same. ***    */
end_comment

begin_function
specifier|static
name|void
name|end_psymtab
parameter_list|(
name|pst
parameter_list|,
name|include_list
parameter_list|,
name|num_includes
parameter_list|,
name|capping_symbol_offset
parameter_list|,
name|capping_text
parameter_list|,
name|dependency_list
parameter_list|,
name|number_dependencies
parameter_list|,
name|capping_global
parameter_list|,
name|capping_static
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|char
modifier|*
modifier|*
name|include_list
decl_stmt|;
name|int
name|num_includes
decl_stmt|;
name|int
name|capping_symbol_offset
decl_stmt|;
name|int
name|capping_text
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
modifier|*
name|dependency_list
decl_stmt|;
name|int
name|number_dependencies
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
name|capping_global
decl_stmt|,
decl|*
name|capping_static
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|partial_symbol
modifier|*
name|ps
decl_stmt|;
name|pst
operator|->
name|ldsymlen
operator|=
name|capping_symbol_offset
operator|-
name|pst
operator|->
name|ldsymoff
expr_stmt|;
name|pst
operator|->
name|texthigh
operator|=
name|capping_text
expr_stmt|;
name|pst
operator|->
name|n_global_syms
operator|=
name|capping_global
operator|-
operator|(
name|global_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|globals_offset
operator|)
expr_stmt|;
name|pst
operator|->
name|n_static_syms
operator|=
name|capping_static
operator|-
operator|(
name|static_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|statics_offset
operator|)
expr_stmt|;
name|pst
operator|->
name|dependencies
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|psymbol_obstack
argument_list|,
name|number_dependencies
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dependency_list
argument_list|,
name|pst
operator|->
name|dependencies
argument_list|,
name|number_dependencies
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pst
operator|->
name|number_of_dependencies
operator|=
name|number_dependencies
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_includes
condition|;
name|i
operator|++
control|)
block|{
comment|/* Eventually, put this on obstack */
name|struct
name|partial_symtab
modifier|*
name|subpst
init|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
argument_list|)
argument_list|)
decl_stmt|;
name|subpst
operator|->
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|psymbol_obstack
argument_list|,
name|strlen
argument_list|(
name|include_list
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|subpst
operator|->
name|filename
argument_list|,
name|include_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|subpst
operator|->
name|ldsymoff
operator|=
name|subpst
operator|->
name|ldsymlen
operator|=
name|subpst
operator|->
name|textlow
operator|=
name|subpst
operator|->
name|texthigh
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|readin
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|dependencies
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|subpst
operator|->
name|dependencies
index|[
literal|0
index|]
operator|=
name|pst
expr_stmt|;
name|subpst
operator|->
name|number_of_dependencies
operator|=
literal|1
expr_stmt|;
name|subpst
operator|->
name|globals_offset
operator|=
name|subpst
operator|->
name|n_global_syms
operator|=
name|subpst
operator|->
name|statics_offset
operator|=
name|subpst
operator|->
name|n_static_syms
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|next
operator|=
name|partial_symtab_list
expr_stmt|;
name|partial_symtab_list
operator|=
name|subpst
expr_stmt|;
block|}
for|for
control|(
name|ps
operator|=
name|global_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|globals_offset
init|;
name|ps
operator|<
name|capping_global
condition|;
operator|++
name|ps
control|)
name|ps
operator|->
name|pst
operator|=
name|pst
expr_stmt|;
for|for
control|(
name|ps
operator|=
name|static_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|statics_offset
init|;
name|ps
operator|<
name|capping_static
condition|;
operator|++
name|ps
control|)
name|ps
operator|->
name|pst
operator|=
name|pst
expr_stmt|;
comment|/* Put the psymtab on the psymtab list */
name|pst
operator|->
name|next
operator|=
name|partial_symtab_list
expr_stmt|;
name|partial_symtab_list
operator|=
name|pst
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Helper routines for psymtab_to_symtab.  */
end_comment

begin_function_decl
specifier|static
name|void
name|scan_file_globals
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_ofile_symtab
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|psymtab_to_symtab_1
parameter_list|(
name|pst
parameter_list|,
name|desc
parameter_list|,
name|stringtab
parameter_list|,
name|stringtab_size
parameter_list|,
name|sym_offset
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|int
name|desc
decl_stmt|;
name|char
modifier|*
name|stringtab
decl_stmt|;
name|int
name|stringtab_size
decl_stmt|;
name|int
name|sym_offset
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|pst
condition|)
return|return;
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Psymtab for %s already read in.  Shouldn't happen.\n"
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Read in all partial symbtabs on which this one is dependent */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pst
operator|->
name|number_of_dependencies
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|readin
condition|)
block|{
comment|/* Inform about additional files that need to be read in.  */
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|" and %s..."
argument_list|,
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|psymtab_to_symtab_1
argument_list|(
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
argument_list|,
name|desc
argument_list|,
name|stringtab
argument_list|,
name|stringtab_size
argument_list|,
name|sym_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pst
operator|->
name|ldsymlen
condition|)
comment|/* Otherwise it's a dummy */
block|{
comment|/* Init stuff necessary for reading in symbols */
name|free_pendings
operator|=
literal|0
expr_stmt|;
name|pending_blocks
operator|=
literal|0
expr_stmt|;
name|file_symbols
operator|=
literal|0
expr_stmt|;
name|global_symbols
operator|=
literal|0
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|really_free_pendings
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Read in this files symbols */
name|lseek
argument_list|(
name|desc
argument_list|,
name|sym_offset
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
name|read_ofile_symtab
argument_list|(
name|desc
argument_list|,
name|stringtab
argument_list|,
name|stringtab_size
argument_list|,
name|pst
operator|->
name|ldsymoff
argument_list|,
name|pst
operator|->
name|ldsymlen
argument_list|,
name|pst
operator|->
name|textlow
argument_list|,
name|pst
operator|->
name|texthigh
operator|-
name|pst
operator|->
name|textlow
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sort_symtab_syms
argument_list|(
name|symtab_list
argument_list|)
expr_stmt|;
comment|/* At beginning since just added */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
name|pst
operator|->
name|readin
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read in all of the symbols for a given psymtab for real.  Return  * the value of the symtab you create.  Do not free the storage  * allocated to the psymtab; it may have pointers to it.  */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|psymtab_to_symtab
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
name|int
name|desc
decl_stmt|;
name|DECLARE_FILE_HEADERS
expr_stmt|;
name|char
modifier|*
name|stringtab
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
modifier|*
name|list_patch
decl_stmt|;
name|int
name|stsize
decl_stmt|,
name|val
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
specifier|extern
name|void
name|close
parameter_list|()
function_decl|;
name|int
name|i
decl_stmt|;
name|struct
name|symtab
modifier|*
name|result
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|symfile
decl_stmt|;
comment|/* Some of the macros require the */
comment|/* variable "name" to be defined in */
comment|/* the context in which they execute */
comment|/* (Yech!)  */
if|if
condition|(
operator|!
name|pst
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Psymtab for %s already read in.  Shouldn't happen.\n"
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|name
condition|)
name|error
argument_list|(
literal|"No symbol file currently specified; use command symbol-file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pst
operator|->
name|ldsymlen
operator|||
name|pst
operator|->
name|number_of_dependencies
condition|)
block|{
comment|/* Print the message now, before reading the string table, 	 to avoid disconcerting pauses.  */
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Reading in symbols for %s..."
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* Open symbol file and read in string table */
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|desc
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* symbol_file_command 					 guarrantees that the symbol file name 					 will be absolute, so there is no 					 need for openp */
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|close
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Symbol file not readable"
argument_list|)
expr_stmt|;
name|READ_FILE_HEADERS
argument_list|(
name|desc
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Read in the string table */
block|lseek (desc, STRING_TABLE_OFFSET, L_SET);       READ_STRING_TABLE_SIZE (stsize);       if (stsize>= 0&& stsize< statbuf.st_size) 	{
ifdef|#
directive|ifdef
name|BROKEN_LARGE_ALLOCA
block|stringtab = (char *) xmalloc (stsize); 	  make_cleanup (free, stringtab);
else|#
directive|else
block|stringtab = (char *) alloca (stsize);
endif|#
directive|endif
block|}       else 	stringtab = NULL;       if (stringtab == NULL) 	error ("ridiculous string table size: %d bytes", stsize);
comment|/* Usually READ_STRING_TABLE_SIZE will have shifted the file pointer. 	 Occaisionally, it won't.  */
block|val = lseek (desc, STRING_TABLE_OFFSET, L_SET);       if (val< 0) 	perror_with_name (name);       val = myread (desc, stringtab, stsize);       if (val< 0) 	perror_with_name (name);
endif|#
directive|endif
comment|/* 0 */
name|stringtab
operator|=
name|symfile_string_table
expr_stmt|;
name|stsize
operator|=
name|symfile_string_table_size
expr_stmt|;
name|psymtab_to_symtab_1
argument_list|(
name|pst
argument_list|,
name|desc
argument_list|,
name|stringtab
argument_list|,
name|stsize
argument_list|,
name|SYMBOL_TABLE_OFFSET
argument_list|)
expr_stmt|;
comment|/* Match with global symbols.  This  only needs to be done once,          after all of the symtabs and dependencies have been read in.   */
name|scan_file_globals
argument_list|()
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
comment|/* Finish up the debug error message.  */
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Search through list for correct name. */
for|for
control|(
name|result
operator|=
name|symtab_list
init|;
name|result
condition|;
name|result
operator|=
name|result
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|result
operator|->
name|filename
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
condition|)
return|return
name|result
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Scan through all of the global symbols defined in the object file,  * assigning values to the debugging symbols that need to be assigned  * to.  Get these symbols from the misc function list.  */
end_comment

begin_function
specifier|static
name|void
name|scan_file_globals
parameter_list|()
block|{
name|int
name|hash
decl_stmt|;
name|int
name|mf
decl_stmt|;
for|for
control|(
name|mf
operator|=
literal|0
init|;
name|mf
operator|<
name|misc_function_count
condition|;
name|mf
operator|++
control|)
block|{
name|char
modifier|*
name|namestring
init|=
name|misc_function_vector
index|[
name|mf
index|]
operator|.
name|name
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|QUIT
expr_stmt|;
name|prev
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Get the hash index and check all the symbols 	 under that hash index. */
name|hash
operator|=
name|hashname
argument_list|(
name|namestring
argument_list|)
expr_stmt|;
for|for
control|(
name|sym
operator|=
name|global_sym_chain
index|[
name|hash
index|]
init|;
name|sym
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|namestring
operator|==
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
index|[
literal|0
index|]
operator|&&
operator|!
name|strcmp
argument_list|(
name|namestring
operator|+
literal|1
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|+
literal|1
argument_list|)
condition|)
block|{
comment|/* Splice this symbol out of the hash chain and 		 assign the value we have to it. */
if|if
condition|(
name|prev
condition|)
name|SYMBOL_VALUE
argument_list|(
name|prev
argument_list|)
operator|=
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
else|else
name|global_sym_chain
index|[
name|hash
index|]
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
comment|/* Check to see whether we need to fix up a common block.  */
comment|/* Note: this code might be executed several times for 		 the same symbol if there are multiple references.  */
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_BLOCK
condition|)
name|fix_common_block
argument_list|(
name|sym
argument_list|,
name|misc_function_vector
index|[
name|mf
index|]
operator|.
name|address
argument_list|)
expr_stmt|;
else|else
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|misc_function_vector
index|[
name|mf
index|]
operator|.
name|address
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|SYMBOL_VALUE
argument_list|(
name|prev
argument_list|)
expr_stmt|;
else|else
name|sym
operator|=
name|global_sym_chain
index|[
name|hash
index|]
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|sym
expr_stmt|;
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Read in a defined section of a specific object file's symbols.  *  * DESC is the file descriptor for the file, positioned at the  * beginning of the symtab  * STRINGTAB is a pointer to the files string  * table, already read in  * SYM_OFFSET is the offset within the file of  * the beginning of the symbols we want to read, NUM_SUMBOLS is the  * number of symbols to read  * TEXT_OFFSET is the offset to be added to  * all values of symbols coming in and  * TEXT_SIZE is the size of the text segment read in.  * OFFSET is a flag which indicates that the value of all of the  * symbols should be offset by TEXT_OFFSET (for the purposes of  * incremental linking).  */
end_comment

begin_function
specifier|static
name|void
name|read_ofile_symtab
parameter_list|(
name|desc
parameter_list|,
name|stringtab
parameter_list|,
name|stringtab_size
parameter_list|,
name|sym_offset
parameter_list|,
name|sym_size
parameter_list|,
name|text_offset
parameter_list|,
name|text_size
parameter_list|,
name|offset
parameter_list|)
name|int
name|desc
decl_stmt|;
specifier|register
name|char
modifier|*
name|stringtab
decl_stmt|;
name|int
name|sym_offset
decl_stmt|;
name|int
name|sym_size
decl_stmt|;
name|int
name|text_offset
decl_stmt|;
name|int
name|text_size
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|namestring
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|nlist
modifier|*
name|bufp
decl_stmt|;
name|unsigned
name|char
name|type
decl_stmt|;
ifdef|#
directive|ifdef
name|N_BINCL
name|subfile_stack
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|stringtab_global
operator|=
name|stringtab
expr_stmt|;
name|last_source_file
operator|=
literal|0
expr_stmt|;
name|symtab_input_desc
operator|=
name|desc
expr_stmt|;
name|symbuf_end
operator|=
name|symbuf_idx
operator|=
literal|0
expr_stmt|;
comment|/* It is necessary to actually read one symbol *before* the start      of this symtab's symbols, because the GCC_COMPILED_FLAG_SYMBOL      occurs before the N_SO symbol.       Detecting this in read_dbx_symtab      would slow down initial readin, so we look for it here instead.  */
if|if
condition|(
name|sym_offset
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
condition|)
block|{
name|lseek
argument_list|(
name|desc
argument_list|,
name|sym_offset
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
name|L_INCR
argument_list|)
expr_stmt|;
name|fill_symbuf
argument_list|()
expr_stmt|;
name|bufp
operator|=
operator|&
name|symbuf
index|[
name|symbuf_idx
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|bufp
operator|->
name|n_un
operator|.
name|n_strx
operator|<
literal|0
operator|||
name|bufp
operator|->
name|n_un
operator|.
name|n_strx
operator|>=
name|stringtab_size
condition|)
name|error
argument_list|(
literal|"Invalid symbol data: bad string table offset: %d"
argument_list|,
name|bufp
operator|->
name|n_un
operator|.
name|n_strx
argument_list|)
expr_stmt|;
name|namestring
operator|=
name|bufp
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
name|processing_gcc_compilation
operator|=
operator|(
name|bufp
operator|->
name|n_type
operator|==
name|N_TEXT
operator|&&
operator|!
name|strcmp
argument_list|(
name|namestring
argument_list|,
name|GCC_COMPILED_FLAG_SYMBOL
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The N_SO starting this symtab is the first symbol, so we 	 better not check the symbol before it.  I'm not this can 	 happen, but it doesn't hurt to check for it.  */
name|lseek
argument_list|(
name|desc
argument_list|,
name|sym_offset
argument_list|,
name|L_INCR
argument_list|)
expr_stmt|;
name|processing_gcc_compilation
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|symbuf_idx
operator|==
name|symbuf_end
condition|)
name|fill_symbuf
argument_list|()
expr_stmt|;
name|bufp
operator|=
operator|&
name|symbuf
index|[
name|symbuf_idx
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
name|bufp
operator|->
name|n_type
operator|!=
name|N_SO
condition|)
name|fatal
argument_list|(
literal|"First symbol in segment of executable not a source symbol"
argument_list|)
expr_stmt|;
for|for
control|(
name|symnum
operator|=
literal|0
init|;
name|symnum
operator|<
name|sym_size
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
condition|;
name|symnum
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* Allow this to be interruptable */
if|if
condition|(
name|symbuf_idx
operator|==
name|symbuf_end
condition|)
name|fill_symbuf
argument_list|()
expr_stmt|;
name|bufp
operator|=
operator|&
name|symbuf
index|[
name|symbuf_idx
operator|++
index|]
expr_stmt|;
name|type
operator|=
name|bufp
operator|->
name|n_type
expr_stmt|;
if|if
condition|(
name|offset
operator|&&
operator|(
name|type
operator|==
name|N_TEXT
operator|||
name|type
operator|==
name|N_DATA
operator|||
name|type
operator|==
name|N_BSS
operator|)
condition|)
name|bufp
operator|->
name|n_value
operator|+=
name|text_offset
expr_stmt|;
if|if
condition|(
name|bufp
operator|->
name|n_un
operator|.
name|n_strx
operator|<
literal|0
operator|||
name|bufp
operator|->
name|n_un
operator|.
name|n_strx
operator|>=
name|stringtab_size
condition|)
name|error
argument_list|(
literal|"Invalid symbol data: bad string table offset: %d"
argument_list|,
name|bufp
operator|->
name|n_un
operator|.
name|n_strx
argument_list|)
expr_stmt|;
name|namestring
operator|=
name|bufp
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|N_STAB
condition|)
name|process_one_symbol
argument_list|(
name|type
argument_list|,
name|bufp
operator|->
name|n_desc
argument_list|,
name|bufp
operator|->
name|n_value
argument_list|,
name|namestring
argument_list|)
expr_stmt|;
comment|/* We skip checking for a new .o or -l file; that should never          happen in this routine. */
elseif|else
if|if
condition|(
name|type
operator|==
name|N_TEXT
operator|&&
operator|!
name|strcmp
argument_list|(
name|namestring
argument_list|,
name|GCC_COMPILED_FLAG_SYMBOL
argument_list|)
condition|)
comment|/* I don't think this code will ever be executed, because 	   the GCC_COMPILED_FLAG_SYMBOL usually is right before 	   the N_SO symbol which starts this source file. 	   However, there is no reason not to accept 	   the GCC_COMPILED_FLAG_SYMBOL anywhere.  */
name|processing_gcc_compilation
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|&
name|N_EXT
operator|||
name|type
operator|==
name|N_TEXT
ifdef|#
directive|ifdef
name|N_NBTEXT
operator|||
name|type
operator|==
name|N_NBTEXT
endif|#
directive|endif
condition|)
comment|/* Global symbol: see if we came across a dbx defintion for 	     a corresponding symbol.  If so, store the value.  Remove 	     syms from the chain when their values are stored, but 	     search the whole chain, as there may be several syms from 	     different files with the same name. */
comment|/* This is probably not true.  Since the files will be read 	     in one at a time, each reference to a global symbol will 	     be satisfied in each file as it appears. So we skip this 	     section. */
operator|&
name|stringtab_global
expr_stmt|;
comment|/* For debugger; am I right? */
block|}
name|end_symtab
argument_list|(
name|text_offset
operator|+
name|text_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|hashname
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|name
decl_stmt|;
specifier|register
name|int
name|total
init|=
name|p
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|total
operator|+=
name|c
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
name|c
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
name|total
operator|+=
name|c
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
name|c
condition|)
name|total
operator|+=
name|p
index|[
literal|3
index|]
operator|<<
literal|6
expr_stmt|;
block|}
comment|/* Ensure result is positive.  */
if|if
condition|(
name|total
operator|<
literal|0
condition|)
name|total
operator|+=
operator|(
literal|1000
operator|<<
literal|6
operator|)
expr_stmt|;
return|return
name|total
operator|%
name|HASHSIZE
return|;
block|}
end_function

begin_comment
comment|/* Put all appropriate global symbols in the symseg data    onto the hash chains so that their addresses will be stored    when seen later in loader global symbols.  */
end_comment

begin_function
specifier|static
name|void
name|hash_symsegs
parameter_list|()
block|{
comment|/* Look at each symbol in each block in each symseg symtab.  */
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|symseg_chain
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|)
operator|-
literal|1
init|;
name|n
operator|>=
literal|0
condition|;
name|n
operator|--
control|)
block|{
specifier|register
name|struct
name|block
modifier|*
name|b
init|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|n
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
init|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* Put the symbol on a chain if its value is an address 		 that is figured out by the loader.  */
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_EXTERNAL
condition|)
block|{
specifier|register
name|int
name|hash
init|=
name|hashname
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
decl_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
name|int
operator|)
name|global_sym_chain
index|[
name|hash
index|]
expr_stmt|;
name|global_sym_chain
index|[
name|hash
index|]
operator|=
name|sym
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|process_one_symbol
parameter_list|(
name|type
parameter_list|,
name|desc
parameter_list|,
name|value
parameter_list|,
name|name
parameter_list|)
name|int
name|type
decl_stmt|,
name|desc
decl_stmt|;
name|CORE_ADDR
name|value
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|context_stack
modifier|*
name|new
decl_stmt|;
name|char
modifier|*
name|colon_pos
decl_stmt|;
comment|/* Something is wrong if we see real data before      seeing a source file name.  */
if|if
condition|(
name|last_source_file
operator|==
literal|0
operator|&&
name|type
operator|!=
name|N_SO
condition|)
block|{
comment|/* Currently this ignores N_ENTRY on Gould machines, N_NSYM on machines 	 where that code is defined.  */
if|if
condition|(
name|IGNORE_SYMBOL
argument_list|(
name|type
argument_list|)
condition|)
return|return;
name|error
argument_list|(
literal|"Invalid symbol data: does not start by identifying a source file."
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|N_FUN
case|:
case|case
name|N_FNAME
case|:
comment|/* Either of these types of symbols indicates the start of 	 a new function.  We must process its "name" normally for dbx, 	 but also record the start of a new lexical context, and possibly 	 also the end of the lexical context for the previous function.  */
comment|/* This is not always true.  This type of symbol may indicate a          text segment variable.  */
name|colon_pos
operator|=
name|index
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|colon_pos
operator|++
operator|||
operator|(
operator|*
name|colon_pos
operator|!=
literal|'f'
operator|&&
operator|*
name|colon_pos
operator|!=
literal|'F'
operator|)
condition|)
block|{
name|define_symbol
argument_list|(
name|value
argument_list|,
name|name
argument_list|,
name|desc
argument_list|)
expr_stmt|;
break|break;
block|}
name|within_function
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|context_stack_depth
operator|>
literal|0
condition|)
block|{
name|new
operator|=
operator|&
name|context_stack
index|[
operator|--
name|context_stack_depth
index|]
expr_stmt|;
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
name|new
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* Stack must be empty now.  */
if|if
condition|(
name|context_stack_depth
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Invalid symbol data: unmatched N_LBRAC before symtab pos %d."
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
name|new
operator|=
operator|&
name|context_stack
index|[
name|context_stack_depth
operator|++
index|]
expr_stmt|;
name|new
operator|->
name|old_blocks
operator|=
name|pending_blocks
expr_stmt|;
name|new
operator|->
name|start_addr
operator|=
name|value
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|define_symbol
argument_list|(
name|value
argument_list|,
name|name
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|local_symbols
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|N_LBRAC
case|:
comment|/* This "symbol" just indicates the start of an inner lexical 	 context within a function.  */
if|if
condition|(
name|context_stack_depth
operator|==
name|context_stack_size
condition|)
block|{
name|context_stack_size
operator|*=
literal|2
expr_stmt|;
name|context_stack
operator|=
operator|(
expr|struct
name|context_stack
operator|*
operator|)
name|xrealloc
argument_list|(
name|context_stack
argument_list|,
operator|(
name|context_stack_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|context_stack
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
operator|&
name|context_stack
index|[
name|context_stack_depth
operator|++
index|]
expr_stmt|;
name|new
operator|->
name|depth
operator|=
name|desc
expr_stmt|;
name|new
operator|->
name|locals
operator|=
name|local_symbols
expr_stmt|;
name|new
operator|->
name|old_blocks
operator|=
name|pending_blocks
expr_stmt|;
name|new
operator|->
name|start_addr
operator|=
name|value
expr_stmt|;
name|new
operator|->
name|name
operator|=
literal|0
expr_stmt|;
name|local_symbols
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|N_RBRAC
case|:
comment|/* This "symbol" just indicates the end of an inner lexical 	 context that was started with N_LBRAC.  */
name|new
operator|=
operator|&
name|context_stack
index|[
operator|--
name|context_stack_depth
index|]
expr_stmt|;
if|if
condition|(
name|desc
operator|!=
name|new
operator|->
name|depth
condition|)
name|error
argument_list|(
literal|"Invalid symbol data: N_LBRAC/N_RBRAC symbol mismatch, symtab pos %d."
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
comment|/* Some native compilers put the variable decls inside of an          LBRAC/RBRAC block.  This macro should be nonzero if this 	 is true.  DESC is N_DESC from the N_RBRAC symbol.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VARIABLES_INSIDE_BLOCK
argument_list|)
define|#
directive|define
name|VARIABLES_INSIDE_BLOCK
parameter_list|(
name|desc
parameter_list|)
value|0
endif|#
directive|endif
comment|/* Can only use new->locals as local symbols here if we're in          gcc or on a machine that puts them before the lbrack.  */
if|if
condition|(
operator|!
name|VARIABLES_INSIDE_BLOCK
argument_list|(
name|desc
argument_list|)
condition|)
name|local_symbols
operator|=
name|new
operator|->
name|locals
expr_stmt|;
comment|/* If this is not the outermost LBRAC...RBRAC pair in the 	 function, its local symbols preceded it, and are the ones 	 just recovered from the context stack.  Defined the block for them.  	 If this is the outermost LBRAC...RBRAC pair, there is no 	 need to do anything; leave the symbols that preceded it 	 to be attached to the function's own block.  However, if 	 it is so, we need to indicate that we just moved outside 	 of the function.  */
if|if
condition|(
name|local_symbols
operator|&&
name|context_stack_depth
operator|>
operator|!
name|VARIABLES_INSIDE_BLOCK
argument_list|(
name|desc
argument_list|)
condition|)
block|{
comment|/* Muzzle a compiler bug that makes end< start.  */
if|if
condition|(
name|new
operator|->
name|start_addr
operator|>
name|value
condition|)
name|new
operator|->
name|start_addr
operator|=
name|value
expr_stmt|;
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
literal|0
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
operator|+
name|last_source_start_addr
argument_list|,
name|value
operator|+
name|last_source_start_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|within_function
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|VARIABLES_INSIDE_BLOCK
argument_list|(
name|desc
argument_list|)
condition|)
comment|/* Now pop locals of block just finished.  */
name|local_symbols
operator|=
name|new
operator|->
name|locals
expr_stmt|;
break|break;
case|case
name|N_FN
operator||
name|N_EXT
case|:
comment|/* This kind of symbol supposedly indicates the start 	 of an object file.  In fact this type does not appear.  */
break|break;
case|case
name|N_SO
case|:
comment|/* This type of symbol indicates the start of data 	 for one source file. 	 Finish the symbol table of the previous source file 	 (if any) and start accumulating a new symbol table.  */
ifdef|#
directive|ifdef
name|PCC_SOL_BROKEN
comment|/* pcc bug, occasionally puts out SO for SOL.  */
if|if
condition|(
name|context_stack_depth
operator|>
literal|0
condition|)
block|{
name|start_subfile
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|last_source_file
condition|)
name|end_symtab
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|start_symtab
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SOL
case|:
comment|/* This type of symbol indicates the start of data for 	 a sub-source-file, one whose contents were copied or 	 included in the compilation of the main source file 	 (whose name was given in the N_SO symbol.)  */
name|start_subfile
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|N_BINCL
case|case
name|N_BINCL
case|:
name|push_subfile
argument_list|()
expr_stmt|;
name|add_new_header_file
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|start_subfile
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_EINCL
case|:
name|start_subfile
argument_list|(
name|pop_subfile
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_EXCL
case|:
name|add_old_header_file
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* have N_BINCL */
case|case
name|N_SLINE
case|:
comment|/* This type of "symbol" really just records 	 one line-number -- core-address correspondence. 	 Enter it in the line list for this symbol table.  */
name|record_line
argument_list|(
name|desc
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_BCOMM
case|:
if|if
condition|(
name|common_block
condition|)
name|error
argument_list|(
literal|"Invalid symbol data: common within common at symtab pos %d"
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
name|common_block
operator|=
name|local_symbols
expr_stmt|;
name|common_block_i
operator|=
name|local_symbols
condition|?
name|local_symbols
operator|->
name|nsyms
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|N_ECOMM
case|:
comment|/* Symbols declared since the BCOMM are to have the common block 	 start address added in when we know it.  common_block points to 	 the first symbol after the BCOMM in the local_symbols list; 	 copy the list and hang it off the symbol for the common block name 	 for later fixup.  */
block|{
name|int
name|i
decl_stmt|;
name|struct
name|pending
modifier|*
name|link
init|=
name|local_symbols
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
init|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|sym
argument_list|,
sizeof|sizeof
expr|*
name|sym
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
expr|enum
name|namespace
operator|)
operator|(
operator|(
name|long
operator|)
name|copy_pending
argument_list|(
name|local_symbols
argument_list|,
name|common_block_i
argument_list|,
name|common_block
argument_list|)
operator|)
expr_stmt|;
name|i
operator|=
name|hashname
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
name|int
operator|)
name|global_sym_chain
index|[
name|i
index|]
expr_stmt|;
name|global_sym_chain
index|[
name|i
index|]
operator|=
name|sym
expr_stmt|;
name|common_block
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|N_ECOML
case|:
case|case
name|N_LENG
case|:
break|break;
default|default:
if|if
condition|(
name|name
condition|)
name|define_symbol
argument_list|(
name|value
argument_list|,
name|name
argument_list|,
name|desc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function was added for C++ functionality.  I presume that it    condenses the bunches formed by reading in an additional .o file    (incremental linking). */
end_comment

begin_function
specifier|static
name|void
name|condense_addl_misc_bunches
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|struct
name|misc_bunch
modifier|*
name|bunch
decl_stmt|;
ifdef|#
directive|ifdef
name|NAMES_HAVE_UNDERSCORE
name|int
name|offset
init|=
literal|1
decl_stmt|;
else|#
directive|else
name|int
name|offset
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|misc_function_vector
operator|=
operator|(
expr|struct
name|misc_function
operator|*
operator|)
name|xrealloc
argument_list|(
name|misc_function_vector
argument_list|,
operator|(
name|misc_count
operator|+
name|misc_function_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|misc_function
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|=
name|misc_function_count
expr_stmt|;
name|bunch
operator|=
name|misc_bunch
expr_stmt|;
while|while
condition|(
name|bunch
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|misc_bunch_index
condition|;
name|i
operator|++
control|)
block|{
name|misc_function_vector
index|[
name|j
index|]
operator|=
name|bunch
operator|->
name|contents
index|[
name|i
index|]
expr_stmt|;
name|misc_function_vector
index|[
name|j
index|]
operator|.
name|name
operator|=
name|concat
argument_list|(
name|misc_function_vector
index|[
name|j
index|]
operator|.
name|name
operator|+
operator|(
name|misc_function_vector
index|[
name|j
index|]
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
condition|?
name|offset
else|:
literal|0
operator|)
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|bunch
operator|=
name|bunch
operator|->
name|next
expr_stmt|;
name|misc_bunch_index
operator|=
name|MISC_BUNCH_SIZE
expr_stmt|;
block|}
name|misc_function_count
operator|+=
name|misc_count
expr_stmt|;
comment|/* Sort the misc functions by address.  */
name|qsort
argument_list|(
name|misc_function_vector
argument_list|,
name|misc_function_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|misc_function
argument_list|)
argument_list|,
name|compare_misc_functions
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read in another .o file and create a symtab entry for it.*/
end_comment

begin_function
specifier|static
name|void
name|read_addl_syms
parameter_list|(
name|desc
parameter_list|,
name|stringtab
parameter_list|,
name|nlistlen
parameter_list|,
name|text_addr
parameter_list|,
name|text_size
parameter_list|)
name|int
name|desc
decl_stmt|;
specifier|register
name|char
modifier|*
name|stringtab
decl_stmt|;
specifier|register
name|int
name|nlistlen
decl_stmt|;
name|unsigned
name|text_addr
decl_stmt|;
name|int
name|text_size
decl_stmt|;
block|{
name|FILE
modifier|*
name|stream
init|=
name|fdopen
argument_list|(
name|desc
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|namestring
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|int
name|hash
decl_stmt|;
ifdef|#
directive|ifdef
name|N_BINCL
name|subfile_stack
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|last_source_file
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|global_sym_chain
argument_list|,
sizeof|sizeof
name|global_sym_chain
argument_list|)
expr_stmt|;
name|symtab_input_desc
operator|=
name|desc
expr_stmt|;
name|stringtab_global
operator|=
name|stringtab
expr_stmt|;
name|fill_symbuf
argument_list|()
expr_stmt|;
for|for
control|(
name|symnum
operator|=
literal|0
init|;
name|symnum
operator|<
name|nlistlen
condition|;
name|symnum
operator|++
control|)
block|{
name|struct
name|nlist
modifier|*
name|bufp
decl_stmt|;
name|unsigned
name|char
name|type
decl_stmt|;
name|QUIT
expr_stmt|;
comment|/* allow this to be interruptable */
if|if
condition|(
name|symbuf_idx
operator|==
name|symbuf_end
condition|)
name|fill_symbuf
argument_list|()
expr_stmt|;
name|bufp
operator|=
operator|&
name|symbuf
index|[
name|symbuf_idx
operator|++
index|]
expr_stmt|;
name|type
operator|=
name|bufp
operator|->
name|n_type
operator|&
name|N_TYPE
expr_stmt|;
name|namestring
operator|=
name|bufp
operator|->
name|n_un
operator|.
name|n_strx
operator|+
name|stringtab
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|N_TEXT
operator|)
operator|||
operator|(
name|type
operator|==
name|N_DATA
operator|)
operator|||
operator|(
name|type
operator|==
name|N_BSS
operator|)
condition|)
block|{
comment|/* Relocate this file's symbol table information 	     to the address it has been loaded into.  */
name|bufp
operator|->
name|n_value
operator|+=
name|text_addr
expr_stmt|;
block|}
name|type
operator|=
name|bufp
operator|->
name|n_type
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|N_STAB
condition|)
name|process_one_symbol
argument_list|(
name|type
argument_list|,
name|bufp
operator|->
name|n_desc
argument_list|,
name|bufp
operator|->
name|n_value
argument_list|,
name|namestring
argument_list|)
expr_stmt|;
comment|/* A static text symbol whose name ends in ".o" 	 can only mean the start of another object file. 	 So end the symtab of the source file we have been processing. 	 This is how we avoid counting the libraries as part 	 or the last source file. 	 Also this way we find end of first object file (crt0).  */
elseif|else
if|if
condition|(
operator|(
name|type
operator|==
name|N_TEXT
ifdef|#
directive|ifdef
name|N_NBTEXT
operator|||
name|type
operator|==
name|N_NBTEXT
endif|#
directive|endif
operator|)
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|namestring
operator|+
name|strlen
argument_list|(
name|namestring
argument_list|)
operator|-
literal|2
argument_list|,
literal|".o"
argument_list|)
operator|)
operator|||
operator|!
name|strncmp
argument_list|(
name|namestring
argument_list|,
literal|"-l"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
if|if
condition|(
name|last_source_file
condition|)
name|end_symtab
argument_list|(
name|bufp
operator|->
name|n_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|&
name|N_EXT
operator|||
name|type
operator|==
name|N_TEXT
ifdef|#
directive|ifdef
name|N_NBTEXT
operator|||
name|type
operator|==
name|N_NBTEXT
endif|#
directive|endif
condition|)
block|{
name|int
name|used_up
init|=
literal|0
decl_stmt|;
comment|/* Record the location of _etext.  */
if|if
condition|(
name|type
operator|==
operator|(
name|N_TEXT
operator||
name|N_EXT
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|namestring
argument_list|,
literal|"_etext"
argument_list|)
condition|)
name|end_of_text_addr
operator|=
name|bufp
operator|->
name|n_value
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 25 Sep 89: The following seems to be stolen from 	     read_ofile_symtab, and is wrong here (i.e. there was no 	     first pass for add-file symbols).  */
comment|/* This shouldn't be necessary, as we now do all of this work 	     in scan_global syms and all misc functions should have been 	     recorded on the first pass.  */
comment|/* Global symbol: see if we came across a dbx definition 	     for a corresponding symbol.  If so, store the value. 	     Remove syms from the chain when their values are stored, 	     but search the whole chain, as there may be several syms 	     from different files with the same name.  */
block|if (type& N_EXT) 	    { 	      prev = 0;
ifdef|#
directive|ifdef
name|NAMES_HAVE_UNDERSCORE
block|hash = hashname (namestring + 1);
else|#
directive|else
comment|/* not NAMES_HAVE_UNDERSCORE */
block|hash = hashname (namestring);
endif|#
directive|endif
comment|/* not NAMES_HAVE_UNDERSCORE */
block|for (sym = global_sym_chain[hash]; 		   sym;) 		{ 		  if (
ifdef|#
directive|ifdef
name|NAMES_HAVE_UNDERSCORE
block|*namestring == '_'&& namestring[1] == SYMBOL_NAME (sym)[0]&& 		      !strcmp (namestring + 2, SYMBOL_NAME (sym) + 1)
else|#
directive|else
comment|/* NAMES_HAVE_UNDERSCORE */
block|namestring[0] == SYMBOL_NAME (sym)[0]&& 		      !strcmp (namestring + 1, SYMBOL_NAME (sym) + 1)
endif|#
directive|endif
comment|/* NAMES_HAVE_UNDERSCORE */
block|) 		    { 		      if (prev) 			SYMBOL_VALUE (prev) = SYMBOL_VALUE (sym); 		      else 			global_sym_chain[hash] 			  = (struct symbol *) SYMBOL_VALUE (sym); 		      if (SYMBOL_CLASS (sym) == LOC_BLOCK) 			fix_common_block (sym, bufp->n_value); 		      else 			SYMBOL_VALUE (sym) = bufp->n_value; 		      if (prev) 			sym = (struct symbol *) SYMBOL_VALUE (prev); 		      else 			sym = global_sym_chain[hash];  		      used_up = 1; 		    } 		  else 		    { 		      prev = sym; 		      sym = (struct symbol *) SYMBOL_VALUE (sym); 		    } 		} 	    }
comment|/* Defined global or text symbol: record as a misc function 	     if it didn't give its address to a debugger symbol above.  */
block|if (type<= (N_TYPE | N_EXT)&& type != N_EXT&& ! used_up) 	    record_misc_function (namestring, bufp->n_value, 				  bufp->n_type);
endif|#
directive|endif
comment|/* 0 */
block|}
block|}
if|if
condition|(
name|last_source_file
condition|)
name|end_symtab
argument_list|(
name|text_addr
operator|+
name|text_size
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* C++:    This function allows the addition of incrementally linked object files.    Since this has a fair amount of code in common with symbol_file_command,    it might be worthwhile to consolidate things, as was done with    read_dbx_symtab and condense_misc_bunches. */
end_comment

begin_function
name|void
name|add_file_command
parameter_list|(
name|arg_string
parameter_list|)
name|char
modifier|*
name|arg_string
decl_stmt|;
block|{
specifier|register
name|int
name|desc
decl_stmt|;
name|DECLARE_FILE_HEADERS
expr_stmt|;
name|struct
name|nlist
modifier|*
name|nlist
decl_stmt|;
name|char
modifier|*
name|stringtab
decl_stmt|;
name|long
name|buffer
decl_stmt|;
specifier|register
name|int
name|val
decl_stmt|;
specifier|extern
name|void
name|close
parameter_list|()
function_decl|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|symtab
modifier|*
name|symseg
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|text_addr
decl_stmt|;
if|if
condition|(
name|arg_string
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"add-file takes a file name and an address"
argument_list|)
expr_stmt|;
name|arg_string
operator|=
name|tilde_expand
argument_list|(
name|arg_string
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|arg_string
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|arg_string
operator|==
literal|' '
condition|;
name|arg_string
operator|++
control|)
empty_stmt|;
name|name
operator|=
name|arg_string
expr_stmt|;
for|for
control|(
init|;
operator|*
name|arg_string
operator|&&
operator|*
name|arg_string
operator|!=
literal|' '
condition|;
name|arg_string
operator|++
control|)
empty_stmt|;
operator|*
name|arg_string
operator|++
operator|=
operator|(
name|char
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"add-file takes a file name and an address"
argument_list|)
expr_stmt|;
name|text_addr
operator|=
name|parse_and_eval_address
argument_list|(
name|arg_string
argument_list|)
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"add symbol table from filename \"%s\" at text_addr = 0x%x\n"
argument_list|,
name|name
argument_list|,
name|text_addr
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
name|desc
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|close
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|READ_FILE_HEADERS
argument_list|(
name|desc
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|NUMBER_OF_SYMBOLS
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s does not have a symbol-table.\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"Reading symbol data from %s..."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Now read the string table, all at once.  */
name|val
operator|=
name|lseek
argument_list|(
name|desc
argument_list|,
name|STRING_TABLE_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|READ_STRING_TABLE_SIZE
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|>=
literal|0
operator|&&
name|buffer
operator|<
name|statbuf
operator|.
name|st_size
condition|)
block|{
ifdef|#
directive|ifdef
name|BROKEN_LARGE_ALLOCA
name|stringtab
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|stringtab
argument_list|)
expr_stmt|;
else|#
directive|else
name|stringtab
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|stringtab
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stringtab
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"ridiculous string table size: %d bytes"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
comment|/* Usually READ_STRING_TABLE_SIZE will have shifted the file pointer.      Occaisionally, it won't.  */
name|val
operator|=
name|lseek
argument_list|(
name|desc
argument_list|,
name|STRING_TABLE_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|val
operator|=
name|myread
argument_list|(
name|desc
argument_list|,
name|stringtab
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Symsegs are no longer supported by GDB.  Setting symseg_chain to      0 is easier than finding all the symseg code and eliminating it.  */
name|symseg_chain
operator|=
literal|0
expr_stmt|;
comment|/* Position to read the symbol table.  Do not read it all at once. */
name|val
operator|=
name|lseek
argument_list|(
name|desc
argument_list|,
name|SYMBOL_TABLE_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|init_misc_functions
argument_list|()
expr_stmt|;
name|make_cleanup
argument_list|(
name|discard_misc_bunches
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|init_header_files
argument_list|()
expr_stmt|;
name|make_cleanup
argument_list|(
name|free_header_files
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_pendings
operator|=
literal|0
expr_stmt|;
name|pending_blocks
operator|=
literal|0
expr_stmt|;
name|file_symbols
operator|=
literal|0
expr_stmt|;
name|global_symbols
operator|=
literal|0
expr_stmt|;
name|make_cleanup
argument_list|(
name|really_free_pendings
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read_addl_syms
argument_list|(
name|desc
argument_list|,
name|stringtab
argument_list|,
name|NUMBER_OF_SYMBOLS
argument_list|,
name|text_addr
argument_list|,
name|SIZE_OF_TEXT_SEGMENT
argument_list|)
expr_stmt|;
comment|/* Sort symbols alphabetically within each block.  */
name|sort_syms
argument_list|()
expr_stmt|;
comment|/* Go over the misc functions and install them in vector.  */
name|condense_addl_misc_bunches
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Don't allow char * to have a typename (else would get caddr_t.)  */
name|TYPE_NAME
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_char
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
comment|/* Free the symtabs made by read_symsegs, but not their contents,      which have been copied into symtabs on symtab_list.  */
while|while
condition|(
name|symseg_chain
condition|)
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|s
init|=
name|symseg_chain
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|symseg_chain
argument_list|)
expr_stmt|;
name|symseg_chain
operator|=
name|s
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read a number by which a type is referred to in dbx data,    or perhaps read a pair (FILENUM, TYPENUM) in parentheses.    Just a single number N is equivalent to (0,N).    Return the two numbers by storing them in the vector TYPENUMS.    TYPENUMS will then be used as an argument to dbx_lookup_type.  */
end_comment

begin_function
specifier|static
name|void
name|read_type_number
parameter_list|(
name|pp
parameter_list|,
name|typenums
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
modifier|*
name|typenums
decl_stmt|;
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'('
condition|)
block|{
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
name|typenums
index|[
literal|0
index|]
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|typenums
index|[
literal|1
index|]
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|typenums
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|typenums
index|[
literal|1
index|]
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|define_symbol
parameter_list|(
name|value
parameter_list|,
name|string
parameter_list|,
name|desc
parameter_list|)
name|int
name|value
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|desc
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
init|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|string
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
name|int
name|deftype
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Ignore syms with empty names.  */
if|if
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Ignore old-style symbols from cc -go  */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
operator|(
operator|(
name|p
operator|-
name|string
operator|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Open-coded bcopy--saves function call time.  */
block|{
specifier|register
name|char
modifier|*
name|p1
init|=
name|string
decl_stmt|;
specifier|register
name|char
modifier|*
name|p2
init|=
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
decl_stmt|;
while|while
condition|(
name|p1
operator|!=
name|p
condition|)
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
comment|/* Determine the type of name being defined.  */
if|if
condition|(
operator|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
operator|)
operator|||
operator|*
name|p
operator|==
literal|'('
condition|)
name|deftype
operator|=
literal|'l'
expr_stmt|;
else|else
name|deftype
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* c is a special case, not followed by a type-number.      SYMBOL:c=iVALUE for an integer constant symbol.      SYMBOL:c=rVALUE for a floating constant symbol.      SYMBOL:c=eTYPE,INTVALUE for an enum constant symbol.         e.g. "b:c=e6,0" for "const b = blob1" 	(where type 6 is defined by "blobs:t6=eblob1:0,blob2:1,;").  */
if|if
condition|(
name|deftype
operator|==
literal|'c'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'='
condition|)
name|error
argument_list|(
literal|"Invalid symbol data at symtab pos %d."
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|'r'
case|:
block|{
name|double
name|d
init|=
name|atof
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|builtin_type_double
expr_stmt|;
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|d
argument_list|,
name|value
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE_BYTES
argument_list|(
name|sym
argument_list|)
operator|=
name|value
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST_BYTES
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|builtin_type_int
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
block|}
break|break;
case|case
literal|'e'
case|:
comment|/* SYMBOL:c=eTYPE,INTVALUE for an enum constant symbol. 	     e.g. "b:c=e6,0" for "const b = blob1" 	     (where type 6 is defined by "blobs:t6=eblob1:0,blob2:1,;").  */
block|{
name|int
name|typenums
index|[
literal|2
index|]
decl_stmt|;
name|read_type_number
argument_list|(
operator|&
name|p
argument_list|,
name|typenums
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|','
condition|)
name|error
argument_list|(
literal|"Invalid symbol data: no comma in enum const symbol"
argument_list|)
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
block|}
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid symbol data at symtab pos %d."
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
block|}
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
block|}
comment|/* Now usually comes a number that says which data type,      and possibly more stuff to define the type      (all of which is handled by read_type)  */
if|if
condition|(
name|deftype
operator|==
literal|'p'
operator|&&
operator|*
name|p
operator|==
literal|'F'
condition|)
comment|/* pF is a two-letter code that means a function parameter in Fortran.        The type-number specifies the type of the return value.        Translate it into a pointer-to-function type.  */
block|{
name|p
operator|++
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|lookup_pointer_type
argument_list|(
name|lookup_function_type
argument_list|(
name|read_type
argument_list|(
operator|&
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|read_type
argument_list|(
operator|&
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|deftype
operator|==
literal|'F'
operator|||
name|deftype
operator|==
literal|'f'
operator|)
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_FUNC
condition|)
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|lookup_function_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
switch|switch
condition|(
name|deftype
condition|)
block|{
case|case
literal|'f'
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
comment|/* For a class G (global) symbol, it appears that the 	 value is not correct.  It is necessary to search for the 	 corresponding linker definition to find the value. 	 These definitions appear at the end of the namelist.  */
name|i
operator|=
name|hashname
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
name|int
operator|)
name|global_sym_chain
index|[
name|i
index|]
expr_stmt|;
name|global_sym_chain
index|[
name|i
index|]
operator|=
name|sym
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
break|break;
comment|/* This case is faked by a conditional above, 	 when there is no code letter in the dbx data. 	 Dbx data never actually contains 'l'.  */
case|case
literal|'l'
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LOCAL
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|value
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_ARG
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|value
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
comment|/* If it's gcc compiled, if it says `short', believe it.  */
if|if
condition|(
name|processing_gcc_compilation
operator|||
name|BELIEVE_PCC_PROMOTION
condition|)
break|break;
if|#
directive|if
name|defined
argument_list|(
name|BELIEVE_PCC_PROMOTION_TYPE
argument_list|)
comment|/* This macro is defined on machines (e.g. sparc) where 	 we should believe the type of a PCC 'short' argument, 	 but shouldn't believe the address (the address is 	 the address of the corresponding int).  Note that 	 this is only different from the BELIEVE_PCC_PROMOTION 	 case on big-endian machines.  	 My guess is that this correction, as opposed to changing 	 the parameter to an 'int' (as done below, for PCC 	 on most machines), is the right thing to do 	 on all machines, but I don't want to risk breaking 	 something that already works.  On most PCC machines, 	 the sparc problem doesn't come up because the calling 	 function has to zero the top bytes (not knowing whether 	 the called function wants an int or a short), so there 	 is no practical difference between an int and a short 	 (except perhaps what happens when the GDB user types 	 "print short_arg = 0x10000;"). 	 Hacked for SunOS 4.1 by gnu@cygnus.com.  In 4.1, the compiler 	 actually produces the correct address (we don't need to fix it 	 up).  I made this code adapt so that it will offset the symbol 	 if it was pointing at an int-aligned location and not 	 otherwise.  This way you can use the same gdb for 4.0.x and 	 4.1 systems.  */
if|if
condition|(
literal|0
operator|==
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|%
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
if|if
condition|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|builtin_type_char
operator|||
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|builtin_type_unsigned_char
condition|)
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|builtin_type_short
operator|||
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|builtin_type_unsigned_short
condition|)
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
else|#
directive|else
comment|/* no BELIEVE_PCC_PROMOTION_TYPE.  */
comment|/* If PCC says a parameter is a short or a char, 	 it is really an int.  */
if|if
condition|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|builtin_type_char
operator|||
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|builtin_type_short
condition|)
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|builtin_type_int
expr_stmt|;
elseif|else
if|if
condition|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|builtin_type_unsigned_char
operator|||
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|==
name|builtin_type_unsigned_short
condition|)
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|builtin_type_unsigned_int
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* no BELIEVE_PCC_PROMOTION_TYPE.  */
case|case
literal|'P'
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGPARM
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|STAB_REG_TO_REGNUM
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* XXX */
ifdef|#
directive|ifdef
name|sparc
block|{
name|struct
name|symbol
modifier|*
name|s0
decl_stmt|;
comment|/* 	 * If we see a parm decl immediately followed by a reg decl of 	 * the same name (and in the same block), we change it to a single  	 * instance of a reg parm.  Sun's cc will generate these. 	 */
if|if
condition|(
name|local_symbols
operator|&&
operator|(
name|s0
operator|=
name|local_symbols
operator|->
name|symbol
index|[
name|local_symbols
operator|->
name|nsyms
operator|-
literal|1
index|]
operator|)
operator|&&
name|SYMBOL_CLASS
argument_list|(
name|s0
argument_list|)
operator|==
name|LOC_ARG
operator|&&
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|s0
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SYMBOL_CLASS
argument_list|(
name|s0
argument_list|)
operator|=
name|LOC_REGPARM
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|s0
argument_list|)
operator|=
name|STAB_REG_TO_REGNUM
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|s0
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
return|return
name|s0
return|;
block|}
block|}
endif|#
directive|endif
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGISTER
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|STAB_REG_TO_REGNUM
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Static symbol at top level of file */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|value
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|value
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|TYPE_FLAGS
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|&
name|TYPE_FLAG_PERM
operator|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* C++ vagaries: we may have a type which is derived from  	 a base type which did not have its name defined when the  	 derived class was output.  We fill in the derived class's  	 base part member's name here in that case.  */
elseif|else
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|)
operator|&&
name|TYPE_N_BASECLASSES
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|TYPE_FIELD_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|i
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_FIELD_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|i
operator|-
literal|1
argument_list|)
operator|=
name|TYPE_NAME
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|value
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|STRUCT_NAMESPACE
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|TYPE_FLAGS
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|&
name|TYPE_FLAG_PERM
operator|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|=
name|obconcat
argument_list|(
literal|""
argument_list|,
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_ENUM
condition|?
literal|"enum "
else|:
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|?
literal|"struct "
else|:
literal|"union "
operator|)
operator|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|file_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* Static symbol of local scope */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|value
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* Reference parameter */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REF_ARG
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|value
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* This is used by Sun FORTRAN for "function result value". 	 Sun claims ("dbx and dbxtool interfaces", 2nd ed) 	 that Pascal uses it too, but when I tried it Pascal used 	 "x:3" (local symbol) instead.  */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LOCAL
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|value
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|local_symbols
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid symbol data: unknown symbol-type code `%c' at symtab pos %d."
argument_list|,
name|deftype
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
block|}
return|return
name|sym
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* What about types defined as forward references inside of a small lexical    scope?  */
end_comment

begin_comment
comment|/* Add a type to the list of undefined types to be checked through    once this file has been read in.  */
end_comment

begin_function
specifier|static
name|void
name|add_undefined_type
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
if|if
condition|(
name|undef_types_length
operator|==
name|undef_types_allocated
condition|)
block|{
name|undef_types_allocated
operator|*=
literal|2
expr_stmt|;
name|undef_types
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|undef_types
argument_list|,
name|undef_types_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|undef_types
index|[
name|undef_types_length
operator|++
index|]
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add here something to go through each undefined type, see if it's    still undefined, and do a full lookup if so.  */
end_comment

begin_function
specifier|static
name|void
name|cleanup_undefined_types
parameter_list|()
block|{
name|struct
name|type
modifier|*
modifier|*
name|type
decl_stmt|,
modifier|*
name|ntype
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
for|for
control|(
name|type
operator|=
name|undef_types
init|;
name|type
operator|<
name|undef_types
operator|+
name|undef_types_length
condition|;
name|type
operator|++
control|)
block|{
name|struct
name|type
modifier|*
name|ntype
init|=
literal|0
decl_stmt|;
comment|/* Reasonable test to see if it's been defined since.  */
if|if
condition|(
name|TYPE_NFIELDS
argument_list|(
operator|*
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|pending
modifier|*
name|ppt
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Name of the type, without "struct" or "union" */
name|char
modifier|*
name|typename
init|=
name|TYPE_NAME
argument_list|(
operator|*
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|typename
argument_list|,
literal|"struct "
argument_list|,
literal|7
argument_list|)
condition|)
name|typename
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|typename
argument_list|,
literal|"union "
argument_list|,
literal|6
argument_list|)
condition|)
name|typename
operator|+=
literal|6
expr_stmt|;
for|for
control|(
name|ppt
operator|=
name|file_symbols
init|;
name|ppt
condition|;
name|ppt
operator|=
name|ppt
operator|->
name|next
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ppt
operator|->
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|ppt
operator|->
name|symbol
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|==
name|STRUCT_NAMESPACE
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE
argument_list|(
operator|*
name|type
argument_list|)
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|typename
argument_list|)
condition|)
name|bcopy
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
operator|*
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* It has been defined; don't mark it as a stub.  */
name|TYPE_FLAGS
argument_list|(
operator|*
name|type
argument_list|)
operator|&=
operator|~
name|TYPE_FLAG_STUB
expr_stmt|;
block|}
name|undef_types_length
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read a dbx type reference or definition;    return the type that is meant.    This can be just a number, in which case it references    a type already defined and placed in type_vector.    Or the number can be followed by an =, in which case    it means to define a new type according to the text that    follows the =.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_type
parameter_list|(
name|pp
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|type
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|struct
name|type
modifier|*
name|type1
decl_stmt|;
name|int
name|typenums
index|[
literal|2
index|]
decl_stmt|;
name|int
name|xtypenums
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|tmpc
decl_stmt|;
comment|/* Read type number if present.  The type number may be omitted.      for instance in a two-dimensional array declared with type      "ar1;1;10;ar1;1;10;4".  */
if|if
condition|(
operator|(
operator|*
operator|*
name|pp
operator|>=
literal|'0'
operator|&&
operator|*
operator|*
name|pp
operator|<=
literal|'9'
operator|)
operator|||
operator|*
operator|*
name|pp
operator|==
literal|'('
condition|)
block|{
name|read_type_number
argument_list|(
name|pp
argument_list|,
name|typenums
argument_list|)
expr_stmt|;
comment|/* Detect random reference to type not yet defined. 	 Allocate a type object but leave it zeroed.  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'='
condition|)
return|return
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|)
return|;
operator|*
name|pp
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* 'typenums=' not present, type is anonymous.  Read and return 	 the definition, but don't put it in the type vector.  */
name|typenums
index|[
literal|0
index|]
operator|=
name|typenums
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
operator|(
operator|*
name|pp
operator|)
index|[
operator|-
literal|1
index|]
condition|)
block|{
case|case
literal|'x'
case|:
block|{
name|enum
name|type_code
name|code
decl_stmt|;
comment|/* Used to index through file_symbols.  */
name|struct
name|pending
modifier|*
name|ppt
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Name including "struct", etc.  */
name|char
modifier|*
name|type_name
decl_stmt|;
comment|/* Name without "struct", etc.  */
name|char
modifier|*
name|type_name_only
decl_stmt|;
block|{
name|char
modifier|*
name|prefix
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
comment|/* Set the type code according to the following letter.  */
switch|switch
condition|(
operator|(
operator|*
name|pp
operator|)
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'s'
case|:
name|code
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
name|prefix
operator|=
literal|"struct "
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|code
operator|=
name|TYPE_CODE_UNION
expr_stmt|;
name|prefix
operator|=
literal|"union "
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|code
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
name|prefix
operator|=
literal|"enum "
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Bad type cross reference at symnum: %d."
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
block|}
name|to
operator|=
name|type_name
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
operator|(
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
operator|(
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
operator|*
name|pp
argument_list|,
literal|':'
argument_list|)
operator|-
operator|(
operator|*
name|pp
operator|)
operator|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Copy the prefix.  */
name|from
operator|=
name|prefix
expr_stmt|;
while|while
condition|(
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
condition|)
empty_stmt|;
name|to
operator|--
expr_stmt|;
name|type_name_only
operator|=
name|to
expr_stmt|;
comment|/* Copy the name.  */
name|from
operator|=
operator|*
name|pp
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
operator|)
operator|!=
literal|':'
condition|)
empty_stmt|;
operator|*
operator|--
name|to
operator|=
literal|'\0'
expr_stmt|;
comment|/* Set the pointer ahead of the name which we just read.  */
operator|*
name|pp
operator|=
name|from
expr_stmt|;
if|#
directive|if
literal|0
comment|/* The following hack is clearly wrong, because it doesn't 	     check whether we are in a baseclass.  I tried to reproduce 	     the case that it is trying to fix, but I couldn't get 	     g++ to put out a cross reference to a basetype.  Perhaps 	     it doesn't do it anymore.  */
comment|/* Note: for C++, the cross reference may be to a base type which 	     has not yet been seen.  In this case, we skip to the comma, 	     which will mark the end of the base class name.  (The ':' 	     at the end of the base class name will be skipped as well.) 	     But sometimes (ie. when the cross ref is the last thing on 	     the line) there will be no ','.  */
block|from = (char *) index (*pp, ','); 	  if (from) 	    *pp = from;
endif|#
directive|endif
comment|/* 0 */
block|}
comment|/* Now check to see whether the type has already been declared.  */
comment|/* This is necessary at least in the case where the 	   program says something like 	     struct foo bar[5]; 	   The compiler puts out a cross-reference; we better find 	   set the length of the structure correctly so we can 	   set the length of the array.  */
for|for
control|(
name|ppt
operator|=
name|file_symbols
init|;
name|ppt
condition|;
name|ppt
operator|=
name|ppt
operator|->
name|next
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ppt
operator|->
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|ppt
operator|->
name|symbol
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_TYPEDEF
operator|&&
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|==
name|STRUCT_NAMESPACE
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|code
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|type_name_only
argument_list|)
condition|)
block|{
name|obstack_free
argument_list|(
name|symbol_obstack
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
name|type
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
block|}
comment|/* Didn't find the type to which this refers, so we must 	   be dealing with a forward reference.  Allocate a type 	   structure for it, and keep track of it so we can 	   fill in the rest of the fields when we get the full 	   type.  */
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|code
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|type_name
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_STUB
expr_stmt|;
name|add_undefined_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'('
case|:
operator|(
operator|*
name|pp
operator|)
operator|--
expr_stmt|;
name|read_type_number
argument_list|(
name|pp
argument_list|,
name|xtypenums
argument_list|)
expr_stmt|;
name|type
operator|=
operator|*
name|dbx_lookup_type
argument_list|(
name|xtypenums
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
name|type
operator|=
name|builtin_type_void
expr_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|type1
operator|=
name|read_type
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_POINTER_TYPE
argument_list|(
name|type1
argument_list|)
condition|)
block|{
name|type
operator|=
name|TYPE_POINTER_TYPE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|)
expr_stmt|;
name|smash_to_pointer_type
argument_list|(
name|type
argument_list|,
name|type1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'@'
case|:
block|{
name|struct
name|type
modifier|*
name|domain
init|=
name|read_type
argument_list|(
name|pp
argument_list|)
decl_stmt|;
name|char
name|c
decl_stmt|;
name|struct
name|type
modifier|*
name|memtype
decl_stmt|;
if|if
condition|(
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|!=
literal|','
condition|)
name|error
argument_list|(
literal|"invalid member type data format, at symtab pos %d."
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
name|memtype
operator|=
name|read_type
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|)
expr_stmt|;
name|smash_to_member_type
argument_list|(
name|type
argument_list|,
name|domain
argument_list|,
name|memtype
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'#'
case|:
block|{
name|struct
name|type
modifier|*
name|domain
init|=
name|read_type
argument_list|(
name|pp
argument_list|)
decl_stmt|;
name|char
name|c
decl_stmt|;
name|struct
name|type
modifier|*
name|return_type
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|args
decl_stmt|;
if|if
condition|(
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|!=
literal|','
condition|)
name|error
argument_list|(
literal|"invalid member type data format, at symtab pos %d."
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
name|return_type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|args
operator|=
name|read_args
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|)
expr_stmt|;
name|smash_to_method_type
argument_list|(
name|type
argument_list|,
name|domain
argument_list|,
name|return_type
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'&'
case|:
name|type1
operator|=
name|read_type
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_REFERENCE_TYPE
argument_list|(
name|type1
argument_list|)
condition|)
block|{
name|type
operator|=
name|TYPE_REFERENCE_TYPE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|)
expr_stmt|;
name|smash_to_reference_type
argument_list|(
name|type
argument_list|,
name|type1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
name|type1
operator|=
name|read_type
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FUNCTION_TYPE
argument_list|(
name|type1
argument_list|)
condition|)
block|{
name|type
operator|=
name|TYPE_FUNCTION_TYPE
argument_list|(
name|type1
argument_list|)
expr_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|)
expr_stmt|;
name|smash_to_function_type
argument_list|(
name|type
argument_list|,
name|type1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
name|type
operator|=
name|read_range_type
argument_list|(
name|pp
argument_list|,
name|typenums
argument_list|)
expr_stmt|;
if|if
condition|(
name|typenums
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
condition|)
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|)
expr_stmt|;
name|type
operator|=
name|read_enum_type
argument_list|(
name|pp
argument_list|,
name|type
argument_list|)
expr_stmt|;
operator|*
name|dbx_lookup_type
argument_list|(
name|typenums
argument_list|)
operator|=
name|type
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|)
expr_stmt|;
name|type
operator|=
name|read_struct_type
argument_list|(
name|pp
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|)
expr_stmt|;
name|type
operator|=
name|read_struct_type
argument_list|(
name|pp
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_UNION
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
if|if
condition|(
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|!=
literal|'r'
condition|)
name|error
argument_list|(
literal|"Invalid symbol data: unrecognized type-code `a%c' %s %d."
argument_list|,
operator|(
operator|*
name|pp
operator|)
index|[
operator|-
literal|1
index|]
argument_list|,
literal|"at symtab position"
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
name|type
operator|=
name|dbx_alloc_type
argument_list|(
name|typenums
argument_list|)
expr_stmt|;
name|type
operator|=
name|read_array_type
argument_list|(
name|pp
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid symbol data: unrecognized type-code `%c' at symtab pos %d."
argument_list|,
operator|(
operator|*
name|pp
operator|)
index|[
operator|-
literal|1
index|]
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* If this is an overriding temporary alteration for a header file's      contents, and this type number is unknown in the global definition,      put this type into the global definition at this type number.  */
block|if (header_file_prev_index>= 0)     {       register struct type **tp         = explicit_lookup_type (header_file_prev_index, typenums[1]);       if (*tp == 0) 	*tp = type;     }
endif|#
directive|endif
return|return
name|type
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This page contains subroutines of read_type.  */
end_comment

begin_comment
comment|/* Read the description of a structure (or union type)    and return an object describing the type.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_struct_type
parameter_list|(
name|pp
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
struct|struct
name|nextfield
block|{
name|struct
name|nextfield
modifier|*
name|next
decl_stmt|;
name|int
name|visibility
decl_stmt|;
name|struct
name|field
name|field
decl_stmt|;
block|}
struct|;
struct|struct
name|next_fnfield
block|{
name|struct
name|next_fnfield
modifier|*
name|next
decl_stmt|;
name|int
name|visibility
decl_stmt|;
name|struct
name|fn_field
name|fn_field
decl_stmt|;
block|}
struct|;
struct|struct
name|next_fnfieldlist
block|{
name|struct
name|next_fnfieldlist
modifier|*
name|next
decl_stmt|;
name|struct
name|fn_fieldlist
name|fn_fieldlist
decl_stmt|;
block|}
struct|;
specifier|register
name|struct
name|nextfield
modifier|*
name|list
init|=
literal|0
decl_stmt|;
name|struct
name|nextfield
modifier|*
name|new
decl_stmt|;
name|int
name|totalsize
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|nfields
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|struct
name|next_fnfieldlist
modifier|*
name|mainlist
init|=
literal|0
decl_stmt|;
name|int
name|nfn_fields
init|=
literal|0
decl_stmt|;
name|int
name|read_possible_virtual_info
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
comment|/* First comes the total size in bytes.  */
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* C++: Now, if the class is a derived class, then the next character      will be a '!', followed by the number of base classes derived from.      Each element in the list contains visibility information,      the offset of this base class in the derived structure,      and then the base type. */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'!'
condition|)
block|{
name|int
name|i
decl_stmt|,
name|n_baseclasses
decl_stmt|,
name|offset
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|baseclass_vec
decl_stmt|;
name|struct
name|type
modifier|*
name|baseclass
decl_stmt|;
name|int
name|via_public
decl_stmt|;
comment|/* Nonzero if it is a virtual baseclass, i.e.,  	 struct A{}; 	 struct B{}; 	 struct C : public B, public virtual A {};  	 B is a baseclass of C; A is a virtual baseclass for C.  This is a C++ 	 2.0 language feature.  */
name|int
name|via_virtual
decl_stmt|;
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
name|n_baseclasses
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|baseclass_vec
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
operator|(
name|n_baseclasses
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
operator|*
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'\\'
condition|)
operator|*
name|pp
operator|=
name|next_symbol_text
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
condition|)
block|{
case|case
literal|'0'
case|:
name|via_virtual
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|via_virtual
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid symbol data: bad visibility format at symtab pos %d"
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
condition|)
block|{
case|case
literal|'0'
case|:
name|via_public
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|via_public
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid symbol data: bad visibility format at symtab pos %d."
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
block|}
comment|/* Offset of the portion of the object corresponding to 	     this baseclass.  Always zero in the absence of 	     multiple inheritance.  */
name|offset
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|baseclass
operator|=
name|read_type
argument_list|(
name|pp
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
comment|/* skip trailing ';' */
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
specifier|static
name|int
name|error_printed
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|error_printed
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nWarning:  GDB has limited understanding of multiple inheritance..."
argument_list|)
expr_stmt|;
name|error_printed
operator|=
literal|1
expr_stmt|;
block|}
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|baseclass_vec
index|[
name|i
index|]
operator|=
name|lookup_basetype_type
argument_list|(
name|baseclass
argument_list|,
name|offset
argument_list|,
name|via_virtual
argument_list|,
name|via_public
argument_list|)
expr_stmt|;
comment|/* Since lookup_basetype_type can copy the type, 	     it might copy a stub type (complete with stub flag). 	     If so, we need to add it to the list of undefined types 	     to clean up later.  Even if lookup_basetype_type 	     didn't copy the type, adding it to the undefined list 	     will not do any harm.  */
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|baseclass_vec
index|[
name|i
index|]
argument_list|)
operator|&
name|TYPE_FLAG_STUB
condition|)
name|add_undefined_type
argument_list|(
name|baseclass_vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Make this baseclass visible for structure-printing purposes.  */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|type
operator|=
name|baseclass_vec
index|[
name|i
index|]
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|TYPE_NAME
argument_list|(
name|baseclass_vec
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|bitpos
operator|=
name|offset
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|bitsize
operator|=
literal|0
expr_stmt|;
comment|/* this should be an unpacked field! */
name|nfields
operator|++
expr_stmt|;
block|}
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|=
name|n_baseclasses
expr_stmt|;
name|TYPE_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|=
name|baseclass_vec
expr_stmt|;
block|}
comment|/* Now come the fields, as NAME:?TYPENUM,BITPOS,BITSIZE; for each one.      At the end, we see a semicolon instead of a field.       In C++, this may wind up being NAME:?TYPENUM:PHYSNAME; for      a static field.       The `?' is a placeholder for one of '+' (public visibility),      '0' (protected visibility), and '-' (private visibility).  */
comment|/* We better set p right now, in case there are no fields at all...    */
name|p
operator|=
operator|*
name|pp
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
block|{
name|int
name|visibility
decl_stmt|;
comment|/* Check for and handle cretinous dbx symbol name continuation!  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'\\'
condition|)
operator|*
name|pp
operator|=
name|next_symbol_text
argument_list|()
expr_stmt|;
comment|/* Get space to record the next field's data.  */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
comment|/* Get the field name.  */
name|p
operator|=
operator|*
name|pp
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|obsavestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|)
expr_stmt|;
comment|/* C++: Check to see if we have hit the methods yet.  */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
break|break;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* This means we have a visibility for a field coming. */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'/'
condition|)
block|{
switch|switch
condition|(
operator|*
operator|++
operator|*
name|pp
condition|)
block|{
case|case
literal|'0'
case|:
name|visibility
operator|=
literal|0
expr_stmt|;
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|visibility
operator|=
literal|1
expr_stmt|;
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|visibility
operator|=
literal|2
expr_stmt|;
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* else normal dbx-style format.  */
name|list
operator|->
name|field
operator|.
name|type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|':'
condition|)
block|{
name|list
operator|->
name|field
operator|.
name|bitpos
operator|=
operator|(
name|long
operator|)
operator|-
literal|1
expr_stmt|;
name|p
operator|=
operator|++
operator|(
operator|*
name|pp
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|';'
condition|)
name|p
operator|++
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|bitsize
operator|=
operator|(
name|long
operator|)
name|savestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|nfields
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
name|error
argument_list|(
literal|"Invalid symbol data: bad structure-type format at symtab pos %d."
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* Skip the comma.  */
name|list
operator|->
name|field
operator|.
name|bitpos
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|bitsize
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This is wrong because this is identical to the symbols 	 produced for GCC 0-size arrays.  For example:          typedef union { 	   int num; 	   char str[0]; 	 } foo; 	 The code which dumped core in such circumstances should be 	 fixed not to dump core.  */
comment|/* g++ -g0 can put out bitpos& bitsize zero for a static 	 field.  This does not give us any way of getting its 	 class, so we can't know its name.  But we can just 	 ignore the field so we don't dump core and other nasty 	 stuff.  */
block|if (list->field.bitpos == 0&& list->field.bitsize == 0) 	{
comment|/* Have we given the warning yet?  */
block|static int warning_given = 0;
comment|/* Only give the warning once, no matter how many class 	     variables there are.  */
block|if (!warning_given) 	    { 	      warning_given = 1; 	      fprintf_filtered (stderr, "\n\ Warning:  DBX-style class variable debugging information encountered.\n\ You seem to have compiled your program with \ \"g++ -g0\" instead of \"g++ -g\".\n\ Therefore GDB will not know about your class variables.\n\ "); 	    }
comment|/* Ignore this field.  */
block|list = list->next; 	}       else
endif|#
directive|endif
comment|/* 0 */
block|{
comment|/* Detect an unpacked field and mark it as such. 	     dbx gives a bit size for all fields. 	     Note that forward refs cannot be packed, 	     and treat enums as if they had the width of ints.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|list
operator|->
name|field
operator|.
name|type
argument_list|)
operator|!=
name|TYPE_CODE_INT
operator|&&
name|TYPE_CODE
argument_list|(
name|list
operator|->
name|field
operator|.
name|type
argument_list|)
operator|!=
name|TYPE_CODE_ENUM
condition|)
name|list
operator|->
name|field
operator|.
name|bitsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|list
operator|->
name|field
operator|.
name|bitsize
operator|==
literal|8
operator|*
name|TYPE_LENGTH
argument_list|(
name|list
operator|->
name|field
operator|.
name|type
argument_list|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|list
operator|->
name|field
operator|.
name|type
argument_list|)
operator|==
name|TYPE_CODE_ENUM
operator|&&
operator|(
name|list
operator|->
name|field
operator|.
name|bitsize
operator|==
literal|8
operator|*
name|TYPE_LENGTH
argument_list|(
name|builtin_type_int
argument_list|)
operator|)
operator|)
operator|)
operator|&&
name|list
operator|->
name|field
operator|.
name|bitpos
operator|%
literal|8
operator|==
literal|0
condition|)
name|list
operator|->
name|field
operator|.
name|bitsize
operator|=
literal|0
expr_stmt|;
name|nfields
operator|++
expr_stmt|;
block|}
block|}
comment|/* Now come the method fields, as NAME::methods      where each method is of the form TYPENUM,ARGS,...:PHYSNAME;      At the end, we see a semicolon instead of a field.       For the case of overloaded operators, the format is      OPERATOR::*.methods, where OPERATOR is the string "operator",      `*' holds the place for an operator name (such as `+=')      and `.' marks the end of the operator name.  */
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* Now, read in the methods.  To simplify matters, we 	 "unread" the name that has been read, so that we can 	 start from the top.  */
name|p
operator|=
operator|*
name|pp
expr_stmt|;
comment|/* chill the list of fields: the last entry (at the head)          is a partially constructed entry which we now scrub.  */
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
comment|/* For each list of method lists... */
do|do
block|{
name|int
name|i
decl_stmt|;
name|struct
name|next_fnfield
modifier|*
name|sublist
init|=
literal|0
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|fn_fields
init|=
literal|0
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
name|struct
name|next_fnfieldlist
modifier|*
name|new_mainlist
init|=
operator|(
expr|struct
name|next_fnfieldlist
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|next_fnfieldlist
argument_list|)
argument_list|)
decl_stmt|;
comment|/* read in the name.  */
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|pp
operator|)
index|[
literal|0
index|]
operator|==
literal|'o'
operator|&&
operator|(
operator|*
name|pp
operator|)
index|[
literal|1
index|]
operator|==
literal|'p'
operator|&&
operator|(
operator|*
name|pp
operator|)
index|[
literal|2
index|]
operator|==
literal|'$'
condition|)
block|{
specifier|static
name|char
name|opname
index|[]
init|=
literal|"operator"
decl_stmt|;
name|char
modifier|*
name|o
init|=
name|opname
operator|+
name|strlen
argument_list|(
name|opname
argument_list|)
decl_stmt|;
comment|/* Skip past '::'.  */
name|p
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'.'
condition|)
operator|*
name|o
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|new_mainlist
operator|->
name|fn_fieldlist
operator|.
name|name
operator|=
name|savestring
argument_list|(
name|opname
argument_list|,
name|o
operator|-
name|opname
argument_list|)
expr_stmt|;
comment|/* Skip past '.'  */
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|new_mainlist
operator|->
name|fn_fieldlist
operator|.
name|name
operator|=
name|savestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|)
expr_stmt|;
comment|/* Skip past '::'.  */
operator|*
name|pp
operator|=
name|p
operator|+
literal|2
expr_stmt|;
block|}
do|do
block|{
name|struct
name|next_fnfield
modifier|*
name|new_sublist
init|=
operator|(
expr|struct
name|next_fnfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|next_fnfield
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Check for and handle cretinous dbx symbol name continuation!  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'\\'
condition|)
operator|*
name|pp
operator|=
name|next_symbol_text
argument_list|()
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|':'
condition|)
name|error
argument_list|(
literal|"invalid symtab info for method at symbol number %d."
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|args
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|new_sublist
operator|->
name|fn_field
operator|.
name|type
argument_list|)
expr_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|';'
condition|)
name|p
operator|++
expr_stmt|;
name|new_sublist
operator|->
name|fn_field
operator|.
name|physname
operator|=
name|savestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|new_sublist
operator|->
name|visibility
operator|=
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'\\'
condition|)
operator|*
name|pp
operator|=
name|next_symbol_text
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
condition|)
block|{
case|case
literal|'*'
case|:
comment|/* virtual member function, followed by index.  */
name|new_sublist
operator|->
name|fn_field
operator|.
name|voffset
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
comment|/* static member function.  */
name|new_sublist
operator|->
name|fn_field
operator|.
name|voffset
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* **pp == '.'.  */
comment|/* normal member function.  */
name|new_sublist
operator|->
name|fn_field
operator|.
name|voffset
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|new_sublist
operator|->
name|next
operator|=
name|sublist
expr_stmt|;
name|sublist
operator|=
name|new_sublist
expr_stmt|;
name|length
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
do|;
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
name|new_mainlist
operator|->
name|fn_fieldlist
operator|.
name|fn_fields
operator|=
operator|(
expr|struct
name|fn_field
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_field
argument_list|)
operator|*
name|length
argument_list|)
expr_stmt|;
name|TYPE_FN_PRIVATE_BITS
argument_list|(
name|new_mainlist
operator|->
name|fn_fieldlist
argument_list|)
operator|=
operator|(
name|int
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
literal|1
operator|+
operator|(
name|length
operator|>>
literal|5
operator|)
operator|)
argument_list|)
expr_stmt|;
name|TYPE_FN_PROTECTED_BITS
argument_list|(
name|new_mainlist
operator|->
name|fn_fieldlist
argument_list|)
operator|=
operator|(
name|int
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
literal|1
operator|+
operator|(
name|length
operator|>>
literal|5
operator|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|length
init|;
name|sublist
condition|;
name|sublist
operator|=
name|sublist
operator|->
name|next
control|)
block|{
name|new_mainlist
operator|->
name|fn_fieldlist
operator|.
name|fn_fields
index|[
operator|--
name|i
index|]
operator|=
name|sublist
operator|->
name|fn_field
expr_stmt|;
if|if
condition|(
name|sublist
operator|->
name|visibility
operator|==
literal|0
condition|)
name|B_SET
argument_list|(
name|new_mainlist
operator|->
name|fn_fieldlist
operator|.
name|private_fn_field_bits
argument_list|,
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sublist
operator|->
name|visibility
operator|==
literal|1
condition|)
name|B_SET
argument_list|(
name|new_mainlist
operator|->
name|fn_fieldlist
operator|.
name|protected_fn_field_bits
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|new_mainlist
operator|->
name|fn_fieldlist
operator|.
name|length
operator|=
name|length
expr_stmt|;
name|new_mainlist
operator|->
name|next
operator|=
name|mainlist
expr_stmt|;
name|mainlist
operator|=
name|new_mainlist
expr_stmt|;
name|nfn_fields
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|';'
condition|)
do|;
block|}
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
comment|/* Now create the vector of fields, and record how big it is.  */
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nfields
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|int
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
literal|1
operator|+
operator|(
name|nfields
operator|>>
literal|5
operator|)
operator|)
argument_list|)
expr_stmt|;
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|int
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
operator|(
literal|1
operator|+
operator|(
name|nfields
operator|>>
literal|5
operator|)
operator|)
argument_list|)
expr_stmt|;
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nfn_fields
expr_stmt|;
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|type
argument_list|)
operator|=
name|nfn_fields
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
operator|++
name|i
control|)
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|type
argument_list|)
operator|+=
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|TYPE_FN_FIELDLISTS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|fn_fieldlist
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_fieldlist
argument_list|)
operator|*
name|nfn_fields
argument_list|)
expr_stmt|;
comment|/* Copy the saved-up fields into the field vector.  */
for|for
control|(
name|n
operator|=
name|nfields
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
name|TYPE_FIELD
argument_list|(
name|type
argument_list|,
operator|--
name|n
argument_list|)
operator|=
name|list
operator|->
name|field
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|visibility
operator|==
literal|0
condition|)
name|SET_TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|list
operator|->
name|visibility
operator|==
literal|1
condition|)
name|SET_TYPE_FIELD_PROTECTED
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
name|nfn_fields
init|;
name|mainlist
condition|;
name|mainlist
operator|=
name|mainlist
operator|->
name|next
control|)
name|TYPE_FN_FIELDLISTS
argument_list|(
name|type
argument_list|)
index|[
operator|--
name|n
index|]
operator|=
name|mainlist
operator|->
name|fn_fieldlist
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'~'
condition|)
block|{
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'='
condition|)
block|{
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_HAS_CONSTRUCTOR
operator||
name|TYPE_FLAG_HAS_DESTRUCTOR
expr_stmt|;
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'+'
condition|)
block|{
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_HAS_CONSTRUCTOR
expr_stmt|;
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'-'
condition|)
block|{
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_HAS_DESTRUCTOR
expr_stmt|;
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Read either a '%' or the final ';'.  */
if|if
condition|(
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|==
literal|'%'
condition|)
block|{
comment|/* Now we must record the virtual function table pointer's 	     field information.  */
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
name|t
operator|=
name|read_type
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|';'
condition|)
name|p
operator|++
expr_stmt|;
name|TYPE_VPTR_BASETYPE
argument_list|(
name|type
argument_list|)
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|t
condition|)
block|{
if|if
condition|(
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|=
name|i
operator|=
literal|0
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
operator|*
name|pp
argument_list|,
name|strlen
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"virtual function table field not found"
argument_list|)
expr_stmt|;
block|}
else|else
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_VPTR_FIELDNO
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|TYPE_VPTR_BASETYPE
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|TYPE_VPTR_BASETYPE
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Read a definition of an array type,    and create and return a suitable type object.    Also creates a range type which represents the bounds of that    array.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_array_type
parameter_list|(
name|pp
parameter_list|,
name|type
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|index_type
decl_stmt|,
modifier|*
name|element_type
decl_stmt|,
modifier|*
name|range_type
decl_stmt|;
name|int
name|lower
decl_stmt|,
name|upper
decl_stmt|;
name|int
name|adjustable
init|=
literal|0
decl_stmt|;
comment|/* Format of an array type:      "ar<index type>;lower;upper;<array_contents_type>".  Put code in      to handle this.       Fortran adjustable arrays use Adigits or Tdigits for lower or upper;      for these, produce a type like float[][].  */
name|index_type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
operator|*
name|pp
operator|)
operator|++
operator|!=
literal|';'
condition|)
name|error
argument_list|(
literal|"Invalid symbol data; improper format of array type decl."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
operator|*
name|pp
operator|>=
literal|'0'
operator|&&
operator|*
operator|*
name|pp
operator|<=
literal|'9'
operator|)
condition|)
block|{
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
name|adjustable
operator|=
literal|1
expr_stmt|;
block|}
name|lower
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
operator|*
name|pp
operator|>=
literal|'0'
operator|&&
operator|*
operator|*
name|pp
operator|<=
literal|'9'
operator|)
condition|)
block|{
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
name|adjustable
operator|=
literal|1
expr_stmt|;
block|}
name|upper
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
name|element_type
operator|=
name|read_type
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|adjustable
condition|)
block|{
name|lower
operator|=
literal|0
expr_stmt|;
name|upper
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|{
comment|/* Create range type.  */
name|range_type
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|range_type
argument_list|)
operator|=
name|TYPE_CODE_RANGE
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|range_type
argument_list|)
operator|=
name|index_type
expr_stmt|;
comment|/* This should never be needed.  */
name|TYPE_LENGTH
argument_list|(
name|range_type
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|range_type
argument_list|)
operator|=
literal|2
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|range_type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|range_type
argument_list|,
literal|0
argument_list|)
operator|=
name|lower
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|range_type
argument_list|,
literal|1
argument_list|)
operator|=
name|upper
expr_stmt|;
block|}
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_ARRAY
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|element_type
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|upper
operator|-
name|lower
operator|+
literal|1
operator|)
operator|*
name|TYPE_LENGTH
argument_list|(
name|element_type
argument_list|)
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
operator|=
name|range_type
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Read a definition of an enumeration type,    and create and return a suitable type object.    Also defines the symbols that represent the values of the type.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_enum_type
parameter_list|(
name|pp
parameter_list|,
name|type
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|long
name|n
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|nsyms
init|=
literal|0
decl_stmt|;
name|struct
name|pending
modifier|*
modifier|*
name|symlist
decl_stmt|;
name|struct
name|pending
modifier|*
name|osyms
decl_stmt|,
modifier|*
name|syms
decl_stmt|;
name|int
name|o_nsyms
decl_stmt|;
if|if
condition|(
name|within_function
condition|)
name|symlist
operator|=
operator|&
name|local_symbols
expr_stmt|;
else|else
name|symlist
operator|=
operator|&
name|file_symbols
expr_stmt|;
name|osyms
operator|=
operator|*
name|symlist
expr_stmt|;
name|o_nsyms
operator|=
name|osyms
condition|?
name|osyms
operator|->
name|nsyms
else|:
literal|0
expr_stmt|;
comment|/* Read the value-names and their values.      The input syntax is NAME:VALUE,NAME:VALUE, and so on.      A semicolon or comman instead of a NAME means the end.  */
while|while
condition|(
operator|*
operator|*
name|pp
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|';'
operator|&&
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
block|{
comment|/* Check for and handle cretinous dbx symbol name continuation!  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'\\'
condition|)
operator|*
name|pp
operator|=
name|next_symbol_text
argument_list|()
expr_stmt|;
name|p
operator|=
operator|*
name|pp
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
name|name
operator|=
name|obsavestring
argument_list|(
operator|*
name|pp
argument_list|,
name|p
operator|-
operator|*
name|pp
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|read_number
argument_list|(
name|pp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sym
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|name
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|n
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|symlist
argument_list|)
expr_stmt|;
name|nsyms
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
condition|)
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* Skip the semicolon.  */
comment|/* Now fill in the fields of the type-structure.  */
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nsyms
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nsyms
argument_list|)
expr_stmt|;
comment|/* Find the symbols for the values and put them into the type.      The symbols can be found in the symlist that we put them on      to cause them to be defined.  osyms contains the old value      of that symlist; everything up to there was defined by us.  */
comment|/* Note that we preserve the order of the enum constants, so      that in something like "enum {FOO, LAST_THING=FOO}" we print      FOO, not LAST_THING.  */
for|for
control|(
name|syms
operator|=
operator|*
name|symlist
operator|,
name|n
operator|=
literal|0
init|;
name|syms
condition|;
name|syms
operator|=
name|syms
operator|->
name|next
control|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|syms
operator|==
name|osyms
condition|)
name|j
operator|=
name|o_nsyms
expr_stmt|;
for|for
control|(
init|;
name|j
operator|<
name|syms
operator|->
name|nsyms
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|syms
operator|->
name|symbol
index|[
name|j
index|]
decl_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|TYPE_FIELD_VALUE
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|n
argument_list|)
operator|=
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|n
operator|++
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|syms
operator|==
name|osyms
condition|)
break|break;
block|}
return|return
name|type
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_OF_TYPE
parameter_list|(
name|t
parameter_list|)
value|((1<< (sizeof (t) - 1)) - 1)
end_define

begin_define
define|#
directive|define
name|MIN_OF_TYPE
parameter_list|(
name|t
parameter_list|)
value|(-(1<< (sizeof (t) - 1)))
end_define

begin_function
specifier|static
name|struct
name|type
modifier|*
name|read_range_type
parameter_list|(
name|pp
parameter_list|,
name|typenums
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|typenums
index|[
literal|2
index|]
decl_stmt|;
block|{
name|int
name|rangenums
index|[
literal|2
index|]
decl_stmt|;
name|long
name|n2
decl_stmt|,
name|n3
decl_stmt|;
name|int
name|n2bits
decl_stmt|,
name|n3bits
decl_stmt|;
name|int
name|self_subrange
decl_stmt|;
name|struct
name|type
modifier|*
name|result_type
decl_stmt|;
name|struct
name|type
modifier|*
name|index_type
decl_stmt|;
comment|/* First comes a type we are a subrange of.      In C it is usually 0, 1 or the type being defined.  */
name|read_type_number
argument_list|(
name|pp
argument_list|,
name|rangenums
argument_list|)
expr_stmt|;
name|self_subrange
operator|=
operator|(
name|rangenums
index|[
literal|0
index|]
operator|==
name|typenums
index|[
literal|0
index|]
operator|&&
name|rangenums
index|[
literal|1
index|]
operator|==
name|typenums
index|[
literal|1
index|]
operator|)
expr_stmt|;
comment|/* A semicolon should now follow; skip it.  */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|';'
condition|)
operator|(
operator|*
name|pp
operator|)
operator|++
expr_stmt|;
comment|/* The remaining two operands are usually lower and upper bounds      of the range.  But in some special cases they mean something else.  */
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|n2
argument_list|,
operator|&
name|n2bits
argument_list|)
expr_stmt|;
name|read_huge_number
argument_list|(
name|pp
argument_list|,
literal|';'
argument_list|,
operator|&
name|n3
argument_list|,
operator|&
name|n3bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|n2bits
operator|==
operator|-
literal|1
operator|||
name|n3bits
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Unrecognized type range %s."
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n2bits
operator|!=
literal|0
operator|||
name|n3bits
operator|!=
literal|0
condition|)
ifdef|#
directive|ifdef
name|LONG_LONG
block|{
name|char
name|got_signed
init|=
literal|0
decl_stmt|;
name|char
name|got_unsigned
init|=
literal|0
decl_stmt|;
comment|/* Number of bits in the type.  */
name|int
name|nbits
decl_stmt|;
comment|/* Range from 0 to<large number> is an unsigned large integral type.  */
if|if
condition|(
operator|(
name|n2bits
operator|==
literal|0
operator|&&
name|n2
operator|==
literal|0
operator|)
operator|&&
name|n3bits
operator|!=
literal|0
condition|)
block|{
name|got_unsigned
operator|=
literal|1
expr_stmt|;
name|nbits
operator|=
name|n3bits
expr_stmt|;
block|}
comment|/* Range fro<large number> to<large number>-1 is a large signed 	 integral type.  */
elseif|else
if|if
condition|(
name|n2bits
operator|!=
literal|0
operator|&&
name|n3bits
operator|!=
literal|0
operator|&&
name|n2bits
operator|==
name|n3bits
operator|+
literal|1
condition|)
block|{
name|got_signed
operator|=
literal|1
expr_stmt|;
name|nbits
operator|=
name|n2bits
expr_stmt|;
block|}
comment|/* Check for "long long".  */
if|if
condition|(
name|got_signed
operator|&&
name|nbits
operator|==
name|CHAR_BIT
operator|*
expr|sizeof
operator|(
name|long
name|long
operator|)
condition|)
return|return
name|builtin_type_long_long
return|;
if|if
condition|(
name|got_unsigned
operator|&&
name|nbits
operator|==
name|CHAR_BIT
operator|*
expr|sizeof
operator|(
name|long
name|long
operator|)
condition|)
return|return
name|builtin_type_unsigned_long_long
return|;
name|error
argument_list|(
literal|"Large type isn't a long long."
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* LONG_LONG */
name|error
argument_list|(
literal|"Type long long not supported on this machine."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* A type defined as a subrange of itself, with bounds both 0, is void.  */
if|if
condition|(
name|self_subrange
operator|&&
name|n2
operator|==
literal|0
operator|&&
name|n3
operator|==
literal|0
condition|)
return|return
name|builtin_type_void
return|;
comment|/* If n3 is zero and n2 is not, we want a floating type,      and n2 is the width in bytes.       Fortran programs appear to use this for complex types also,      and they give no way to distinguish between double and single-complex!      We don't have complex types, so we would lose on all fortran files!      So return type `double' for all of those.  It won't work right      for the complex values, but at least it makes the file loadable.  */
if|if
condition|(
name|n3
operator|==
literal|0
operator|&&
name|n2
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|n2
operator|==
sizeof|sizeof
argument_list|(
name|float
argument_list|)
condition|)
return|return
name|builtin_type_float
return|;
return|return
name|builtin_type_double
return|;
block|}
comment|/* If the upper bound is -1, it must really be an unsigned int.  */
elseif|else
if|if
condition|(
name|n2
operator|==
literal|0
operator|&&
name|n3
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
return|return
name|builtin_type_unsigned_int
return|;
else|else
return|return
name|builtin_type_unsigned_long
return|;
block|}
comment|/* Special case: char is defined (Who knows why) as a subrange of      itself with range 0-127.  */
elseif|else
if|if
condition|(
name|self_subrange
operator|&&
name|n2
operator|==
literal|0
operator|&&
name|n3
operator|==
literal|127
condition|)
return|return
name|builtin_type_char
return|;
comment|/* Assumptions made here: Subrange of self is equivalent to subrange      of int.  */
elseif|else
if|if
condition|(
name|n2
operator|==
literal|0
operator|&&
operator|(
name|self_subrange
operator|||
operator|*
name|dbx_lookup_type
argument_list|(
name|rangenums
argument_list|)
operator|==
name|builtin_type_int
operator|)
condition|)
block|{
comment|/* an unsigned type */
if|if
condition|(
name|n3
operator|==
name|UINT_MAX
condition|)
return|return
name|builtin_type_unsigned_int
return|;
if|if
condition|(
name|n3
operator|==
name|ULONG_MAX
condition|)
return|return
name|builtin_type_unsigned_long
return|;
if|if
condition|(
name|n3
operator|==
name|USHRT_MAX
condition|)
return|return
name|builtin_type_unsigned_short
return|;
if|if
condition|(
name|n3
operator|==
name|UCHAR_MAX
condition|)
return|return
name|builtin_type_unsigned_char
return|;
block|}
ifdef|#
directive|ifdef
name|LONG_LONG
elseif|else
if|if
condition|(
name|n3
operator|==
literal|0
operator|&&
name|n2
operator|==
operator|-
expr|sizeof
operator|(
name|long
name|long
operator|)
condition|)
return|return
name|builtin_type_long_long
return|;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|n2
operator|==
operator|-
name|n3
operator|-
literal|1
condition|)
block|{
comment|/* a signed type */
if|if
condition|(
name|n3
operator|==
name|INT_MAX
condition|)
return|return
name|builtin_type_int
return|;
if|if
condition|(
name|n3
operator|==
name|LONG_MAX
condition|)
return|return
name|builtin_type_long
return|;
if|if
condition|(
name|n3
operator|==
name|SHRT_MAX
condition|)
return|return
name|builtin_type_short
return|;
if|if
condition|(
name|n3
operator|==
name|CHAR_MAX
condition|)
return|return
name|builtin_type_char
return|;
block|}
comment|/* We have a real range type on our hands.  Allocate space and      return a real pointer.  */
comment|/* At this point I don't have the faintest idea how to deal with      a self_subrange type; I'm going to assume that this is used      as an idiom, and that all of them are special cases.  So . . .  */
if|if
condition|(
name|self_subrange
condition|)
name|error
argument_list|(
literal|"Type defined as subrange of itself: %s."
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|result_type
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|result_type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|result_type
argument_list|)
operator|=
operator|(
name|self_subrange
condition|?
name|builtin_type_int
else|:
operator|*
name|dbx_lookup_type
argument_list|(
name|rangenums
argument_list|)
operator|)
expr_stmt|;
comment|/* We have to figure out how many bytes it takes to hold this      range type.  I'm going to assume that anything that is pushing      the bounds of a long was taken care of above.  */
if|if
condition|(
name|n2
operator|>=
name|MIN_OF_TYPE
argument_list|(
name|char
argument_list|)
operator|&&
name|n3
operator|<=
name|MAX_OF_TYPE
argument_list|(
name|char
argument_list|)
condition|)
name|TYPE_LENGTH
argument_list|(
name|result_type
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|n2
operator|>=
name|MIN_OF_TYPE
argument_list|(
name|short
argument_list|)
operator|&&
name|n3
operator|<=
name|MAX_OF_TYPE
argument_list|(
name|short
argument_list|)
condition|)
name|TYPE_LENGTH
argument_list|(
name|result_type
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n2
operator|>=
name|MIN_OF_TYPE
argument_list|(
name|int
argument_list|)
operator|&&
name|n3
operator|<=
name|MAX_OF_TYPE
argument_list|(
name|int
argument_list|)
condition|)
name|TYPE_LENGTH
argument_list|(
name|result_type
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n2
operator|>=
name|MIN_OF_TYPE
argument_list|(
name|long
argument_list|)
operator|&&
name|n3
operator|<=
name|MAX_OF_TYPE
argument_list|(
name|long
argument_list|)
condition|)
name|TYPE_LENGTH
argument_list|(
name|result_type
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Ranged type doesn't fit within known sizes."
argument_list|)
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|result_type
argument_list|)
operator|=
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|result_type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|result_type
argument_list|)
operator|=
name|TYPE_CODE_RANGE
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|result_type
argument_list|)
operator|=
literal|2
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|result_type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|symbol_obstack
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|result_type
argument_list|)
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|result_type
argument_list|,
literal|0
argument_list|)
operator|=
name|n2
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|result_type
argument_list|,
literal|1
argument_list|)
operator|=
name|n3
expr_stmt|;
return|return
name|result_type
return|;
block|}
end_function

begin_comment
comment|/* Read a number from the string pointed to by *PP.    The value of *PP is advanced over the number.    If END is nonzero, the character that ends the    number must match END, or an error happens;    and that character is skipped if it does match.    If END is zero, *PP is left pointing to that character.  */
end_comment

begin_function
specifier|static
name|long
name|read_number
parameter_list|(
name|pp
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|end
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
specifier|register
name|long
name|n
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|sign
init|=
literal|1
decl_stmt|;
comment|/* Handle an optional leading minus sign.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/* Read the digits, as far as they go.  */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|n
operator|*=
literal|10
expr_stmt|;
name|n
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|end
condition|)
block|{
if|if
condition|(
name|c
operator|&&
name|c
operator|!=
name|end
condition|)
name|error
argument_list|(
literal|"Invalid symbol data: invalid character \\%03o at symbol pos %d."
argument_list|,
name|c
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
block|}
else|else
operator|--
name|p
expr_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
return|return
name|n
operator|*
name|sign
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_huge_number
parameter_list|(
name|pp
parameter_list|,
name|end
parameter_list|,
name|valu
parameter_list|,
name|bits
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|end
decl_stmt|;
name|long
modifier|*
name|valu
decl_stmt|;
name|int
modifier|*
name|bits
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
name|int
name|sign
init|=
literal|1
decl_stmt|;
name|long
name|n
init|=
literal|0
decl_stmt|;
name|int
name|radix
init|=
literal|10
decl_stmt|;
name|char
name|overflow
init|=
literal|0
decl_stmt|;
name|int
name|nbits
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|long
name|upper_limit
decl_stmt|;
comment|/* Handle an optional leading minus sign.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/* Leading zero means octal.  GCC uses this to output values larger      than an int (because that would be hard in decimal).  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'0'
condition|)
block|{
name|radix
operator|=
literal|8
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|upper_limit
operator|=
name|LONG_MAX
operator|/
name|radix
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
if|if
condition|(
name|n
operator|<=
name|upper_limit
condition|)
block|{
name|n
operator|*=
name|radix
expr_stmt|;
name|n
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
name|overflow
operator|=
literal|1
expr_stmt|;
comment|/* This depends on large values being output in octal, which is 	 what GCC does. */
if|if
condition|(
name|radix
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|nbits
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
comment|/* Ignore leading zeroes.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'1'
condition|)
name|nbits
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'2'
operator|||
name|c
operator|==
literal|'3'
condition|)
name|nbits
operator|=
literal|2
expr_stmt|;
else|else
name|nbits
operator|=
literal|3
expr_stmt|;
block|}
else|else
name|nbits
operator|+=
literal|3
expr_stmt|;
block|}
block|}
if|if
condition|(
name|end
condition|)
block|{
if|if
condition|(
name|c
operator|&&
name|c
operator|!=
name|end
condition|)
block|{
if|if
condition|(
name|bits
operator|!=
name|NULL
condition|)
operator|*
name|bits
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
block|}
else|else
operator|--
name|p
expr_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|overflow
condition|)
block|{
if|if
condition|(
name|nbits
operator|==
literal|0
condition|)
block|{
comment|/* Large decimal constants are an error (because it is hard to 	     count how many bits are in them).  */
if|if
condition|(
name|bits
operator|!=
name|NULL
condition|)
operator|*
name|bits
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
comment|/* -0x7f is the same as 0x80.  So deal with it by adding one to 	 the number of bits.  */
if|if
condition|(
name|sign
operator|==
operator|-
literal|1
condition|)
operator|++
name|nbits
expr_stmt|;
if|if
condition|(
name|bits
condition|)
operator|*
name|bits
operator|=
name|nbits
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|valu
condition|)
operator|*
name|valu
operator|=
name|n
operator|*
name|sign
expr_stmt|;
if|if
condition|(
name|bits
condition|)
operator|*
name|bits
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read in an argument list. This is a list of types. It is terminated with    a ':', FYI. Return the list of types read in. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|read_args
parameter_list|(
name|pp
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|end
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|types
index|[
literal|1024
index|]
decl_stmt|,
modifier|*
modifier|*
name|rval
decl_stmt|;
comment|/* allow for fns of 1023 parameters */
name|int
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
operator|*
name|pp
operator|!=
name|end
condition|)
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|','
condition|)
name|error
argument_list|(
literal|"Invalid argument list: no ',', at symtab pos %d"
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
comment|/* Check for and handle cretinous dbx symbol name continuation! */
if|if
condition|(
operator|*
operator|*
name|pp
operator|==
literal|'\\'
condition|)
operator|*
name|pp
operator|=
name|next_symbol_text
argument_list|()
expr_stmt|;
name|types
index|[
name|n
operator|++
index|]
operator|=
name|read_type
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
operator|*
name|pp
operator|+=
literal|1
expr_stmt|;
comment|/* get past `end' (the ':' character) */
if|if
condition|(
name|n
operator|==
literal|1
condition|)
block|{
name|rval
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|types
index|[
name|n
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|TYPE_CODE_VOID
condition|)
block|{
name|rval
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|rval
operator|+
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rval
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|types
argument_list|,
name|rval
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* This function is really horrible, but to avoid it, there would need    to be more filling in of forward references.  THIS SHOULD BE MOVED OUT    OF COFFREAD.C AND DBXREAD.C TO SOME PLACE WHERE IT CAN BE SHARED */
end_comment

begin_function
name|int
name|fill_in_vptr_fieldno
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|<
literal|0
condition|)
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|=
name|fill_in_vptr_fieldno
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy a pending list, used to record the contents of a common    block for later fixup. BUG FIX by rde@topexpress.co.uk */
end_comment

begin_function
specifier|static
name|struct
name|pending
modifier|*
name|copy_pending
parameter_list|(
name|beg
parameter_list|,
name|begi
parameter_list|,
name|end
parameter_list|)
name|struct
name|pending
modifier|*
name|beg
decl_stmt|,
decl|*
name|end
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|begi
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|pending
modifier|*
name|new
init|=
literal|0
decl_stmt|;
name|struct
name|pending
modifier|*
name|next
decl_stmt|;
comment|/* rde note: `begi' is an offset in block `end', NOT `beg' */
for|for
control|(
name|next
operator|=
name|beg
init|;
name|next
operator|!=
literal|0
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|next
operator|==
name|end
condition|?
name|begi
else|:
literal|0
init|;
name|j
operator|<
name|next
operator|->
name|nsyms
condition|;
name|j
operator|++
control|)
name|add_symbol_to_list
argument_list|(
name|next
operator|->
name|symbol
index|[
name|j
index|]
argument_list|,
operator|&
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|end
condition|)
break|break;
block|}
return|return
name|new
return|;
block|}
end_block

begin_comment
comment|/* Add a common block's start address to the offset of each symbol    declared to be in it (by being between a BCOMM/ECOMM pair that uses    the common block name).  */
end_comment

begin_function
specifier|static
name|void
name|fix_common_block
parameter_list|(
name|sym
parameter_list|,
name|value
parameter_list|)
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|value
decl_stmt|;
block|{
name|struct
name|pending
modifier|*
name|next
init|=
operator|(
expr|struct
name|pending
operator|*
operator|)
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|next
operator|->
name|nsyms
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
name|SYMBOL_VALUE
argument_list|(
name|next
operator|->
name|symbol
index|[
name|j
index|]
argument_list|)
operator|+=
name|value
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_dbxread
parameter_list|()
block|{
name|symfile
operator|=
literal|0
expr_stmt|;
name|header_files
operator|=
operator|(
expr|struct
name|header_file
operator|*
operator|)
literal|0
expr_stmt|;
name|this_object_header_files
operator|=
operator|(
name|int
operator|*
operator|)
literal|0
expr_stmt|;
name|undef_types_allocated
operator|=
literal|20
expr_stmt|;
name|undef_types_length
operator|=
literal|0
expr_stmt|;
name|undef_types
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|undef_types_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"symbol-file"
argument_list|,
name|class_files
argument_list|,
name|symbol_file_command
argument_list|,
literal|"Load symbol table (in dbx format) from executable file FILE."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"add-file"
argument_list|,
name|class_files
argument_list|,
name|add_file_command
argument_list|,
literal|"Load the symbols from FILE, assuming its code is at TEXT_START."
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* READ_DBX_FORMAT */
end_comment

end_unit

