begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  * Modified 1990 by Van Jacobson at Lawrence Berkeley Laboratory.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)stack.c	6.3 (Berkeley) 5/8/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Print and select stack frames for GDB, the GNU debugger.    Copyright (C) 1986, 1987, 1989 Free Software Foundation, Inc.  This file is part of GDB.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* modified by rjc Thu Nov  1 16:46:57 1990, fixed return_command so that    it can return values, it still has problems when running on pmax,    cannot write register 65 */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_comment
comment|/* Thie "selected" stack frame is used by default for local and arg access.    May be zero, for no selected frame.  */
end_comment

begin_decl_stmt
name|FRAME
name|selected_frame
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Level of the selected frame:    0 for innermost, 1 for its caller, ...    or -1 for frame specified by address with no defined level.  */
end_comment

begin_decl_stmt
name|int
name|selected_frame_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means print the full filename and linenumber    when a frame is printed, and do so in a format programs can parse.  */
end_comment

begin_decl_stmt
name|int
name|frame_file_full_name
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|select_calling_frame
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_frame_info
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Print a stack frame briefly.  FRAME should be the frame id    and LEVEL should be its level in the stack (or -1 for level not defined).    This prints the level, the function executing, the arguments,    and the file name and line number.    If the pc is not at the beginning of the source line,    the actual pc is printed at the beginning.     If SOURCE is 1, print the source line as well.    If SOURCE is -1, print ONLY the source line.  */
end_comment

begin_function
specifier|static
name|void
name|print_stack_frame
parameter_list|(
name|frame
parameter_list|,
name|level
parameter_list|,
name|source
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|source
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|print_frame_info
argument_list|(
name|fi
argument_list|,
name|level
argument_list|,
name|source
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flag which will indicate when the frame has been changed    by and "up" or "down" command.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|frame_changed
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|print_frame_info
parameter_list|(
name|fi
parameter_list|,
name|level
parameter_list|,
name|source
parameter_list|,
name|args
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
specifier|register
name|int
name|level
decl_stmt|;
name|int
name|source
decl_stmt|;
name|int
name|args
decl_stmt|;
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|symbol
modifier|*
name|func
decl_stmt|;
specifier|register
name|char
modifier|*
name|funname
init|=
literal|0
decl_stmt|;
name|int
name|numargs
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
comment|/* Don't give very much information if we haven't readin the      symbol table yet.  */
name|pst
operator|=
name|find_pc_psymtab
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pst
operator|&&
operator|!
name|pst
operator|->
name|readin
condition|)
block|{
comment|/* Abbreviated information.  */
name|char
modifier|*
name|fname
decl_stmt|;
if|if
condition|(
operator|!
name|find_pc_partial_function
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
condition|)
name|fname
operator|=
literal|"??"
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"#%-2d "
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"0x%x in "
argument_list|,
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
name|fputs_demangled
argument_list|(
name|fname
argument_list|,
name|stdout
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" (...)\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
name|sal
operator|=
name|find_pc_line
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|next_frame
argument_list|)
expr_stmt|;
name|func
operator|=
name|find_pc_function
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
block|{
comment|/* In certain pathological cases, the symtabs give the wrong 	 function (when we are in the first function in a file which 	 is compiled without debugging symbols, the previous function 	 is compiled with debugging symbols, and the "foo.o" symbol 	 that is supposed to tell us where the file with debugging symbols 	 ends has been truncated by ar because it is longer than 15 	 characters).  	 So look in the misc_function_vector as well, and if it comes 	 up with a larger address for the function use that instead. 	 I don't think this can ever cause any problems; 	 there shouldn't be any 	 misc_function_vector symbols in the middle of a function.  */
name|int
name|misc_index
init|=
name|find_pc_misc_function
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|misc_index
operator|>=
literal|0
operator|&&
operator|(
name|misc_function_vector
index|[
name|misc_index
index|]
operator|.
name|address
operator|>
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|func
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* In this case we have no way of knowing the source file 	     and line number, so don't print them.  */
name|sal
operator|.
name|symtab
operator|=
literal|0
expr_stmt|;
comment|/* We also don't know anything about the function besides 	     its address and name.  */
name|func
operator|=
literal|0
expr_stmt|;
name|funname
operator|=
name|misc_function_vector
index|[
name|misc_index
index|]
operator|.
name|name
expr_stmt|;
block|}
else|else
name|funname
operator|=
name|SYMBOL_NAME
argument_list|(
name|func
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|int
name|misc_index
init|=
name|find_pc_misc_function
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|misc_index
operator|>=
literal|0
condition|)
name|funname
operator|=
name|misc_function_vector
index|[
name|misc_index
index|]
operator|.
name|name
expr_stmt|;
block|}
if|if
condition|(
name|frame_changed
operator|||
name|source
operator|>=
literal|0
operator|||
operator|!
name|sal
operator|.
name|symtab
condition|)
block|{
if|if
condition|(
name|level
operator|>=
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"#%-2d "
argument_list|,
name|level
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|frame_changed
condition|)
name|printf
argument_list|(
literal|"#%-2d "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|pc
operator|!=
name|sal
operator|.
name|pc
operator|||
operator|!
name|sal
operator|.
name|symtab
condition|)
name|printf_filtered
argument_list|(
literal|"0x%x in "
argument_list|,
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
name|fputs_demangled
argument_list|(
name|funname
condition|?
name|funname
else|:
literal|"??"
argument_list|,
name|stdout
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" ("
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
block|{
if|if
condition|(
name|func
condition|)
name|numargs
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|FRAME_NUM_ARGS
argument_list|(
name|numargs
argument_list|,
name|fi
argument_list|)
expr_stmt|;
name|print_frame_args
argument_list|(
name|func
argument_list|,
name|fi
argument_list|,
name|numargs
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
condition|)
name|printf_filtered
argument_list|(
literal|" (%s line %d)"
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|frame_changed
operator|||
name|source
operator|!=
literal|0
operator|)
operator|&&
name|sal
operator|.
name|symtab
condition|)
block|{
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|mid_statement
init|=
name|source
operator|<
literal|0
operator|&&
name|fi
operator|->
name|pc
operator|!=
name|sal
operator|.
name|pc
decl_stmt|;
if|if
condition|(
name|frame_file_full_name
condition|)
name|done
operator|=
name|identify_source_line
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|mid_statement
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|mid_statement
condition|)
name|printf_filtered
argument_list|(
literal|"0x%x\t"
argument_list|,
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|line
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|current_source_line
operator|=
name|max
argument_list|(
name|sal
operator|.
name|line
operator|-
literal|5
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|frame_changed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|source
operator|!=
literal|0
condition|)
name|set_default_breakpoint
argument_list|(
literal|1
argument_list|,
name|fi
operator|->
name|pc
argument_list|,
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call here to print info on selected frame, after a trap.  */
end_comment

begin_function
name|void
name|print_sel_frame
parameter_list|(
name|just_source
parameter_list|)
name|int
name|just_source
decl_stmt|;
block|{
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
operator|-
literal|1
argument_list|,
name|just_source
condition|?
operator|-
literal|1
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print info on the selected frame, including level number    but not source.  */
end_comment

begin_function
name|void
name|print_selected_frame
parameter_list|()
block|{
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
name|selected_frame_level
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|void
name|flush_cached_frames
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|FRAME_SPECIFICATION_DYADIC
end_ifdef

begin_function_decl
specifier|extern
name|FRAME
name|setup_arbitrary_frame
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Read a frame specification in whatever the appropriate format is.  */
end_comment

begin_function
specifier|static
name|FRAME
name|parse_frame_specification
parameter_list|(
name|frame_exp
parameter_list|)
name|char
modifier|*
name|frame_exp
decl_stmt|;
block|{
name|int
name|numargs
init|=
literal|0
decl_stmt|;
name|int
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
if|if
condition|(
name|frame_exp
condition|)
block|{
name|char
modifier|*
name|addr_string
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|tmp_cleanup
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fci
decl_stmt|;
while|while
condition|(
operator|*
name|frame_exp
operator|==
literal|' '
condition|)
name|frame_exp
operator|++
expr_stmt|;
for|for
control|(
name|p
operator|=
name|frame_exp
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|frame_exp
condition|)
block|{
name|numargs
operator|=
literal|1
expr_stmt|;
name|addr_string
operator|=
name|savestring
argument_list|(
name|frame_exp
argument_list|,
name|p
operator|-
name|frame_exp
argument_list|)
expr_stmt|;
block|{
name|tmp_cleanup
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|addr_string
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|parse_and_eval_address
argument_list|(
name|addr_string
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|tmp_cleanup
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|numargs
operator|=
literal|2
expr_stmt|;
name|arg2
operator|=
name|parse_and_eval_address
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
switch|switch
condition|(
name|numargs
condition|)
block|{
case|case
literal|0
case|:
return|return
name|selected_frame
return|;
comment|/* NOTREACHED */
case|case
literal|1
case|:
block|{
name|int
name|level
init|=
name|arg1
decl_stmt|;
name|FRAME
name|fid
init|=
name|find_relative_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
operator|&
name|level
argument_list|)
decl_stmt|;
name|FRAME
name|tfid
decl_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
comment|/* find_relative_frame was successful */
return|return
name|fid
return|;
comment|/* If (s)he specifies the frame with an address, he deserves what 	   (s)he gets.  Still, give the highest one that matches.  */
for|for
control|(
name|fid
operator|=
name|get_current_frame
argument_list|()
init|;
name|fid
operator|&&
name|FRAME_FP
argument_list|(
name|fid
argument_list|)
operator|!=
name|arg1
condition|;
name|fid
operator|=
name|get_prev_frame
argument_list|(
name|fid
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
name|fid
condition|)
while|while
condition|(
operator|(
name|tfid
operator|=
name|get_prev_frame
argument_list|(
name|fid
argument_list|)
operator|)
operator|&&
operator|(
name|FRAME_FP
argument_list|(
name|tfid
argument_list|)
operator|==
name|arg1
operator|)
condition|)
name|fid
operator|=
name|tfid
expr_stmt|;
ifdef|#
directive|ifdef
name|FRAME_SPECIFICATION_DYADIC
if|if
condition|(
operator|!
name|fid
condition|)
name|error
argument_list|(
literal|"Incorrect number of args in frame specification"
argument_list|)
expr_stmt|;
return|return
name|fid
return|;
else|#
directive|else
return|return
name|create_new_frame
argument_list|(
name|arg1
argument_list|,
literal|0
argument_list|)
return|;
endif|#
directive|endif
block|}
comment|/* NOTREACHED */
case|case
literal|2
case|:
comment|/* Must be addresses */
ifndef|#
directive|ifndef
name|FRAME_SPECIFICATION_DYADIC
name|error
argument_list|(
literal|"Incorrect number of args in frame specification"
argument_list|)
expr_stmt|;
else|#
directive|else
return|return
name|setup_arbitrary_frame
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
endif|#
directive|endif
comment|/* NOTREACHED */
block|}
name|fatal
argument_list|(
literal|"Internal: Error in parsing in parse_frame_specification"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/* FRAME_ARGS_ADDRESS_CORRECT is just like FRAME_ARGS_ADDRESS except    that if it is unsure about the answer, it returns Frame_unknown    instead of guessing (this happens on the VAX, for example).     On most machines, we never have to guess about the args address,    so FRAME_ARGS_ADDRESS{,_CORRECT} are the same.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FRAME_ARGS_ADDRESS_CORRECT
argument_list|)
end_if

begin_define
define|#
directive|define
name|FRAME_ARGS_ADDRESS_CORRECT
value|FRAME_ARGS_ADDRESS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Print verbosely the selected frame or the frame at address ADDR.    This means absolutely all information in the frame is printed.  */
end_comment

begin_function
specifier|static
name|void
name|frame_info
parameter_list|(
name|addr_exp
parameter_list|)
name|char
modifier|*
name|addr_exp
decl_stmt|;
block|{
name|FRAME
name|frame
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|struct
name|frame_saved_regs
name|fsr
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|symbol
modifier|*
name|func
decl_stmt|;
name|FRAME
name|calling_frame
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|char
modifier|*
name|funname
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|have_inferior_p
argument_list|()
operator|||
name|have_core_file_p
argument_list|()
operator|)
condition|)
name|error
argument_list|(
literal|"No inferior or core file."
argument_list|)
expr_stmt|;
name|frame
operator|=
name|parse_frame_specification
argument_list|(
name|addr_exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|frame
condition|)
name|error
argument_list|(
literal|"Invalid frame specified."
argument_list|)
expr_stmt|;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|get_frame_saved_regs
argument_list|(
name|fi
argument_list|,
operator|&
name|fsr
argument_list|)
expr_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|next_frame
argument_list|)
expr_stmt|;
name|func
operator|=
name|get_frame_function
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
name|funname
operator|=
name|SYMBOL_NAME
argument_list|(
name|func
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|int
name|misc_index
init|=
name|find_pc_misc_function
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|misc_index
operator|>=
literal|0
condition|)
name|funname
operator|=
name|misc_function_vector
index|[
name|misc_index
index|]
operator|.
name|name
expr_stmt|;
block|}
name|calling_frame
operator|=
name|get_prev_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|addr_exp
operator|&&
name|selected_frame_level
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"Stack level %d, frame at 0x%x:\n pc = 0x%x"
argument_list|,
name|selected_frame_level
argument_list|,
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
argument_list|,
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Stack frame at 0x%x:\n pc = 0x%x"
argument_list|,
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
argument_list|,
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|funname
condition|)
name|printf
argument_list|(
literal|" in %s"
argument_list|,
name|funname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
condition|)
name|printf
argument_list|(
literal|" (%s line %d)"
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"; saved pc 0x%x\n"
argument_list|,
name|FRAME_SAVED_PC
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|calling_frame
condition|)
name|printf
argument_list|(
literal|" called by frame at 0x%x"
argument_list|,
name|FRAME_FP
argument_list|(
name|calling_frame
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|next_frame
operator|&&
name|calling_frame
condition|)
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|next_frame
condition|)
name|printf
argument_list|(
literal|" caller of frame at 0x%x"
argument_list|,
name|fi
operator|->
name|next_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|next_frame
operator|||
name|calling_frame
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|{
comment|/* Address of the argument list for this frame, or Frame_unknown.  */
name|CORE_ADDR
name|arg_list
init|=
name|FRAME_ARGS_ADDRESS_CORRECT
argument_list|(
name|fi
argument_list|)
decl_stmt|;
comment|/* Number of args for this frame, or -1 if unknown.  */
name|int
name|numargs
decl_stmt|;
if|if
condition|(
name|arg_list
operator|!=
name|Frame_unknown
condition|)
block|{
name|printf
argument_list|(
literal|" Arglist at 0x%x,"
argument_list|,
name|arg_list
argument_list|)
expr_stmt|;
name|FRAME_NUM_ARGS
argument_list|(
name|numargs
argument_list|,
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|numargs
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|" args: "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|numargs
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" no args."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|numargs
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|" 1 arg: "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %d args: "
argument_list|,
name|numargs
argument_list|)
expr_stmt|;
name|print_frame_args
argument_list|(
name|func
argument_list|,
name|fi
argument_list|,
name|numargs
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The sp is special; what's returned isn't the save address, but      actually the value of the previous frame's sp.  */
name|printf
argument_list|(
literal|" Previous frame's sp is 0x%x\n"
argument_list|,
name|fsr
operator|.
name|regs
index|[
name|SP_REGNUM
index|]
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fsr
operator|.
name|regs
index|[
name|i
index|]
operator|&&
name|i
operator|!=
name|SP_REGNUM
condition|)
block|{
if|if
condition|(
name|count
operator|%
literal|4
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" Saved registers:"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n  "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s at 0x%x"
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|,
name|fsr
operator|.
name|regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Set a limit on the number of frames printed by default in a    backtrace.  */
end_comment

begin_endif
unit|static int backtrace_limit;  static void set_backtrace_limit_command (count_exp, from_tty)      char *count_exp;      int from_tty; {   int count = parse_and_eval_address (count_exp);    if (count< 0)     error ("Negative argument not meaningful as backtrace limit.");    backtrace_limit = count; }  static void backtrace_limit_info (arg, from_tty)      char *arg;      int from_tty; {   if (arg)     error ("\"Info backtrace-limit\" takes no arguments.");    printf ("Backtrace limit: %d.\n", backtrace_limit); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Print briefly all stack frames or just the innermost COUNT frames.  */
end_comment

begin_function
specifier|static
name|void
name|backtrace_command
parameter_list|(
name|count_exp
parameter_list|)
name|char
modifier|*
name|count_exp
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|FRAME
name|frame
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|FRAME
name|trailing
decl_stmt|;
specifier|register
name|int
name|trailing_level
decl_stmt|;
comment|/* The following code must do two things.  First, it must      set the variable TRAILING to the frame from which we should start      printing.  Second, it must set the variable count to the number      of frames which we should print, or -1 if all of them.  */
name|trailing
operator|=
name|get_current_frame
argument_list|()
expr_stmt|;
name|trailing_level
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|count_exp
condition|)
block|{
name|count
operator|=
name|parse_and_eval_address
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|FRAME
name|current
decl_stmt|;
name|count
operator|=
operator|-
name|count
expr_stmt|;
name|current
operator|=
name|trailing
expr_stmt|;
while|while
condition|(
name|current
operator|&&
name|count
operator|--
condition|)
name|current
operator|=
name|get_prev_frame
argument_list|(
name|current
argument_list|)
expr_stmt|;
comment|/* Will stop when CURRENT reaches the top of the stack.  TRAILING 	     will be COUNT below it.  */
while|while
condition|(
name|current
condition|)
block|{
name|trailing
operator|=
name|get_prev_frame
argument_list|(
name|trailing
argument_list|)
expr_stmt|;
name|current
operator|=
name|get_prev_frame
argument_list|(
name|current
argument_list|)
expr_stmt|;
name|trailing_level
operator|++
expr_stmt|;
block|}
name|count
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
name|count
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|frame
operator|=
name|trailing
init|;
name|frame
operator|&&
name|count
operator|--
condition|;
name|i
operator|++
operator|,
name|frame
operator|=
name|get_prev_frame
argument_list|(
name|frame
argument_list|)
control|)
block|{
name|QUIT
expr_stmt|;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|print_frame_info
argument_list|(
name|fi
argument_list|,
name|trailing_level
operator|+
name|i
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If we've stopped before the end, mention that.  */
if|if
condition|(
name|frame
condition|)
name|printf_filtered
argument_list|(
literal|"(More stack frames follow...)\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the local variables of a block B active in FRAME.    Return 1 if any variables were printed; 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|print_block_frame_locals
parameter_list|(
name|b
parameter_list|,
name|frame
parameter_list|,
name|stream
parameter_list|)
name|struct
name|block
modifier|*
name|b
decl_stmt|;
specifier|register
name|FRAME
name|frame
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|nsyms
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|int
name|values_printed
init|=
literal|0
decl_stmt|;
name|nsyms
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_LOCAL
operator|||
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_REGISTER
operator|||
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_STATIC
condition|)
block|{
name|values_printed
operator|=
literal|1
expr_stmt|;
name|fputs_filtered
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" = "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_variable_value
argument_list|(
name|sym
argument_list|,
name|frame
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|values_printed
return|;
block|}
end_function

begin_comment
comment|/* Print on STREAM all the local variables in frame FRAME,    including all the blocks active in that frame    at its current pc.     Returns 1 if the job was done,    or 0 if nothing was printed because we have no info    on the function running in FRAME.  */
end_comment

begin_function
specifier|static
name|int
name|print_frame_local_vars
parameter_list|(
name|frame
parameter_list|,
name|stream
parameter_list|)
specifier|register
name|FRAME
name|frame
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
specifier|register
name|struct
name|block
modifier|*
name|block
init|=
name|get_frame_block
argument_list|(
name|frame
argument_list|)
decl_stmt|;
specifier|register
name|int
name|values_printed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|block
operator|==
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"No symbol table info available.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|block
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|print_block_frame_locals
argument_list|(
name|block
argument_list|,
name|frame
argument_list|,
name|stream
argument_list|)
condition|)
name|values_printed
operator|=
literal|1
expr_stmt|;
comment|/* After handling the function's top-level block, stop. 	 Don't continue to its superblock, the block of 	 per-file symbols.  */
if|if
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
condition|)
break|break;
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|values_printed
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"No locals.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|locals_info
parameter_list|()
block|{
if|if
condition|(
operator|!
name|have_inferior_p
argument_list|()
operator|&&
operator|!
name|have_core_file_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"No inferior or core file."
argument_list|)
expr_stmt|;
name|print_frame_local_vars
argument_list|(
name|selected_frame
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_frame_arg_vars
parameter_list|(
name|frame
parameter_list|,
name|stream
parameter_list|)
specifier|register
name|FRAME
name|frame
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|func
init|=
name|get_frame_function
argument_list|(
name|frame
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|int
name|nsyms
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
specifier|register
name|int
name|values_printed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|func
operator|==
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"No symbol table info available.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|b
operator|=
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|func
argument_list|)
expr_stmt|;
name|nsyms
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|b
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_ARG
operator|||
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_REF_ARG
operator|||
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_REGPARM
condition|)
block|{
name|values_printed
operator|=
literal|1
expr_stmt|;
name|fputs_filtered
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" = "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_variable_value
argument_list|(
name|sym
argument_list|,
name|frame
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|values_printed
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"No arguments.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|args_info
parameter_list|()
block|{
if|if
condition|(
operator|!
name|have_inferior_p
argument_list|()
operator|&&
operator|!
name|have_core_file_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"No inferior or core file."
argument_list|)
expr_stmt|;
name|print_frame_arg_vars
argument_list|(
name|selected_frame
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Select frame FRAME, and note that its stack level is LEVEL.    LEVEL may be -1 if an actual level number is not known.  */
end_comment

begin_function
name|void
name|select_frame
parameter_list|(
name|frame
parameter_list|,
name|level
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
name|selected_frame
operator|=
name|frame
expr_stmt|;
name|selected_frame_level
operator|=
name|level
expr_stmt|;
comment|/* Ensure that symbols for this frame are readin.  */
if|if
condition|(
name|frame
condition|)
name|find_pc_symtab
argument_list|(
name|get_frame_info
argument_list|(
name|frame
argument_list|)
operator|->
name|pc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store the selected frame and its level into *FRAMEP and *LEVELP.  */
end_comment

begin_function
name|void
name|record_selected_frame
parameter_list|(
name|frameaddrp
parameter_list|,
name|levelp
parameter_list|)
name|FRAME_ADDR
modifier|*
name|frameaddrp
decl_stmt|;
name|int
modifier|*
name|levelp
decl_stmt|;
block|{
operator|*
name|frameaddrp
operator|=
name|FRAME_FP
argument_list|(
name|selected_frame
argument_list|)
expr_stmt|;
operator|*
name|levelp
operator|=
name|selected_frame_level
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the symbol-block in which the selected frame is executing.    Can return zero under various legitimate circumstances.  */
end_comment

begin_function
name|struct
name|block
modifier|*
name|get_selected_block
parameter_list|()
block|{
if|if
condition|(
operator|!
name|have_inferior_p
argument_list|()
operator|&&
operator|!
name|have_core_file_p
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|selected_frame
condition|)
return|return
name|get_current_block
argument_list|()
return|;
return|return
name|get_frame_block
argument_list|(
name|selected_frame
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find a frame a certain number of levels away from FRAME.    LEVEL_OFFSET_PTR points to an int containing the number of levels.    Positive means go to earlier frames (up); negative, the reverse.    The int that contains the number of levels is counted toward    zero as the frames for those levels are found.    If the top or bottom frame is reached, that frame is returned,    but the final value of *LEVEL_OFFSET_PTR is nonzero and indicates    how much farther the original request asked to go.  */
end_comment

begin_function
name|FRAME
name|find_relative_frame
parameter_list|(
name|frame
parameter_list|,
name|level_offset_ptr
parameter_list|)
specifier|register
name|FRAME
name|frame
decl_stmt|;
specifier|register
name|int
modifier|*
name|level_offset_ptr
decl_stmt|;
block|{
specifier|register
name|FRAME
name|prev
decl_stmt|;
specifier|register
name|FRAME
name|frame1
decl_stmt|,
name|frame2
decl_stmt|;
comment|/* Going up is simple: just do get_prev_frame enough times      or until initial frame is reached.  */
while|while
condition|(
operator|*
name|level_offset_ptr
operator|>
literal|0
condition|)
block|{
name|prev
operator|=
name|get_prev_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|==
literal|0
condition|)
break|break;
operator|(
operator|*
name|level_offset_ptr
operator|)
operator|--
expr_stmt|;
name|frame
operator|=
name|prev
expr_stmt|;
block|}
comment|/* Going down could be done by iterating get_frame_info to      find the next frame, but that would be quadratic      since get_frame_info must scan all the way from the current frame.      The following algorithm is linear.  */
if|if
condition|(
operator|*
name|level_offset_ptr
operator|<
literal|0
condition|)
block|{
comment|/* First put frame1 at innermost frame 	 and frame2 N levels up from there.  */
name|frame1
operator|=
name|get_current_frame
argument_list|()
expr_stmt|;
name|frame2
operator|=
name|frame1
expr_stmt|;
while|while
condition|(
operator|*
name|level_offset_ptr
operator|<
literal|0
operator|&&
name|frame2
operator|!=
name|frame
condition|)
block|{
name|frame2
operator|=
name|get_prev_frame
argument_list|(
name|frame2
argument_list|)
expr_stmt|;
operator|(
operator|*
name|level_offset_ptr
operator|)
operator|++
expr_stmt|;
block|}
comment|/* Then slide frame1 and frame2 up in synchrony 	 and when frame2 reaches our starting point 	 frame1 must be N levels down from there.  */
while|while
condition|(
name|frame2
operator|!=
name|frame
condition|)
block|{
name|frame1
operator|=
name|get_prev_frame
argument_list|(
name|frame1
argument_list|)
expr_stmt|;
name|frame2
operator|=
name|get_prev_frame
argument_list|(
name|frame2
argument_list|)
expr_stmt|;
block|}
return|return
name|frame1
return|;
block|}
return|return
name|frame
return|;
block|}
end_function

begin_comment
comment|/* The "frame" command.  With no arg, print selected frame briefly.    With arg LEVEL_EXP, select the frame at level LEVEL if it is a    valid level.  Otherwise, treat level_exp as an address expression    and print it.  See parse_frame_specification for more info on proper    frame expressions. */
end_comment

begin_function
specifier|static
name|void
name|frame_command
parameter_list|(
name|level_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|level_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|FRAME
name|frame
decl_stmt|,
name|frame1
decl_stmt|;
name|unsigned
name|int
name|level
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|have_inferior_p
argument_list|()
operator|&&
operator|!
name|have_core_file_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"No inferior or core file."
argument_list|)
expr_stmt|;
name|frame
operator|=
name|parse_frame_specification
argument_list|(
name|level_exp
argument_list|)
expr_stmt|;
for|for
control|(
name|frame1
operator|=
name|get_prev_frame
argument_list|(
literal|0
argument_list|)
init|;
name|frame1
operator|&&
name|frame1
operator|!=
name|frame
condition|;
name|frame1
operator|=
name|get_prev_frame
argument_list|(
name|frame1
argument_list|)
control|)
name|level
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|frame1
condition|)
name|level
operator|=
literal|0
expr_stmt|;
name|frame_changed
operator|=
name|level
expr_stmt|;
name|select_frame
argument_list|(
name|frame
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|from_tty
condition|)
return|return;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
name|selected_frame_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Select the frame up one or COUNT stack levels    from the previously selected frame, and print it briefly.  */
end_comment

begin_function
specifier|static
name|void
name|up_command
parameter_list|(
name|count_exp
parameter_list|)
name|char
modifier|*
name|count_exp
decl_stmt|;
block|{
specifier|register
name|FRAME
name|frame
decl_stmt|;
name|int
name|count
init|=
literal|1
decl_stmt|,
name|count1
decl_stmt|;
if|if
condition|(
name|count_exp
condition|)
name|count
operator|=
name|parse_and_eval_address
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
name|count1
operator|=
name|count
expr_stmt|;
if|if
condition|(
operator|!
name|have_inferior_p
argument_list|()
operator|&&
operator|!
name|have_core_file_p
argument_list|()
condition|)
name|error
argument_list|(
literal|"No inferior or core file."
argument_list|)
expr_stmt|;
name|frame
operator|=
name|find_relative_frame
argument_list|(
name|selected_frame
argument_list|,
operator|&
name|count1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count1
operator|!=
literal|0
operator|&&
name|count_exp
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Initial frame selected; you cannot go up."
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|frame
argument_list|,
name|selected_frame_level
operator|+
name|count
operator|-
name|count1
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
name|selected_frame_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|frame_changed
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Select the frame down one or COUNT stack levels    from the previously selected frame, and print it briefly.  */
end_comment

begin_function
specifier|static
name|void
name|down_command
parameter_list|(
name|count_exp
parameter_list|)
name|char
modifier|*
name|count_exp
decl_stmt|;
block|{
specifier|register
name|FRAME
name|frame
decl_stmt|;
name|int
name|count
init|=
operator|-
literal|1
decl_stmt|,
name|count1
decl_stmt|;
if|if
condition|(
name|count_exp
condition|)
name|count
operator|=
operator|-
name|parse_and_eval_address
argument_list|(
name|count_exp
argument_list|)
expr_stmt|;
name|count1
operator|=
name|count
expr_stmt|;
name|frame
operator|=
name|find_relative_frame
argument_list|(
name|selected_frame
argument_list|,
operator|&
name|count1
argument_list|)
expr_stmt|;
if|if
condition|(
name|count1
operator|!=
literal|0
operator|&&
name|count_exp
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Bottom (i.e., innermost) frame selected; you cannot go down."
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|frame
argument_list|,
name|selected_frame_level
operator|+
name|count
operator|-
name|count1
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
name|selected_frame_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|frame_changed
operator|--
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|return_command
parameter_list|(
name|retval_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|retval_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|value
name|return_value
decl_stmt|;
name|struct
name|symbol
modifier|*
name|thisfun
init|=
name|get_frame_function
argument_list|(
name|selected_frame
argument_list|)
decl_stmt|;
name|FRAME_ADDR
name|selected_frame_addr
init|=
name|FRAME_FP
argument_list|(
name|selected_frame
argument_list|)
decl_stmt|;
comment|/* If interactive, require confirmation.  */
if|if
condition|(
name|from_tty
condition|)
block|{
if|if
condition|(
name|thisfun
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"Make %s return now? "
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|thisfun
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"Make selected stack frame return now? "
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not confirmed."
argument_list|)
expr_stmt|;
block|}
comment|/* Do the real work.  Pop until the specified frame is current.  We      use this method because the selected_frame is not valid after      a POP_FRAME.  Note that this will not work if the selected frame      shares it's fp with another frame.  */
while|while
condition|(
name|selected_frame_addr
operator|!=
name|FRAME_FP
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
condition|)
name|POP_FRAME
expr_stmt|;
comment|/* get the return value while still in this frame */
if|if
condition|(
name|retval_exp
condition|)
name|return_value
operator|=
name|parse_and_eval
argument_list|(
name|retval_exp
argument_list|)
expr_stmt|;
comment|/* Then pop that frame.  */
name|POP_FRAME
expr_stmt|;
comment|/* Store the return value if there was one */
if|if
condition|(
name|retval_exp
condition|)
name|set_return_value
argument_list|(
name|return_value
argument_list|)
expr_stmt|;
comment|/* If interactive, print the frame that is now current.  */
if|if
condition|(
name|from_tty
condition|)
name|frame_command
argument_list|(
literal|"0"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|setlist
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_stack
parameter_list|()
block|{
if|#
directive|if
literal|0
block|backtrace_limit = 30;
endif|#
directive|endif
name|add_com
argument_list|(
literal|"return"
argument_list|,
name|class_stack
argument_list|,
name|return_command
argument_list|,
literal|"Make selected stack frame return to its caller.\n\ Control remains in the debugger, but when you continue\n\ execution will resume in the frame above the one now selected.\n\ If an argument is given, it is an expression for the value to return."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"up"
argument_list|,
name|class_stack
argument_list|,
name|up_command
argument_list|,
literal|"Select and print stack frame that called this one.\n\ An argument says how many frames up to go."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"down"
argument_list|,
name|class_stack
argument_list|,
name|down_command
argument_list|,
literal|"Select and print stack frame called by this one.\n\ An argument says how many frames down to go."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"do"
argument_list|,
literal|"down"
argument_list|,
name|class_stack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"frame"
argument_list|,
name|class_stack
argument_list|,
name|frame_command
argument_list|,
literal|"Select and print a stack frame.\n\ With no argument, print the selected stack frame.  (See also \"info frame\").\n\ An argument specifies the frame to select.\n\ It can be a stack frame number or the address of the frame.\n\ With argument, nothing is printed if input is coming from\n\ a command file or a user-defined command."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"f"
argument_list|,
literal|"frame"
argument_list|,
name|class_stack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"backtrace"
argument_list|,
name|class_stack
argument_list|,
name|backtrace_command
argument_list|,
literal|"Print backtrace of all stack frames, or innermost COUNT frames.\n\ With a negative argument, print outermost -COUNT frames."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"bt"
argument_list|,
literal|"backtrace"
argument_list|,
name|class_stack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"where"
argument_list|,
literal|"backtrace"
argument_list|,
name|class_alias
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"stack"
argument_list|,
name|backtrace_command
argument_list|,
literal|"Backtrace of the stack, or innermost COUNT frames."
argument_list|)
expr_stmt|;
name|add_info_alias
argument_list|(
literal|"s"
argument_list|,
literal|"stack"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"frame"
argument_list|,
name|frame_info
argument_list|,
literal|"All about selected stack frame, or frame at ADDR."
argument_list|)
expr_stmt|;
name|add_info_alias
argument_list|(
literal|"f"
argument_list|,
literal|"frame"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"locals"
argument_list|,
name|locals_info
argument_list|,
literal|"Local variables of current stack frame."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"args"
argument_list|,
name|args_info
argument_list|,
literal|"Argument variables of current stack frame."
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|add_cmd ("backtrace-limit", class_stack, set_backtrace_limit_command,  	   "Specify maximum number of frames for \"backtrace\" to print by default.",&setlist);   add_info ("backtrace-limit", backtrace_limit_info, 	    "The maximum number of frames for \"backtrace\" to print by default.");
endif|#
directive|endif
block|}
end_function

end_unit

