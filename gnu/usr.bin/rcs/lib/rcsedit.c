begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* RCS stream editor */
end_comment

begin_comment
comment|/******************************************************************************  *                       edits the input file according to a  *                       script from stdin, generated by diff -n  *                       performs keyword expansion  ******************************************************************************  */
end_comment

begin_comment
comment|/* Copyright 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991, 1992, 1993, 1994, 1995 Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/*  * Revision 5.19  1995/06/16 06:19:24  eggert  * Update FSF address.  *  * Revision 5.18  1995/06/01 16:23:43  eggert  * (dirtpname): No longer external.  * (do_link): Simplify logic.  * (finisheditline, finishedit): Replace Iseek/Itell with what they stand for.  * (fopen_update_truncate): Replace `#if' with `if'.  * (keyreplace, makedirtemp): dirlen(x) -> basefilename(x)-x.  *  * (edit_string): Fix bug: if !large_memory, a bogus trailing `@' was output  * at the end of incomplete lines.  *  * (keyreplace): Do not assume that seeking backwards  * at the start of a file will fail; on some systems it succeeds.  * Convert C- and Pascal-style comment starts to ` *' in comment leader.  *  * (rcswriteopen): Use fdSafer to get safer file descriptor.  * Open RCS file with FOPEN_RB.  *  * (chnamemod): Work around bad_NFS_rename bug; don't ignore un_link result.  * Fall back on chmod if fchmod fails, since it might be ENOSYS.  *  * (aflush): Move to rcslex.c.  *  * Revision 5.17  1994/03/20 04:52:58  eggert  * Normally calculate the $Log prefix from context, not from RCS file.  * Move setmtime here from rcsutil.c.  Add ORCSerror.  Remove lint.  *  * Revision 5.16  1993/11/03 17:42:27  eggert  * Add -z.  Add Name keyword.  If bad_unlink, ignore errno when unlink fails.  * Escape white space, $, and \ in keyword string file names.  * Don't output 2 spaces between date and time after Log.  *  * Revision 5.15  1992/07/28  16:12:44  eggert  * Some hosts have readlink but not ELOOP.  Avoid `unsigned'.  * Preserve dates more systematically.  Statement macro names now end in _.  *  * Revision 5.14  1992/02/17  23:02:24  eggert  * Add -T support.  *  * Revision 5.13  1992/01/24  18:44:19  eggert  * Add support for bad_chmod_close, bad_creat0.  *  * Revision 5.12  1992/01/06  02:42:34  eggert  * Add setmode parameter to chnamemod.  addsymbol now reports changes.  * while (E) ; -> while (E) continue;  *  * Revision 5.11  1991/11/03  01:11:44  eggert  * Move the warning about link breaking to where they're actually being broken.  *  * Revision 5.10  1991/10/07  17:32:46  eggert  * Support piece tables even if !has_mmap.  Fix rare NFS bugs.  *  * Revision 5.9  1991/09/17  19:07:40  eggert  * SGI readlink() yields ENXIO, not EINVAL, for nonlinks.  *  * Revision 5.8  1991/08/19  03:13:55  eggert  * Add piece tables, NFS bug workarounds.  Catch odd filenames.  Tune.  *  * Revision 5.7  1991/04/21  11:58:21  eggert  * Fix errno bugs.  Add -x, RCSINIT, MS-DOS support.  *  * Revision 5.6  1991/02/25  07:12:40  eggert  * Fix setuid bug.  Support new link behavior.  Work around broken "w+" fopen.  *  * Revision 5.5  1990/12/30  05:07:35  eggert  * Fix report of busy RCS files when !defined(O_CREAT) | !defined(O_EXCL).  *  * Revision 5.4  1990/11/01  05:03:40  eggert  * Permit arbitrary data in comment leaders.  *  * Revision 5.3  1990/09/11  02:41:13  eggert  * Tune expandline().  *  * Revision 5.2  1990/09/04  08:02:21  eggert  * Count RCS lines better.  Improve incomplete line handling.  *  * Revision 5.1  1990/08/29  07:13:56  eggert  * Add -kkvl.  * Fix bug when getting revisions to files ending in incomplete lines.  * Fix bug in comment leader expansion.  *  * Revision 5.0  1990/08/22  08:12:47  eggert  * Don't require final newline.  * Don't append "checked in with -k by " to logs,  * so that checking in a program with -k doesn't change it.  * Don't generate trailing white space for empty comment leader.  * Remove compile-time limits; use malloc instead.  Add -k, -V.  * Permit dates past 1999/12/31.  Make lock and temp files faster and safer.  * Ansify and Posixate.  Check diff's output.  *  * Revision 4.8  89/05/01  15:12:35  narten  * changed copyright header to reflect current distribution rules  *  * Revision 4.7  88/11/08  13:54:14  narten  * misplaced semicolon caused infinite loop  *  * Revision 4.6  88/08/09  19:12:45  eggert  * Shrink stdio code size; allow cc -R.  *  * Revision 4.5  87/12/18  11:38:46  narten  * Changes from the 43. version. Don't know the significance of the  * first change involving "rewind". Also, additional "lint" cleanup.  * (Guy Harris)  *  * Revision 4.4  87/10/18  10:32:21  narten  * Updating version numbers. Changes relative to version 1.1 actually  * relative to 4.1  *  * Revision 1.4  87/09/24  13:59:29  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf  * warnings)  *  * Revision 1.3  87/09/15  16:39:39  shepler  * added an initializatin of the variables editline and linecorr  * this will be done each time a file is processed.  * (there was an obscure bug where if co was used to retrieve multiple files  *  it would dump)  * fix attributed to  Roy Morris @FileNet Corp ...!felix!roy  *  * Revision 1.2  87/03/27  14:22:17  jenkins  * Port to suns  *  * Revision 4.1  83/05/12  13:10:30  wft  * Added new markers Id and RCSfile; added locker to Header and Id.  * Overhauled expandline completely() (problem with $01234567890123456789@).  * Moved trymatch() and marker table to rcskeys.c.  *  * Revision 3.7  83/05/12  13:04:39  wft  * Added retry to expandline to resume after failed match which ended in $.  * Fixed truncation problem for $19chars followed by@@.  * Log no longer expands full path of RCS file.  *  * Revision 3.6  83/05/11  16:06:30  wft  * added retry to expandline to resume after failed match which ended in $.  * Fixed truncation problem for $19chars followed by@@.  *  * Revision 3.5  82/12/04  13:20:56  wft  * Added expansion of keyword Locker.  *  * Revision 3.4  82/12/03  12:26:54  wft  * Added line number correction in case editing does not start at the  * beginning of the file.  * Changed keyword expansion to always print a space before closing KDELIM;  * Expansion for Header shortened.  *  * Revision 3.3  82/11/14  14:49:30  wft  * removed Suffix from keyword expansion. Replaced fclose with ffclose.  * keyreplace() gets log message from delta, not from curlogmsg.  * fixed expression overflow in while(c=putc(GETC....  * checked nil printing.  *  * Revision 3.2  82/10/18  21:13:39  wft  * I added checks for write errors during the co process, and renamed  * expandstring() to xpandstring().  *  * Revision 3.1  82/10/13  15:52:55  wft  * changed type of result of getc() from char to int.  * made keyword expansion loop in expandline() portable to machines  * without sign-extension.  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_macro
name|libId
argument_list|(
argument|editId
argument_list|,
literal|"$FreeBSD$"
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|void
name|editEndsPrematurely
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
name|exiting
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|editLineNumberOverflow
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
name|exiting
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|escape_string
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|keyreplace
name|P
argument_list|(
operator|(
expr|enum
name|markers
operator|,
expr|struct
name|hshentry
specifier|const
operator|*
operator|,
name|int
operator|,
name|RILE
operator|*
operator|,
name|FILE
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fcopy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* result file descriptor			    */
end_comment

begin_decl_stmt
name|char
specifier|const
modifier|*
name|resultname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* result pathname				    */
end_comment

begin_decl_stmt
name|int
name|locker_expansion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* should the locker name be appended to Id val?   */
end_comment

begin_if
if|#
directive|if
operator|!
name|large_memory
end_if

begin_decl_stmt
specifier|static
name|RILE
modifier|*
name|fedit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* edit file descriptor */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|editname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* edit pathname */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|long
name|editline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* edit line counter; #lines before cursor   */
end_comment

begin_decl_stmt
specifier|static
name|long
name|linecorr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #adds - #deletes in each edit run.		    */
end_comment

begin_comment
comment|/*used to correct editline in case file is not rewound after */
end_comment

begin_comment
comment|/* applying one delta                                        */
end_comment

begin_comment
comment|/* indexes into dirtpname */
end_comment

begin_define
define|#
directive|define
name|lockdirtp_index
value|0
end_define

begin_define
define|#
directive|define
name|newRCSdirtp_index
value|bad_creat0
end_define

begin_define
define|#
directive|define
name|newworkdirtp_index
value|(newRCSdirtp_index+1)
end_define

begin_define
define|#
directive|define
name|DIRTEMPNAMES
value|(newworkdirtp_index + 1)
end_define

begin_enum
enum|enum
name|maker
block|{
name|notmade
block|,
name|real
block|,
name|effective
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|struct
name|buf
name|dirtpname
index|[
name|DIRTEMPNAMES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* unlink these when done */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|maker
specifier|volatile
name|dirtpmaker
index|[
name|DIRTEMPNAMES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if these are set */
end_comment

begin_define
define|#
directive|define
name|lockname
value|(dirtpname[lockdirtp_index].string)
end_define

begin_define
define|#
directive|define
name|newRCSname
value|(dirtpname[newRCSdirtp_index].string)
end_define

begin_if
if|#
directive|if
name|has_NFS
operator|||
name|bad_unlink
end_if

begin_function
name|int
name|un_link
parameter_list|(
name|s
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
comment|/*  * Remove S, even if it is unwritable.  * Ignore unlink() ENOENT failures; NFS generates bogus ones.  */
block|{
if|#
directive|if
name|bad_unlink
if|if
condition|(
name|unlink
argument_list|(
name|s
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
comment|/* 			* Forge ahead even if errno == ENOENT; some completely 			* brain-damaged hosts (e.g. PCTCP 2.2) yield ENOENT 			* even for existing unwritable files. 			*/
if|if
condition|(
name|chmod
argument_list|(
name|s
argument_list|,
name|S_IWUSR
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|e
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|has_NFS
return|return
name|unlink
argument_list|(
name|s
argument_list|)
operator|==
literal|0
operator|||
name|errno
operator|==
name|ENOENT
condition|?
literal|0
else|:
operator|-
literal|1
return|;
else|#
directive|else
return|return
name|unlink
argument_list|(
name|s
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|has_rename
end_if

begin_if
if|#
directive|if
operator|!
name|has_NFS
end_if

begin_define
define|#
directive|define
name|do_link
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
value|link(s,t)
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|do_link
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|do_link
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|,
decl|*
name|t
decl_stmt|;
end_function

begin_comment
comment|/* Link S to T, ignoring bogus EEXIST problems due to NFS failures.  */
end_comment

begin_block
block|{
name|int
name|r
init|=
name|link
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
operator|&&
name|errno
operator|==
name|EEXIST
condition|)
block|{
name|struct
name|stat
name|sb
decl_stmt|,
name|tb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|s
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
operator|&&
name|stat
argument_list|(
name|t
argument_list|,
operator|&
name|tb
argument_list|)
operator|==
literal|0
operator|&&
name|same_file
argument_list|(
name|sb
argument_list|,
name|tb
argument_list|,
literal|0
argument_list|)
condition|)
name|r
operator|=
literal|0
expr_stmt|;
name|errno
operator|=
name|EEXIST
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|editEndsPrematurely
parameter_list|()
block|{
name|fatserror
argument_list|(
literal|"edit script ends prematurely"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|editLineNumberOverflow
parameter_list|()
block|{
name|fatserror
argument_list|(
literal|"edit script refers to line past end of file"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|large_memory
end_if

begin_if
if|#
directive|if
name|has_memmove
end_if

begin_define
define|#
directive|define
name|movelines
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|n
parameter_list|)
value|VOID memmove(s1, s2, (n)*sizeof(Iptr_type))
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|void
name|movelines
name|P
argument_list|(
operator|(
name|Iptr_type
operator|*
operator|,
name|Iptr_type
specifier|const
operator|*
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|movelines
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|n
parameter_list|)
specifier|register
name|Iptr_type
modifier|*
name|s1
decl_stmt|;
specifier|register
name|Iptr_type
specifier|const
modifier|*
name|s2
decl_stmt|;
specifier|register
name|long
name|n
decl_stmt|;
block|{
if|if
condition|(
name|s1
operator|<
name|s2
condition|)
do|do
block|{
operator|*
name|s1
operator|++
operator|=
operator|*
name|s2
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
condition|)
do|;
else|else
block|{
name|s1
operator|+=
name|n
expr_stmt|;
name|s2
operator|+=
name|n
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|s1
operator|=
operator|*
operator|--
name|s2
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
condition|)
do|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|deletelines
name|P
argument_list|(
operator|(
name|long
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|finisheditline
name|P
argument_list|(
operator|(
name|RILE
operator|*
operator|,
name|FILE
operator|*
operator|,
name|Iptr_type
operator|,
expr|struct
name|hshentry
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|insertline
name|P
argument_list|(
operator|(
name|long
operator|,
name|Iptr_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|snapshotline
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|Iptr_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * `line' contains pointers to the lines in the currently `edited' file.  * It is a 0-origin array that represents linelim-gapsize lines.  * line[0 .. gap-1] and line[gap+gapsize .. linelim-1] hold pointers to lines.  * line[gap .. gap+gapsize-1] contains garbage.  *  * Any @s in lines are duplicated.  * Lines are terminated by \n, or (for a last partial line only) by single @.  */
end_comment

begin_decl_stmt
specifier|static
name|Iptr_type
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|gap
decl_stmt|,
name|gapsize
decl_stmt|,
name|linelim
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|insertline
parameter_list|(
name|n
parameter_list|,
name|l
parameter_list|)
name|long
name|n
decl_stmt|;
name|Iptr_type
name|l
decl_stmt|;
comment|/* Before line N, insert line L.  N is 0-origin.  */
block|{
if|if
condition|(
name|linelim
operator|-
name|gapsize
operator|<
name|n
condition|)
name|editLineNumberOverflow
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|gapsize
condition|)
name|line
operator|=
operator|!
name|linelim
condition|?
name|tnalloc
argument_list|(
name|Iptr_type
argument_list|,
name|linelim
operator|=
name|gapsize
operator|=
literal|1024
argument_list|)
else|:
operator|(
name|gap
operator|=
name|gapsize
operator|=
name|linelim
operator|,
name|trealloc
argument_list|(
name|Iptr_type
argument_list|,
name|line
argument_list|,
name|linelim
operator|<<=
literal|1
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|gap
condition|)
name|movelines
argument_list|(
name|line
operator|+
name|n
operator|+
name|gapsize
argument_list|,
name|line
operator|+
name|n
argument_list|,
name|gap
operator|-
name|n
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gap
operator|<
name|n
condition|)
name|movelines
argument_list|(
name|line
operator|+
name|gap
argument_list|,
name|line
operator|+
name|gap
operator|+
name|gapsize
argument_list|,
name|n
operator|-
name|gap
argument_list|)
expr_stmt|;
name|line
index|[
name|n
index|]
operator|=
name|l
expr_stmt|;
name|gap
operator|=
name|n
operator|+
literal|1
expr_stmt|;
name|gapsize
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|deletelines
parameter_list|(
name|n
parameter_list|,
name|nlines
parameter_list|)
name|long
name|n
decl_stmt|,
name|nlines
decl_stmt|;
comment|/* Delete lines N through N+NLINES-1.  N is 0-origin.  */
block|{
name|long
name|l
init|=
name|n
operator|+
name|nlines
decl_stmt|;
if|if
condition|(
name|linelim
operator|-
name|gapsize
operator|<
name|l
operator|||
name|l
operator|<
name|n
condition|)
name|editLineNumberOverflow
argument_list|()
expr_stmt|;
if|if
condition|(
name|l
operator|<
name|gap
condition|)
name|movelines
argument_list|(
name|line
operator|+
name|l
operator|+
name|gapsize
argument_list|,
name|line
operator|+
name|l
argument_list|,
name|gap
operator|-
name|l
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gap
operator|<
name|n
condition|)
name|movelines
argument_list|(
name|line
operator|+
name|gap
argument_list|,
name|line
operator|+
name|gap
operator|+
name|gapsize
argument_list|,
name|n
operator|-
name|gap
argument_list|)
expr_stmt|;
name|gap
operator|=
name|n
expr_stmt|;
name|gapsize
operator|+=
name|nlines
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|snapshotline
parameter_list|(
name|f
parameter_list|,
name|l
parameter_list|)
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|register
name|Iptr_type
name|l
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|l
operator|++
operator|)
operator|==
name|SDELIM
operator|&&
operator|*
name|l
operator|++
operator|!=
name|SDELIM
condition|)
return|return;
name|aputc_
argument_list|(
argument|c
argument_list|,
argument|f
argument_list|)
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
block|}
end_function

begin_function
name|void
name|snapshotedit
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
comment|/* Copy the current state of the edits to F.  */
block|{
specifier|register
name|Iptr_type
modifier|*
name|p
decl_stmt|,
modifier|*
name|lim
decl_stmt|,
modifier|*
name|l
init|=
name|line
decl_stmt|;
for|for
control|(
name|p
operator|=
name|l
operator|,
name|lim
operator|=
name|l
operator|+
name|gap
init|;
name|p
operator|<
name|lim
condition|;
control|)
name|snapshotline
argument_list|(
name|f
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|+=
name|gapsize
operator|,
name|lim
operator|=
name|l
operator|+
name|linelim
init|;
name|p
operator|<
name|lim
condition|;
control|)
name|snapshotline
argument_list|(
name|f
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|finisheditline
parameter_list|(
name|fin
parameter_list|,
name|fout
parameter_list|,
name|l
parameter_list|,
name|delta
parameter_list|)
name|RILE
modifier|*
name|fin
decl_stmt|;
name|FILE
modifier|*
name|fout
decl_stmt|;
name|Iptr_type
name|l
decl_stmt|;
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
block|{
name|fin
operator|->
name|ptr
operator|=
name|l
expr_stmt|;
if|if
condition|(
name|expandline
argument_list|(
name|fin
argument_list|,
name|fout
argument_list|,
name|delta
argument_list|,
name|true
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
name|true
argument_list|)
operator|<
literal|0
condition|)
name|faterror
argument_list|(
literal|"finisheditline internal error"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|finishedit
parameter_list|(
name|delta
parameter_list|,
name|outfile
parameter_list|,
name|done
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|int
name|done
decl_stmt|;
comment|/*  * Doing expansion if DELTA is set, output the state of the edits to OUTFILE.  * But do nothing unless DONE is set (which means we are on the last pass).  */
block|{
if|if
condition|(
name|done
condition|)
block|{
name|openfcopy
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|outfile
operator|=
name|fcopy
expr_stmt|;
if|if
condition|(
operator|!
name|delta
condition|)
name|snapshotedit
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|Iptr_type
modifier|*
name|p
decl_stmt|,
modifier|*
name|lim
decl_stmt|,
modifier|*
name|l
init|=
name|line
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
init|=
name|finptr
decl_stmt|;
name|Iptr_type
name|here
init|=
name|fin
operator|->
name|ptr
decl_stmt|;
for|for
control|(
name|p
operator|=
name|l
operator|,
name|lim
operator|=
name|l
operator|+
name|gap
init|;
name|p
operator|<
name|lim
condition|;
control|)
name|finisheditline
argument_list|(
name|fin
argument_list|,
name|outfile
argument_list|,
operator|*
name|p
operator|++
argument_list|,
name|delta
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|+=
name|gapsize
operator|,
name|lim
operator|=
name|l
operator|+
name|linelim
init|;
name|p
operator|<
name|lim
condition|;
control|)
name|finisheditline
argument_list|(
name|fin
argument_list|,
name|outfile
argument_list|,
operator|*
name|p
operator|++
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|fin
operator|->
name|ptr
operator|=
name|here
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Open a temporary NAME for output, truncating any previous contents.  */
end_comment

begin_define
define|#
directive|define
name|fopen_update_truncate
parameter_list|(
name|name
parameter_list|)
value|fopenSafer(name, FOPEN_W_WORK)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !large_memory */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|fopen_update_truncate
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|FILE
modifier|*
name|fopen_update_truncate
parameter_list|(
name|name
parameter_list|)
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|bad_fopen_wplus
operator|&&
name|un_link
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
condition|)
name|efaterror
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|fopenSafer
argument_list|(
name|name
argument_list|,
name|FOPEN_WPLUS_WORK
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|openfcopy
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|(
name|fcopy
operator|=
name|f
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|resultname
condition|)
name|resultname
operator|=
name|maketemp
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fcopy
operator|=
name|fopen_update_truncate
argument_list|(
name|resultname
argument_list|)
operator|)
condition|)
name|efaterror
argument_list|(
name|resultname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|large_memory
end_if

begin_decl_stmt
specifier|static
name|void
name|swapeditfiles
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|swapeditfiles
parameter_list|(
name|outfile
parameter_list|)
name|FILE
modifier|*
name|outfile
decl_stmt|;
comment|/* Function: swaps resultname and editname, assigns fedit=fcopy,  * and rewinds fedit for reading.  Set fcopy to outfile if nonnull;  * otherwise, set fcopy to be resultname opened for reading and writing.  */
block|{
name|char
specifier|const
modifier|*
name|tmpptr
decl_stmt|;
name|editline
operator|=
literal|0
expr_stmt|;
name|linecorr
operator|=
literal|0
expr_stmt|;
name|Orewind
argument_list|(
name|fcopy
argument_list|)
expr_stmt|;
name|fedit
operator|=
name|fcopy
expr_stmt|;
name|tmpptr
operator|=
name|editname
expr_stmt|;
name|editname
operator|=
name|resultname
expr_stmt|;
name|resultname
operator|=
name|tmpptr
expr_stmt|;
name|openfcopy
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|snapshotedit
parameter_list|(
name|f
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
comment|/* Copy the current state of the edits to F.  */
block|{
name|finishedit
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|fastcopy
argument_list|(
name|fedit
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|Irewind
argument_list|(
name|fedit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|finishedit
parameter_list|(
name|delta
parameter_list|,
name|outfile
parameter_list|,
name|done
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|int
name|done
decl_stmt|;
comment|/* copy the rest of the edit file and close it (if it exists).  * if delta, perform keyword substitution at the same time.  * If DONE is set, we are finishing the last pass.  */
block|{
specifier|register
name|RILE
modifier|*
name|fe
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fc
decl_stmt|;
name|fe
operator|=
name|fedit
expr_stmt|;
if|if
condition|(
name|fe
condition|)
block|{
name|fc
operator|=
name|fcopy
expr_stmt|;
if|if
condition|(
name|delta
condition|)
block|{
while|while
condition|(
literal|1
operator|<
name|expandline
argument_list|(
name|fe
argument_list|,
name|fc
argument_list|,
name|delta
argument_list|,
name|false
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
name|true
argument_list|)
condition|)
empty_stmt|;
block|}
else|else
block|{
name|fastcopy
argument_list|(
name|fe
argument_list|,
name|fc
argument_list|)
expr_stmt|;
block|}
name|Ifclose
argument_list|(
name|fe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|done
condition|)
name|swapeditfiles
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|large_memory
end_if

begin_define
define|#
directive|define
name|copylines
parameter_list|(
name|upto
parameter_list|,
name|delta
parameter_list|)
value|(editline = (upto))
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|void
name|copylines
name|P
argument_list|(
operator|(
name|long
operator|,
expr|struct
name|hshentry
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|copylines
parameter_list|(
name|upto
parameter_list|,
name|delta
parameter_list|)
specifier|register
name|long
name|upto
decl_stmt|;
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
comment|/*  * Copy input lines editline+1..upto from fedit to fcopy.  * If delta, keyword expansion is done simultaneously.  * editline is updated. Rewinds a file only if necessary.  */
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|declarecache
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|fc
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fe
decl_stmt|;
if|if
condition|(
name|upto
operator|<
name|editline
condition|)
block|{
comment|/* swap files */
name|finishedit
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* assumes edit only during last pass, from the beginning*/
block|}
name|fe
operator|=
name|fedit
expr_stmt|;
name|fc
operator|=
name|fcopy
expr_stmt|;
if|if
condition|(
name|editline
operator|<
name|upto
condition|)
if|if
condition|(
name|delta
condition|)
do|do
block|{
if|if
condition|(
name|expandline
argument_list|(
name|fe
argument_list|,
name|fc
argument_list|,
name|delta
argument_list|,
name|false
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
name|true
argument_list|)
operator|<=
literal|1
condition|)
name|editLineNumberOverflow
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|editline
operator|<
name|upto
condition|)
do|;
else|else
block|{
name|setupcache
argument_list|(
name|fe
argument_list|)
expr_stmt|;
name|cache
argument_list|(
name|fe
argument_list|)
expr_stmt|;
do|do
block|{
do|do
block|{
name|cachegeteof_
argument_list|(
argument|c
argument_list|,
argument|editLineNumberOverflow();
argument_list|)
name|aputc_
argument_list|(
argument|c
argument_list|,
argument|fc
argument_list|)
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
block|}
do|while
condition|(
operator|++
name|editline
operator|<
name|upto
condition|)
do|;
name|uncache
argument_list|(
name|fe
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|xpandstring
parameter_list|(
name|delta
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
comment|/* Function: Reads a string terminated by SDELIM from finptr and writes it  * to fcopy. Double SDELIM is replaced with single SDELIM.  * Keyword expansion is performed with data from delta.  * If foutptr is nonnull, the string is also copied unchanged to foutptr.  */
block|{
while|while
condition|(
literal|1
operator|<
name|expandline
argument_list|(
name|finptr
argument_list|,
name|fcopy
argument_list|,
name|delta
argument_list|,
name|true
argument_list|,
name|foutptr
argument_list|,
name|true
argument_list|)
condition|)
continue|continue;
block|}
end_function

begin_function
name|void
name|copystring
parameter_list|()
comment|/* Function: copies a string terminated with a single SDELIM from finptr to  * fcopy, replacing all double SDELIM with a single SDELIM.  * If foutptr is nonnull, the string also copied unchanged to foutptr.  * editline is incremented by the number of lines copied.  * Assumption: next character read is first string character.  */
block|{
specifier|register
name|c
expr_stmt|;
name|declarecache
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|frew
decl_stmt|,
modifier|*
name|fcop
decl_stmt|;
specifier|register
name|int
name|amidline
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
decl_stmt|;
name|fin
operator|=
name|finptr
expr_stmt|;
name|setupcache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|cache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|frew
operator|=
name|foutptr
expr_stmt|;
name|fcop
operator|=
name|fcopy
expr_stmt|;
name|amidline
operator|=
name|false
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|GETC_
argument_list|(
argument|frew
argument_list|,
argument|c
argument_list|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
operator|++
name|editline
expr_stmt|;
operator|++
name|rcsline
expr_stmt|;
name|amidline
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|SDELIM
case|:
name|GETC_
argument_list|(
argument|frew
argument_list|,
argument|c
argument_list|)
if|if
condition|(
name|c
operator|!=
name|SDELIM
condition|)
block|{
comment|/* end of string */
name|nextc
operator|=
name|c
expr_stmt|;
name|editline
operator|+=
name|amidline
expr_stmt|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* fall into */
default|default:
name|amidline
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|aputc_
argument_list|(
argument|c
argument_list|,
argument|fcop
argument_list|)
block|}
block|}
end_function

begin_function
name|void
name|enterstring
parameter_list|()
comment|/* Like copystring, except the string is put into the edit data structure.  */
block|{
if|#
directive|if
operator|!
name|large_memory
name|editname
operator|=
literal|0
expr_stmt|;
name|fedit
operator|=
literal|0
expr_stmt|;
name|editline
operator|=
name|linecorr
operator|=
literal|0
expr_stmt|;
name|resultname
operator|=
name|maketemp
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fcopy
operator|=
name|fopen_update_truncate
argument_list|(
name|resultname
argument_list|)
operator|)
condition|)
name|efaterror
argument_list|(
name|resultname
argument_list|)
expr_stmt|;
name|copystring
argument_list|()
expr_stmt|;
else|#
directive|else
specifier|register
name|int
name|c
decl_stmt|;
name|declarecache
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|frew
decl_stmt|;
specifier|register
name|long
name|e
decl_stmt|,
name|oe
decl_stmt|;
specifier|register
name|int
name|amidline
decl_stmt|,
name|oamidline
decl_stmt|;
specifier|register
name|Iptr_type
name|optr
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
decl_stmt|;
name|e
operator|=
literal|0
expr_stmt|;
name|gap
operator|=
literal|0
expr_stmt|;
name|gapsize
operator|=
name|linelim
expr_stmt|;
name|fin
operator|=
name|finptr
expr_stmt|;
name|setupcache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|cache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|advise_access
argument_list|(
name|fin
argument_list|,
name|MADV_NORMAL
argument_list|)
expr_stmt|;
name|frew
operator|=
name|foutptr
expr_stmt|;
name|amidline
operator|=
name|false
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|optr
operator|=
name|cacheptr
argument_list|()
expr_stmt|;
name|GETC_
argument_list|(
argument|frew
argument_list|,
argument|c
argument_list|)
name|oamidline
operator|=
name|amidline
expr_stmt|;
name|oe
operator|=
name|e
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
operator|++
name|e
expr_stmt|;
operator|++
name|rcsline
expr_stmt|;
name|amidline
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|SDELIM
case|:
name|GETC_
argument_list|(
argument|frew
argument_list|,
argument|c
argument_list|)
if|if
condition|(
name|c
operator|!=
name|SDELIM
condition|)
block|{
comment|/* end of string */
name|nextc
operator|=
name|c
expr_stmt|;
name|editline
operator|=
name|e
operator|+
name|amidline
expr_stmt|;
name|linecorr
operator|=
literal|0
expr_stmt|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* fall into */
default|default:
name|amidline
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|oamidline
condition|)
name|insertline
argument_list|(
name|oe
argument_list|,
name|optr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
if|#
directive|if
name|large_memory
name|edit_string
parameter_list|()
else|#
directive|else
function|editstring
parameter_list|(
name|delta
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
endif|#
directive|endif
comment|/*  * Read an edit script from finptr and applies it to the edit file. #if !large_memory  * The result is written to fcopy.  * If delta, keyword expansion is performed simultaneously.  * If running out of lines in fedit, fedit and fcopy are swapped.  * editname is the name of the file that goes with fedit. #endif  * If foutptr is set, the edit script is also copied verbatim to foutptr.  * Assumes that all these files are open.  * resultname is the name of the file that goes with fcopy.  * Assumes the next input character from finptr is the first character of  * the edit script. Resets nextc on exit.  */
block|{
name|int
name|ed
decl_stmt|;
comment|/* editor command */
specifier|register
name|int
name|c
decl_stmt|;
name|declarecache
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|frew
decl_stmt|;
if|#
directive|if
operator|!
name|large_memory
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
name|long
name|line_lim
init|=
name|LONG_MAX
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fe
decl_stmt|;
endif|#
directive|endif
specifier|register
name|long
name|i
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
decl_stmt|;
if|#
directive|if
name|large_memory
specifier|register
name|long
name|j
decl_stmt|;
endif|#
directive|endif
name|struct
name|diffcmd
name|dc
decl_stmt|;
name|editline
operator|+=
name|linecorr
expr_stmt|;
name|linecorr
operator|=
literal|0
expr_stmt|;
comment|/*correct line number*/
name|frew
operator|=
name|foutptr
expr_stmt|;
name|fin
operator|=
name|finptr
expr_stmt|;
name|setupcache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|initdiffcmd
argument_list|(
operator|&
name|dc
argument_list|)
expr_stmt|;
while|while
condition|(
literal|0
operator|<=
operator|(
name|ed
operator|=
name|getdiffcmd
argument_list|(
name|fin
argument_list|,
name|true
argument_list|,
name|frew
argument_list|,
operator|&
name|dc
argument_list|)
operator|)
condition|)
if|#
directive|if
operator|!
name|large_memory
if|if
condition|(
name|line_lim
operator|<=
name|dc
operator|.
name|line1
condition|)
name|editLineNumberOverflow
argument_list|()
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|!
name|ed
condition|)
block|{
name|copylines
argument_list|(
name|dc
operator|.
name|line1
operator|-
literal|1
argument_list|,
name|delta
argument_list|)
expr_stmt|;
comment|/* skip over unwanted lines */
name|i
operator|=
name|dc
operator|.
name|nlines
expr_stmt|;
name|linecorr
operator|-=
name|i
expr_stmt|;
name|editline
operator|+=
name|i
expr_stmt|;
if|#
directive|if
name|large_memory
name|deletelines
argument_list|(
name|editline
operator|+
name|linecorr
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|#
directive|else
name|fe
operator|=
name|fedit
expr_stmt|;
do|do
block|{
comment|/*skip next line*/
do|do
block|{
name|Igeteof_
argument_list|(
argument|fe
argument_list|,
argument|c
argument_list|,
argument|{ if (i!=
literal|1
argument|) editLineNumberOverflow(); line_lim = dc.dafter; break; }
argument_list|)
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Copy lines without deleting any.  */
name|copylines
argument_list|(
name|dc
operator|.
name|line1
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|i
operator|=
name|dc
operator|.
name|nlines
expr_stmt|;
if|#
directive|if
name|large_memory
name|j
operator|=
name|editline
operator|+
name|linecorr
expr_stmt|;
endif|#
directive|endif
name|linecorr
operator|+=
name|i
expr_stmt|;
if|#
directive|if
operator|!
name|large_memory
name|f
operator|=
name|fcopy
expr_stmt|;
if|if
condition|(
name|delta
condition|)
do|do
block|{
switch|switch
condition|(
name|expandline
argument_list|(
name|fin
argument_list|,
name|f
argument_list|,
name|delta
argument_list|,
name|true
argument_list|,
name|frew
argument_list|,
name|true
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
if|if
condition|(
name|i
operator|==
literal|1
condition|)
return|return;
comment|/* fall into */
case|case
operator|-
literal|1
case|:
name|editEndsPrematurely
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
else|else
endif|#
directive|endif
block|{
name|cache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
do|do
block|{
if|#
directive|if
name|large_memory
name|insertline
argument_list|(
name|j
operator|++
argument_list|,
name|cacheptr
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
name|GETC_
argument_list|(
argument|frew
argument_list|,
argument|c
argument_list|)
if|if
condition|(
name|c
operator|==
name|SDELIM
condition|)
block|{
name|GETC_
argument_list|(
argument|frew
argument_list|,
argument|c
argument_list|)
if|if
condition|(
name|c
operator|!=
name|SDELIM
condition|)
block|{
if|if
condition|(
operator|--
name|i
condition|)
name|editEndsPrematurely
argument_list|()
expr_stmt|;
name|nextc
operator|=
name|c
expr_stmt|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|#
directive|if
operator|!
name|large_memory
name|aputc_
argument_list|(
argument|c
argument_list|,
argument|f
argument_list|)
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
block|}
operator|++
name|rcsline
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* The rest is for keyword expansion */
end_comment

begin_function
name|int
name|expandline
parameter_list|(
name|infile
parameter_list|,
name|outfile
parameter_list|,
name|delta
parameter_list|,
name|delimstuffed
parameter_list|,
name|frewfile
parameter_list|,
name|dolog
parameter_list|)
name|RILE
modifier|*
name|infile
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|,
decl|*
name|frewfile
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|delimstuffed
decl_stmt|,
name|dolog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Read a line from INFILE and write it to OUTFILE.  * Do keyword expansion with data from DELTA.  * If DELIMSTUFFED is true, double SDELIM is replaced with single SDELIM.  * If FREWFILE is set, copy the line unchanged to FREWFILE.  * DELIMSTUFFED must be true if FREWFILE is set.  * Append revision history to log only if DOLOG is set.  * Yields -1 if no data is copied, 0 if an incomplete line is copied,  * 2 if a complete line is copied; adds 1 to yield if expansion occurred.  */
end_comment

begin_block
block|{
specifier|register
name|c
expr_stmt|;
name|declarecache
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|out
decl_stmt|,
modifier|*
name|frew
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|e
decl_stmt|,
name|ds
decl_stmt|,
name|r
decl_stmt|;
name|char
specifier|const
modifier|*
name|tlim
decl_stmt|;
specifier|static
name|struct
name|buf
name|keyval
decl_stmt|;
name|enum
name|markers
name|matchresult
decl_stmt|;
name|setupcache
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|cache
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|out
operator|=
name|outfile
expr_stmt|;
name|frew
operator|=
name|frewfile
expr_stmt|;
name|ds
operator|=
name|delimstuffed
expr_stmt|;
name|bufalloc
argument_list|(
operator|&
name|keyval
argument_list|,
name|keylength
operator|+
literal|3
argument_list|)
expr_stmt|;
name|e
operator|=
literal|0
expr_stmt|;
name|r
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ds
condition|)
name|GETC_
argument_list|(
argument|frew
argument_list|,
argument|c
argument_list|)
else|else
name|cachegeteof_
argument_list|(
argument|c
argument_list|,
argument|goto uncache_exit;
argument_list|)
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|SDELIM
case|:
if|if
condition|(
name|ds
condition|)
block|{
name|GETC_
argument_list|(
argument|frew
argument_list|,
argument|c
argument_list|)
if|if
condition|(
name|c
operator|!=
name|SDELIM
condition|)
block|{
comment|/* end of string */
name|nextc
operator|=
name|c
expr_stmt|;
goto|goto
name|uncache_exit
goto|;
block|}
block|}
comment|/* fall into */
default|default:
name|aputc_
argument_list|(
argument|c
argument_list|,
argument|out
argument_list|)
name|r
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|rcsline
operator|+=
name|ds
expr_stmt|;
name|aputc_
argument_list|(
argument|c
argument_list|,
argument|out
argument_list|)
name|r
operator|=
literal|2
expr_stmt|;
goto|goto
name|uncache_exit
goto|;
case|case
name|KDELIM
case|:
name|r
operator|=
literal|0
expr_stmt|;
comment|/* check for keyword */
comment|/* first, copy a long enough string into keystring */
name|tp
operator|=
name|keyval
operator|.
name|string
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
name|KDELIM
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ds
condition|)
name|GETC_
argument_list|(
argument|frew
argument_list|,
argument|c
argument_list|)
else|else
name|cachegeteof_
argument_list|(
argument|c
argument_list|,
argument|goto keystring_eof;
argument_list|)
if|if
condition|(
name|tp
operator|<=
operator|&
name|keyval
operator|.
name|string
index|[
name|keylength
index|]
condition|)
switch|switch
condition|(
name|ctab
index|[
name|c
index|]
condition|)
block|{
case|case
name|LETTER
case|:
case|case
name|Letter
case|:
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
break|break;
block|}
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
name|matchresult
operator|=
name|trymatch
argument_list|(
name|keyval
operator|.
name|string
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|matchresult
operator|==
name|Nomatch
condition|)
block|{
name|tp
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|aputs
argument_list|(
name|keyval
operator|.
name|string
argument_list|,
name|out
argument_list|)
expr_stmt|;
continue|continue;
comment|/* last c handled properly */
block|}
comment|/* Now we have a keyword terminated with a K/VDELIM */
if|if
condition|(
name|c
operator|==
name|VDELIM
condition|)
block|{
comment|/* try to find closing KDELIM, and replace value */
name|tlim
operator|=
name|keyval
operator|.
name|string
operator|+
name|keyval
operator|.
name|size
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ds
condition|)
name|GETC_
argument_list|(
argument|frew
argument_list|,
argument|c
argument_list|)
else|else
name|cachegeteof_
argument_list|(
argument|c
argument_list|,
argument|goto keystring_eof;
argument_list|)
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|KDELIM
condition|)
break|break;
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|tlim
operator|<=
name|tp
condition|)
name|tp
operator|=
name|bufenlarge
argument_list|(
operator|&
name|keyval
argument_list|,
operator|&
name|tlim
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SDELIM
operator|&&
name|ds
condition|)
block|{
comment|/*skip next SDELIM */
name|GETC_
argument_list|(
argument|frew
argument_list|,
argument|c
argument_list|)
if|if
condition|(
name|c
operator|!=
name|SDELIM
condition|)
block|{
comment|/* end of string before closing KDELIM or newline */
name|nextc
operator|=
name|c
expr_stmt|;
goto|goto
name|keystring_eof
goto|;
block|}
block|}
block|}
if|if
condition|(
name|c
operator|!=
name|KDELIM
condition|)
block|{
comment|/* couldn't find closing KDELIM -- give up */
operator|*
name|tp
operator|=
literal|0
expr_stmt|;
name|aputs
argument_list|(
name|keyval
operator|.
name|string
argument_list|,
name|out
argument_list|)
expr_stmt|;
continue|continue;
comment|/* last c handled properly */
block|}
block|}
comment|/* now put out the new keyword value */
name|uncache
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|keyreplace
argument_list|(
name|matchresult
argument_list|,
name|delta
argument_list|,
name|ds
argument_list|,
name|infile
argument_list|,
name|out
argument_list|,
name|dolog
argument_list|)
expr_stmt|;
name|cache
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|e
operator|=
literal|1
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
name|keystring_eof
label|:
operator|*
name|tp
operator|=
literal|0
expr_stmt|;
name|aputs
argument_list|(
name|keyval
operator|.
name|string
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|uncache_exit
label|:
name|uncache
argument_list|(
name|infile
argument_list|)
expr_stmt|;
return|return
name|r
operator|+
name|e
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|escape_string
parameter_list|(
name|out
parameter_list|,
name|s
parameter_list|)
specifier|register
name|FILE
modifier|*
name|out
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
comment|/* Output to OUT the string S, escaping chars that would break `ci -k'.  */
block|{
specifier|register
name|char
name|c
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
condition|)
block|{
case|case
literal|0
case|:
return|return;
case|case
literal|'\t'
case|:
name|aputs
argument_list|(
literal|"\\t"
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|aputs
argument_list|(
literal|"\\n"
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
literal|' '
case|:
name|aputs
argument_list|(
literal|"\\040"
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|KDELIM
case|:
name|aputs
argument_list|(
literal|"\\044"
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
name|VERSION
argument_list|(
literal|5
argument_list|)
operator|<=
name|RCSversion
condition|)
block|{
name|aputs
argument_list|(
literal|"\\\\"
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* fall into */
default|default:
name|aputc_
argument_list|(
argument|c
argument_list|,
argument|out
argument_list|)
break|break;
block|}
block|}
end_function

begin_decl_stmt
name|char
specifier|const
name|ciklog
index|[
name|ciklogsize
index|]
init|=
literal|"checked in with -k by "
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|keyreplace
parameter_list|(
name|marker
parameter_list|,
name|delta
parameter_list|,
name|delimstuffed
parameter_list|,
name|infile
parameter_list|,
name|out
parameter_list|,
name|dolog
parameter_list|)
name|enum
name|markers
name|marker
decl_stmt|;
specifier|register
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
name|int
name|delimstuffed
decl_stmt|;
name|RILE
modifier|*
name|infile
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|out
decl_stmt|;
name|int
name|dolog
decl_stmt|;
comment|/* function: outputs the keyword value(s) corresponding to marker.  * Attributes are derived from delta.  */
block|{
specifier|register
name|char
specifier|const
modifier|*
name|sp
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|date
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|size_t
name|cs
decl_stmt|,
name|cw
decl_stmt|,
name|ls
decl_stmt|;
name|char
specifier|const
modifier|*
name|sp1
decl_stmt|;
name|char
name|datebuf
index|[
name|datesize
operator|+
name|zonelenmax
index|]
decl_stmt|;
name|int
name|RCSv
decl_stmt|;
name|int
name|exp
decl_stmt|;
name|sp
operator|=
name|Keyword
index|[
operator|(
name|int
operator|)
name|marker
index|]
expr_stmt|;
name|exp
operator|=
name|Expand
expr_stmt|;
name|date
operator|=
name|delta
operator|->
name|date
expr_stmt|;
name|RCSv
operator|=
name|RCSversion
expr_stmt|;
if|if
condition|(
name|exp
operator|!=
name|VAL_EXPAND
condition|)
name|aprintf
argument_list|(
name|out
argument_list|,
literal|"%c%s"
argument_list|,
name|KDELIM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|!=
name|KEY_EXPAND
condition|)
block|{
if|if
condition|(
name|exp
operator|!=
name|VAL_EXPAND
condition|)
name|aprintf
argument_list|(
name|out
argument_list|,
literal|"%c%c"
argument_list|,
name|VDELIM
argument_list|,
name|marker
operator|==
name|Log
operator|&&
name|RCSv
operator|<
name|VERSION
argument_list|(
literal|5
argument_list|)
condition|?
literal|'\t'
else|:
literal|' '
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|marker
condition|)
block|{
case|case
name|Author
case|:
name|aputs
argument_list|(
name|delta
operator|->
name|author
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|Date
case|:
name|aputs
argument_list|(
name|date2str
argument_list|(
name|date
argument_list|,
name|datebuf
argument_list|)
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|FreeBSD
case|:
case|case
name|Id
case|:
case|case
name|Header
case|:
name|escape_string
argument_list|(
name|out
argument_list|,
name|marker
operator|==
name|Id
operator|||
name|marker
operator|==
name|FreeBSD
operator|||
name|RCSv
operator|<
name|VERSION
argument_list|(
literal|4
argument_list|)
condition|?
name|basefilename
argument_list|(
name|RCSname
argument_list|)
else|:
name|getfullRCSname
argument_list|()
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
name|out
argument_list|,
literal|" %s %s %s %s"
argument_list|,
name|delta
operator|->
name|num
argument_list|,
name|date2str
argument_list|(
name|date
argument_list|,
name|datebuf
argument_list|)
argument_list|,
name|delta
operator|->
name|author
argument_list|,
name|RCSv
operator|==
name|VERSION
argument_list|(
literal|3
argument_list|)
operator|&&
name|delta
operator|->
name|lockedby
condition|?
literal|"Locked"
else|:
name|delta
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|->
name|lockedby
condition|)
if|if
condition|(
name|VERSION
argument_list|(
literal|5
argument_list|)
operator|<=
name|RCSv
condition|)
block|{
if|if
condition|(
name|locker_expansion
operator|||
name|exp
operator|==
name|KEYVALLOCK_EXPAND
condition|)
name|aprintf
argument_list|(
name|out
argument_list|,
literal|" %s"
argument_list|,
name|delta
operator|->
name|lockedby
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RCSv
operator|==
name|VERSION
argument_list|(
literal|4
argument_list|)
condition|)
name|aprintf
argument_list|(
name|out
argument_list|,
literal|" Locker: %s"
argument_list|,
name|delta
operator|->
name|lockedby
argument_list|)
expr_stmt|;
break|break;
case|case
name|Locker
case|:
if|if
condition|(
name|delta
operator|->
name|lockedby
condition|)
if|if
condition|(
name|locker_expansion
operator|||
name|exp
operator|==
name|KEYVALLOCK_EXPAND
operator|||
name|RCSv
operator|<=
name|VERSION
argument_list|(
literal|4
argument_list|)
condition|)
name|aputs
argument_list|(
name|delta
operator|->
name|lockedby
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|Log
case|:
case|case
name|RCSfile
case|:
name|escape_string
argument_list|(
name|out
argument_list|,
name|basefilename
argument_list|(
name|RCSname
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|Name
case|:
if|if
condition|(
name|delta
operator|->
name|name
condition|)
name|aputs
argument_list|(
name|delta
operator|->
name|name
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|Revision
case|:
name|aputs
argument_list|(
name|delta
operator|->
name|num
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
case|case
name|Source
case|:
name|escape_string
argument_list|(
name|out
argument_list|,
name|getfullRCSname
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|State
case|:
name|aputs
argument_list|(
name|delta
operator|->
name|state
argument_list|,
name|out
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|exp
operator|!=
name|VAL_EXPAND
condition|)
name|afputc
argument_list|(
literal|' '
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exp
operator|!=
name|VAL_EXPAND
condition|)
name|afputc
argument_list|(
name|KDELIM
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|marker
operator|==
name|Log
operator|&&
name|dolog
condition|)
block|{
name|struct
name|buf
name|leader
decl_stmt|;
name|sp
operator|=
name|delta
operator|->
name|log
operator|.
name|string
expr_stmt|;
name|ls
operator|=
name|delta
operator|->
name|log
operator|.
name|size
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|ciklog
argument_list|)
operator|-
literal|1
operator|<=
name|ls
operator|&&
operator|!
name|memcmp
argument_list|(
name|sp
argument_list|,
name|ciklog
argument_list|,
sizeof|sizeof
argument_list|(
name|ciklog
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
return|return;
name|bufautobegin
argument_list|(
operator|&
name|leader
argument_list|)
expr_stmt|;
if|if
condition|(
name|RCSversion
operator|<
name|VERSION
argument_list|(
literal|5
argument_list|)
condition|)
block|{
name|cp
operator|=
name|Comment
operator|.
name|string
expr_stmt|;
name|cs
operator|=
name|Comment
operator|.
name|size
expr_stmt|;
block|}
else|else
block|{
name|int
name|kdelim_found
init|=
literal|0
decl_stmt|;
name|Ioffset_type
name|chars_read
init|=
name|Itell
argument_list|(
name|infile
argument_list|)
decl_stmt|;
name|declarecache
expr_stmt|;
name|setupcache
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|cache
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
comment|/* Pacify `gcc -Wall'.  */
comment|/* 		    * Back up to the start of the current input line, 		    * setting CS to the number of characters before `$Log'. 		    */
name|cs
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
operator|--
name|chars_read
condition|)
goto|goto
name|done_backing_up
goto|;
name|cacheunget_
argument_list|(
argument|infile
argument_list|,
argument|c
argument_list|)
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|c
operator|==
name|SDELIM
operator|&&
name|delimstuffed
condition|)
block|{
if|if
condition|(
operator|!
operator|--
name|chars_read
condition|)
break|break;
name|cacheunget_
argument_list|(
argument|infile
argument_list|,
argument|c
argument_list|)
if|if
condition|(
name|c
operator|!=
name|SDELIM
condition|)
block|{
name|cacheget_
argument_list|(
argument|c
argument_list|)
break|break;
block|}
block|}
name|cs
operator|+=
name|kdelim_found
expr_stmt|;
name|kdelim_found
operator||=
name|c
operator|==
name|KDELIM
expr_stmt|;
block|}
name|cacheget_
argument_list|(
argument|c
argument_list|)
name|done_backing_up
label|:
empty_stmt|;
comment|/* Copy characters before `$Log' into LEADER.  */
name|bufalloc
argument_list|(
operator|&
name|leader
argument_list|,
name|cs
argument_list|)
expr_stmt|;
name|cp
operator|=
name|leader
operator|.
name|string
expr_stmt|;
for|for
control|(
name|cw
operator|=
literal|0
init|;
name|cw
operator|<
name|cs
condition|;
name|cw
operator|++
control|)
block|{
name|leader
operator|.
name|string
index|[
name|cw
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SDELIM
operator|&&
name|delimstuffed
condition|)
name|cacheget_
argument_list|(
argument|c
argument_list|)
name|cacheget_
argument_list|(
argument|c
argument_list|)
block|}
comment|/* Convert traditional C or Pascal leader to ` *'.  */
for|for
control|(
name|cw
operator|=
literal|0
init|;
name|cw
operator|<
name|cs
condition|;
name|cw
operator|++
control|)
if|if
condition|(
name|ctab
index|[
operator|(
name|unsigned
name|char
operator|)
name|cp
index|[
name|cw
index|]
index|]
operator|!=
name|SPACE
condition|)
break|break;
if|if
condition|(
name|cw
operator|+
literal|1
operator|<
name|cs
operator|&&
name|cp
index|[
name|cw
operator|+
literal|1
index|]
operator|==
literal|'*'
operator|&&
operator|(
name|cp
index|[
name|cw
index|]
operator|==
literal|'/'
operator|||
name|cp
index|[
name|cw
index|]
operator|==
literal|'('
operator|)
condition|)
block|{
name|size_t
name|i
init|=
name|cw
operator|+
literal|1
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
if|if
condition|(
operator|++
name|i
operator|==
name|cs
condition|)
block|{
name|warn
argument_list|(
literal|"`%c* $Log' is obsolescent; use ` * $Log'."
argument_list|,
name|cp
index|[
name|cw
index|]
argument_list|)
expr_stmt|;
name|leader
operator|.
name|string
index|[
name|cw
index|]
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|ctab
index|[
operator|(
name|unsigned
name|char
operator|)
name|cp
index|[
name|i
index|]
index|]
operator|!=
name|SPACE
condition|)
break|break;
block|}
comment|/* Skip `$Log ... $' string.  */
do|do
block|{
name|cacheget_
argument_list|(
argument|c
argument_list|)
block|}
do|while
condition|(
name|c
operator|!=
name|KDELIM
condition|)
do|;
name|uncache
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
name|afputc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|awrite
argument_list|(
name|cp
argument_list|,
name|cs
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|sp1
operator|=
name|date2str
argument_list|(
name|date
argument_list|,
name|datebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|VERSION
argument_list|(
literal|5
argument_list|)
operator|<=
name|RCSv
condition|)
block|{
name|aprintf
argument_list|(
name|out
argument_list|,
literal|"Revision %s  %s  %s"
argument_list|,
name|delta
operator|->
name|num
argument_list|,
name|sp1
argument_list|,
name|delta
operator|->
name|author
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* oddity: 2 spaces between date and time, not 1 as usual */
name|sp1
operator|=
name|strchr
argument_list|(
name|sp1
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
name|out
argument_list|,
literal|"Revision %s  %.*s %s  %s"
argument_list|,
name|delta
operator|->
name|num
argument_list|,
call|(
name|int
call|)
argument_list|(
name|sp1
operator|-
name|datebuf
argument_list|)
argument_list|,
name|datebuf
argument_list|,
name|sp1
argument_list|,
name|delta
operator|->
name|author
argument_list|)
expr_stmt|;
block|}
comment|/* Do not include state: it may change and is not updated.  */
name|cw
operator|=
name|cs
expr_stmt|;
if|if
condition|(
name|VERSION
argument_list|(
literal|5
argument_list|)
operator|<=
name|RCSv
condition|)
for|for
control|(
init|;
name|cw
operator|&&
operator|(
name|cp
index|[
name|cw
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|cp
index|[
name|cw
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|;
operator|--
name|cw
control|)
continue|continue;
for|for
control|(
init|;
condition|;
control|)
block|{
name|afputc
argument_list|(
literal|'\n'
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|awrite
argument_list|(
name|cp
argument_list|,
name|cw
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ls
condition|)
break|break;
operator|--
name|ls
expr_stmt|;
name|c
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|awrite
argument_list|(
name|cp
operator|+
name|cw
argument_list|,
name|cs
operator|-
name|cw
argument_list|,
name|out
argument_list|)
expr_stmt|;
do|do
block|{
name|afputc
argument_list|(
name|c
argument_list|,
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ls
condition|)
break|break;
operator|--
name|ls
expr_stmt|;
name|c
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
block|}
block|}
name|bufautoend
argument_list|(
operator|&
name|leader
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|has_readlink
end_if

begin_decl_stmt
specifier|static
name|int
name|resolve_symlink
name|P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|resolve_symlink
parameter_list|(
name|L
parameter_list|)
name|struct
name|buf
modifier|*
name|L
decl_stmt|;
comment|/*  * If L is a symbolic link, resolve it to the name that it points to.  * If unsuccessful, set errno and yield -1.  * If it points to an existing file, yield 1.  * Otherwise, set errno=ENOENT and yield 0.  */
block|{
name|char
modifier|*
name|b
decl_stmt|,
name|a
index|[
name|SIZEABLE_PATH
index|]
decl_stmt|;
name|int
name|e
decl_stmt|;
name|size_t
name|s
decl_stmt|;
name|ssize_t
name|r
decl_stmt|;
name|struct
name|buf
name|bigbuf
decl_stmt|;
name|int
name|linkcount
init|=
name|MAXSYMLINKS
decl_stmt|;
name|b
operator|=
name|a
expr_stmt|;
name|s
operator|=
sizeof|sizeof
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|bigbuf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|readlink
argument_list|(
name|L
operator|->
name|string
argument_list|,
name|b
argument_list|,
name|s
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|r
operator|==
name|s
condition|)
block|{
name|bufalloc
argument_list|(
operator|&
name|bigbuf
argument_list|,
name|s
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|b
operator|=
name|bigbuf
operator|.
name|string
expr_stmt|;
name|s
operator|=
name|bigbuf
operator|.
name|size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|linkcount
operator|--
condition|)
block|{
ifndef|#
directive|ifndef
name|ELOOP
comment|/* 		    * Some pedantic Posix 1003.1-1990 hosts have readlink 		    * but not ELOOP.  Approximate ELOOP with EMLINK. 		    */
define|#
directive|define
name|ELOOP
value|EMLINK
endif|#
directive|endif
name|errno
operator|=
name|ELOOP
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
comment|/* Splice symbolic link into L.  */
name|b
index|[
name|r
index|]
operator|=
literal|'\0'
expr_stmt|;
name|L
operator|->
name|string
index|[
name|ROOTPATH
argument_list|(
name|b
argument_list|)
condition|?
literal|0
else|:
name|basefilename
argument_list|(
name|L
operator|->
name|string
argument_list|)
operator|-
name|L
operator|->
name|string
index|]
operator|=
literal|'\0'
expr_stmt|;
name|bufscat
argument_list|(
name|L
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
name|errno
expr_stmt|;
name|bufautoend
argument_list|(
operator|&
name|bigbuf
argument_list|)
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
switch|switch
condition|(
name|e
condition|)
block|{
case|case
name|readlink_isreg_errno
case|:
return|return
literal|1
return|;
case|case
name|ENOENT
case|:
return|return
literal|0
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|RILE
modifier|*
name|rcswriteopen
parameter_list|(
name|RCSbuf
parameter_list|,
name|status
parameter_list|,
name|mustread
parameter_list|)
name|struct
name|buf
modifier|*
name|RCSbuf
decl_stmt|;
name|struct
name|stat
modifier|*
name|status
decl_stmt|;
name|int
name|mustread
decl_stmt|;
comment|/*  * Create the lock file corresponding to RCSBUF.  * Then try to open RCSBUF for reading and yield its RILE* descriptor.  * Put its status into *STATUS too.  * MUSTREAD is true if the file must already exist, too.  * If all goes well, discard any previously acquired locks,  * and set fdlock to the file descriptor of the RCS lockfile.  */
block|{
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|sp
decl_stmt|,
modifier|*
name|RCSpath
decl_stmt|,
modifier|*
name|x
decl_stmt|;
name|RILE
modifier|*
name|f
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|int
name|e
decl_stmt|,
name|exists
decl_stmt|,
name|fdesc
decl_stmt|,
name|fdescSafer
decl_stmt|,
name|r
decl_stmt|,
name|waslocked
decl_stmt|;
name|struct
name|buf
modifier|*
name|dirt
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|waslocked
operator|=
literal|0
operator|<=
name|fdlock
expr_stmt|;
name|exists
operator|=
if|#
directive|if
name|has_readlink
name|resolve_symlink
argument_list|(
name|RCSbuf
argument_list|)
expr_stmt|;
else|#
directive|else
name|stat
argument_list|(
name|RCSbuf
operator|->
name|string
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
literal|0
condition|?
literal|1
else|:
name|errno
operator|==
name|ENOENT
condition|?
literal|0
else|:
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|exists
operator|<
operator|(
name|mustread
operator||
name|waslocked
operator|)
condition|)
comment|/* 		 * There's an unusual problem with the RCS file; 		 * or the RCS file doesn't exist, 		 * and we must read or we already have a lock elsewhere. 		 */
return|return
literal|0
return|;
name|RCSpath
operator|=
name|RCSbuf
operator|->
name|string
expr_stmt|;
name|sp
operator|=
name|basefilename
argument_list|(
name|RCSpath
argument_list|)
expr_stmt|;
name|l
operator|=
name|sp
operator|-
name|RCSpath
expr_stmt|;
name|dirt
operator|=
operator|&
name|dirtpname
index|[
name|waslocked
index|]
expr_stmt|;
name|bufscpy
argument_list|(
name|dirt
argument_list|,
name|RCSpath
argument_list|)
expr_stmt|;
name|tp
operator|=
name|dirt
operator|->
name|string
operator|+
name|l
expr_stmt|;
name|x
operator|=
name|rcssuffix
argument_list|(
name|RCSpath
argument_list|)
expr_stmt|;
if|#
directive|if
name|has_readlink
if|if
condition|(
operator|!
name|x
condition|)
block|{
name|error
argument_list|(
literal|"symbolic link to non RCS file `%s'"
argument_list|,
name|RCSpath
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|*
name|sp
operator|==
operator|*
name|x
condition|)
block|{
name|error
argument_list|(
literal|"RCS pathname `%s' incompatible with suffix `%s'"
argument_list|,
name|sp
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Create a lock filename that is a function of the RCS filename.  */
if|if
condition|(
operator|*
name|x
condition|)
block|{
comment|/* 		 * The suffix is nonempty. 		 * The lock filename is the first char of of the suffix, 		 * followed by the RCS filename with last char removed.  E.g.: 		 *	foo,v	RCS filename with suffix ,v 		 *	,foo,	lock filename 		 */
operator|*
name|tp
operator|++
operator|=
operator|*
name|x
expr_stmt|;
while|while
condition|(
operator|*
name|sp
condition|)
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
operator|*
operator|--
name|tp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The suffix is empty. 		 * The lock filename is the RCS filename 		 * with last char replaced by '_'. 		 */
while|while
condition|(
operator|(
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
operator|)
condition|)
continue|continue;
name|tp
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|tp
operator|==
literal|'_'
condition|)
block|{
name|error
argument_list|(
literal|"RCS pathname `%s' ends with `%c'"
argument_list|,
name|RCSpath
argument_list|,
operator|*
name|tp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|tp
operator|=
literal|'_'
expr_stmt|;
block|}
name|sp
operator|=
name|dirt
operator|->
name|string
expr_stmt|;
name|f
operator|=
literal|0
expr_stmt|;
comment|/* 	* good news: 	*	open(f, O_CREAT|O_EXCL|O_TRUNC|..., OPEN_CREAT_READONLY) 	*	is atomic according to Posix 1003.1-1990. 	* bad news: 	*	NFS ignores O_EXCL and doesn't comply with Posix 1003.1-1990. 	* good news: 	*	(O_TRUNC,OPEN_CREAT_READONLY) normally guarantees atomicity 	*	even with NFS. 	* bad news: 	*	If you're root, (O_TRUNC,OPEN_CREAT_READONLY) doesn't 	*	guarantee atomicity. 	* good news: 	*	Root-over-the-wire NFS access is rare for security reasons. 	*	This bug has never been reported in practice with RCS. 	* So we don't worry about this bug. 	* 	* An even rarer NFS bug can occur when clients retry requests. 	* This can happen in the usual case of NFS over UDP. 	* Suppose client A releases a lock by renaming ",f," to "f,v" at 	* about the same time that client B obtains a lock by creating ",f,", 	* and suppose A's first rename request is delayed, so A reissues it. 	* The sequence of events might be: 	*	A sends rename(",f,", "f,v") 	*	B sends create(",f,") 	*	A sends retry of rename(",f,", "f,v") 	*	server receives, does, and acknowledges A's first rename() 	*	A receives acknowledgment, and its RCS program exits 	*	server receives, does, and acknowledges B's create() 	*	server receives, does, and acknowledges A's retry of rename() 	* This not only wrongly deletes B's lock, it removes the RCS file! 	* Most NFS implementations have idempotency caches that usually prevent 	* this scenario, but such caches are finite and can be overrun. 	* This problem afflicts not only RCS, which uses open() and rename() 	* to get and release locks; it also afflicts the traditional 	* Unix method of using link() and unlink() to get and release locks, 	* and the less traditional method of using mkdir() and rmdir(). 	* There is no easy workaround. 	* Any new method based on lockf() seemingly would be incompatible with 	* the old methods; besides, lockf() is notoriously buggy under NFS. 	* Since this problem afflicts scads of Unix programs, but is so rare 	* that nobody seems to be worried about it, we won't worry either. 	*/
if|#
directive|if
operator|!
name|open_can_creat
define|#
directive|define
name|create
parameter_list|(
name|f
parameter_list|)
value|creat(f, OPEN_CREAT_READONLY)
else|#
directive|else
define|#
directive|define
name|create
parameter_list|(
name|f
parameter_list|)
value|open(f, OPEN_O_BINARY|OPEN_O_LOCK|OPEN_O_WRONLY|O_CREAT|O_EXCL|O_TRUNC, OPEN_CREAT_READONLY)
endif|#
directive|endif
name|catchints
argument_list|()
expr_stmt|;
name|ignoreints
argument_list|()
expr_stmt|;
comment|/* 	 * Create a lock file for an RCS file.  This should be atomic, i.e. 	 * if two processes try it simultaneously, at most one should succeed. 	 */
name|seteid
argument_list|()
expr_stmt|;
name|fdesc
operator|=
name|create
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|fdescSafer
operator|=
name|fdSafer
argument_list|(
name|fdesc
argument_list|)
expr_stmt|;
comment|/* Do it now; setrid might use stderr.  */
name|e
operator|=
name|errno
expr_stmt|;
name|setrid
argument_list|()
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|fdesc
condition|)
name|dirtpmaker
index|[
literal|0
index|]
operator|=
name|effective
expr_stmt|;
if|if
condition|(
name|fdescSafer
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|==
name|EACCES
operator|&&
name|stat
argument_list|(
name|sp
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
literal|0
condition|)
comment|/* The RCS file is busy.  */
name|e
operator|=
name|EEXIST
expr_stmt|;
block|}
else|else
block|{
name|e
operator|=
name|ENOENT
expr_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
name|f
operator|=
name|Iopen
argument_list|(
name|RCSpath
argument_list|,
name|FOPEN_RB
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|e
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|f
operator|&&
name|waslocked
condition|)
block|{
comment|/* Discard the previous lock in favor of this one.  */
name|ORCSclose
argument_list|()
expr_stmt|;
name|seteid
argument_list|()
expr_stmt|;
name|r
operator|=
name|un_link
argument_list|(
name|lockname
argument_list|)
expr_stmt|;
name|e
operator|=
name|errno
expr_stmt|;
name|setrid
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|enfaterror
argument_list|(
name|e
argument_list|,
name|lockname
argument_list|)
expr_stmt|;
name|bufscpy
argument_list|(
operator|&
name|dirtpname
index|[
name|lockdirtp_index
index|]
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
name|fdlock
operator|=
name|fdescSafer
expr_stmt|;
block|}
name|restoreints
argument_list|()
expr_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_function
name|void
name|keepdirtemp
parameter_list|(
name|name
parameter_list|)
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
comment|/* Do not unlink name, either because it's not there any more,  * or because it has already been unlinked.  */
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|DIRTEMPNAMES
init|;
literal|0
operator|<=
operator|--
name|i
condition|;
control|)
if|if
condition|(
name|dirtpname
index|[
name|i
index|]
operator|.
name|string
operator|==
name|name
condition|)
block|{
name|dirtpmaker
index|[
name|i
index|]
operator|=
name|notmade
expr_stmt|;
return|return;
block|}
name|faterror
argument_list|(
literal|"keepdirtemp"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
specifier|const
modifier|*
name|makedirtemp
parameter_list|(
name|isworkfile
parameter_list|)
name|int
name|isworkfile
decl_stmt|;
comment|/*  * Create a unique pathname and store it into dirtpname.  * Because of storage in tpnames, dirtempunlink() can unlink the file later.  * Return a pointer to the pathname created.  * If ISWORKFILE is 1, put it into the working file's directory;  * if 0, put the unique file in RCSfile's directory.  */
block|{
specifier|register
name|char
modifier|*
name|tp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
specifier|register
name|size_t
name|dl
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bn
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|name
init|=
name|isworkfile
condition|?
name|workname
else|:
name|RCSname
decl_stmt|;
name|dl
operator|=
name|basefilename
argument_list|(
name|name
argument_list|)
operator|-
name|name
expr_stmt|;
name|bn
operator|=
operator|&
name|dirtpname
index|[
name|newRCSdirtp_index
operator|+
name|isworkfile
index|]
expr_stmt|;
name|bufalloc
argument_list|(
name|bn
argument_list|,
if|#
directive|if
name|has_mktemp
name|dl
operator|+
literal|9
else|#
directive|else
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|3
endif|#
directive|endif
argument_list|)
expr_stmt|;
name|bufscpy
argument_list|(
name|bn
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|np
operator|=
name|tp
operator|=
name|bn
operator|->
name|string
expr_stmt|;
name|tp
operator|+=
name|dl
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|'_'
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|'0'
operator|+
name|isworkfile
expr_stmt|;
name|catchints
argument_list|()
expr_stmt|;
if|#
directive|if
name|has_mktemp
name|VOID
name|strcpy
argument_list|(
name|tp
argument_list|,
literal|"XXXXXX"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mktemp
argument_list|(
name|np
argument_list|)
operator|||
operator|!
operator|*
name|np
condition|)
name|faterror
argument_list|(
literal|"can't make temporary pathname `%.*s_%cXXXXXX'"
argument_list|,
operator|(
name|int
operator|)
name|dl
argument_list|,
name|name
argument_list|,
literal|'0'
operator|+
name|isworkfile
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 		 * Posix 1003.1-1990 has no reliable way 		 * to create a unique file in a named directory. 		 * We fudge here.  If the filename is abcde, 		 * the temp filename is _Ncde where N is a digit. 		 */
name|name
operator|+=
name|dl
expr_stmt|;
if|if
condition|(
operator|*
name|name
condition|)
name|name
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|name
condition|)
name|name
operator|++
expr_stmt|;
name|VOID
name|strcpy
argument_list|(
name|tp
argument_list|,
name|name
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|dirtpmaker
index|[
name|newRCSdirtp_index
operator|+
name|isworkfile
index|]
operator|=
name|real
expr_stmt|;
return|return
name|np
return|;
block|}
end_function

begin_function
name|void
name|dirtempunlink
parameter_list|()
comment|/* Clean up makedirtemp() files.  May be invoked by signal handler. */
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|enum
name|maker
name|m
decl_stmt|;
for|for
control|(
name|i
operator|=
name|DIRTEMPNAMES
init|;
literal|0
operator|<=
operator|--
name|i
condition|;
control|)
if|if
condition|(
operator|(
name|m
operator|=
name|dirtpmaker
index|[
name|i
index|]
operator|)
operator|!=
name|notmade
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|effective
condition|)
name|seteid
argument_list|()
expr_stmt|;
name|VOID
name|un_link
argument_list|(
name|dirtpname
index|[
name|i
index|]
operator|.
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|effective
condition|)
name|setrid
argument_list|()
expr_stmt|;
name|dirtpmaker
index|[
name|i
index|]
operator|=
name|notmade
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
if|#
directive|if
name|has_prototypes
name|chnamemod
parameter_list|(
name|FILE
modifier|*
modifier|*
name|fromp
parameter_list|,
name|char
specifier|const
modifier|*
name|from
parameter_list|,
name|char
specifier|const
modifier|*
name|to
parameter_list|,
name|int
name|set_mode
parameter_list|,
name|mode_t
name|mode
parameter_list|,
name|time_t
name|mtime
parameter_list|)
comment|/* The `#if has_prototypes' is needed because mode_t might promote to int.  */
else|#
directive|else
function|chnamemod
parameter_list|(
name|fromp
parameter_list|,
name|from
parameter_list|,
name|to
parameter_list|,
name|set_mode
parameter_list|,
name|mode
parameter_list|,
name|mtime
parameter_list|)
name|FILE
modifier|*
modifier|*
name|fromp
decl_stmt|;
name|char
specifier|const
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|set_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mode_t
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|time_t
name|mtime
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Rename a file (with stream pointer *FROMP) from FROM to TO.  * FROM already exists.  * If 0< SET_MODE, change the mode to MODE, before renaming if possible.  * If MTIME is not -1, change its mtime to MTIME before renaming.  * Close and clear *FROMP before renaming it.  * Unlink TO if it already exists.  * Return -1 on error (setting errno), 0 otherwise.  */
end_comment

begin_block
block|{
name|mode_t
name|mode_while_renaming
init|=
name|mode
decl_stmt|;
name|int
name|fchmod_set_mode
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|bad_a_rename
operator|||
name|bad_NFS_rename
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|bad_NFS_rename
operator|||
operator|(
name|bad_a_rename
operator|&&
name|set_mode
operator|<=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
operator|*
name|fromp
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|bad_a_rename
operator|&&
name|set_mode
operator|<=
literal|0
condition|)
name|mode
operator|=
name|st
operator|.
name|st_mode
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|bad_a_rename
comment|/* 		* There's a short window of inconsistency 		* during which the lock file is writable. 		*/
name|mode_while_renaming
operator|=
name|mode
operator||
name|S_IWUSR
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|mode_while_renaming
condition|)
name|set_mode
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|has_fchmod
if|if
condition|(
literal|0
operator|<
name|set_mode
operator|&&
name|fchmod
argument_list|(
name|fileno
argument_list|(
operator|*
name|fromp
argument_list|)
argument_list|,
name|mode_while_renaming
argument_list|)
operator|==
literal|0
condition|)
name|fchmod_set_mode
operator|=
name|set_mode
expr_stmt|;
endif|#
directive|endif
comment|/* If bad_chmod_close, we must close before chmod.  */
name|Ozclose
argument_list|(
name|fromp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fchmod_set_mode
operator|<
name|set_mode
operator|&&
name|chmod
argument_list|(
name|from
argument_list|,
name|mode_while_renaming
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|setmtime
argument_list|(
name|from
argument_list|,
name|mtime
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|#
directive|if
operator|!
name|has_rename
operator|||
name|bad_b_rename
comment|/* 		* There's a short window of inconsistency 		* during which TO does not exist. 		*/
if|if
condition|(
name|un_link
argument_list|(
name|to
argument_list|)
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
if|#
directive|if
name|has_rename
if|if
condition|(
name|rename
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|has_NFS
operator|&&
name|errno
operator|==
name|ENOENT
operator|)
condition|)
return|return
operator|-
literal|1
return|;
else|#
directive|else
if|if
condition|(
name|do_link
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
operator|!=
literal|0
operator|||
name|un_link
argument_list|(
name|from
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
if|#
directive|if
name|bad_NFS_rename
block|{
comment|/* 	    * Check whether the rename falsely reported success. 	    * A race condition can occur between the rename and the stat. 	    */
name|struct
name|stat
name|tostat
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|to
argument_list|,
operator|&
name|tostat
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|same_file
argument_list|(
name|st
argument_list|,
name|tostat
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
endif|#
directive|endif
if|#
directive|if
name|bad_a_rename
if|if
condition|(
literal|0
operator|<
name|set_mode
operator|&&
name|chmod
argument_list|(
name|to
argument_list|,
name|mode
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_block

begin_function
name|int
name|setmtime
parameter_list|(
name|file
parameter_list|,
name|mtime
parameter_list|)
name|char
specifier|const
modifier|*
name|file
decl_stmt|;
name|time_t
name|mtime
decl_stmt|;
comment|/* Set FILE's last modified time to MTIME, but do nothing if MTIME is -1.  */
block|{
specifier|static
name|struct
name|utimbuf
name|amtime
decl_stmt|;
comment|/* static so unused fields are zero */
if|if
condition|(
name|mtime
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
name|amtime
operator|.
name|actime
operator|=
name|now
argument_list|()
expr_stmt|;
name|amtime
operator|.
name|modtime
operator|=
name|mtime
expr_stmt|;
return|return
name|utime
argument_list|(
name|file
argument_list|,
operator|&
name|amtime
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|findlock
parameter_list|(
name|delete
parameter_list|,
name|target
parameter_list|)
name|int
name|delete
decl_stmt|;
name|struct
name|hshentry
modifier|*
modifier|*
name|target
decl_stmt|;
comment|/*  * Find the first lock held by caller and return a pointer  * to the locked delta; also removes the lock if DELETE.  * If one lock, put it into *TARGET.  * Return 0 for no locks, 1 for one, 2 for two or more.  */
block|{
specifier|register
name|struct
name|rcslock
modifier|*
name|next
decl_stmt|,
modifier|*
modifier|*
name|trail
decl_stmt|,
modifier|*
modifier|*
name|found
decl_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|trail
operator|=
operator|&
name|Locks
init|;
operator|(
name|next
operator|=
operator|*
name|trail
operator|)
condition|;
name|trail
operator|=
operator|&
name|next
operator|->
name|nextlock
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|getcaller
argument_list|()
argument_list|,
name|next
operator|->
name|login
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|found
condition|)
block|{
name|rcserror
argument_list|(
literal|"multiple revisions locked by %s; please specify one"
argument_list|,
name|getcaller
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
name|found
operator|=
name|trail
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
return|return
literal|0
return|;
name|next
operator|=
operator|*
name|found
expr_stmt|;
operator|*
name|target
operator|=
name|next
operator|->
name|delta
expr_stmt|;
if|if
condition|(
name|delete
condition|)
block|{
name|next
operator|->
name|delta
operator|->
name|lockedby
operator|=
literal|0
expr_stmt|;
operator|*
name|found
operator|=
name|next
operator|->
name|nextlock
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|addlock
parameter_list|(
name|delta
parameter_list|,
name|verbose
parameter_list|)
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
name|int
name|verbose
decl_stmt|;
comment|/*  * Add a lock held by caller to DELTA and yield 1 if successful.  * Print an error message if verbose and yield -1 if no lock is added because  * DELTA is locked by somebody other than caller.  * Return 0 if the caller already holds the lock.  */
block|{
specifier|register
name|struct
name|rcslock
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|next
operator|=
name|Locks
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|nextlock
control|)
if|if
condition|(
name|cmpnum
argument_list|(
name|delta
operator|->
name|num
argument_list|,
name|next
operator|->
name|delta
operator|->
name|num
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|getcaller
argument_list|()
argument_list|,
name|next
operator|->
name|login
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
block|{
if|if
condition|(
name|verbose
condition|)
name|rcserror
argument_list|(
literal|"Revision %s is already locked by %s."
argument_list|,
name|delta
operator|->
name|num
argument_list|,
name|next
operator|->
name|login
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|next
operator|=
name|ftalloc
argument_list|(
expr|struct
name|rcslock
argument_list|)
expr_stmt|;
name|delta
operator|->
name|lockedby
operator|=
name|next
operator|->
name|login
operator|=
name|getcaller
argument_list|()
expr_stmt|;
name|next
operator|->
name|delta
operator|=
name|delta
expr_stmt|;
name|next
operator|->
name|nextlock
operator|=
name|Locks
expr_stmt|;
name|Locks
operator|=
name|next
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|addsymbol
parameter_list|(
name|num
parameter_list|,
name|name
parameter_list|,
name|rebind
parameter_list|)
name|char
specifier|const
modifier|*
name|num
decl_stmt|,
decl|*
name|name
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|rebind
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Associate with revision NUM the new symbolic NAME.  * If NAME already exists and REBIND is set, associate NAME with NUM;  * otherwise, print an error message and return false;  * Return -1 if unsuccessful, 0 if no change, 1 if change.  */
end_comment

begin_block
block|{
specifier|register
name|struct
name|assoc
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|next
operator|=
name|Symbols
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|nextassoc
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|next
operator|->
name|symbol
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|next
operator|->
name|num
argument_list|,
name|num
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|rebind
condition|)
block|{
name|next
operator|->
name|num
operator|=
name|num
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|rcserror
argument_list|(
literal|"symbolic name %s already bound to %s"
argument_list|,
name|name
argument_list|,
name|next
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|next
operator|=
name|ftalloc
argument_list|(
expr|struct
name|assoc
argument_list|)
expr_stmt|;
name|next
operator|->
name|symbol
operator|=
name|name
expr_stmt|;
name|next
operator|->
name|num
operator|=
name|num
expr_stmt|;
name|next
operator|->
name|nextassoc
operator|=
name|Symbols
expr_stmt|;
name|Symbols
operator|=
name|next
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_function
name|char
specifier|const
modifier|*
name|getcaller
parameter_list|()
comment|/* Get the caller's login name.  */
block|{
if|#
directive|if
name|has_setuid
return|return
name|getusername
argument_list|(
name|euid
argument_list|()
operator|!=
name|ruid
argument_list|()
argument_list|)
return|;
else|#
directive|else
return|return
name|getusername
argument_list|(
name|false
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|checkaccesslist
parameter_list|()
comment|/*  * Return true if caller is the superuser, the owner of the  * file, the access list is empty, or caller is on the access list.  * Otherwise, print an error message and return false.  */
block|{
specifier|register
name|struct
name|access
specifier|const
modifier|*
name|next
decl_stmt|;
if|if
condition|(
operator|!
name|AccessList
operator|||
name|myself
argument_list|(
name|RCSstat
operator|.
name|st_uid
argument_list|)
operator|||
name|strcmp
argument_list|(
name|getcaller
argument_list|()
argument_list|,
literal|"root"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|next
operator|=
name|AccessList
expr_stmt|;
do|do
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|getcaller
argument_list|()
argument_list|,
name|next
operator|->
name|login
argument_list|)
operator|==
literal|0
condition|)
return|return
name|true
return|;
block|}
do|while
condition|(
operator|(
name|next
operator|=
name|next
operator|->
name|nextaccess
operator|)
condition|)
do|;
name|rcserror
argument_list|(
literal|"user %s not on the access list"
argument_list|,
name|getcaller
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
name|int
name|dorewrite
parameter_list|(
name|lockflag
parameter_list|,
name|changed
parameter_list|)
name|int
name|lockflag
decl_stmt|,
name|changed
decl_stmt|;
comment|/*  * Do nothing if LOCKFLAG is zero.  * Prepare to rewrite an RCS file if CHANGED is positive.  * Stop rewriting if CHANGED is zero, because there won't be any changes.  * Fail if CHANGED is negative.  * Return 0 on success, -1 on failure.  */
block|{
name|int
name|r
init|=
literal|0
decl_stmt|,
name|e
decl_stmt|;
if|if
condition|(
name|lockflag
condition|)
if|if
condition|(
name|changed
condition|)
block|{
if|if
condition|(
name|changed
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|putadmin
argument_list|()
expr_stmt|;
name|puttree
argument_list|(
name|Head
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
name|frewrite
argument_list|,
literal|"\n\n%s%c"
argument_list|,
name|Kdesc
argument_list|,
name|nextc
argument_list|)
expr_stmt|;
name|foutptr
operator|=
name|frewrite
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|bad_creat0
name|int
name|nr
init|=
operator|!
operator|!
name|frewrite
decl_stmt|,
name|ne
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|ORCSclose
argument_list|()
expr_stmt|;
name|seteid
argument_list|()
expr_stmt|;
name|ignoreints
argument_list|()
expr_stmt|;
if|#
directive|if
name|bad_creat0
if|if
condition|(
name|nr
condition|)
block|{
name|nr
operator|=
name|un_link
argument_list|(
name|newRCSname
argument_list|)
expr_stmt|;
name|ne
operator|=
name|errno
expr_stmt|;
name|keepdirtemp
argument_list|(
name|newRCSname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|r
operator|=
name|un_link
argument_list|(
name|lockname
argument_list|)
expr_stmt|;
name|e
operator|=
name|errno
expr_stmt|;
name|keepdirtemp
argument_list|(
name|lockname
argument_list|)
expr_stmt|;
name|restoreints
argument_list|()
expr_stmt|;
name|setrid
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|enerror
argument_list|(
name|e
argument_list|,
name|lockname
argument_list|)
expr_stmt|;
if|#
directive|if
name|bad_creat0
if|if
condition|(
name|nr
operator|!=
literal|0
condition|)
block|{
name|enerror
argument_list|(
name|ne
argument_list|,
name|newRCSname
argument_list|)
expr_stmt|;
name|r
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|donerewrite
parameter_list|(
name|changed
parameter_list|,
name|newRCStime
parameter_list|)
name|int
name|changed
decl_stmt|;
name|time_t
name|newRCStime
decl_stmt|;
comment|/*  * Finish rewriting an RCS file if CHANGED is nonzero.  * Set its mode if CHANGED is positive.  * Set its modification time to NEWRCSTIME unless it is -1.  * Return 0 on success, -1 on failure.  */
block|{
name|int
name|r
init|=
literal|0
decl_stmt|,
name|e
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|bad_creat0
name|int
name|lr
decl_stmt|,
name|le
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|changed
operator|&&
operator|!
name|nerror
condition|)
block|{
if|if
condition|(
name|finptr
condition|)
block|{
name|fastcopy
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
name|Izclose
argument_list|(
operator|&
name|finptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|1
operator|<
name|RCSstat
operator|.
name|st_nlink
condition|)
name|rcswarn
argument_list|(
literal|"breaking hard link"
argument_list|)
expr_stmt|;
name|aflush
argument_list|(
name|frewrite
argument_list|)
expr_stmt|;
name|seteid
argument_list|()
expr_stmt|;
name|ignoreints
argument_list|()
expr_stmt|;
name|r
operator|=
name|chnamemod
argument_list|(
operator|&
name|frewrite
argument_list|,
name|newRCSname
argument_list|,
name|RCSname
argument_list|,
name|changed
argument_list|,
name|RCSstat
operator|.
name|st_mode
operator|&
operator|(
name|mode_t
operator|)
operator|~
operator|(
name|S_IWUSR
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
argument_list|,
name|newRCStime
argument_list|)
expr_stmt|;
name|e
operator|=
name|errno
expr_stmt|;
name|keepdirtemp
argument_list|(
name|newRCSname
argument_list|)
expr_stmt|;
if|#
directive|if
name|bad_creat0
name|lr
operator|=
name|un_link
argument_list|(
name|lockname
argument_list|)
expr_stmt|;
name|le
operator|=
name|errno
expr_stmt|;
name|keepdirtemp
argument_list|(
name|lockname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|restoreints
argument_list|()
expr_stmt|;
name|setrid
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|enerror
argument_list|(
name|e
argument_list|,
name|RCSname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"saved in %s"
argument_list|,
name|newRCSname
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|bad_creat0
if|if
condition|(
name|lr
operator|!=
literal|0
condition|)
block|{
name|enerror
argument_list|(
name|le
argument_list|,
name|lockname
argument_list|)
expr_stmt|;
name|r
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
name|void
name|ORCSclose
parameter_list|()
block|{
if|if
condition|(
literal|0
operator|<=
name|fdlock
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
name|fdlock
argument_list|)
operator|!=
literal|0
condition|)
name|efaterror
argument_list|(
name|lockname
argument_list|)
expr_stmt|;
name|fdlock
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|Ozclose
argument_list|(
operator|&
name|frewrite
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ORCSerror
parameter_list|()
comment|/* * Like ORCSclose, except we are cleaning up after an interrupt or fatal error. * Do not report errors, since this may loop.  This is needed only because * some brain-damaged hosts (e.g. OS/2) cannot unlink files that are open, and * some nearly-Posix hosts (e.g. NFS) work better if the files are closed first. * This isn't a completely reliable away to work around brain-damaged hosts, * because of the gap between actual file opening and setting frewrite etc., * but it's better than nothing. */
block|{
if|if
condition|(
literal|0
operator|<=
name|fdlock
condition|)
name|VOID
name|close
argument_list|(
name|fdlock
argument_list|)
decl_stmt|;
if|if
condition|(
name|frewrite
condition|)
comment|/* Avoid fclose, since stdio may not be reentrant.  */
name|VOID
name|close
argument_list|(
name|fileno
argument_list|(
name|frewrite
argument_list|)
argument_list|)
decl_stmt|;
block|}
end_function

end_unit

