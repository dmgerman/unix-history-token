begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convert between RCS time format and Posix and/or C formats.  */
end_comment

begin_comment
comment|/* Copyright 1992, 1993, 1994, 1995 Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_include
include|#
directive|include
file|"partime.h"
end_include

begin_include
include|#
directive|include
file|"maketime.h"
end_include

begin_macro
name|libId
argument_list|(
argument|rcstimeId
argument_list|,
literal|"$FreeBSD$"
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|long
name|zone_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* seconds east of UTC, or TM_LOCAL_ZONE */
end_comment

begin_decl_stmt
specifier|static
name|int
name|use_zone_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if zero, use UTC without zone indication */
end_comment

begin_comment
comment|/* * Convert Unix time to RCS format. * For compatibility with older versions of RCS, * dates from 1900 through 1999 are stored without the leading "19". */
end_comment

begin_function
name|void
name|time2date
parameter_list|(
name|unixtime
parameter_list|,
name|date
parameter_list|)
name|time_t
name|unixtime
decl_stmt|;
name|char
name|date
index|[
name|datesize
index|]
decl_stmt|;
block|{
specifier|register
name|struct
name|tm
specifier|const
modifier|*
name|tm
init|=
name|time2tm
argument_list|(
name|unixtime
argument_list|,
name|RCSversion
operator|<
name|VERSION
argument_list|(
literal|5
argument_list|)
argument_list|)
decl_stmt|;
name|VOID
name|sprintf
argument_list|(
name|date
argument_list|,
if|#
directive|if
name|has_printf_dot
literal|"%.2d.%.2d.%.2d.%.2d.%.2d.%.2d"
argument_list|,
else|#
directive|else
literal|"%02d.%02d.%02d.%02d.%02d.%02d"
argument_list|,
endif|#
directive|endif
name|tm
operator|->
name|tm_year
operator|+
operator|(
operator|(
name|unsigned
operator|)
name|tm
operator|->
name|tm_year
operator|<
literal|100
condition|?
literal|0
else|:
literal|1900
operator|)
argument_list|,
name|tm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tm
operator|->
name|tm_mday
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|,
name|tm
operator|->
name|tm_sec
argument_list|)
decl_stmt|;
block|}
end_function

begin_comment
comment|/* Like str2time, except die if an error was found.  */
end_comment

begin_decl_stmt
specifier|static
name|time_t
name|str2time_checked
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|time_t
operator|,
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|time_t
name|str2time_checked
parameter_list|(
name|source
parameter_list|,
name|default_time
parameter_list|,
name|default_zone
parameter_list|)
name|char
specifier|const
modifier|*
name|source
decl_stmt|;
name|time_t
name|default_time
decl_stmt|;
name|long
name|default_zone
decl_stmt|;
block|{
name|time_t
name|t
init|=
name|str2time
argument_list|(
name|source
argument_list|,
name|default_time
argument_list|,
name|default_zone
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
operator|-
literal|1
condition|)
name|faterror
argument_list|(
literal|"unknown date/time: %s"
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* * Parse a free-format date in SOURCE, convert it * into RCS internal format, and store the result into TARGET. */
end_comment

begin_function
name|void
name|str2date
parameter_list|(
name|source
parameter_list|,
name|target
parameter_list|)
name|char
specifier|const
modifier|*
name|source
decl_stmt|;
name|char
name|target
index|[
name|datesize
index|]
decl_stmt|;
block|{
name|time2date
argument_list|(
name|str2time_checked
argument_list|(
name|source
argument_list|,
name|now
argument_list|()
argument_list|,
name|use_zone_offset
condition|?
name|zone_offset
else|:
name|RCSversion
operator|<
name|VERSION
argument_list|(
literal|5
argument_list|)
condition|?
name|TM_LOCAL_ZONE
else|:
literal|0
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert an RCS internal format date to time_t.  */
end_comment

begin_function
name|time_t
name|date2time
parameter_list|(
name|source
parameter_list|)
name|char
specifier|const
name|source
index|[
name|datesize
index|]
decl_stmt|;
block|{
name|char
name|s
index|[
name|datesize
operator|+
name|zonelenmax
index|]
decl_stmt|;
return|return
name|str2time_checked
argument_list|(
name|date2str
argument_list|(
name|source
argument_list|,
name|s
argument_list|)
argument_list|,
operator|(
name|time_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set the time zone for date2str output.  */
end_comment

begin_function
name|void
name|zone_set
parameter_list|(
name|s
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|use_zone_offset
operator|=
operator|*
name|s
operator|)
condition|)
block|{
name|long
name|zone
decl_stmt|;
name|char
specifier|const
modifier|*
name|zonetail
init|=
name|parzone
argument_list|(
name|s
argument_list|,
operator|&
name|zone
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|zonetail
operator|||
operator|*
name|zonetail
condition|)
name|error
argument_list|(
literal|"%s: not a known time zone"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|zone_offset
operator|=
name|zone
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* * Format a user-readable form of the RCS format DATE into the buffer DATEBUF. * Yield DATEBUF. */
end_comment

begin_function
name|char
specifier|const
modifier|*
name|date2str
parameter_list|(
name|date
parameter_list|,
name|datebuf
parameter_list|)
name|char
specifier|const
name|date
index|[
name|datesize
index|]
decl_stmt|;
name|char
name|datebuf
index|[
name|datesize
operator|+
name|zonelenmax
index|]
decl_stmt|;
block|{
specifier|register
name|char
specifier|const
modifier|*
name|p
init|=
name|date
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'.'
condition|)
continue|continue;
if|if
condition|(
operator|!
name|use_zone_offset
condition|)
name|VOID
name|sprintf
argument_list|(
name|datebuf
argument_list|,
literal|"19%.*s/%.2s/%.2s %.2s:%.2s:%s"
operator|+
operator|(
name|date
index|[
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|VERSION
argument_list|(
literal|5
argument_list|)
operator|<=
name|RCSversion
condition|?
literal|0
else|:
literal|2
operator|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|date
operator|-
literal|1
argument_list|)
argument_list|,
name|date
argument_list|,
name|p
argument_list|,
name|p
operator|+
literal|3
argument_list|,
name|p
operator|+
literal|6
argument_list|,
name|p
operator|+
literal|9
argument_list|,
name|p
operator|+
literal|12
argument_list|)
decl_stmt|;
else|else
block|{
name|struct
name|tm
name|t
decl_stmt|;
name|struct
name|tm
specifier|const
modifier|*
name|z
decl_stmt|;
name|int
name|non_hour
decl_stmt|;
name|long
name|zone
decl_stmt|;
name|char
name|c
decl_stmt|;
name|t
operator|.
name|tm_year
operator|=
name|atoi
argument_list|(
name|date
argument_list|)
operator|-
operator|(
name|date
index|[
literal|2
index|]
operator|==
literal|'.'
condition|?
literal|0
else|:
literal|1900
operator|)
expr_stmt|;
name|t
operator|.
name|tm_mon
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
operator|-
literal|1
expr_stmt|;
name|t
operator|.
name|tm_mday
operator|=
name|atoi
argument_list|(
name|p
operator|+
literal|3
argument_list|)
expr_stmt|;
name|t
operator|.
name|tm_hour
operator|=
name|atoi
argument_list|(
name|p
operator|+
literal|6
argument_list|)
expr_stmt|;
name|t
operator|.
name|tm_min
operator|=
name|atoi
argument_list|(
name|p
operator|+
literal|9
argument_list|)
expr_stmt|;
name|t
operator|.
name|tm_sec
operator|=
name|atoi
argument_list|(
name|p
operator|+
literal|12
argument_list|)
expr_stmt|;
name|t
operator|.
name|tm_wday
operator|=
operator|-
literal|1
expr_stmt|;
name|zone
operator|=
name|zone_offset
expr_stmt|;
if|if
condition|(
name|zone
operator|==
name|TM_LOCAL_ZONE
condition|)
block|{
name|time_t
name|u
init|=
name|tm2time
argument_list|(
operator|&
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|,
name|d
decl_stmt|;
name|z
operator|=
name|localtime
argument_list|(
operator|&
name|u
argument_list|)
expr_stmt|;
name|d
operator|=
name|difftm
argument_list|(
name|z
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|zone
operator|=
operator|(
name|time_t
operator|)
operator|-
literal|1
operator|<
literal|0
operator|||
name|d
operator|<
operator|-
name|d
condition|?
name|d
else|:
operator|-
operator|(
name|long
operator|)
operator|-
name|d
expr_stmt|;
block|}
else|else
block|{
name|adjzone
argument_list|(
operator|&
name|t
argument_list|,
name|zone
argument_list|)
expr_stmt|;
name|z
operator|=
operator|&
name|t
expr_stmt|;
block|}
name|c
operator|=
literal|'+'
expr_stmt|;
if|if
condition|(
name|zone
operator|<
literal|0
condition|)
block|{
name|zone
operator|=
operator|-
name|zone
expr_stmt|;
name|c
operator|=
literal|'-'
expr_stmt|;
block|}
name|VOID
name|sprintf
argument_list|(
name|datebuf
argument_list|,
if|#
directive|if
name|has_printf_dot
literal|"%.2d-%.2d-%.2d %.2d:%.2d:%.2d%c%.2d"
argument_list|,
else|#
directive|else
literal|"%02d-%02d-%02d %02d:%02d:%02d%c%02d"
argument_list|,
endif|#
directive|endif
name|z
operator|->
name|tm_year
operator|+
literal|1900
argument_list|,
name|z
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|z
operator|->
name|tm_mday
argument_list|,
name|z
operator|->
name|tm_hour
argument_list|,
name|z
operator|->
name|tm_min
argument_list|,
name|z
operator|->
name|tm_sec
argument_list|,
name|c
argument_list|,
call|(
name|int
call|)
argument_list|(
name|zone
operator|/
operator|(
literal|60
operator|*
literal|60
operator|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|non_hour
operator|=
name|zone
operator|%
operator|(
literal|60
operator|*
literal|60
operator|)
operator|)
condition|)
block|{
if|#
directive|if
name|has_printf_dot
specifier|static
name|char
specifier|const
name|fmt
index|[]
init|=
literal|":%.2d"
decl_stmt|;
else|#
directive|else
specifier|static
name|char
specifier|const
name|fmt
index|[]
init|=
literal|":%02d"
decl_stmt|;
endif|#
directive|endif
name|VOID
name|sprintf
argument_list|(
name|datebuf
operator|+
name|strlen
argument_list|(
name|datebuf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|non_hour
operator|/
literal|60
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|non_hour
operator|%=
literal|60
operator|)
condition|)
name|VOID
name|sprintf
argument_list|(
name|datebuf
operator|+
name|strlen
argument_list|(
name|datebuf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|non_hour
argument_list|)
decl_stmt|;
block|}
block|}
return|return
name|datebuf
return|;
block|}
end_function

end_unit

