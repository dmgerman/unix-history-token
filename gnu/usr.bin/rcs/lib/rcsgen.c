begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *                     RCS revision generation  */
end_comment

begin_comment
comment|/* Copyright (C) 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991 by Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/* $Log: rcsgen.c,v $  * Revision 5.10  1991/10/07  17:32:46  eggert  * Fix log bugs, e.g. ci -t/dev/null when has_mmap.  *  * Revision 5.9  1991/09/10  22:15:46  eggert  * Fix test for redirected stdin.  *  * Revision 5.8  1991/08/19  03:13:55  eggert  * Add piece tables.  Tune.  *  * Revision 5.7  1991/04/21  11:58:24  eggert  * Add MS-DOS support.  *  * Revision 5.6  1990/12/27  19:54:26  eggert  * Fix bug: rcs -t inserted \n, making RCS file grow.  *  * Revision 5.5  1990/12/04  05:18:45  eggert  * Use -I for prompts and -q for diagnostics.  *  * Revision 5.4  1990/11/01  05:03:47  eggert  * Add -I and new -t behavior.  Permit arbitrary data in logs.  *  * Revision 5.3  1990/09/21  06:12:43  hammer  * made putdesc() treat stdin the same whether or not it was from a terminal  * by making it recognize that a single '.' was then end of the  * description always  *  * Revision 5.2  1990/09/04  08:02:25  eggert  * Fix `co -p1.1 -ko' bug.  Standardize yes-or-no procedure.  *  * Revision 5.1  1990/08/29  07:14:01  eggert  * Clean old log messages too.  *  * Revision 5.0  1990/08/22  08:12:52  eggert  * Remove compile-time limits; use malloc instead.  * Ansify and Posixate.  *  * Revision 4.7  89/05/01  15:12:49  narten  * changed copyright header to reflect current distribution rules  *   * Revision 4.6  88/08/28  14:59:10  eggert  * Shrink stdio code size; allow cc -R; remove lint; isatty() -> ttystdin()  *   * Revision 4.5  87/12/18  11:43:25  narten  * additional lint cleanups, and a bug fix from the 4.3BSD version that  * keeps "ci" from sticking a '\377' into the description if you run it  * with a zero-length file as the description. (Guy Harris)  *   * Revision 4.4  87/10/18  10:35:10  narten  * Updating version numbers. Changes relative to 1.1 actually relative to  * 4.2  *   * Revision 1.3  87/09/24  13:59:51  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf   * warnings)  *   * Revision 1.2  87/03/27  14:22:27  jenkins  * Port to suns  *   * Revision 4.2  83/12/02  23:01:39  wft  * merged 4.1 and 3.3.1.1 (clearerr(stdin)).  *   * Revision 4.1  83/05/10  16:03:33  wft  * Changed putamin() to abort if trying to reread redirected stdin.  * Fixed getdesc() to output a prompt on initial newline.  *   * Revision 3.3.1.1  83/10/19  04:21:51  lepreau  * Added clearerr(stdin) for re-reading description from stdin.  *   * Revision 3.3  82/11/28  21:36:49  wft  * 4.2 prerelease  *   * Revision 3.3  82/11/28  21:36:49  wft  * Replaced ferror() followed by fclose() with ffclose().  * Putdesc() now suppresses the prompts if stdin  * is not a terminal. A pointer to the current log message is now  * inserted into the corresponding delta, rather than leaving it in a  * global variable.  *  * Revision 3.2  82/10/18  21:11:26  wft  * I added checks for write errors during editing, and improved  * the prompt on putdesc().  *  * Revision 3.1  82/10/13  15:55:09  wft  * corrected type of variables assigned to by getc (char --> int)  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_macro
name|libId
argument_list|(
argument|genId
argument_list|,
literal|"$Id: rcsgen.c,v 5.10 1991/10/07 17:32:46 eggert Exp $"
argument_list|)
end_macro

begin_decl_stmt
name|int
name|interactiveflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Should we act as if stdin is a tty?  */
end_comment

begin_decl_stmt
name|struct
name|buf
name|curlogbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for current log message */
end_comment

begin_enum
enum|enum
name|stringwork
block|{
name|enter
block|,
name|copy
block|,
name|edit
block|,
name|expand
block|,
name|edit_expand
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|void
name|scandeltatext
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|,
expr|enum
name|stringwork
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|char
specifier|const
modifier|*
name|buildrevision
parameter_list|(
name|deltas
parameter_list|,
name|target
parameter_list|,
name|outfile
parameter_list|,
name|expandflag
parameter_list|)
name|struct
name|hshentries
specifier|const
modifier|*
name|deltas
decl_stmt|;
name|struct
name|hshentry
modifier|*
name|target
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|int
name|expandflag
decl_stmt|;
comment|/* Function: Generates the revision given by target  * by retrieving all deltas given by parameter deltas and combining them.  * If outfile is set, the revision is output to it,  * otherwise written into a temporary file.  * Temporary files are allocated by maketemp().  * if expandflag is set, keyword expansion is performed.  * Return nil if outfile is set, the name of the temporary file otherwise.  *  * Algorithm: Copy initial revision unchanged.  Then edit all revisions but  * the last one into it, alternating input and output files (resultfile and  * editfile). The last revision is then edited in, performing simultaneous  * keyword substitution (this saves one extra pass).  * All this simplifies if only one revision needs to be generated,  * or no keyword expansion is necessary, or if output goes to stdout.  */
block|{
if|if
condition|(
name|deltas
operator|->
name|first
operator|==
name|target
condition|)
block|{
comment|/* only latest revision to generate */
name|openfcopy
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|scandeltatext
argument_list|(
name|target
argument_list|,
name|expandflag
condition|?
name|expand
else|:
name|copy
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
condition|)
return|return
literal|0
return|;
else|else
block|{
name|Ozclose
argument_list|(
operator|&
name|fcopy
argument_list|)
expr_stmt|;
return|return
operator|(
name|resultfile
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* several revisions to generate */
comment|/* Get initial revision without keyword expansion.  */
name|scandeltatext
argument_list|(
name|deltas
operator|->
name|first
argument_list|,
name|enter
argument_list|,
name|false
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|deltas
operator|=
name|deltas
operator|->
name|rest
operator|)
operator|->
name|rest
condition|)
block|{
comment|/* do all deltas except last one */
name|scandeltatext
argument_list|(
name|deltas
operator|->
name|first
argument_list|,
name|edit
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expandflag
operator|||
name|outfile
condition|)
block|{
comment|/* first, get to beginning of file*/
name|finishedit
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
name|nil
argument_list|,
name|outfile
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|scandeltatext
argument_list|(
name|deltas
operator|->
name|first
argument_list|,
name|expandflag
condition|?
name|edit_expand
else|:
name|edit
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|finishedit
argument_list|(
name|expandflag
condition|?
name|deltas
operator|->
name|first
else|:
operator|(
expr|struct
name|hshentry
operator|*
operator|)
name|nil
argument_list|,
name|outfile
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
condition|)
return|return
literal|0
return|;
name|Ozclose
argument_list|(
operator|&
name|fcopy
argument_list|)
expr_stmt|;
return|return
name|resultfile
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|scandeltatext
parameter_list|(
name|delta
parameter_list|,
name|func
parameter_list|,
name|needlog
parameter_list|)
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
name|enum
name|stringwork
name|func
decl_stmt|;
name|int
name|needlog
decl_stmt|;
comment|/* Function: Scans delta text nodes up to and including the one given  * by delta. For the one given by delta, the log message is saved into  * delta->log if needlog is set; func specifies how to handle the text.  * Assumes the initial lexeme must be read in first.  * Does not advance nexttok after it is finished.  */
block|{
name|struct
name|hshentry
specifier|const
modifier|*
name|nextdelta
decl_stmt|;
name|struct
name|cbuf
name|cb
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|eoflex
argument_list|()
condition|)
name|fatserror
argument_list|(
literal|"can't find delta for revision %s"
argument_list|,
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nextdelta
operator|=
name|getnum
argument_list|()
operator|)
condition|)
block|{
name|fatserror
argument_list|(
literal|"delta number corrupted"
argument_list|)
expr_stmt|;
block|}
name|getkeystring
argument_list|(
name|Klog
argument_list|)
expr_stmt|;
if|if
condition|(
name|needlog
operator|&&
name|delta
operator|==
name|nextdelta
condition|)
block|{
name|cb
operator|=
name|savestring
argument_list|(
operator|&
name|curlogbuf
argument_list|)
expr_stmt|;
name|delta
operator|->
name|log
operator|=
name|cleanlogmsg
argument_list|(
name|curlogbuf
operator|.
name|string
argument_list|,
name|cb
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|readstring
argument_list|()
expr_stmt|;
block|}
name|nextlex
argument_list|()
expr_stmt|;
while|while
condition|(
name|nexttok
operator|==
name|ID
operator|&&
name|strcmp
argument_list|(
name|NextString
argument_list|,
name|Ktext
argument_list|)
operator|!=
literal|0
condition|)
name|ignorephrase
argument_list|()
expr_stmt|;
name|getkeystring
argument_list|(
name|Ktext
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|==
name|nextdelta
condition|)
break|break;
name|readstring
argument_list|()
expr_stmt|;
comment|/* skip over it */
block|}
switch|switch
condition|(
name|func
condition|)
block|{
case|case
name|enter
case|:
name|enterstring
argument_list|()
expr_stmt|;
break|break;
case|case
name|copy
case|:
name|copystring
argument_list|()
expr_stmt|;
break|break;
case|case
name|expand
case|:
name|xpandstring
argument_list|(
name|delta
argument_list|)
expr_stmt|;
break|break;
case|case
name|edit
case|:
name|editstring
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
name|nil
argument_list|)
expr_stmt|;
break|break;
case|case
name|edit_expand
case|:
name|editstring
argument_list|(
name|delta
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|struct
name|cbuf
name|cleanlogmsg
parameter_list|(
name|m
parameter_list|,
name|s
parameter_list|)
name|char
modifier|*
name|m
decl_stmt|;
name|size_t
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|t
init|=
name|m
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|f
init|=
name|t
decl_stmt|;
name|struct
name|cbuf
name|r
decl_stmt|;
while|while
condition|(
name|s
condition|)
block|{
operator|--
name|s
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|t
operator|++
operator|=
operator|*
name|f
operator|++
operator|)
operator|==
literal|'\n'
condition|)
while|while
condition|(
name|m
operator|<
operator|--
name|t
condition|)
if|if
condition|(
name|t
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
operator|&&
name|t
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\t'
condition|)
block|{
operator|*
name|t
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
block|}
block|}
while|while
condition|(
name|m
operator|<
name|t
operator|&&
operator|(
name|t
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|t
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|||
name|t
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
operator|--
name|t
expr_stmt|;
name|r
operator|.
name|string
operator|=
name|m
expr_stmt|;
name|r
operator|.
name|size
operator|=
name|t
operator|-
name|m
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|ttystdin
parameter_list|()
block|{
specifier|static
name|int
name|initialized
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
if|if
condition|(
operator|!
name|interactiveflag
condition|)
name|interactiveflag
operator|=
name|isatty
argument_list|(
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|initialized
operator|=
name|true
expr_stmt|;
block|}
return|return
name|interactiveflag
return|;
block|}
end_function

begin_function
name|int
name|getcstdin
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
name|in
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|in
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|in
argument_list|)
operator|&&
name|ttystdin
argument_list|()
condition|)
name|clearerr
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
name|testIerror
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|in
argument_list|)
operator|&&
name|ttystdin
argument_list|()
condition|)
name|afputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_if
if|#
directive|if
name|has_prototypes
end_if

begin_function
name|int
name|yesorno
parameter_list|(
name|int
name|default_answer
parameter_list|,
name|char
specifier|const
modifier|*
name|question
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/*VARARGS2*/
function|int 	yesorno
parameter_list|(
name|default_answer
parameter_list|,
name|question
parameter_list|,
name|va_alist
parameter_list|)
name|int
name|default_answer
decl_stmt|;
name|char
specifier|const
modifier|*
name|question
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|quietflag
operator|&&
name|ttystdin
argument_list|()
condition|)
block|{
name|oflush
argument_list|()
expr_stmt|;
name|vararg_start
argument_list|(
name|args
argument_list|,
name|question
argument_list|)
expr_stmt|;
name|fvfprintf
argument_list|(
name|stderr
argument_list|,
name|question
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|eflush
argument_list|()
expr_stmt|;
name|r
operator|=
name|c
operator|=
name|getcstdin
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
operator|!
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
name|c
operator|=
name|getcstdin
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|'y'
operator|||
name|r
operator|==
literal|'Y'
condition|)
return|return
name|true
return|;
if|if
condition|(
name|r
operator|==
literal|'n'
operator|||
name|r
operator|==
literal|'N'
condition|)
return|return
name|false
return|;
block|}
return|return
name|default_answer
return|;
block|}
end_function

begin_function
name|void
name|putdesc
parameter_list|(
name|textflag
parameter_list|,
name|textfile
parameter_list|)
name|int
name|textflag
decl_stmt|;
name|char
modifier|*
name|textfile
decl_stmt|;
comment|/* Function: puts the descriptive text into file frewrite.  * if finptr&& !textflag, the text is copied from the old description.  * Otherwise, if the textfile!=nil, the text is read from that  * file, or from stdin, if textfile==nil.  * A textfile with a leading '-' is treated as a string, not a file name.  * If finptr, the old descriptive text is discarded.  * Always clears foutptr.  */
block|{
specifier|static
name|struct
name|buf
name|desc
decl_stmt|;
specifier|static
name|struct
name|cbuf
name|desclean
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|txt
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|frew
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|size_t
name|s
decl_stmt|;
name|char
specifier|const
modifier|*
name|plim
decl_stmt|;
name|frew
operator|=
name|frewrite
expr_stmt|;
if|if
condition|(
name|finptr
operator|&&
operator|!
name|textflag
condition|)
block|{
comment|/* copy old description */
name|aprintf
argument_list|(
name|frew
argument_list|,
literal|"\n\n%s%c"
argument_list|,
name|Kdesc
argument_list|,
name|nextc
argument_list|)
expr_stmt|;
name|foutptr
operator|=
name|frewrite
expr_stmt|;
name|getdesc
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|foutptr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|foutptr
operator|=
literal|0
expr_stmt|;
comment|/* get new description */
if|if
condition|(
name|finptr
condition|)
block|{
comment|/*skip old description*/
name|getdesc
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
name|aprintf
argument_list|(
name|frew
argument_list|,
literal|"\n\n%s\n%c"
argument_list|,
name|Kdesc
argument_list|,
name|SDELIM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|textfile
condition|)
name|desclean
operator|=
name|getsstdin
argument_list|(
literal|"t-"
argument_list|,
literal|"description"
argument_list|,
literal|"NOTE: This is NOT the log message!\n"
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|desclean
operator|.
name|string
condition|)
block|{
if|if
condition|(
operator|*
name|textfile
operator|==
literal|'-'
condition|)
block|{
name|p
operator|=
name|textfile
operator|+
literal|1
expr_stmt|;
name|s
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|txt
operator|=
name|fopen
argument_list|(
name|textfile
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
name|efaterror
argument_list|(
name|textfile
argument_list|)
expr_stmt|;
name|bufalloc
argument_list|(
operator|&
name|desc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|desc
operator|.
name|string
expr_stmt|;
name|plim
operator|=
name|p
operator|+
name|desc
operator|.
name|size
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|txt
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|testIerror
argument_list|(
name|txt
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|txt
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|plim
operator|<=
name|p
condition|)
name|p
operator|=
name|bufenlarge
argument_list|(
operator|&
name|desc
argument_list|,
operator|&
name|plim
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|txt
argument_list|)
operator|!=
literal|0
condition|)
name|Ierror
argument_list|()
expr_stmt|;
name|s
operator|=
name|p
operator|-
name|desc
operator|.
name|string
expr_stmt|;
name|p
operator|=
name|desc
operator|.
name|string
expr_stmt|;
block|}
name|desclean
operator|=
name|cleanlogmsg
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|putstring
argument_list|(
name|frew
argument_list|,
name|false
argument_list|,
name|desclean
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|aputc
argument_list|(
literal|'\n'
argument_list|,
name|frew
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|cbuf
name|getsstdin
parameter_list|(
name|option
parameter_list|,
name|name
parameter_list|,
name|note
parameter_list|,
name|buf
parameter_list|)
name|char
specifier|const
modifier|*
name|option
decl_stmt|,
decl|*
name|name
decl_stmt|,
modifier|*
name|note
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|buf
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|size_t
name|i
decl_stmt|;
specifier|register
name|int
name|tty
init|=
name|ttystdin
argument_list|()
decl_stmt|;
if|if
condition|(
name|tty
condition|)
name|aprintf
argument_list|(
name|stderr
argument_list|,
literal|"enter %s, terminated with single '.' or end of file:\n%s>> "
argument_list|,
name|name
argument_list|,
name|note
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
name|faterror
argument_list|(
literal|"can't reread redirected stdin for %s; use -%s<%s>"
argument_list|,
name|name
argument_list|,
name|option
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
literal|0
init|;
name|c
operator|=
name|getcstdin
argument_list|()
operator|,
operator|!
name|feof
argument_list|(
name|stdin
argument_list|)
condition|;
name|bufrealloc
argument_list|(
name|buf
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|,
name|p
operator|=
name|buf
operator|->
name|string
operator|,
name|p
index|[
name|i
operator|++
index|]
operator|=
name|c
control|)
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
if|if
condition|(
name|i
operator|&&
name|p
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|i
operator|==
literal|1
operator|||
name|p
index|[
name|i
operator|-
literal|2
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
comment|/* Remove trailing '.'.  */
operator|--
name|i
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|tty
condition|)
name|aputs
argument_list|(
literal|">> "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return
name|cleanlogmsg
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
return|;
block|}
end_block

end_unit

