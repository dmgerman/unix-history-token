begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generate RCS revisions.  */
end_comment

begin_comment
comment|/* Copyright 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991, 1992, 1993, 1994, 1995 Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/*  * Revision 5.16  1995/06/16 06:19:24  eggert  * Update FSF address.  *  * Revision 5.15  1995/06/01 16:23:43  eggert  * (putadmin): Open RCS file with FOPEN_WB.  *  * Revision 5.14  1994/03/17 14:05:48  eggert  * Work around SVR4 stdio performance bug.  * Flush stderr after prompt.  Remove lint.  *  * Revision 5.13  1993/11/03 17:42:27  eggert  * Don't discard ignored phrases.  Improve quality of diagnostics.  *  * Revision 5.12  1992/07/28  16:12:44  eggert  * Statement macro names now end in _.  * Be consistent about pathnames vs filenames.  *  * Revision 5.11  1992/01/24  18:44:19  eggert  * Move put routines here from rcssyn.c.  * Add support for bad_creat0.  *  * Revision 5.10  1991/10/07  17:32:46  eggert  * Fix log bugs, e.g. ci -t/dev/null when has_mmap.  *  * Revision 5.9  1991/09/10  22:15:46  eggert  * Fix test for redirected stdin.  *  * Revision 5.8  1991/08/19  03:13:55  eggert  * Add piece tables.  Tune.  *  * Revision 5.7  1991/04/21  11:58:24  eggert  * Add MS-DOS support.  *  * Revision 5.6  1990/12/27  19:54:26  eggert  * Fix bug: rcs -t inserted \n, making RCS file grow.  *  * Revision 5.5  1990/12/04  05:18:45  eggert  * Use -I for prompts and -q for diagnostics.  *  * Revision 5.4  1990/11/01  05:03:47  eggert  * Add -I and new -t behavior.  Permit arbitrary data in logs.  *  * Revision 5.3  1990/09/21  06:12:43  hammer  * made putdesc() treat stdin the same whether or not it was from a terminal  * by making it recognize that a single '.' was then end of the  * description always  *  * Revision 5.2  1990/09/04  08:02:25  eggert  * Fix `co -p1.1 -ko' bug.  Standardize yes-or-no procedure.  *  * Revision 5.1  1990/08/29  07:14:01  eggert  * Clean old log messages too.  *  * Revision 5.0  1990/08/22  08:12:52  eggert  * Remove compile-time limits; use malloc instead.  * Ansify and Posixate.  *  * Revision 4.7  89/05/01  15:12:49  narten  * changed copyright header to reflect current distribution rules  *  * Revision 4.6  88/08/28  14:59:10  eggert  * Shrink stdio code size; allow cc -R; remove lint; isatty() -> ttystdin()  *  * Revision 4.5  87/12/18  11:43:25  narten  * additional lint cleanups, and a bug fix from the 4.3BSD version that  * keeps "ci" from sticking a '\377' into the description if you run it  * with a zero-length file as the description. (Guy Harris)  *  * Revision 4.4  87/10/18  10:35:10  narten  * Updating version numbers. Changes relative to 1.1 actually relative to  * 4.2  *  * Revision 1.3  87/09/24  13:59:51  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf  * warnings)  *  * Revision 1.2  87/03/27  14:22:27  jenkins  * Port to suns  *  * Revision 4.2  83/12/02  23:01:39  wft  * merged 4.1 and 3.3.1.1 (clearerr(stdin)).  *  * Revision 4.1  83/05/10  16:03:33  wft  * Changed putamin() to abort if trying to reread redirected stdin.  * Fixed getdesc() to output a prompt on initial newline.  *  * Revision 3.3.1.1  83/10/19  04:21:51  lepreau  * Added clearerr(stdin) for re-reading description from stdin.  *  * Revision 3.3  82/11/28  21:36:49  wft  * 4.2 prerelease  *  * Revision 3.3  82/11/28  21:36:49  wft  * Replaced ferror() followed by fclose() with ffclose().  * Putdesc() now suppresses the prompts if stdin  * is not a terminal. A pointer to the current log message is now  * inserted into the corresponding delta, rather than leaving it in a  * global variable.  *  * Revision 3.2  82/10/18  21:11:26  wft  * I added checks for write errors during editing, and improved  * the prompt on putdesc().  *  * Revision 3.1  82/10/13  15:55:09  wft  * corrected type of variables assigned to by getc (char --> int)  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_macro
name|libId
argument_list|(
argument|genId
argument_list|,
literal|"$Id$"
argument_list|)
end_macro

begin_decl_stmt
name|int
name|interactiveflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Should we act as if stdin is a tty?  */
end_comment

begin_decl_stmt
name|struct
name|buf
name|curlogbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for current log message */
end_comment

begin_enum
enum|enum
name|stringwork
block|{
name|enter
block|,
name|copy
block|,
name|edit
block|,
name|expand
block|,
name|edit_expand
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|void
name|putdelta
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
specifier|const
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scandeltatext
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|,
expr|enum
name|stringwork
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|char
specifier|const
modifier|*
name|buildrevision
parameter_list|(
name|deltas
parameter_list|,
name|target
parameter_list|,
name|outfile
parameter_list|,
name|expandflag
parameter_list|)
name|struct
name|hshentries
specifier|const
modifier|*
name|deltas
decl_stmt|;
name|struct
name|hshentry
modifier|*
name|target
decl_stmt|;
name|FILE
modifier|*
name|outfile
decl_stmt|;
name|int
name|expandflag
decl_stmt|;
comment|/* Function: Generates the revision given by target  * by retrieving all deltas given by parameter deltas and combining them.  * If outfile is set, the revision is output to it,  * otherwise written into a temporary file.  * Temporary files are allocated by maketemp().  * if expandflag is set, keyword expansion is performed.  * Return 0 if outfile is set, the name of the temporary file otherwise.  *  * Algorithm: Copy initial revision unchanged.  Then edit all revisions but  * the last one into it, alternating input and output files (resultname and  * editname). The last revision is then edited in, performing simultaneous  * keyword substitution (this saves one extra pass).  * All this simplifies if only one revision needs to be generated,  * or no keyword expansion is necessary, or if output goes to stdout.  */
block|{
if|if
condition|(
name|deltas
operator|->
name|first
operator|==
name|target
condition|)
block|{
comment|/* only latest revision to generate */
name|openfcopy
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|scandeltatext
argument_list|(
name|target
argument_list|,
name|expandflag
condition|?
name|expand
else|:
name|copy
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
condition|)
return|return
literal|0
return|;
else|else
block|{
name|Ozclose
argument_list|(
operator|&
name|fcopy
argument_list|)
expr_stmt|;
return|return
name|resultname
return|;
block|}
block|}
else|else
block|{
comment|/* several revisions to generate */
comment|/* Get initial revision without keyword expansion.  */
name|scandeltatext
argument_list|(
name|deltas
operator|->
name|first
argument_list|,
name|enter
argument_list|,
name|false
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|deltas
operator|=
name|deltas
operator|->
name|rest
operator|)
operator|->
name|rest
condition|)
block|{
comment|/* do all deltas except last one */
name|scandeltatext
argument_list|(
name|deltas
operator|->
name|first
argument_list|,
name|edit
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|expandflag
operator|||
name|outfile
condition|)
block|{
comment|/* first, get to beginning of file*/
name|finishedit
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
literal|0
argument_list|,
name|outfile
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|scandeltatext
argument_list|(
name|target
argument_list|,
name|expandflag
condition|?
name|edit_expand
else|:
name|edit
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|finishedit
argument_list|(
name|expandflag
condition|?
name|target
else|:
operator|(
expr|struct
name|hshentry
operator|*
operator|)
literal|0
argument_list|,
name|outfile
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
condition|)
return|return
literal|0
return|;
name|Ozclose
argument_list|(
operator|&
name|fcopy
argument_list|)
expr_stmt|;
return|return
name|resultname
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|scandeltatext
parameter_list|(
name|delta
parameter_list|,
name|func
parameter_list|,
name|needlog
parameter_list|)
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
name|enum
name|stringwork
name|func
decl_stmt|;
name|int
name|needlog
decl_stmt|;
comment|/* Function: Scans delta text nodes up to and including the one given  * by delta. For the one given by delta, the log message is saved into  * delta->log if needlog is set; func specifies how to handle the text.  * Similarly, if needlog, delta->igtext is set to the ignored phrases.  * Assumes the initial lexeme must be read in first.  * Does not advance nexttok after it is finished.  */
block|{
name|struct
name|hshentry
specifier|const
modifier|*
name|nextdelta
decl_stmt|;
name|struct
name|cbuf
name|cb
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|eoflex
argument_list|()
condition|)
name|fatserror
argument_list|(
literal|"can't find delta for revision %s"
argument_list|,
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nextdelta
operator|=
name|getnum
argument_list|()
operator|)
condition|)
block|{
name|fatserror
argument_list|(
literal|"delta number corrupted"
argument_list|)
expr_stmt|;
block|}
name|getkeystring
argument_list|(
name|Klog
argument_list|)
expr_stmt|;
if|if
condition|(
name|needlog
operator|&&
name|delta
operator|==
name|nextdelta
condition|)
block|{
name|cb
operator|=
name|savestring
argument_list|(
operator|&
name|curlogbuf
argument_list|)
expr_stmt|;
name|delta
operator|->
name|log
operator|=
name|cleanlogmsg
argument_list|(
name|curlogbuf
operator|.
name|string
argument_list|,
name|cb
operator|.
name|size
argument_list|)
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
name|delta
operator|->
name|igtext
operator|=
name|getphrases
argument_list|(
name|Ktext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|readstring
argument_list|()
expr_stmt|;
name|ignorephrases
argument_list|(
name|Ktext
argument_list|)
expr_stmt|;
block|}
name|getkeystring
argument_list|(
name|Ktext
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|==
name|nextdelta
condition|)
break|break;
name|readstring
argument_list|()
expr_stmt|;
comment|/* skip over it */
block|}
switch|switch
condition|(
name|func
condition|)
block|{
case|case
name|enter
case|:
name|enterstring
argument_list|()
expr_stmt|;
break|break;
case|case
name|copy
case|:
name|copystring
argument_list|()
expr_stmt|;
break|break;
case|case
name|expand
case|:
name|xpandstring
argument_list|(
name|delta
argument_list|)
expr_stmt|;
break|break;
case|case
name|edit
case|:
name|editstring
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|edit_expand
case|:
name|editstring
argument_list|(
name|delta
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|struct
name|cbuf
name|cleanlogmsg
parameter_list|(
name|m
parameter_list|,
name|s
parameter_list|)
name|char
modifier|*
name|m
decl_stmt|;
name|size_t
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|t
init|=
name|m
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|f
init|=
name|t
decl_stmt|;
name|struct
name|cbuf
name|r
decl_stmt|;
while|while
condition|(
name|s
condition|)
block|{
operator|--
name|s
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|t
operator|++
operator|=
operator|*
name|f
operator|++
operator|)
operator|==
literal|'\n'
condition|)
while|while
condition|(
name|m
operator|<
operator|--
name|t
condition|)
if|if
condition|(
name|t
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
operator|&&
name|t
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\t'
condition|)
block|{
operator|*
name|t
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
block|}
block|}
while|while
condition|(
name|m
operator|<
name|t
operator|&&
operator|(
name|t
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|t
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|||
name|t
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
operator|--
name|t
expr_stmt|;
name|r
operator|.
name|string
operator|=
name|m
expr_stmt|;
name|r
operator|.
name|size
operator|=
name|t
operator|-
name|m
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int
name|ttystdin
parameter_list|()
block|{
specifier|static
name|int
name|initialized
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
if|if
condition|(
operator|!
name|interactiveflag
condition|)
name|interactiveflag
operator|=
name|isatty
argument_list|(
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|initialized
operator|=
name|true
expr_stmt|;
block|}
return|return
name|interactiveflag
return|;
block|}
end_function

begin_function
name|int
name|getcstdin
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
name|in
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|in
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|in
argument_list|)
operator|&&
name|ttystdin
argument_list|()
condition|)
name|clearerr
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|testIerror
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|in
argument_list|)
operator|&&
name|ttystdin
argument_list|()
condition|)
name|afputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_if
if|#
directive|if
name|has_prototypes
end_if

begin_function
name|int
name|yesorno
parameter_list|(
name|int
name|default_answer
parameter_list|,
name|char
specifier|const
modifier|*
name|question
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/*VARARGS2*/
function|int 	yesorno
parameter_list|(
name|default_answer
parameter_list|,
name|question
parameter_list|,
name|va_alist
parameter_list|)
name|int
name|default_answer
decl_stmt|;
name|char
specifier|const
modifier|*
name|question
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
operator|!
name|quietflag
operator|&&
name|ttystdin
argument_list|()
condition|)
block|{
name|oflush
argument_list|()
expr_stmt|;
name|vararg_start
argument_list|(
name|args
argument_list|,
name|question
argument_list|)
expr_stmt|;
name|fvfprintf
argument_list|(
name|stderr
argument_list|,
name|question
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|eflush
argument_list|()
expr_stmt|;
name|r
operator|=
name|c
operator|=
name|getcstdin
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
operator|!
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
name|c
operator|=
name|getcstdin
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|'y'
operator|||
name|r
operator|==
literal|'Y'
condition|)
return|return
name|true
return|;
if|if
condition|(
name|r
operator|==
literal|'n'
operator|||
name|r
operator|==
literal|'N'
condition|)
return|return
name|false
return|;
block|}
return|return
name|default_answer
return|;
block|}
end_function

begin_function
name|void
name|putdesc
parameter_list|(
name|textflag
parameter_list|,
name|textfile
parameter_list|)
name|int
name|textflag
decl_stmt|;
name|char
modifier|*
name|textfile
decl_stmt|;
comment|/* Function: puts the descriptive text into file frewrite.  * if finptr&& !textflag, the text is copied from the old description.  * Otherwise, if textfile, the text is read from that  * file, or from stdin, if !textfile.  * A textfile with a leading '-' is treated as a string, not a pathname.  * If finptr, the old descriptive text is discarded.  * Always clears foutptr.  */
block|{
specifier|static
name|struct
name|buf
name|desc
decl_stmt|;
specifier|static
name|struct
name|cbuf
name|desclean
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|txt
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|frew
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|size_t
name|s
decl_stmt|;
name|char
specifier|const
modifier|*
name|plim
decl_stmt|;
name|frew
operator|=
name|frewrite
expr_stmt|;
if|if
condition|(
name|finptr
operator|&&
operator|!
name|textflag
condition|)
block|{
comment|/* copy old description */
name|aprintf
argument_list|(
name|frew
argument_list|,
literal|"\n\n%s%c"
argument_list|,
name|Kdesc
argument_list|,
name|nextc
argument_list|)
expr_stmt|;
name|foutptr
operator|=
name|frewrite
expr_stmt|;
name|getdesc
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|foutptr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|foutptr
operator|=
literal|0
expr_stmt|;
comment|/* get new description */
if|if
condition|(
name|finptr
condition|)
block|{
comment|/*skip old description*/
name|getdesc
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
name|aprintf
argument_list|(
name|frew
argument_list|,
literal|"\n\n%s\n%c"
argument_list|,
name|Kdesc
argument_list|,
name|SDELIM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|textfile
condition|)
name|desclean
operator|=
name|getsstdin
argument_list|(
literal|"t-"
argument_list|,
literal|"description"
argument_list|,
literal|"NOTE: This is NOT the log message!\n"
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|desclean
operator|.
name|string
condition|)
block|{
if|if
condition|(
operator|*
name|textfile
operator|==
literal|'-'
condition|)
block|{
name|p
operator|=
name|textfile
operator|+
literal|1
expr_stmt|;
name|s
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|txt
operator|=
name|fopenSafer
argument_list|(
name|textfile
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
name|efaterror
argument_list|(
name|textfile
argument_list|)
expr_stmt|;
name|bufalloc
argument_list|(
operator|&
name|desc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|desc
operator|.
name|string
expr_stmt|;
name|plim
operator|=
name|p
operator|+
name|desc
operator|.
name|size
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|txt
argument_list|)
operator|)
operator|==
name|EOF
condition|)
block|{
name|testIerror
argument_list|(
name|txt
argument_list|)
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|txt
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|plim
operator|<=
name|p
condition|)
name|p
operator|=
name|bufenlarge
argument_list|(
operator|&
name|desc
argument_list|,
operator|&
name|plim
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|txt
argument_list|)
operator|!=
literal|0
condition|)
name|Ierror
argument_list|()
expr_stmt|;
name|s
operator|=
name|p
operator|-
name|desc
operator|.
name|string
expr_stmt|;
name|p
operator|=
name|desc
operator|.
name|string
expr_stmt|;
block|}
name|desclean
operator|=
name|cleanlogmsg
argument_list|(
name|p
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|putstring
argument_list|(
name|frew
argument_list|,
name|false
argument_list|,
name|desclean
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|aputc_
argument_list|(
literal|'\n'
argument_list|,
argument|frew
argument_list|)
block|}
block|}
end_function

begin_function
name|struct
name|cbuf
name|getsstdin
parameter_list|(
name|option
parameter_list|,
name|name
parameter_list|,
name|note
parameter_list|,
name|buf
parameter_list|)
name|char
specifier|const
modifier|*
name|option
decl_stmt|,
decl|*
name|name
decl_stmt|,
modifier|*
name|note
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|buf
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|size_t
name|i
decl_stmt|;
specifier|register
name|int
name|tty
init|=
name|ttystdin
argument_list|()
decl_stmt|;
if|if
condition|(
name|tty
condition|)
block|{
name|aprintf
argument_list|(
name|stderr
argument_list|,
literal|"enter %s, terminated with single '.' or end of file:\n%s>> "
argument_list|,
name|name
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|eflush
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
name|rcsfaterror
argument_list|(
literal|"can't reread redirected stdin for %s; use -%s<%s>"
argument_list|,
name|name
argument_list|,
name|option
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
literal|0
init|;
name|c
operator|=
name|getcstdin
argument_list|()
operator|,
operator|!
name|feof
argument_list|(
name|stdin
argument_list|)
condition|;
name|bufrealloc
argument_list|(
name|buf
argument_list|,
name|i
operator|+
literal|1
argument_list|)
operator|,
name|p
operator|=
name|buf
operator|->
name|string
operator|,
name|p
index|[
name|i
operator|++
index|]
operator|=
name|c
control|)
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
if|if
condition|(
name|i
operator|&&
name|p
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|i
operator|==
literal|1
operator|||
name|p
index|[
name|i
operator|-
literal|2
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
comment|/* Remove trailing '.'.  */
operator|--
name|i
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|tty
condition|)
block|{
name|aputs
argument_list|(
literal|">> "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|eflush
argument_list|()
expr_stmt|;
block|}
return|return
name|cleanlogmsg
argument_list|(
name|p
argument_list|,
name|i
argument_list|)
return|;
block|}
end_block

begin_function
name|void
name|putadmin
parameter_list|()
comment|/* Output the admin node.  */
block|{
specifier|register
name|FILE
modifier|*
name|fout
decl_stmt|;
name|struct
name|assoc
specifier|const
modifier|*
name|curassoc
decl_stmt|;
name|struct
name|rcslock
specifier|const
modifier|*
name|curlock
decl_stmt|;
name|struct
name|access
specifier|const
modifier|*
name|curaccess
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fout
operator|=
name|frewrite
operator|)
condition|)
block|{
if|#
directive|if
name|bad_creat0
name|ORCSclose
argument_list|()
expr_stmt|;
name|fout
operator|=
name|fopenSafer
argument_list|(
name|makedirtemp
argument_list|(
literal|0
argument_list|)
argument_list|,
name|FOPEN_WB
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|fo
init|=
name|fdlock
decl_stmt|;
name|fdlock
operator|=
operator|-
literal|1
expr_stmt|;
name|fout
operator|=
name|fdopen
argument_list|(
name|fo
argument_list|,
name|FOPEN_WB
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|frewrite
operator|=
name|fout
operator|)
condition|)
name|efaterror
argument_list|(
name|RCSname
argument_list|)
expr_stmt|;
block|}
comment|/* 	* Output the first character with putc, not printf. 	* Otherwise, an SVR4 stdio bug buffers output inefficiently. 	*/
name|aputc_
argument_list|(
argument|*Khead
argument_list|,
argument|fout
argument_list|)
name|aprintf
argument_list|(
name|fout
argument_list|,
literal|"%s\t%s;\n"
argument_list|,
name|Khead
operator|+
literal|1
argument_list|,
name|Head
condition|?
name|Head
operator|->
name|num
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|Dbranch
operator|&&
name|VERSION
argument_list|(
literal|4
argument_list|)
operator|<=
name|RCSversion
condition|)
name|aprintf
argument_list|(
name|fout
argument_list|,
literal|"%s\t%s;\n"
argument_list|,
name|Kbranch
argument_list|,
name|Dbranch
argument_list|)
expr_stmt|;
name|aputs
argument_list|(
name|Kaccess
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|curaccess
operator|=
name|AccessList
expr_stmt|;
while|while
condition|(
name|curaccess
condition|)
block|{
name|aprintf
argument_list|(
name|fout
argument_list|,
literal|"\n\t%s"
argument_list|,
name|curaccess
operator|->
name|login
argument_list|)
expr_stmt|;
name|curaccess
operator|=
name|curaccess
operator|->
name|nextaccess
expr_stmt|;
block|}
name|aprintf
argument_list|(
name|fout
argument_list|,
literal|";\n%s"
argument_list|,
name|Ksymbols
argument_list|)
expr_stmt|;
name|curassoc
operator|=
name|Symbols
expr_stmt|;
while|while
condition|(
name|curassoc
condition|)
block|{
name|aprintf
argument_list|(
name|fout
argument_list|,
literal|"\n\t%s:%s"
argument_list|,
name|curassoc
operator|->
name|symbol
argument_list|,
name|curassoc
operator|->
name|num
argument_list|)
expr_stmt|;
name|curassoc
operator|=
name|curassoc
operator|->
name|nextassoc
expr_stmt|;
block|}
name|aprintf
argument_list|(
name|fout
argument_list|,
literal|";\n%s"
argument_list|,
name|Klocks
argument_list|)
expr_stmt|;
name|curlock
operator|=
name|Locks
expr_stmt|;
while|while
condition|(
name|curlock
condition|)
block|{
name|aprintf
argument_list|(
name|fout
argument_list|,
literal|"\n\t%s:%s"
argument_list|,
name|curlock
operator|->
name|login
argument_list|,
name|curlock
operator|->
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
name|curlock
operator|=
name|curlock
operator|->
name|nextlock
expr_stmt|;
block|}
if|if
condition|(
name|StrictLocks
condition|)
name|aprintf
argument_list|(
name|fout
argument_list|,
literal|"; %s"
argument_list|,
name|Kstrict
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
name|fout
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Comment
operator|.
name|size
condition|)
block|{
name|aprintf
argument_list|(
name|fout
argument_list|,
literal|"%s\t"
argument_list|,
name|Kcomment
argument_list|)
expr_stmt|;
name|putstring
argument_list|(
name|fout
argument_list|,
name|true
argument_list|,
name|Comment
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
name|fout
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Expand
operator|!=
name|KEYVAL_EXPAND
condition|)
name|aprintf
argument_list|(
name|fout
argument_list|,
literal|"%s\t%c%s%c;\n"
argument_list|,
name|Kexpand
argument_list|,
name|SDELIM
argument_list|,
name|expand_names
index|[
name|Expand
index|]
argument_list|,
name|SDELIM
argument_list|)
expr_stmt|;
name|awrite
argument_list|(
name|Ignored
operator|.
name|string
argument_list|,
name|Ignored
operator|.
name|size
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|aputc_
argument_list|(
literal|'\n'
argument_list|,
argument|fout
argument_list|)
block|}
end_function

begin_function
specifier|static
name|void
name|putdelta
parameter_list|(
name|node
parameter_list|,
name|fout
parameter_list|)
specifier|register
name|struct
name|hshentry
specifier|const
modifier|*
name|node
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fout
decl_stmt|;
comment|/* Output the delta NODE to FOUT.  */
block|{
name|struct
name|branchhead
specifier|const
modifier|*
name|nextbranch
decl_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
return|return;
name|aprintf
argument_list|(
name|fout
argument_list|,
literal|"\n%s\n%s\t%s;\t%s %s;\t%s %s;\nbranches"
argument_list|,
name|node
operator|->
name|num
argument_list|,
name|Kdate
argument_list|,
name|node
operator|->
name|date
argument_list|,
name|Kauthor
argument_list|,
name|node
operator|->
name|author
argument_list|,
name|Kstate
argument_list|,
name|node
operator|->
name|state
condition|?
name|node
operator|->
name|state
else|:
literal|""
argument_list|)
expr_stmt|;
name|nextbranch
operator|=
name|node
operator|->
name|branches
expr_stmt|;
while|while
condition|(
name|nextbranch
condition|)
block|{
name|aprintf
argument_list|(
name|fout
argument_list|,
literal|"\n\t%s"
argument_list|,
name|nextbranch
operator|->
name|hsh
operator|->
name|num
argument_list|)
expr_stmt|;
name|nextbranch
operator|=
name|nextbranch
operator|->
name|nextbranch
expr_stmt|;
block|}
name|aprintf
argument_list|(
name|fout
argument_list|,
literal|";\n%s\t%s;\n"
argument_list|,
name|Knext
argument_list|,
name|node
operator|->
name|next
condition|?
name|node
operator|->
name|next
operator|->
name|num
else|:
literal|""
argument_list|)
expr_stmt|;
name|awrite
argument_list|(
name|node
operator|->
name|ig
operator|.
name|string
argument_list|,
name|node
operator|->
name|ig
operator|.
name|size
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|puttree
parameter_list|(
name|root
parameter_list|,
name|fout
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|root
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fout
decl_stmt|;
comment|/* Output the delta tree with base ROOT in preorder to FOUT.  */
block|{
name|struct
name|branchhead
specifier|const
modifier|*
name|nextbranch
decl_stmt|;
if|if
condition|(
operator|!
name|root
condition|)
return|return;
if|if
condition|(
name|root
operator|->
name|selector
condition|)
name|putdelta
argument_list|(
name|root
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|puttree
argument_list|(
name|root
operator|->
name|next
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|nextbranch
operator|=
name|root
operator|->
name|branches
expr_stmt|;
while|while
condition|(
name|nextbranch
condition|)
block|{
name|puttree
argument_list|(
name|nextbranch
operator|->
name|hsh
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|nextbranch
operator|=
name|nextbranch
operator|->
name|nextbranch
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|putdtext
parameter_list|(
name|delta
parameter_list|,
name|srcname
parameter_list|,
name|fout
parameter_list|,
name|diffmt
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
name|char
specifier|const
modifier|*
name|srcname
decl_stmt|;
name|FILE
modifier|*
name|fout
decl_stmt|;
name|int
name|diffmt
decl_stmt|;
comment|/*  * Output a deltatext node with delta number DELTA->num, log message DELTA->log,  * ignored phrases DELTA->igtext and text SRCNAME to FOUT.  * Double up all SDELIMs in both the log and the text.  * Make sure the log message ends in \n.  * Return false on error.  * If DIFFMT, also check that the text is valid diff -n output.  */
block|{
name|RILE
modifier|*
name|fin
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|fin
operator|=
name|Iopen
argument_list|(
name|srcname
argument_list|,
literal|"r"
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
literal|0
argument_list|)
operator|)
condition|)
block|{
name|eerror
argument_list|(
name|srcname
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|putdftext
argument_list|(
name|delta
argument_list|,
name|fin
argument_list|,
name|fout
argument_list|,
name|diffmt
argument_list|)
expr_stmt|;
name|Ifclose
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
name|void
name|putstring
parameter_list|(
name|out
parameter_list|,
name|delim
parameter_list|,
name|s
parameter_list|,
name|log
parameter_list|)
specifier|register
name|FILE
modifier|*
name|out
decl_stmt|;
name|struct
name|cbuf
name|s
decl_stmt|;
name|int
name|delim
decl_stmt|,
name|log
decl_stmt|;
comment|/*  * Output to OUT one SDELIM if DELIM, then the string S with SDELIMs doubled.  * If LOG is set then S is a log string; append a newline if S is nonempty.  */
block|{
specifier|register
name|char
specifier|const
modifier|*
name|sp
decl_stmt|;
specifier|register
name|size_t
name|ss
decl_stmt|;
if|if
condition|(
name|delim
condition|)
name|aputc_
argument_list|(
argument|SDELIM
argument_list|,
argument|out
argument_list|)
name|sp
operator|=
name|s
operator|.
name|string
expr_stmt|;
for|for
control|(
name|ss
operator|=
name|s
operator|.
name|size
init|;
name|ss
condition|;
operator|--
name|ss
control|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
name|SDELIM
condition|)
name|aputc_
argument_list|(
argument|SDELIM
argument_list|,
argument|out
argument_list|)
name|aputc_
argument_list|(
argument|*sp++
argument_list|,
argument|out
argument_list|)
block|}
if|if
condition|(
name|s
operator|.
name|size
operator|&&
name|log
condition|)
name|aputc_
argument_list|(
literal|'\n'
argument_list|,
argument|out
argument_list|)
name|aputc_
argument_list|(
argument|SDELIM
argument_list|,
argument|out
argument_list|)
block|}
end_function

begin_function
name|void
name|putdftext
parameter_list|(
name|delta
parameter_list|,
name|finfile
parameter_list|,
name|foutfile
parameter_list|,
name|diffmt
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
name|RILE
modifier|*
name|finfile
decl_stmt|;
name|FILE
modifier|*
name|foutfile
decl_stmt|;
name|int
name|diffmt
decl_stmt|;
comment|/* like putdtext(), except the source file is already open */
block|{
name|declarecache
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|fout
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fin
decl_stmt|;
name|int
name|ed
decl_stmt|;
name|struct
name|diffcmd
name|dc
decl_stmt|;
name|fout
operator|=
name|foutfile
expr_stmt|;
name|aprintf
argument_list|(
name|fout
argument_list|,
name|DELNUMFORM
argument_list|,
name|delta
operator|->
name|num
argument_list|,
name|Klog
argument_list|)
expr_stmt|;
comment|/* put log */
name|putstring
argument_list|(
name|fout
argument_list|,
name|true
argument_list|,
name|delta
operator|->
name|log
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|aputc_
argument_list|(
literal|'\n'
argument_list|,
argument|fout
argument_list|)
comment|/* put ignored phrases */
name|awrite
argument_list|(
name|delta
operator|->
name|igtext
operator|.
name|string
argument_list|,
name|delta
operator|->
name|igtext
operator|.
name|size
argument_list|,
name|fout
argument_list|)
expr_stmt|;
comment|/* put text */
name|aprintf
argument_list|(
name|fout
argument_list|,
literal|"%s\n%c"
argument_list|,
name|Ktext
argument_list|,
name|SDELIM
argument_list|)
expr_stmt|;
name|fin
operator|=
name|finfile
expr_stmt|;
name|setupcache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|diffmt
condition|)
block|{
comment|/* Copy the file */
name|cache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cachegeteof_
argument_list|(
argument|c
argument_list|,
argument|break;
argument_list|)
if|if
condition|(
name|c
operator|==
name|SDELIM
condition|)
name|aputc_
argument_list|(
argument|SDELIM
argument_list|,
argument|fout
argument_list|)
comment|/*double up SDELIM*/
name|aputc_
argument_list|(
argument|c
argument_list|,
argument|fout
argument_list|)
block|}
block|}
else|else
block|{
name|initdiffcmd
argument_list|(
operator|&
name|dc
argument_list|)
expr_stmt|;
while|while
condition|(
literal|0
operator|<=
operator|(
name|ed
operator|=
name|getdiffcmd
argument_list|(
name|fin
argument_list|,
name|false
argument_list|,
name|fout
argument_list|,
operator|&
name|dc
argument_list|)
operator|)
condition|)
if|if
condition|(
name|ed
condition|)
block|{
name|cache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
while|while
condition|(
name|dc
operator|.
name|nlines
operator|--
condition|)
do|do
block|{
name|cachegeteof_
argument_list|(
argument|c
argument_list|,
argument|{ if (!dc.nlines) goto OK_EOF; unexpected_EOF(); }
argument_list|)
if|if
condition|(
name|c
operator|==
name|SDELIM
condition|)
name|aputc_
argument_list|(
argument|SDELIM
argument_list|,
argument|fout
argument_list|)
name|aputc_
argument_list|(
argument|c
argument_list|,
argument|fout
argument_list|)
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
name|uncache
argument_list|(
name|fin
argument_list|)
expr_stmt|;
block|}
block|}
name|OK_EOF
label|:
name|aprintf
argument_list|(
name|fout
argument_list|,
literal|"%c\n"
argument_list|,
name|SDELIM
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

