begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Compare working files, ignoring RCS keyword strings.  */
end_comment

begin_comment
comment|/*****************************************************************************  *                       rcsfcmp()  *                       Testprogram: define FCMPTEST  *****************************************************************************  */
end_comment

begin_comment
comment|/* Copyright 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991, 1992, 1993, 1994, 1995 Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/*  * $Log: rcsfcmp.c,v $  * Revision 5.14  1995/06/16 06:19:24  eggert  * Update FSF address.  *  * Revision 5.13  1995/06/01 16:23:43  eggert  * (rcsfcmp): Add -kb support.  *  * Revision 5.12  1994/03/17 14:05:48  eggert  * Normally calculate the $Log prefix from context, not from RCS file.  * Calculate line numbers correctly even if the $Log prefix contains newlines.  * Remove lint.  *  * Revision 5.11  1993/11/03 17:42:27  eggert  * Fix yet another off-by-one error when comparing Log string expansions.  *  * Revision 5.10  1992/07/28 16:12:44  eggert  * Statement macro names now end in _.  *  * Revision 5.9  1991/10/07  17:32:46  eggert  * Count log lines correctly.  *  * Revision 5.8  1991/08/19  03:13:55  eggert  * Tune.  *  * Revision 5.7  1991/04/21  11:58:22  eggert  * Fix errno bug.  Add MS-DOS support.  *  * Revision 5.6  1991/02/28  19:18:47  eggert  * Open work file at most once.  *  * Revision 5.5  1990/11/27  09:26:05  eggert  * Fix comment leader bug.  *  * Revision 5.4  1990/11/01  05:03:42  eggert  * Permit arbitrary data in logs and comment leaders.  *  * Revision 5.3  1990/09/11  02:41:15  eggert  * Don't ignore differences inside keyword strings if -ko is set.  *  * Revision 5.1  1990/08/29  07:13:58  eggert  * Clean old log messages too.  *  * Revision 5.0  1990/08/22  08:12:49  eggert  * Don't append "checked in with -k by " log to logs,  * so that checking in a program with -k doesn't change it.  * Ansify and Posixate.  Remove lint.  *  * Revision 4.5  89/05/01  15:12:42  narten  * changed copyright header to reflect current distribution rules  *  * Revision 4.4  88/08/09  19:12:50  eggert  * Shrink stdio code size.  *  * Revision 4.3  87/12/18  11:40:02  narten  * lint cleanups (Guy Harris)  *  * Revision 4.2  87/10/18  10:33:06  narten  * updting version number. Changes relative to 1.1 actually relative to  * 4.1  *  * Revision 1.2  87/03/27  14:22:19  jenkins  * Port to suns  *  * Revision 4.1  83/05/10  16:24:04  wft  * Marker matching now uses trymatch(). Marker pattern is now  * checked precisely.  *  * Revision 3.1  82/12/04  13:21:40  wft  * Initial revision.  *  */
end_comment

begin_comment
comment|/* #define FCMPTEST */
end_comment

begin_comment
comment|/* Testprogram; prints out whether two files are identical,  * except for keywords  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_macro
name|libId
argument_list|(
argument|fcmpId
argument_list|,
literal|"$Id: rcsfcmp.c,v 5.14 1995/06/16 06:19:24 eggert Exp $"
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|int
name|discardkeyval
name|P
argument_list|(
operator|(
name|int
operator|,
name|RILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|discardkeyval
parameter_list|(
name|c
parameter_list|,
name|f
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|f
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|KDELIM
case|:
case|case
literal|'\n'
case|:
return|return
name|c
return|;
default|default:
name|Igeteof_
argument_list|(
argument|f
argument_list|,
argument|c
argument_list|,
argument|return EOF;
argument_list|)
break|break;
block|}
block|}
end_function

begin_function
name|int
name|rcsfcmp
parameter_list|(
name|xfp
parameter_list|,
name|xstatp
parameter_list|,
name|uname
parameter_list|,
name|delta
parameter_list|)
specifier|register
name|RILE
modifier|*
name|xfp
decl_stmt|;
name|struct
name|stat
specifier|const
modifier|*
name|xstatp
decl_stmt|;
name|char
specifier|const
modifier|*
name|uname
decl_stmt|;
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
comment|/* Compare the files xfp and uname.  Return zero  * if xfp has the same contents as uname and neither has keywords,  * otherwise -1 if they are the same ignoring keyword values,  * and 1 if they differ even ignoring  * keyword values. For the LOG-keyword, rcsfcmp skips the log message  * given by the parameter delta in xfp.  Thus, rcsfcmp returns nonpositive  * if xfp contains the same as uname, with the keywords expanded.  * Implementation: character-by-character comparison until $ is found.  * If a $ is found, read in the marker keywords; if they are real keywords  * and identical, read in keyword value. If value is terminated properly,  * disregard it and optionally skip log message; otherwise, compare value.  */
block|{
specifier|register
name|int
name|xc
decl_stmt|,
name|uc
decl_stmt|;
name|char
name|xkeyword
index|[
name|keylength
operator|+
literal|2
index|]
decl_stmt|;
name|int
name|eqkeyvals
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|ufp
decl_stmt|;
specifier|register
name|int
name|xeof
decl_stmt|,
name|ueof
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|sp
decl_stmt|;
specifier|register
name|size_t
name|leaderlen
decl_stmt|;
name|int
name|result
decl_stmt|;
name|enum
name|markers
name|match1
decl_stmt|;
name|struct
name|stat
name|ustat
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ufp
operator|=
name|Iopen
argument_list|(
name|uname
argument_list|,
name|FOPEN_R_WORK
argument_list|,
operator|&
name|ustat
argument_list|)
operator|)
condition|)
block|{
name|efaterror
argument_list|(
name|uname
argument_list|)
expr_stmt|;
block|}
name|xeof
operator|=
name|ueof
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|MIN_UNEXPAND
operator|<=
name|Expand
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|result
operator|=
name|xstatp
operator|->
name|st_size
operator|!=
name|ustat
operator|.
name|st_size
operator|)
condition|)
block|{
if|#
directive|if
name|large_memory
operator|&&
name|maps_memory
name|result
operator|=
operator|!
operator|!
name|memcmp
argument_list|(
name|xfp
operator|->
name|base
argument_list|,
name|ufp
operator|->
name|base
argument_list|,
operator|(
name|size_t
operator|)
name|xstatp
operator|->
name|st_size
argument_list|)
expr_stmt|;
else|#
directive|else
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* get the next characters */
name|Igeteof_
argument_list|(
argument|xfp
argument_list|,
argument|xc
argument_list|,
argument|xeof=true;
argument_list|)
name|Igeteof_
argument_list|(
argument|ufp
argument_list|,
argument|uc
argument_list|,
argument|ueof=true;
argument_list|)
if|if
condition|(
name|xeof
operator||
name|ueof
condition|)
goto|goto
name|eof
goto|;
if|if
condition|(
name|xc
operator|!=
name|uc
condition|)
goto|goto
name|return1
goto|;
block|}
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|xc
operator|=
literal|0
expr_stmt|;
name|uc
operator|=
literal|0
expr_stmt|;
comment|/* Keep lint happy.  */
name|leaderlen
operator|=
literal|0
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|xc
operator|!=
name|KDELIM
condition|)
block|{
comment|/* get the next characters */
name|Igeteof_
argument_list|(
argument|xfp
argument_list|,
argument|xc
argument_list|,
argument|xeof=true;
argument_list|)
name|Igeteof_
argument_list|(
argument|ufp
argument_list|,
argument|uc
argument_list|,
argument|ueof=true;
argument_list|)
if|if
condition|(
name|xeof
operator||
name|ueof
condition|)
goto|goto
name|eof
goto|;
block|}
else|else
block|{
comment|/* try to get both keywords */
name|tp
operator|=
name|xkeyword
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|Igeteof_
argument_list|(
argument|xfp
argument_list|,
argument|xc
argument_list|,
argument|xeof=true;
argument_list|)
name|Igeteof_
argument_list|(
argument|ufp
argument_list|,
argument|uc
argument_list|,
argument|ueof=true;
argument_list|)
if|if
condition|(
name|xeof
operator||
name|ueof
condition|)
goto|goto
name|eof
goto|;
if|if
condition|(
name|xc
operator|!=
name|uc
condition|)
break|break;
switch|switch
condition|(
name|xc
condition|)
block|{
default|default:
if|if
condition|(
name|xkeyword
operator|+
name|keylength
operator|<=
name|tp
condition|)
break|break;
operator|*
name|tp
operator|++
operator|=
name|xc
expr_stmt|;
continue|continue;
case|case
literal|'\n'
case|:
case|case
name|KDELIM
case|:
case|case
name|VDELIM
case|:
break|break;
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|xc
operator|==
name|KDELIM
operator|||
name|xc
operator|==
name|VDELIM
operator|)
operator|&&
operator|(
name|uc
operator|==
name|KDELIM
operator|||
name|uc
operator|==
name|VDELIM
operator|)
operator|&&
operator|(
operator|*
name|tp
operator|=
name|xc
operator|,
operator|(
name|match1
operator|=
name|trymatch
argument_list|(
name|xkeyword
argument_list|)
operator|)
operator|!=
name|Nomatch
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|FCMPTEST
name|VOID
name|printf
argument_list|(
literal|"found common keyword %s\n"
argument_list|,
name|xkeyword
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|result
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|xc
operator|!=
name|uc
condition|)
block|{
name|xc
operator|=
name|discardkeyval
argument_list|(
name|xc
argument_list|,
name|xfp
argument_list|)
expr_stmt|;
name|uc
operator|=
name|discardkeyval
argument_list|(
name|uc
argument_list|,
name|ufp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xeof
operator|=
name|xc
operator|==
name|EOF
operator|)
operator||
operator|(
name|ueof
operator|=
name|uc
operator|==
name|EOF
operator|)
condition|)
goto|goto
name|eof
goto|;
name|eqkeyvals
operator|=
name|false
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|xc
condition|)
block|{
default|default:
name|Igeteof_
argument_list|(
argument|xfp
argument_list|,
argument|xc
argument_list|,
argument|xeof=true;
argument_list|)
name|Igeteof_
argument_list|(
argument|ufp
argument_list|,
argument|uc
argument_list|,
argument|ueof=true;
argument_list|)
if|if
condition|(
name|xeof
operator||
name|ueof
condition|)
goto|goto
name|eof
goto|;
continue|continue;
case|case
literal|'\n'
case|:
case|case
name|KDELIM
case|:
name|eqkeyvals
operator|=
name|true
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|xc
operator|!=
name|uc
condition|)
goto|goto
name|return1
goto|;
if|if
condition|(
name|xc
operator|==
name|KDELIM
condition|)
block|{
comment|/* Skip closing KDELIM.  */
name|Igeteof_
argument_list|(
argument|xfp
argument_list|,
argument|xc
argument_list|,
argument|xeof=true;
argument_list|)
name|Igeteof_
argument_list|(
argument|ufp
argument_list|,
argument|uc
argument_list|,
argument|ueof=true;
argument_list|)
if|if
condition|(
name|xeof
operator||
name|ueof
condition|)
goto|goto
name|eof
goto|;
comment|/* if the keyword is LOG, also skip the log message in xfp*/
if|if
condition|(
name|match1
operator|==
name|Log
condition|)
block|{
comment|/* first, compute the number of line feeds in log msg */
name|int
name|lncnt
decl_stmt|;
name|size_t
name|ls
decl_stmt|,
name|ccnt
decl_stmt|;
name|sp
operator|=
name|delta
operator|->
name|log
operator|.
name|string
expr_stmt|;
name|ls
operator|=
name|delta
operator|->
name|log
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|ls
operator|<
sizeof|sizeof
argument_list|(
name|ciklog
argument_list|)
operator|-
literal|1
operator|||
name|memcmp
argument_list|(
name|sp
argument_list|,
name|ciklog
argument_list|,
sizeof|sizeof
argument_list|(
name|ciklog
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* 			* This log message was inserted.  Skip its header. 			* The number of newlines to skip is 			* 1 + (C+1)*(1+L+1), where C is the number of newlines 			* in the comment leader, and L is the number of 			* newlines in the log string. 			*/
name|int
name|c1
init|=
literal|1
decl_stmt|;
for|for
control|(
name|ccnt
operator|=
name|Comment
operator|.
name|size
init|;
name|ccnt
operator|--
condition|;
control|)
name|c1
operator|+=
name|Comment
operator|.
name|string
index|[
name|ccnt
index|]
operator|==
literal|'\n'
expr_stmt|;
name|lncnt
operator|=
literal|2
operator|*
name|c1
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|ls
operator|--
condition|)
if|if
condition|(
operator|*
name|sp
operator|++
operator|==
literal|'\n'
condition|)
name|lncnt
operator|+=
name|c1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|xc
operator|==
literal|'\n'
condition|)
if|if
condition|(
operator|--
name|lncnt
operator|==
literal|0
condition|)
break|break;
name|Igeteof_
argument_list|(
argument|xfp
argument_list|,
argument|xc
argument_list|,
argument|goto returnresult;
argument_list|)
block|}
comment|/* skip last comment leader */
comment|/* Can't just skip another line here, because there may be */
comment|/* additional characters on the line (after the Log....$)  */
name|ccnt
operator|=
name|RCSversion
operator|<
name|VERSION
argument_list|(
literal|5
argument_list|)
condition|?
name|Comment
operator|.
name|size
else|:
name|leaderlen
expr_stmt|;
do|do
block|{
name|Igeteof_
argument_list|(
argument|xfp
argument_list|,
argument|xc
argument_list|,
argument|goto returnresult;
argument_list|)
comment|/* 			     * Read to the end of the comment leader or '\n', 			     * whatever comes first, because the leader's 			     * trailing white space was probably stripped. 			     */
block|}
do|while
condition|(
name|ccnt
operator|--
operator|&&
operator|(
name|xc
operator|!=
literal|'\n'
operator|||
operator|--
name|c1
operator|)
condition|)
do|;
block|}
block|}
block|}
else|else
block|{
comment|/* both end in the same character, but not a KDELIM */
comment|/* must compare string values.*/
ifdef|#
directive|ifdef
name|FCMPTEST
name|VOID
name|printf
argument_list|(
literal|"non-terminated keywords %s, potentially different values\n"
argument_list|,
name|xkeyword
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|eqkeyvals
condition|)
goto|goto
name|return1
goto|;
block|}
block|}
block|}
if|if
condition|(
name|xc
operator|!=
name|uc
condition|)
goto|goto
name|return1
goto|;
if|if
condition|(
name|xc
operator|==
literal|'\n'
condition|)
name|leaderlen
operator|=
literal|0
expr_stmt|;
else|else
name|leaderlen
operator|++
expr_stmt|;
block|}
block|}
name|eof
label|:
if|if
condition|(
name|xeof
operator|==
name|ueof
condition|)
goto|goto
name|returnresult
goto|;
name|return1
label|:
name|result
operator|=
literal|1
expr_stmt|;
name|returnresult
label|:
name|Ifclose
argument_list|(
name|ufp
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FCMPTEST
end_ifdef

begin_decl_stmt
name|char
specifier|const
name|cmdid
index|[]
init|=
literal|"rcsfcmp"
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
comment|/* first argument: comment leader; 2nd: log message, 3rd: expanded file,  * 4th: unexpanded file  */
block|{
name|struct
name|hshentry
name|delta
decl_stmt|;
name|Comment
operator|.
name|string
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|Comment
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|delta
operator|.
name|log
operator|.
name|string
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|delta
operator|.
name|log
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcsfcmp
argument_list|(
name|Iopen
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|,
name|FOPEN_R_WORK
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
literal|0
argument_list|)
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|,
operator|&
name|delta
argument_list|)
condition|)
name|VOID
name|printf
argument_list|(
literal|"files are the same\n"
argument_list|)
decl_stmt|;
else|else
name|VOID
name|printf
argument_list|(
literal|"files are different\n"
argument_list|)
decl_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

