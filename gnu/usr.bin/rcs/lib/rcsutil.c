begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* RCS utility functions */
end_comment

begin_comment
comment|/* Copyright 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991, 1992, 1993, 1994, 1995 Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/*  * Revision 5.20  1995/06/16 06:19:24  eggert  * (catchsig): Remove `return'.  * Update FSF address.  *  * Revision 5.19  1995/06/02 18:19:00  eggert  * (catchsigaction): New name for `catchsig', for sa_sigaction signature.  * Use nRCS even if !has_psiginfo, to remove unused variable warning.  * (setup_catchsig): Use sa_sigaction only if has_sa_sigaction.  * Use ENOTSUP only if defined.  *  * Revision 5.18  1995/06/01 16:23:43  eggert  * (catchsig, restoreints, setup_catchsig): Use SA_SIGINFO, not has_psiginfo,  * to determine whether to use SA_SIGINFO feature,  * but also check at runtime whether the feature works.  * (catchsig): If an mmap_signal occurs, report the affected file name.  * (unsupported_SA_SIGINFO, accessName): New variables.  * (setup_catchsig): If using SA_SIGINFO, use sa_sigaction, not sa_handler.  * If SA_SIGINFO fails, fall back on sa_handler method.  *  * (readAccessFilenameBuffer, dupSafer, fdSafer, fopenSafer): New functions.  * (concatenate): Remove.  *  * (runv): Work around bad_wait_if_SIGCHLD_ignored bug.  * Remove reference to OPEN_O_WORK.  *  * Revision 5.17  1994/03/20 04:52:58  eggert  * Specify subprocess input via file descriptor, not file name.  * Avoid messing with I/O buffers in the child process.  * Define dup in terms of F_DUPFD if it exists.  * Move setmtime to rcsedit.c.  Remove lint.  *  * Revision 5.16  1993/11/09 17:40:15  eggert  * -V now prints version on stdout and exits.  *  * Revision 5.15  1993/11/03 17:42:27  eggert  * Use psiginfo and setreuid if available.  Move date2str to maketime.c.  *  * Revision 5.14  1992/07/28  16:12:44  eggert  * Add -V.  has_sigaction overrides sig_zaps_handler.  Fix -M bug.  * Add mmap_signal, which minimizes signal handling for non-mmap hosts.  *  * Revision 5.13  1992/02/17  23:02:28  eggert  * Work around NFS mmap SIGBUS problem.  Add -T support.  *  * Revision 5.12  1992/01/24  18:44:19  eggert  * Work around NFS mmap bug that leads to SIGBUS core dumps.  lint -> RCS_lint  *  * Revision 5.11  1992/01/06  02:42:34  eggert  * O_BINARY -> OPEN_O_WORK  * while (E) ; -> while (E) continue;  *  * Revision 5.10  1991/10/07  17:32:46  eggert  * Support piece tables even if !has_mmap.  *  * Revision 5.9  1991/08/19  03:13:55  eggert  * Add spawn() support.  Explicate assumptions about getting invoker's name.  * Standardize user-visible dates.  Tune.  *  * Revision 5.8  1991/04/21  11:58:30  eggert  * Plug setuid security hole.  *  * Revision 5.6  1991/02/26  17:48:39  eggert  * Fix setuid bug.  Use fread, fwrite more portably.  * Support waitpid.  Don't assume -1 is acceptable to W* macros.  * strsave -> str_save (DG/UX name clash)  *  * Revision 5.5  1990/12/04  05:18:49  eggert  * Don't output a blank line after a signal diagnostic.  * Use -I for prompts and -q for diagnostics.  *  * Revision 5.4  1990/11/01  05:03:53  eggert  * Remove unneeded setid check.  Add awrite(), fremember().  *  * Revision 5.3  1990/10/06  00:16:45  eggert  * Don't fread F if feof(F).  *  * Revision 5.2  1990/09/04  08:02:31  eggert  * Store fread()'s result in an fread_type object.  *  * Revision 5.1  1990/08/29  07:14:07  eggert  * Declare getpwuid() more carefully.  *  * Revision 5.0  1990/08/22  08:13:46  eggert  * Add setuid support.  Permit multiple locks per user.  * Remove compile-time limits; use malloc instead.  * Switch to GMT.  Permit dates past 1999/12/31.  * Add -V.  Remove snooping.  Ansify and Posixate.  * Tune.  Some USG hosts define NSIG but not sys_siglist.  * Don't run /bin/sh if it's hopeless.  * Don't leave garbage behind if the output is an empty pipe.  * Clean up after SIGXCPU or SIGXFSZ.  Print name of signal that caused cleanup.  *  * Revision 4.6  89/05/01  15:13:40  narten  * changed copyright header to reflect current distribution rules  *  * Revision 4.5  88/11/08  16:01:02  narten  * corrected use of varargs routines  *  * Revision 4.4  88/08/09  19:13:24  eggert  * Check for memory exhaustion.  * Permit signal handlers to yield either 'void' or 'int'; fix oldSIGINT botch.  * Use execv(), not system(); yield exit status like diff(1)'s.  *  * Revision 4.3  87/10/18  10:40:22  narten  * Updating version numbers. Changes relative to 1.1 actually  * relative to 4.1  *  * Revision 1.3  87/09/24  14:01:01  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf  * warnings)  *  * Revision 1.2  87/03/27  14:22:43  jenkins  * Port to suns  *  * Revision 4.1  83/05/10  15:53:13  wft  * Added getcaller() and findlock().  * Changed catchints() to check SIGINT for SIG_IGN before setting up the signal  * (needed for background jobs in older shells). Added restoreints().  * Removed printing of full RCS path from logcommand().  *  * Revision 3.8  83/02/15  15:41:49  wft  * Added routine fastcopy() to copy remainder of a file in blocks.  *  * Revision 3.7  82/12/24  15:25:19  wft  * added catchints(), ignoreints() for catching and ingnoring interrupts;  * fixed catchsig().  *  * Revision 3.6  82/12/08  21:52:05  wft  * Using DATEFORM to format dates.  *  * Revision 3.5  82/12/04  18:20:49  wft  * Replaced SNOOPDIR with SNOOPFILE; changed addlock() to update  * lockedby-field.  *  * Revision 3.4  82/12/03  17:17:43  wft  * Added check to addlock() ensuring only one lock per person.  * Addlock also returns a pointer to the lock created. Deleted fancydate().  *  * Revision 3.3  82/11/27  12:24:37  wft  * moved rmsema(), trysema(), trydiraccess(), getfullRCSname() to rcsfnms.c.  * Introduced macro SNOOP so that snoop can be placed in directory other than  * TARGETDIR. Changed %02d to %.2d for compatibility reasons.  *  * Revision 3.2  82/10/18  21:15:11  wft  * added function getfullRCSname().  *  * Revision 3.1  82/10/13  16:17:37  wft  * Cleanup message is now suppressed in quiet mode.  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_macro
name|libId
argument_list|(
argument|utilId
argument_list|,
literal|"$FreeBSD$"
argument_list|)
end_macro

begin_if
if|#
directive|if
operator|!
name|has_memcmp
end_if

begin_function
name|int
name|memcmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|n
parameter_list|)
name|void
specifier|const
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_decl_stmt
name|size_t
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|char
specifier|const
modifier|*
name|p1
init|=
operator|(
name|unsigned
name|char
specifier|const
operator|*
operator|)
name|s1
decl_stmt|,
modifier|*
name|p2
init|=
operator|(
name|unsigned
name|char
specifier|const
operator|*
operator|)
name|s2
decl_stmt|;
specifier|register
name|size_t
name|i
init|=
name|n
decl_stmt|;
specifier|register
name|int
name|r
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|--
operator|&&
operator|!
operator|(
name|r
operator|=
operator|(
operator|*
name|p1
operator|++
operator|-
operator|*
name|p2
operator|++
operator|)
operator|)
condition|)
empty_stmt|;
return|return
name|r
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|has_memcpy
end_if

begin_function
name|void
modifier|*
name|memcpy
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|n
parameter_list|)
name|void
modifier|*
name|s1
decl_stmt|;
name|void
specifier|const
modifier|*
name|s2
decl_stmt|;
name|size_t
name|n
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p1
init|=
operator|(
name|char
operator|*
operator|)
name|s1
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|p2
init|=
operator|(
name|char
specifier|const
operator|*
operator|)
name|s2
decl_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
operator|*
name|p1
operator|++
operator|=
operator|*
name|p2
operator|++
expr_stmt|;
return|return
name|s1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|RCS_lint
end_if

begin_decl_stmt
name|malloc_type
name|lintalloc
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * list of blocks allocated with ftestalloc()  * These blocks can be freed by ffree when we're done with the current file.  * We could put the free block inside struct alloclist, rather than a pointer  * to the free block, but that would be less portable.  */
end_comment

begin_struct
struct|struct
name|alloclist
block|{
name|malloc_type
name|alloc
decl_stmt|;
name|struct
name|alloclist
modifier|*
name|nextalloc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|alloclist
modifier|*
name|alloced
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|malloc_type
name|okalloc
name|P
argument_list|(
operator|(
name|malloc_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|malloc_type
name|okalloc
parameter_list|(
name|p
parameter_list|)
name|malloc_type
name|p
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|p
condition|)
name|faterror
argument_list|(
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|malloc_type
name|testalloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
comment|/* Allocate a block, testing that the allocation succeeded.  */
block|{
return|return
name|okalloc
argument_list|(
name|malloc
argument_list|(
name|size
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|malloc_type
name|testrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|malloc_type
name|ptr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
comment|/* Reallocate a block, testing that the allocation succeeded.  */
block|{
return|return
name|okalloc
argument_list|(
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|malloc_type
name|fremember
parameter_list|(
name|ptr
parameter_list|)
name|malloc_type
name|ptr
decl_stmt|;
comment|/* Remember PTR in 'alloced' so that it can be freed later.  Yield PTR.  */
block|{
specifier|register
name|struct
name|alloclist
modifier|*
name|q
init|=
name|talloc
argument_list|(
expr|struct
name|alloclist
argument_list|)
decl_stmt|;
name|q
operator|->
name|nextalloc
operator|=
name|alloced
expr_stmt|;
name|alloced
operator|=
name|q
expr_stmt|;
return|return
name|q
operator|->
name|alloc
operator|=
name|ptr
return|;
block|}
end_function

begin_function
name|malloc_type
name|ftestalloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
comment|/* Allocate a block, putting it in 'alloced' so it can be freed later. */
block|{
return|return
name|fremember
argument_list|(
name|testalloc
argument_list|(
name|size
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ffree
parameter_list|()
comment|/* Free all blocks allocated with ftestalloc().  */
block|{
specifier|register
name|struct
name|alloclist
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|p
operator|=
name|alloced
init|;
name|p
condition|;
name|p
operator|=
name|q
control|)
block|{
name|q
operator|=
name|p
operator|->
name|nextalloc
expr_stmt|;
name|tfree
argument_list|(
name|p
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|tfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|alloced
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ffree1
parameter_list|(
name|f
parameter_list|)
specifier|register
name|char
specifier|const
modifier|*
name|f
decl_stmt|;
comment|/* Free the block f, which was allocated by ftestalloc.  */
block|{
specifier|register
name|struct
name|alloclist
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|a
init|=
operator|&
name|alloced
decl_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
operator|*
name|a
operator|)
operator|->
name|alloc
operator|!=
name|f
condition|)
name|a
operator|=
operator|&
name|p
operator|->
name|nextalloc
expr_stmt|;
operator|*
name|a
operator|=
name|p
operator|->
name|nextalloc
expr_stmt|;
name|tfree
argument_list|(
name|p
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|tfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|str_save
parameter_list|(
name|s
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
comment|/* Save s in permanently allocated storage. */
block|{
return|return
name|strcpy
argument_list|(
name|tnalloc
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|fstr_save
parameter_list|(
name|s
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
comment|/* Save s in storage that will be deallocated when we're done with this file. */
block|{
return|return
name|strcpy
argument_list|(
name|ftnalloc
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|cgetenv
parameter_list|(
name|name
parameter_list|)
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
comment|/* Like getenv(), but yield a copy; getenv() can overwrite old results. */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
return|return
operator|(
name|p
operator|=
name|getenv
argument_list|(
name|name
argument_list|)
operator|)
condition|?
name|str_save
argument_list|(
name|p
argument_list|)
else|:
name|p
return|;
block|}
end_function

begin_function
name|char
specifier|const
modifier|*
name|getusername
parameter_list|(
name|suspicious
parameter_list|)
name|int
name|suspicious
decl_stmt|;
comment|/* Get the caller's login name.  Trust only getwpuid if SUSPICIOUS.  */
block|{
specifier|static
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
block|{
if|if
condition|(
comment|/* Prefer getenv() unless suspicious; it's much faster.  */
if|#
directive|if
name|getlogin_is_secure
operator|(
name|suspicious
operator|||
operator|(
operator|!
operator|(
name|name
operator|=
name|cgetenv
argument_list|(
literal|"LOGNAME"
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|name
operator|=
name|cgetenv
argument_list|(
literal|"USER"
argument_list|)
operator|)
operator|)
operator|)
operator|&&
operator|!
operator|(
name|name
operator|=
name|getlogin
argument_list|()
operator|)
else|#
directive|else
name|suspicious
operator|||
operator|(
operator|!
operator|(
name|name
operator|=
name|cgetenv
argument_list|(
literal|"LOGNAME"
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|name
operator|=
name|cgetenv
argument_list|(
literal|"USER"
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|name
operator|=
name|getlogin
argument_list|()
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
if|#
directive|if
name|has_getuid
operator|&&
name|has_getpwuid
name|struct
name|passwd
specifier|const
modifier|*
name|pw
init|=
name|getpwuid
argument_list|(
name|ruid
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pw
condition|)
name|faterror
argument_list|(
literal|"no password entry for userid %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ruid
argument_list|()
argument_list|)
expr_stmt|;
name|name
operator|=
name|pw
operator|->
name|pw_name
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|has_setuid
name|faterror
argument_list|(
literal|"setuid not supported"
argument_list|)
expr_stmt|;
else|#
directive|else
name|faterror
argument_list|(
literal|"Who are you?  Please setenv LOGNAME."
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
name|checksid
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|name
return|;
block|}
end_function

begin_if
if|#
directive|if
name|has_signal
end_if

begin_comment
comment|/*  *	 Signal handling  *  * Standard C places too many restrictions on signal handlers.  * We obey as many of them as we can.  * Posix places fewer restrictions, and we are Posix-compatible here.  */
end_comment

begin_decl_stmt
specifier|static
name|sig_atomic_t
specifier|volatile
name|heldsignal
decl_stmt|,
name|holdlevel
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SA_SIGINFO
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|unsupported_SA_SIGINFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|siginfo_t
name|bufsiginfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|siginfo_t
modifier|*
specifier|volatile
name|heldsiginfo
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|has_NFS
operator|&&
name|has_mmap
operator|&&
name|large_memory
operator|&&
name|mmap_signal
end_if

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|accessName
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|readAccessFilenameBuffer
parameter_list|(
name|filename
parameter_list|,
name|p
parameter_list|)
name|char
specifier|const
modifier|*
name|filename
decl_stmt|;
name|unsigned
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
block|{
name|unsigned
name|char
specifier|volatile
name|t
decl_stmt|;
name|accessName
operator|=
name|filename
expr_stmt|;
name|t
operator|=
operator|*
name|p
expr_stmt|;
name|accessName
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|accessName
value|((char const *) 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|has_psignal
end_if

begin_define
define|#
directive|define
name|psignal
value|my_psignal
end_define

begin_decl_stmt
specifier|static
name|void
name|my_psignal
name|P
argument_list|(
operator|(
name|int
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|my_psignal
parameter_list|(
name|sig
parameter_list|,
name|s
parameter_list|)
name|int
name|sig
decl_stmt|;
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
block|{
name|char
specifier|const
modifier|*
name|sname
init|=
literal|"Unknown signal"
decl_stmt|;
if|#
directive|if
name|has_sys_siglist
operator|&&
name|defined
argument_list|(
name|NSIG
argument_list|)
if|if
condition|(
operator|(
name|unsigned
operator|)
name|sig
operator|<
name|NSIG
condition|)
name|sname
operator|=
name|sys_siglist
index|[
name|sig
index|]
expr_stmt|;
else|#
directive|else
switch|switch
condition|(
name|sig
condition|)
block|{
ifdef|#
directive|ifdef
name|SIGHUP
case|case
name|SIGHUP
case|:
name|sname
operator|=
literal|"Hangup"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGINT
case|case
name|SIGINT
case|:
name|sname
operator|=
literal|"Interrupt"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
case|case
name|SIGPIPE
case|:
name|sname
operator|=
literal|"Broken pipe"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
case|case
name|SIGQUIT
case|:
name|sname
operator|=
literal|"Quit"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
case|case
name|SIGTERM
case|:
name|sname
operator|=
literal|"Terminated"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXCPU
case|case
name|SIGXCPU
case|:
name|sname
operator|=
literal|"Cputime limit exceeded"
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXFSZ
case|case
name|SIGXFSZ
case|:
name|sname
operator|=
literal|"Filesize limit exceeded"
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|has_mmap
operator|&&
name|large_memory
if|#
directive|if
name|defined
argument_list|(
name|SIGBUS
argument_list|)
operator|&&
name|mmap_signal
operator|==
name|SIGBUS
case|case
name|SIGBUS
case|:
name|sname
operator|=
literal|"Bus error"
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSEGV
argument_list|)
operator|&&
name|mmap_signal
operator|==
name|SIGSEGV
case|case
name|SIGSEGV
case|:
name|sname
operator|=
literal|"Segmentation fault"
expr_stmt|;
break|break;
endif|#
directive|endif
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* Avoid calling sprintf etc., in case they're not reentrant.  */
block|{
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|b
init|=
name|buf
decl_stmt|;
for|for
control|(
name|p
operator|=
name|s
init|;
operator|*
name|p
condition|;
operator|*
name|b
operator|++
operator|=
operator|*
name|p
operator|++
control|)
continue|continue;
operator|*
name|b
operator|++
operator|=
literal|':'
expr_stmt|;
operator|*
name|b
operator|++
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|p
operator|=
name|sname
init|;
operator|*
name|p
condition|;
operator|*
name|b
operator|++
operator|=
operator|*
name|p
operator|++
control|)
continue|continue;
operator|*
name|b
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|VOID
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|buf
argument_list|,
name|b
operator|-
name|buf
argument_list|)
decl_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|signal_type
name|catchsig
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SA_SIGINFO
end_ifdef

begin_decl_stmt
specifier|static
name|signal_type
name|catchsigaction
name|P
argument_list|(
operator|(
name|int
operator|,
name|siginfo_t
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|signal_type
name|catchsig
parameter_list|(
name|s
parameter_list|)
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|SA_SIGINFO
block|{
name|catchsigaction
argument_list|(
name|s
argument_list|,
operator|(
name|siginfo_t
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|signal_type
name|catchsigaction
parameter_list|(
name|s
parameter_list|,
name|i
parameter_list|,
name|c
parameter_list|)
name|int
name|s
decl_stmt|;
name|siginfo_t
modifier|*
name|i
decl_stmt|;
name|void
modifier|*
name|c
decl_stmt|;
endif|#
directive|endif
block|{
if|#
directive|if
name|sig_zaps_handler
comment|/* If a signal arrives before we reset the handler, we lose. */
name|VOID
name|signal
argument_list|(
name|s
argument_list|,
name|SIG_IGN
argument_list|)
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SA_SIGINFO
if|if
condition|(
operator|!
name|unsupported_SA_SIGINFO
condition|)
name|i
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|holdlevel
condition|)
block|{
name|heldsignal
operator|=
name|s
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_SIGINFO
if|if
condition|(
name|i
condition|)
block|{
name|bufsiginfo
operator|=
operator|*
name|i
expr_stmt|;
name|heldsiginfo
operator|=
operator|&
name|bufsiginfo
expr_stmt|;
block|}
endif|#
directive|endif
return|return;
block|}
name|ignoreints
argument_list|()
expr_stmt|;
name|setrid
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|quietflag
condition|)
block|{
comment|/* Avoid calling sprintf etc., in case they're not reentrant.  */
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|b
init|=
name|buf
decl_stmt|;
if|if
condition|(
operator|!
operator|(
if|#
directive|if
name|has_mmap
operator|&&
name|large_memory
operator|&&
name|mmap_signal
comment|/* Check whether this signal was planned.  */
name|s
operator|==
name|mmap_signal
operator|&&
name|accessName
else|#
directive|else
literal|0
endif|#
directive|endif
operator|)
condition|)
block|{
name|char
specifier|const
modifier|*
name|nRCS
init|=
literal|"\nRCS"
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SA_SIGINFO
argument_list|)
operator|&&
name|has_si_errno
operator|&&
name|has_mmap
operator|&&
name|large_memory
operator|&&
name|mmap_signal
if|if
condition|(
name|s
operator|==
name|mmap_signal
operator|&&
name|i
operator|&&
name|i
operator|->
name|si_errno
condition|)
block|{
name|errno
operator|=
name|i
operator|->
name|si_errno
expr_stmt|;
name|perror
argument_list|(
name|nRCS
operator|++
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SA_SIGINFO
argument_list|)
operator|&&
name|has_psiginfo
if|if
condition|(
name|i
condition|)
name|psiginfo
argument_list|(
name|i
argument_list|,
name|nRCS
argument_list|)
expr_stmt|;
else|else
name|psignal
argument_list|(
name|s
argument_list|,
name|nRCS
argument_list|)
expr_stmt|;
else|#
directive|else
name|psignal
argument_list|(
name|s
argument_list|,
name|nRCS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
for|for
control|(
name|p
operator|=
literal|"RCS: "
init|;
operator|*
name|p
condition|;
operator|*
name|b
operator|++
operator|=
operator|*
name|p
operator|++
control|)
continue|continue;
if|#
directive|if
name|has_mmap
operator|&&
name|large_memory
operator|&&
name|mmap_signal
if|if
condition|(
name|s
operator|==
name|mmap_signal
condition|)
block|{
name|p
operator|=
name|accessName
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
literal|"Was a file changed by some other process?  "
expr_stmt|;
else|else
block|{
name|char
specifier|const
modifier|*
name|p1
decl_stmt|;
for|for
control|(
name|p1
operator|=
name|p
init|;
operator|*
name|p1
condition|;
name|p1
operator|++
control|)
continue|continue;
name|VOID
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|buf
argument_list|,
name|b
operator|-
name|buf
argument_list|)
decl_stmt|;
name|VOID
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|p
argument_list|,
name|p1
operator|-
name|p
argument_list|)
decl_stmt|;
name|b
operator|=
name|buf
expr_stmt|;
name|p
operator|=
literal|": Permission denied.  "
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
condition|)
operator|*
name|b
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|p
operator|=
literal|"Cleaning up.\n"
init|;
operator|*
name|p
condition|;
operator|*
name|b
operator|++
operator|=
operator|*
name|p
operator|++
control|)
continue|continue;
name|VOID
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|buf
argument_list|,
name|b
operator|-
name|buf
argument_list|)
decl_stmt|;
block|}
name|exiterr
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ignoreints
parameter_list|()
block|{
operator|++
name|holdlevel
expr_stmt|;
block|}
end_function

begin_function
name|void
name|restoreints
parameter_list|()
block|{
if|if
condition|(
operator|!
operator|--
name|holdlevel
operator|&&
name|heldsignal
condition|)
ifdef|#
directive|ifdef
name|SA_SIGINFO
name|VOID
name|catchsigaction
argument_list|(
name|heldsignal
argument_list|,
name|heldsiginfo
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
else|#
directive|else
name|VOID
name|catchsig
argument_list|(
name|heldsignal
argument_list|)
decl_stmt|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|setup_catchsig
name|P
argument_list|(
operator|(
name|int
specifier|const
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|has_sigaction
end_if

begin_decl_stmt
specifier|static
name|void
name|check_sig
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|check_sig
parameter_list|(
name|r
parameter_list|)
name|int
name|r
decl_stmt|;
block|{
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
name|efaterror
argument_list|(
literal|"signal handling"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_catchsig
parameter_list|(
name|sig
parameter_list|,
name|sigs
parameter_list|)
name|int
specifier|const
modifier|*
name|sig
decl_stmt|;
name|int
name|sigs
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|sigaction
name|act
decl_stmt|;
for|for
control|(
name|i
operator|=
name|sigs
init|;
literal|0
operator|<=
operator|--
name|i
condition|;
control|)
block|{
name|check_sig
argument_list|(
name|sigaction
argument_list|(
name|sig
index|[
name|i
index|]
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|act
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|act
operator|.
name|sa_handler
operator|!=
name|SIG_IGN
condition|)
block|{
name|act
operator|.
name|sa_handler
operator|=
name|catchsig
expr_stmt|;
ifdef|#
directive|ifdef
name|SA_SIGINFO
if|if
condition|(
operator|!
name|unsupported_SA_SIGINFO
condition|)
block|{
if|#
directive|if
name|has_sa_sigaction
name|act
operator|.
name|sa_sigaction
operator|=
name|catchsigaction
expr_stmt|;
else|#
directive|else
name|act
operator|.
name|sa_handler
operator|=
name|catchsigaction
expr_stmt|;
endif|#
directive|endif
name|act
operator|.
name|sa_flags
operator||=
name|SA_SIGINFO
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|j
operator|=
name|sigs
init|;
literal|0
operator|<=
operator|--
name|j
condition|;
control|)
name|check_sig
argument_list|(
name|sigaddset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|,
name|sig
index|[
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|sig
index|[
name|i
index|]
argument_list|,
operator|&
name|act
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SA_SIGINFO
argument_list|)
operator|&&
name|defined
argument_list|(
name|ENOTSUP
argument_list|)
if|if
condition|(
name|errno
operator|==
name|ENOTSUP
operator|&&
operator|!
name|unsupported_SA_SIGINFO
condition|)
block|{
comment|/* Turn off use of SA_SIGINFO and try again.  */
name|unsupported_SA_SIGINFO
operator|=
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
name|check_sig
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|has_sigblock
end_if

begin_function
specifier|static
name|void
name|setup_catchsig
parameter_list|(
name|sig
parameter_list|,
name|sigs
parameter_list|)
name|int
specifier|const
modifier|*
name|sig
decl_stmt|;
name|int
name|sigs
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sigs
init|;
literal|0
operator|<=
operator|--
name|i
condition|;
control|)
name|mask
operator||=
name|sigmask
argument_list|(
name|sig
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mask
operator|=
name|sigblock
argument_list|(
name|mask
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sigs
init|;
literal|0
operator|<=
operator|--
name|i
condition|;
control|)
if|if
condition|(
name|signal
argument_list|(
name|sig
index|[
name|i
index|]
argument_list|,
name|catchsig
argument_list|)
operator|==
name|SIG_IGN
operator|&&
name|signal
argument_list|(
name|sig
index|[
name|i
index|]
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|catchsig
condition|)
name|faterror
argument_list|(
literal|"signal catcher failure"
argument_list|)
expr_stmt|;
name|VOID
name|sigsetmask
argument_list|(
name|mask
argument_list|)
decl_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|setup_catchsig
parameter_list|(
name|sig
parameter_list|,
name|sigs
parameter_list|)
name|int
specifier|const
modifier|*
name|sig
decl_stmt|;
name|int
name|sigs
decl_stmt|;
block|{
specifier|register
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sigs
init|;
literal|0
operator|<=
operator|--
name|i
condition|;
control|)
if|if
condition|(
name|signal
argument_list|(
name|sig
index|[
name|i
index|]
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
operator|&&
name|signal
argument_list|(
name|sig
index|[
name|i
index|]
argument_list|,
name|catchsig
argument_list|)
operator|!=
name|SIG_IGN
condition|)
name|faterror
argument_list|(
literal|"signal catcher failure"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
specifier|const
name|regsigs
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|SIGHUP
name|SIGHUP
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGINT
name|SIGINT
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
name|SIGPIPE
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGQUIT
name|SIGQUIT
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
name|SIGTERM
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXCPU
name|SIGXCPU
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXFSZ
name|SIGXFSZ
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|catchints
parameter_list|()
block|{
specifier|static
name|int
name|catching_ints
decl_stmt|;
if|if
condition|(
operator|!
name|catching_ints
condition|)
block|{
name|catching_ints
operator|=
name|true
expr_stmt|;
name|setup_catchsig
argument_list|(
name|regsigs
argument_list|,
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|regsigs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|regsigs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|has_mmap
operator|&&
name|large_memory
operator|&&
name|mmap_signal
end_if

begin_comment
comment|/*     * If you mmap an NFS file, and someone on another client removes the last     * link to that file, and you later reference an uncached part of that file,     * you'll get a SIGBUS or SIGSEGV (depending on the operating system).     * Catch the signal and report the problem to the user.     * Unfortunately, there's no portable way to differentiate between this     * problem and actual bugs in the program.     * This NFS problem is rare, thank goodness.     *     * This can also occur if someone truncates the file, even without NFS.     */
end_comment

begin_decl_stmt
specifier|static
name|int
specifier|const
name|mmapsigs
index|[]
init|=
block|{
name|mmap_signal
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|catchmmapints
parameter_list|()
block|{
specifier|static
name|int
name|catching_mmap_ints
decl_stmt|;
if|if
condition|(
operator|!
name|catching_mmap_ints
condition|)
block|{
name|catching_mmap_ints
operator|=
name|true
expr_stmt|;
name|setup_catchsig
argument_list|(
name|mmapsigs
argument_list|,
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|mmapsigs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|mmapsigs
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* has_signal */
end_comment

begin_function
name|void
name|fastcopy
parameter_list|(
name|inf
parameter_list|,
name|outf
parameter_list|)
specifier|register
name|RILE
modifier|*
name|inf
decl_stmt|;
name|FILE
modifier|*
name|outf
decl_stmt|;
comment|/* Function: copies the remainder of file inf to outf.  */
block|{
if|#
directive|if
name|large_memory
if|#
directive|if
name|maps_memory
name|awrite
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
name|inf
operator|->
name|ptr
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|inf
operator|->
name|lim
operator|-
name|inf
operator|->
name|ptr
argument_list|)
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|inf
operator|->
name|ptr
operator|=
name|inf
operator|->
name|lim
expr_stmt|;
else|#
directive|else
for|for
control|(
init|;
condition|;
control|)
block|{
name|awrite
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
name|inf
operator|->
name|ptr
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|inf
operator|->
name|readlim
operator|-
name|inf
operator|->
name|ptr
argument_list|)
argument_list|,
name|outf
argument_list|)
expr_stmt|;
name|inf
operator|->
name|ptr
operator|=
name|inf
operator|->
name|readlim
expr_stmt|;
if|if
condition|(
name|inf
operator|->
name|ptr
operator|==
name|inf
operator|->
name|lim
condition|)
break|break;
name|VOID
name|Igetmore
argument_list|(
name|inf
argument_list|)
decl_stmt|;
block|}
endif|#
directive|endif
else|#
directive|else
name|char
name|buf
index|[
name|BUFSIZ
operator|*
literal|8
index|]
decl_stmt|;
specifier|register
name|fread_type
name|rcount
decl_stmt|;
comment|/*now read the rest of the file in blocks*/
while|while
condition|(
operator|!
name|feof
argument_list|(
name|inf
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|rcount
operator|=
name|Fread
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|inf
argument_list|)
operator|)
condition|)
block|{
name|testIerror
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return;
block|}
name|awrite
argument_list|(
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|rcount
argument_list|,
name|outf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SSIZE_MAX
end_ifndef

begin_comment
comment|/* This does not work in #ifs, but it's good enough for us.  */
end_comment

begin_comment
comment|/* Underestimating SSIZE_MAX may slow us down, but it won't break us.  */
end_comment

begin_define
define|#
directive|define
name|SSIZE_MAX
value|((unsigned)-1>> 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|awrite
parameter_list|(
name|buf
parameter_list|,
name|chars
parameter_list|,
name|f
parameter_list|)
name|char
specifier|const
modifier|*
name|buf
decl_stmt|;
name|size_t
name|chars
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
comment|/* Posix 1003.1-1990 ssize_t hack */
while|while
condition|(
name|SSIZE_MAX
operator|<
name|chars
condition|)
block|{
if|if
condition|(
name|Fwrite
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|SSIZE_MAX
argument_list|,
name|f
argument_list|)
operator|!=
name|SSIZE_MAX
condition|)
name|Oerror
argument_list|()
expr_stmt|;
name|buf
operator|+=
name|SSIZE_MAX
expr_stmt|;
name|chars
operator|-=
name|SSIZE_MAX
expr_stmt|;
block|}
if|if
condition|(
name|Fwrite
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|chars
argument_list|,
name|f
argument_list|)
operator|!=
name|chars
condition|)
name|Oerror
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* dup a file descriptor; the result must not be stdin, stdout, or stderr.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dupSafer
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|dupSafer
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|F_DUPFD
return|return
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_DUPFD
argument_list|,
name|STDERR_FILENO
operator|+
literal|1
argument_list|)
return|;
else|#
directive|else
name|int
name|e
decl_stmt|,
name|f
decl_stmt|,
name|i
decl_stmt|,
name|used
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|STDIN_FILENO
operator|<=
operator|(
name|f
operator|=
name|dup
argument_list|(
name|fd
argument_list|)
operator|)
operator|&&
name|f
operator|<=
name|STDERR_FILENO
condition|)
name|used
operator||=
literal|1
operator|<<
name|f
expr_stmt|;
name|e
operator|=
name|errno
expr_stmt|;
for|for
control|(
name|i
operator|=
name|STDIN_FILENO
init|;
name|i
operator|<=
name|STDERR_FILENO
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|used
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|VOID
name|close
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
return|return
name|f
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Renumber a file descriptor so that it's not stdin, stdout, or stderr.  */
end_comment

begin_function
name|int
name|fdSafer
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
if|if
condition|(
name|STDIN_FILENO
operator|<=
name|fd
operator|&&
name|fd
operator|<=
name|STDERR_FILENO
condition|)
block|{
name|int
name|f
init|=
name|dupSafer
argument_list|(
name|fd
argument_list|)
decl_stmt|;
name|int
name|e
init|=
name|errno
decl_stmt|;
name|VOID
name|close
argument_list|(
name|fd
argument_list|)
decl_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
name|fd
operator|=
name|f
expr_stmt|;
block|}
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/* Like fopen, except the result is never stdin, stdout, or stderr.  */
end_comment

begin_function
name|FILE
modifier|*
name|fopenSafer
parameter_list|(
name|filename
parameter_list|,
name|type
parameter_list|)
name|char
specifier|const
modifier|*
name|filename
decl_stmt|;
name|char
specifier|const
modifier|*
name|type
decl_stmt|;
block|{
name|FILE
modifier|*
name|stream
init|=
name|fopen
argument_list|(
name|filename
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|stream
condition|)
block|{
name|int
name|fd
init|=
name|fileno
argument_list|(
name|stream
argument_list|)
decl_stmt|;
if|if
condition|(
name|STDIN_FILENO
operator|<=
name|fd
operator|&&
name|fd
operator|<=
name|STDERR_FILENO
condition|)
block|{
name|int
name|f
init|=
name|dupSafer
argument_list|(
name|fd
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|<
literal|0
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|VOID
name|fclose
argument_list|(
name|stream
argument_list|)
decl_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|stream
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|VOID
name|close
argument_list|(
name|f
argument_list|)
decl_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
return|return
literal|0
return|;
block|}
name|stream
operator|=
name|fdopen
argument_list|(
name|f
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|stream
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|F_DUPFD
end_ifdef

begin_undef
undef|#
directive|undef
name|dup
end_undef

begin_define
define|#
directive|define
name|dup
parameter_list|(
name|fd
parameter_list|)
value|fcntl(fd, F_DUPFD, 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|has_fork
operator|||
name|has_spawn
end_if

begin_decl_stmt
specifier|static
name|int
name|movefd
name|P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|movefd
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|)
name|int
name|old
decl_stmt|,
name|new
decl_stmt|;
block|{
if|if
condition|(
name|old
operator|<
literal|0
operator|||
name|old
operator|==
name|new
condition|)
return|return
name|old
return|;
ifdef|#
directive|ifdef
name|F_DUPFD
name|new
operator|=
name|fcntl
argument_list|(
name|old
argument_list|,
name|F_DUPFD
argument_list|,
name|new
argument_list|)
expr_stmt|;
else|#
directive|else
name|new
operator|=
name|dup2
argument_list|(
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|close
argument_list|(
name|old
argument_list|)
operator|==
literal|0
condition|?
name|new
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|fdreopen
name|P
argument_list|(
operator|(
name|int
operator|,
name|char
specifier|const
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|fdreopen
parameter_list|(
name|fd
parameter_list|,
name|file
parameter_list|,
name|flags
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
specifier|const
modifier|*
name|file
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|newfd
decl_stmt|;
name|VOID
name|close
argument_list|(
name|fd
argument_list|)
decl_stmt|;
name|newfd
operator|=
if|#
directive|if
operator|!
name|open_can_creat
name|flags
operator|&
name|O_CREAT
condition|?
name|creat
argument_list|(
name|file
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|)
else|:
endif|#
directive|endif
name|open
argument_list|(
name|file
argument_list|,
name|flags
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|)
expr_stmt|;
return|return
name|movefd
argument_list|(
name|newfd
argument_list|,
name|fd
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|has_spawn
end_if

begin_decl_stmt
specifier|static
name|void
name|redirect
name|P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|redirect
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|)
name|int
name|old
decl_stmt|,
name|new
decl_stmt|;
comment|/* * Move file descriptor OLD to NEW. * If OLD is -1, do nothing. * If OLD is -2, just close NEW. */
block|{
if|if
condition|(
operator|(
name|old
operator|!=
operator|-
literal|1
operator|&&
name|close
argument_list|(
name|new
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
literal|0
operator|<=
name|old
operator|&&
name|movefd
argument_list|(
name|old
argument_list|,
name|new
argument_list|)
operator|<
literal|0
operator|)
condition|)
name|efaterror
argument_list|(
literal|"spawn I/O redirection"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !has_fork&& !has_spawn */
end_comment

begin_decl_stmt
specifier|static
name|void
name|bufargcat
name|P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|,
name|int
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|bufargcat
parameter_list|(
name|b
parameter_list|,
name|c
parameter_list|,
name|s
parameter_list|)
specifier|register
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
comment|/* Append to B a copy of C, plus a quoted copy of S.  */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|t
decl_stmt|;
name|size_t
name|bl
decl_stmt|,
name|sl
decl_stmt|;
for|for
control|(
name|t
operator|=
name|s
operator|,
name|sl
operator|=
literal|0
init|;
operator|*
name|t
condition|;
control|)
name|sl
operator|+=
literal|3
operator|*
operator|(
operator|*
name|t
operator|++
operator|==
literal|'\''
operator|)
operator|+
literal|1
expr_stmt|;
name|bl
operator|=
name|strlen
argument_list|(
name|b
operator|->
name|string
argument_list|)
expr_stmt|;
name|bufrealloc
argument_list|(
name|b
argument_list|,
name|bl
operator|+
name|sl
operator|+
literal|4
argument_list|)
expr_stmt|;
name|p
operator|=
name|b
operator|->
name|string
operator|+
name|bl
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\''
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\''
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\''
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\''
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\''
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|has_spawn
operator|&&
name|has_fork
end_if

begin_comment
comment|/* * Output the string S to stderr, without touching any I/O buffers. * This is useful if you are a child process, whose buffers are usually wrong. * Exit immediately if the write does not completely succeed. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|write_stderr
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|write_stderr
parameter_list|(
name|s
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
block|{
name|size_t
name|slen
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|s
argument_list|,
name|slen
argument_list|)
operator|!=
name|slen
condition|)
name|_exit
argument_list|(
name|EXIT_TROUBLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* * Run a command. * infd, if not -1, is the input file descriptor. * outname, if nonzero, is the name of the output file. * args[1..] form the command to be run; args[0] might be modified. */
end_comment

begin_function
name|int
name|runv
parameter_list|(
name|infd
parameter_list|,
name|outname
parameter_list|,
name|args
parameter_list|)
name|int
name|infd
decl_stmt|;
name|char
specifier|const
modifier|*
name|outname
decl_stmt|,
decl|*
modifier|*
name|args
decl_stmt|;
end_function

begin_block
block|{
name|int
name|wstatus
decl_stmt|;
if|#
directive|if
name|bad_wait_if_SIGCHLD_ignored
specifier|static
name|int
name|fixed_SIGCHLD
decl_stmt|;
if|if
condition|(
operator|!
name|fixed_SIGCHLD
condition|)
block|{
name|fixed_SIGCHLD
operator|=
name|true
expr_stmt|;
ifndef|#
directive|ifndef
name|SIGCHLD
define|#
directive|define
name|SIGCHLD
value|SIGCLD
endif|#
directive|endif
name|VOID
name|signal
parameter_list|(
name|SIGCHLD
parameter_list|,
name|SIG_DFL
parameter_list|)
function_decl|;
block|}
endif|#
directive|endif
name|oflush
argument_list|()
expr_stmt|;
name|eflush
argument_list|()
expr_stmt|;
block|{
if|#
directive|if
name|has_spawn
name|int
name|in
decl_stmt|,
name|out
decl_stmt|;
name|char
specifier|const
modifier|*
name|file
decl_stmt|;
name|in
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|infd
operator|!=
operator|-
literal|1
operator|&&
name|infd
operator|!=
name|STDIN_FILENO
condition|)
block|{
if|if
condition|(
operator|(
name|in
operator|=
name|dup
argument_list|(
name|STDIN_FILENO
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EBADF
condition|)
name|efaterror
argument_list|(
literal|"spawn input setup"
argument_list|)
expr_stmt|;
name|in
operator|=
operator|-
literal|2
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|F_DUPFD
if|if
condition|(
name|close
argument_list|(
name|STDIN_FILENO
argument_list|)
operator|!=
literal|0
condition|)
name|efaterror
argument_list|(
literal|"spawn input close"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
ifdef|#
directive|ifdef
name|F_DUPFD
name|fcntl
argument_list|(
name|infd
argument_list|,
name|F_DUPFD
argument_list|,
name|STDIN_FILENO
argument_list|)
operator|!=
name|STDIN_FILENO
else|#
directive|else
name|dup2
argument_list|(
name|infd
argument_list|,
name|STDIN_FILENO
argument_list|)
operator|!=
name|STDIN_FILENO
endif|#
directive|endif
condition|)
name|efaterror
argument_list|(
literal|"spawn input redirection"
argument_list|)
expr_stmt|;
block|}
name|out
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|outname
condition|)
block|{
if|if
condition|(
operator|(
name|out
operator|=
name|dup
argument_list|(
name|STDOUT_FILENO
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EBADF
condition|)
name|efaterror
argument_list|(
literal|"spawn output setup"
argument_list|)
expr_stmt|;
name|out
operator|=
operator|-
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|fdreopen
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|outname
argument_list|,
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_WRONLY
argument_list|)
operator|<
literal|0
condition|)
name|efaterror
argument_list|(
name|outname
argument_list|)
expr_stmt|;
block|}
name|wstatus
operator|=
name|spawn_RCS
argument_list|(
literal|0
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|args
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RCS_SHELL
if|if
condition|(
name|wstatus
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ENOEXEC
condition|)
block|{
name|args
index|[
literal|0
index|]
operator|=
name|RCS_SHELL
expr_stmt|;
name|wstatus
operator|=
name|spawnv
argument_list|(
literal|0
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|args
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|redirect
argument_list|(
name|in
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|redirect
argument_list|(
name|out
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|has_fork
name|pid_t
name|pid
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|pid
operator|=
name|vfork
argument_list|()
operator|)
condition|)
block|{
name|char
specifier|const
modifier|*
name|notfound
decl_stmt|;
if|if
condition|(
name|infd
operator|!=
operator|-
literal|1
operator|&&
name|infd
operator|!=
name|STDIN_FILENO
operator|&&
operator|(
ifdef|#
directive|ifdef
name|F_DUPFD
operator|(
name|VOID
name|close
argument_list|(
name|STDIN_FILENO
argument_list|)
operator|,
name|fcntl
argument_list|(
name|infd
argument_list|,
name|F_DUPFD
argument_list|,
name|STDIN_FILENO
argument_list|)
operator|!=
name|STDIN_FILENO
operator|)
else|#
directive|else
name|dup2
argument_list|(
name|infd
argument_list|,
name|STDIN_FILENO
argument_list|)
operator|!=
name|STDIN_FILENO
endif|#
directive|endif
operator|)
condition|)
block|{
comment|/* Avoid perror since it may misuse buffers.  */
name|write_stderr
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|write_stderr
argument_list|(
literal|": I/O redirection failed\n"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EXIT_TROUBLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outname
condition|)
if|if
condition|(
name|fdreopen
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|outname
argument_list|,
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_WRONLY
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Avoid perror since it may misuse buffers.  */
name|write_stderr
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|write_stderr
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
name|write_stderr
argument_list|(
name|outname
argument_list|)
expr_stmt|;
name|write_stderr
argument_list|(
literal|": cannot create\n"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EXIT_TROUBLE
argument_list|)
expr_stmt|;
block|}
name|VOID
name|exec_RCS
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|args
operator|+
literal|1
operator|)
argument_list|)
decl_stmt|;
name|notfound
operator|=
name|args
index|[
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|RCS_SHELL
if|if
condition|(
name|errno
operator|==
name|ENOEXEC
condition|)
block|{
name|args
index|[
literal|0
index|]
operator|=
name|notfound
operator|=
name|RCS_SHELL
expr_stmt|;
name|VOID
name|execv
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|args
argument_list|)
decl_stmt|;
block|}
endif|#
directive|endif
comment|/* Avoid perror since it may misuse buffers.  */
name|write_stderr
argument_list|(
name|notfound
argument_list|)
expr_stmt|;
name|write_stderr
argument_list|(
literal|": not found\n"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EXIT_TROUBLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|efaterror
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
if|#
directive|if
name|has_waitpid
if|if
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|wstatus
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|efaterror
argument_list|(
literal|"waitpid"
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|pid_t
name|w
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|wait
argument_list|(
operator|&
name|wstatus
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|efaterror
argument_list|(
literal|"wait"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|w
operator|!=
name|pid
condition|)
do|;
block|}
endif|#
directive|endif
else|#
directive|else
specifier|static
name|struct
name|buf
name|b
decl_stmt|;
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
comment|/* Use system().  On many hosts system() discards signals.  Yuck!  */
name|p
operator|=
name|args
operator|+
literal|1
expr_stmt|;
name|bufscpy
argument_list|(
operator|&
name|b
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|p
condition|)
name|bufargcat
argument_list|(
operator|&
name|b
argument_list|,
literal|' '
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|infd
operator|!=
operator|-
literal|1
operator|&&
name|infd
operator|!=
name|STDIN_FILENO
condition|)
block|{
name|char
name|redirection
index|[
literal|32
index|]
decl_stmt|;
name|VOID
name|sprintf
argument_list|(
name|redirection
argument_list|,
literal|"<&%d"
argument_list|,
name|infd
argument_list|)
decl_stmt|;
name|bufscat
argument_list|(
operator|&
name|b
argument_list|,
name|redirection
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outname
condition|)
name|bufargcat
argument_list|(
operator|&
name|b
argument_list|,
literal|'>'
argument_list|,
name|outname
argument_list|)
expr_stmt|;
name|wstatus
operator|=
name|system
argument_list|(
name|b
operator|.
name|string
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|wstatus
argument_list|)
condition|)
block|{
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|wstatus
argument_list|)
condition|)
block|{
name|psignal
argument_list|(
name|WTERMSIG
argument_list|(
name|wstatus
argument_list|)
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fatcleanup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|faterror
argument_list|(
literal|"%s failed for unknown reason"
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|WEXITSTATUS
argument_list|(
name|wstatus
argument_list|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|CARGSMAX
value|20
end_define

begin_comment
comment|/* * Run a command. * infd, if not -1, is the input file descriptor. * outname, if nonzero, is the name of the output file. * The remaining arguments specify the command and its arguments. */
end_comment

begin_function
name|int
if|#
directive|if
name|has_prototypes
name|run
parameter_list|(
name|int
name|infd
parameter_list|,
name|char
specifier|const
modifier|*
name|outname
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/*VARARGS2*/
function|run
parameter_list|(
name|infd
parameter_list|,
name|outname
parameter_list|,
name|va_alist
parameter_list|)
name|int
name|infd
decl_stmt|;
name|char
specifier|const
modifier|*
name|outname
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|ap
decl_stmt|;
name|char
specifier|const
modifier|*
name|rgargs
index|[
name|CARGSMAX
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|vararg_start
argument_list|(
name|ap
argument_list|,
name|outname
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
operator|(
name|rgargs
index|[
name|i
operator|++
index|]
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
specifier|const
operator|*
argument_list|)
operator|)
condition|;
control|)
if|if
condition|(
name|CARGSMAX
operator|<=
name|i
condition|)
name|faterror
argument_list|(
literal|"too many command arguments"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|runv
argument_list|(
name|infd
argument_list|,
name|outname
argument_list|,
name|rgargs
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|RCSversion
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|setRCSversion
parameter_list|(
name|str
parameter_list|)
name|char
specifier|const
modifier|*
name|str
decl_stmt|;
block|{
specifier|static
name|int
name|oldversion
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|s
init|=
name|str
operator|+
literal|2
decl_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
block|{
name|int
name|v
init|=
name|VERSION_DEFAULT
decl_stmt|;
if|if
condition|(
name|oldversion
condition|)
name|redefined
argument_list|(
literal|'V'
argument_list|)
expr_stmt|;
name|oldversion
operator|=
name|true
expr_stmt|;
name|v
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|v
operator|=
literal|10
operator|*
name|v
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
name|s
condition|)
name|error
argument_list|(
literal|"%s isn't a number"
argument_list|,
name|str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|<
name|VERSION_min
operator|||
name|VERSION_max
operator|<
name|v
condition|)
name|error
argument_list|(
literal|"%s out of range %d..%d"
argument_list|,
name|str
argument_list|,
name|VERSION_min
argument_list|,
name|VERSION_max
argument_list|)
expr_stmt|;
name|RCSversion
operator|=
name|VERSION
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"RCS version %s\n"
argument_list|,
name|RCS_version_string
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|getRCSINIT
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|newargv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
decl|*
modifier|*
modifier|*
name|newargv
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|char
specifier|const
modifier|*
name|ev
decl_stmt|;
name|size_t
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|ev
operator|=
name|cgetenv
argument_list|(
literal|"RCSLOCALID"
argument_list|)
operator|)
condition|)
name|setRCSLocalId
argument_list|(
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ev
operator|=
name|cgetenv
argument_list|(
literal|"RCSINCEXC"
argument_list|)
operator|)
condition|)
name|setIncExc
argument_list|(
name|ev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|q
operator|=
name|cgetenv
argument_list|(
literal|"RCSINIT"
argument_list|)
operator|)
condition|)
operator|*
name|newargv
operator|=
name|argv
expr_stmt|;
else|else
block|{
name|n
operator|=
name|argc
operator|+
literal|2
expr_stmt|;
comment|/* 		 * Count spaces in RCSINIT to allocate a new arg vector. 		 * This is an upper bound, but it's OK even if too large. 		 */
for|for
control|(
name|p
operator|=
name|q
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
default|default:
continue|continue;
case|case
literal|' '
case|:
case|case
literal|'\b'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\v'
case|:
name|n
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\0'
case|:
break|break;
block|}
break|break;
block|}
operator|*
name|newargv
operator|=
name|pp
operator|=
name|tnalloc
argument_list|(
name|char
operator|*
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
comment|/* copy program name */
for|for
control|(
name|p
operator|=
name|q
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|q
condition|)
block|{
case|case
literal|'\0'
case|:
goto|goto
name|copyrest
goto|;
case|case
literal|' '
case|:
case|case
literal|'\b'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\v'
case|:
name|q
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
operator|*
name|pp
operator|++
operator|=
name|p
expr_stmt|;
operator|++
name|argc
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
operator|)
condition|)
block|{
case|case
literal|'\0'
case|:
goto|goto
name|copyrest
goto|;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|!
operator|*
name|q
condition|)
goto|goto
name|copyrest
goto|;
name|p
index|[
operator|-
literal|1
index|]
operator|=
operator|*
name|q
operator|++
expr_stmt|;
continue|continue;
default|default:
continue|continue;
case|case
literal|' '
case|:
case|case
literal|'\b'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\v'
case|:
break|break;
block|}
break|break;
block|}
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|copyrest
label|:
while|while
condition|(
operator|(
operator|*
name|pp
operator|++
operator|=
operator|*
name|argv
operator|++
operator|)
condition|)
continue|continue;
block|}
return|return
name|argc
return|;
block|}
end_block

begin_define
define|#
directive|define
name|cacheid
parameter_list|(
name|E
parameter_list|)
value|static uid_t i; static int s; if (!s){ s=1; i=(E); } return i
end_define

begin_if
if|#
directive|if
name|has_getuid
end_if

begin_function
name|uid_t
name|ruid
parameter_list|()
block|{
name|cacheid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|has_setuid
end_if

begin_function
name|uid_t
name|euid
parameter_list|()
block|{
name|cacheid
argument_list|(
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|has_setuid
end_if

begin_comment
comment|/*  * Setuid execution really works only with Posix 1003.1a Draft 5 seteuid(),  * because it lets us switch back and forth between arbitrary users.  * If seteuid() doesn't work, we fall back on setuid(),  * which works if saved setuid is supported,  * unless the real or effective user is root.  * This area is such a mess that we always check switches at runtime.  */
end_comment

begin_function
specifier|static
name|void
if|#
directive|if
name|has_prototypes
name|set_uid_to
parameter_list|(
name|uid_t
name|u
parameter_list|)
else|#
directive|else
function|set_uid_to
parameter_list|(
name|u
parameter_list|)
name|uid_t
name|u
decl_stmt|;
endif|#
directive|endif
comment|/* Become user u.  */
block|{
specifier|static
name|int
name|looping
decl_stmt|;
if|if
condition|(
name|euid
argument_list|()
operator|==
name|ruid
argument_list|()
condition|)
return|return;
if|#
directive|if
operator|(
name|has_fork
operator|||
name|has_spawn
operator|)
operator|&&
name|DIFF_ABSOLUTE
if|#
directive|if
name|has_setreuid
if|if
condition|(
name|setreuid
argument_list|(
name|u
operator|==
name|euid
argument_list|()
condition|?
name|ruid
argument_list|()
else|:
name|euid
argument_list|()
argument_list|,
name|u
argument_list|)
operator|!=
literal|0
condition|)
name|efaterror
argument_list|(
literal|"setuid"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|seteuid
argument_list|(
name|u
argument_list|)
operator|!=
literal|0
condition|)
name|efaterror
argument_list|(
literal|"setuid"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|geteuid
argument_list|()
operator|!=
name|u
condition|)
block|{
if|if
condition|(
name|looping
condition|)
return|return;
name|looping
operator|=
name|true
expr_stmt|;
name|faterror
argument_list|(
literal|"root setuid not supported"
operator|+
operator|(
name|u
condition|?
literal|5
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|stick_with_euid
decl_stmt|;
end_decl_stmt

begin_function
name|void
comment|/* Ignore all calls to seteid() and setrid().  */
name|nosetid
parameter_list|()
block|{
name|stick_with_euid
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
name|void
name|seteid
parameter_list|()
comment|/* Become effective user.  */
block|{
if|if
condition|(
operator|!
name|stick_with_euid
condition|)
name|set_uid_to
argument_list|(
name|euid
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setrid
parameter_list|()
comment|/* Become real user.  */
block|{
if|if
condition|(
operator|!
name|stick_with_euid
condition|)
name|set_uid_to
argument_list|(
name|ruid
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|time_t
name|now
parameter_list|()
block|{
specifier|static
name|time_t
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|&&
name|time
argument_list|(
operator|&
name|t
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|efaterror
argument_list|(
literal|"time"
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

end_unit

