begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* RCS filename and pathname handling */
end_comment

begin_comment
comment|/****************************************************************************  *                     creation and deletion of /tmp temporaries  *		       pairing of RCS pathnames and working pathnames.  *                     Testprogram: define PAIRTEST  ****************************************************************************  */
end_comment

begin_comment
comment|/* Copyright 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991, 1992, 1993, 1994, 1995 Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/*  * Revision 5.16  1995/06/16 06:19:24  eggert  * Update FSF address.  *  * Revision 5.15  1995/06/01 16:23:43  eggert  * (basefilename): Renamed from basename to avoid collisions.  * (dirlen): Remove (for similar reasons).  * (rcsreadopen): Open with FOPEN_RB.  * (SLASHSLASH_is_SLASH): Default is 0.  * (getcwd): Work around bad_wait_if_SIGCHLD_ignored bug.  *  * Revision 5.14  1994/03/17 14:05:48  eggert  * Strip trailing SLASHes from TMPDIR; some systems need this.  Remove lint.  *  * Revision 5.13  1993/11/03 17:42:27  eggert  * Determine whether a file name is too long indirectly,  * by examining inode numbers, instead of trying to use operating system  * primitives like pathconf, which are not trustworthy in general.  * File names may now hold white space or $.  * Do not flatten ../X in pathnames; that may yield wrong answer for symlinks.  * Add getabsname hook.  Improve quality of diagnostics.  *  * Revision 5.12  1992/07/28  16:12:44  eggert  * Add .sty.  .pl now implies Perl, not Prolog.  Fix fdlock initialization bug.  * Check that $PWD is really ".".  Be consistent about pathnames vs filenames.  *  * Revision 5.11  1992/02/17  23:02:25  eggert  * `a/RCS/b/c' is now an RCS file with an empty extension, not just `a/b/RCS/c'.  *  * Revision 5.10  1992/01/24  18:44:19  eggert  * Fix bug: Expand and Ignored weren't reinitialized.  * Avoid `char const c=ch;' compiler bug.  * Add support for bad_creat0.  *  * Revision 5.9  1992/01/06  02:42:34  eggert  * Shorten long (>31 chars) name.  * while (E) ; -> while (E) continue;  *  * Revision 5.8  1991/09/24  00:28:40  eggert  * Don't export bindex().  *  * Revision 5.7  1991/08/19  03:13:55  eggert  * Fix messages when rcswriteopen fails.  * Look in $TMP and $TEMP if $TMPDIR isn't set.  Tune.  *  * Revision 5.6  1991/04/21  11:58:23  eggert  * Fix errno bugs.  Add -x, RCSINIT, MS-DOS support.  *  * Revision 5.5  1991/02/26  17:48:38  eggert  * Fix setuid bug.  Support new link behavior.  * Define more portable getcwd().  *  * Revision 5.4  1990/11/01  05:03:43  eggert  * Permit arbitrary data in comment leaders.  *  * Revision 5.3  1990/09/14  22:56:16  hammer  * added more filename extensions and their comment leaders  *  * Revision 5.2  1990/09/04  08:02:23  eggert  * Fix typo when !RCSSEP.  *  * Revision 5.1  1990/08/29  07:13:59  eggert  * Work around buggy compilers with defective argument promotion.  *  * Revision 5.0  1990/08/22  08:12:50  eggert  * Ignore signals when manipulating the semaphore file.  * Modernize list of filename extensions.  * Permit paths of arbitrary length.  Beware filenames beginning with "-".  * Remove compile-time limits; use malloc instead.  * Permit dates past 1999/12/31.  Make lock and temp files faster and safer.  * Ansify and Posixate.  * Don't use access().  Fix test for non-regular files.  Tune.  *  * Revision 4.8  89/05/01  15:09:41  narten  * changed getwd to not stat empty directories.  *  * Revision 4.7  88/08/09  19:12:53  eggert  * Fix troff macro comment leader bug; add Prolog; allow cc -R; remove lint.  *  * Revision 4.6  87/12/18  11:40:23  narten  * additional file types added from 4.3 BSD version, and SPARC assembler  * comment character added. Also, more lint cleanups. (Guy Harris)  *  * Revision 4.5  87/10/18  10:34:16  narten  * Updating version numbers. Changes relative to 1.1 actually relative  * to verion 4.3  *  * Revision 1.3  87/03/27  14:22:21  jenkins  * Port to suns  *  * Revision 1.2  85/06/26  07:34:28  svb  * Comment leader '% ' for '*.tex' files added.  *  * Revision 4.3  83/12/15  12:26:48  wft  * Added check for KDELIM in filenames to pairfilenames().  *  * Revision 4.2  83/12/02  22:47:45  wft  * Added csh, red, and sl filename suffixes.  *  * Revision 4.1  83/05/11  16:23:39  wft  * Added initialization of Dbranch to InitAdmin(). Canged pairfilenames():  * 1. added copying of path from workfile to RCS file, if RCS file is omitted;  * 2. added getting the file status of RCS and working files;  * 3. added ignoring of directories.  *  * Revision 3.7  83/05/11  15:01:58  wft  * Added comtable[] which pairs filename suffixes with comment leaders;  * updated InitAdmin() accordingly.  *  * Revision 3.6  83/04/05  14:47:36  wft  * fixed Suffix in InitAdmin().  *  * Revision 3.5  83/01/17  18:01:04  wft  * Added getwd() and rename(); these can be removed by defining  * V4_2BSD, since they are not needed in 4.2 bsd.  * Changed sys/param.h to sys/types.h.  *  * Revision 3.4  82/12/08  21:55:20  wft  * removed unused variable.  *  * Revision 3.3  82/11/28  20:31:37  wft  * Changed mktempfile() to store the generated filenames.  * Changed getfullRCSname() to store the file and pathname, and to  * delete leading "../" and "./".  *  * Revision 3.2  82/11/12  14:29:40  wft  * changed pairfilenames() to handle file.sfx,v; also deleted checkpathnosfx(),  * checksuffix(), checkfullpath(). Semaphore name generation updated.  * mktempfile() now checks for nil path; freefilename initialized properly.  * Added Suffix .h to InitAdmin. Added testprogram PAIRTEST.  * Moved rmsema, trysema, trydiraccess, getfullRCSname from rcsutil.c to here.  *  * Revision 3.1  82/10/18  14:51:28  wft  * InitAdmin() now initializes StrictLocks=STRICT_LOCKING (def. in rcsbase.h).  * renamed checkpath() to checkfullpath().  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_macro
name|libId
argument_list|(
argument|fnmsId
argument_list|,
literal|"$Id: rcsfnms.c,v 1.6 1997/02/22 15:47:36 peter Exp $"
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|bindex
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fin2open
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|size_t
operator|,
name|char
specifier|const
operator|*
operator|,
name|size_t
operator|,
name|char
specifier|const
operator|*
operator|,
name|size_t
operator|,
name|RILE
operator|*
operator|(
operator|*
operator|)
name|P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|,
expr|struct
name|stat
operator|*
operator|,
name|int
operator|)
argument_list|)
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|finopen
name|P
argument_list|(
operator|(
name|RILE
operator|*
operator|(
operator|*
operator|)
name|P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|,
expr|struct
name|stat
operator|*
operator|,
name|int
operator|)
argument_list|)
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|suffix_matches
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|dir_useful_len
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|suffixlen
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|InitAdmin
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
specifier|const
modifier|*
name|RCSname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|workname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fdlock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|workstdout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|stat
name|RCSstat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
specifier|const
modifier|*
name|suffixes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|rcsdir
index|[]
init|=
literal|"RCS"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|rcslen
value|(sizeof(rcsdir)-1)
end_define

begin_decl_stmt
specifier|static
name|struct
name|buf
name|RCSbuf
decl_stmt|,
name|RCSb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|RCSerrno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temp names to be unlinked when done, if they are not 0.  */
end_comment

begin_define
define|#
directive|define
name|TEMPNAMES
value|5
end_define

begin_comment
comment|/* must be at least DIRTEMPNAMES (see rcsedit.c) */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
specifier|volatile
name|tpnames
index|[
name|TEMPNAMES
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|compair
block|{
name|char
specifier|const
modifier|*
name|suffix
decl_stmt|,
modifier|*
name|comlead
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* * This table is present only for backwards compatibility. * Normally we ignore this table, and use the prefix of the `$Log' line instead. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|compair
specifier|const
name|comtable
index|[]
init|=
block|{
block|{
literal|"a"
block|,
literal|"-- "
block|}
block|,
comment|/* Ada */
block|{
literal|"ada"
block|,
literal|"-- "
block|}
block|,
block|{
literal|"adb"
block|,
literal|"-- "
block|}
block|,
block|{
literal|"ads"
block|,
literal|"-- "
block|}
block|,
block|{
literal|"asm"
block|,
literal|";; "
block|}
block|,
comment|/* assembler (MS-DOS) */
block|{
literal|"bat"
block|,
literal|":: "
block|}
block|,
comment|/* batch (MS-DOS) */
block|{
literal|"body"
block|,
literal|"-- "
block|}
block|,
comment|/* Ada */
block|{
literal|"c"
block|,
literal|" * "
block|}
block|,
comment|/* C */
block|{
literal|"c++"
block|,
literal|"// "
block|}
block|,
comment|/* C++ in all its infinite guises */
block|{
literal|"cc"
block|,
literal|"// "
block|}
block|,
block|{
literal|"cpp"
block|,
literal|"// "
block|}
block|,
block|{
literal|"cxx"
block|,
literal|"// "
block|}
block|,
block|{
literal|"cl"
block|,
literal|";;; "
block|}
block|,
comment|/* Common Lisp */
block|{
literal|"cmd"
block|,
literal|":: "
block|}
block|,
comment|/* command (OS/2) */
block|{
literal|"cmf"
block|,
literal|"c "
block|}
block|,
comment|/* CM Fortran */
block|{
literal|"cs"
block|,
literal|" * "
block|}
block|,
comment|/* C* */
block|{
literal|"el"
block|,
literal|"; "
block|}
block|,
comment|/* Emacs Lisp */
block|{
literal|"f"
block|,
literal|"c "
block|}
block|,
comment|/* Fortran */
block|{
literal|"for"
block|,
literal|"c "
block|}
block|,
block|{
literal|"h"
block|,
literal|" * "
block|}
block|,
comment|/* C-header */
block|{
literal|"hpp"
block|,
literal|"// "
block|}
block|,
comment|/* C++ header */
block|{
literal|"hxx"
block|,
literal|"// "
block|}
block|,
block|{
literal|"l"
block|,
literal|" * "
block|}
block|,
comment|/* lex (NOTE: franzlisp disagrees) */
block|{
literal|"lisp"
block|,
literal|";;; "
block|}
block|,
comment|/* Lucid Lisp */
block|{
literal|"lsp"
block|,
literal|";; "
block|}
block|,
comment|/* Microsoft Lisp */
block|{
literal|"m"
block|,
literal|"// "
block|}
block|,
comment|/* Objective C */
block|{
literal|"mac"
block|,
literal|";; "
block|}
block|,
comment|/* macro (DEC-10, MS-DOS, PDP-11, VMS, etc) */
block|{
literal|"me"
block|,
literal|".\\\" "
block|}
block|,
comment|/* troff -me */
block|{
literal|"ml"
block|,
literal|"; "
block|}
block|,
comment|/* mocklisp */
block|{
literal|"mm"
block|,
literal|".\\\" "
block|}
block|,
comment|/* troff -mm */
block|{
literal|"ms"
block|,
literal|".\\\" "
block|}
block|,
comment|/* troff -ms */
block|{
literal|"p"
block|,
literal|" * "
block|}
block|,
comment|/* Pascal */
block|{
literal|"pas"
block|,
literal|" * "
block|}
block|,
block|{
literal|"ps"
block|,
literal|"% "
block|}
block|,
comment|/* PostScript */
block|{
literal|"spec"
block|,
literal|"-- "
block|}
block|,
comment|/* Ada */
block|{
literal|"sty"
block|,
literal|"% "
block|}
block|,
comment|/* LaTeX style */
block|{
literal|"tex"
block|,
literal|"% "
block|}
block|,
comment|/* TeX */
block|{
literal|"y"
block|,
literal|" * "
block|}
block|,
comment|/* yacc */
block|{
literal|0
block|,
literal|"# "
block|}
comment|/* default for unknown suffix; must be last */
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|has_mktemp
end_if

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|tmp
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|tmp
parameter_list|()
comment|/* Yield the name of the tmp directory.  */
block|{
specifier|static
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|&&
operator|!
operator|(
name|s
operator|=
name|cgetenv
argument_list|(
literal|"TMPDIR"
argument_list|)
operator|)
comment|/* Unix tradition */
operator|&&
operator|!
operator|(
name|s
operator|=
name|cgetenv
argument_list|(
literal|"TMP"
argument_list|)
operator|)
comment|/* DOS tradition */
operator|&&
operator|!
operator|(
name|s
operator|=
name|cgetenv
argument_list|(
literal|"TEMP"
argument_list|)
operator|)
comment|/* another DOS tradition */
condition|)
name|s
operator|=
name|TMPDIR
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|char
specifier|const
modifier|*
name|maketemp
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
comment|/* Create a unique pathname using n and the process id and store it  * into the nth slot in tpnames.  * Because of storage in tpnames, tempunlink() can unlink the file later.  * Return a pointer to the pathname created.  */
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
specifier|const
modifier|*
name|t
init|=
name|tpnames
index|[
name|n
index|]
decl_stmt|;
if|if
condition|(
name|t
condition|)
return|return
name|t
return|;
name|catchints
argument_list|()
expr_stmt|;
block|{
if|#
directive|if
name|has_mktemp
name|char
specifier|const
modifier|*
name|tp
init|=
name|tmp
argument_list|()
decl_stmt|;
name|size_t
name|tplen
init|=
name|dir_useful_len
argument_list|(
name|tp
argument_list|)
decl_stmt|;
name|p
operator|=
name|testalloc
argument_list|(
name|tplen
operator|+
literal|10
argument_list|)
expr_stmt|;
name|VOID
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%.*s%cT%cXXXXXX"
argument_list|,
operator|(
name|int
operator|)
name|tplen
argument_list|,
name|tp
argument_list|,
name|SLASH
argument_list|,
literal|'0'
operator|+
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mktemp
argument_list|(
name|p
argument_list|)
operator|||
operator|!
operator|*
name|p
condition|)
name|faterror
argument_list|(
literal|"can't make temporary pathname `%.*s%cT%cXXXXXX'"
argument_list|,
operator|(
name|int
operator|)
name|tplen
argument_list|,
name|tp
argument_list|,
name|SLASH
argument_list|,
literal|'0'
operator|+
name|n
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|static
name|char
name|tpnamebuf
index|[
name|TEMPNAMES
index|]
index|[
name|L_tmpnam
index|]
decl_stmt|;
name|p
operator|=
name|tpnamebuf
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|tmpnam
argument_list|(
name|p
argument_list|)
operator|||
operator|!
operator|*
name|p
condition|)
ifdef|#
directive|ifdef
name|P_tmpdir
name|faterror
argument_list|(
literal|"can't make temporary pathname `%s...'"
argument_list|,
name|P_tmpdir
argument_list|)
expr_stmt|;
else|#
directive|else
name|faterror
argument_list|(
literal|"can't make temporary pathname"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
name|tpnames
index|[
name|n
index|]
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|void
name|tempunlink
parameter_list|()
comment|/* Clean up maketemp() files.  May be invoked by signal handler.  */
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TEMPNAMES
init|;
literal|0
operator|<=
operator|--
name|i
condition|;
control|)
if|if
condition|(
operator|(
name|p
operator|=
name|tpnames
index|[
name|i
index|]
operator|)
condition|)
block|{
name|VOID
name|unlink
argument_list|(
name|p
argument_list|)
decl_stmt|;
comment|/* 		 * We would tfree(p) here, 		 * but this might dump core if we're handing a signal. 		 * We're about to exit anyway, so we won't bother. 		 */
name|tpnames
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|bindex
parameter_list|(
name|sp
parameter_list|,
name|c
parameter_list|)
specifier|register
name|char
specifier|const
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
comment|/* Function: Finds the last occurrence of character c in string sp  * and returns a pointer to the character just beyond it. If the  * character doesn't occur in the string, sp is returned.  */
block|{
specifier|register
name|char
specifier|const
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|sp
expr_stmt|;
while|while
condition|(
operator|*
name|sp
condition|)
block|{
if|if
condition|(
operator|*
name|sp
operator|++
operator|==
name|c
condition|)
name|r
operator|=
name|sp
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|suffix_matches
parameter_list|(
name|suffix
parameter_list|,
name|pattern
parameter_list|)
specifier|register
name|char
specifier|const
modifier|*
name|suffix
decl_stmt|,
decl|*
name|pattern
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|pattern
condition|)
return|return
name|true
return|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|*
name|suffix
operator|++
operator|-
operator|(
name|c
operator|=
operator|*
name|pattern
operator|++
operator|)
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|!
name|c
condition|)
return|return
name|true
return|;
break|break;
case|case
literal|'A'
operator|-
literal|'a'
case|:
if|if
condition|(
name|ctab
index|[
name|c
index|]
operator|==
name|Letter
condition|)
break|break;
comment|/* fall into */
default|default:
return|return
name|false
return|;
block|}
block|}
end_block

begin_function
specifier|static
name|void
name|InitAdmin
parameter_list|()
comment|/* function: initializes an admin node */
block|{
specifier|register
name|char
specifier|const
modifier|*
name|Suffix
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|Head
operator|=
literal|0
expr_stmt|;
name|Dbranch
operator|=
literal|0
expr_stmt|;
name|AccessList
operator|=
literal|0
expr_stmt|;
name|Symbols
operator|=
literal|0
expr_stmt|;
name|Locks
operator|=
literal|0
expr_stmt|;
name|StrictLocks
operator|=
name|STRICT_LOCKING
expr_stmt|;
comment|/* guess the comment leader from the suffix*/
name|Suffix
operator|=
name|bindex
argument_list|(
name|workname
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|Suffix
operator|==
name|workname
condition|)
name|Suffix
operator|=
literal|""
expr_stmt|;
comment|/* empty suffix; will get default*/
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|suffix_matches
argument_list|(
name|Suffix
argument_list|,
name|comtable
index|[
name|i
index|]
operator|.
name|suffix
argument_list|)
condition|;
name|i
operator|++
control|)
continue|continue;
name|Comment
operator|.
name|string
operator|=
name|comtable
index|[
name|i
index|]
operator|.
name|comlead
expr_stmt|;
name|Comment
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|comtable
index|[
name|i
index|]
operator|.
name|comlead
argument_list|)
expr_stmt|;
name|Expand
operator|=
name|KEYVAL_EXPAND
expr_stmt|;
name|clear_buf
argument_list|(
operator|&
name|Ignored
argument_list|)
expr_stmt|;
name|Lexinit
argument_list|()
expr_stmt|;
comment|/* note: if !finptr, reads nothing; only initializes */
block|}
end_function

begin_function
name|void
name|bufalloc
parameter_list|(
name|b
parameter_list|,
name|size
parameter_list|)
specifier|register
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
name|size_t
name|size
decl_stmt|;
comment|/* Ensure *B is a name buffer of at least SIZE bytes.  * *B's old contents can be freed; *B's new contents are undefined.  */
block|{
if|if
condition|(
name|b
operator|->
name|size
operator|<
name|size
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|size
condition|)
name|tfree
argument_list|(
name|b
operator|->
name|string
argument_list|)
expr_stmt|;
else|else
name|b
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|malloc_type
argument_list|)
expr_stmt|;
while|while
condition|(
name|b
operator|->
name|size
operator|<
name|size
condition|)
name|b
operator|->
name|size
operator|<<=
literal|1
expr_stmt|;
name|b
operator|->
name|string
operator|=
name|tnalloc
argument_list|(
name|char
argument_list|,
name|b
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|bufrealloc
parameter_list|(
name|b
parameter_list|,
name|size
parameter_list|)
specifier|register
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
name|size_t
name|size
decl_stmt|;
comment|/* like bufalloc, except *B's old contents, if any, are preserved */
block|{
if|if
condition|(
name|b
operator|->
name|size
operator|<
name|size
condition|)
block|{
if|if
condition|(
operator|!
name|b
operator|->
name|size
condition|)
name|bufalloc
argument_list|(
name|b
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|(
name|b
operator|->
name|size
operator|<<=
literal|1
operator|)
operator|<
name|size
condition|)
continue|continue;
name|b
operator|->
name|string
operator|=
name|trealloc
argument_list|(
name|char
argument_list|,
name|b
operator|->
name|string
argument_list|,
name|b
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|bufautoend
parameter_list|(
name|b
parameter_list|)
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
comment|/* Free an auto buffer at block exit. */
block|{
if|if
condition|(
name|b
operator|->
name|size
condition|)
name|tfree
argument_list|(
name|b
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|cbuf
name|bufremember
parameter_list|(
name|b
parameter_list|,
name|s
parameter_list|)
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
name|size_t
name|s
decl_stmt|;
comment|/*  * Free the buffer B with used size S.  * Yield a cbuf with identical contents.  * The cbuf will be reclaimed when this input file is finished.  */
block|{
name|struct
name|cbuf
name|cb
decl_stmt|;
if|if
condition|(
operator|(
name|cb
operator|.
name|size
operator|=
name|s
operator|)
condition|)
name|cb
operator|.
name|string
operator|=
name|fremember
argument_list|(
name|trealloc
argument_list|(
name|char
argument_list|,
name|b
operator|->
name|string
argument_list|,
name|s
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|bufautoend
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* not really auto */
name|cb
operator|.
name|string
operator|=
literal|""
expr_stmt|;
block|}
return|return
name|cb
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|bufenlarge
parameter_list|(
name|b
parameter_list|,
name|alim
parameter_list|)
specifier|register
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
name|char
specifier|const
modifier|*
modifier|*
name|alim
decl_stmt|;
comment|/* Make *B larger.  Set *ALIM to its new limit, and yield the relocated value  * of its old limit.  */
block|{
name|size_t
name|s
init|=
name|b
operator|->
name|size
decl_stmt|;
name|bufrealloc
argument_list|(
name|b
argument_list|,
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|alim
operator|=
name|b
operator|->
name|string
operator|+
name|b
operator|->
name|size
expr_stmt|;
return|return
name|b
operator|->
name|string
operator|+
name|s
return|;
block|}
end_function

begin_function
name|void
name|bufscat
parameter_list|(
name|b
parameter_list|,
name|s
parameter_list|)
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
comment|/* Concatenate S to B's end. */
block|{
name|size_t
name|blen
init|=
name|b
operator|->
name|string
condition|?
name|strlen
argument_list|(
name|b
operator|->
name|string
argument_list|)
else|:
literal|0
decl_stmt|;
name|bufrealloc
argument_list|(
name|b
argument_list|,
name|blen
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|VOID
name|strcpy
argument_list|(
name|b
operator|->
name|string
operator|+
name|blen
argument_list|,
name|s
argument_list|)
decl_stmt|;
block|}
end_function

begin_function
name|void
name|bufscpy
parameter_list|(
name|b
parameter_list|,
name|s
parameter_list|)
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
comment|/* Copy S into B. */
block|{
name|bufalloc
argument_list|(
name|b
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|VOID
name|strcpy
argument_list|(
name|b
operator|->
name|string
argument_list|,
name|s
argument_list|)
decl_stmt|;
block|}
end_function

begin_function
name|char
specifier|const
modifier|*
name|basefilename
parameter_list|(
name|p
parameter_list|)
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
comment|/* Yield the address of the base filename of the pathname P.  */
block|{
specifier|register
name|char
specifier|const
modifier|*
name|b
init|=
name|p
decl_stmt|,
modifier|*
name|q
init|=
name|p
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|*
name|q
operator|++
condition|)
block|{
case|case
name|SLASHes
case|:
name|b
operator|=
name|q
expr_stmt|;
break|break;
case|case
literal|0
case|:
return|return
name|b
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|size_t
name|suffixlen
parameter_list|(
name|x
parameter_list|)
name|char
specifier|const
modifier|*
name|x
decl_stmt|;
comment|/* Yield the length of X, an RCS pathname suffix.  */
block|{
specifier|register
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|x
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|0
case|:
case|case
name|SLASHes
case|:
return|return
name|p
operator|-
name|x
return|;
default|default:
operator|++
name|p
expr_stmt|;
continue|continue;
block|}
block|}
end_function

begin_function
name|char
specifier|const
modifier|*
name|rcssuffix
parameter_list|(
name|name
parameter_list|)
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
comment|/* Yield the suffix of NAME if it is an RCS pathname, 0 otherwise.  */
block|{
name|char
specifier|const
modifier|*
name|x
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|nz
decl_stmt|;
name|size_t
name|nl
decl_stmt|,
name|xl
decl_stmt|;
name|nl
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|nz
operator|=
name|name
operator|+
name|nl
expr_stmt|;
name|x
operator|=
name|suffixes
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|xl
operator|=
name|suffixlen
argument_list|(
name|x
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|xl
operator|<=
name|nl
operator|&&
name|memcmp
argument_list|(
name|p
operator|=
name|nz
operator|-
name|xl
argument_list|,
name|x
argument_list|,
name|xl
argument_list|)
operator|==
literal|0
condition|)
return|return
name|p
return|;
block|}
else|else
for|for
control|(
name|p
operator|=
name|name
init|;
name|p
operator|<
name|nz
operator|-
name|rcslen
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|isSLASH
argument_list|(
name|p
index|[
name|rcslen
index|]
argument_list|)
operator|&&
operator|(
name|p
operator|==
name|name
operator|||
name|isSLASH
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|&&
name|memcmp
argument_list|(
name|p
argument_list|,
name|rcsdir
argument_list|,
name|rcslen
argument_list|)
operator|==
literal|0
condition|)
return|return
name|nz
return|;
name|x
operator|+=
name|xl
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|x
operator|++
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|RILE
modifier|*
name|rcsreadopen
parameter_list|(
name|RCSpath
parameter_list|,
name|status
parameter_list|,
name|mustread
parameter_list|)
name|struct
name|buf
modifier|*
name|RCSpath
decl_stmt|;
name|struct
name|stat
modifier|*
name|status
decl_stmt|;
name|int
name|mustread
decl_stmt|;
comment|/* Open RCSPATH for reading and yield its FILE* descriptor.  * If successful, set *STATUS to its status.  * Pass this routine to pairnames() for read-only access to the file.  */
block|{
return|return
name|Iopen
argument_list|(
name|RCSpath
operator|->
name|string
argument_list|,
name|FOPEN_RB
argument_list|,
name|status
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|finopen
argument_list|(
name|rcsopen
argument_list|,
name|mustread
argument_list|)
name|RILE
modifier|*
argument_list|(
operator|*
name|rcsopen
argument_list|)
name|P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|,
expr|struct
name|stat
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mustread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Use RCSOPEN to open an RCS file; MUSTREAD is set if the file must be read.  * Set finptr to the result and yield true if successful.  * RCSb holds the file's name.  * Set RCSbuf to the best RCS name found so far, and RCSerrno to its errno.  * Yield true if successful or if an unusual failure.  */
end_comment

begin_block
block|{
name|int
name|interesting
decl_stmt|,
name|preferold
decl_stmt|;
comment|/* 	 * We prefer an old name to that of a nonexisting new RCS file, 	 * unless we tried locking the old name and failed. 	 */
name|preferold
operator|=
name|RCSbuf
operator|.
name|string
index|[
literal|0
index|]
operator|&&
operator|(
name|mustread
operator|||
literal|0
operator|<=
name|fdlock
operator|)
expr_stmt|;
name|finptr
operator|=
call|(
modifier|*
name|rcsopen
call|)
argument_list|(
operator|&
name|RCSb
argument_list|,
operator|&
name|RCSstat
argument_list|,
name|mustread
argument_list|)
expr_stmt|;
name|interesting
operator|=
name|finptr
operator|||
name|errno
operator|!=
name|ENOENT
expr_stmt|;
if|if
condition|(
name|interesting
operator|||
operator|!
name|preferold
condition|)
block|{
comment|/* Use the new name.  */
name|RCSerrno
operator|=
name|errno
expr_stmt|;
name|bufscpy
argument_list|(
operator|&
name|RCSbuf
argument_list|,
name|RCSb
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
return|return
name|interesting
return|;
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|fin2open
argument_list|(
name|d
argument_list|,
name|dlen
argument_list|,
name|base
argument_list|,
name|baselen
argument_list|,
name|x
argument_list|,
name|xlen
argument_list|,
name|rcsopen
argument_list|,
name|mustread
argument_list|)
name|char
decl|const
modifier|*
name|d
decl_stmt|,
modifier|*
name|base
decl_stmt|,
modifier|*
name|x
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|dlen
decl_stmt|,
name|baselen
decl_stmt|,
name|xlen
decl_stmt|;
end_decl_stmt

begin_macro
name|RILE
end_macro

begin_expr_stmt
operator|*
operator|(
operator|*
name|rcsopen
operator|)
name|P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|,
expr|struct
name|stat
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|mustread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * D is a directory name with length DLEN (including trailing slash).  * BASE is a filename with length BASELEN.  * X is an RCS pathname suffix with length XLEN.  * Use RCSOPEN to open an RCS file; MUSTREAD is set if the file must be read.  * Yield true if successful.  * Try dRCS/basex first; if that fails and x is nonempty, try dbasex.  * Put these potential names in RCSb.  * Set RCSbuf to the best RCS name found so far, and RCSerrno to its errno.  * Yield true if successful or if an unusual failure.  */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|bufalloc
argument_list|(
operator|&
name|RCSb
argument_list|,
name|dlen
operator|+
name|rcslen
operator|+
literal|1
operator|+
name|baselen
operator|+
name|xlen
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Try dRCS/basex.  */
name|VOID
name|memcpy
parameter_list|(
name|p
init|=
name|RCSb
operator|.
name|string
parameter_list|,
name|d
parameter_list|,
name|dlen
parameter_list|)
function_decl|;
name|VOID
name|memcpy
argument_list|(
name|p
operator|+=
name|dlen
argument_list|,
name|rcsdir
argument_list|,
name|rcslen
argument_list|)
decl_stmt|;
name|p
operator|+=
name|rcslen
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|SLASH
expr_stmt|;
name|VOID
name|memcpy
parameter_list|(
name|p
parameter_list|,
name|base
parameter_list|,
name|baselen
parameter_list|)
function_decl|;
name|VOID
name|memcpy
argument_list|(
name|p
operator|+=
name|baselen
argument_list|,
name|x
argument_list|,
name|xlen
argument_list|)
decl_stmt|;
name|p
index|[
name|xlen
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xlen
condition|)
block|{
if|if
condition|(
name|finopen
argument_list|(
name|rcsopen
argument_list|,
name|mustread
argument_list|)
condition|)
return|return
name|true
return|;
comment|/* Try dbasex.  */
comment|/* Start from scratch, because finopen() may have changed RCSb.  */
name|VOID
name|memcpy
parameter_list|(
name|p
init|=
name|RCSb
operator|.
name|string
parameter_list|,
name|d
parameter_list|,
name|dlen
parameter_list|)
function_decl|;
name|VOID
name|memcpy
argument_list|(
name|p
operator|+=
name|dlen
argument_list|,
name|base
argument_list|,
name|baselen
argument_list|)
decl_stmt|;
name|VOID
name|memcpy
argument_list|(
name|p
operator|+=
name|baselen
argument_list|,
name|x
argument_list|,
name|xlen
argument_list|)
decl_stmt|;
name|p
index|[
name|xlen
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|finopen
argument_list|(
name|rcsopen
argument_list|,
name|mustread
argument_list|)
return|;
block|}
end_block

begin_decl_stmt
name|int
name|pairnames
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|rcsopen
argument_list|,
name|mustread
argument_list|,
name|quiet
argument_list|)
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_macro
name|RILE
end_macro

begin_expr_stmt
operator|*
operator|(
operator|*
name|rcsopen
operator|)
name|P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|,
expr|struct
name|stat
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|mustread
decl_stmt|,
name|quiet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Pair the pathnames pointed to by argv; argc indicates  * how many there are.  * Place a pointer to the RCS pathname into RCSname,  * and a pointer to the pathname of the working file into workname.  * If both are given, and workstdout  * is set, a warning is printed.  *  * If the RCS file exists, places its status into RCSstat.  *  * If the RCS file exists, it is RCSOPENed for reading, the file pointer  * is placed into finptr, and the admin-node is read in; returns 1.  * If the RCS file does not exist and MUSTREAD,  * print an error unless QUIET and return 0.  * Otherwise, initialize the admin node and return -1.  *  * 0 is returned on all errors, e.g. files that are not regular files.  */
end_comment

begin_block
block|{
specifier|static
name|struct
name|buf
name|tempbuf
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|arg
decl_stmt|,
modifier|*
name|RCS1
decl_stmt|;
name|char
specifier|const
modifier|*
name|base
decl_stmt|,
modifier|*
name|RCSbase
decl_stmt|,
modifier|*
name|x
decl_stmt|;
name|int
name|paired
decl_stmt|;
name|size_t
name|arglen
decl_stmt|,
name|dlen
decl_stmt|,
name|baselen
decl_stmt|,
name|xlen
decl_stmt|;
name|fdlock
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|arg
operator|=
operator|*
name|argv
operator|)
condition|)
return|return
literal|0
return|;
comment|/* already paired pathname */
if|if
condition|(
operator|*
name|arg
operator|==
literal|'-'
condition|)
block|{
name|error
argument_list|(
literal|"%s option is ignored after pathnames"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|base
operator|=
name|basefilename
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|paired
operator|=
name|false
expr_stmt|;
comment|/* first check suffix to see whether it is an RCS file or not */
if|if
condition|(
operator|(
name|x
operator|=
name|rcssuffix
argument_list|(
name|arg
argument_list|)
operator|)
condition|)
block|{
comment|/* RCS pathname given */
name|RCS1
operator|=
name|arg
expr_stmt|;
name|RCSbase
operator|=
name|base
expr_stmt|;
name|baselen
operator|=
name|x
operator|-
name|base
expr_stmt|;
if|if
condition|(
literal|1
operator|<
name|argc
operator|&&
operator|!
name|rcssuffix
argument_list|(
name|workname
operator|=
name|p
operator|=
name|argv
index|[
literal|1
index|]
argument_list|)
operator|&&
name|baselen
operator|<=
operator|(
name|arglen
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|p
operator|+=
name|arglen
operator|-
name|baselen
operator|)
operator|==
name|workname
operator|||
name|isSLASH
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|&&
name|memcmp
argument_list|(
name|base
argument_list|,
name|p
argument_list|,
name|baselen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|argv
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|paired
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|bufscpy
argument_list|(
operator|&
name|tempbuf
argument_list|,
name|base
argument_list|)
expr_stmt|;
name|workname
operator|=
name|p
operator|=
name|tempbuf
operator|.
name|string
expr_stmt|;
name|p
index|[
name|baselen
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* working file given; now try to find RCS file */
name|workname
operator|=
name|arg
expr_stmt|;
name|baselen
operator|=
name|strlen
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* Derive RCS pathname.  */
if|if
condition|(
literal|1
operator|<
name|argc
operator|&&
operator|(
name|x
operator|=
name|rcssuffix
argument_list|(
name|RCS1
operator|=
name|argv
index|[
literal|1
index|]
argument_list|)
operator|)
operator|&&
name|baselen
operator|<=
name|x
operator|-
name|RCS1
operator|&&
operator|(
operator|(
name|RCSbase
operator|=
name|x
operator|-
name|baselen
operator|)
operator|==
name|RCS1
operator|||
name|isSLASH
argument_list|(
name|RCSbase
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|&&
name|memcmp
argument_list|(
name|base
argument_list|,
name|RCSbase
argument_list|,
name|baselen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|argv
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|paired
operator|=
name|true
expr_stmt|;
block|}
else|else
name|RCSbase
operator|=
name|RCS1
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now we have a (tentative) RCS pathname in RCS1 and workname.  */
comment|/* Second, try to find the right RCS file */
if|if
condition|(
name|RCSbase
operator|!=
name|RCS1
condition|)
block|{
comment|/* a path for RCSfile is given; single RCS file to look for */
name|bufscpy
argument_list|(
operator|&
name|RCSbuf
argument_list|,
name|RCS1
argument_list|)
expr_stmt|;
name|finptr
operator|=
call|(
modifier|*
name|rcsopen
call|)
argument_list|(
operator|&
name|RCSbuf
argument_list|,
operator|&
name|RCSstat
argument_list|,
name|mustread
argument_list|)
expr_stmt|;
name|RCSerrno
operator|=
name|errno
expr_stmt|;
block|}
else|else
block|{
name|bufscpy
argument_list|(
operator|&
name|RCSbuf
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|RCS1
condition|)
comment|/* RCS filename was given without path.  */
name|VOID
name|fin2open
argument_list|(
name|arg
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
name|RCSbase
argument_list|,
name|baselen
argument_list|,
name|x
argument_list|,
name|strlen
argument_list|(
name|x
argument_list|)
argument_list|,
name|rcsopen
argument_list|,
name|mustread
argument_list|)
decl_stmt|;
else|else
block|{
comment|/* No RCS pathname was given.  */
comment|/* Try each suffix in turn.  */
name|dlen
operator|=
name|base
operator|-
name|arg
expr_stmt|;
name|x
operator|=
name|suffixes
expr_stmt|;
while|while
condition|(
operator|!
name|fin2open
argument_list|(
name|arg
argument_list|,
name|dlen
argument_list|,
name|base
argument_list|,
name|baselen
argument_list|,
name|x
argument_list|,
name|xlen
operator|=
name|suffixlen
argument_list|(
name|x
argument_list|)
argument_list|,
name|rcsopen
argument_list|,
name|mustread
argument_list|)
condition|)
block|{
name|x
operator|+=
name|xlen
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|x
operator|++
condition|)
break|break;
block|}
block|}
block|}
name|RCSname
operator|=
name|p
operator|=
name|RCSbuf
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|finptr
condition|)
block|{
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|RCSstat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%s isn't a regular file -- ignored"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|Lexinit
argument_list|()
expr_stmt|;
name|getadmin
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|RCSerrno
operator|!=
name|ENOENT
operator|||
name|mustread
operator|||
name|fdlock
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|RCSerrno
operator|==
name|EEXIST
condition|)
name|error
argument_list|(
literal|"RCS file %s is in use"
argument_list|,
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|quiet
operator|||
name|RCSerrno
operator|!=
name|ENOENT
condition|)
name|enerror
argument_list|(
name|RCSerrno
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|InitAdmin
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|paired
operator|&&
name|workstdout
condition|)
name|workwarn
argument_list|(
literal|"Working file ignored due to -p option"
argument_list|)
expr_stmt|;
name|prevkeys
operator|=
name|false
expr_stmt|;
return|return
name|finptr
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
end_block

begin_function
name|char
specifier|const
modifier|*
name|getfullRCSname
parameter_list|()
comment|/*  * Return a pointer to the full pathname of the RCS file.  * Remove leading `./'.  */
block|{
if|if
condition|(
name|ROOTPATH
argument_list|(
name|RCSname
argument_list|)
condition|)
block|{
return|return
name|RCSname
return|;
block|}
else|else
block|{
specifier|static
name|struct
name|buf
name|rcsbuf
decl_stmt|;
if|#
directive|if
name|needs_getabsname
name|bufalloc
argument_list|(
operator|&
name|rcsbuf
argument_list|,
name|SIZEABLE_PATH
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|getabsname
argument_list|(
name|RCSname
argument_list|,
name|rcsbuf
operator|.
name|string
argument_list|,
name|rcsbuf
operator|.
name|size
argument_list|)
operator|!=
literal|0
condition|)
if|if
condition|(
name|errno
operator|==
name|ERANGE
condition|)
name|bufalloc
argument_list|(
operator|&
name|rcsbuf
argument_list|,
name|rcsbuf
operator|.
name|size
operator|<<
literal|1
argument_list|)
expr_stmt|;
else|else
name|efaterror
argument_list|(
literal|"getabsname"
argument_list|)
expr_stmt|;
else|#
directive|else
specifier|static
name|char
specifier|const
modifier|*
name|wdptr
decl_stmt|;
specifier|static
name|struct
name|buf
name|wdbuf
decl_stmt|;
specifier|static
name|size_t
name|wdlen
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|r
decl_stmt|;
specifier|register
name|size_t
name|dlen
decl_stmt|;
specifier|register
name|char
modifier|*
name|d
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|wd
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|wd
operator|=
name|wdptr
operator|)
condition|)
block|{
comment|/* Get working directory for the first time.  */
name|char
modifier|*
name|PWD
init|=
name|cgetenv
argument_list|(
literal|"PWD"
argument_list|)
decl_stmt|;
name|struct
name|stat
name|PWDstat
decl_stmt|,
name|dotstat
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|d
operator|=
name|PWD
operator|)
operator|&&
name|ROOTPATH
argument_list|(
name|PWD
argument_list|)
operator|&&
name|stat
argument_list|(
name|PWD
argument_list|,
operator|&
name|PWDstat
argument_list|)
operator|==
literal|0
operator|&&
name|stat
argument_list|(
literal|"."
argument_list|,
operator|&
name|dotstat
argument_list|)
operator|==
literal|0
operator|&&
name|same_file
argument_list|(
name|PWDstat
argument_list|,
name|dotstat
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
name|bufalloc
argument_list|(
operator|&
name|wdbuf
argument_list|,
name|SIZEABLE_PATH
operator|+
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|has_getcwd
operator|||
operator|!
name|has_getwd
while|while
condition|(
operator|!
operator|(
name|d
operator|=
name|getcwd
argument_list|(
name|wdbuf
operator|.
name|string
argument_list|,
name|wdbuf
operator|.
name|size
argument_list|)
operator|)
condition|)
if|if
condition|(
name|errno
operator|==
name|ERANGE
condition|)
name|bufalloc
argument_list|(
operator|&
name|wdbuf
argument_list|,
name|wdbuf
operator|.
name|size
operator|<<
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|d
operator|=
name|PWD
operator|)
condition|)
break|break;
else|else
name|efaterror
argument_list|(
literal|"getcwd"
argument_list|)
expr_stmt|;
else|#
directive|else
name|d
operator|=
name|getwd
argument_list|(
name|wdbuf
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|&&
operator|!
operator|(
name|d
operator|=
name|PWD
operator|)
condition|)
name|efaterror
argument_list|(
literal|"getwd"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|wdlen
operator|=
name|dir_useful_len
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
index|[
name|wdlen
index|]
operator|=
literal|0
expr_stmt|;
name|wdptr
operator|=
name|wd
operator|=
name|d
expr_stmt|;
block|}
comment|/* 		* Remove leading `./'s from RCSname. 		* Do not try to handle `../', since removing it may yield 		* the wrong answer in the presence of symbolic links. 		*/
for|for
control|(
name|r
operator|=
name|RCSname
init|;
name|r
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|isSLASH
argument_list|(
name|r
index|[
literal|1
index|]
argument_list|)
condition|;
name|r
operator|+=
literal|2
control|)
comment|/* `.////' is equivalent to `./'.  */
while|while
condition|(
name|isSLASH
argument_list|(
name|r
index|[
literal|2
index|]
argument_list|)
condition|)
name|r
operator|++
expr_stmt|;
comment|/* Build full pathname.  */
name|dlen
operator|=
name|wdlen
expr_stmt|;
name|bufalloc
argument_list|(
operator|&
name|rcsbuf
argument_list|,
name|dlen
operator|+
name|strlen
argument_list|(
name|r
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|d
operator|=
name|rcsbuf
operator|.
name|string
expr_stmt|;
name|VOID
name|memcpy
argument_list|(
name|d
argument_list|,
name|wd
argument_list|,
name|dlen
argument_list|)
decl_stmt|;
name|d
operator|+=
name|dlen
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|SLASH
expr_stmt|;
name|VOID
name|strcpy
argument_list|(
name|d
argument_list|,
name|r
argument_list|)
decl_stmt|;
endif|#
directive|endif
return|return
name|rcsbuf
operator|.
name|string
return|;
block|}
block|}
end_function

begin_function
name|char
specifier|const
modifier|*
name|getfullCVSname
parameter_list|()
comment|/*  * Return a pointer to the fill pathname of the RCS file, but trim $CVSROOT.  */
block|{
name|char
specifier|const
modifier|*
name|CVSname
decl_stmt|;
name|char
specifier|const
modifier|*
name|cvsroot
decl_stmt|;
name|int
name|rootlen
decl_stmt|;
name|CVSname
operator|=
name|getfullRCSname
argument_list|()
expr_stmt|;
name|cvsroot
operator|=
name|getenv
argument_list|(
literal|"CVSROOT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvsroot
condition|)
block|{
name|rootlen
operator|=
name|strlen
argument_list|(
name|cvsroot
argument_list|)
expr_stmt|;
comment|/* ignore trailing '/' chars from $CVSROOT */
while|while
condition|(
name|rootlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cvsroot
index|[
name|rootlen
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|rootlen
operator|--
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|CVSname
argument_list|,
name|cvsroot
argument_list|,
name|rootlen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|CVSname
operator|+=
name|rootlen
expr_stmt|;
comment|/* skip any leading '/' chars */
while|while
condition|(
operator|*
name|CVSname
operator|==
literal|'/'
condition|)
name|CVSname
operator|++
expr_stmt|;
return|return
name|CVSname
return|;
block|}
block|}
return|return
name|CVSname
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|dir_useful_len
parameter_list|(
name|d
parameter_list|)
name|char
specifier|const
modifier|*
name|d
decl_stmt|;
comment|/* * D names a directory; yield the number of characters of D's useful part. * To create a file in D, append a SLASH and a file name to D's useful part. * Ignore trailing slashes if possible; not only are they ugly, * but some non-Posix systems misbehave unless the slashes are omitted. */
block|{
ifndef|#
directive|ifndef
name|SLASHSLASH_is_SLASH
define|#
directive|define
name|SLASHSLASH_is_SLASH
value|0
endif|#
directive|endif
name|size_t
name|dlen
init|=
name|strlen
argument_list|(
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SLASHSLASH_is_SLASH
operator|&&
name|dlen
operator|==
literal|2
operator|&&
name|isSLASH
argument_list|(
name|d
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isSLASH
argument_list|(
name|d
index|[
literal|1
index|]
argument_list|)
condition|)
operator|--
name|dlen
expr_stmt|;
else|else
while|while
condition|(
name|dlen
operator|&&
name|isSLASH
argument_list|(
name|d
index|[
name|dlen
operator|-
literal|1
index|]
argument_list|)
condition|)
operator|--
name|dlen
expr_stmt|;
return|return
name|dlen
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|isSLASH
end_ifndef

begin_function
name|int
name|isSLASH
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|SLASHes
case|:
return|return
name|true
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|has_getcwd
operator|&&
operator|!
name|has_getwd
end_if

begin_function
name|char
modifier|*
name|getcwd
parameter_list|(
name|path
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
specifier|static
name|char
specifier|const
name|usrbinpwd
index|[]
init|=
literal|"/usr/bin/pwd"
decl_stmt|;
define|#
directive|define
name|binpwd
value|(usrbinpwd+4)
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|lim
decl_stmt|;
name|int
name|closeerrno
decl_stmt|,
name|closeerror
decl_stmt|,
name|e
decl_stmt|,
name|fd
index|[
literal|2
index|]
decl_stmt|,
name|readerror
decl_stmt|,
name|toolong
decl_stmt|,
name|wstatus
decl_stmt|;
name|pid_t
name|child
decl_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|pipe
argument_list|(
name|fd
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|bad_wait_if_SIGCHLD_ignored
ifndef|#
directive|ifndef
name|SIGCHLD
define|#
directive|define
name|SIGCHLD
value|SIGCLD
endif|#
directive|endif
name|VOID
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_DFL
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|child
operator|=
name|vfork
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|fd
index|[
literal|1
index|]
operator|==
name|STDOUT_FILENO
operator|||
ifdef|#
directive|ifdef
name|F_DUPFD
operator|(
name|VOID
name|close
argument_list|(
name|STDOUT_FILENO
argument_list|)
operator|,
name|fcntl
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
name|F_DUPFD
argument_list|,
name|STDOUT_FILENO
argument_list|)
operator|)
else|#
directive|else
name|dup2
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
endif|#
directive|endif
operator|==
name|STDOUT_FILENO
operator|&&
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|VOID
name|close
argument_list|(
name|STDERR_FILENO
argument_list|)
decl_stmt|;
name|VOID
name|execl
argument_list|(
name|binpwd
argument_list|,
name|binpwd
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
name|VOID
name|execl
argument_list|(
name|usrbinpwd
argument_list|,
name|usrbinpwd
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
block|}
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
name|errno
expr_stmt|;
name|closeerror
operator|=
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|closeerrno
operator|=
name|errno
expr_stmt|;
name|fp
operator|=
literal|0
expr_stmt|;
name|readerror
operator|=
name|toolong
operator|=
name|wstatus
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|path
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|child
condition|)
block|{
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|e
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|fp
condition|)
block|{
name|lim
operator|=
name|p
operator|+
name|size
expr_stmt|;
for|for
control|(
name|p
operator|=
name|path
init|;
condition|;
operator|*
name|p
operator|++
operator|=
name|c
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|readerror
operator|=
literal|1
expr_stmt|;
name|e
operator|=
name|errno
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|p
operator|==
name|lim
condition|)
block|{
name|toolong
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|#
directive|if
name|has_waitpid
if|if
condition|(
name|waitpid
argument_list|(
name|child
argument_list|,
operator|&
name|wstatus
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|wstatus
operator|=
literal|1
expr_stmt|;
else|#
directive|else
block|{
name|pid_t
name|w
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|w
operator|=
name|wait
argument_list|(
operator|&
name|wstatus
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|wstatus
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|w
operator|!=
name|child
condition|)
do|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|VOID
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|readerror
condition|)
block|{
name|errno
operator|=
name|e
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|closeerror
condition|)
block|{
name|errno
operator|=
name|closeerrno
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|toolong
condition|)
block|{
name|errno
operator|=
name|ERANGE
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|wstatus
operator|||
name|p
operator|==
name|path
operator|||
operator|*
operator|--
name|p
operator|!=
literal|'\n'
condition|)
block|{
name|errno
operator|=
name|EACCES
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
name|path
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PAIRTEST
end_ifdef

begin_comment
comment|/* test program for pairnames() and getfullRCSname() */
end_comment

begin_decl_stmt
name|char
specifier|const
name|cmdid
index|[]
init|=
literal|"pair"
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|int
name|initflag
decl_stmt|;
name|quietflag
operator|=
name|initflag
operator|=
name|false
expr_stmt|;
while|while
condition|(
operator|--
name|argc
operator|,
operator|++
name|argv
operator|,
name|argc
operator|>=
literal|1
operator|&&
operator|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
condition|)
block|{
switch|switch
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'p'
case|:
name|workstdout
operator|=
name|stdout
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|initflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quietflag
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"unknown option: %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|do
block|{
name|RCSname
operator|=
name|workname
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|pairnames
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|rcsreadopen
argument_list|,
operator|!
name|initflag
argument_list|,
name|quietflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|diagnose
argument_list|(
literal|"RCS pathname: %s; working pathname: %s\nFull RCS pathname: %s\n"
argument_list|,
name|RCSname
argument_list|,
name|workname
argument_list|,
name|getfullRCSname
argument_list|()
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|result
condition|)
block|{
case|case
literal|0
case|:
continue|continue;
comment|/* already paired file */
case|case
literal|1
case|:
if|if
condition|(
name|initflag
condition|)
block|{
name|rcserror
argument_list|(
literal|"already exists"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|diagnose
argument_list|(
literal|"RCS file %s exists\n"
argument_list|,
name|RCSname
argument_list|)
expr_stmt|;
block|}
name|Ifclose
argument_list|(
name|finptr
argument_list|)
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
name|diagnose
argument_list|(
literal|"RCS file doesn't exist\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|++
name|argv
operator|,
operator|--
name|argc
operator|>=
literal|1
condition|)
do|;
block|}
end_function

begin_function
name|void
name|exiterr
parameter_list|()
block|{
name|dirtempunlink
argument_list|()
expr_stmt|;
name|tempunlink
argument_list|()
expr_stmt|;
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

