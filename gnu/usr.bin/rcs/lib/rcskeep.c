begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Extract RCS keyword string values from working files.  */
end_comment

begin_comment
comment|/* Copyright 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991, 1992, 1993, 1994, 1995 Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/*  * Revision 5.10  1995/06/16 06:19:24  eggert  * Update FSF address.  *  * Revision 5.9  1995/06/01 16:23:43  eggert  * (getoldkeys): Don't panic if a Name: is empty.  *  * Revision 5.8  1994/03/17 14:05:48  eggert  * Remove lint.  *  * Revision 5.7  1993/11/09 17:40:15  eggert  * Use simpler timezone parsing strategy now that we're using ISO 8601 format.  *  * Revision 5.6  1993/11/03 17:42:27  eggert  * Scan for Name keyword.  Improve quality of diagnostics.  *  * Revision 5.5  1992/07/28  16:12:44  eggert  * Statement macro names now end in _.  *  * Revision 5.4  1991/08/19  03:13:55  eggert  * Tune.  *  * Revision 5.3  1991/04/21  11:58:25  eggert  * Shorten names to keep them distinct on shortname hosts.  *  * Revision 5.2  1990/10/04  06:30:20  eggert  * Parse time zone offsets; future RCS versions may output them.  *  * Revision 5.1  1990/09/20  02:38:56  eggert  * ci -k now checks dates more thoroughly.  *  * Revision 5.0  1990/08/22  08:12:53  eggert  * Retrieve old log message if there is one.  * Don't require final newline.  * Remove compile-time limits; use malloc instead.  Tune.  * Permit dates past 1999/12/31.  Ansify and Posixate.  *  * Revision 4.6  89/05/01  15:12:56  narten  * changed copyright header to reflect current distribution rules  *  * Revision 4.5  88/08/09  19:13:03  eggert  * Remove lint and speed up by making FILE *fp local, not global.  *  * Revision 4.4  87/12/18  11:44:21  narten  * more lint cleanups (Guy Harris)  *  * Revision 4.3  87/10/18  10:35:50  narten  * Updating version numbers. Changes relative to 1.1 actually relative  * to 4.1  *  * Revision 1.3  87/09/24  14:00:00  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf  * warnings)  *  * Revision 1.2  87/03/27  14:22:29  jenkins  * Port to suns  *  * Revision 4.1  83/05/10  16:26:44  wft  * Added new markers Id and RCSfile; extraction added.  * Marker matching with trymatch().  *  * Revision 3.2  82/12/24  12:08:26  wft  * added missing #endif.  *  * Revision 3.1  82/12/04  13:22:41  wft  * Initial revision.  *  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_macro
name|libId
argument_list|(
argument|keepId
argument_list|,
literal|"$FreeBSD$"
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|int
name|badly_terminated
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|checknum
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get0val
name|P
argument_list|(
operator|(
name|int
operator|,
name|RILE
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getval
name|P
argument_list|(
operator|(
name|RILE
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|keepdate
name|P
argument_list|(
operator|(
name|RILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|keepid
name|P
argument_list|(
operator|(
name|int
operator|,
name|RILE
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|keeprev
name|P
argument_list|(
operator|(
name|RILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prevkeys
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
name|prevauthor
decl_stmt|,
name|prevdate
decl_stmt|,
name|prevname
decl_stmt|,
name|prevrev
decl_stmt|,
name|prevstate
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|getoldkeys
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|RILE
modifier|*
name|fp
decl_stmt|;
comment|/* Function: Tries to read keyword values for author, date,  * revision number, and state out of the file fp.  * If fp is null, workname is opened and closed instead of using fp.  * The results are placed into  * prevauthor, prevdate, prevname, prevrev, prevstate.  * Aborts immediately if it finds an error and returns false.  * If it returns true, it doesn't mean that any of the  * values were found; instead, check to see whether the corresponding arrays  * contain the empty string.  */
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|char
name|keyword
index|[
name|keylength
operator|+
literal|1
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
name|int
name|needs_closing
decl_stmt|;
name|int
name|prevname_found
decl_stmt|;
if|if
condition|(
name|prevkeys
condition|)
return|return
name|true
return|;
name|needs_closing
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|Iopen
argument_list|(
name|workname
argument_list|,
name|FOPEN_R_WORK
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
literal|0
argument_list|)
operator|)
condition|)
block|{
name|eerror
argument_list|(
name|workname
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|needs_closing
operator|=
name|true
expr_stmt|;
block|}
comment|/* initialize to empty */
name|bufscpy
argument_list|(
operator|&
name|prevauthor
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|bufscpy
argument_list|(
operator|&
name|prevdate
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|bufscpy
argument_list|(
operator|&
name|prevname
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|prevname_found
operator|=
literal|0
expr_stmt|;
name|bufscpy
argument_list|(
operator|&
name|prevrev
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|bufscpy
argument_list|(
operator|&
name|prevstate
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\0'
expr_stmt|;
comment|/* anything but KDELIM */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|==
name|KDELIM
condition|)
block|{
do|do
block|{
comment|/* try to get keyword */
name|tp
operator|=
name|keyword
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|Igeteof_
argument_list|(
argument|fp
argument_list|,
argument|c
argument_list|,
argument|goto ok;
argument_list|)
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
if|if
condition|(
name|keyword
operator|+
name|keylength
operator|<=
name|tp
condition|)
break|break;
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
case|case
literal|'\n'
case|:
case|case
name|KDELIM
case|:
case|case
name|VDELIM
case|:
break|break;
block|}
break|break;
block|}
block|}
do|while
condition|(
name|c
operator|==
name|KDELIM
condition|)
do|;
if|if
condition|(
name|c
operator|!=
name|VDELIM
condition|)
continue|continue;
operator|*
name|tp
operator|=
name|c
expr_stmt|;
name|Igeteof_
argument_list|(
argument|fp
argument_list|,
argument|c
argument_list|,
argument|break;
argument_list|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
break|break;
default|default:
continue|continue;
block|}
switch|switch
condition|(
name|trymatch
argument_list|(
name|keyword
argument_list|)
condition|)
block|{
case|case
name|Author
case|:
if|if
condition|(
operator|!
name|keepid
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|,
operator|&
name|prevauthor
argument_list|)
condition|)
return|return
name|false
return|;
name|c
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|Date
case|:
if|if
condition|(
operator|!
operator|(
name|c
operator|=
name|keepdate
argument_list|(
name|fp
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
break|break;
case|case
name|Header
case|:
case|case
name|Id
case|:
if|if
condition|(
operator|!
operator|(
name|getval
argument_list|(
name|fp
argument_list|,
operator|(
expr|struct
name|buf
operator|*
operator|)
literal|0
argument_list|,
name|false
argument_list|)
operator|&&
name|keeprev
argument_list|(
name|fp
argument_list|)
operator|&&
operator|(
name|c
operator|=
name|keepdate
argument_list|(
name|fp
argument_list|)
operator|)
operator|&&
name|keepid
argument_list|(
name|c
argument_list|,
name|fp
argument_list|,
operator|&
name|prevauthor
argument_list|)
operator|&&
name|keepid
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|,
operator|&
name|prevstate
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
comment|/* Skip either ``who'' (new form) or ``Locker: who'' (old).  */
if|if
condition|(
name|getval
argument_list|(
name|fp
argument_list|,
operator|(
expr|struct
name|buf
operator|*
operator|)
literal|0
argument_list|,
name|true
argument_list|)
operator|&&
name|getval
argument_list|(
name|fp
argument_list|,
operator|(
expr|struct
name|buf
operator|*
operator|)
literal|0
argument_list|,
name|true
argument_list|)
condition|)
name|c
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|nerror
condition|)
return|return
name|false
return|;
else|else
name|c
operator|=
name|KDELIM
expr_stmt|;
break|break;
case|case
name|Locker
case|:
operator|(
name|void
operator|)
name|getval
argument_list|(
name|fp
argument_list|,
operator|(
expr|struct
name|buf
operator|*
operator|)
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|Log
case|:
case|case
name|RCSfile
case|:
case|case
name|Source
case|:
if|if
condition|(
operator|!
name|getval
argument_list|(
name|fp
argument_list|,
operator|(
expr|struct
name|buf
operator|*
operator|)
literal|0
argument_list|,
name|false
argument_list|)
condition|)
return|return
name|false
return|;
name|c
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|Name
case|:
if|if
condition|(
name|getval
argument_list|(
name|fp
argument_list|,
operator|&
name|prevname
argument_list|,
name|false
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|prevname
operator|.
name|string
condition|)
name|checkssym
argument_list|(
name|prevname
operator|.
name|string
argument_list|)
expr_stmt|;
name|prevname_found
operator|=
literal|1
expr_stmt|;
block|}
name|c
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|Revision
case|:
if|if
condition|(
operator|!
name|keeprev
argument_list|(
name|fp
argument_list|)
condition|)
return|return
name|false
return|;
name|c
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|State
case|:
if|if
condition|(
operator|!
name|keepid
argument_list|(
literal|0
argument_list|,
name|fp
argument_list|,
operator|&
name|prevstate
argument_list|)
condition|)
return|return
name|false
return|;
name|c
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
if|if
condition|(
operator|!
name|c
condition|)
name|Igeteof_
argument_list|(
argument|fp
argument_list|,
argument|c
argument_list|,
argument|c=
literal|0
argument|;
argument_list|)
if|if
condition|(
name|c
operator|!=
name|KDELIM
condition|)
block|{
name|workerror
argument_list|(
literal|"closing %c missing on keyword"
argument_list|,
name|KDELIM
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|prevname_found
operator|&&
operator|*
name|prevauthor
operator|.
name|string
operator|&&
operator|*
name|prevdate
operator|.
name|string
operator|&&
operator|*
name|prevrev
operator|.
name|string
operator|&&
operator|*
name|prevstate
operator|.
name|string
condition|)
break|break;
block|}
name|Igeteof_
argument_list|(
argument|fp
argument_list|,
argument|c
argument_list|,
argument|break;
argument_list|)
block|}
name|ok
label|:
if|if
condition|(
name|needs_closing
condition|)
name|Ifclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
else|else
name|Irewind
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|prevkeys
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|badly_terminated
parameter_list|()
block|{
name|workerror
argument_list|(
literal|"badly terminated keyword value"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getval
parameter_list|(
name|fp
parameter_list|,
name|target
parameter_list|,
name|optional
parameter_list|)
specifier|register
name|RILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|buf
modifier|*
name|target
decl_stmt|;
name|int
name|optional
decl_stmt|;
comment|/* Reads a keyword value from FP into TARGET.  * Returns true if one is found, false otherwise.  * Does not modify target if it is 0.  * Do not report an error if OPTIONAL is set and KDELIM is found instead.  */
block|{
name|int
name|c
decl_stmt|;
name|Igeteof_
argument_list|(
argument|fp
argument_list|,
argument|c
argument_list|,
argument|return badly_terminated();
argument_list|)
return|return
name|get0val
argument_list|(
name|c
argument_list|,
name|fp
argument_list|,
name|target
argument_list|,
name|optional
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get0val
parameter_list|(
name|c
parameter_list|,
name|fp
parameter_list|,
name|target
parameter_list|,
name|optional
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|RILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|buf
modifier|*
name|target
decl_stmt|;
name|int
name|optional
decl_stmt|;
comment|/* Reads a keyword value from C+FP into TARGET, perhaps OPTIONALly.  * Same as getval, except C is the lookahead character.  */
block|{
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
name|char
specifier|const
modifier|*
name|tlim
decl_stmt|;
specifier|register
name|int
name|got1
decl_stmt|;
if|if
condition|(
name|target
condition|)
block|{
name|bufalloc
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tp
operator|=
name|target
operator|->
name|string
expr_stmt|;
name|tlim
operator|=
name|tp
operator|+
name|target
operator|->
name|size
expr_stmt|;
block|}
else|else
name|tlim
operator|=
name|tp
operator|=
literal|0
expr_stmt|;
name|got1
operator|=
name|false
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
name|got1
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|tp
condition|)
block|{
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|tlim
operator|<=
name|tp
condition|)
name|tp
operator|=
name|bufenlarge
argument_list|(
name|target
argument_list|,
operator|&
name|tlim
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
if|if
condition|(
name|tp
condition|)
block|{
operator|*
name|tp
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|KEEPTEST
name|VOID
name|printf
argument_list|(
literal|"getval: %s\n"
argument_list|,
name|target
argument_list|)
decl_stmt|;
endif|#
directive|endif
block|}
return|return
name|got1
return|;
case|case
name|KDELIM
case|:
if|if
condition|(
operator|!
name|got1
operator|&&
name|optional
condition|)
return|return
name|false
return|;
comment|/* fall into */
case|case
literal|'\n'
case|:
case|case
literal|0
case|:
return|return
name|badly_terminated
argument_list|()
return|;
block|}
name|Igeteof_
argument_list|(
argument|fp
argument_list|,
argument|c
argument_list|,
argument|return badly_terminated();
argument_list|)
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|keepdate
parameter_list|(
name|fp
parameter_list|)
name|RILE
modifier|*
name|fp
decl_stmt|;
comment|/* Function: reads a date prevdate; checks format  * Return 0 on error, lookahead character otherwise.  */
block|{
name|struct
name|buf
name|prevday
decl_stmt|,
name|prevtime
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|prevday
argument_list|)
expr_stmt|;
if|if
condition|(
name|getval
argument_list|(
name|fp
argument_list|,
operator|&
name|prevday
argument_list|,
name|false
argument_list|)
condition|)
block|{
name|bufautobegin
argument_list|(
operator|&
name|prevtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|getval
argument_list|(
name|fp
argument_list|,
operator|&
name|prevtime
argument_list|,
name|false
argument_list|)
condition|)
block|{
name|Igeteof_
argument_list|(
argument|fp
argument_list|,
argument|c
argument_list|,
argument|c=
literal|0
argument|;
argument_list|)
if|if
condition|(
name|c
condition|)
block|{
specifier|register
name|char
specifier|const
modifier|*
name|d
init|=
name|prevday
operator|.
name|string
decl_stmt|,
modifier|*
name|t
init|=
name|prevtime
operator|.
name|string
decl_stmt|;
name|bufalloc
argument_list|(
operator|&
name|prevdate
argument_list|,
name|strlen
argument_list|(
name|d
argument_list|)
operator|+
name|strlen
argument_list|(
name|t
argument_list|)
operator|+
literal|9
argument_list|)
expr_stmt|;
name|VOID
name|sprintf
argument_list|(
name|prevdate
operator|.
name|string
argument_list|,
literal|"%s%s %s%s"
argument_list|,
comment|/* Parse dates put out by old versions of RCS.  */
name|isdigit
argument_list|(
name|d
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|d
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|isdigit
argument_list|(
name|d
index|[
literal|2
index|]
argument_list|)
condition|?
literal|"19"
else|:
literal|""
argument_list|,
name|d
argument_list|,
name|t
argument_list|,
name|strchr
argument_list|(
name|t
argument_list|,
literal|'-'
argument_list|)
operator|||
name|strchr
argument_list|(
name|t
argument_list|,
literal|'+'
argument_list|)
condition|?
literal|""
else|:
literal|"+0000"
argument_list|)
decl_stmt|;
block|}
block|}
name|bufautoend
argument_list|(
operator|&
name|prevtime
argument_list|)
expr_stmt|;
block|}
name|bufautoend
argument_list|(
operator|&
name|prevday
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|keepid
parameter_list|(
name|c
parameter_list|,
name|fp
parameter_list|,
name|b
parameter_list|)
name|int
name|c
decl_stmt|;
name|RILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
comment|/* Get previous identifier from C+FP into B.  */
block|{
if|if
condition|(
operator|!
name|c
condition|)
name|Igeteof_
argument_list|(
argument|fp
argument_list|,
argument|c
argument_list|,
argument|return false;
argument_list|)
if|if
condition|(
operator|!
name|get0val
argument_list|(
name|c
argument_list|,
name|fp
argument_list|,
name|b
argument_list|,
name|false
argument_list|)
condition|)
return|return
name|false
return|;
name|checksid
argument_list|(
name|b
operator|->
name|string
argument_list|)
expr_stmt|;
return|return
operator|!
name|nerror
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|keeprev
parameter_list|(
name|fp
parameter_list|)
name|RILE
modifier|*
name|fp
decl_stmt|;
comment|/* Get previous revision from FP into prevrev.  */
block|{
return|return
name|getval
argument_list|(
name|fp
argument_list|,
operator|&
name|prevrev
argument_list|,
name|false
argument_list|)
operator|&&
name|checknum
argument_list|(
name|prevrev
operator|.
name|string
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|checknum
parameter_list|(
name|s
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
specifier|const
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|dotcount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|s
init|;
condition|;
name|sp
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|sp
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|dotcount
operator|&
literal|1
condition|)
return|return
name|true
return|;
else|else
break|break;
case|case
literal|'.'
case|:
name|dotcount
operator|++
expr_stmt|;
continue|continue;
default|default:
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|sp
argument_list|)
condition|)
continue|continue;
break|break;
block|}
break|break;
block|}
name|workerror
argument_list|(
literal|"%s is not a revision number"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KEEPTEST
end_ifdef

begin_comment
comment|/* Print the keyword values found.  */
end_comment

begin_decl_stmt
name|char
specifier|const
name|cmdid
index|[]
init|=
literal|"keeptest"
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
while|while
condition|(
operator|*
operator|(
operator|++
name|argv
operator|)
condition|)
block|{
name|workname
operator|=
operator|*
name|argv
expr_stmt|;
name|getoldkeys
argument_list|(
operator|(
name|RILE
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|VOID
name|printf
argument_list|(
literal|"%s:  revision: %s, date: %s, author: %s, name: %s, state: %s\n"
argument_list|,
operator|*
name|argv
argument_list|,
name|prevrev
operator|.
name|string
argument_list|,
name|prevdate
operator|.
name|string
argument_list|,
name|prevauthor
operator|.
name|string
argument_list|,
name|prevname
operator|.
name|string
argument_list|,
name|prevstate
operator|.
name|string
argument_list|)
decl_stmt|;
block|}
name|exitmain
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

