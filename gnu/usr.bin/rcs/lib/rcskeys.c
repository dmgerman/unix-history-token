begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* RCS keyword table and match operation */
end_comment

begin_comment
comment|/* Copyright 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991, 1992, 1993, 1995 Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/*  * Revision 5.4  1995/06/16 06:19:24  eggert  * Update FSF address.  *  * Revision 5.3  1993/11/03 17:42:27  eggert  * Add Name keyword.  *  * Revision 5.2  1991/08/19  03:13:55  eggert  * Say `T const' instead of `const T'; it's less confusing for pointer types.  * (This change was made in other source files too.)  *  * Revision 5.1  1991/04/21  11:58:25  eggert  * Don't put , just before } in initializer.  *  * Revision 5.0  1990/08/22  08:12:54  eggert  * Add -k.  Ansify and Posixate.  *  * Revision 4.3  89/05/01  15:13:02  narten  * changed copyright header to reflect current distribution rules  *  * Revision 4.2  87/10/18  10:36:33  narten  * Updating version numbers. Changes relative to 1.1 actuallyt  * relative to 4.1  *  * Revision 1.2  87/09/24  14:00:10  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf  * warnings)  *  * Revision 4.1  83/05/04  10:06:53  wft  * Initial revision.  *  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_macro
name|libId
argument_list|(
argument|keysId
argument_list|,
literal|"$FreeBSD$"
argument_list|)
end_macro

begin_decl_stmt
name|char
specifier|const
modifier|*
specifier|const
name|Keyword
index|[]
init|=
block|{
comment|/* This must be in the same order as rcsbase.h's enum markers type. */
literal|0
block|,
name|AUTHOR
block|,
name|DATE
block|,
name|HEADER
block|,
name|IDH
block|,
name|LOCKER
block|,
name|LOG
block|,
name|NAME
block|,
name|RCSFILE
block|,
name|REVISION
block|,
name|SOURCE
block|,
name|STATE
block|,
name|FREEBSD
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expand all keywords by default */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ExpandKeyword
index|[]
init|=
block|{
name|false
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|false
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|enum
name|markers
name|trymatch
parameter_list|(
name|string
parameter_list|)
name|char
specifier|const
modifier|*
name|string
decl_stmt|;
comment|/* function: Checks whether string starts with a keyword followed  * by a KDELIM or a VDELIM.  * If successful, returns the appropriate marker, otherwise Nomatch.  */
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|j
operator|=
sizeof|sizeof
argument_list|(
name|Keyword
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|Keyword
argument_list|)
init|;
operator|(
operator|--
name|j
operator|)
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|ExpandKeyword
index|[
name|j
index|]
condition|)
continue|continue;
comment|/* try next keyword */
name|p
operator|=
name|Keyword
index|[
name|j
index|]
expr_stmt|;
name|s
operator|=
name|string
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|==
operator|*
name|s
operator|++
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|p
condition|)
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
name|KDELIM
case|:
case|case
name|VDELIM
case|:
return|return
operator|(
expr|enum
name|markers
operator|)
name|j
return|;
default|default:
return|return
name|Nomatch
return|;
block|}
block|}
block|}
return|return
operator|(
name|Nomatch
operator|)
return|;
block|}
end_function

begin_macro
name|setIncExc
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sets up the ExpandKeyword table according to command-line flags */
end_comment

begin_block
block|{
name|char
modifier|*
name|key
decl_stmt|;
name|int
name|include
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
name|arg
operator|+=
literal|2
expr_stmt|;
switch|switch
condition|(
operator|*
name|arg
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|include
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|include
operator|=
name|true
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|false
operator|)
return|;
block|}
if|if
condition|(
name|include
condition|)
for|for
control|(
name|j
operator|=
sizeof|sizeof
argument_list|(
name|Keyword
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|Keyword
argument_list|)
init|;
operator|(
operator|--
name|j
operator|)
condition|;
control|)
name|ExpandKeyword
index|[
name|j
index|]
operator|=
name|false
expr_stmt|;
name|key
operator|=
name|strtok
argument_list|(
name|arg
argument_list|,
literal|","
argument_list|)
expr_stmt|;
while|while
condition|(
name|key
condition|)
block|{
for|for
control|(
name|j
operator|=
sizeof|sizeof
argument_list|(
name|Keyword
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|Keyword
argument_list|)
init|;
operator|(
operator|--
name|j
operator|)
condition|;
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|Keyword
index|[
name|j
index|]
argument_list|)
condition|)
name|ExpandKeyword
index|[
name|j
index|]
operator|=
name|include
expr_stmt|;
name|key
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_block

end_unit

