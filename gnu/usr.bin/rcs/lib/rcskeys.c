begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* RCS keyword table and match operation */
end_comment

begin_comment
comment|/* Copyright 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991, 1992, 1993, 1995 Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/*  * Revision 5.4  1995/06/16 06:19:24  eggert  * Update FSF address.  *  * Revision 5.3  1993/11/03 17:42:27  eggert  * Add Name keyword.  *  * Revision 5.2  1991/08/19  03:13:55  eggert  * Say `T const' instead of `const T'; it's less confusing for pointer types.  * (This change was made in other source files too.)  *  * Revision 5.1  1991/04/21  11:58:25  eggert  * Don't put , just before } in initializer.  *  * Revision 5.0  1990/08/22  08:12:54  eggert  * Add -k.  Ansify and Posixate.  *  * Revision 4.3  89/05/01  15:13:02  narten  * changed copyright header to reflect current distribution rules  *  * Revision 4.2  87/10/18  10:36:33  narten  * Updating version numbers. Changes relative to 1.1 actuallyt  * relative to 4.1  *  * Revision 1.2  87/09/24  14:00:10  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf  * warnings)  *  * Revision 4.1  83/05/04  10:06:53  wft  * Initial revision.  *  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_macro
name|libId
argument_list|(
argument|keysId
argument_list|,
literal|"$FreeBSD$"
argument_list|)
end_macro

begin_decl_stmt
name|char
specifier|const
modifier|*
name|Keyword
index|[]
init|=
block|{
comment|/* This must be in the same order as rcsbase.h's enum markers type. */
literal|0
block|,
name|AUTHOR
block|,
name|DATE
block|,
name|HEADER
block|,
name|IDH
block|,
name|LOCKER
block|,
name|LOG
block|,
name|NAME
block|,
name|RCSFILE
block|,
name|REVISION
block|,
name|SOURCE
block|,
name|STATE
block|,
name|CVSHEADER
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expand all keywords by default */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ExpandKeyword
index|[]
init|=
block|{
name|false
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|,
name|true
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|markers
name|LocalIdMode
init|=
name|Id
decl_stmt|;
end_decl_stmt

begin_function
name|enum
name|markers
name|trymatch
parameter_list|(
name|string
parameter_list|)
name|char
specifier|const
modifier|*
name|string
decl_stmt|;
comment|/* function: Checks whether string starts with a keyword followed  * by a KDELIM or a VDELIM.  * If successful, returns the appropriate marker, otherwise Nomatch.  */
block|{
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|char
specifier|const
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|j
operator|=
sizeof|sizeof
argument_list|(
name|Keyword
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|Keyword
argument_list|)
init|;
operator|(
operator|--
name|j
operator|)
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|ExpandKeyword
index|[
name|j
index|]
condition|)
continue|continue;
comment|/* try next keyword */
name|p
operator|=
name|Keyword
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
continue|continue;
name|s
operator|=
name|string
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|==
operator|*
name|s
operator|++
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|p
condition|)
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
name|KDELIM
case|:
case|case
name|VDELIM
case|:
return|return
operator|(
expr|enum
name|markers
operator|)
name|j
return|;
default|default:
return|return
name|Nomatch
return|;
block|}
block|}
block|}
return|return
operator|(
name|Nomatch
operator|)
return|;
block|}
end_function

begin_function
name|void
name|setIncExc
parameter_list|(
name|arg
parameter_list|)
name|char
specifier|const
modifier|*
name|arg
decl_stmt|;
comment|/* Sets up the ExpandKeyword table according to command-line flags */
block|{
name|char
modifier|*
name|key
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|include
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
name|copy
operator|=
name|strdup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|next
operator|=
name|copy
expr_stmt|;
switch|switch
condition|(
operator|*
name|next
operator|++
condition|)
block|{
case|case
literal|'e'
case|:
name|include
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|include
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|include
condition|)
for|for
control|(
name|j
operator|=
sizeof|sizeof
argument_list|(
name|Keyword
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|Keyword
argument_list|)
init|;
operator|(
operator|--
name|j
operator|)
condition|;
control|)
name|ExpandKeyword
index|[
name|j
index|]
operator|=
name|false
expr_stmt|;
name|key
operator|=
name|strtok
argument_list|(
name|next
argument_list|,
literal|","
argument_list|)
expr_stmt|;
while|while
condition|(
name|key
condition|)
block|{
for|for
control|(
name|j
operator|=
sizeof|sizeof
argument_list|(
name|Keyword
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|Keyword
argument_list|)
init|;
operator|(
operator|--
name|j
operator|)
condition|;
control|)
block|{
if|if
condition|(
name|Keyword
index|[
name|j
index|]
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|Keyword
index|[
name|j
index|]
argument_list|)
condition|)
name|ExpandKeyword
index|[
name|j
index|]
operator|=
name|include
expr_stmt|;
block|}
name|key
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|setRCSLocalId
parameter_list|(
name|string
parameter_list|)
name|char
specifier|const
modifier|*
name|string
decl_stmt|;
comment|/* function: sets local RCS id and RCSLOCALID envariable */
block|{
specifier|static
name|char
name|local_id
index|[
name|keylength
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|key
decl_stmt|;
name|int
name|j
decl_stmt|;
name|copy
operator|=
name|strdup
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|next
operator|=
name|copy
expr_stmt|;
name|key
operator|=
name|strtok
argument_list|(
name|next
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|key
argument_list|)
operator|>
name|keylength
condition|)
name|error
argument_list|(
literal|"LocalId is too long"
argument_list|)
expr_stmt|;
name|VOID
name|strcpy
argument_list|(
name|local_id
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|Keyword
index|[
name|LocalId
index|]
operator|=
name|local_id
expr_stmt|;
comment|/* options? */
while|while
condition|(
name|key
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|Keyword
index|[
name|Id
index|]
argument_list|)
condition|)
name|LocalIdMode
operator|=
name|Id
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|Keyword
index|[
name|Header
index|]
argument_list|)
condition|)
name|LocalIdMode
operator|=
name|Header
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|Keyword
index|[
name|CVSHeader
index|]
argument_list|)
condition|)
name|LocalIdMode
operator|=
name|CVSHeader
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Unknown LocalId mode"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

