begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * PARTIME		parse date/time string into a TM structure  *  * Returns:  *	0 if parsing failed  *	else time values in specified TM structure and zone (unspecified values  *		set to TMNULL)  * Notes:  *	This code is quasi-public; it may be used freely in like software.  *	It is not to be sold, nor used in licensed software without  *	permission of the author.  *	For everyone's benefit, please report bugs and improvements!  * 	Copyright 1980 by Ken Harrenstien, SRI International.  *	(ARPANET: KLH @ SRI)  */
end_comment

begin_comment
comment|/* Hacknotes:  *	If parsing changed so that no backup needed, could perhaps modify  *		to use a FILE input stream.  Need terminator, though.  *	Perhaps should return 0 on success, else a non-zero error val?  */
end_comment

begin_comment
comment|/* $Log: partime.c,v $  * Revision 5.6  1991/08/19  03:13:55  eggert  * Update timezones.  *  * Revision 5.5  1991/04/21  11:58:18  eggert  * Don't put , just before } in initializer.  *  * Revision 5.4  1990/10/04  06:30:15  eggert  * Remove date vs time heuristics that fail between 2000 and 2400.  * Check for overflow when lexing an integer.  * Parse 'Jan 10 LT' as 'Jan 10, LT', not 'Jan, 10 LT'.  *  * Revision 5.3  1990/09/24  18:56:31  eggert  * Update timezones.  *  * Revision 5.2  1990/09/04  08:02:16  eggert  * Don't parse two-digit years, because it won't work after 1999/12/31.  * Don't permit 'Aug Aug'.  *  * Revision 5.1  1990/08/29  07:13:49  eggert  * Be able to parse our own date format.  Don't assume year<10000.  *  * Revision 5.0  1990/08/22  08:12:40  eggert  * Switch to GMT and fix the bugs exposed thereby.  Update timezones.  * Ansify and Posixate.  Fix peekahead and int-size bugs.  *  * Revision 1.4  89/05/01  14:48:46  narten  * fixed #ifdef DEBUG construct  *   * Revision 1.3  88/08/28  14:53:40  eggert  * Remove unportable "#endif XXX"s.  *   * Revision 1.2  87/03/27  14:21:53  jenkins  * Port to suns  *   * Revision 1.1  82/05/06  11:38:26  wft  * Initial revision  *   */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_macro
name|libId
argument_list|(
argument|partId
argument_list|,
literal|"$Id: partime.c,v 5.6 1991/08/19 03:13:55 eggert Exp $"
argument_list|)
end_macro

begin_define
define|#
directive|define
name|given
parameter_list|(
name|v
parameter_list|)
value|(0<= (v))
end_define

begin_define
define|#
directive|define
name|TMNULL
value|(-1)
end_define

begin_comment
comment|/* Items not given are given this value */
end_comment

begin_define
define|#
directive|define
name|TZ_OFFSET
value|(24*60)
end_define

begin_comment
comment|/* TMNULL<  zone_offset - TZ_OFFSET */
end_comment

begin_struct
struct|struct
name|tmwent
block|{
name|char
specifier|const
modifier|*
name|went
decl_stmt|;
name|short
name|wval
decl_stmt|;
name|char
name|wflgs
decl_stmt|;
name|char
name|wtype
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* wflgs */
end_comment

begin_define
define|#
directive|define
name|TWTIME
value|02
end_define

begin_comment
comment|/* Word is a time value (absence implies date) */
end_comment

begin_define
define|#
directive|define
name|TWDST
value|04
end_define

begin_comment
comment|/* Word is a DST-type timezone */
end_comment

begin_comment
comment|/* wtype */
end_comment

begin_define
define|#
directive|define
name|TM_MON
value|1
end_define

begin_comment
comment|/* month name */
end_comment

begin_define
define|#
directive|define
name|TM_WDAY
value|2
end_define

begin_comment
comment|/* weekday name */
end_comment

begin_define
define|#
directive|define
name|TM_ZON
value|3
end_define

begin_comment
comment|/* time zone name */
end_comment

begin_define
define|#
directive|define
name|TM_LT
value|4
end_define

begin_comment
comment|/* local time */
end_comment

begin_define
define|#
directive|define
name|TM_DST
value|5
end_define

begin_comment
comment|/* daylight savings time */
end_comment

begin_define
define|#
directive|define
name|TM_12
value|6
end_define

begin_comment
comment|/* AM, PM, NOON, or MIDNIGHT */
end_comment

begin_comment
comment|/* wval (for wtype==TM_12) */
end_comment

begin_define
define|#
directive|define
name|T12_AM
value|1
end_define

begin_define
define|#
directive|define
name|T12_PM
value|2
end_define

begin_define
define|#
directive|define
name|T12_NOON
value|12
end_define

begin_define
define|#
directive|define
name|T12_MIDNIGHT
value|0
end_define

begin_decl_stmt
specifier|static
name|struct
name|tmwent
specifier|const
name|tmwords
index|[]
init|=
block|{
block|{
literal|"january"
block|,
literal|0
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"february"
block|,
literal|1
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"march"
block|,
literal|2
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"april"
block|,
literal|3
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"may"
block|,
literal|4
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"june"
block|,
literal|5
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"july"
block|,
literal|6
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"august"
block|,
literal|7
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"september"
block|,
literal|8
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"october"
block|,
literal|9
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"november"
block|,
literal|10
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"december"
block|,
literal|11
block|,
literal|0
block|,
name|TM_MON
block|}
block|,
block|{
literal|"sunday"
block|,
literal|0
block|,
literal|0
block|,
name|TM_WDAY
block|}
block|,
block|{
literal|"monday"
block|,
literal|1
block|,
literal|0
block|,
name|TM_WDAY
block|}
block|,
block|{
literal|"tuesday"
block|,
literal|2
block|,
literal|0
block|,
name|TM_WDAY
block|}
block|,
block|{
literal|"wednesday"
block|,
literal|3
block|,
literal|0
block|,
name|TM_WDAY
block|}
block|,
block|{
literal|"thursday"
block|,
literal|4
block|,
literal|0
block|,
name|TM_WDAY
block|}
block|,
block|{
literal|"friday"
block|,
literal|5
block|,
literal|0
block|,
name|TM_WDAY
block|}
block|,
block|{
literal|"saturday"
block|,
literal|6
block|,
literal|0
block|,
name|TM_WDAY
block|}
block|,
block|{
literal|"gmt"
block|,
literal|0
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Greenwich */
block|{
literal|"utc"
block|,
literal|0
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
block|{
literal|"ut"
block|,
literal|0
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
block|{
literal|"cut"
block|,
literal|0
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
block|{
literal|"nzst"
block|,
operator|-
literal|12
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* New Zealand */
block|{
literal|"jst"
block|,
operator|-
literal|9
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Japan */
block|{
literal|"kst"
block|,
operator|-
literal|9
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Korea */
block|{
literal|"ist"
block|,
operator|-
literal|5
operator|*
literal|60
operator|-
literal|30
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* India */
block|{
literal|"eet"
block|,
operator|-
literal|2
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Eastern Europe */
block|{
literal|"cet"
block|,
operator|-
literal|1
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Central Europe */
block|{
literal|"met"
block|,
operator|-
literal|1
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Middle Europe */
block|{
literal|"wet"
block|,
literal|0
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Western Europe */
block|{
literal|"nst"
block|,
literal|3
operator|*
literal|60
operator|+
literal|30
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Newfoundland */
block|{
literal|"ast"
block|,
literal|4
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Atlantic */
block|{
literal|"est"
block|,
literal|5
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Eastern */
block|{
literal|"cst"
block|,
literal|6
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Central */
block|{
literal|"mst"
block|,
literal|7
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Mountain */
block|{
literal|"pst"
block|,
literal|8
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Pacific */
block|{
literal|"akst"
block|,
literal|9
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Alaska */
block|{
literal|"hast"
block|,
literal|10
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Hawaii-Aleutian */
block|{
literal|"hst"
block|,
literal|10
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Hawaii */
block|{
literal|"sst"
block|,
literal|11
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_ZON
block|}
block|,
comment|/* Samoa */
block|{
literal|"nzdt"
block|,
operator|-
literal|12
operator|*
literal|60
block|,
name|TWTIME
operator|+
name|TWDST
block|,
name|TM_ZON
block|}
block|,
comment|/* New Zealand */
block|{
literal|"kdt"
block|,
operator|-
literal|9
operator|*
literal|60
block|,
name|TWTIME
operator|+
name|TWDST
block|,
name|TM_ZON
block|}
block|,
comment|/* Korea */
block|{
literal|"bst"
block|,
literal|0
operator|*
literal|60
block|,
name|TWTIME
operator|+
name|TWDST
block|,
name|TM_ZON
block|}
block|,
comment|/* Britain */
block|{
literal|"ndt"
block|,
literal|3
operator|*
literal|60
operator|+
literal|30
block|,
name|TWTIME
operator|+
name|TWDST
block|,
name|TM_ZON
block|}
block|,
comment|/* Newfoundland */
block|{
literal|"adt"
block|,
literal|4
operator|*
literal|60
block|,
name|TWTIME
operator|+
name|TWDST
block|,
name|TM_ZON
block|}
block|,
comment|/* Atlantic */
block|{
literal|"edt"
block|,
literal|5
operator|*
literal|60
block|,
name|TWTIME
operator|+
name|TWDST
block|,
name|TM_ZON
block|}
block|,
comment|/* Eastern */
block|{
literal|"cdt"
block|,
literal|6
operator|*
literal|60
block|,
name|TWTIME
operator|+
name|TWDST
block|,
name|TM_ZON
block|}
block|,
comment|/* Central */
block|{
literal|"mdt"
block|,
literal|7
operator|*
literal|60
block|,
name|TWTIME
operator|+
name|TWDST
block|,
name|TM_ZON
block|}
block|,
comment|/* Mountain */
block|{
literal|"pdt"
block|,
literal|8
operator|*
literal|60
block|,
name|TWTIME
operator|+
name|TWDST
block|,
name|TM_ZON
block|}
block|,
comment|/* Pacific */
block|{
literal|"akdt"
block|,
literal|9
operator|*
literal|60
block|,
name|TWTIME
operator|+
name|TWDST
block|,
name|TM_ZON
block|}
block|,
comment|/* Alaska */
block|{
literal|"hadt"
block|,
literal|10
operator|*
literal|60
block|,
name|TWTIME
operator|+
name|TWDST
block|,
name|TM_ZON
block|}
block|,
comment|/* Hawaii-Aleutian */
if|#
directive|if
literal|0
comment|/* 	 * The following names are duplicates or are not well attested. 	 * A standard is needed. 	 */
block|{"east",        -10*60, TWTIME, TM_ZON},
comment|/* Eastern Australia */
block|{"cast",        -9*60-30, TWTIME, TM_ZON},
comment|/* Central Australia */
block|{"cst",         -8*60, TWTIME, TM_ZON},
comment|/* China */
block|{"hkt",         -8*60, TWTIME, TM_ZON},
comment|/* Hong Kong */
block|{"sst",         -8*60, TWTIME, TM_ZON},
comment|/* Singapore */
block|{"wast",        -8*60, TWTIME, TM_ZON},
comment|/* Western Australia */
block|{"?",		-6*60-30, TWTIME, TM_ZON},
comment|/* Burma */
block|{"?",           -4*60-30, TWTIME, TM_ZON},
comment|/* Afghanistan */
block|{"it",          -3*60-30, TWTIME, TM_ZON},
comment|/* Iran */
block|{"ist",         -2*60, TWTIME, TM_ZON},
comment|/* Israel */
block|{"mez",		-1*60, TWTIME, TM_ZON},
comment|/* Mittel-Europaeische Zeit */
block|{"ast",          1*60, TWTIME, TM_ZON},
comment|/* Azores */
block|{"fst",          2*60, TWTIME, TM_ZON},
comment|/* Fernando de Noronha */
block|{"bst",          3*60, TWTIME, TM_ZON},
comment|/* Brazil */
block|{"wst",          4*60, TWTIME, TM_ZON},
comment|/* Western Brazil */
block|{"ast",          5*60, TWTIME, TM_ZON},
comment|/* Acre Brazil */
block|{"?",            9*60+30, TWTIME, TM_ZON},
comment|/* Marquesas */
block|{"?",		 12*60, TWTIME, TM_ZON},
comment|/* Kwajalein */
block|{"eadt",        -10*60, TWTIME+TWDST, TM_ZON},
comment|/* Eastern Australia */
block|{"cadt",        -9*60-30, TWTIME+TWDST, TM_ZON},
comment|/* Central Australia */
block|{"cdt",         -8*60, TWTIME+TWDST, TM_ZON},
comment|/* China */
block|{"wadt",        -8*60, TWTIME+TWDST, TM_ZON},
comment|/* Western Australia */
block|{"idt",         -2*60, TWTIME+TWDST, TM_ZON},
comment|/* Israel */
block|{"eest",        -2*60, TWTIME+TWDST, TM_ZON},
comment|/* Eastern Europe */
block|{"cest",        -1*60, TWTIME+TWDST, TM_ZON},
comment|/* Central Europe */
block|{"mest",        -1*60, TWTIME+TWDST, TM_ZON},
comment|/* Middle Europe */
block|{"mesz",	-1*60, TWTIME+TWDST, TM_ZON},
comment|/* Mittel-Europaeische Sommerzeit */
block|{"west",         0*60, TWTIME+TWDST, TM_ZON},
comment|/* Western Europe */
block|{"adt",          1*60, TWTIME+TWDST, TM_ZON},
comment|/* Azores */
block|{"fdt",          2*60, TWTIME+TWDST, TM_ZON},
comment|/* Fernando de Noronha */
block|{"edt",          3*60, TWTIME+TWDST, TM_ZON},
comment|/* Eastern Brazil */
block|{"wdt",          4*60, TWTIME+TWDST, TM_ZON},
comment|/* Western Brazil */
block|{"adt",          5*60, TWTIME+TWDST, TM_ZON},
comment|/* Acre Brazil */
endif|#
directive|endif
block|{
literal|"lt"
block|,
literal|0
block|,
name|TWTIME
block|,
name|TM_LT
block|}
block|,
comment|/* local time */
block|{
literal|"dst"
block|,
literal|1
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_DST
block|}
block|,
comment|/* daylight savings time */
block|{
literal|"ddst"
block|,
literal|2
operator|*
literal|60
block|,
name|TWTIME
block|,
name|TM_DST
block|}
block|,
comment|/* double dst */
block|{
literal|"am"
block|,
name|T12_AM
block|,
name|TWTIME
block|,
name|TM_12
block|}
block|,
block|{
literal|"pm"
block|,
name|T12_PM
block|,
name|TWTIME
block|,
name|TM_12
block|}
block|,
block|{
literal|"noon"
block|,
name|T12_NOON
block|,
name|TWTIME
block|,
name|TM_12
block|}
block|,
block|{
literal|"midnight"
block|,
name|T12_MIDNIGHT
block|,
name|TWTIME
block|,
name|TM_12
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|/* Zero entry to terminate searches */
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|token
block|{
name|char
specifier|const
modifier|*
name|tcp
decl_stmt|;
comment|/* pointer to string */
name|int
name|tcnt
decl_stmt|;
comment|/* # chars */
name|char
name|tbrk
decl_stmt|;
comment|/* "break" char */
name|char
name|tbrkl
decl_stmt|;
comment|/* last break char */
name|char
name|tflg
decl_stmt|;
comment|/* 0 = alpha, 1 = numeric */
union|union
block|{
comment|/* Resulting value; */
name|int
name|tnum
decl_stmt|;
comment|/* either a #, or */
name|struct
name|tmwent
specifier|const
modifier|*
name|ttmw
decl_stmt|;
comment|/* a ptr to a tmwent.  */
block|}
name|tval
union|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|tmwent
specifier|const
modifier|*
name|ptmatchstr
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|int
operator|,
expr|struct
name|tmwent
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pt12hack
name|P
argument_list|(
operator|(
expr|struct
name|tm
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ptitoken
name|P
argument_list|(
operator|(
expr|struct
name|token
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ptstash
name|P
argument_list|(
operator|(
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pttoken
name|P
argument_list|(
operator|(
expr|struct
name|token
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|goodzone
parameter_list|(
name|t
parameter_list|,
name|offset
parameter_list|,
name|am
parameter_list|)
specifier|register
name|struct
name|token
specifier|const
modifier|*
name|t
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
modifier|*
name|am
decl_stmt|;
block|{
specifier|register
name|int
name|m
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|tflg
operator|&&
name|t
operator|->
name|tcnt
operator|==
literal|4
operator|+
name|offset
operator|&&
operator|(
name|m
operator|=
name|t
operator|->
name|tval
operator|.
name|tnum
operator|)
operator|<=
literal|2400
operator|&&
name|isdigit
argument_list|(
name|t
operator|->
name|tcp
index|[
name|offset
index|]
argument_list|)
operator|&&
operator|(
name|m
operator|%=
literal|100
operator|)
operator|<
literal|60
condition|)
block|{
name|m
operator|+=
name|t
operator|->
name|tval
operator|.
name|tnum
operator|/
literal|100
operator|*
literal|60
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|tcp
index|[
name|offset
operator|-
literal|1
index|]
operator|==
literal|'+'
condition|)
name|m
operator|=
operator|-
name|m
expr_stmt|;
operator|*
name|am
operator|=
name|m
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|partime
parameter_list|(
name|astr
parameter_list|,
name|atm
parameter_list|,
name|zone
parameter_list|)
name|char
specifier|const
modifier|*
name|astr
decl_stmt|;
specifier|register
name|struct
name|tm
modifier|*
name|atm
decl_stmt|;
name|int
modifier|*
name|zone
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|token
name|btoken
decl_stmt|,
name|atoken
decl_stmt|;
name|int
name|zone_offset
decl_stmt|;
comment|/* minutes west of GMT, plus TZ_OFFSET */
specifier|register
name|char
specifier|const
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|;
name|int
name|ord
decl_stmt|,
name|midnoon
decl_stmt|;
name|int
modifier|*
name|atmfield
decl_stmt|,
name|dst
decl_stmt|,
name|m
decl_stmt|;
name|int
name|got1
init|=
literal|0
decl_stmt|;
name|atm
operator|->
name|tm_sec
operator|=
name|TMNULL
expr_stmt|;
name|atm
operator|->
name|tm_min
operator|=
name|TMNULL
expr_stmt|;
name|atm
operator|->
name|tm_hour
operator|=
name|TMNULL
expr_stmt|;
name|atm
operator|->
name|tm_mday
operator|=
name|TMNULL
expr_stmt|;
name|atm
operator|->
name|tm_mon
operator|=
name|TMNULL
expr_stmt|;
name|atm
operator|->
name|tm_year
operator|=
name|TMNULL
expr_stmt|;
name|atm
operator|->
name|tm_wday
operator|=
name|TMNULL
expr_stmt|;
name|atm
operator|->
name|tm_yday
operator|=
name|TMNULL
expr_stmt|;
name|midnoon
operator|=
name|TMNULL
expr_stmt|;
comment|/* and our own temp stuff */
name|zone_offset
operator|=
name|TMNULL
expr_stmt|;
name|dst
operator|=
name|TMNULL
expr_stmt|;
name|btoken
operator|.
name|tcnt
operator|=
name|btoken
operator|.
name|tbrk
operator|=
literal|0
expr_stmt|;
name|btoken
operator|.
name|tcp
operator|=
name|astr
expr_stmt|;
for|for
control|(
init|;
condition|;
name|got1
operator|=
literal|1
control|)
block|{
if|if
condition|(
operator|!
name|ptitoken
argument_list|(
operator|&
name|btoken
argument_list|)
condition|)
comment|/* Get a token */
block|{
if|if
condition|(
name|btoken
operator|.
name|tval
operator|.
name|tnum
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Read error? */
if|if
condition|(
name|given
argument_list|(
name|midnoon
argument_list|)
condition|)
comment|/* EOF, wrap up */
if|if
condition|(
operator|!
name|pt12hack
argument_list|(
name|atm
argument_list|,
name|midnoon
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|given
argument_list|(
name|atm
operator|->
name|tm_min
argument_list|)
condition|)
name|atm
operator|->
name|tm_min
operator|=
literal|0
expr_stmt|;
operator|*
name|zone
operator|=
operator|(
name|given
argument_list|(
name|zone_offset
argument_list|)
condition|?
name|zone_offset
operator|-
name|TZ_OFFSET
else|:
literal|0
operator|)
operator|-
operator|(
name|given
argument_list|(
name|dst
argument_list|)
condition|?
name|dst
else|:
literal|0
operator|)
expr_stmt|;
return|return
name|got1
return|;
block|}
if|if
condition|(
name|btoken
operator|.
name|tflg
operator|==
literal|0
condition|)
comment|/* Alpha? */
block|{
name|i
operator|=
name|btoken
operator|.
name|tval
operator|.
name|ttmw
operator|->
name|wval
expr_stmt|;
switch|switch
condition|(
name|btoken
operator|.
name|tval
operator|.
name|ttmw
operator|->
name|wtype
condition|)
block|{
default|default:
return|return
literal|0
return|;
case|case
name|TM_MON
case|:
name|atmfield
operator|=
operator|&
name|atm
operator|->
name|tm_mon
expr_stmt|;
break|break;
case|case
name|TM_WDAY
case|:
name|atmfield
operator|=
operator|&
name|atm
operator|->
name|tm_wday
expr_stmt|;
break|break;
case|case
name|TM_DST
case|:
name|atmfield
operator|=
operator|&
name|dst
expr_stmt|;
break|break;
case|case
name|TM_LT
case|:
if|if
condition|(
name|ptstash
argument_list|(
operator|&
name|dst
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
name|i
operator|=
literal|48
operator|*
literal|60
expr_stmt|;
comment|/* local time magic number -- see maketime() */
comment|/* fall into */
case|case
name|TM_ZON
case|:
name|i
operator|+=
name|TZ_OFFSET
expr_stmt|;
if|if
condition|(
name|btoken
operator|.
name|tval
operator|.
name|ttmw
operator|->
name|wflgs
operator|&
name|TWDST
condition|)
if|if
condition|(
name|ptstash
argument_list|(
operator|&
name|dst
argument_list|,
literal|60
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Peek ahead for offset immediately afterwards. */
if|if
condition|(
operator|(
name|btoken
operator|.
name|tbrk
operator|==
literal|'-'
operator|||
name|btoken
operator|.
name|tbrk
operator|==
literal|'+'
operator|)
operator|&&
operator|(
name|atoken
operator|=
name|btoken
operator|,
operator|++
name|atoken
operator|.
name|tcnt
operator|,
name|ptitoken
argument_list|(
operator|&
name|atoken
argument_list|)
operator|)
operator|&&
name|goodzone
argument_list|(
operator|&
name|atoken
argument_list|,
literal|0
argument_list|,
operator|&
name|m
argument_list|)
condition|)
block|{
name|i
operator|+=
name|m
expr_stmt|;
name|btoken
operator|=
name|atoken
expr_stmt|;
block|}
name|atmfield
operator|=
operator|&
name|zone_offset
expr_stmt|;
break|break;
case|case
name|TM_12
case|:
name|atmfield
operator|=
operator|&
name|midnoon
expr_stmt|;
block|}
if|if
condition|(
name|ptstash
argument_list|(
name|atmfield
argument_list|,
name|i
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: val already set */
continue|continue;
block|}
comment|/* Token is number.  Lots of hairy heuristics. */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|btoken
operator|.
name|tcp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|goodzone
argument_list|(
operator|&
name|btoken
argument_list|,
literal|1
argument_list|,
operator|&
name|m
argument_list|)
condition|)
return|return
literal|0
return|;
name|zone_offset
operator|=
name|TZ_OFFSET
operator|+
name|m
expr_stmt|;
continue|continue;
block|}
name|i
operator|=
name|btoken
operator|.
name|tval
operator|.
name|tnum
expr_stmt|;
comment|/* Value now known to be valid; get it. */
if|if
condition|(
name|btoken
operator|.
name|tcnt
operator|==
literal|3
condition|)
comment|/*  3 digits = HMM   */
block|{
name|hhmm4
label|:
if|if
condition|(
name|ptstash
argument_list|(
operator|&
name|atm
operator|->
name|tm_min
argument_list|,
name|i
operator|%
literal|100
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: min conflict */
name|i
operator|/=
literal|100
expr_stmt|;
name|hh2
label|:
if|if
condition|(
name|ptstash
argument_list|(
operator|&
name|atm
operator|->
name|tm_hour
argument_list|,
name|i
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: hour conflict */
continue|continue;
block|}
if|if
condition|(
literal|4
operator|<
name|btoken
operator|.
name|tcnt
condition|)
goto|goto
name|year4
goto|;
comment|/* far in the future */
if|if
condition|(
name|btoken
operator|.
name|tcnt
operator|==
literal|4
condition|)
comment|/* 4 digits = YEAR or HHMM */
block|{
if|if
condition|(
name|given
argument_list|(
name|atm
operator|->
name|tm_year
argument_list|)
condition|)
goto|goto
name|hhmm4
goto|;
comment|/* Already got yr? */
if|if
condition|(
name|given
argument_list|(
name|atm
operator|->
name|tm_hour
argument_list|)
condition|)
goto|goto
name|year4
goto|;
comment|/* Already got hr? */
if|if
condition|(
name|btoken
operator|.
name|tbrk
operator|==
literal|':'
condition|)
comment|/* HHMM:SS ? */
if|if
condition|(
name|ptstash
argument_list|(
operator|&
name|atm
operator|->
name|tm_hour
argument_list|,
name|i
operator|/
literal|100
argument_list|)
operator|||
name|ptstash
argument_list|(
operator|&
name|atm
operator|->
name|tm_min
argument_list|,
name|i
operator|%
literal|100
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: hr/min clash */
else|else
goto|goto
name|coltm2
goto|;
comment|/* Go handle SS */
if|if
condition|(
name|btoken
operator|.
name|tbrk
operator|!=
literal|','
operator|&&
name|btoken
operator|.
name|tbrk
operator|!=
literal|'/'
operator|&&
operator|(
name|atoken
operator|=
name|btoken
operator|,
name|ptitoken
argument_list|(
operator|&
name|atoken
argument_list|)
operator|)
comment|/* Peek */
operator|&&
operator|(
name|atoken
operator|.
name|tflg
condition|?
operator|!
name|isdigit
argument_list|(
operator|*
name|atoken
operator|.
name|tcp
argument_list|)
else|:
name|atoken
operator|.
name|tval
operator|.
name|ttmw
operator|->
name|wflgs
operator|&
name|TWTIME
operator|)
condition|)
comment|/* HHMM-ZON */
goto|goto
name|hhmm4
goto|;
goto|goto
name|year4
goto|;
comment|/* Give up, assume year. */
block|}
comment|/* From this point on, assume tcnt == 1 or 2 */
comment|/* 2 digits = MM, DD, or HH (MM and SS caught at coltime) */
if|if
condition|(
name|btoken
operator|.
name|tbrk
operator|==
literal|':'
condition|)
comment|/* HH:MM[:SS] */
goto|goto
name|coltime
goto|;
comment|/*  must be part of time. */
if|if
condition|(
literal|31
operator|<
name|i
condition|)
return|return
literal|0
return|;
comment|/* Check for numerical-format date */
for|for
control|(
name|cp
operator|=
literal|"/-."
init|;
name|ch
operator|=
operator|*
name|cp
operator|++
condition|;
control|)
block|{
name|ord
operator|=
operator|(
name|ch
operator|==
literal|'.'
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
comment|/* n/m = D/M or M/D */
if|if
condition|(
name|btoken
operator|.
name|tbrk
operator|==
name|ch
condition|)
comment|/* "NN-" */
block|{
if|if
condition|(
name|btoken
operator|.
name|tbrkl
operator|!=
name|ch
condition|)
block|{
name|atoken
operator|=
name|btoken
expr_stmt|;
name|atoken
operator|.
name|tcnt
operator|++
expr_stmt|;
if|if
condition|(
name|ptitoken
argument_list|(
operator|&
name|atoken
argument_list|)
operator|&&
name|atoken
operator|.
name|tflg
operator|==
literal|0
operator|&&
name|atoken
operator|.
name|tval
operator|.
name|ttmw
operator|->
name|wtype
operator|==
name|TM_MON
condition|)
goto|goto
name|dd2
goto|;
if|if
condition|(
name|ord
condition|)
goto|goto
name|mm2
goto|;
else|else
goto|goto
name|dd2
goto|;
comment|/* "NN-" */
block|}
comment|/* "-NN-" */
if|if
condition|(
operator|!
name|given
argument_list|(
name|atm
operator|->
name|tm_mday
argument_list|)
operator|&&
name|given
argument_list|(
name|atm
operator|->
name|tm_year
argument_list|)
condition|)
comment|/* If "YYYY-NN-" */
goto|goto
name|mm2
goto|;
comment|/* then always MM */
if|if
condition|(
name|ord
condition|)
goto|goto
name|dd2
goto|;
else|else
goto|goto
name|mm2
goto|;
block|}
if|if
condition|(
name|btoken
operator|.
name|tbrkl
operator|==
name|ch
comment|/* "-NN" */
operator|&&
name|given
argument_list|(
name|ord
condition|?
name|atm
operator|->
name|tm_mon
else|:
name|atm
operator|->
name|tm_mday
argument_list|)
condition|)
if|if
condition|(
operator|!
name|given
argument_list|(
name|ord
condition|?
name|atm
operator|->
name|tm_mday
else|:
name|atm
operator|->
name|tm_mon
argument_list|)
condition|)
comment|/* MM/DD */
if|if
condition|(
name|ord
condition|)
goto|goto
name|dd2
goto|;
else|else
goto|goto
name|mm2
goto|;
block|}
comment|/* Now reduced to choice between HH and DD */
if|if
condition|(
name|given
argument_list|(
name|atm
operator|->
name|tm_hour
argument_list|)
condition|)
goto|goto
name|dd2
goto|;
comment|/* Have hour? Assume day. */
if|if
condition|(
name|given
argument_list|(
name|atm
operator|->
name|tm_mday
argument_list|)
condition|)
goto|goto
name|hh2
goto|;
comment|/* Have day? Assume hour. */
if|if
condition|(
name|given
argument_list|(
name|atm
operator|->
name|tm_mon
argument_list|)
condition|)
goto|goto
name|dd2
goto|;
comment|/* Have month? Assume day. */
if|if
condition|(
name|i
operator|>
literal|24
condition|)
goto|goto
name|dd2
goto|;
comment|/* Impossible HH means DD */
name|atoken
operator|=
name|btoken
expr_stmt|;
if|if
condition|(
operator|!
name|ptitoken
argument_list|(
operator|&
name|atoken
argument_list|)
condition|)
comment|/* Read ahead! */
if|if
condition|(
name|atoken
operator|.
name|tval
operator|.
name|tnum
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: bad token */
else|else
goto|goto
name|dd2
goto|;
comment|/* EOF, assume day. */
if|if
condition|(
name|atoken
operator|.
name|tflg
condition|?
operator|!
name|isdigit
argument_list|(
operator|*
name|atoken
operator|.
name|tcp
argument_list|)
else|:
name|atoken
operator|.
name|tval
operator|.
name|ttmw
operator|->
name|wflgs
operator|&
name|TWTIME
condition|)
comment|/* If next token is a time spec, assume hour */
goto|goto
name|hh2
goto|;
comment|/* e.g. "3 PM", "11-EDT"  */
name|dd2
label|:
if|if
condition|(
name|ptstash
argument_list|(
operator|&
name|atm
operator|->
name|tm_mday
argument_list|,
name|i
argument_list|)
condition|)
comment|/* Store day (1 based) */
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
name|mm2
label|:
if|if
condition|(
name|ptstash
argument_list|(
operator|&
name|atm
operator|->
name|tm_mon
argument_list|,
name|i
operator|-
literal|1
argument_list|)
condition|)
comment|/* Store month (make zero based) */
return|return
operator|(
literal|0
operator|)
return|;
continue|continue;
name|year4
label|:
if|if
condition|(
operator|(
name|i
operator|-=
literal|1900
operator|)
operator|<
literal|0
operator|||
name|ptstash
argument_list|(
operator|&
name|atm
operator|->
name|tm_year
argument_list|,
name|i
argument_list|)
condition|)
comment|/* Store year-1900 */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: year conflict */
continue|continue;
comment|/* Hack HH:MM[[:]SS] */
name|coltime
label|:
if|if
condition|(
name|ptstash
argument_list|(
operator|&
name|atm
operator|->
name|tm_hour
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|ptitoken
argument_list|(
operator|&
name|btoken
argument_list|)
condition|)
return|return
operator|(
operator|!
name|btoken
operator|.
name|tval
operator|.
name|tnum
operator|)
return|;
if|if
condition|(
operator|!
name|btoken
operator|.
name|tflg
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: HH:<alpha> */
if|if
condition|(
name|btoken
operator|.
name|tcnt
operator|==
literal|4
condition|)
comment|/* MMSS */
if|if
condition|(
name|ptstash
argument_list|(
operator|&
name|atm
operator|->
name|tm_min
argument_list|,
name|btoken
operator|.
name|tval
operator|.
name|tnum
operator|/
literal|100
argument_list|)
operator|||
name|ptstash
argument_list|(
operator|&
name|atm
operator|->
name|tm_sec
argument_list|,
name|btoken
operator|.
name|tval
operator|.
name|tnum
operator|%
literal|100
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
continue|continue;
if|if
condition|(
name|btoken
operator|.
name|tcnt
operator|!=
literal|2
operator|||
name|ptstash
argument_list|(
operator|&
name|atm
operator|->
name|tm_min
argument_list|,
name|btoken
operator|.
name|tval
operator|.
name|tnum
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: MM bad */
if|if
condition|(
name|btoken
operator|.
name|tbrk
operator|!=
literal|':'
condition|)
continue|continue;
comment|/* Seconds follow? */
name|coltm2
label|:
if|if
condition|(
operator|!
name|ptitoken
argument_list|(
operator|&
name|btoken
argument_list|)
condition|)
return|return
operator|(
operator|!
name|btoken
operator|.
name|tval
operator|.
name|tnum
operator|)
return|;
if|if
condition|(
operator|!
name|btoken
operator|.
name|tflg
operator|||
name|btoken
operator|.
name|tcnt
operator|!=
literal|2
comment|/* Verify SS */
operator|||
name|ptstash
argument_list|(
operator|&
name|atm
operator|->
name|tm_sec
argument_list|,
name|btoken
operator|.
name|tval
operator|.
name|tnum
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* ERR: SS bad */
block|}
block|}
end_function

begin_comment
comment|/* Store date/time value, return 0 if successful.  * Fail if entry is already set.  */
end_comment

begin_function
specifier|static
name|int
name|ptstash
parameter_list|(
name|adr
parameter_list|,
name|val
parameter_list|)
name|int
modifier|*
name|adr
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
specifier|register
name|int
modifier|*
name|a
decl_stmt|;
if|if
condition|(
name|given
argument_list|(
operator|*
operator|(
name|a
operator|=
name|adr
operator|)
argument_list|)
condition|)
return|return
literal|1
return|;
operator|*
name|a
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This subroutine is invoked for AM, PM, NOON and MIDNIGHT when wrapping up  * just prior to returning from partime.  */
end_comment

begin_function
specifier|static
name|int
name|pt12hack
parameter_list|(
name|tm
parameter_list|,
name|aval
parameter_list|)
specifier|register
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
specifier|register
name|int
name|aval
decl_stmt|;
block|{
specifier|register
name|int
name|h
init|=
name|tm
operator|->
name|tm_hour
decl_stmt|;
switch|switch
condition|(
name|aval
condition|)
block|{
case|case
name|T12_AM
case|:
case|case
name|T12_PM
case|:
if|if
condition|(
name|h
operator|>
literal|12
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|h
operator|==
literal|12
condition|)
name|tm
operator|->
name|tm_hour
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aval
operator|==
name|T12_PM
condition|)
name|tm
operator|->
name|tm_hour
operator|+=
literal|12
expr_stmt|;
break|break;
default|default:
if|if
condition|(
literal|0
operator|<
name|tm
operator|->
name|tm_min
operator|||
literal|0
operator|<
name|tm
operator|->
name|tm_sec
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|given
argument_list|(
name|h
argument_list|)
operator|||
name|h
operator|==
literal|12
condition|)
name|tm
operator|->
name|tm_hour
operator|=
name|aval
expr_stmt|;
elseif|else
if|if
condition|(
name|aval
operator|==
name|T12_MIDNIGHT
operator|&&
operator|(
name|h
operator|==
literal|0
operator|||
name|h
operator|==
literal|24
operator|)
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Get a token and identify it to some degree.  * Returns 0 on failure; token.tval will be 0 for normal EOF, otherwise  * hit error of some sort  */
end_comment

begin_function
specifier|static
name|int
name|ptitoken
parameter_list|(
name|tkp
parameter_list|)
specifier|register
name|struct
name|token
modifier|*
name|tkp
decl_stmt|;
block|{
specifier|register
name|char
specifier|const
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
operator|!
name|pttoken
argument_list|(
name|tkp
argument_list|)
condition|)
ifdef|#
directive|ifdef
name|DEBUG
block|{
name|VOID
name|printf
argument_list|(
literal|"EOF\n"
argument_list|)
decl_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
name|cp
operator|=
name|tkp
operator|->
name|tcp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|VOID
name|printf
argument_list|(
literal|"Token: \"%.*s\" "
argument_list|,
name|tkp
operator|->
name|tcnt
argument_list|,
name|cp
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tkp
operator|->
name|tflg
condition|)
block|{
name|i
operator|=
name|tkp
operator|->
name|tcnt
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'+'
operator|||
operator|*
name|cp
operator|==
literal|'-'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
while|while
condition|(
literal|0
operator|<=
operator|--
name|i
condition|)
block|{
name|j
operator|=
name|tkp
operator|->
name|tval
operator|.
name|tnum
operator|*
literal|10
expr_stmt|;
name|k
operator|=
name|j
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|j
operator|/
literal|10
operator|!=
name|tkp
operator|->
name|tval
operator|.
name|tnum
operator|||
name|k
operator|<
name|j
condition|)
block|{
comment|/* arithmetic overflow */
name|tkp
operator|->
name|tval
operator|.
name|tnum
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|tkp
operator|->
name|tval
operator|.
name|tnum
operator|=
name|k
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|tkp
operator|->
name|tval
operator|.
name|ttmw
operator|=
name|ptmatchstr
argument_list|(
name|cp
argument_list|,
name|tkp
operator|->
name|tcnt
argument_list|,
name|tmwords
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|VOID
name|printf
argument_list|(
literal|"Not found!\n"
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|tkp
operator|->
name|tval
operator|.
name|tnum
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|tkp
operator|->
name|tflg
condition|)
name|VOID
name|printf
argument_list|(
literal|"Val: %d.\n"
argument_list|,
name|tkp
operator|->
name|tval
operator|.
name|tnum
argument_list|)
decl_stmt|;
else|else
name|VOID
name|printf
argument_list|(
literal|"Found: \"%s\", val: %d, type %d\n"
argument_list|,
name|tkp
operator|->
name|tval
operator|.
name|ttmw
operator|->
name|went
argument_list|,
name|tkp
operator|->
name|tval
operator|.
name|ttmw
operator|->
name|wval
argument_list|,
name|tkp
operator|->
name|tval
operator|.
name|ttmw
operator|->
name|wtype
argument_list|)
decl_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read token from input string into token structure */
end_comment

begin_function
specifier|static
name|int
name|pttoken
parameter_list|(
name|tkp
parameter_list|)
specifier|register
name|struct
name|token
modifier|*
name|tkp
decl_stmt|;
block|{
specifier|register
name|char
specifier|const
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
specifier|const
modifier|*
name|astr
decl_stmt|;
name|tkp
operator|->
name|tcp
operator|=
name|astr
operator|=
name|cp
operator|=
name|tkp
operator|->
name|tcp
operator|+
name|tkp
operator|->
name|tcnt
expr_stmt|;
name|tkp
operator|->
name|tbrkl
operator|=
name|tkp
operator|->
name|tbrk
expr_stmt|;
comment|/* Set "last break" */
name|tkp
operator|->
name|tcnt
operator|=
name|tkp
operator|->
name|tbrk
operator|=
name|tkp
operator|->
name|tflg
operator|=
literal|0
expr_stmt|;
name|tkp
operator|->
name|tval
operator|.
name|tnum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|cp
operator|++
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
comment|/* Flush all whitespace */
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\v'
case|:
case|case
literal|'\f'
case|:
if|if
condition|(
operator|!
name|tkp
operator|->
name|tcnt
condition|)
block|{
comment|/* If no token yet */
name|tkp
operator|->
name|tcp
operator|=
name|cp
expr_stmt|;
comment|/* ignore the brk */
continue|continue;
comment|/* and go on. */
block|}
comment|/* fall into */
case|case
literal|'('
case|:
case|case
literal|')'
case|:
comment|/* Perhaps any non-alphanum */
case|case
literal|'-'
case|:
case|case
literal|','
case|:
comment|/* shd qualify as break? */
case|case
literal|'+'
case|:
case|case
literal|'/'
case|:
case|case
literal|':'
case|:
case|case
literal|'.'
case|:
comment|/* Break chars */
if|if
condition|(
name|tkp
operator|->
name|tcnt
operator|==
literal|0
condition|)
comment|/* If no token yet */
block|{
name|tkp
operator|->
name|tcp
operator|=
name|cp
expr_stmt|;
comment|/* ignore the brk */
name|tkp
operator|->
name|tbrkl
operator|=
name|c
expr_stmt|;
continue|continue;
comment|/* and go on. */
block|}
name|tkp
operator|->
name|tbrk
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|tkp
operator|->
name|tcnt
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|tkp
operator|->
name|tcnt
operator|++
condition|)
block|{
comment|/* If first char of token, */
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|tkp
operator|->
name|tflg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|astr
operator|<
name|cp
operator|-
literal|2
operator|&&
operator|(
name|cp
index|[
operator|-
literal|2
index|]
operator|==
literal|'-'
operator|||
name|cp
index|[
operator|-
literal|2
index|]
operator|==
literal|'+'
operator|)
condition|)
block|{
comment|/* timezone is break+sign+digit */
name|tkp
operator|->
name|tcp
operator|--
expr_stmt|;
name|tkp
operator|->
name|tcnt
operator|++
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|isdigit
argument_list|(
name|c
argument_list|)
operator|!=
literal|0
operator|)
operator|!=
name|tkp
operator|->
name|tflg
condition|)
block|{
comment|/* else check type */
name|tkp
operator|->
name|tbrk
operator|=
name|c
expr_stmt|;
return|return
operator|--
name|tkp
operator|->
name|tcnt
return|;
comment|/* Wrong type, back up */
block|}
block|}
return|return
operator|(
name|tkp
operator|->
name|tcnt
operator|)
return|;
comment|/* When hit EOF */
block|}
end_function

begin_function
specifier|static
name|struct
name|tmwent
specifier|const
modifier|*
name|ptmatchstr
parameter_list|(
name|astr
parameter_list|,
name|cnt
parameter_list|,
name|astruc
parameter_list|)
name|char
specifier|const
modifier|*
name|astr
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|struct
name|tmwent
specifier|const
modifier|*
name|astruc
decl_stmt|;
block|{
specifier|register
name|char
specifier|const
modifier|*
name|cp
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|struct
name|tmwent
specifier|const
modifier|*
name|lastptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lastptr
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|mp
operator|=
name|astruc
operator|->
name|went
condition|;
name|astruc
operator|+=
literal|1
control|)
block|{
name|cp
operator|=
name|astr
expr_stmt|;
for|for
control|(
name|i
operator|=
name|cnt
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
operator|*
name|cp
operator|++
operator|-
operator|(
name|c
operator|=
operator|*
name|mp
operator|++
operator|)
condition|)
block|{
case|case
literal|0
case|:
continue|continue;
comment|/* Exact match */
case|case
literal|'A'
operator|-
literal|'a'
case|:
if|if
condition|(
name|ctab
index|[
name|c
index|]
operator|==
name|Letter
condition|)
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
operator|*
name|mp
condition|)
return|return
name|astruc
return|;
comment|/* Exact match */
elseif|else
if|if
condition|(
name|lastptr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Ambiguous */
else|else
name|lastptr
operator|=
name|astruc
expr_stmt|;
comment|/* 1st ambig */
block|}
return|return
name|lastptr
return|;
block|}
end_function

end_unit

