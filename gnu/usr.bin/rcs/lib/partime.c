begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Parse a string, yielding a struct partime that describes it.  */
end_comment

begin_comment
comment|/* Copyright 1993, 1994, 1995 Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_if
if|#
directive|if
name|has_conf_h
end_if

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|P
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|const
end_define

begin_define
define|#
directive|define
name|P
parameter_list|(
name|x
parameter_list|)
value|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_undef
undef|#
directive|undef
name|isdigit
end_undef

begin_define
define|#
directive|define
name|isdigit
parameter_list|(
name|c
parameter_list|)
value|(((unsigned)(c)-'0')<= 9)
end_define

begin_comment
comment|/* faster than stock */
end_comment

begin_include
include|#
directive|include
file|"partime.h"
end_include

begin_decl_stmt
name|char
specifier|const
name|partimeId
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lookup tables for names of months, weekdays, time zones.  */
end_comment

begin_define
define|#
directive|define
name|NAME_LENGTH_MAXIMUM
value|4
end_define

begin_struct
struct|struct
name|name_val
block|{
name|char
name|name
index|[
name|NAME_LENGTH_MAXIMUM
index|]
decl_stmt|;
name|int
name|val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|parse_decimal
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|parse_fixed
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|parse_pattern_letter
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|int
operator|,
expr|struct
name|partime
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|parse_prefix
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
expr|struct
name|partime
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|parse_ranged
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lookup
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
expr|struct
name|name_val
specifier|const
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|merge_partime
name|P
argument_list|(
operator|(
expr|struct
name|partime
operator|*
operator|,
expr|struct
name|partime
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|undefine
name|P
argument_list|(
operator|(
expr|struct
name|partime
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|name_val
specifier|const
name|month_names
index|[]
init|=
block|{
block|{
literal|"jan"
block|,
literal|0
block|}
block|,
block|{
literal|"feb"
block|,
literal|1
block|}
block|,
block|{
literal|"mar"
block|,
literal|2
block|}
block|,
block|{
literal|"apr"
block|,
literal|3
block|}
block|,
block|{
literal|"may"
block|,
literal|4
block|}
block|,
block|{
literal|"jun"
block|,
literal|5
block|}
block|,
block|{
literal|"jul"
block|,
literal|6
block|}
block|,
block|{
literal|"aug"
block|,
literal|7
block|}
block|,
block|{
literal|"sep"
block|,
literal|8
block|}
block|,
block|{
literal|"oct"
block|,
literal|9
block|}
block|,
block|{
literal|"nov"
block|,
literal|10
block|}
block|,
block|{
literal|"dec"
block|,
literal|11
block|}
block|,
block|{
literal|""
block|,
name|TM_UNDEFINED
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|name_val
specifier|const
name|weekday_names
index|[]
init|=
block|{
block|{
literal|"sun"
block|,
literal|0
block|}
block|,
block|{
literal|"mon"
block|,
literal|1
block|}
block|,
block|{
literal|"tue"
block|,
literal|2
block|}
block|,
block|{
literal|"wed"
block|,
literal|3
block|}
block|,
block|{
literal|"thu"
block|,
literal|4
block|}
block|,
block|{
literal|"fri"
block|,
literal|5
block|}
block|,
block|{
literal|"sat"
block|,
literal|6
block|}
block|,
block|{
literal|""
block|,
name|TM_UNDEFINED
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|hr60nonnegative
parameter_list|(
name|t
parameter_list|)
value|((t)/100 * 60  +  (t)%100)
end_define

begin_define
define|#
directive|define
name|hr60
parameter_list|(
name|t
parameter_list|)
value|((t)<0 ? -hr60nonnegative(-(t)) : hr60nonnegative(t))
end_define

begin_define
define|#
directive|define
name|zs
parameter_list|(
name|t
parameter_list|,
name|s
parameter_list|)
value|{s, hr60(t)}
end_define

begin_define
define|#
directive|define
name|zd
parameter_list|(
name|t
parameter_list|,
name|s
parameter_list|,
name|d
parameter_list|)
value|zs(t, s),  zs((t)+100, d)
end_define

begin_decl_stmt
specifier|static
name|struct
name|name_val
specifier|const
name|zone_names
index|[]
init|=
block|{
name|zs
argument_list|(
operator|-
literal|1000
argument_list|,
literal|"hst"
argument_list|)
block|,
comment|/* Hawaii */
name|zd
argument_list|(
operator|-
literal|1000
argument_list|,
literal|"hast"
argument_list|,
literal|"hadt"
argument_list|)
block|,
comment|/* Hawaii-Aleutian */
name|zd
argument_list|(
operator|-
literal|900
argument_list|,
literal|"akst"
argument_list|,
literal|"akdt"
argument_list|)
block|,
comment|/* Alaska */
name|zd
argument_list|(
operator|-
literal|800
argument_list|,
literal|"pst"
argument_list|,
literal|"pdt"
argument_list|)
block|,
comment|/* Pacific */
name|zd
argument_list|(
operator|-
literal|700
argument_list|,
literal|"mst"
argument_list|,
literal|"mdt"
argument_list|)
block|,
comment|/* Mountain */
name|zd
argument_list|(
operator|-
literal|600
argument_list|,
literal|"cst"
argument_list|,
literal|"cdt"
argument_list|)
block|,
comment|/* Central */
name|zd
argument_list|(
operator|-
literal|500
argument_list|,
literal|"est"
argument_list|,
literal|"edt"
argument_list|)
block|,
comment|/* Eastern */
name|zd
argument_list|(
operator|-
literal|400
argument_list|,
literal|"ast"
argument_list|,
literal|"adt"
argument_list|)
block|,
comment|/* Atlantic */
name|zd
argument_list|(
operator|-
literal|330
argument_list|,
literal|"nst"
argument_list|,
literal|"ndt"
argument_list|)
block|,
comment|/* Newfoundland */
name|zs
argument_list|(
literal|000
argument_list|,
literal|"utc"
argument_list|)
block|,
comment|/* Coordinated Universal */
name|zs
argument_list|(
literal|000
argument_list|,
literal|"cut"
argument_list|)
block|,
comment|/* " */
name|zs
argument_list|(
literal|000
argument_list|,
literal|"ut"
argument_list|)
block|,
comment|/* Universal */
name|zs
argument_list|(
literal|000
argument_list|,
literal|"z"
argument_list|)
block|,
comment|/* Zulu (required by ISO 8601) */
name|zd
argument_list|(
literal|000
argument_list|,
literal|"gmt"
argument_list|,
literal|"bst"
argument_list|)
block|,
comment|/* Greenwich Mean, British Summer */
name|zs
argument_list|(
literal|000
argument_list|,
literal|"wet"
argument_list|)
block|,
comment|/* Western Europe */
name|zs
argument_list|(
literal|100
argument_list|,
literal|"met"
argument_list|)
block|,
comment|/* Middle Europe */
name|zs
argument_list|(
literal|100
argument_list|,
literal|"cet"
argument_list|)
block|,
comment|/* Central Europe */
name|zs
argument_list|(
literal|200
argument_list|,
literal|"eet"
argument_list|)
block|,
comment|/* Eastern Europe */
name|zs
argument_list|(
literal|530
argument_list|,
literal|"ist"
argument_list|)
block|,
comment|/* India */
name|zd
argument_list|(
literal|900
argument_list|,
literal|"jst"
argument_list|,
literal|"jdt"
argument_list|)
block|,
comment|/* Japan */
name|zd
argument_list|(
literal|900
argument_list|,
literal|"kst"
argument_list|,
literal|"kdt"
argument_list|)
block|,
comment|/* Korea */
name|zd
argument_list|(
literal|1200
argument_list|,
literal|"nzst"
argument_list|,
literal|"nzdt"
argument_list|)
block|,
comment|/* New Zealand */
block|{
literal|"lt"
block|,
literal|1
block|}
block|,
if|#
directive|if
literal|0
comment|/* The following names are duplicates or are not well attested.  */
block|zs(-1100, "sst"),
comment|/* Samoa */
block|zs(-1000, "tht"),
comment|/* Tahiti */
block|zs(- 930, "mqt"),
comment|/* Marquesas */
block|zs(- 900, "gbt"),
comment|/* Gambier */
block|zd(- 900, "yst", "ydt"),
comment|/* Yukon - name is no longer used */
block|zs(- 830, "pit"),
comment|/* Pitcairn */
block|zd(- 500, "cst", "cdt"),
comment|/* Cuba */
block|zd(- 500, "ast", "adt"),
comment|/* Acre */
block|zd(- 400, "wst", "wdt"),
comment|/* Western Brazil */
block|zd(- 400, "ast", "adt"),
comment|/* Andes */
block|zd(- 400, "cst", "cdt"),
comment|/* Chile */
block|zs(- 300, "wgt"),
comment|/* Western Greenland */
block|zd(- 300, "est", "edt"),
comment|/* Eastern South America */
block|zs(- 300, "mgt"),
comment|/* Middle Greenland */
block|zd(- 200, "fst", "fdt"),
comment|/* Fernando de Noronha */
block|zs(- 100, "egt"),
comment|/* Eastern Greenland */
block|zs(- 100, "aat"),
comment|/* Atlantic Africa */
block|zs(- 100, "act"),
comment|/* Azores and Canaries */
block|zs(  000, "wat"),
comment|/* West Africa */
block|zs(  100, "cat"),
comment|/* Central Africa */
block|zd(  100, "mez","mesz"),
comment|/* Mittel-Europaeische Zeit */
block|zs(  200, "sat"),
comment|/* South Africa */
block|zd(  200, "ist", "idt"),
comment|/* Israel */
block|zs(  300, "eat"),
comment|/* East Africa */
block|zd(  300, "ast", "adt"),
comment|/* Arabia */
block|zd(  300, "msk", "msd"),
comment|/* Moscow */
block|zd(  330, "ist", "idt"),
comment|/* Iran */
block|zs(  400, "gst"),
comment|/* Gulf */
block|zs(  400, "smt"),
comment|/* Seychelles& Mascarene */
block|zd(  400, "esk", "esd"),
comment|/* Yekaterinburg */
block|zd(  400, "bsk", "bsd"),
comment|/* Baku */
block|zs(  430, "aft"),
comment|/* Afghanistan */
block|zd(  500, "osk", "osd"),
comment|/* Omsk */
block|zs(  500, "pkt"),
comment|/* Pakistan */
block|zd(  500, "tsk", "tsd"),
comment|/* Tashkent */
block|zs(  545, "npt"),
comment|/* Nepal */
block|zs(  600, "bgt"),
comment|/* Bangladesh */
block|zd(  600, "nsk", "nsd"),
comment|/* Novosibirsk */
block|zs(  630, "bmt"),
comment|/* Burma */
block|zs(  630, "cct"),
comment|/* Cocos */
block|zs(  700, "ict"),
comment|/* Indochina */
block|zs(  700, "jvt"),
comment|/* Java */
block|zd(  700, "isk", "isd"),
comment|/* Irkutsk */
block|zs(  800, "hkt"),
comment|/* Hong Kong */
block|zs(  800, "pst"),
comment|/* Philippines */
block|zs(  800, "sgt"),
comment|/* Singapore */
block|zd(  800, "cst", "cdt"),
comment|/* China */
block|zd(  800, "ust", "udt"),
comment|/* Ulan Bator */
block|zd(  800, "wst", "wst"),
comment|/* Western Australia */
block|zd(  800, "ysk", "ysd"),
comment|/* Yakutsk */
block|zs(  900, "blt"),
comment|/* Belau */
block|zs(  900, "mlt"),
comment|/* Moluccas */
block|zd(  900, "vsk", "vsd"),
comment|/* Vladivostok */
block|zd(  930, "cst", "cst"),
comment|/* Central Australia */
block|zs( 1000, "gst"),
comment|/* Guam */
block|zd( 1000, "gsk", "gsd"),
comment|/* Magadan */
block|zd( 1000, "est", "est"),
comment|/* Eastern Australia */
block|zd( 1100,"lhst","lhst"),
comment|/* Lord Howe */
block|zd( 1100, "psk", "psd"),
comment|/* Petropavlovsk-Kamchatski */
block|zs( 1100,"ncst"),
comment|/* New Caledonia */
block|zs( 1130,"nrft"),
comment|/* Norfolk */
block|zd( 1200, "ask", "asd"),
comment|/* Anadyr */
block|zs( 1245,"nz-chat"),
comment|/* Chatham */
block|zs( 1300, "tgt"),
comment|/* Tongatapu */
endif|#
directive|endif
block|{
literal|""
block|,
operator|-
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|lookup
parameter_list|(
name|s
parameter_list|,
name|table
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
name|struct
name|name_val
specifier|const
name|table
index|[]
decl_stmt|;
comment|/* Look for a prefix of S in TABLE, returning val for first matching entry.  */
block|{
name|int
name|j
decl_stmt|;
name|char
name|buf
index|[
name|NAME_LENGTH_MAXIMUM
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NAME_LENGTH_MAXIMUM
condition|;
name|j
operator|++
control|)
block|{
name|unsigned
name|char
name|c
init|=
operator|*
name|s
operator|++
decl_stmt|;
name|buf
index|[
name|j
index|]
operator|=
name|isupper
argument_list|(
name|c
argument_list|)
condition|?
name|tolower
argument_list|(
name|c
argument_list|)
else|:
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
for|for
control|(
init|;
name|table
index|[
literal|0
index|]
operator|.
name|name
index|[
literal|0
index|]
condition|;
name|table
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|buf
index|[
name|j
index|]
operator|==
name|table
index|[
literal|0
index|]
operator|.
name|name
index|[
name|j
index|]
condition|;
control|)
if|if
condition|(
operator|++
name|j
operator|==
name|NAME_LENGTH_MAXIMUM
operator|||
operator|!
name|table
index|[
literal|0
index|]
operator|.
name|name
index|[
name|j
index|]
condition|)
goto|goto
name|done
goto|;
name|done
label|:
return|return
name|table
index|[
literal|0
index|]
operator|.
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|undefine
parameter_list|(
name|t
parameter_list|)
name|struct
name|partime
modifier|*
name|t
decl_stmt|;
comment|/* Set *T to ``undefined'' values.  */
block|{
name|t
operator|->
name|tm
operator|.
name|tm_sec
operator|=
name|t
operator|->
name|tm
operator|.
name|tm_min
operator|=
name|t
operator|->
name|tm
operator|.
name|tm_hour
operator|=
name|t
operator|->
name|tm
operator|.
name|tm_mday
operator|=
name|t
operator|->
name|tm
operator|.
name|tm_mon
operator|=
name|t
operator|->
name|tm
operator|.
name|tm_year
operator|=
name|t
operator|->
name|tm
operator|.
name|tm_wday
operator|=
name|t
operator|->
name|tm
operator|.
name|tm_yday
operator|=
name|t
operator|->
name|ymodulus
operator|=
name|t
operator|->
name|yweek
operator|=
name|TM_UNDEFINED
expr_stmt|;
name|t
operator|->
name|zone
operator|=
name|TM_UNDEFINED_ZONE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* * Array of patterns to look for in a date string. * Order is important: we look for the first matching pattern * whose values do not contradict values that we already know about. * See `parse_pattern_letter' below for the meaning of the pattern codes. */
end_comment

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|patterns
index|[]
init|=
block|{
comment|/* 	* These traditional patterns must come first, 	* to prevent an ISO 8601 format from misinterpreting their prefixes. 	*/
literal|"E_n_y"
block|,
literal|"x"
block|,
comment|/* RFC 822 */
literal|"E_n"
block|,
literal|"n_E"
block|,
literal|"n"
block|,
literal|"t:m:s_A"
block|,
literal|"t:m_A"
block|,
literal|"t_A"
block|,
comment|/* traditional */
literal|"y/N/D$"
block|,
comment|/* traditional RCS */
comment|/* ISO 8601:1988 formats, generalized a bit.  */
literal|"y-N-D$"
block|,
literal|"4ND$"
block|,
literal|"Y-N$"
block|,
literal|"RND$"
block|,
literal|"-R=N$"
block|,
literal|"-R$"
block|,
literal|"--N=D$"
block|,
literal|"N=DT"
block|,
literal|"--N$"
block|,
literal|"---D$"
block|,
literal|"DT"
block|,
literal|"Y-d$"
block|,
literal|"4d$"
block|,
literal|"R=d$"
block|,
literal|"-d$"
block|,
literal|"dT"
block|,
literal|"y-W-X"
block|,
literal|"yWX"
block|,
literal|"y=W"
block|,
literal|"-r-W-X"
block|,
literal|"r-W-XT"
block|,
literal|"-rWX"
block|,
literal|"rWXT"
block|,
literal|"-W=X"
block|,
literal|"W=XT"
block|,
literal|"-W"
block|,
literal|"-w-X"
block|,
literal|"w-XT"
block|,
literal|"---X$"
block|,
literal|"XT"
block|,
literal|"4$"
block|,
literal|"T"
block|,
literal|"h:m:s$"
block|,
literal|"hms$"
block|,
literal|"h:m$"
block|,
literal|"hm$"
block|,
literal|"h$"
block|,
literal|"-m:s$"
block|,
literal|"-ms$"
block|,
literal|"-m$"
block|,
literal|"--s$"
block|,
literal|"Y"
block|,
literal|"Z"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|parse_prefix
parameter_list|(
name|str
parameter_list|,
name|t
parameter_list|,
name|pi
parameter_list|)
name|char
specifier|const
modifier|*
name|str
decl_stmt|;
name|struct
name|partime
modifier|*
name|t
decl_stmt|;
name|int
modifier|*
name|pi
decl_stmt|;
comment|/* * Parse an initial prefix of STR, setting *T accordingly. * Return the first character after the prefix, or 0 if it couldn't be parsed. * Start with pattern *PI; if success, set *PI to the next pattern to try. * Set *PI to -1 if we know there are no more patterns to try; * if *PI is initially negative, give up immediately. */
block|{
name|int
name|i
init|=
operator|*
name|pi
decl_stmt|;
name|char
specifier|const
modifier|*
name|pat
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Remove initial noise.  */
while|while
condition|(
operator|!
name|isalnum
argument_list|(
name|c
operator|=
operator|*
name|str
argument_list|)
operator|&&
name|c
operator|!=
literal|'-'
operator|&&
name|c
operator|!=
literal|'+'
condition|)
block|{
if|if
condition|(
operator|!
name|c
condition|)
block|{
name|undefine
argument_list|(
name|t
argument_list|)
expr_stmt|;
operator|*
name|pi
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|str
return|;
block|}
name|str
operator|++
expr_stmt|;
block|}
comment|/* Try a pattern until one succeeds.  */
while|while
condition|(
operator|(
name|pat
operator|=
name|patterns
index|[
name|i
operator|++
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
specifier|const
modifier|*
name|s
init|=
name|str
decl_stmt|;
name|undefine
argument_list|(
name|t
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|c
operator|=
operator|*
name|pat
operator|++
operator|)
condition|)
block|{
operator|*
name|pi
operator|=
name|i
expr_stmt|;
return|return
name|s
return|;
block|}
block|}
do|while
condition|(
operator|(
name|s
operator|=
name|parse_pattern_letter
argument_list|(
name|s
argument_list|,
name|c
argument_list|,
name|t
argument_list|)
operator|)
operator|!=
literal|0
condition|)
do|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|parse_fixed
parameter_list|(
name|s
parameter_list|,
name|digits
parameter_list|,
name|res
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
name|int
name|digits
decl_stmt|,
decl|*
name|res
decl_stmt|;
end_function

begin_comment
comment|/* * Parse an initial prefix of S of length DIGITS; it must be a number. * Store the parsed number into *RES. * Return the first character after the prefix, or 0 if it couldn't be parsed. */
end_comment

begin_block
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|char
specifier|const
modifier|*
name|lim
init|=
name|s
operator|+
name|digits
decl_stmt|;
while|while
condition|(
name|s
operator|<
name|lim
condition|)
block|{
name|unsigned
name|d
init|=
operator|*
name|s
operator|++
operator|-
literal|'0'
decl_stmt|;
if|if
condition|(
literal|9
operator|<
name|d
condition|)
return|return
literal|0
return|;
name|n
operator|=
literal|10
operator|*
name|n
operator|+
name|d
expr_stmt|;
block|}
operator|*
name|res
operator|=
name|n
expr_stmt|;
return|return
name|s
return|;
block|}
end_block

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|parse_ranged
parameter_list|(
name|s
parameter_list|,
name|digits
parameter_list|,
name|lo
parameter_list|,
name|hi
parameter_list|,
name|res
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
name|int
name|digits
decl_stmt|,
name|lo
decl_stmt|,
name|hi
decl_stmt|,
decl|*
name|res
decl_stmt|;
end_function

begin_comment
comment|/* * Parse an initial prefix of S of length DIGITS; * it must be a number in the range LO through HI. * Store the parsed number into *RES. * Return the first character after the prefix, or 0 if it couldn't be parsed. */
end_comment

begin_block
block|{
name|s
operator|=
name|parse_fixed
argument_list|(
name|s
argument_list|,
name|digits
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
name|s
operator|&&
name|lo
operator|<=
operator|*
name|res
operator|&&
operator|*
name|res
operator|<=
name|hi
condition|?
name|s
else|:
literal|0
return|;
block|}
end_block

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|parse_decimal
parameter_list|(
name|s
parameter_list|,
name|digits
parameter_list|,
name|lo
parameter_list|,
name|hi
parameter_list|,
name|resolution
parameter_list|,
name|res
parameter_list|,
name|fres
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
name|int
name|digits
decl_stmt|,
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|resolution
decl_stmt|,
decl|*
name|res
decl_stmt|,
modifier|*
name|fres
decl_stmt|;
end_function

begin_comment
comment|/* * Parse an initial prefix of S of length DIGITS; * it must be a number in the range LO through HI * and it may be followed by a fraction that is to be computed using RESOLUTION. * Store the parsed number into *RES; store the fraction times RESOLUTION, * rounded to the nearest integer, into *FRES. * Return the first character after the prefix, or 0 if it couldn't be parsed. */
end_comment

begin_block
block|{
name|s
operator|=
name|parse_fixed
argument_list|(
name|s
argument_list|,
name|digits
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
name|lo
operator|<=
operator|*
name|res
operator|&&
operator|*
name|res
operator|<=
name|hi
condition|)
block|{
name|int
name|f
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|','
operator|||
name|s
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|char
specifier|const
modifier|*
name|s1
init|=
operator|++
name|s
decl_stmt|;
name|int
name|num10
init|=
literal|0
decl_stmt|,
name|denom10
init|=
literal|10
decl_stmt|,
name|product
decl_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|++
name|s
argument_list|)
condition|)
name|denom10
operator|*=
literal|10
expr_stmt|;
name|s
operator|=
name|parse_fixed
argument_list|(
name|s1
argument_list|,
name|s
operator|-
name|s1
argument_list|,
operator|&
name|num10
argument_list|)
expr_stmt|;
name|product
operator|=
name|num10
operator|*
name|resolution
expr_stmt|;
name|f
operator|=
operator|(
name|product
operator|+
operator|(
name|denom10
operator|>>
literal|1
operator|)
operator|)
operator|/
name|denom10
expr_stmt|;
name|f
operator|-=
name|f
operator|&
operator|(
name|product
operator|%
name|denom10
operator|==
name|denom10
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* round to even */
if|if
condition|(
name|f
operator|<
literal|0
operator|||
name|product
operator|/
name|resolution
operator|!=
name|num10
condition|)
return|return
literal|0
return|;
comment|/* overflow */
block|}
operator|*
name|fres
operator|=
name|f
expr_stmt|;
return|return
name|s
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|parzone
parameter_list|(
name|s
parameter_list|,
name|zone
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
name|long
modifier|*
name|zone
decl_stmt|;
comment|/* * Parse an initial prefix of S; it must denote a time zone. * Set *ZONE to the number of seconds east of GMT, * or to TM_LOCAL_ZONE if it is the local time zone. * Return the first character after the prefix, or 0 if it couldn't be parsed. */
block|{
name|char
name|sign
decl_stmt|;
name|int
name|hh
decl_stmt|,
name|mm
decl_stmt|,
name|ss
decl_stmt|;
name|int
name|minutesEastOfUTC
decl_stmt|;
name|long
name|offset
decl_stmt|,
name|z
decl_stmt|;
comment|/* 	* The formats are LT, n, n DST, nDST, no, o 	* where n is a time zone name 	* and o is a time zone offset of the form [-+]hh[:mm[:ss]]. 	*/
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'-'
case|:
case|case
literal|'+'
case|:
name|z
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|minutesEastOfUTC
operator|=
name|lookup
argument_list|(
name|s
argument_list|,
name|zone_names
argument_list|)
expr_stmt|;
if|if
condition|(
name|minutesEastOfUTC
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Don't bother to check rest of spelling.  */
while|while
condition|(
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
comment|/* Don't modify LT.  */
if|if
condition|(
name|minutesEastOfUTC
operator|==
literal|1
condition|)
block|{
operator|*
name|zone
operator|=
name|TM_LOCAL_ZONE
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
name|z
operator|=
name|minutesEastOfUTC
operator|*
literal|60L
expr_stmt|;
comment|/* Look for trailing " DST".  */
if|if
condition|(
operator|(
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'T'
operator|||
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|'t'
operator|)
operator|&&
operator|(
name|s
index|[
operator|-
literal|2
index|]
operator|==
literal|'S'
operator|||
name|s
index|[
operator|-
literal|2
index|]
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|s
index|[
operator|-
literal|3
index|]
operator|==
literal|'D'
operator|||
name|s
index|[
operator|-
literal|3
index|]
operator|==
literal|'t'
operator|)
condition|)
goto|goto
name|trailing_dst
goto|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'D'
operator|||
name|s
index|[
literal|0
index|]
operator|==
literal|'d'
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'S'
operator|||
name|s
index|[
literal|1
index|]
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|s
index|[
literal|2
index|]
operator|==
literal|'T'
operator|||
name|s
index|[
literal|2
index|]
operator|==
literal|'t'
operator|)
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
name|trailing_dst
label|:
operator|*
name|zone
operator|=
name|z
operator|+
literal|60
operator|*
literal|60
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'-'
case|:
case|case
literal|'+'
case|:
break|break;
default|default:
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
block|}
name|sign
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|parse_ranged
argument_list|(
name|s
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|23
argument_list|,
operator|&
name|hh
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
name|mm
operator|=
name|ss
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|parse_ranged
argument_list|(
name|s
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|59
argument_list|,
operator|&
name|mm
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
operator|&&
name|s
index|[
operator|-
literal|3
index|]
operator|==
literal|':'
operator|&&
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|parse_ranged
argument_list|(
name|s
operator|+
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|59
argument_list|,
operator|&
name|ss
argument_list|)
operator|)
condition|)
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
name|offset
operator|=
operator|(
name|hh
operator|*
literal|60
operator|+
name|mm
operator|)
operator|*
literal|60L
operator|+
name|ss
expr_stmt|;
operator|*
name|zone
operator|=
name|z
operator|+
operator|(
name|sign
operator|==
literal|'-'
condition|?
operator|-
name|offset
else|:
name|offset
operator|)
expr_stmt|;
comment|/* 	* ?? Are fractions allowed here? 	* If so, they're not implemented. 	*/
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|parse_pattern_letter
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|,
name|t
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
name|int
name|c
decl_stmt|;
name|struct
name|partime
modifier|*
name|t
decl_stmt|;
comment|/* * Parse an initial prefix of S, matching the pattern whose code is C. * Set *T accordingly. * Return the first character after the prefix, or 0 if it couldn't be parsed. */
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'$'
case|:
comment|/* The next character must be a non-digit.  */
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'-'
case|:
case|case
literal|'/'
case|:
case|case
literal|':'
case|:
comment|/* These characters stand for themselves.  */
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
name|c
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'4'
case|:
comment|/* 4-digit year */
name|s
operator|=
name|parse_fixed
argument_list|(
name|s
argument_list|,
literal|4
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_year
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
comment|/* optional '-' */
name|s
operator|+=
operator|*
name|s
operator|==
literal|'-'
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
comment|/* AM or PM */
comment|/* 			* This matches the regular expression [AaPp][Mm]?. 			* It must not be followed by a letter or digit; 			* otherwise it would match prefixes of strings like "PST". 			*/
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
if|if
condition|(
name|t
operator|->
name|tm
operator|.
name|tm_hour
operator|==
literal|12
condition|)
name|t
operator|->
name|tm
operator|.
name|tm_hour
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
case|case
literal|'p'
case|:
if|if
condition|(
name|t
operator|->
name|tm
operator|.
name|tm_hour
operator|!=
literal|12
condition|)
name|t
operator|->
name|tm
operator|.
name|tm_hour
operator|+=
literal|12
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'M'
case|:
case|case
literal|'m'
case|:
name|s
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|isalnum
argument_list|(
operator|*
name|s
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|'D'
case|:
comment|/* day of month [01-31] */
name|s
operator|=
name|parse_ranged
argument_list|(
name|s
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|31
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_mday
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* day of year [001-366] */
name|s
operator|=
name|parse_ranged
argument_list|(
name|s
argument_list|,
literal|3
argument_list|,
literal|1
argument_list|,
literal|366
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_yday
argument_list|)
expr_stmt|;
name|t
operator|->
name|tm
operator|.
name|tm_yday
operator|--
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* extended day of month [1-9, 01-31] */
name|s
operator|=
name|parse_ranged
argument_list|(
name|s
argument_list|,
operator|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|s
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|s
index|[
literal|1
index|]
argument_list|)
operator|)
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
literal|31
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_mday
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* hour [00-23 followed by optional fraction] */
block|{
name|int
name|frac
decl_stmt|;
name|s
operator|=
name|parse_decimal
argument_list|(
name|s
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|23
argument_list|,
literal|60
operator|*
literal|60
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_hour
argument_list|,
operator|&
name|frac
argument_list|)
expr_stmt|;
name|t
operator|->
name|tm
operator|.
name|tm_min
operator|=
name|frac
operator|/
literal|60
expr_stmt|;
name|t
operator|->
name|tm
operator|.
name|tm_sec
operator|=
name|frac
operator|%
literal|60
expr_stmt|;
block|}
break|break;
case|case
literal|'m'
case|:
comment|/* minute [00-59 followed by optional fraction] */
name|s
operator|=
name|parse_decimal
argument_list|(
name|s
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|59
argument_list|,
literal|60
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_min
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_sec
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* month name [e.g. "Jan"] */
if|if
condition|(
operator|!
name|TM_DEFINED
argument_list|(
name|t
operator|->
name|tm
operator|.
name|tm_mon
operator|=
name|lookup
argument_list|(
name|s
argument_list|,
name|month_names
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Don't bother to check rest of spelling.  */
while|while
condition|(
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* month [01-12] */
name|s
operator|=
name|parse_ranged
argument_list|(
name|s
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_mon
argument_list|)
expr_stmt|;
name|t
operator|->
name|tm
operator|.
name|tm_mon
operator|--
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* year % 10 (remainder in origin-0 decade) [0-9] */
name|s
operator|=
name|parse_fixed
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_year
argument_list|)
expr_stmt|;
name|t
operator|->
name|ymodulus
operator|=
literal|10
expr_stmt|;
break|break;
name|case_R
label|:
case|case
literal|'R'
case|:
comment|/* year % 100 (remainder in origin-0 century) [00-99] */
name|s
operator|=
name|parse_fixed
argument_list|(
name|s
argument_list|,
literal|2
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_year
argument_list|)
expr_stmt|;
name|t
operator|->
name|ymodulus
operator|=
literal|100
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* second [00-60 followed by optional fraction] */
block|{
name|int
name|frac
decl_stmt|;
name|s
operator|=
name|parse_decimal
argument_list|(
name|s
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|60
argument_list|,
literal|1
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_sec
argument_list|,
operator|&
name|frac
argument_list|)
expr_stmt|;
name|t
operator|->
name|tm
operator|.
name|tm_sec
operator|+=
name|frac
expr_stmt|;
block|}
break|break;
case|case
literal|'T'
case|:
comment|/* 'T' or 't' */
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'T'
case|:
case|case
literal|'t'
case|:
break|break;
default|default:
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'t'
case|:
comment|/* traditional hour [1-9 or 01-12] */
name|s
operator|=
name|parse_ranged
argument_list|(
name|s
argument_list|,
operator|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|s
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|s
index|[
literal|1
index|]
argument_list|)
operator|)
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
literal|12
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_hour
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* 'W' or 'w' only (stands for current week) */
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'W'
case|:
case|case
literal|'w'
case|:
break|break;
default|default:
return|return
literal|0
return|;
block|}
break|break;
case|case
literal|'W'
case|:
comment|/* 'W' or 'w', followed by a week of year [00-53] */
switch|switch
condition|(
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'W'
case|:
case|case
literal|'w'
case|:
break|break;
default|default:
return|return
literal|0
return|;
block|}
name|s
operator|=
name|parse_ranged
argument_list|(
name|s
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|53
argument_list|,
operator|&
name|t
operator|->
name|yweek
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* weekday (1=Mon ... 7=Sun) [1-7] */
name|s
operator|=
name|parse_ranged
argument_list|(
name|s
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|7
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_wday
argument_list|)
expr_stmt|;
name|t
operator|->
name|tm
operator|.
name|tm_wday
operator|--
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* weekday name [e.g. "Sun"] */
if|if
condition|(
operator|!
name|TM_DEFINED
argument_list|(
name|t
operator|->
name|tm
operator|.
name|tm_wday
operator|=
name|lookup
argument_list|(
name|s
argument_list|,
name|weekday_names
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Don't bother to check rest of spelling.  */
while|while
condition|(
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
comment|/* either R or Y */
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|s
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|s
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|s
index|[
literal|2
index|]
argument_list|)
condition|)
goto|goto
name|case_R
goto|;
comment|/* fall into */
case|case
literal|'Y'
case|:
comment|/* year in full [4 or more digits] */
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|s
index|[
name|len
index|]
argument_list|)
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|4
condition|)
return|return
literal|0
return|;
name|s
operator|=
name|parse_fixed
argument_list|(
name|s
argument_list|,
name|len
argument_list|,
operator|&
name|t
operator|->
name|tm
operator|.
name|tm_year
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'Z'
case|:
comment|/* time zone */
name|s
operator|=
name|parzone
argument_list|(
name|s
argument_list|,
operator|&
name|t
operator|->
name|zone
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
comment|/* possibly empty sequence of non-alphanumerics */
while|while
condition|(
operator|!
name|isalnum
argument_list|(
operator|*
name|s
argument_list|)
operator|&&
operator|*
name|s
condition|)
name|s
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* bad pattern */
return|return
literal|0
return|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|merge_partime
parameter_list|(
name|t
parameter_list|,
name|u
parameter_list|)
name|struct
name|partime
modifier|*
name|t
decl_stmt|;
name|struct
name|partime
specifier|const
modifier|*
name|u
decl_stmt|;
comment|/* * If there is no conflict, merge into *T the additional information in *U * and return 0.  Otherwise do nothing and return -1. */
block|{
define|#
directive|define
name|conflict
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a) != (b)&&  TM_DEFINED (a)&&  TM_DEFINED (b))
if|if
condition|(
name|conflict
argument_list|(
name|t
operator|->
name|tm
operator|.
name|tm_sec
argument_list|,
name|u
operator|->
name|tm
operator|.
name|tm_sec
argument_list|)
operator|||
name|conflict
argument_list|(
name|t
operator|->
name|tm
operator|.
name|tm_min
argument_list|,
name|u
operator|->
name|tm
operator|.
name|tm_min
argument_list|)
operator|||
name|conflict
argument_list|(
name|t
operator|->
name|tm
operator|.
name|tm_hour
argument_list|,
name|u
operator|->
name|tm
operator|.
name|tm_hour
argument_list|)
operator|||
name|conflict
argument_list|(
name|t
operator|->
name|tm
operator|.
name|tm_mday
argument_list|,
name|u
operator|->
name|tm
operator|.
name|tm_mday
argument_list|)
operator|||
name|conflict
argument_list|(
name|t
operator|->
name|tm
operator|.
name|tm_mon
argument_list|,
name|u
operator|->
name|tm
operator|.
name|tm_mon
argument_list|)
operator|||
name|conflict
argument_list|(
name|t
operator|->
name|tm
operator|.
name|tm_year
argument_list|,
name|u
operator|->
name|tm
operator|.
name|tm_year
argument_list|)
operator|||
name|conflict
argument_list|(
name|t
operator|->
name|tm
operator|.
name|tm_wday
argument_list|,
name|u
operator|->
name|tm
operator|.
name|tm_yday
argument_list|)
operator|||
name|conflict
argument_list|(
name|t
operator|->
name|ymodulus
argument_list|,
name|u
operator|->
name|ymodulus
argument_list|)
operator|||
name|conflict
argument_list|(
name|t
operator|->
name|yweek
argument_list|,
name|u
operator|->
name|yweek
argument_list|)
operator|||
operator|(
name|t
operator|->
name|zone
operator|!=
name|u
operator|->
name|zone
operator|&&
name|t
operator|->
name|zone
operator|!=
name|TM_UNDEFINED_ZONE
operator|&&
name|u
operator|->
name|zone
operator|!=
name|TM_UNDEFINED_ZONE
operator|)
condition|)
return|return
operator|-
literal|1
return|;
undef|#
directive|undef
name|conflict
define|#
directive|define
name|merge_
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|if (TM_DEFINED (b)) (a) = (b);
name|merge_
argument_list|(
argument|t->tm.tm_sec
argument_list|,
argument|u->tm.tm_sec
argument_list|)
name|merge_
argument_list|(
argument|t->tm.tm_min
argument_list|,
argument|u->tm.tm_min
argument_list|)
name|merge_
argument_list|(
argument|t->tm.tm_hour
argument_list|,
argument|u->tm.tm_hour
argument_list|)
name|merge_
argument_list|(
argument|t->tm.tm_mday
argument_list|,
argument|u->tm.tm_mday
argument_list|)
name|merge_
argument_list|(
argument|t->tm.tm_mon
argument_list|,
argument|u->tm.tm_mon
argument_list|)
name|merge_
argument_list|(
argument|t->tm.tm_year
argument_list|,
argument|u->tm.tm_year
argument_list|)
name|merge_
argument_list|(
argument|t->tm.tm_wday
argument_list|,
argument|u->tm.tm_yday
argument_list|)
name|merge_
argument_list|(
argument|t->ymodulus
argument_list|,
argument|u->ymodulus
argument_list|)
name|merge_
argument_list|(
argument|t->yweek
argument_list|,
argument|u->yweek
argument_list|)
undef|#
directive|undef
name|merge_
if|if
condition|(
name|u
operator|->
name|zone
operator|!=
name|TM_UNDEFINED_ZONE
condition|)
name|t
operator|->
name|zone
operator|=
name|u
operator|->
name|zone
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|partime
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
name|struct
name|partime
modifier|*
name|t
decl_stmt|;
comment|/* * Parse a date/time prefix of S, putting the parsed result into *T. * Return the first character after the prefix. * The prefix may contain no useful information; * in that case, *T will contain only undefined values. */
block|{
name|struct
name|partime
name|p
decl_stmt|;
name|undefine
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
specifier|const
modifier|*
name|s1
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|s1
operator|=
name|parse_prefix
argument_list|(
name|s
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|i
argument_list|)
operator|)
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
do|while
condition|(
name|merge_partime
argument_list|(
name|t
argument_list|,
operator|&
name|p
argument_list|)
operator|!=
literal|0
condition|)
do|;
name|s
operator|=
name|s1
expr_stmt|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|s
return|;
block|}
end_function

end_unit

