begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle RCS revision numbers.  */
end_comment

begin_comment
comment|/* Copyright 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991, 1992, 1993, 1994, 1995 Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/*  * Revision 5.10  1995/06/16 06:19:24  eggert  * Update FSF address.  *  * Revision 5.9  1995/06/01 16:23:43  eggert  * (cmpdate, normalizeyear): New functions work around MKS RCS incompatibility.  * (cmpnum, compartial): s[d] -> *(s+d) to work around Cray compiler bug.  * (genrevs, genbranch): cmpnum -> cmpdate  *  * Revision 5.8  1994/03/17 14:05:48  eggert  * Remove lint.  *  * Revision 5.7  1993/11/09 17:40:15  eggert  * Fix format string typos.  *  * Revision 5.6  1993/11/03 17:42:27  eggert  * Revision number `.N' now stands for `D.N', where D is the default branch.  * Add -z.  Improve quality of diagnostics.  Add `namedrev' for Name support.  *  * Revision 5.5  1992/07/28  16:12:44  eggert  * Identifiers may now start with a digit.  Avoid `unsigned'.  *  * Revision 5.4  1992/01/06  02:42:34  eggert  * while (E) ; -> while (E) continue;  *  * Revision 5.3  1991/08/19  03:13:55  eggert  * Add `-r$', `-rB.'.  Remove botches like `<now>' from messages.  Tune.  *  * Revision 5.2  1991/04/21  11:58:28  eggert  * Add tiprev().  *  * Revision 5.1  1991/02/25  07:12:43  eggert  * Avoid overflow when comparing revision numbers.  *  * Revision 5.0  1990/08/22  08:13:43  eggert  * Remove compile-time limits; use malloc instead.  * Ansify and Posixate.  Tune.  * Remove possibility of an internal error.  Remove lint.  *  * Revision 4.5  89/05/01  15:13:22  narten  * changed copyright header to reflect current distribution rules  *  * Revision 4.4  87/12/18  11:45:22  narten  * more lint cleanups. Also, the NOTREACHED comment is no longer necessary,  * since there's now a return value there with a value. (Guy Harris)  *  * Revision 4.3  87/10/18  10:38:42  narten  * Updating version numbers. Changes relative to version 1.1 actually  * relative to 4.1  *  * Revision 1.3  87/09/24  14:00:37  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf  * warnings)  *  * Revision 1.2  87/03/27  14:22:37  jenkins  * Port to suns  *  * Revision 4.1  83/03/25  21:10:45  wft  * Only changed $Header to $Id.  *  * Revision 3.4  82/12/04  13:24:08  wft  * Replaced getdelta() with gettree().  *  * Revision 3.3  82/11/28  21:33:15  wft  * fixed compartial() and compnum() for nil-parameters; fixed nils  * in error messages. Testprogram output shortenend.  *  * Revision 3.2  82/10/18  21:19:47  wft  * renamed compnum->cmpnum, compnumfld->cmpnumfld,  * numericrevno->numricrevno.  *  * Revision 3.1  82/10/11  19:46:09  wft  * changed expandsym() to check for source==nil; returns zero length string  * in that case.  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_macro
name|libId
argument_list|(
argument|revId
argument_list|,
literal|"$FreeBSD$"
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|branchtip
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|lookupsym
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|normalizeyear
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|char
index|[
literal|5
index|]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hshentry
modifier|*
name|genbranch
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|,
name|int
operator|,
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|,
expr|struct
name|hshentries
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|absent
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cantfindbranch
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
index|[
name|datesize
index|]
operator|,
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|store1
name|P
argument_list|(
operator|(
expr|struct
name|hshentries
operator|*
operator|*
operator|*
operator|,
expr|struct
name|hshentry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|countnumflds
parameter_list|(
name|s
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
comment|/* Given a pointer s to a dotted number (date or revision number),  * countnumflds returns the number of digitfields in s.  */
block|{
specifier|register
name|char
specifier|const
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sp
operator|=
name|s
operator|)
operator|||
operator|!
operator|*
name|sp
condition|)
return|return
literal|0
return|;
name|count
operator|=
literal|1
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|sp
operator|++
operator|==
literal|'.'
condition|)
name|count
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|sp
condition|)
do|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
name|void
name|getbranchno
parameter_list|(
name|revno
parameter_list|,
name|branchno
parameter_list|)
name|char
specifier|const
modifier|*
name|revno
decl_stmt|;
name|struct
name|buf
modifier|*
name|branchno
decl_stmt|;
comment|/* Given a revision number revno, getbranchno copies the number of the branch  * on which revno is into branchno. If revno itself is a branch number,  * it is copied unchanged.  */
block|{
specifier|register
name|int
name|numflds
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
name|bufscpy
argument_list|(
name|branchno
argument_list|,
name|revno
argument_list|)
expr_stmt|;
name|numflds
operator|=
name|countnumflds
argument_list|(
name|revno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|numflds
operator|&
literal|1
operator|)
condition|)
block|{
name|tp
operator|=
name|branchno
operator|->
name|string
expr_stmt|;
while|while
condition|(
operator|--
name|numflds
condition|)
while|while
condition|(
operator|*
name|tp
operator|++
operator|!=
literal|'.'
condition|)
continue|continue;
operator|*
operator|(
name|tp
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|cmpnum
parameter_list|(
name|num1
parameter_list|,
name|num2
parameter_list|)
name|char
specifier|const
modifier|*
name|num1
decl_stmt|,
decl|*
name|num2
decl_stmt|;
end_function

begin_comment
comment|/* compares the two dotted numbers num1 and num2 lexicographically  * by field. Individual fields are compared numerically.  * returns<0, 0,>0 if num1<num2, num1==num2, and num1>num2, resp.  * omitted fields are assumed to be higher than the existing ones. */
end_comment

begin_block
block|{
specifier|register
name|char
specifier|const
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
specifier|register
name|size_t
name|d1
decl_stmt|,
name|d2
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|;
name|s1
operator|=
name|num1
condition|?
name|num1
else|:
literal|""
expr_stmt|;
name|s2
operator|=
name|num2
condition|?
name|num2
else|:
literal|""
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Give precedence to shorter one.  */
if|if
condition|(
operator|!
operator|*
name|s1
condition|)
return|return
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s2
return|;
if|if
condition|(
operator|!
operator|*
name|s2
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Strip leading zeros, then find number of digits.  */
while|while
condition|(
operator|*
name|s1
operator|==
literal|'0'
condition|)
operator|++
name|s1
expr_stmt|;
while|while
condition|(
operator|*
name|s2
operator|==
literal|'0'
condition|)
operator|++
name|s2
expr_stmt|;
for|for
control|(
name|d1
operator|=
literal|0
init|;
name|isdigit
argument_list|(
operator|*
operator|(
name|s1
operator|+
name|d1
operator|)
argument_list|)
condition|;
name|d1
operator|++
control|)
continue|continue;
for|for
control|(
name|d2
operator|=
literal|0
init|;
name|isdigit
argument_list|(
operator|*
operator|(
name|s2
operator|+
name|d2
operator|)
argument_list|)
condition|;
name|d2
operator|++
control|)
continue|continue;
comment|/* Do not convert to integer; it might overflow!  */
if|if
condition|(
name|d1
operator|!=
name|d2
condition|)
return|return
name|d1
operator|<
name|d2
condition|?
operator|-
literal|1
else|:
literal|1
return|;
if|if
condition|(
operator|(
name|r
operator|=
name|memcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|d1
argument_list|)
operator|)
condition|)
return|return
name|r
return|;
name|s1
operator|+=
name|d1
expr_stmt|;
name|s2
operator|+=
name|d1
expr_stmt|;
comment|/* skip '.' */
if|if
condition|(
operator|*
name|s1
condition|)
name|s1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s2
condition|)
name|s2
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_function
name|int
name|cmpnumfld
parameter_list|(
name|num1
parameter_list|,
name|num2
parameter_list|,
name|fld
parameter_list|)
name|char
specifier|const
modifier|*
name|num1
decl_stmt|,
decl|*
name|num2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|fld
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compare the two dotted numbers at field fld.  * num1 and num2 must have at least fld fields.  * fld must be positive. */
end_comment

begin_block
block|{
specifier|register
name|char
specifier|const
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
specifier|register
name|size_t
name|d1
decl_stmt|,
name|d2
decl_stmt|;
name|s1
operator|=
name|num1
expr_stmt|;
name|s2
operator|=
name|num2
expr_stmt|;
comment|/* skip fld-1 fields */
while|while
condition|(
operator|--
name|fld
condition|)
block|{
while|while
condition|(
operator|*
name|s1
operator|++
operator|!=
literal|'.'
condition|)
continue|continue;
while|while
condition|(
operator|*
name|s2
operator|++
operator|!=
literal|'.'
condition|)
continue|continue;
block|}
comment|/* Now s1 and s2 point to the beginning of the respective fields */
while|while
condition|(
operator|*
name|s1
operator|==
literal|'0'
condition|)
operator|++
name|s1
expr_stmt|;
for|for
control|(
name|d1
operator|=
literal|0
init|;
name|isdigit
argument_list|(
operator|*
operator|(
name|s1
operator|+
name|d1
operator|)
argument_list|)
condition|;
name|d1
operator|++
control|)
continue|continue;
while|while
condition|(
operator|*
name|s2
operator|==
literal|'0'
condition|)
operator|++
name|s2
expr_stmt|;
for|for
control|(
name|d2
operator|=
literal|0
init|;
name|isdigit
argument_list|(
operator|*
operator|(
name|s2
operator|+
name|d2
operator|)
argument_list|)
condition|;
name|d2
operator|++
control|)
continue|continue;
return|return
name|d1
operator|<
name|d2
condition|?
operator|-
literal|1
else|:
name|d1
operator|==
name|d2
condition|?
name|memcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|d1
argument_list|)
else|:
literal|1
return|;
block|}
end_block

begin_function
name|int
name|cmpdate
parameter_list|(
name|d1
parameter_list|,
name|d2
parameter_list|)
name|char
specifier|const
modifier|*
name|d1
decl_stmt|,
decl|*
name|d2
decl_stmt|;
end_function

begin_comment
comment|/* * Compare the two dates.  This is just like cmpnum, * except that for compatibility with old versions of RCS, * 1900 is added to dates with two-digit years. */
end_comment

begin_block
block|{
name|char
name|year1
index|[
literal|5
index|]
decl_stmt|,
name|year2
index|[
literal|5
index|]
decl_stmt|;
name|int
name|r
init|=
name|cmpnumfld
argument_list|(
name|normalizeyear
argument_list|(
name|d1
argument_list|,
name|year1
argument_list|)
argument_list|,
name|normalizeyear
argument_list|(
name|d2
argument_list|,
name|year2
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|r
return|;
else|else
block|{
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|d1
argument_list|)
condition|)
name|d1
operator|++
expr_stmt|;
name|d1
operator|+=
operator|*
name|d1
operator|==
literal|'.'
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|d2
argument_list|)
condition|)
name|d2
operator|++
expr_stmt|;
name|d2
operator|+=
operator|*
name|d2
operator|==
literal|'.'
expr_stmt|;
return|return
name|cmpnum
argument_list|(
name|d1
argument_list|,
name|d2
argument_list|)
return|;
block|}
block|}
end_block

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|normalizeyear
parameter_list|(
name|date
parameter_list|,
name|year
parameter_list|)
name|char
specifier|const
modifier|*
name|date
decl_stmt|;
name|char
name|year
index|[
literal|5
index|]
decl_stmt|;
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|date
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|date
index|[
literal|1
index|]
argument_list|)
operator|&&
operator|!
name|isdigit
argument_list|(
name|date
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|year
index|[
literal|0
index|]
operator|=
literal|'1'
expr_stmt|;
name|year
index|[
literal|1
index|]
operator|=
literal|'9'
expr_stmt|;
name|year
index|[
literal|2
index|]
operator|=
name|date
index|[
literal|0
index|]
expr_stmt|;
name|year
index|[
literal|3
index|]
operator|=
name|date
index|[
literal|1
index|]
expr_stmt|;
name|year
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|year
return|;
block|}
else|else
return|return
name|date
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|cantfindbranch
argument_list|(
name|revno
argument_list|,
name|date
argument_list|,
name|author
argument_list|,
name|state
argument_list|)
name|char
decl|const
modifier|*
name|revno
decl_stmt|,
name|date
index|[
name|datesize
index|]
decl_stmt|,
modifier|*
name|author
decl_stmt|,
modifier|*
name|state
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|datebuf
index|[
name|datesize
operator|+
name|zonelenmax
index|]
decl_stmt|;
name|rcserror
argument_list|(
literal|"No revision on branch %s has%s%s%s%s%s%s."
argument_list|,
name|revno
argument_list|,
name|date
condition|?
literal|" a date before "
else|:
literal|""
argument_list|,
name|date
condition|?
name|date2str
argument_list|(
name|date
argument_list|,
name|datebuf
argument_list|)
else|:
literal|""
argument_list|,
name|author
condition|?
literal|" and author "
operator|+
operator|(
name|date
condition|?
literal|0
else|:
literal|4
operator|)
else|:
literal|""
argument_list|,
name|author
condition|?
name|author
else|:
literal|""
argument_list|,
name|state
condition|?
literal|" and state "
operator|+
operator|(
name|date
operator|||
name|author
condition|?
literal|0
else|:
literal|4
operator|)
else|:
literal|""
argument_list|,
name|state
condition|?
name|state
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|absent
parameter_list|(
name|revno
parameter_list|,
name|field
parameter_list|)
name|char
specifier|const
modifier|*
name|revno
decl_stmt|;
name|int
name|field
decl_stmt|;
block|{
name|struct
name|buf
name|t
decl_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|rcserror
argument_list|(
literal|"%s %s absent"
argument_list|,
name|field
operator|&
literal|1
condition|?
literal|"revision"
else|:
literal|"branch"
argument_list|,
name|partialno
argument_list|(
operator|&
name|t
argument_list|,
name|revno
argument_list|,
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|bufautoend
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|compartial
parameter_list|(
name|num1
parameter_list|,
name|num2
parameter_list|,
name|length
parameter_list|)
name|char
specifier|const
modifier|*
name|num1
decl_stmt|,
decl|*
name|num2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   compare the first "length" fields of two dot numbers;      the omitted field is considered to be larger than any number  */
end_comment

begin_comment
comment|/*   restriction:  at least one number has length or more fields   */
end_comment

begin_block
block|{
specifier|register
name|char
specifier|const
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
specifier|register
name|size_t
name|d1
decl_stmt|,
name|d2
decl_stmt|;
specifier|register
name|int
name|r
decl_stmt|;
name|s1
operator|=
name|num1
expr_stmt|;
name|s2
operator|=
name|num2
expr_stmt|;
if|if
condition|(
operator|!
name|s1
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|s2
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|s1
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
operator|*
name|s2
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|*
name|s1
operator|==
literal|'0'
condition|)
operator|++
name|s1
expr_stmt|;
for|for
control|(
name|d1
operator|=
literal|0
init|;
name|isdigit
argument_list|(
operator|*
operator|(
name|s1
operator|+
name|d1
operator|)
argument_list|)
condition|;
name|d1
operator|++
control|)
continue|continue;
while|while
condition|(
operator|*
name|s2
operator|==
literal|'0'
condition|)
operator|++
name|s2
expr_stmt|;
for|for
control|(
name|d2
operator|=
literal|0
init|;
name|isdigit
argument_list|(
operator|*
operator|(
name|s2
operator|+
name|d2
operator|)
argument_list|)
condition|;
name|d2
operator|++
control|)
continue|continue;
if|if
condition|(
name|d1
operator|!=
name|d2
condition|)
return|return
name|d1
operator|<
name|d2
condition|?
operator|-
literal|1
else|:
literal|1
return|;
if|if
condition|(
operator|(
name|r
operator|=
name|memcmp
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|d1
argument_list|)
operator|)
condition|)
return|return
name|r
return|;
if|if
condition|(
operator|!
operator|--
name|length
condition|)
return|return
literal|0
return|;
name|s1
operator|+=
name|d1
expr_stmt|;
name|s2
operator|+=
name|d1
expr_stmt|;
if|if
condition|(
operator|*
name|s1
operator|==
literal|'.'
condition|)
name|s1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s2
operator|==
literal|'.'
condition|)
name|s2
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|partialno
parameter_list|(
name|rev1
parameter_list|,
name|rev2
parameter_list|,
name|length
parameter_list|)
name|struct
name|buf
modifier|*
name|rev1
decl_stmt|;
name|char
specifier|const
modifier|*
name|rev2
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
comment|/* Function: Copies length fields of revision number rev2 into rev1.  * Return rev1's string.  */
block|{
specifier|register
name|char
modifier|*
name|r1
decl_stmt|;
name|bufscpy
argument_list|(
name|rev1
argument_list|,
name|rev2
argument_list|)
expr_stmt|;
name|r1
operator|=
name|rev1
operator|->
name|string
expr_stmt|;
while|while
condition|(
name|length
condition|)
block|{
while|while
condition|(
operator|*
name|r1
operator|!=
literal|'.'
operator|&&
operator|*
name|r1
condition|)
operator|++
name|r1
expr_stmt|;
operator|++
name|r1
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
comment|/* eliminate last '.'*/
operator|*
operator|(
name|r1
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
return|return
name|rev1
operator|->
name|string
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|store1
parameter_list|(
name|store
parameter_list|,
name|next
parameter_list|)
name|struct
name|hshentries
modifier|*
modifier|*
modifier|*
name|store
decl_stmt|;
name|struct
name|hshentry
modifier|*
name|next
decl_stmt|;
comment|/*  * Allocate a new list node that addresses NEXT.  * Append it to the list that **STORE is the end pointer of.  */
block|{
specifier|register
name|struct
name|hshentries
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|ftalloc
argument_list|(
expr|struct
name|hshentries
argument_list|)
expr_stmt|;
name|p
operator|->
name|first
operator|=
name|next
expr_stmt|;
operator|*
operator|*
name|store
operator|=
name|p
expr_stmt|;
operator|*
name|store
operator|=
operator|&
name|p
operator|->
name|rest
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|hshentry
modifier|*
name|genrevs
parameter_list|(
name|revno
parameter_list|,
name|date
parameter_list|,
name|author
parameter_list|,
name|state
parameter_list|,
name|store
parameter_list|)
name|char
specifier|const
modifier|*
name|revno
decl_stmt|,
decl|*
name|date
decl_stmt|,
modifier|*
name|author
decl_stmt|,
modifier|*
name|state
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|hshentries
modifier|*
modifier|*
name|store
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: finds the deltas needed for reconstructing the  * revision given by revno, date, author, and state, and stores pointers  * to these deltas into a list whose starting address is given by store.  * The last delta (target delta) is returned.  * If the proper delta could not be found, 0 is returned.  */
end_comment

begin_block
block|{
name|int
name|length
decl_stmt|;
specifier|register
name|struct
name|hshentry
modifier|*
name|next
decl_stmt|;
name|int
name|result
decl_stmt|;
name|char
specifier|const
modifier|*
name|branchnum
decl_stmt|;
name|struct
name|buf
name|t
decl_stmt|;
name|char
name|datebuf
index|[
name|datesize
operator|+
name|zonelenmax
index|]
decl_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|next
operator|=
name|Head
operator|)
condition|)
block|{
name|rcserror
argument_list|(
literal|"RCS file empty"
argument_list|)
expr_stmt|;
goto|goto
name|norev
goto|;
block|}
name|length
operator|=
name|countnumflds
argument_list|(
name|revno
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>=
literal|1
condition|)
block|{
comment|/* at least one field; find branch exactly */
while|while
condition|(
operator|(
name|result
operator|=
name|cmpnumfld
argument_list|(
name|revno
argument_list|,
name|next
operator|->
name|num
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|store1
argument_list|(
operator|&
name|store
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|next
condition|)
block|{
name|rcserror
argument_list|(
literal|"branch number %s too low"
argument_list|,
name|partialno
argument_list|(
operator|&
name|t
argument_list|,
name|revno
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|norev
goto|;
block|}
block|}
if|if
condition|(
name|result
operator|>
literal|0
condition|)
block|{
name|absent
argument_list|(
name|revno
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|norev
goto|;
block|}
block|}
if|if
condition|(
name|length
operator|<=
literal|1
condition|)
block|{
comment|/* pick latest one on given branch */
name|branchnum
operator|=
name|next
operator|->
name|num
expr_stmt|;
comment|/* works even for empty revno*/
while|while
condition|(
name|next
operator|&&
name|cmpnumfld
argument_list|(
name|branchnum
argument_list|,
name|next
operator|->
name|num
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|date
operator|&&
name|cmpdate
argument_list|(
name|date
argument_list|,
name|next
operator|->
name|date
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|author
operator|&&
name|strcmp
argument_list|(
name|author
argument_list|,
name|next
operator|->
name|author
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|state
operator|&&
name|strcmp
argument_list|(
name|state
argument_list|,
name|next
operator|->
name|state
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|store1
argument_list|(
operator|&
name|store
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|next
operator|||
operator|(
name|cmpnumfld
argument_list|(
name|branchnum
argument_list|,
name|next
operator|->
name|num
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
operator|)
condition|)
comment|/*overshot*/
block|{
name|cantfindbranch
argument_list|(
name|length
condition|?
name|revno
else|:
name|partialno
argument_list|(
operator|&
name|t
argument_list|,
name|branchnum
argument_list|,
literal|1
argument_list|)
argument_list|,
name|date
argument_list|,
name|author
argument_list|,
name|state
argument_list|)
expr_stmt|;
goto|goto
name|norev
goto|;
block|}
else|else
block|{
name|store1
argument_list|(
operator|&
name|store
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
operator|*
name|store
operator|=
literal|0
expr_stmt|;
return|return
name|next
return|;
block|}
comment|/* length>=2 */
comment|/* find revision; may go low if length==2*/
while|while
condition|(
operator|(
name|result
operator|=
name|cmpnumfld
argument_list|(
name|revno
argument_list|,
name|next
operator|->
name|num
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
operator|&&
operator|(
name|cmpnumfld
argument_list|(
name|revno
argument_list|,
name|next
operator|->
name|num
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|store1
argument_list|(
operator|&
name|store
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|next
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|next
operator|||
name|cmpnumfld
argument_list|(
name|revno
argument_list|,
name|next
operator|->
name|num
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rcserror
argument_list|(
literal|"revision number %s too low"
argument_list|,
name|partialno
argument_list|(
operator|&
name|t
argument_list|,
name|revno
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|norev
goto|;
block|}
if|if
condition|(
operator|(
name|length
operator|>
literal|2
operator|)
operator|&&
operator|(
name|result
operator|!=
literal|0
operator|)
condition|)
block|{
name|absent
argument_list|(
name|revno
argument_list|,
literal|2
argument_list|)
expr_stmt|;
goto|goto
name|norev
goto|;
block|}
comment|/* print last one */
name|store1
argument_list|(
operator|&
name|store
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|2
condition|)
return|return
name|genbranch
argument_list|(
name|next
argument_list|,
name|revno
argument_list|,
name|length
argument_list|,
name|date
argument_list|,
name|author
argument_list|,
name|state
argument_list|,
name|store
argument_list|)
return|;
else|else
block|{
comment|/* length == 2*/
if|if
condition|(
name|date
operator|&&
name|cmpdate
argument_list|(
name|date
argument_list|,
name|next
operator|->
name|date
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rcserror
argument_list|(
literal|"Revision %s has date %s."
argument_list|,
name|next
operator|->
name|num
argument_list|,
name|date2str
argument_list|(
name|next
operator|->
name|date
argument_list|,
name|datebuf
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|author
operator|&&
name|strcmp
argument_list|(
name|author
argument_list|,
name|next
operator|->
name|author
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rcserror
argument_list|(
literal|"Revision %s has author %s."
argument_list|,
name|next
operator|->
name|num
argument_list|,
name|next
operator|->
name|author
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|state
operator|&&
name|strcmp
argument_list|(
name|state
argument_list|,
name|next
operator|->
name|state
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rcserror
argument_list|(
literal|"Revision %s has state %s."
argument_list|,
name|next
operator|->
name|num
argument_list|,
name|next
operator|->
name|state
condition|?
name|next
operator|->
name|state
else|:
literal|"<empty>"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|store
operator|=
literal|0
expr_stmt|;
return|return
name|next
return|;
block|}
name|norev
label|:
name|bufautoend
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_function
specifier|static
name|struct
name|hshentry
modifier|*
name|genbranch
parameter_list|(
name|bpoint
parameter_list|,
name|revno
parameter_list|,
name|length
parameter_list|,
name|date
parameter_list|,
name|author
parameter_list|,
name|state
parameter_list|,
name|store
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|bpoint
decl_stmt|;
name|char
specifier|const
modifier|*
name|revno
decl_stmt|;
name|int
name|length
decl_stmt|;
name|char
specifier|const
modifier|*
name|date
decl_stmt|,
decl|*
name|author
decl_stmt|,
modifier|*
name|state
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|hshentries
modifier|*
modifier|*
name|store
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: given a branchpoint, a revision number, date, author, and state,  * genbranch finds the deltas necessary to reconstruct the given revision  * from the branch point on.  * Pointers to the found deltas are stored in a list beginning with store.  * revno must be on a side branch.  * Return 0 on error.  */
end_comment

begin_block
block|{
name|int
name|field
decl_stmt|;
specifier|register
name|struct
name|hshentry
modifier|*
name|next
decl_stmt|,
modifier|*
name|trail
decl_stmt|;
specifier|register
name|struct
name|branchhead
specifier|const
modifier|*
name|bhead
decl_stmt|;
name|int
name|result
decl_stmt|;
name|struct
name|buf
name|t
decl_stmt|;
name|char
name|datebuf
index|[
name|datesize
operator|+
name|zonelenmax
index|]
decl_stmt|;
name|field
operator|=
literal|3
expr_stmt|;
name|bhead
operator|=
name|bpoint
operator|->
name|branches
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|bhead
condition|)
block|{
name|bufautobegin
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|rcserror
argument_list|(
literal|"no side branches present for %s"
argument_list|,
name|partialno
argument_list|(
operator|&
name|t
argument_list|,
name|revno
argument_list|,
name|field
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|bufautoend
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*find branch head*/
comment|/*branches are arranged in increasing order*/
while|while
condition|(
literal|0
operator|<
operator|(
name|result
operator|=
name|cmpnumfld
argument_list|(
name|revno
argument_list|,
name|bhead
operator|->
name|hsh
operator|->
name|num
argument_list|,
name|field
argument_list|)
operator|)
condition|)
block|{
name|bhead
operator|=
name|bhead
operator|->
name|nextbranch
expr_stmt|;
if|if
condition|(
operator|!
name|bhead
condition|)
block|{
name|bufautobegin
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|rcserror
argument_list|(
literal|"branch number %s too high"
argument_list|,
name|partialno
argument_list|(
operator|&
name|t
argument_list|,
name|revno
argument_list|,
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|bufautoend
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|absent
argument_list|(
name|revno
argument_list|,
name|field
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|next
operator|=
name|bhead
operator|->
name|hsh
expr_stmt|;
if|if
condition|(
name|length
operator|==
name|field
condition|)
block|{
comment|/* pick latest one on that branch */
name|trail
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
operator|!
name|date
operator|||
name|cmpdate
argument_list|(
name|date
argument_list|,
name|next
operator|->
name|date
argument_list|)
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|!
name|author
operator|||
name|strcmp
argument_list|(
name|author
argument_list|,
name|next
operator|->
name|author
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|state
operator|||
name|strcmp
argument_list|(
name|state
argument_list|,
name|next
operator|->
name|state
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|trail
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|next
condition|)
do|;
if|if
condition|(
operator|!
name|trail
condition|)
block|{
name|cantfindbranch
argument_list|(
name|revno
argument_list|,
name|date
argument_list|,
name|author
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* print up to last one suitable */
name|next
operator|=
name|bhead
operator|->
name|hsh
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|trail
condition|)
block|{
name|store1
argument_list|(
operator|&
name|store
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
block|}
name|store1
argument_list|(
operator|&
name|store
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
operator|*
name|store
operator|=
literal|0
expr_stmt|;
return|return
name|next
return|;
block|}
comment|/* length> field */
comment|/* find revision */
comment|/* check low */
if|if
condition|(
name|cmpnumfld
argument_list|(
name|revno
argument_list|,
name|next
operator|->
name|num
argument_list|,
name|field
operator|+
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|bufautobegin
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|rcserror
argument_list|(
literal|"revision number %s too low"
argument_list|,
name|partialno
argument_list|(
operator|&
name|t
argument_list|,
name|revno
argument_list|,
name|field
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|bufautoend
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
do|do
block|{
name|store1
argument_list|(
operator|&
name|store
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|trail
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|next
operator|&&
name|cmpnumfld
argument_list|(
name|revno
argument_list|,
name|next
operator|->
name|num
argument_list|,
name|field
operator|+
literal|1
argument_list|)
operator|>=
literal|0
condition|)
do|;
if|if
condition|(
operator|(
name|length
operator|>
name|field
operator|+
literal|1
operator|)
operator|&&
comment|/*need exact hit */
operator|(
name|cmpnumfld
argument_list|(
name|revno
argument_list|,
name|trail
operator|->
name|num
argument_list|,
name|field
operator|+
literal|1
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|absent
argument_list|(
name|revno
argument_list|,
name|field
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|length
operator|==
name|field
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|date
operator|&&
name|cmpdate
argument_list|(
name|date
argument_list|,
name|trail
operator|->
name|date
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rcserror
argument_list|(
literal|"Revision %s has date %s."
argument_list|,
name|trail
operator|->
name|num
argument_list|,
name|date2str
argument_list|(
name|trail
operator|->
name|date
argument_list|,
name|datebuf
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|author
operator|&&
name|strcmp
argument_list|(
name|author
argument_list|,
name|trail
operator|->
name|author
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rcserror
argument_list|(
literal|"Revision %s has author %s."
argument_list|,
name|trail
operator|->
name|num
argument_list|,
name|trail
operator|->
name|author
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|state
operator|&&
name|strcmp
argument_list|(
name|state
argument_list|,
name|trail
operator|->
name|state
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rcserror
argument_list|(
literal|"Revision %s has state %s."
argument_list|,
name|trail
operator|->
name|num
argument_list|,
name|trail
operator|->
name|state
condition|?
name|trail
operator|->
name|state
else|:
literal|"<empty>"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|bhead
operator|=
name|trail
operator|->
name|branches
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|field
operator|+=
literal|2
operator|)
operator|<=
name|length
condition|)
do|;
operator|*
name|store
operator|=
literal|0
expr_stmt|;
return|return
name|trail
return|;
block|}
end_block

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|lookupsym
parameter_list|(
name|id
parameter_list|)
name|char
specifier|const
modifier|*
name|id
decl_stmt|;
comment|/* Function: looks up id in the list of symbolic names starting  * with pointer SYMBOLS, and returns a pointer to the corresponding  * revision number.  Return 0 if not present.  */
block|{
specifier|register
name|struct
name|assoc
specifier|const
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|next
operator|=
name|Symbols
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|nextassoc
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|id
argument_list|,
name|next
operator|->
name|symbol
argument_list|)
operator|==
literal|0
condition|)
return|return
name|next
operator|->
name|num
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|expandsym
parameter_list|(
name|source
parameter_list|,
name|target
parameter_list|)
name|char
specifier|const
modifier|*
name|source
decl_stmt|;
name|struct
name|buf
modifier|*
name|target
decl_stmt|;
comment|/* Function: Source points to a revision number. Expandsym copies  * the number to target, but replaces all symbolic fields in the  * source number with their numeric values.  * Expand a branch followed by `.' to the latest revision on that branch.  * Ignore `.' after a revision.  Remove leading zeros.  * returns false on error;  */
block|{
return|return
name|fexpandsym
argument_list|(
name|source
argument_list|,
name|target
argument_list|,
operator|(
name|RILE
operator|*
operator|)
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|fexpandsym
parameter_list|(
name|source
parameter_list|,
name|target
parameter_list|,
name|fp
parameter_list|)
name|char
specifier|const
modifier|*
name|source
decl_stmt|;
name|struct
name|buf
modifier|*
name|target
decl_stmt|;
name|RILE
modifier|*
name|fp
decl_stmt|;
comment|/* Same as expandsym, except if FP is nonzero, it is used to expand KDELIM.  */
block|{
specifier|register
name|char
specifier|const
modifier|*
name|sp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
name|char
specifier|const
modifier|*
name|tlim
decl_stmt|;
name|int
name|dots
decl_stmt|;
name|sp
operator|=
name|source
expr_stmt|;
name|bufalloc
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tp
operator|=
name|target
operator|->
name|string
expr_stmt|;
if|if
condition|(
operator|!
name|sp
operator|||
operator|!
operator|*
name|sp
condition|)
block|{
comment|/* Accept 0 pointer as a legal value.  */
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|sp
index|[
literal|0
index|]
operator|==
name|KDELIM
operator|&&
operator|!
name|sp
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|getoldkeys
argument_list|(
name|fp
argument_list|)
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
operator|*
name|prevrev
operator|.
name|string
condition|)
block|{
name|workerror
argument_list|(
literal|"working file lacks revision number"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|bufscpy
argument_list|(
name|target
argument_list|,
name|prevrev
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|tlim
operator|=
name|tp
operator|+
name|target
operator|->
name|size
expr_stmt|;
name|dots
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|tp
decl_stmt|;
name|size_t
name|s
init|=
name|tp
operator|-
name|target
operator|->
name|string
decl_stmt|;
name|int
name|id
init|=
name|false
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|ctab
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|sp
index|]
condition|)
block|{
case|case
name|IDCHAR
case|:
case|case
name|LETTER
case|:
case|case
name|Letter
case|:
name|id
operator|=
name|true
expr_stmt|;
comment|/* fall into */
case|case
name|DIGIT
case|:
if|if
condition|(
name|tlim
operator|<=
name|p
condition|)
name|p
operator|=
name|bufenlarge
argument_list|(
name|target
argument_list|,
operator|&
name|tlim
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|tlim
operator|<=
name|p
condition|)
name|p
operator|=
name|bufenlarge
argument_list|(
name|target
argument_list|,
operator|&
name|tlim
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|tp
operator|=
name|target
operator|->
name|string
operator|+
name|s
expr_stmt|;
if|if
condition|(
name|id
condition|)
block|{
name|bp
operator|=
name|lookupsym
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bp
condition|)
block|{
name|rcserror
argument_list|(
literal|"Symbolic name `%s' is undefined."
argument_list|,
name|tp
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
else|else
block|{
comment|/* skip leading zeros */
for|for
control|(
name|bp
operator|=
name|tp
init|;
operator|*
name|bp
operator|==
literal|'0'
operator|&&
name|isdigit
argument_list|(
name|bp
index|[
literal|1
index|]
argument_list|)
condition|;
name|bp
operator|++
control|)
continue|continue;
if|if
condition|(
operator|!
operator|*
name|bp
condition|)
if|if
condition|(
name|s
operator|||
operator|*
name|sp
operator|!=
literal|'.'
condition|)
break|break;
else|else
block|{
comment|/* Insert default branch before initial `.'.  */
name|char
specifier|const
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|Dbranch
condition|)
name|b
operator|=
name|Dbranch
expr_stmt|;
elseif|else
if|if
condition|(
name|Head
condition|)
name|b
operator|=
name|Head
operator|->
name|num
expr_stmt|;
else|else
break|break;
name|getbranchno
argument_list|(
name|b
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|bp
operator|=
name|tp
operator|=
name|target
operator|->
name|string
expr_stmt|;
name|tlim
operator|=
name|tp
operator|+
name|target
operator|->
name|size
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|(
operator|*
name|tp
operator|++
operator|=
operator|*
name|bp
operator|++
operator|)
condition|)
if|if
condition|(
name|tlim
operator|<=
name|tp
condition|)
name|tp
operator|=
name|bufenlarge
argument_list|(
name|target
argument_list|,
operator|&
name|tlim
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|sp
operator|++
condition|)
block|{
case|case
literal|'\0'
case|:
return|return
name|true
return|;
case|case
literal|'.'
case|:
if|if
condition|(
operator|!
operator|*
name|sp
condition|)
block|{
if|if
condition|(
name|dots
operator|&
literal|1
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|bp
operator|=
name|branchtip
argument_list|(
name|target
operator|->
name|string
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
name|bufscpy
argument_list|(
name|target
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
operator|++
name|dots
expr_stmt|;
name|tp
index|[
operator|-
literal|1
index|]
operator|=
literal|'.'
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|rcserror
argument_list|(
literal|"improper revision number: %s"
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
name|char
specifier|const
modifier|*
name|namedrev
parameter_list|(
name|name
parameter_list|,
name|delta
parameter_list|)
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
comment|/* Yield NAME if it names DELTA, 0 otherwise.  */
block|{
if|if
condition|(
name|name
condition|)
block|{
name|char
specifier|const
modifier|*
name|id
init|=
literal|0
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|val
decl_stmt|;
for|for
control|(
name|p
operator|=
name|name
init|;
condition|;
name|p
operator|++
control|)
switch|switch
condition|(
name|ctab
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
condition|)
block|{
case|case
name|IDCHAR
case|:
case|case
name|LETTER
case|:
case|case
name|Letter
case|:
name|id
operator|=
name|name
expr_stmt|;
break|break;
case|case
name|DIGIT
case|:
break|break;
case|case
name|UNKN
case|:
if|if
condition|(
operator|!
operator|*
name|p
operator|&&
name|id
operator|&&
operator|(
name|val
operator|=
name|lookupsym
argument_list|(
name|id
argument_list|)
operator|)
operator|&&
name|strcmp
argument_list|(
name|val
argument_list|,
name|delta
operator|->
name|num
argument_list|)
operator|==
literal|0
condition|)
return|return
name|id
return|;
comment|/* fall into */
default|default:
return|return
literal|0
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|branchtip
parameter_list|(
name|branch
parameter_list|)
name|char
specifier|const
modifier|*
name|branch
decl_stmt|;
block|{
name|struct
name|hshentry
modifier|*
name|h
decl_stmt|;
name|struct
name|hshentries
modifier|*
name|hs
decl_stmt|;
name|h
operator|=
name|genrevs
argument_list|(
name|branch
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|hs
argument_list|)
expr_stmt|;
return|return
name|h
condition|?
name|h
operator|->
name|num
else|:
operator|(
name|char
specifier|const
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_function
name|char
specifier|const
modifier|*
name|tiprev
parameter_list|()
block|{
return|return
name|Dbranch
condition|?
name|branchtip
argument_list|(
name|Dbranch
argument_list|)
else|:
name|Head
condition|?
name|Head
operator|->
name|num
else|:
operator|(
name|char
specifier|const
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|REVTEST
end_ifdef

begin_comment
comment|/* * Test the routines that generate a sequence of delta numbers * needed to regenerate a given delta. */
end_comment

begin_decl_stmt
name|char
specifier|const
name|cmdid
index|[]
init|=
literal|"revtest"
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|static
name|struct
name|buf
name|numricrevno
decl_stmt|;
name|char
name|symrevno
index|[
literal|100
index|]
decl_stmt|;
comment|/* used for input of revision numbers */
name|char
name|author
index|[
literal|20
index|]
decl_stmt|;
name|char
name|state
index|[
literal|20
index|]
decl_stmt|;
name|char
name|date
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|hshentries
modifier|*
name|gendeltas
decl_stmt|;
name|struct
name|hshentry
modifier|*
name|target
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|aputs
argument_list|(
literal|"No input file\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exitmain
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|finptr
operator|=
name|Iopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|FOPEN_R
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
literal|0
argument_list|)
operator|)
condition|)
block|{
name|faterror
argument_list|(
literal|"can't open input file %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|Lexinit
argument_list|()
expr_stmt|;
name|getadmin
argument_list|()
expr_stmt|;
name|gettree
argument_list|()
expr_stmt|;
name|getdesc
argument_list|(
name|false
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* all output goes to stderr, to have diagnostics and       */
comment|/* errors in sequence.                                      */
name|aputs
argument_list|(
literal|"\nEnter revision number or<return> or '.': "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|symrevno
argument_list|,
literal|100
argument_list|,
name|stdin
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|symrevno
operator|==
literal|'.'
condition|)
break|break;
name|aprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s;\n"
argument_list|,
name|symrevno
argument_list|)
expr_stmt|;
name|expandsym
argument_list|(
name|symrevno
argument_list|,
operator|&
name|numricrevno
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
name|stderr
argument_list|,
literal|"expanded number: %s; "
argument_list|,
name|numricrevno
operator|.
name|string
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
name|stderr
argument_list|,
literal|"Date: "
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|date
argument_list|,
literal|20
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s; "
argument_list|,
name|date
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
name|stderr
argument_list|,
literal|"Author: "
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|author
argument_list|,
literal|20
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s; "
argument_list|,
name|author
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
name|stderr
argument_list|,
literal|"State: "
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|state
argument_list|,
literal|20
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|aprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s;\n"
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|target
operator|=
name|genrevs
argument_list|(
name|numricrevno
operator|.
name|string
argument_list|,
operator|*
name|date
condition|?
name|date
else|:
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|*
name|author
condition|?
name|author
else|:
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|*
name|state
condition|?
name|state
else|:
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|gendeltas
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
block|{
while|while
condition|(
name|gendeltas
condition|)
block|{
name|aprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|gendeltas
operator|->
name|first
operator|->
name|num
argument_list|)
expr_stmt|;
name|gendeltas
operator|=
name|gendeltas
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|true
condition|)
do|;
name|aprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
expr_stmt|;
name|exitmain
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|exiterr
parameter_list|()
block|{
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

