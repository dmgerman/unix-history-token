begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *                       rcsmerge operation  */
end_comment

begin_comment
comment|/*****************************************************************************  *                       join 2 revisions with respect to a third  *****************************************************************************  */
end_comment

begin_comment
comment|/* Copyright (C) 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991 by Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/* $Log: rcsmerge.c,v $  * Revision 5.7  1991/11/20  17:58:09  eggert  * Don't Iopen(f, "r+"); it's not portable.  *  * Revision 5.6  1991/08/19  03:13:55  eggert  * Add -r$.  Tune.  *  * Revision 5.5  1991/04/21  11:58:27  eggert  * Add -x, RCSINIT, MS-DOS support.  *  * Revision 5.4  1991/02/25  07:12:43  eggert  * Merging a revision to itself is no longer an error.  *  * Revision 5.3  1990/11/01  05:03:50  eggert  * Remove unneeded setid check.  *  * Revision 5.2  1990/09/04  08:02:28  eggert  * Check for I/O error when reading working file.  *  * Revision 5.1  1990/08/29  07:14:04  eggert  * Add -q.  Pass -L options to merge.  *  * Revision 5.0  1990/08/22  08:13:41  eggert  * Propagate merge's exit status.  * Remove compile-time limits; use malloc instead.  * Make lock and temp files faster and safer.  Ansify and Posixate.  Add -V.  * Don't use access().  Tune.  *  * Revision 4.5  89/05/01  15:13:16  narten  * changed copyright header to reflect current distribution rules  *   * Revision 4.4  88/08/09  19:13:13  eggert  * Beware merging into a readonly file.  * Beware merging a revision to itself (no change).  * Use execv(), not system(); yield exit status like diff(1)'s.  *   * Revision 4.3  87/10/18  10:38:02  narten  * Updating version numbers. Changes relative to version 1.1   * actually relative to 4.1  *   * Revision 1.3  87/09/24  14:00:31  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf   * warnings)  *   * Revision 1.2  87/03/27  14:22:36  jenkins  * Port to suns  *   * Revision 4.1  83/03/28  11:14:57  wft  * Added handling of default branch.  *   * Revision 3.3  82/12/24  15:29:00  wft  * Added call to catchsig().  *  * Revision 3.2  82/12/10  21:32:02  wft  * Replaced getdelta() with gettree(); improved error messages.  *  * Revision 3.1  82/11/28  19:27:44  wft  * Initial revision.  *  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_decl_stmt
specifier|static
name|char
specifier|const
name|co
index|[]
init|=
name|CO
decl_stmt|;
end_decl_stmt

begin_macro
name|mainProg
argument_list|(
argument|rcsmergeId
argument_list|,
literal|"rcsmerge"
argument_list|,
literal|"$Id: rcsmerge.c,v 5.7 1991/11/20 17:58:09 eggert Exp $"
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|char
specifier|const
name|cmdusage
index|[]
init|=
literal|"\nrcsmerge usage: rcsmerge -rrev1 [-rrev2] [-p] [-Vn] file"
decl_stmt|;
specifier|static
name|char
specifier|const
name|quietarg
index|[]
init|=
literal|"-q"
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
modifier|*
name|newargv
decl_stmt|;
name|char
specifier|const
modifier|*
name|arg
index|[
literal|3
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
name|rev
index|[
literal|2
index|]
decl_stmt|;
comment|/*revision numbers*/
name|char
specifier|const
modifier|*
name|expandarg
decl_stmt|,
modifier|*
name|versionarg
decl_stmt|;
name|int
name|tostdout
decl_stmt|;
name|int
name|status
decl_stmt|;
name|RILE
modifier|*
name|workptr
decl_stmt|;
name|struct
name|buf
name|commarg
decl_stmt|;
name|struct
name|buf
name|numericrev
decl_stmt|;
comment|/* holds expanded revision number */
name|struct
name|hshentries
modifier|*
name|gendeltas
decl_stmt|;
comment|/* deltas to be generated */
name|struct
name|hshentry
modifier|*
name|target
decl_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|commarg
argument_list|)
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|numericrev
argument_list|)
expr_stmt|;
name|rev
index|[
literal|0
index|]
operator|=
name|rev
index|[
literal|1
index|]
operator|=
name|nil
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
comment|/* Keep lint happy.  */
name|tostdout
operator|=
name|false
expr_stmt|;
name|expandarg
operator|=
name|versionarg
operator|=
name|quietarg
expr_stmt|;
comment|/* i.e. a no-op */
name|suffixes
operator|=
name|X_DEFAULT
expr_stmt|;
name|argc
operator|=
name|getRCSINIT
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|newargv
argument_list|)
expr_stmt|;
name|argv
operator|=
name|newargv
expr_stmt|;
while|while
condition|(
name|a
operator|=
operator|*
operator|++
name|argv
operator|,
literal|0
operator|<
operator|--
name|argc
operator|&&
operator|*
name|a
operator|++
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
operator|*
name|a
operator|++
condition|)
block|{
case|case
literal|'p'
case|:
name|tostdout
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'q'
case|:
name|quietflag
operator|=
name|true
expr_stmt|;
name|revno
label|:
if|if
condition|(
operator|!
operator|*
name|a
condition|)
break|break;
comment|/* falls into -r */
case|case
literal|'r'
case|:
if|if
condition|(
operator|!
name|rev
index|[
literal|0
index|]
condition|)
name|rev
index|[
literal|0
index|]
operator|=
name|a
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|rev
index|[
literal|1
index|]
condition|)
name|rev
index|[
literal|1
index|]
operator|=
name|a
expr_stmt|;
else|else
name|faterror
argument_list|(
literal|"too many revision numbers"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|suffixes
operator|=
name|a
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|versionarg
operator|=
operator|*
name|argv
expr_stmt|;
name|setRCSversion
argument_list|(
name|versionarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|expandarg
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|str2expmode
argument_list|(
name|expandarg
operator|+
literal|2
argument_list|)
condition|)
break|break;
comment|/* fall into */
default|default:
name|faterror
argument_list|(
literal|"unknown option: %s%s"
argument_list|,
operator|*
name|argv
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
comment|/* end of option processing */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|faterror
argument_list|(
literal|"no input file%s"
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rev
index|[
literal|0
index|]
condition|)
name|faterror
argument_list|(
literal|"no base revision number given"
argument_list|)
expr_stmt|;
comment|/* now handle all filenames */
if|if
condition|(
literal|0
operator|<
name|pairfilenames
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|rcsreadopen
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
condition|)
block|{
if|if
condition|(
name|argc
operator|>
literal|2
operator|||
operator|(
name|argc
operator|==
literal|2
operator|&&
name|argv
index|[
literal|1
index|]
operator|!=
name|nil
operator|)
condition|)
name|warn
argument_list|(
literal|"too many arguments"
argument_list|)
expr_stmt|;
name|diagnose
argument_list|(
literal|"RCS file: %s\n"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|workptr
operator|=
name|Iopen
argument_list|(
name|workfilename
argument_list|,
name|FOPEN_R_WORK
argument_list|,
operator|(
expr|struct
name|stat
operator|*
operator|)
literal|0
argument_list|)
operator|)
condition|)
name|efaterror
argument_list|(
name|workfilename
argument_list|)
expr_stmt|;
name|gettree
argument_list|()
expr_stmt|;
comment|/* reads in the delta tree */
if|if
condition|(
name|Head
operator|==
name|nil
condition|)
name|faterror
argument_list|(
literal|"no revisions present"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|rev
index|[
literal|0
index|]
condition|)
name|rev
index|[
literal|0
index|]
operator|=
name|Dbranch
condition|?
name|Dbranch
else|:
name|Head
operator|->
name|num
expr_stmt|;
if|if
condition|(
operator|!
name|fexpandsym
argument_list|(
name|rev
index|[
literal|0
index|]
argument_list|,
operator|&
name|numericrev
argument_list|,
name|workptr
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
operator|(
name|target
operator|=
name|genrevs
argument_list|(
name|numericrev
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|&
name|gendeltas
argument_list|)
operator|)
condition|)
goto|goto
name|end
goto|;
name|rev
index|[
literal|0
index|]
operator|=
name|target
operator|->
name|num
expr_stmt|;
if|if
condition|(
operator|!
name|rev
index|[
literal|1
index|]
operator|||
operator|!
operator|*
name|rev
index|[
literal|1
index|]
condition|)
name|rev
index|[
literal|1
index|]
operator|=
name|Dbranch
condition|?
name|Dbranch
else|:
name|Head
operator|->
name|num
expr_stmt|;
if|if
condition|(
operator|!
name|fexpandsym
argument_list|(
name|rev
index|[
literal|1
index|]
argument_list|,
operator|&
name|numericrev
argument_list|,
name|workptr
argument_list|)
condition|)
goto|goto
name|end
goto|;
if|if
condition|(
operator|!
operator|(
name|target
operator|=
name|genrevs
argument_list|(
name|numericrev
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|&
name|gendeltas
argument_list|)
operator|)
condition|)
goto|goto
name|end
goto|;
name|rev
index|[
literal|1
index|]
operator|=
name|target
operator|->
name|num
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|rev
index|[
literal|0
index|]
argument_list|,
name|rev
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tostdout
condition|)
block|{
name|FILE
modifier|*
name|o
decl_stmt|;
if|#
directive|if
name|text_equals_binary_stdio
operator|||
name|text_work_stdio
name|o
operator|=
name|stdout
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|o
operator|=
name|fdopen
argument_list|(
name|STDOUT_FILENO
argument_list|,
name|FOPEN_W_WORK
argument_list|)
operator|)
condition|)
name|efaterror
argument_list|(
literal|"stdout"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fastcopy
argument_list|(
name|workptr
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|Ofclose
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
goto|goto
name|end
goto|;
block|}
name|Izclose
argument_list|(
operator|&
name|workptr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|diagnose
argument_list|(
literal|"retrieving revision %s\n"
argument_list|,
name|rev
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bufscpy
argument_list|(
operator|&
name|commarg
argument_list|,
literal|"-p"
argument_list|)
expr_stmt|;
name|bufscat
argument_list|(
operator|&
name|commarg
argument_list|,
name|rev
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
comment|/* Do not collide with merger.c maketemp().  */
name|arg
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|maketemp
argument_list|(
name|i
operator|+
literal|3
argument_list|)
argument_list|,
name|co
argument_list|,
name|quietarg
argument_list|,
name|commarg
operator|.
name|string
argument_list|,
name|expandarg
argument_list|,
name|versionarg
argument_list|,
name|RCSfilename
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
condition|)
name|faterror
argument_list|(
literal|"co failed"
argument_list|)
expr_stmt|;
block|}
name|diagnose
argument_list|(
literal|"Merging differences between %s and %s into %s%s\n"
argument_list|,
name|rev
index|[
literal|0
index|]
argument_list|,
name|rev
index|[
literal|1
index|]
argument_list|,
name|workfilename
argument_list|,
name|tostdout
condition|?
literal|"; result to stdout"
else|:
literal|""
argument_list|)
expr_stmt|;
name|arg
index|[
literal|0
index|]
operator|=
name|rev
index|[
literal|0
index|]
operator|=
name|workfilename
expr_stmt|;
name|status
operator|=
name|merge
argument_list|(
name|tostdout
argument_list|,
name|rev
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|end
label|:
name|Izclose
argument_list|(
operator|&
name|workptr
argument_list|)
expr_stmt|;
name|tempunlink
argument_list|()
expr_stmt|;
name|exitmain
argument_list|(
name|nerror
condition|?
name|DIFF_TROUBLE
else|:
name|status
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|lint
end_if

begin_define
define|#
directive|define
name|exiterr
value|rmergeExit
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|exiting
name|void
name|exiterr
parameter_list|()
block|{
name|tempunlink
argument_list|()
expr_stmt|;
name|_exit
argument_list|(
name|DIFF_TROUBLE
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

