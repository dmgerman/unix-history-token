begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Check in revisions of RCS files from working files.  */
end_comment

begin_comment
comment|/* Copyright 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991, 1992, 1993, 1994, 1995 Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/*  * $Log: ci.c,v $  * Revision 5.30  1995/06/16 06:19:24  eggert  * Update FSF address.  *  * Revision 5.29  1995/06/01 16:23:43  eggert  * (main): Add -kb.  * Use `cmpdate', not `cmpnum', to compare dates.  * This is for MKS RCS's incompatible 20th-century date format.  * Don't worry about errno after ftruncate fails.  * Fix input file rewinding bug when large_memory&& !maps_memory  * and checking in a branch tip.  *  * (fixwork): Fall back on chmod if fchmod fails, since it might be ENOSYS.  *  * Revision 5.28  1994/03/20 04:52:58  eggert  * Do not generate a corrupted RCS file if the user modifies the working file  * while `ci' is running.  * Do not remove the lock when `ci -l' reverts.  * Move buffer-flushes out of critical sections, since they aren't critical.  * Use ORCSerror to clean up after a fatal error.  * Specify subprocess input via file descriptor, not file name.  *  * Revision 5.27  1993/11/09 17:40:15  eggert  * -V now prints version on stdout and exits.  Don't print usage twice.  *  * Revision 5.26  1993/11/03 17:42:27  eggert  * Add -z.  Don't subtract from RCS file timestamp even if -T.  * Scan for and use Name keyword if -k.  * Don't discard ignored phrases.  Improve quality of diagnostics.  *  * Revision 5.25  1992/07/28  16:12:44  eggert  * Add -i, -j, -V.  Check that working and RCS files are distinct.  *  * Revision 5.24  1992/02/17  23:02:06  eggert  * `-rREV' now just specifies a revision REV; only bare `-r' reverts to default.  * Add -T.  *  * Revision 5.23  1992/01/27  16:42:51  eggert  * Always unlock branchpoint if caller has a lock.  * Add support for bad_chmod_close, bad_creat0.  lint -> RCS_lint  *  * Revision 5.22  1992/01/06  02:42:34  eggert  * Invoke utime() before chmod() to keep some buggy systems happy.  *  * Revision 5.21  1991/11/20  17:58:07  eggert  * Don't read the delta tree from a nonexistent RCS file.  *  * Revision 5.20  1991/10/07  17:32:46  eggert  * Fix log bugs.  Remove lint.  *  * Revision 5.19  1991/09/26  23:10:30  eggert  * Plug file descriptor leak.  *  * Revision 5.18  1991/09/18  07:29:10  eggert  * Work around a common ftruncate() bug.  *  * Revision 5.17  1991/09/10  22:15:46  eggert  * Fix test for redirected stdin.  *  * Revision 5.16  1991/08/19  23:17:54  eggert  * When there are no changes, revert to previous revision instead of aborting.  * Add piece tables, -M, -r$.  Tune.  *  * Revision 5.15  1991/04/21  11:58:14  eggert  * Ensure that working file is newer than RCS file after ci -[lu].  * Add -x, RCSINIT, MS-DOS support.  *  * Revision 5.14  1991/02/28  19:18:47  eggert  * Don't let a setuid ci create a new RCS file; rcs -i -a must be run first.  * Fix ci -ko -l mode bug.  Open work file at most once.  *  * Revision 5.13  1991/02/25  07:12:33  eggert  * getdate -> getcurdate (SVR4 name clash)  *  * Revision 5.12  1990/12/31  01:00:12  eggert  * Don't use uninitialized storage when handling -{N,n}.  *  * Revision 5.11  1990/12/04  05:18:36  eggert  * Use -I for prompts and -q for diagnostics.  *  * Revision 5.10  1990/11/05  20:30:10  eggert  * Don't remove working file when aborting due to no changes.  *  * Revision 5.9  1990/11/01  05:03:23  eggert  * Add -I and new -t behavior.  Permit arbitrary data in logs.  *  * Revision 5.8  1990/10/04  06:30:09  eggert  * Accumulate exit status across files.  *  * Revision 5.7  1990/09/25  20:11:46  hammer  * fixed another small typo  *  * Revision 5.6  1990/09/24  21:48:50  hammer  * added cleanups from Paul Eggert.  *  * Revision 5.5  1990/09/21  06:16:38  hammer  * made it handle multiple -{N,n}'s.  Also, made it treat re-directed stdin  * the same as the terminal  *  * Revision 5.4  1990/09/20  02:38:51  eggert  * ci -k now checks dates more thoroughly.  *  * Revision 5.3  1990/09/11  02:41:07  eggert  * Fix revision bug with `ci -k file1 file2'.  *  * Revision 5.2  1990/09/04  08:02:10  eggert  * Permit adjacent revisions with identical time stamps (possible on fast hosts).  * Improve incomplete line handling.  Standardize yes-or-no procedure.  *  * Revision 5.1  1990/08/29  07:13:44  eggert  * Expand locker value like co.  Clean old log messages too.  *  * Revision 5.0  1990/08/22  08:10:00  eggert  * Don't require a final newline.  * Make lock and temp files faster and safer.  * Remove compile-time limits; use malloc instead.  * Permit dates past 1999/12/31.  Switch to GMT.  * Add setuid support.  Don't pass +args to diff.  Check diff's output.  * Ansify and Posixate.  Add -k, -V.  Remove snooping.  Tune.  * Check diff's output.  *  * Revision 4.9  89/05/01  15:10:54  narten  * changed copyright header to reflect current distribution rules  *   * Revision 4.8  88/11/08  13:38:23  narten  * changes from root@seismo.CSS.GOV (Super User)  * -d with no arguments uses the mod time of the file it is checking in  *   * Revision 4.7  88/08/09  19:12:07  eggert  * Make sure workfile is a regular file; use its mode if RCSfile doesn't have one.  * Use execv(), not system(); allow cc -R; remove lint.  * isatty(fileno(stdin)) -> ttystdin()  *   * Revision 4.6  87/12/18  11:34:41  narten  * lint cleanups (from Guy Harris)  *   * Revision 4.5  87/10/18  10:18:48  narten  * Updating version numbers. Changes relative to revision 1.1 are actually  * relative to 4.3  *   * Revision 1.3  87/09/24  13:57:19  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf   * warnings)  *   * Revision 1.2  87/03/27  14:21:33  jenkins  * Port to suns  *   * Revision 4.3  83/12/15  12:28:54  wft  * ci -u and ci -l now set mode of working file properly.  *   * Revision 4.2  83/12/05  13:40:54  wft  * Merged with 3.9.1.1: added calls to clearerr(stdin).  * made rewriteflag external.  *   * Revision 4.1  83/05/10  17:03:06  wft  * Added option -d and -w, and updated assingment of date, etc. to new delta.  * Added handling of default branches.  * Option -k generates std. log message; fixed undef. pointer in reading of log.  * Replaced getlock() with findlock(), link--unlink with rename(),  * getpwuid() with getcaller().  * Moved all revision number generation to new routine addelta().  * Removed calls to stat(); now done by pairfilenames().  * Changed most calls to catchints() with restoreints().  * Directed all interactive messages to stderr.  *   * Revision 3.9.1.1  83/10/19  04:21:03  lepreau  * Added clearerr(stdin) to getlogmsg() for re-reading stdin.  *   * Revision 3.9  83/02/15  15:25:44  wft  * 4.2 prerelease  *   * Revision 3.9  83/02/15  15:25:44  wft  * Added call to fastcopy() to copy remainder of RCS file.  *  * Revision 3.8  83/01/14  15:34:05  wft  * Added ignoring of interrupts while new RCS file is renamed;  * Avoids deletion of RCS files by interrupts.  *  * Revision 3.7  82/12/10  16:09:20  wft  * Corrected checking of return code from diff.  *  * Revision 3.6  82/12/08  21:34:49  wft  * Using DATEFORM to prepare date of checked-in revision;  * Fixed return from addbranch().  *  * Revision 3.5  82/12/04  18:32:42  wft  * Replaced getdelta() with gettree(), SNOOPDIR with SNOOPFILE. Updated  * field lockedby in removelock(), moved getlogmsg() before calling diff.  *  * Revision 3.4  82/12/02  13:27:13  wft  * added option -k.  *  * Revision 3.3  82/11/28  20:53:31  wft  * Added mustcheckin() to check for redundant checkins.  * Added xpandfile() to do keyword expansion for -u and -l;  * -m appends linefeed to log message if necessary.  * getlogmsg() suppresses prompt if stdin is not a terminal.  * Replaced keeplock with lockflag, fclose() with ffclose(),  * %02d with %.2d, getlogin() with getpwuid().  *  * Revision 3.2  82/10/18  20:57:23  wft  * An RCS file inherits its mode during the first ci from the working file,  * otherwise it stays the same, except that write permission is removed.  * Fixed ci -l, added ci -u (both do an implicit co after the ci).  * Fixed call to getlogin(), added call to getfullRCSname(), added check  * for write error.  * Changed conflicting identifiers.  *  * Revision 3.1  82/10/13  16:04:59  wft  * fixed type of variables receiving from getc() (char -> int).  * added include file dbm.h for getting BYTESIZ. This is used  * to check the return code from diff portably.  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_struct
struct|struct
name|Symrev
block|{
name|char
specifier|const
modifier|*
name|ssymbol
decl_stmt|;
name|int
name|override
decl_stmt|;
name|struct
name|Symrev
modifier|*
name|nextsym
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|getcurdate
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|addbranch
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|addelta
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|addsyms
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fixwork
name|P
argument_list|(
operator|(
name|mode_t
operator|,
name|time_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|removelock
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xpandfile
name|P
argument_list|(
operator|(
name|RILE
operator|*
operator|,
expr|struct
name|hshentry
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cbuf
name|getlogmsg
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cleanup
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|incnum
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|addassoclst
name|P
argument_list|(
operator|(
name|int
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|exfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|RILE
modifier|*
name|workptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* working file pointer		*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buf
name|newdelnum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new revision number		*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cbuf
name|msg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|exitstatus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|forceciflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* forces check in		*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|keepflag
decl_stmt|,
name|keepworkingfile
decl_stmt|,
name|rcsinitflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hshentries
modifier|*
name|gendeltas
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* deltas to be generated	*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hshentry
modifier|*
name|targetdelta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* old delta to be generated	*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hshentry
name|newdelta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new delta to be inserted	*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|stat
name|workstat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|Symrev
modifier|*
name|assoclst
decl_stmt|,
modifier|*
modifier|*
name|nextassoc
decl_stmt|;
end_decl_stmt

begin_macro
name|mainProg
argument_list|(
argument|ciId
argument_list|,
literal|"ci"
argument_list|,
literal|"$Id: ci.c,v 5.30 1995/06/16 06:19:24 eggert Exp $"
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|char
specifier|const
name|cmdusage
index|[]
init|=
literal|"\nci usage: ci -{fIklMqru}[rev] -d[date] -mmsg -{nN}name -sstate -ttext -T -Vn -wwho -xsuff -zzone file ..."
decl_stmt|;
specifier|static
name|char
specifier|const
name|default_state
index|[]
init|=
name|DEFAULTSTATE
decl_stmt|;
name|char
name|altdate
index|[
name|datesize
index|]
decl_stmt|;
name|char
name|olddate
index|[
name|datesize
index|]
decl_stmt|;
name|char
name|newdatebuf
index|[
name|datesize
operator|+
name|zonelenmax
index|]
decl_stmt|;
name|char
name|targetdatebuf
index|[
name|datesize
operator|+
name|zonelenmax
index|]
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
modifier|*
name|newargv
decl_stmt|,
modifier|*
name|textfile
decl_stmt|;
name|char
specifier|const
modifier|*
name|author
decl_stmt|,
modifier|*
name|krev
decl_stmt|,
modifier|*
name|rev
decl_stmt|,
modifier|*
name|state
decl_stmt|;
name|char
specifier|const
modifier|*
name|diffname
decl_stmt|,
modifier|*
name|expname
decl_stmt|;
name|char
specifier|const
modifier|*
name|newworkname
decl_stmt|;
name|int
name|initflag
decl_stmt|,
name|mustread
decl_stmt|;
name|int
name|lockflag
decl_stmt|,
name|lockthis
decl_stmt|,
name|mtimeflag
decl_stmt|,
name|removedlock
decl_stmt|,
name|Ttimeflag
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|changedRCS
decl_stmt|,
name|changework
decl_stmt|,
name|dolog
decl_stmt|,
name|newhead
decl_stmt|;
name|int
name|usestatdate
decl_stmt|;
comment|/* Use mod time of file for -d.  */
name|mode_t
name|newworkmode
decl_stmt|;
comment|/* mode for working file */
name|time_t
name|mtime
decl_stmt|,
name|wtime
decl_stmt|;
name|struct
name|hshentry
modifier|*
name|workdelta
decl_stmt|;
name|setrid
argument_list|()
expr_stmt|;
name|author
operator|=
name|rev
operator|=
name|state
operator|=
name|textfile
operator|=
literal|0
expr_stmt|;
name|initflag
operator|=
name|lockflag
operator|=
name|mustread
operator|=
name|false
expr_stmt|;
name|mtimeflag
operator|=
name|false
expr_stmt|;
name|Ttimeflag
operator|=
name|false
expr_stmt|;
name|altdate
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* empty alternate date for -d */
name|usestatdate
operator|=
name|false
expr_stmt|;
name|suffixes
operator|=
name|X_DEFAULT
expr_stmt|;
name|nextassoc
operator|=
operator|&
name|assoclst
expr_stmt|;
name|argc
operator|=
name|getRCSINIT
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|newargv
argument_list|)
expr_stmt|;
name|argv
operator|=
name|newargv
expr_stmt|;
while|while
condition|(
name|a
operator|=
operator|*
operator|++
name|argv
operator|,
literal|0
operator|<
operator|--
name|argc
operator|&&
operator|*
name|a
operator|++
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
operator|*
name|a
operator|++
condition|)
block|{
case|case
literal|'r'
case|:
if|if
condition|(
operator|*
name|a
condition|)
goto|goto
name|revno
goto|;
name|keepworkingfile
operator|=
name|lockflag
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|keepworkingfile
operator|=
name|lockflag
operator|=
name|true
expr_stmt|;
name|revno
label|:
if|if
condition|(
operator|*
name|a
condition|)
block|{
if|if
condition|(
name|rev
condition|)
name|warn
argument_list|(
literal|"redefinition of revision number"
argument_list|)
expr_stmt|;
name|rev
operator|=
name|a
expr_stmt|;
block|}
break|break;
case|case
literal|'u'
case|:
name|keepworkingfile
operator|=
name|true
expr_stmt|;
name|lockflag
operator|=
name|false
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'i'
case|:
name|initflag
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'j'
case|:
name|mustread
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'I'
case|:
name|interactiveflag
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'q'
case|:
name|quietflag
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'f'
case|:
name|forceciflag
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'k'
case|:
name|keepflag
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'m'
case|:
if|if
condition|(
name|msg
operator|.
name|size
condition|)
name|redefined
argument_list|(
literal|'m'
argument_list|)
expr_stmt|;
name|msg
operator|=
name|cleanlogmsg
argument_list|(
name|a
argument_list|,
name|strlen
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
operator|.
name|size
condition|)
name|error
argument_list|(
literal|"missing message for -m option"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
operator|!
operator|*
name|a
condition|)
block|{
name|error
argument_list|(
literal|"missing symbolic name after -n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|checkssym
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|addassoclst
argument_list|(
name|false
argument_list|,
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
if|if
condition|(
operator|!
operator|*
name|a
condition|)
block|{
name|error
argument_list|(
literal|"missing symbolic name after -N"
argument_list|)
expr_stmt|;
break|break;
block|}
name|checkssym
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|addassoclst
argument_list|(
name|true
argument_list|,
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
operator|*
name|a
condition|)
block|{
if|if
condition|(
name|state
condition|)
name|redefined
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
name|checksid
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|state
operator|=
name|a
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"missing state for -s option"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
operator|*
name|a
condition|)
block|{
if|if
condition|(
name|textfile
condition|)
name|redefined
argument_list|(
literal|'t'
argument_list|)
expr_stmt|;
name|textfile
operator|=
name|a
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|altdate
index|[
literal|0
index|]
operator|||
name|usestatdate
condition|)
name|redefined
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
name|altdate
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|usestatdate
operator|=
operator|!
operator|*
name|a
operator|)
condition|)
name|str2date
argument_list|(
name|a
argument_list|,
name|altdate
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|mtimeflag
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'w'
case|:
if|if
condition|(
operator|*
name|a
condition|)
block|{
if|if
condition|(
name|author
condition|)
name|redefined
argument_list|(
literal|'w'
argument_list|)
expr_stmt|;
name|checksid
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|author
operator|=
name|a
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"missing author for -w option"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|suffixes
operator|=
name|a
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|setRCSversion
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|zone_set
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
operator|!
operator|*
name|a
condition|)
block|{
name|Ttimeflag
operator|=
name|true
expr_stmt|;
break|break;
block|}
comment|/* fall into */
default|default:
name|error
argument_list|(
literal|"unknown option: %s%s"
argument_list|,
operator|*
name|argv
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
comment|/* end processing of options */
comment|/* Handle all pathnames.  */
if|if
condition|(
name|nerror
condition|)
name|cleanup
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|faterror
argument_list|(
literal|"no input file%s"
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
literal|0
operator|<
name|argc
condition|;
name|cleanup
argument_list|()
operator|,
operator|++
name|argv
operator|,
operator|--
name|argc
control|)
block|{
name|targetdelta
operator|=
literal|0
expr_stmt|;
name|ffree
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|pairnames
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|rcswriteopen
argument_list|,
name|mustread
argument_list|,
name|false
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* New RCS file */
if|#
directive|if
name|has_setuid
operator|&&
name|has_getuid
if|if
condition|(
name|euid
argument_list|()
operator|!=
name|ruid
argument_list|()
condition|)
block|{
name|workerror
argument_list|(
literal|"setuid initial checkin prohibited; use `rcs -i -a' first"
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
name|rcsinitflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* Error */
continue|continue;
case|case
literal|1
case|:
comment|/* Normal checkin with prev . RCS file */
if|if
condition|(
name|initflag
condition|)
block|{
name|rcserror
argument_list|(
literal|"already exists"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|rcsinitflag
operator|=
operator|!
name|Head
expr_stmt|;
block|}
comment|/* 	 * RCSname contains the name of the RCS file, and 	 * workname contains the name of the working file. 	 * If the RCS file exists, finptr contains the file descriptor for the 	 * RCS file, and RCSstat is set. The admin node is initialized.          */
name|diagnose
argument_list|(
literal|"%s<--  %s\n"
argument_list|,
name|RCSname
argument_list|,
name|workname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|workptr
operator|=
name|Iopen
argument_list|(
name|workname
argument_list|,
name|FOPEN_R_WORK
argument_list|,
operator|&
name|workstat
argument_list|)
operator|)
condition|)
block|{
name|eerror
argument_list|(
name|workname
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|finptr
condition|)
block|{
if|if
condition|(
name|same_file
argument_list|(
name|RCSstat
argument_list|,
name|workstat
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rcserror
argument_list|(
literal|"RCS file is the same as working file %s."
argument_list|,
name|workname
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|checkaccesslist
argument_list|()
condition|)
continue|continue;
block|}
name|krev
operator|=
name|rev
expr_stmt|;
if|if
condition|(
name|keepflag
condition|)
block|{
comment|/* get keyword values from working file */
if|if
condition|(
operator|!
name|getoldkeys
argument_list|(
name|workptr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|rev
operator|&&
operator|!
operator|*
operator|(
name|krev
operator|=
name|prevrev
operator|.
name|string
operator|)
condition|)
block|{
name|workerror
argument_list|(
literal|"can't find a revision number"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|*
name|prevdate
operator|.
name|string
operator|&&
operator|*
name|altdate
operator|==
literal|'\0'
operator|&&
name|usestatdate
operator|==
name|false
condition|)
name|workwarn
argument_list|(
literal|"can't find a date"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|prevauthor
operator|.
name|string
operator|&&
operator|!
name|author
condition|)
name|workwarn
argument_list|(
literal|"can't find an author"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|prevstate
operator|.
name|string
operator|&&
operator|!
name|state
condition|)
name|workwarn
argument_list|(
literal|"can't find a state"
argument_list|)
expr_stmt|;
block|}
comment|/* end processing keepflag */
comment|/* Read the delta tree.  */
if|if
condition|(
name|finptr
condition|)
name|gettree
argument_list|()
expr_stmt|;
comment|/* expand symbolic revision number */
if|if
condition|(
operator|!
name|fexpandsym
argument_list|(
name|krev
argument_list|,
operator|&
name|newdelnum
argument_list|,
name|workptr
argument_list|)
condition|)
continue|continue;
comment|/* splice new delta into tree */
if|if
condition|(
operator|(
name|removedlock
operator|=
name|addelta
argument_list|()
operator|)
operator|<
literal|0
condition|)
continue|continue;
name|newdelta
operator|.
name|num
operator|=
name|newdelnum
operator|.
name|string
expr_stmt|;
name|newdelta
operator|.
name|branches
operator|=
literal|0
expr_stmt|;
name|newdelta
operator|.
name|lockedby
operator|=
literal|0
expr_stmt|;
comment|/* This might be changed by addlock().  */
name|newdelta
operator|.
name|selector
operator|=
name|true
expr_stmt|;
name|newdelta
operator|.
name|name
operator|=
literal|0
expr_stmt|;
name|clear_buf
argument_list|(
operator|&
name|newdelta
operator|.
name|ig
argument_list|)
expr_stmt|;
name|clear_buf
argument_list|(
operator|&
name|newdelta
operator|.
name|igtext
argument_list|)
expr_stmt|;
comment|/* set author */
if|if
condition|(
name|author
condition|)
name|newdelta
operator|.
name|author
operator|=
name|author
expr_stmt|;
comment|/* set author given by -w         */
elseif|else
if|if
condition|(
name|keepflag
operator|&&
operator|*
name|prevauthor
operator|.
name|string
condition|)
name|newdelta
operator|.
name|author
operator|=
name|prevauthor
operator|.
name|string
expr_stmt|;
comment|/* preserve old author if possible*/
else|else
name|newdelta
operator|.
name|author
operator|=
name|getcaller
argument_list|()
expr_stmt|;
comment|/* otherwise use caller's id      */
name|newdelta
operator|.
name|state
operator|=
name|default_state
expr_stmt|;
if|if
condition|(
name|state
condition|)
name|newdelta
operator|.
name|state
operator|=
name|state
expr_stmt|;
comment|/* set state given by -s          */
elseif|else
if|if
condition|(
name|keepflag
operator|&&
operator|*
name|prevstate
operator|.
name|string
condition|)
name|newdelta
operator|.
name|state
operator|=
name|prevstate
operator|.
name|string
expr_stmt|;
comment|/* preserve old state if possible */
if|if
condition|(
name|usestatdate
condition|)
block|{
name|time2date
argument_list|(
name|workstat
operator|.
name|st_mtime
argument_list|,
name|altdate
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|altdate
operator|!=
literal|'\0'
condition|)
name|newdelta
operator|.
name|date
operator|=
name|altdate
expr_stmt|;
comment|/* set date given by -d           */
elseif|else
if|if
condition|(
name|keepflag
operator|&&
operator|*
name|prevdate
operator|.
name|string
condition|)
block|{
comment|/* Preserve old date if possible.  */
name|str2date
argument_list|(
name|prevdate
operator|.
name|string
argument_list|,
name|olddate
argument_list|)
expr_stmt|;
name|newdelta
operator|.
name|date
operator|=
name|olddate
expr_stmt|;
block|}
else|else
name|newdelta
operator|.
name|date
operator|=
name|getcurdate
argument_list|()
expr_stmt|;
comment|/* use current date */
comment|/* now check validity of date -- needed because of -d and -k          */
if|if
condition|(
name|targetdelta
operator|&&
name|cmpdate
argument_list|(
name|newdelta
operator|.
name|date
argument_list|,
name|targetdelta
operator|->
name|date
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rcserror
argument_list|(
literal|"Date %s precedes %s in revision %s."
argument_list|,
name|date2str
argument_list|(
name|newdelta
operator|.
name|date
argument_list|,
name|newdatebuf
argument_list|)
argument_list|,
name|date2str
argument_list|(
name|targetdelta
operator|->
name|date
argument_list|,
name|targetdatebuf
argument_list|)
argument_list|,
name|targetdelta
operator|->
name|num
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|lockflag
operator|&&
name|addlock
argument_list|(
operator|&
name|newdelta
argument_list|,
name|true
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|keepflag
operator|&&
operator|*
name|prevname
operator|.
name|string
condition|)
if|if
condition|(
name|addsymbol
argument_list|(
name|newdelta
operator|.
name|num
argument_list|,
name|prevname
operator|.
name|string
argument_list|,
name|false
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|addsyms
argument_list|(
name|newdelta
operator|.
name|num
argument_list|)
condition|)
continue|continue;
name|putadmin
argument_list|()
expr_stmt|;
name|puttree
argument_list|(
name|Head
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
name|putdesc
argument_list|(
name|false
argument_list|,
name|textfile
argument_list|)
expr_stmt|;
name|changework
operator|=
name|Expand
operator|<
name|MIN_UNCHANGED_EXPAND
expr_stmt|;
name|dolog
operator|=
name|true
expr_stmt|;
name|lockthis
operator|=
name|lockflag
expr_stmt|;
name|workdelta
operator|=
operator|&
name|newdelta
expr_stmt|;
comment|/* build rest of file */
if|if
condition|(
name|rcsinitflag
condition|)
block|{
name|diagnose
argument_list|(
literal|"initial revision: %s\n"
argument_list|,
name|newdelta
operator|.
name|num
argument_list|)
expr_stmt|;
comment|/* get logmessage */
name|newdelta
operator|.
name|log
operator|=
name|getlogmsg
argument_list|()
expr_stmt|;
name|putdftext
argument_list|(
operator|&
name|newdelta
argument_list|,
name|workptr
argument_list|,
name|frewrite
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|RCSstat
operator|.
name|st_mode
operator|=
name|workstat
operator|.
name|st_mode
expr_stmt|;
name|RCSstat
operator|.
name|st_nlink
operator|=
literal|0
expr_stmt|;
name|changedRCS
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|diffname
operator|=
name|maketemp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|newhead
operator|=
name|Head
operator|==
operator|&
name|newdelta
expr_stmt|;
if|if
condition|(
operator|!
name|newhead
condition|)
name|foutptr
operator|=
name|frewrite
expr_stmt|;
name|expname
operator|=
name|buildrevision
argument_list|(
name|gendeltas
argument_list|,
name|targetdelta
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|forceciflag
operator|&&
name|strcmp
argument_list|(
name|newdelta
operator|.
name|state
argument_list|,
name|targetdelta
operator|->
name|state
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|changework
operator|=
name|rcsfcmp
argument_list|(
name|workptr
argument_list|,
operator|&
name|workstat
argument_list|,
name|expname
argument_list|,
name|targetdelta
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|diagnose
argument_list|(
literal|"file is unchanged; reverting to previous revision %s\n"
argument_list|,
name|targetdelta
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|removedlock
operator|<
name|lockflag
condition|)
block|{
name|diagnose
argument_list|(
literal|"previous revision was not locked; ignoring -l option\n"
argument_list|)
expr_stmt|;
name|lockthis
operator|=
literal|0
expr_stmt|;
block|}
name|dolog
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|changedRCS
operator|=
name|lockflag
operator|<
name|removedlock
operator|||
name|assoclst
operator|)
condition|)
name|workdelta
operator|=
name|targetdelta
expr_stmt|;
else|else
block|{
comment|/* 			 * We have started to build the wrong new RCS file. 			 * Start over from the beginning. 			 */
name|long
name|hwm
init|=
name|ftell
argument_list|(
name|frewrite
argument_list|)
decl_stmt|;
name|int
name|bad_truncate
decl_stmt|;
name|Orewind
argument_list|(
name|frewrite
argument_list|)
expr_stmt|;
comment|/* 			* Work around a common ftruncate() bug: 			* NFS won't let you truncate a file that you 			* currently lack permissions for, even if you 			* had permissions when you opened it. 			* Also, Posix 1003.1b-1993 sec 5.6.7.2 p 128 l 1022 			* says ftruncate might fail because it's not supported. 			*/
if|#
directive|if
operator|!
name|has_ftruncate
undef|#
directive|undef
name|ftruncate
define|#
directive|define
name|ftruncate
parameter_list|(
name|fd
parameter_list|,
name|length
parameter_list|)
value|(-1)
endif|#
directive|endif
name|bad_truncate
operator|=
name|ftruncate
argument_list|(
name|fileno
argument_list|(
name|frewrite
argument_list|)
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|Irewind
argument_list|(
name|finptr
argument_list|)
expr_stmt|;
name|Lexinit
argument_list|()
expr_stmt|;
name|getadmin
argument_list|()
expr_stmt|;
name|gettree
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|workdelta
operator|=
name|genrevs
argument_list|(
name|targetdelta
operator|->
name|num
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|gendeltas
argument_list|)
operator|)
condition|)
continue|continue;
name|workdelta
operator|->
name|log
operator|=
name|targetdelta
operator|->
name|log
expr_stmt|;
if|if
condition|(
name|newdelta
operator|.
name|state
operator|!=
name|default_state
condition|)
name|workdelta
operator|->
name|state
operator|=
name|newdelta
operator|.
name|state
expr_stmt|;
if|if
condition|(
name|lockthis
operator|<
name|removedlock
operator|&&
name|removelock
argument_list|(
name|workdelta
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|addsyms
argument_list|(
name|workdelta
operator|->
name|num
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|dorewrite
argument_list|(
name|true
argument_list|,
name|true
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|fastcopy
argument_list|(
name|finptr
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad_truncate
condition|)
while|while
condition|(
name|ftell
argument_list|(
name|frewrite
argument_list|)
operator|<
name|hwm
condition|)
comment|/* White out any earlier mistake with '\n's.  */
comment|/* This is unlikely.  */
name|afputc
argument_list|(
literal|'\n'
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|wfd
init|=
name|Ifileno
argument_list|(
name|workptr
argument_list|)
decl_stmt|;
name|struct
name|stat
name|checkworkstat
decl_stmt|;
name|char
specifier|const
modifier|*
name|diffv
index|[
literal|6
operator|+
operator|!
operator|!
name|OPEN_O_BINARY
index|]
decl_stmt|,
modifier|*
modifier|*
name|diffp
decl_stmt|;
if|#
directive|if
name|large_memory
operator|&&
operator|!
name|maps_memory
name|FILE
modifier|*
name|wfile
init|=
name|workptr
operator|->
name|stream
decl_stmt|;
name|long
name|wfile_off
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|has_fflush_input
operator|&&
operator|!
operator|(
name|large_memory
operator|&&
name|maps_memory
operator|)
name|off_t
name|wfd_off
decl_stmt|;
endif|#
directive|endif
name|diagnose
argument_list|(
literal|"new revision: %s; previous revision: %s\n"
argument_list|,
name|newdelta
operator|.
name|num
argument_list|,
name|targetdelta
operator|->
name|num
argument_list|)
expr_stmt|;
name|newdelta
operator|.
name|log
operator|=
name|getlogmsg
argument_list|()
expr_stmt|;
if|#
directive|if
operator|!
name|large_memory
name|Irewind
argument_list|(
name|workptr
argument_list|)
expr_stmt|;
if|#
directive|if
name|has_fflush_input
if|if
condition|(
name|fflush
argument_list|(
name|workptr
argument_list|)
operator|!=
literal|0
condition|)
name|Ierror
argument_list|()
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
if|#
directive|if
operator|!
name|maps_memory
if|if
condition|(
operator|(
name|wfile_off
operator|=
name|ftell
argument_list|(
name|wfile
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|||
name|fseek
argument_list|(
name|wfile
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
if|#
directive|if
name|has_fflush_input
operator|||
name|fflush
argument_list|(
name|wfile
argument_list|)
operator|!=
literal|0
endif|#
directive|endif
condition|)
name|Ierror
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
operator|!
name|has_fflush_input
operator|&&
operator|!
operator|(
name|large_memory
operator|&&
name|maps_memory
operator|)
name|wfd_off
operator|=
name|lseek
argument_list|(
name|wfd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
if|if
condition|(
name|wfd_off
operator|==
operator|-
literal|1
operator|||
operator|(
name|wfd_off
operator|!=
literal|0
operator|&&
name|lseek
argument_list|(
name|wfd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|Ierror
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|diffp
operator|=
name|diffv
expr_stmt|;
operator|*
operator|++
name|diffp
operator|=
name|DIFF
expr_stmt|;
operator|*
operator|++
name|diffp
operator|=
name|DIFFFLAGS
expr_stmt|;
if|#
directive|if
name|OPEN_O_BINARY
if|if
condition|(
name|Expand
operator|==
name|BINARY_EXPAND
condition|)
operator|*
operator|++
name|diffp
operator|=
literal|"--binary"
expr_stmt|;
endif|#
directive|endif
operator|*
operator|++
name|diffp
operator|=
name|newhead
condition|?
literal|"-"
else|:
name|expname
expr_stmt|;
operator|*
operator|++
name|diffp
operator|=
name|newhead
condition|?
name|expname
else|:
literal|"-"
expr_stmt|;
operator|*
operator|++
name|diffp
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|runv
argument_list|(
name|wfd
argument_list|,
name|diffname
argument_list|,
name|diffv
argument_list|)
condition|)
block|{
case|case
name|DIFF_FAILURE
case|:
case|case
name|DIFF_SUCCESS
case|:
break|break;
default|default:
name|rcsfaterror
argument_list|(
literal|"diff failed"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|has_fflush_input
operator|&&
operator|!
operator|(
name|large_memory
operator|&&
name|maps_memory
operator|)
if|if
condition|(
name|lseek
argument_list|(
name|wfd
argument_list|,
name|wfd_off
argument_list|,
name|SEEK_CUR
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|Ierror
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|large_memory
operator|&&
operator|!
name|maps_memory
if|if
condition|(
name|fseek
argument_list|(
name|wfile
argument_list|,
name|wfile_off
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
condition|)
name|Ierror
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|newhead
condition|)
block|{
name|Irewind
argument_list|(
name|workptr
argument_list|)
expr_stmt|;
name|putdftext
argument_list|(
operator|&
name|newdelta
argument_list|,
name|workptr
argument_list|,
name|frewrite
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|putdtext
argument_list|(
name|targetdelta
argument_list|,
name|diffname
argument_list|,
name|frewrite
argument_list|,
name|true
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|putdtext
argument_list|(
operator|&
name|newdelta
argument_list|,
name|diffname
argument_list|,
name|frewrite
argument_list|,
name|true
argument_list|)
condition|)
continue|continue;
comment|/* 		    * Check whether the working file changed during checkin, 		    * to avoid producing an inconsistent RCS file. 		    */
if|if
condition|(
name|fstat
argument_list|(
name|wfd
argument_list|,
operator|&
name|checkworkstat
argument_list|)
operator|!=
literal|0
operator|||
name|workstat
operator|.
name|st_mtime
operator|!=
name|checkworkstat
operator|.
name|st_mtime
operator|||
name|workstat
operator|.
name|st_size
operator|!=
name|checkworkstat
operator|.
name|st_size
condition|)
block|{
name|workerror
argument_list|(
literal|"file changed during checkin"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|changedRCS
operator|=
name|true
expr_stmt|;
block|}
block|}
comment|/* Deduce time_t of new revision if it is needed later.  */
name|wtime
operator|=
operator|(
name|time_t
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|mtimeflag
operator||
name|Ttimeflag
condition|)
name|wtime
operator|=
name|date2time
argument_list|(
name|workdelta
operator|->
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
name|donerewrite
argument_list|(
name|changedRCS
argument_list|,
operator|!
name|Ttimeflag
condition|?
operator|(
name|time_t
operator|)
operator|-
literal|1
else|:
name|finptr
operator|&&
name|wtime
operator|<
name|RCSstat
operator|.
name|st_mtime
condition|?
name|RCSstat
operator|.
name|st_mtime
else|:
name|wtime
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|keepworkingfile
condition|)
block|{
name|Izclose
argument_list|(
operator|&
name|workptr
argument_list|)
expr_stmt|;
name|r
operator|=
name|un_link
argument_list|(
name|workname
argument_list|)
expr_stmt|;
comment|/* Get rid of old file */
block|}
else|else
block|{
name|newworkmode
operator|=
name|WORKMODE
argument_list|(
name|RCSstat
operator|.
name|st_mode
argument_list|,
operator|!
operator|(
name|Expand
operator|==
name|VAL_EXPAND
operator|||
name|lockthis
operator|<
name|StrictLocks
operator|)
argument_list|)
expr_stmt|;
name|mtime
operator|=
name|mtimeflag
condition|?
name|wtime
else|:
operator|(
name|time_t
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Expand if it might change or if we can't fix mode, time.  */
if|if
condition|(
name|changework
operator|||
operator|(
name|r
operator|=
name|fixwork
argument_list|(
name|newworkmode
argument_list|,
name|mtime
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|Irewind
argument_list|(
name|workptr
argument_list|)
expr_stmt|;
comment|/* Expand keywords in file.  */
name|locker_expansion
operator|=
name|lockthis
expr_stmt|;
name|workdelta
operator|->
name|name
operator|=
name|namedrev
argument_list|(
name|assoclst
condition|?
name|assoclst
operator|->
name|ssymbol
else|:
name|keepflag
operator|&&
operator|*
name|prevname
operator|.
name|string
condition|?
name|prevname
operator|.
name|string
else|:
name|rev
argument_list|,
name|workdelta
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|xpandfile
argument_list|(
name|workptr
argument_list|,
name|workdelta
argument_list|,
operator|&
name|newworkname
argument_list|,
name|dolog
argument_list|)
condition|)
block|{
default|default:
continue|continue;
case|case
literal|0
case|:
comment|/* 			     * No expansion occurred; try to reuse working file 			     * unless we already tried and failed. 			     */
if|if
condition|(
name|changework
condition|)
if|if
condition|(
operator|(
name|r
operator|=
name|fixwork
argument_list|(
name|newworkmode
argument_list|,
name|mtime
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* fall into */
case|case
literal|1
case|:
name|Izclose
argument_list|(
operator|&
name|workptr
argument_list|)
expr_stmt|;
name|aflush
argument_list|(
name|exfile
argument_list|)
expr_stmt|;
name|ignoreints
argument_list|()
expr_stmt|;
name|r
operator|=
name|chnamemod
argument_list|(
operator|&
name|exfile
argument_list|,
name|newworkname
argument_list|,
name|workname
argument_list|,
literal|1
argument_list|,
name|newworkmode
argument_list|,
name|mtime
argument_list|)
expr_stmt|;
name|keepdirtemp
argument_list|(
name|newworkname
argument_list|)
expr_stmt|;
name|restoreints
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|eerror
argument_list|(
name|workname
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|diagnose
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
block|}
name|tempunlink
argument_list|()
expr_stmt|;
name|exitmain
argument_list|(
name|exitstatus
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end of main (ci) */
end_comment

begin_function
specifier|static
name|void
name|cleanup
parameter_list|()
block|{
if|if
condition|(
name|nerror
condition|)
name|exitstatus
operator|=
name|EXIT_FAILURE
expr_stmt|;
name|Izclose
argument_list|(
operator|&
name|finptr
argument_list|)
expr_stmt|;
name|Izclose
argument_list|(
operator|&
name|workptr
argument_list|)
expr_stmt|;
name|Ozclose
argument_list|(
operator|&
name|exfile
argument_list|)
expr_stmt|;
name|Ozclose
argument_list|(
operator|&
name|fcopy
argument_list|)
expr_stmt|;
name|ORCSclose
argument_list|()
expr_stmt|;
name|dirtempunlink
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|RCS_lint
end_if

begin_define
define|#
directive|define
name|exiterr
value|ciExit
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|exiterr
parameter_list|()
block|{
name|ORCSerror
argument_list|()
expr_stmt|;
name|dirtempunlink
argument_list|()
expr_stmt|;
name|tempunlink
argument_list|()
expr_stmt|;
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************/
end_comment

begin_comment
comment|/* the rest are auxiliary routines                               */
end_comment

begin_function
specifier|static
name|int
name|addelta
parameter_list|()
comment|/* Function: Appends a delta to the delta tree, whose number is  * given by newdelnum.  Updates Head, newdelnum, newdelnumlength,  * and the links in newdelta.  * Return -1 on error, 1 if a lock is removed, 0 otherwise.  */
block|{
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|removedlock
decl_stmt|;
name|int
name|newdnumlength
decl_stmt|;
comment|/* actual length of new rev. num. */
name|newdnumlength
operator|=
name|countnumflds
argument_list|(
name|newdelnum
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcsinitflag
condition|)
block|{
comment|/* this covers non-existing RCS file and a file initialized with rcs -i */
if|if
condition|(
name|newdnumlength
operator|==
literal|0
operator|&&
name|Dbranch
condition|)
block|{
name|bufscpy
argument_list|(
operator|&
name|newdelnum
argument_list|,
name|Dbranch
argument_list|)
expr_stmt|;
name|newdnumlength
operator|=
name|countnumflds
argument_list|(
name|Dbranch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newdnumlength
operator|==
literal|0
condition|)
name|bufscpy
argument_list|(
operator|&
name|newdelnum
argument_list|,
literal|"1.1"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|newdnumlength
operator|==
literal|1
condition|)
name|bufscat
argument_list|(
operator|&
name|newdelnum
argument_list|,
literal|".1"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|newdnumlength
operator|>
literal|2
condition|)
block|{
name|rcserror
argument_list|(
literal|"Branch point doesn't exist for revision %s."
argument_list|,
name|newdelnum
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* newdnumlength == 2 is OK;  */
name|Head
operator|=
operator|&
name|newdelta
expr_stmt|;
name|newdelta
operator|.
name|next
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|newdnumlength
operator|==
literal|0
condition|)
block|{
comment|/* derive new revision number from locks */
switch|switch
condition|(
name|findlock
argument_list|(
name|true
argument_list|,
operator|&
name|targetdelta
argument_list|)
condition|)
block|{
default|default:
comment|/* found two or more old locks */
return|return
operator|-
literal|1
return|;
case|case
literal|1
case|:
comment|/* found an old lock */
comment|/* check whether locked revision exists */
if|if
condition|(
operator|!
name|genrevs
argument_list|(
name|targetdelta
operator|->
name|num
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|gendeltas
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|targetdelta
operator|==
name|Head
condition|)
block|{
comment|/* make new head */
name|newdelta
operator|.
name|next
operator|=
name|Head
expr_stmt|;
name|Head
operator|=
operator|&
name|newdelta
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|targetdelta
operator|->
name|next
operator|&&
name|countnumflds
argument_list|(
name|targetdelta
operator|->
name|num
argument_list|)
operator|>
literal|2
condition|)
block|{
comment|/* new tip revision on side branch */
name|targetdelta
operator|->
name|next
operator|=
operator|&
name|newdelta
expr_stmt|;
name|newdelta
operator|.
name|next
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* middle revision; start a new branch */
name|bufscpy
argument_list|(
operator|&
name|newdelnum
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|addbranch
argument_list|(
name|targetdelta
argument_list|,
operator|&
name|newdelnum
argument_list|,
literal|1
argument_list|)
return|;
block|}
name|incnum
argument_list|(
name|targetdelta
operator|->
name|num
argument_list|,
operator|&
name|newdelnum
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* successful use of existing lock */
case|case
literal|0
case|:
comment|/* no existing lock; try Dbranch */
comment|/* update newdelnum */
if|if
condition|(
name|StrictLocks
operator|||
operator|!
name|myself
argument_list|(
name|RCSstat
operator|.
name|st_uid
argument_list|)
condition|)
block|{
name|rcserror
argument_list|(
literal|"no lock set by %s"
argument_list|,
name|getcaller
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|Dbranch
condition|)
block|{
name|bufscpy
argument_list|(
operator|&
name|newdelnum
argument_list|,
name|Dbranch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|incnum
argument_list|(
name|Head
operator|->
name|num
argument_list|,
operator|&
name|newdelnum
argument_list|)
expr_stmt|;
block|}
name|newdnumlength
operator|=
name|countnumflds
argument_list|(
name|newdelnum
operator|.
name|string
argument_list|)
expr_stmt|;
comment|/* now fall into next statement */
block|}
block|}
if|if
condition|(
name|newdnumlength
operator|<=
literal|2
condition|)
block|{
comment|/* add new head per given number */
if|if
condition|(
name|newdnumlength
operator|==
literal|1
condition|)
block|{
comment|/* make a two-field number out of it*/
if|if
condition|(
name|cmpnumfld
argument_list|(
name|newdelnum
operator|.
name|string
argument_list|,
name|Head
operator|->
name|num
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|incnum
argument_list|(
name|Head
operator|->
name|num
argument_list|,
operator|&
name|newdelnum
argument_list|)
expr_stmt|;
else|else
name|bufscat
argument_list|(
operator|&
name|newdelnum
argument_list|,
literal|".1"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmpnum
argument_list|(
name|newdelnum
operator|.
name|string
argument_list|,
name|Head
operator|->
name|num
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|rcserror
argument_list|(
literal|"revision %s too low; must be higher than %s"
argument_list|,
name|newdelnum
operator|.
name|string
argument_list|,
name|Head
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|targetdelta
operator|=
name|Head
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
operator|(
name|removedlock
operator|=
name|removelock
argument_list|(
name|Head
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|genrevs
argument_list|(
name|Head
operator|->
name|num
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|gendeltas
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|newdelta
operator|.
name|next
operator|=
name|Head
expr_stmt|;
name|Head
operator|=
operator|&
name|newdelta
expr_stmt|;
block|}
return|return
name|removedlock
return|;
block|}
else|else
block|{
comment|/* put new revision on side branch */
comment|/*first, get branch point */
name|tp
operator|=
name|newdelnum
operator|.
name|string
expr_stmt|;
for|for
control|(
name|i
operator|=
name|newdnumlength
operator|-
operator|(
operator|(
name|newdnumlength
operator|&
literal|1
operator|)
operator|^
literal|1
operator|)
init|;
operator|--
name|i
condition|;
control|)
while|while
condition|(
operator|*
name|tp
operator|++
operator|!=
literal|'.'
condition|)
continue|continue;
operator|*
operator|--
name|tp
operator|=
literal|0
expr_stmt|;
comment|/* Kill final dot to get old delta temporarily. */
if|if
condition|(
operator|!
operator|(
name|targetdelta
operator|=
name|genrevs
argument_list|(
name|newdelnum
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|gendeltas
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|cmpnum
argument_list|(
name|targetdelta
operator|->
name|num
argument_list|,
name|newdelnum
operator|.
name|string
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rcserror
argument_list|(
literal|"can't find branch point %s"
argument_list|,
name|newdelnum
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|tp
operator|=
literal|'.'
expr_stmt|;
comment|/* Restore final dot. */
return|return
name|addbranch
argument_list|(
name|targetdelta
argument_list|,
operator|&
name|newdelnum
argument_list|,
literal|0
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|addbranch
parameter_list|(
name|branchpoint
parameter_list|,
name|num
parameter_list|,
name|removedlock
parameter_list|)
name|struct
name|hshentry
modifier|*
name|branchpoint
decl_stmt|;
name|struct
name|buf
modifier|*
name|num
decl_stmt|;
name|int
name|removedlock
decl_stmt|;
comment|/* adds a new branch and branch delta at branchpoint.  * If num is the null string, appends the new branch, incrementing  * the highest branch number (initially 1), and setting the level number to 1.  * the new delta and branchhead are in globals newdelta and newbranch, resp.  * the new number is placed into num.  * Return -1 on error, 1 if a lock is removed, 0 otherwise.  * If REMOVEDLOCK is 1, a lock was already removed.  */
block|{
name|struct
name|branchhead
modifier|*
name|bhead
decl_stmt|,
modifier|*
modifier|*
name|btrail
decl_stmt|;
name|struct
name|buf
name|branchnum
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|field
decl_stmt|,
name|numlength
decl_stmt|;
specifier|static
name|struct
name|branchhead
name|newbranch
decl_stmt|;
comment|/* new branch to be inserted */
name|numlength
operator|=
name|countnumflds
argument_list|(
name|num
operator|->
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|branchpoint
operator|->
name|branches
condition|)
block|{
comment|/* start first branch */
name|branchpoint
operator|->
name|branches
operator|=
operator|&
name|newbranch
expr_stmt|;
if|if
condition|(
name|numlength
operator|==
literal|0
condition|)
block|{
name|bufscpy
argument_list|(
name|num
argument_list|,
name|branchpoint
operator|->
name|num
argument_list|)
expr_stmt|;
name|bufscat
argument_list|(
name|num
argument_list|,
literal|".1.1"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numlength
operator|&
literal|1
condition|)
name|bufscat
argument_list|(
name|num
argument_list|,
literal|".1"
argument_list|)
expr_stmt|;
name|newbranch
operator|.
name|nextbranch
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|numlength
operator|==
literal|0
condition|)
block|{
comment|/* append new branch to the end */
name|bhead
operator|=
name|branchpoint
operator|->
name|branches
expr_stmt|;
while|while
condition|(
name|bhead
operator|->
name|nextbranch
condition|)
name|bhead
operator|=
name|bhead
operator|->
name|nextbranch
expr_stmt|;
name|bhead
operator|->
name|nextbranch
operator|=
operator|&
name|newbranch
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|branchnum
argument_list|)
expr_stmt|;
name|getbranchno
argument_list|(
name|bhead
operator|->
name|hsh
operator|->
name|num
argument_list|,
operator|&
name|branchnum
argument_list|)
expr_stmt|;
name|incnum
argument_list|(
name|branchnum
operator|.
name|string
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|bufautoend
argument_list|(
operator|&
name|branchnum
argument_list|)
expr_stmt|;
name|bufscat
argument_list|(
name|num
argument_list|,
literal|".1"
argument_list|)
expr_stmt|;
name|newbranch
operator|.
name|nextbranch
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* place the branch properly */
name|field
operator|=
name|numlength
operator|-
operator|(
operator|(
name|numlength
operator|&
literal|1
operator|)
operator|^
literal|1
operator|)
expr_stmt|;
comment|/* field of branch number */
name|btrail
operator|=
operator|&
name|branchpoint
operator|->
name|branches
expr_stmt|;
while|while
condition|(
literal|0
operator|<
operator|(
name|result
operator|=
name|cmpnumfld
argument_list|(
name|num
operator|->
name|string
argument_list|,
operator|(
operator|*
name|btrail
operator|)
operator|->
name|hsh
operator|->
name|num
argument_list|,
name|field
argument_list|)
operator|)
condition|)
block|{
name|btrail
operator|=
operator|&
operator|(
operator|*
name|btrail
operator|)
operator|->
name|nextbranch
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|btrail
condition|)
block|{
name|result
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
comment|/* insert/append new branchhead */
name|newbranch
operator|.
name|nextbranch
operator|=
operator|*
name|btrail
expr_stmt|;
operator|*
name|btrail
operator|=
operator|&
name|newbranch
expr_stmt|;
if|if
condition|(
name|numlength
operator|&
literal|1
condition|)
name|bufscat
argument_list|(
name|num
argument_list|,
literal|".1"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* branch exists; append to end */
name|bufautobegin
argument_list|(
operator|&
name|branchnum
argument_list|)
expr_stmt|;
name|getbranchno
argument_list|(
name|num
operator|->
name|string
argument_list|,
operator|&
name|branchnum
argument_list|)
expr_stmt|;
name|targetdelta
operator|=
name|genrevs
argument_list|(
name|branchnum
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|gendeltas
argument_list|)
expr_stmt|;
name|bufautoend
argument_list|(
operator|&
name|branchnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|targetdelta
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|cmpnum
argument_list|(
name|num
operator|->
name|string
argument_list|,
name|targetdelta
operator|->
name|num
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|rcserror
argument_list|(
literal|"revision %s too low; must be higher than %s"
argument_list|,
name|num
operator|->
name|string
argument_list|,
name|targetdelta
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|removedlock
operator|&&
literal|0
operator|<=
operator|(
name|removedlock
operator|=
name|removelock
argument_list|(
name|targetdelta
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|numlength
operator|&
literal|1
condition|)
name|incnum
argument_list|(
name|targetdelta
operator|->
name|num
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|targetdelta
operator|->
name|next
operator|=
operator|&
name|newdelta
expr_stmt|;
name|newdelta
operator|.
name|next
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|removedlock
return|;
comment|/* Don't do anything to newbranch.  */
block|}
block|}
name|newbranch
operator|.
name|hsh
operator|=
operator|&
name|newdelta
expr_stmt|;
name|newdelta
operator|.
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|branchpoint
operator|->
name|lockedby
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|branchpoint
operator|->
name|lockedby
argument_list|,
name|getcaller
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
return|return
name|removelock
argument_list|(
name|branchpoint
argument_list|)
return|;
comment|/* This returns 1.  */
return|return
name|removedlock
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|addsyms
parameter_list|(
name|num
parameter_list|)
name|char
specifier|const
modifier|*
name|num
decl_stmt|;
block|{
specifier|register
name|struct
name|Symrev
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|assoclst
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextsym
control|)
if|if
condition|(
name|addsymbol
argument_list|(
name|num
argument_list|,
name|p
operator|->
name|ssymbol
argument_list|,
name|p
operator|->
name|override
argument_list|)
operator|<
literal|0
condition|)
return|return
name|false
return|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|incnum
parameter_list|(
name|onum
parameter_list|,
name|nnum
parameter_list|)
name|char
specifier|const
modifier|*
name|onum
decl_stmt|;
name|struct
name|buf
modifier|*
name|nnum
decl_stmt|;
comment|/* Increment the last field of revision number onum by one and  * place the result into nnum.  */
block|{
specifier|register
name|char
modifier|*
name|tp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
specifier|register
name|size_t
name|l
decl_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|onum
argument_list|)
expr_stmt|;
name|bufalloc
argument_list|(
name|nnum
argument_list|,
name|l
operator|+
literal|2
argument_list|)
expr_stmt|;
name|np
operator|=
name|tp
operator|=
name|nnum
operator|->
name|string
expr_stmt|;
name|VOID
name|strcpy
argument_list|(
name|np
argument_list|,
name|onum
argument_list|)
decl_stmt|;
for|for
control|(
name|tp
operator|=
name|np
operator|+
name|l
init|;
name|np
operator|!=
name|tp
condition|;
control|)
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|--
name|tp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|tp
operator|!=
literal|'9'
condition|)
block|{
operator|++
operator|*
name|tp
expr_stmt|;
return|return;
block|}
operator|*
name|tp
operator|=
literal|'0'
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|++
expr_stmt|;
break|break;
block|}
comment|/* We changed 999 to 000; now change it to 1000.  */
operator|*
name|tp
operator|=
literal|'1'
expr_stmt|;
name|tp
operator|=
name|np
operator|+
name|l
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|tp
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|removelock
parameter_list|(
name|delta
parameter_list|)
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
comment|/* function: Finds the lock held by caller on delta,  * removes it, and returns nonzero if successful.  * Print an error message and return -1 if there is no such lock.  * An exception is if !StrictLocks, and caller is the owner of  * the RCS file. If caller does not have a lock in this case,  * return 0; return 1 if a lock is actually removed.  */
block|{
specifier|register
name|struct
name|rcslock
modifier|*
name|next
decl_stmt|,
modifier|*
modifier|*
name|trail
decl_stmt|;
name|char
specifier|const
modifier|*
name|num
decl_stmt|;
name|num
operator|=
name|delta
operator|->
name|num
expr_stmt|;
for|for
control|(
name|trail
operator|=
operator|&
name|Locks
init|;
operator|(
name|next
operator|=
operator|*
name|trail
operator|)
condition|;
name|trail
operator|=
operator|&
name|next
operator|->
name|nextlock
control|)
if|if
condition|(
name|next
operator|->
name|delta
operator|==
name|delta
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|getcaller
argument_list|()
argument_list|,
name|next
operator|->
name|login
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We found a lock on delta by caller; delete it.  */
operator|*
name|trail
operator|=
name|next
operator|->
name|nextlock
expr_stmt|;
name|delta
operator|->
name|lockedby
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|rcserror
argument_list|(
literal|"revision %s locked by %s"
argument_list|,
name|num
argument_list|,
name|next
operator|->
name|login
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|StrictLocks
operator|&&
name|myself
argument_list|(
name|RCSstat
operator|.
name|st_uid
argument_list|)
condition|)
return|return
literal|0
return|;
name|rcserror
argument_list|(
literal|"no lock set by %s for revision %s"
argument_list|,
name|getcaller
argument_list|()
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|getcurdate
parameter_list|()
comment|/* Return a pointer to the current date.  */
block|{
specifier|static
name|char
name|buffer
index|[
name|datesize
index|]
decl_stmt|;
comment|/* date buffer */
if|if
condition|(
operator|!
name|buffer
index|[
literal|0
index|]
condition|)
name|time2date
argument_list|(
name|now
argument_list|()
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_function
specifier|static
name|int
if|#
directive|if
name|has_prototypes
name|fixwork
parameter_list|(
name|mode_t
name|newworkmode
parameter_list|,
name|time_t
name|mtime
parameter_list|)
comment|/* The `#if has_prototypes' is needed because mode_t might promote to int.  */
else|#
directive|else
function|fixwork
parameter_list|(
name|newworkmode
parameter_list|,
name|mtime
parameter_list|)
name|mode_t
name|newworkmode
decl_stmt|;
name|time_t
name|mtime
decl_stmt|;
endif|#
directive|endif
block|{
return|return
literal|1
operator|<
name|workstat
operator|.
name|st_nlink
operator|||
operator|(
name|newworkmode
operator|&
name|S_IWUSR
operator|&&
operator|!
name|myself
argument_list|(
name|workstat
operator|.
name|st_uid
argument_list|)
operator|)
operator|||
name|setmtime
argument_list|(
name|workname
argument_list|,
name|mtime
argument_list|)
operator|!=
literal|0
condition|?
operator|-
literal|1
else|:
name|workstat
operator|.
name|st_mode
operator|==
name|newworkmode
condition|?
literal|0
if|#
directive|if
name|has_fchmod
else|:
name|fchmod
argument_list|(
name|Ifileno
argument_list|(
name|workptr
argument_list|)
argument_list|,
name|newworkmode
argument_list|)
operator|==
literal|0
condition|?
literal|0
endif|#
directive|endif
if|#
directive|if
name|bad_chmod_close
else|:
operator|-
literal|1
else|#
directive|else
operator|:
name|chmod
argument_list|(
name|workname
argument_list|,
name|newworkmode
argument_list|)
endif|#
directive|endif
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xpandfile
parameter_list|(
name|unexfile
parameter_list|,
name|delta
parameter_list|,
name|exname
parameter_list|,
name|dolog
parameter_list|)
name|RILE
modifier|*
name|unexfile
decl_stmt|;
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
name|char
specifier|const
modifier|*
modifier|*
name|exname
decl_stmt|;
name|int
name|dolog
decl_stmt|;
comment|/*  * Read unexfile and copy it to a  * file, performing keyword substitution with data from delta.  * Return -1 if unsuccessful, 1 if expansion occurred, 0 otherwise.  * If successful, stores the stream descriptor into *EXFILEP  * and its name into *EXNAME.  */
block|{
name|char
specifier|const
modifier|*
name|targetname
decl_stmt|;
name|int
name|e
decl_stmt|,
name|r
decl_stmt|;
name|targetname
operator|=
name|makedirtemp
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|exfile
operator|=
name|fopenSafer
argument_list|(
name|targetname
argument_list|,
name|FOPEN_W_WORK
argument_list|)
operator|)
condition|)
block|{
name|eerror
argument_list|(
name|targetname
argument_list|)
expr_stmt|;
name|workerror
argument_list|(
literal|"can't build working file"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|r
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|MIN_UNEXPAND
operator|<=
name|Expand
condition|)
name|fastcopy
argument_list|(
name|unexfile
argument_list|,
name|exfile
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|e
operator|=
name|expandline
argument_list|(
name|unexfile
argument_list|,
name|exfile
argument_list|,
name|delta
argument_list|,
name|false
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
name|dolog
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|<
literal|0
condition|)
break|break;
name|r
operator||=
name|e
expr_stmt|;
if|if
condition|(
name|e
operator|<=
literal|1
condition|)
break|break;
block|}
block|}
operator|*
name|exname
operator|=
name|targetname
expr_stmt|;
return|return
name|r
operator|&
literal|1
return|;
block|}
end_function

begin_comment
comment|/* --------------------- G E T L O G M S G --------------------------------*/
end_comment

begin_function
specifier|static
name|struct
name|cbuf
name|getlogmsg
parameter_list|()
comment|/* Obtain and yield a log message.  * If a log message is given with -m, yield that message.  * If this is the initial revision, yield a standard log message.  * Otherwise, reads a character string from the terminal.  * Stops after reading EOF or a single '.' on a  * line. getlogmsg prompts the first time it is called for the  * log message; during all later calls it asks whether the previous  * log message can be reused.  */
block|{
specifier|static
name|char
specifier|const
name|emptych
index|[]
init|=
name|EMPTYLOG
decl_stmt|,
name|initialch
index|[]
init|=
literal|"Initial revision"
decl_stmt|;
specifier|static
name|struct
name|cbuf
specifier|const
name|emptylog
init|=
block|{
name|emptych
block|,
sizeof|sizeof
argument_list|(
name|emptych
argument_list|)
operator|-
expr|sizeof
operator|(
name|char
operator|)
block|}
decl_stmt|,
name|initiallog
init|=
block|{
name|initialch
block|,
sizeof|sizeof
argument_list|(
name|initialch
argument_list|)
operator|-
expr|sizeof
operator|(
name|char
operator|)
block|}
decl_stmt|;
specifier|static
name|struct
name|buf
name|logbuf
decl_stmt|;
specifier|static
name|struct
name|cbuf
name|logmsg
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
specifier|register
name|size_t
name|i
decl_stmt|;
name|char
specifier|const
modifier|*
name|caller
decl_stmt|;
if|if
condition|(
name|msg
operator|.
name|size
condition|)
return|return
name|msg
return|;
if|if
condition|(
name|keepflag
condition|)
block|{
comment|/* generate std. log message */
name|caller
operator|=
name|getcaller
argument_list|()
expr_stmt|;
name|i
operator|=
sizeof|sizeof
argument_list|(
name|ciklog
argument_list|)
operator|+
name|strlen
argument_list|(
name|caller
argument_list|)
operator|+
literal|3
expr_stmt|;
name|bufalloc
argument_list|(
operator|&
name|logbuf
argument_list|,
name|i
operator|+
name|datesize
operator|+
name|zonelenmax
argument_list|)
expr_stmt|;
name|tp
operator|=
name|logbuf
operator|.
name|string
expr_stmt|;
name|VOID
name|sprintf
argument_list|(
name|tp
argument_list|,
literal|"%s%s at "
argument_list|,
name|ciklog
argument_list|,
name|caller
argument_list|)
decl_stmt|;
name|VOID
name|date2str
argument_list|(
name|getcurdate
argument_list|()
argument_list|,
name|tp
operator|+
name|i
argument_list|)
decl_stmt|;
name|logmsg
operator|.
name|string
operator|=
name|tp
expr_stmt|;
name|logmsg
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
name|logmsg
return|;
block|}
if|if
condition|(
operator|!
name|targetdelta
operator|&&
operator|(
name|cmpnum
argument_list|(
name|newdelnum
operator|.
name|string
argument_list|,
literal|"1.1"
argument_list|)
operator|==
literal|0
operator|||
name|cmpnum
argument_list|(
name|newdelnum
operator|.
name|string
argument_list|,
literal|"1.0"
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|initiallog
return|;
if|if
condition|(
name|logmsg
operator|.
name|size
condition|)
block|{
comment|/*previous log available*/
if|if
condition|(
name|yesorno
argument_list|(
name|true
argument_list|,
literal|"reuse log message of previous file? [yn](y): "
argument_list|)
condition|)
return|return
name|logmsg
return|;
block|}
comment|/* now read string from stdin */
name|logmsg
operator|=
name|getsstdin
argument_list|(
literal|"m"
argument_list|,
literal|"log message"
argument_list|,
literal|""
argument_list|,
operator|&
name|logbuf
argument_list|)
expr_stmt|;
comment|/* now check whether the log message is not empty */
if|if
condition|(
name|logmsg
operator|.
name|size
condition|)
return|return
name|logmsg
return|;
return|return
name|emptylog
return|;
block|}
end_function

begin_comment
comment|/*  Make a linked list of Symbolic names  */
end_comment

begin_function
specifier|static
name|void
name|addassoclst
parameter_list|(
name|flag
parameter_list|,
name|sp
parameter_list|)
name|int
name|flag
decl_stmt|;
name|char
specifier|const
modifier|*
name|sp
decl_stmt|;
block|{
name|struct
name|Symrev
modifier|*
name|pt
decl_stmt|;
name|pt
operator|=
name|talloc
argument_list|(
expr|struct
name|Symrev
argument_list|)
expr_stmt|;
name|pt
operator|->
name|ssymbol
operator|=
name|sp
expr_stmt|;
name|pt
operator|->
name|override
operator|=
name|flag
expr_stmt|;
name|pt
operator|->
name|nextsym
operator|=
literal|0
expr_stmt|;
operator|*
name|nextassoc
operator|=
name|pt
expr_stmt|;
name|nextassoc
operator|=
operator|&
name|pt
operator|->
name|nextsym
expr_stmt|;
block|}
end_function

end_unit

