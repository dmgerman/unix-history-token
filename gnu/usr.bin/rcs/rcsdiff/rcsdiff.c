begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Compare RCS revisions.  */
end_comment

begin_comment
comment|/* Copyright 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991, 1992, 1993, 1994, 1995 Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/*  * Revision 5.19  1995/06/16 06:19:24  eggert  * Update FSF address.  *  * Revision 5.18  1995/06/01 16:23:43  eggert  * (main): Pass "--binary" if -kb and if --binary makes a difference.  * Don't treat + options specially.  *  * Revision 5.17  1994/03/17 14:05:48  eggert  * Specify subprocess input via file descriptor, not file name.  Remove lint.  *  * Revision 5.16  1993/11/09 17:40:15  eggert  * -V now prints version on stdout and exits.  Don't print usage twice.  *  * Revision 5.15  1993/11/03 17:42:27  eggert  * Add -z.  Ignore -T.  Pass -Vn to `co'.  Add Name keyword.  * Put revision numbers in -c output.  Improve quality of diagnostics.  *  * Revision 5.14  1992/07/28  16:12:44  eggert  * Add -V.  Use co -M for better dates with traditional diff -c.  *  * Revision 5.13  1992/02/17  23:02:23  eggert  * Output more readable context diff headers.  * Suppress needless checkout and comparison of identical revisions.  *  * Revision 5.12  1992/01/24  18:44:19  eggert  * Add GNU diff 1.15.2's new options.  lint -> RCS_lint  *  * Revision 5.11  1992/01/06  02:42:34  eggert  * Update usage string.  *  * Revision 5.10  1991/10/07  17:32:46  eggert  * Remove lint.  *  * Revision 5.9  1991/08/19  03:13:55  eggert  * Add RCSINIT, -r$.  Tune.  *  * Revision 5.8  1991/04/21  11:58:21  eggert  * Add -x, RCSINIT, MS-DOS support.  *  * Revision 5.7  1990/12/13  06:54:07  eggert  * GNU diff 1.15 has -u.  *  * Revision 5.6  1990/11/01  05:03:39  eggert  * Remove unneeded setid check.  *  * Revision 5.5  1990/10/04  06:30:19  eggert  * Accumulate exit status across files.  *  * Revision 5.4  1990/09/27  01:31:43  eggert  * Yield 1, not EXIT_FAILURE, when diffs are found.  *  * Revision 5.3  1990/09/11  02:41:11  eggert  * Simplify -kkvl test.  *  * Revision 5.2  1990/09/04  17:07:19  eggert  * Diff's argv was too small by 1.  *  * Revision 5.1  1990/08/29  07:13:55  eggert  * Add -kkvl.  *  * Revision 5.0  1990/08/22  08:12:46  eggert  * Add -k, -V.  Don't use access().  Add setuid support.  * Remove compile-time limits; use malloc instead.  * Don't pass arguments with leading '+' to diff; GNU DIFF treats them as options.  * Add GNU diff's flags.  Make lock and temp files faster and safer.  * Ansify and Posixate.  *  * Revision 4.6  89/05/01  15:12:27  narten  * changed copyright header to reflect current distribution rules  *  * Revision 4.5  88/08/09  19:12:41  eggert  * Use execv(), not system(); yield exit status like diff(1)s; allow cc -R.  *  * Revision 4.4  87/12/18  11:37:46  narten  * changes Jay Lepreau made in the 4.3 BSD version, to add support for  * "-i", "-w", and "-t" flags and to permit flags to be bundled together,  * merged in.  *  * Revision 4.3  87/10/18  10:31:42  narten  * Updating version numbers. Changes relative to 1.1 actually  * relative to 4.1  *  * Revision 1.3  87/09/24  13:59:21  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf  * warnings)  *  * Revision 1.2  87/03/27  14:22:15  jenkins  * Port to suns  *  * Revision 4.1  83/05/03  22:13:19  wft  * Added default branch, option -q, exit status like diff.  * Added fterror() to replace faterror().  *  * Revision 3.6  83/01/15  17:52:40  wft  * Expanded mainprogram to handle multiple RCS files.  *  * Revision 3.5  83/01/06  09:33:45  wft  * Fixed passing of -c (context) option to diff.  *  * Revision 3.4  82/12/24  15:28:38  wft  * Added call to catchsig().  *  * Revision 3.3  82/12/10  16:08:17  wft  * Corrected checking of return code from diff; improved error msgs.  *  * Revision 3.2  82/12/04  13:20:09  wft  * replaced getdelta() with gettree(). Changed diagnostics.  *  * Revision 3.1  82/11/28  19:25:04  wft  * Initial revision.  *  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_if
if|#
directive|if
name|DIFF_L
end_if

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|setup_label
name|P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|,
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
index|[
name|datesize
index|]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|cleanup
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|exitstatus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|RILE
modifier|*
name|workptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|stat
name|workstat
decl_stmt|;
end_decl_stmt

begin_macro
name|mainProg
argument_list|(
argument|rcsdiffId
argument_list|,
literal|"rcsdiff"
argument_list|,
literal|"$FreeBSD$"
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|char
specifier|const
name|cmdusage
index|[]
init|=
literal|"\nrcsdiff usage: rcsdiff -ksubst -q -rrev1 [-rrev2] -Vn -xsuff -zzone [diff options] file ..."
decl_stmt|;
name|int
name|revnums
decl_stmt|;
comment|/* counter for revision numbers given */
name|char
specifier|const
modifier|*
name|rev1
decl_stmt|,
modifier|*
name|rev2
decl_stmt|;
comment|/* revision numbers from command line */
name|char
specifier|const
modifier|*
name|xrev1
decl_stmt|,
modifier|*
name|xrev2
decl_stmt|;
comment|/* expanded revision numbers */
name|char
specifier|const
modifier|*
name|expandarg
decl_stmt|,
modifier|*
name|lexpandarg
decl_stmt|,
modifier|*
name|suffixarg
decl_stmt|,
modifier|*
name|versionarg
decl_stmt|,
modifier|*
name|zonearg
decl_stmt|;
if|#
directive|if
name|DIFF_L
specifier|static
name|struct
name|buf
name|labelbuf
index|[
literal|2
index|]
decl_stmt|;
name|int
name|file_labels
decl_stmt|;
name|char
specifier|const
modifier|*
modifier|*
name|diff_label1
decl_stmt|,
modifier|*
modifier|*
name|diff_label2
decl_stmt|;
name|char
name|date2
index|[
name|datesize
index|]
decl_stmt|;
endif|#
directive|endif
name|char
specifier|const
modifier|*
name|cov
index|[
literal|10
operator|+
operator|!
name|DIFF_L
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
modifier|*
name|diffv
decl_stmt|,
modifier|*
modifier|*
name|diffp
decl_stmt|,
modifier|*
modifier|*
name|diffpend
decl_stmt|;
comment|/* argv for subsidiary diff */
name|char
specifier|const
modifier|*
modifier|*
name|pp
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|diffvstr
decl_stmt|;
name|struct
name|buf
name|commarg
decl_stmt|;
name|struct
name|buf
name|numericrev
decl_stmt|;
comment|/* expanded revision number */
name|struct
name|hshentries
modifier|*
name|gendeltas
decl_stmt|;
comment|/* deltas to be generated */
name|struct
name|hshentry
modifier|*
name|target
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|dcp
decl_stmt|,
modifier|*
modifier|*
name|newargv
decl_stmt|;
name|int
name|no_diff_means_no_output
decl_stmt|;
specifier|register
name|c
expr_stmt|;
name|exitstatus
operator|=
name|DIFF_SUCCESS
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|commarg
argument_list|)
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|numericrev
argument_list|)
expr_stmt|;
name|revnums
operator|=
literal|0
expr_stmt|;
name|rev1
operator|=
name|rev2
operator|=
name|xrev2
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|DIFF_L
name|file_labels
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|expandarg
operator|=
name|suffixarg
operator|=
name|versionarg
operator|=
name|zonearg
operator|=
literal|0
expr_stmt|;
name|no_diff_means_no_output
operator|=
name|true
expr_stmt|;
name|suffixes
operator|=
name|X_DEFAULT
expr_stmt|;
comment|/*     * Room for runv extra + args [+ --binary] [+ 2 labels]     * + 1 file + 1 trailing null.     */
name|diffv
operator|=
name|tnalloc
argument_list|(
name|char
specifier|const
operator|*
argument_list|,
literal|1
operator|+
name|argc
operator|+
operator|!
operator|!
name|OPEN_O_BINARY
operator|+
literal|2
operator|*
name|DIFF_L
operator|+
literal|2
argument_list|)
expr_stmt|;
name|diffp
operator|=
name|diffv
operator|+
literal|1
expr_stmt|;
operator|*
name|diffp
operator|++
operator|=
name|DIFF
expr_stmt|;
name|argc
operator|=
name|getRCSINIT
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|newargv
argument_list|)
expr_stmt|;
name|argv
operator|=
name|newargv
expr_stmt|;
while|while
condition|(
name|a
operator|=
operator|*
operator|++
name|argv
operator|,
literal|0
operator|<
operator|--
name|argc
operator|&&
operator|*
name|a
operator|++
operator|==
literal|'-'
condition|)
block|{
name|dcp
operator|=
name|a
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|a
operator|++
operator|)
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'r'
case|:
switch|switch
condition|(
operator|++
name|revnums
condition|)
block|{
case|case
literal|1
case|:
name|rev1
operator|=
name|a
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|rev2
operator|=
name|a
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"too many revision numbers"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|option_handled
goto|;
case|case
literal|'-'
case|:
case|case
literal|'D'
case|:
name|no_diff_means_no_output
operator|=
name|false
expr_stmt|;
comment|/* fall into */
case|case
literal|'C'
case|:
case|case
literal|'F'
case|:
case|case
literal|'I'
case|:
case|case
literal|'L'
case|:
case|case
literal|'W'
case|:
if|#
directive|if
name|DIFF_L
if|if
condition|(
name|c
operator|==
literal|'L'
operator|&&
name|file_labels
operator|++
operator|==
literal|2
condition|)
name|faterror
argument_list|(
literal|"too many -L options"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|dcp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|*
name|a
condition|)
do|do
operator|*
name|dcp
operator|++
operator|=
operator|*
name|a
operator|++
expr_stmt|;
do|while
condition|(
operator|*
name|a
condition|)
do|;
else|else
block|{
if|if
condition|(
operator|!
operator|--
name|argc
condition|)
name|faterror
argument_list|(
literal|"-%c needs following argument%s"
argument_list|,
name|c
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
operator|*
name|diffp
operator|++
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'y'
case|:
name|no_diff_means_no_output
operator|=
name|false
expr_stmt|;
comment|/* fall into */
case|case
literal|'B'
case|:
case|case
literal|'H'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'p'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'w'
case|:
operator|*
name|dcp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quietflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|suffixarg
operator|=
operator|*
name|argv
expr_stmt|;
name|suffixes
operator|=
operator|*
name|argv
operator|+
literal|2
expr_stmt|;
goto|goto
name|option_handled
goto|;
case|case
literal|'z'
case|:
name|zonearg
operator|=
operator|*
name|argv
expr_stmt|;
name|zone_set
argument_list|(
operator|*
name|argv
operator|+
literal|2
argument_list|)
expr_stmt|;
goto|goto
name|option_handled
goto|;
case|case
literal|'T'
case|:
comment|/* Ignore -T, so that RCSINIT can contain -T.  */
if|if
condition|(
operator|*
name|a
condition|)
goto|goto
name|unknown
goto|;
break|break;
case|case
literal|'V'
case|:
name|versionarg
operator|=
operator|*
name|argv
expr_stmt|;
name|setRCSversion
argument_list|(
name|versionarg
argument_list|)
expr_stmt|;
goto|goto
name|option_handled
goto|;
case|case
literal|'k'
case|:
name|expandarg
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|str2expmode
argument_list|(
name|expandarg
operator|+
literal|2
argument_list|)
condition|)
goto|goto
name|option_handled
goto|;
comment|/* fall into */
default|default:
name|unknown
label|:
name|error
argument_list|(
literal|"unknown option: %s%s"
argument_list|,
operator|*
name|argv
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|option_handled
label|:
if|if
condition|(
name|dcp
operator|!=
operator|*
name|argv
operator|+
literal|1
condition|)
block|{
operator|*
name|dcp
operator|=
literal|0
expr_stmt|;
operator|*
name|diffp
operator|++
operator|=
operator|*
name|argv
expr_stmt|;
block|}
block|}
comment|/* end of option processing */
for|for
control|(
name|pp
operator|=
name|diffv
operator|+
literal|2
operator|,
name|c
operator|=
literal|0
init|;
name|pp
operator|<
name|diffp
condition|;
control|)
name|c
operator|+=
name|strlen
argument_list|(
operator|*
name|pp
operator|++
argument_list|)
operator|+
literal|1
expr_stmt|;
name|diffvstr
operator|=
name|a
operator|=
name|tnalloc
argument_list|(
name|char
argument_list|,
name|c
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|diffv
operator|+
literal|2
init|;
name|pp
operator|<
name|diffp
condition|;
control|)
block|{
name|p
operator|=
operator|*
name|pp
operator|++
expr_stmt|;
operator|*
name|a
operator|++
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|a
operator|=
operator|*
name|p
operator|++
operator|)
condition|)
name|a
operator|++
expr_stmt|;
block|}
operator|*
name|a
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|DIFF_L
name|diff_label1
operator|=
name|diff_label2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|file_labels
operator|<
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|file_labels
condition|)
name|diff_label1
operator|=
name|diffp
operator|++
expr_stmt|;
name|diff_label2
operator|=
name|diffp
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
name|diffpend
operator|=
name|diffp
expr_stmt|;
name|cov
index|[
literal|1
index|]
operator|=
name|CO
expr_stmt|;
name|cov
index|[
literal|2
index|]
operator|=
literal|"-q"
expr_stmt|;
if|#
directive|if
operator|!
name|DIFF_L
name|cov
index|[
literal|3
index|]
operator|=
literal|"-M"
expr_stmt|;
endif|#
directive|endif
comment|/* Now handle all pathnames.  */
if|if
condition|(
name|nerror
condition|)
name|cleanup
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|faterror
argument_list|(
literal|"no input file%s"
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
literal|0
operator|<
name|argc
condition|;
name|cleanup
argument_list|()
operator|,
operator|++
name|argv
operator|,
operator|--
name|argc
control|)
block|{
name|ffree
argument_list|()
expr_stmt|;
if|if
condition|(
name|pairnames
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|rcsreadopen
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
name|diagnose
argument_list|(
literal|"===================================================================\nRCS file: %s\n"
argument_list|,
name|RCSname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rev2
condition|)
block|{
comment|/* Make sure work file is readable, and get its status.  */
if|if
condition|(
operator|!
operator|(
name|workptr
operator|=
name|Iopen
argument_list|(
name|workname
argument_list|,
name|FOPEN_R_WORK
argument_list|,
operator|&
name|workstat
argument_list|)
operator|)
condition|)
block|{
name|eerror
argument_list|(
name|workname
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|gettree
argument_list|()
expr_stmt|;
comment|/* reads in the delta tree */
if|if
condition|(
operator|!
name|Head
condition|)
block|{
name|rcserror
argument_list|(
literal|"no revisions present"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|revnums
operator|==
literal|0
operator|||
operator|!
operator|*
name|rev1
condition|)
name|rev1
operator|=
name|Dbranch
condition|?
name|Dbranch
else|:
name|Head
operator|->
name|num
expr_stmt|;
if|if
condition|(
operator|!
name|fexpandsym
argument_list|(
name|rev1
argument_list|,
operator|&
name|numericrev
argument_list|,
name|workptr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|target
operator|=
name|genrevs
argument_list|(
name|numericrev
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|gendeltas
argument_list|)
operator|)
condition|)
continue|continue;
name|xrev1
operator|=
name|target
operator|->
name|num
expr_stmt|;
if|#
directive|if
name|DIFF_L
if|if
condition|(
name|diff_label1
condition|)
operator|*
name|diff_label1
operator|=
name|setup_label
argument_list|(
operator|&
name|labelbuf
index|[
literal|0
index|]
argument_list|,
name|target
operator|->
name|num
argument_list|,
name|target
operator|->
name|date
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lexpandarg
operator|=
name|expandarg
expr_stmt|;
if|if
condition|(
name|revnums
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|fexpandsym
argument_list|(
operator|*
name|rev2
condition|?
name|rev2
else|:
name|Dbranch
condition|?
name|Dbranch
else|:
name|Head
operator|->
name|num
argument_list|,
operator|&
name|numericrev
argument_list|,
name|workptr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|target
operator|=
name|genrevs
argument_list|(
name|numericrev
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|gendeltas
argument_list|)
operator|)
condition|)
continue|continue;
name|xrev2
operator|=
name|target
operator|->
name|num
expr_stmt|;
if|if
condition|(
name|no_diff_means_no_output
operator|&&
name|xrev1
operator|==
name|xrev2
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|target
operator|->
name|lockedby
operator|&&
operator|!
name|lexpandarg
operator|&&
name|Expand
operator|==
name|KEYVAL_EXPAND
operator|&&
name|WORKMODE
argument_list|(
name|RCSstat
operator|.
name|st_mode
argument_list|,
name|true
argument_list|)
operator|==
name|workstat
operator|.
name|st_mode
condition|)
name|lexpandarg
operator|=
literal|"-kkvl"
expr_stmt|;
name|Izclose
argument_list|(
operator|&
name|workptr
argument_list|)
expr_stmt|;
if|#
directive|if
name|DIFF_L
if|if
condition|(
name|diff_label2
condition|)
if|if
condition|(
name|revnums
operator|==
literal|2
condition|)
operator|*
name|diff_label2
operator|=
name|setup_label
argument_list|(
operator|&
name|labelbuf
index|[
literal|1
index|]
argument_list|,
name|target
operator|->
name|num
argument_list|,
name|target
operator|->
name|date
argument_list|)
expr_stmt|;
else|else
block|{
name|time2date
argument_list|(
name|workstat
operator|.
name|st_mtime
argument_list|,
name|date2
argument_list|)
expr_stmt|;
operator|*
name|diff_label2
operator|=
name|setup_label
argument_list|(
operator|&
name|labelbuf
index|[
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|date2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|diagnose
argument_list|(
literal|"retrieving revision %s\n"
argument_list|,
name|xrev1
argument_list|)
expr_stmt|;
name|bufscpy
argument_list|(
operator|&
name|commarg
argument_list|,
literal|"-p"
argument_list|)
expr_stmt|;
name|bufscat
argument_list|(
operator|&
name|commarg
argument_list|,
name|rev1
argument_list|)
expr_stmt|;
comment|/* not xrev1, for $Name's sake */
name|pp
operator|=
operator|&
name|cov
index|[
literal|3
operator|+
operator|!
name|DIFF_L
index|]
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
name|commarg
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|lexpandarg
condition|)
operator|*
name|pp
operator|++
operator|=
name|lexpandarg
expr_stmt|;
if|if
condition|(
name|suffixarg
condition|)
operator|*
name|pp
operator|++
operator|=
name|suffixarg
expr_stmt|;
if|if
condition|(
name|versionarg
condition|)
operator|*
name|pp
operator|++
operator|=
name|versionarg
expr_stmt|;
if|if
condition|(
name|zonearg
condition|)
operator|*
name|pp
operator|++
operator|=
name|zonearg
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
name|RCSname
expr_stmt|;
operator|*
name|pp
operator|=
literal|0
expr_stmt|;
name|diffp
operator|=
name|diffpend
expr_stmt|;
if|#
directive|if
name|OPEN_O_BINARY
if|if
condition|(
name|Expand
operator|==
name|BINARY_EXPAND
condition|)
operator|*
name|diffp
operator|++
operator|=
literal|"--binary"
expr_stmt|;
endif|#
directive|endif
name|diffp
index|[
literal|0
index|]
operator|=
name|maketemp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|runv
argument_list|(
operator|-
literal|1
argument_list|,
name|diffp
index|[
literal|0
index|]
argument_list|,
name|cov
argument_list|)
condition|)
block|{
name|rcserror
argument_list|(
literal|"co failed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|rev2
condition|)
block|{
name|diffp
index|[
literal|1
index|]
operator|=
name|workname
expr_stmt|;
if|if
condition|(
operator|*
name|workname
operator|==
literal|'-'
condition|)
block|{
name|char
modifier|*
name|dp
init|=
name|ftnalloc
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|workname
argument_list|)
operator|+
literal|3
argument_list|)
decl_stmt|;
name|diffp
index|[
literal|1
index|]
operator|=
name|dp
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
name|SLASH
expr_stmt|;
name|VOID
name|strcpy
parameter_list|(
name|dp
parameter_list|,
name|workname
parameter_list|)
function_decl|;
block|}
block|}
else|else
block|{
name|diagnose
argument_list|(
literal|"retrieving revision %s\n"
argument_list|,
name|xrev2
argument_list|)
expr_stmt|;
name|bufscpy
argument_list|(
operator|&
name|commarg
argument_list|,
literal|"-p"
argument_list|)
expr_stmt|;
name|bufscat
argument_list|(
operator|&
name|commarg
argument_list|,
name|rev2
argument_list|)
expr_stmt|;
comment|/* not xrev2, for $Name's sake */
name|cov
index|[
literal|3
operator|+
operator|!
name|DIFF_L
index|]
operator|=
name|commarg
operator|.
name|string
expr_stmt|;
name|diffp
index|[
literal|1
index|]
operator|=
name|maketemp
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|runv
argument_list|(
operator|-
literal|1
argument_list|,
name|diffp
index|[
literal|1
index|]
argument_list|,
name|cov
argument_list|)
condition|)
block|{
name|rcserror
argument_list|(
literal|"co failed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|!
name|rev2
condition|)
name|diagnose
argument_list|(
literal|"diff%s -r%s %s\n"
argument_list|,
name|diffvstr
argument_list|,
name|xrev1
argument_list|,
name|workname
argument_list|)
expr_stmt|;
else|else
name|diagnose
argument_list|(
literal|"diff%s -r%s -r%s\n"
argument_list|,
name|diffvstr
argument_list|,
name|xrev1
argument_list|,
name|xrev2
argument_list|)
expr_stmt|;
name|diffp
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|runv
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|diffv
argument_list|)
condition|)
block|{
case|case
name|DIFF_SUCCESS
case|:
break|break;
case|case
name|DIFF_FAILURE
case|:
if|if
condition|(
name|exitstatus
operator|==
name|DIFF_SUCCESS
condition|)
name|exitstatus
operator|=
name|DIFF_FAILURE
expr_stmt|;
break|break;
default|default:
name|workerror
argument_list|(
literal|"diff failed"
argument_list|)
expr_stmt|;
block|}
block|}
name|tempunlink
argument_list|()
expr_stmt|;
name|exitmain
argument_list|(
name|exitstatus
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|cleanup
parameter_list|()
block|{
if|if
condition|(
name|nerror
condition|)
name|exitstatus
operator|=
name|DIFF_TROUBLE
expr_stmt|;
name|Izclose
argument_list|(
operator|&
name|finptr
argument_list|)
expr_stmt|;
name|Izclose
argument_list|(
operator|&
name|workptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|RCS_lint
end_if

begin_define
define|#
directive|define
name|exiterr
value|rdiffExit
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|exiterr
parameter_list|()
block|{
name|tempunlink
argument_list|()
expr_stmt|;
name|_exit
argument_list|(
name|DIFF_TROUBLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|DIFF_L
end_if

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|setup_label
parameter_list|(
name|b
parameter_list|,
name|num
parameter_list|,
name|date
parameter_list|)
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
name|char
specifier|const
modifier|*
name|num
decl_stmt|;
name|char
specifier|const
name|date
index|[
name|datesize
index|]
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|datestr
index|[
name|datesize
operator|+
name|zonelenmax
index|]
decl_stmt|;
name|VOID
name|date2str
argument_list|(
name|date
argument_list|,
name|datestr
argument_list|)
decl_stmt|;
name|bufalloc
argument_list|(
name|b
argument_list|,
name|strlen
argument_list|(
name|workname
argument_list|)
operator|+
sizeof|sizeof
name|datestr
operator|+
literal|4
operator|+
operator|(
name|num
condition|?
name|strlen
argument_list|(
name|num
argument_list|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|b
operator|->
name|string
expr_stmt|;
if|if
condition|(
name|num
condition|)
name|VOID
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"-L%s\t%s\t%s"
argument_list|,
name|workname
argument_list|,
name|datestr
argument_list|,
name|num
argument_list|)
decl_stmt|;
else|else
name|VOID
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"-L%s\t%s"
argument_list|,
name|workname
argument_list|,
name|datestr
argument_list|)
decl_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

