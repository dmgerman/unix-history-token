begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *                     RCS rcsdiff operation  */
end_comment

begin_comment
comment|/*****************************************************************************  *                       generate difference between RCS revisions  *****************************************************************************  */
end_comment

begin_comment
comment|/* Copyright (C) 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991 by Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/* $Log: rcsdiff.c,v $  * Revision 1.1.1.1  1993/06/18  04:22:16  jkh  * Updated GNU utilities  *  * Revision 5.10  1991/10/07  17:32:46  eggert  * Remove lint.  *  * Revision 5.9  1991/08/19  03:13:55  eggert  * Add RCSINIT, -r$.  Tune.  *  * Revision 5.8  1991/04/21  11:58:21  eggert  * Add -x, RCSINIT, MS-DOS support.  *  * Revision 5.7  1990/12/13  06:54:07  eggert  * GNU diff 1.15 has -u.  *  * Revision 5.6  1990/11/01  05:03:39  eggert  * Remove unneeded setid check.  *  * Revision 5.5  1990/10/04  06:30:19  eggert  * Accumulate exit status across files.  *  * Revision 5.4  1990/09/27  01:31:43  eggert  * Yield 1, not EXIT_FAILURE, when diffs are found.  *  * Revision 5.3  1990/09/11  02:41:11  eggert  * Simplify -kkvl test.  *  * Revision 5.2  1990/09/04  17:07:19  eggert  * Diff's argv was too small by 1.  *  * Revision 5.1  1990/08/29  07:13:55  eggert  * Add -kkvl.  *  * Revision 5.0  1990/08/22  08:12:46  eggert  * Add -k, -V.  Don't use access().  Add setuid support.  * Remove compile-time limits; use malloc instead.  * Don't pass arguments with leading '+' to diff; GNU DIFF treats them as options.  * Add GNU diff's flags.  Make lock and temp files faster and safer.  * Ansify and Posixate.  *  * Revision 4.6  89/05/01  15:12:27  narten  * changed copyright header to reflect current distribution rules  *  * Revision 4.5  88/08/09  19:12:41  eggert  * Use execv(), not system(); yield exit status like diff(1)s; allow cc -R.  *  * Revision 4.4  87/12/18  11:37:46  narten  * changes Jay Lepreau made in the 4.3 BSD version, to add support for  * "-i", "-w", and "-t" flags and to permit flags to be bundled together,  * merged in.  *  * Revision 4.3  87/10/18  10:31:42  narten  * Updating version numbers. Changes relative to 1.1 actually  * relative to 4.1  *  * Revision 1.3  87/09/24  13:59:21  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf  * warnings)  *  * Revision 1.2  87/03/27  14:22:15  jenkins  * Port to suns  *  * Revision 4.1  83/05/03  22:13:19  wft  * Added default branch, option -q, exit status like diff.  * Added fterror() to replace faterror().  *  * Revision 3.6  83/01/15  17:52:40  wft  * Expanded mainprogram to handle multiple RCS files.  *  * Revision 3.5  83/01/06  09:33:45  wft  * Fixed passing of -c (context) option to diff.  *  * Revision 3.4  82/12/24  15:28:38  wft  * Added call to catchsig().  *  * Revision 3.3  82/12/10  16:08:17  wft  * Corrected checking of return code from diff; improved error msgs.  *  * Revision 3.2  82/12/04  13:20:09  wft  * replaced getdelta() with gettree(). Changed diagnostics.  *  * Revision 3.1  82/11/28  19:25:04  wft  * Initial revision.  *  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_if
if|#
directive|if
name|DIFF_L
end_if

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|setup_label
name|P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|,
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
index|[
name|datesize
index|]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|cleanup
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|exitstatus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|RILE
modifier|*
name|workptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|stat
name|workstat
decl_stmt|;
end_decl_stmt

begin_macro
name|mainProg
argument_list|(
argument|rcsdiffId
argument_list|,
literal|"rcsdiff"
argument_list|,
literal|"$Id: rcsdiff.c,v 1.1.1.1 1993/06/18 04:22:16 jkh Exp $"
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|char
specifier|const
name|cmdusage
index|[]
init|=
literal|"\nrcsdiff usage: rcsdiff [-q] [-rrev1 [-rrev2]] [-Vn] [diff options] file ..."
decl_stmt|;
name|int
name|revnums
decl_stmt|;
comment|/* counter for revision numbers given */
name|char
specifier|const
modifier|*
name|rev1
decl_stmt|,
modifier|*
name|rev2
decl_stmt|;
comment|/* revision numbers from command line */
name|char
specifier|const
modifier|*
name|xrev1
decl_stmt|,
modifier|*
name|xrev2
decl_stmt|;
comment|/* expanded revision numbers */
name|char
specifier|const
modifier|*
name|expandarg
decl_stmt|,
modifier|*
name|lexpandarg
decl_stmt|,
modifier|*
name|versionarg
decl_stmt|;
if|#
directive|if
name|DIFF_L
specifier|static
name|struct
name|buf
name|labelbuf
index|[
literal|2
index|]
decl_stmt|;
name|int
name|file_labels
decl_stmt|;
name|char
specifier|const
modifier|*
modifier|*
name|diff_label1
decl_stmt|,
modifier|*
modifier|*
name|diff_label2
decl_stmt|;
name|char
name|date2
index|[
name|datesize
index|]
decl_stmt|;
endif|#
directive|endif
name|char
specifier|const
modifier|*
name|cov
index|[
literal|9
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
modifier|*
name|diffv
decl_stmt|,
modifier|*
modifier|*
name|diffp
decl_stmt|;
comment|/* argv for subsidiary diff */
name|char
specifier|const
modifier|*
modifier|*
name|pp
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|diffvstr
decl_stmt|;
name|struct
name|buf
name|commarg
decl_stmt|;
name|struct
name|buf
name|numericrev
decl_stmt|;
comment|/* expanded revision number */
name|struct
name|hshentries
modifier|*
name|gendeltas
decl_stmt|;
comment|/* deltas to be generated */
name|struct
name|hshentry
modifier|*
name|target
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|dcp
decl_stmt|,
modifier|*
modifier|*
name|newargv
decl_stmt|;
specifier|register
name|c
expr_stmt|;
name|exitstatus
operator|=
name|DIFF_SUCCESS
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|commarg
argument_list|)
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|numericrev
argument_list|)
expr_stmt|;
name|revnums
operator|=
literal|0
expr_stmt|;
name|rev1
operator|=
name|rev2
operator|=
name|xrev2
operator|=
name|nil
expr_stmt|;
if|#
directive|if
name|DIFF_L
name|file_labels
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|expandarg
operator|=
name|versionarg
operator|=
literal|0
expr_stmt|;
name|suffixes
operator|=
name|X_DEFAULT
expr_stmt|;
comment|/* Room for args + 2 i/o [+ 2 labels] + 1 file + 1 trailing null.  */
name|diffp
operator|=
name|diffv
operator|=
name|tnalloc
argument_list|(
name|char
specifier|const
operator|*
argument_list|,
name|argc
operator|+
literal|4
operator|+
literal|2
operator|*
name|DIFF_L
argument_list|)
expr_stmt|;
operator|*
name|diffp
operator|++
operator|=
name|nil
expr_stmt|;
operator|*
name|diffp
operator|++
operator|=
name|nil
expr_stmt|;
operator|*
name|diffp
operator|++
operator|=
name|DIFF
expr_stmt|;
name|argc
operator|=
name|getRCSINIT
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|newargv
argument_list|)
expr_stmt|;
name|argv
operator|=
name|newargv
expr_stmt|;
while|while
condition|(
name|a
operator|=
operator|*
operator|++
name|argv
operator|,
literal|0
operator|<
operator|--
name|argc
operator|&&
operator|*
name|a
operator|++
operator|==
literal|'-'
condition|)
block|{
name|dcp
operator|=
name|a
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|a
operator|++
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'r'
case|:
switch|switch
condition|(
operator|++
name|revnums
condition|)
block|{
case|case
literal|1
case|:
name|rev1
operator|=
name|a
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|rev2
operator|=
name|a
expr_stmt|;
break|break;
default|default:
name|faterror
argument_list|(
literal|"too many revision numbers"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|option_handled
goto|;
if|#
directive|if
name|DIFF_L
case|case
literal|'L'
case|:
if|if
condition|(
operator|++
name|file_labels
operator|==
literal|2
condition|)
name|faterror
argument_list|(
literal|"too many -L options"
argument_list|)
expr_stmt|;
comment|/* fall into */
endif|#
directive|endif
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'F'
case|:
case|case
literal|'I'
case|:
operator|*
name|dcp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|*
name|a
condition|)
do|do
operator|*
name|dcp
operator|++
operator|=
operator|*
name|a
operator|++
expr_stmt|;
do|while
condition|(
operator|*
name|a
condition|)
do|;
else|else
block|{
if|if
condition|(
operator|!
operator|--
name|argc
condition|)
name|faterror
argument_list|(
literal|"-%c needs following argument%s"
argument_list|,
name|c
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
operator|*
name|diffp
operator|++
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'B'
case|:
case|case
literal|'H'
case|:
case|case
literal|'T'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'n'
case|:
case|case
literal|'p'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'w'
case|:
operator|*
name|dcp
operator|++
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quietflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|suffixes
operator|=
operator|*
name|argv
operator|+
literal|2
expr_stmt|;
goto|goto
name|option_handled
goto|;
case|case
literal|'V'
case|:
name|versionarg
operator|=
operator|*
name|argv
expr_stmt|;
name|setRCSversion
argument_list|(
name|versionarg
argument_list|)
expr_stmt|;
goto|goto
name|option_handled
goto|;
case|case
literal|'k'
case|:
name|expandarg
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|str2expmode
argument_list|(
name|expandarg
operator|+
literal|2
argument_list|)
condition|)
goto|goto
name|option_handled
goto|;
comment|/* fall into */
default|default:
name|faterror
argument_list|(
literal|"unknown option: %s%s"
argument_list|,
operator|*
name|argv
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|option_handled
label|:
if|if
condition|(
name|dcp
operator|!=
operator|*
name|argv
operator|+
literal|1
condition|)
block|{
operator|*
name|dcp
operator|=
literal|0
expr_stmt|;
operator|*
name|diffp
operator|++
operator|=
operator|*
name|argv
expr_stmt|;
block|}
block|}
comment|/* end of option processing */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|faterror
argument_list|(
literal|"no input file%s"
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|diffv
operator|+
literal|3
operator|,
name|c
operator|=
literal|0
init|;
name|pp
operator|<
name|diffp
condition|;
control|)
name|c
operator|+=
name|strlen
argument_list|(
operator|*
name|pp
operator|++
argument_list|)
operator|+
literal|1
expr_stmt|;
name|diffvstr
operator|=
name|a
operator|=
name|tnalloc
argument_list|(
name|char
argument_list|,
name|c
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|diffv
operator|+
literal|3
init|;
name|pp
operator|<
name|diffp
condition|;
control|)
block|{
name|p
operator|=
operator|*
name|pp
operator|++
expr_stmt|;
operator|*
name|a
operator|++
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|a
operator|=
operator|*
name|p
operator|++
operator|)
condition|)
name|a
operator|++
expr_stmt|;
block|}
operator|*
name|a
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|DIFF_L
name|diff_label1
operator|=
name|diff_label2
operator|=
name|nil
expr_stmt|;
if|if
condition|(
name|file_labels
operator|<
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|file_labels
condition|)
name|diff_label1
operator|=
name|diffp
operator|++
expr_stmt|;
name|diff_label2
operator|=
name|diffp
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
name|diffp
index|[
literal|2
index|]
operator|=
name|nil
expr_stmt|;
name|cov
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|cov
index|[
literal|2
index|]
operator|=
name|CO
expr_stmt|;
name|cov
index|[
literal|3
index|]
operator|=
literal|"-q"
expr_stmt|;
comment|/* now handle all filenames */
do|do
block|{
name|ffree
argument_list|()
expr_stmt|;
if|if
condition|(
name|pairfilenames
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|rcsreadopen
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
name|diagnose
argument_list|(
literal|"===================================================================\nRCS file: %s\n"
argument_list|,
name|RCSfilename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rev2
condition|)
block|{
comment|/* Make sure work file is readable, and get its status.  */
if|if
condition|(
operator|!
operator|(
name|workptr
operator|=
name|Iopen
argument_list|(
name|workfilename
argument_list|,
name|FOPEN_R_WORK
argument_list|,
operator|&
name|workstat
argument_list|)
operator|)
condition|)
block|{
name|eerror
argument_list|(
name|workfilename
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|gettree
argument_list|()
expr_stmt|;
comment|/* reads in the delta tree */
if|if
condition|(
name|Head
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"no revisions present"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|revnums
operator|==
literal|0
operator|||
operator|!
operator|*
name|rev1
condition|)
name|rev1
operator|=
name|Dbranch
condition|?
name|Dbranch
else|:
name|Head
operator|->
name|num
expr_stmt|;
if|if
condition|(
operator|!
name|fexpandsym
argument_list|(
name|rev1
argument_list|,
operator|&
name|numericrev
argument_list|,
name|workptr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|target
operator|=
name|genrevs
argument_list|(
name|numericrev
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|&
name|gendeltas
argument_list|)
operator|)
condition|)
continue|continue;
name|xrev1
operator|=
name|target
operator|->
name|num
expr_stmt|;
if|#
directive|if
name|DIFF_L
if|if
condition|(
name|diff_label1
condition|)
operator|*
name|diff_label1
operator|=
name|setup_label
argument_list|(
operator|&
name|labelbuf
index|[
literal|0
index|]
argument_list|,
name|target
operator|->
name|num
argument_list|,
name|target
operator|->
name|date
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lexpandarg
operator|=
name|expandarg
expr_stmt|;
if|if
condition|(
name|revnums
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|fexpandsym
argument_list|(
operator|*
name|rev2
condition|?
name|rev2
else|:
name|Dbranch
condition|?
name|Dbranch
else|:
name|Head
operator|->
name|num
argument_list|,
operator|&
name|numericrev
argument_list|,
name|workptr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|target
operator|=
name|genrevs
argument_list|(
name|numericrev
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nil
argument_list|,
operator|&
name|gendeltas
argument_list|)
operator|)
condition|)
continue|continue;
name|xrev2
operator|=
name|target
operator|->
name|num
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target
operator|->
name|lockedby
operator|&&
operator|!
name|lexpandarg
operator|&&
name|Expand
operator|==
name|KEYVAL_EXPAND
operator|&&
name|WORKMODE
argument_list|(
name|RCSstat
operator|.
name|st_mode
argument_list|,
name|true
argument_list|)
operator|==
name|workstat
operator|.
name|st_mode
condition|)
name|lexpandarg
operator|=
literal|"-kkvl"
expr_stmt|;
name|Izclose
argument_list|(
operator|&
name|workptr
argument_list|)
expr_stmt|;
if|#
directive|if
name|DIFF_L
if|if
condition|(
name|diff_label2
condition|)
if|if
condition|(
name|revnums
operator|==
literal|2
condition|)
operator|*
name|diff_label2
operator|=
name|setup_label
argument_list|(
operator|&
name|labelbuf
index|[
literal|1
index|]
argument_list|,
name|target
operator|->
name|num
argument_list|,
name|target
operator|->
name|date
argument_list|)
expr_stmt|;
else|else
block|{
name|time2date
argument_list|(
name|workstat
operator|.
name|st_mtime
argument_list|,
name|date2
argument_list|)
expr_stmt|;
operator|*
name|diff_label2
operator|=
name|setup_label
argument_list|(
operator|&
name|labelbuf
index|[
literal|1
index|]
argument_list|,
name|workfilename
argument_list|,
name|date2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|diagnose
argument_list|(
literal|"retrieving revision %s\n"
argument_list|,
name|xrev1
argument_list|)
expr_stmt|;
name|bufscpy
argument_list|(
operator|&
name|commarg
argument_list|,
literal|"-p"
argument_list|)
expr_stmt|;
name|bufscat
argument_list|(
operator|&
name|commarg
argument_list|,
name|xrev1
argument_list|)
expr_stmt|;
name|cov
index|[
literal|1
index|]
operator|=
name|diffp
index|[
literal|0
index|]
operator|=
name|maketemp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pp
operator|=
operator|&
name|cov
index|[
literal|4
index|]
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
name|commarg
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|lexpandarg
condition|)
operator|*
name|pp
operator|++
operator|=
name|lexpandarg
expr_stmt|;
if|if
condition|(
name|versionarg
condition|)
operator|*
name|pp
operator|++
operator|=
name|versionarg
expr_stmt|;
operator|*
name|pp
operator|++
operator|=
name|RCSfilename
expr_stmt|;
operator|*
name|pp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|runv
argument_list|(
name|cov
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"co failed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|rev2
condition|)
block|{
name|diffp
index|[
literal|1
index|]
operator|=
name|workfilename
expr_stmt|;
if|if
condition|(
name|workfilename
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
comment|/* Some diffs have options with leading '+'.  */
name|char
modifier|*
name|dp
init|=
name|ftnalloc
argument_list|(
name|char
argument_list|,
name|strlen
argument_list|(
name|workfilename
argument_list|)
operator|+
literal|3
argument_list|)
decl_stmt|;
name|diffp
index|[
literal|1
index|]
operator|=
name|dp
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
name|SLASH
expr_stmt|;
name|VOID
name|strcpy
parameter_list|(
name|dp
parameter_list|,
name|workfilename
parameter_list|)
function_decl|;
block|}
block|}
else|else
block|{
name|diagnose
argument_list|(
literal|"retrieving revision %s\n"
argument_list|,
name|xrev2
argument_list|)
expr_stmt|;
name|bufscpy
argument_list|(
operator|&
name|commarg
argument_list|,
literal|"-p"
argument_list|)
expr_stmt|;
name|bufscat
argument_list|(
operator|&
name|commarg
argument_list|,
name|xrev2
argument_list|)
expr_stmt|;
name|cov
index|[
literal|1
index|]
operator|=
name|diffp
index|[
literal|1
index|]
operator|=
name|maketemp
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cov
index|[
literal|4
index|]
operator|=
name|commarg
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|runv
argument_list|(
name|cov
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"co failed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|!
name|rev2
condition|)
name|diagnose
argument_list|(
literal|"diff%s -r%s %s\n"
argument_list|,
name|diffvstr
argument_list|,
name|xrev1
argument_list|,
name|workfilename
argument_list|)
expr_stmt|;
else|else
name|diagnose
argument_list|(
literal|"diff%s -r%s -r%s\n"
argument_list|,
name|diffvstr
argument_list|,
name|xrev1
argument_list|,
name|xrev2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|runv
argument_list|(
name|diffv
argument_list|)
condition|)
block|{
case|case
name|DIFF_SUCCESS
case|:
break|break;
case|case
name|DIFF_FAILURE
case|:
if|if
condition|(
name|exitstatus
operator|==
name|DIFF_SUCCESS
condition|)
name|exitstatus
operator|=
name|DIFF_FAILURE
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"diff failed"
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|cleanup
argument_list|()
operator|,
operator|++
name|argv
operator|,
operator|--
name|argc
operator|>=
literal|1
condition|)
do|;
name|tempunlink
argument_list|()
expr_stmt|;
name|exitmain
argument_list|(
name|exitstatus
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|cleanup
parameter_list|()
block|{
if|if
condition|(
name|nerror
condition|)
name|exitstatus
operator|=
name|DIFF_TROUBLE
expr_stmt|;
name|Izclose
argument_list|(
operator|&
name|finptr
argument_list|)
expr_stmt|;
name|Izclose
argument_list|(
operator|&
name|workptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|lint
end_if

begin_define
define|#
directive|define
name|exiterr
value|rdiffExit
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|exiting
name|void
name|exiterr
parameter_list|()
block|{
name|tempunlink
argument_list|()
expr_stmt|;
name|_exit
argument_list|(
name|DIFF_TROUBLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|DIFF_L
end_if

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|setup_label
parameter_list|(
name|b
parameter_list|,
name|name
parameter_list|,
name|date
parameter_list|)
name|struct
name|buf
modifier|*
name|b
decl_stmt|;
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
name|char
specifier|const
name|date
index|[
name|datesize
index|]
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|l
init|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|3
decl_stmt|;
name|bufalloc
argument_list|(
name|b
argument_list|,
name|l
operator|+
name|datesize
argument_list|)
expr_stmt|;
name|p
operator|=
name|b
operator|->
name|string
expr_stmt|;
name|VOID
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"-L%s\t"
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|VOID
name|date2str
argument_list|(
name|date
argument_list|,
name|p
operator|+
name|l
argument_list|)
decl_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

