begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Check out working files from revisions of RCS files.  */
end_comment

begin_comment
comment|/* Copyright 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991, 1992, 1993, 1994, 1995 Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/*  * Revision 5.18  1995/06/16 06:19:24  eggert  * Update FSF address.  *  * Revision 5.17  1995/06/01 16:23:43  eggert  * (main, preparejoin): Pass argument instead of using `join' static variable.  * (main): Add -kb.  *  * Revision 5.16  1994/03/17 14:05:48  eggert  * Move buffer-flushes out of critical sections, since they aren't critical.  * Use ORCSerror to clean up after a fatal error.  Remove lint.  * Specify subprocess input via file descriptor, not file name.  *  * Revision 5.15  1993/11/09 17:40:15  eggert  * -V now prints version on stdout and exits.  Don't print usage twice.  *  * Revision 5.14  1993/11/03 17:42:27  eggert  * Add -z.  Generate a value for the Name keyword.  * Don't arbitrarily limit the number of joins.  * Improve quality of diagnostics.  *  * Revision 5.13  1992/07/28  16:12:44  eggert  * Add -V.  Check that working and RCS files are distinct.  *  * Revision 5.12  1992/02/17  23:02:08  eggert  * Add -T.  *  * Revision 5.11  1992/01/24  18:44:19  eggert  * Add support for bad_creat0.  lint -> RCS_lint  *  * Revision 5.10  1992/01/06  02:42:34  eggert  * Update usage string.  *  * Revision 5.9  1991/10/07  17:32:46  eggert  * -k affects just working file, not RCS file.  *  * Revision 5.8  1991/08/19  03:13:55  eggert  * Warn before removing somebody else's file.  * Add -M.  Fix co -j bugs.  Tune.  *  * Revision 5.7  1991/04/21  11:58:15  eggert  * Ensure that working file is newer than RCS file after co -[lu].  * Add -x, RCSINIT, MS-DOS support.  *  * Revision 5.6  1990/12/04  05:18:38  eggert  * Don't checkaccesslist() unless necessary.  * Use -I for prompts and -q for diagnostics.  *  * Revision 5.5  1990/11/01  05:03:26  eggert  * Fix -j.  Add -I.  *  * Revision 5.4  1990/10/04  06:30:11  eggert  * Accumulate exit status across files.  *  * Revision 5.3  1990/09/11  02:41:09  eggert  * co -kv yields a readonly working file.  *  * Revision 5.2  1990/09/04  08:02:13  eggert  * Standardize yes-or-no procedure.  *  * Revision 5.0  1990/08/22  08:10:02  eggert  * Permit multiple locks by same user.  Add setuid support.  * Remove compile-time limits; use malloc instead.  * Permit dates past 1999/12/31.  Switch to GMT.  * Make lock and temp files faster and safer.  * Ansify and Posixate.  Add -k, -V.  Remove snooping.  Tune.  *  * Revision 4.7  89/05/01  15:11:41  narten  * changed copyright header to reflect current distribution rules  *  * Revision 4.6  88/08/09  19:12:15  eggert  * Fix "co -d" core dump; rawdate wasn't always initialized.  * Use execv(), not system(); fix putchar('\0') and diagnose() botches; remove lint  *  * Revision 4.5  87/12/18  11:35:40  narten  * lint cleanups (from Guy Harris)  *  * Revision 4.4  87/10/18  10:20:53  narten  * Updating version numbers changes relative to 1.1, are actually  * relative to 4.2  *  * Revision 1.3  87/09/24  13:58:30  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf  * warnings)  *  * Revision 1.2  87/03/27  14:21:38  jenkins  * Port to suns  *  * Revision 4.2  83/12/05  13:39:48  wft  * made rewriteflag external.  *  * Revision 4.1  83/05/10  16:52:55  wft  * Added option -u and -f.  * Added handling of default branch.  * Replaced getpwuid() with getcaller().  * Removed calls to stat(); now done by pairfilenames().  * Changed and renamed rmoldfile() to rmworkfile().  * Replaced catchints() calls with restoreints(), unlink()--link() with rename();  *  * Revision 3.7  83/02/15  15:27:07  wft  * Added call to fastcopy() to copy remainder of RCS file.  *  * Revision 3.6  83/01/15  14:37:50  wft  * Added ignoring of interrupts while RCS file is renamed; this avoids  * deletion of RCS files during the unlink/link window.  *  * Revision 3.5  82/12/08  21:40:11  wft  * changed processing of -d to use DATEFORM; removed actual from  * call to preparejoin; re-fixed printing of done at the end.  *  * Revision 3.4  82/12/04  18:40:00  wft  * Replaced getdelta() with gettree(), SNOOPDIR with SNOOPFILE.  * Fixed printing of "done".  *  * Revision 3.3  82/11/28  22:23:11  wft  * Replaced getlogin() with getpwuid(), flcose() with ffclose(),  * %02d with %.2d, mode generation for working file with WORKMODE.  * Fixed nil printing. Fixed -j combined with -l and -p, and exit  * for non-existing revisions in preparejoin().  *  * Revision 3.2  82/10/18  20:47:21  wft  * Mode of working file is now maintained even for co -l, but write permission  * is removed.  * The working file inherits its mode from the RCS file, plus write permission  * for the owner. The write permission is not given if locking is strict and  * co does not lock.  * An existing working file without write permission is deleted automatically.  * Otherwise, co asks (empty answer: abort co).  * Call to getfullRCSname() added, check for write error added, call  * for getlogin() fixed.  *  * Revision 3.1  82/10/13  16:01:30  wft  * fixed type of variables receiving from getc() (char -> int).  * removed unused variables.  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|addjoin
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|getancestor
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|buildjoin
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|preparejoin
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rmlock
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rmworkfile
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cleanup
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|quietarg
index|[]
init|=
literal|"-q"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|expandarg
decl_stmt|,
modifier|*
name|suffixarg
decl_stmt|,
modifier|*
name|versionarg
decl_stmt|,
modifier|*
name|zonearg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
modifier|*
name|joinlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* revisions to be joined */
end_comment

begin_decl_stmt
specifier|static
name|int
name|joinlength
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|neworkptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|exitstatus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|forceflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lastjoin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index of last element in joinlist  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lockflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -1 -> unlock, 0 -> do nothing, 1 -> lock */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mtimeflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hshentries
modifier|*
name|gendeltas
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* deltas to be generated	*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hshentry
modifier|*
name|targetdelta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* final delta to be generated	*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|stat
name|workstat
decl_stmt|;
end_decl_stmt

begin_macro
name|mainProg
argument_list|(
argument|coId
argument_list|,
literal|"co"
argument_list|,
literal|"$FreeBSD$"
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|char
specifier|const
name|cmdusage
index|[]
init|=
literal|"\nco usage: co -{fIlMpqru}[rev] -ddate -jjoins -ksubst -sstate -T -w[who] -Vn -xsuff -zzone file ..."
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|joinflag
decl_stmt|,
modifier|*
modifier|*
name|newargv
decl_stmt|;
name|char
specifier|const
modifier|*
name|author
decl_stmt|,
modifier|*
name|date
decl_stmt|,
modifier|*
name|rev
decl_stmt|,
modifier|*
name|state
decl_stmt|;
name|char
specifier|const
modifier|*
name|joinname
decl_stmt|,
modifier|*
name|newdate
decl_stmt|,
modifier|*
name|neworkname
decl_stmt|;
name|int
name|changelock
decl_stmt|;
comment|/* 1 if a lock has been changed, -1 if error */
name|int
name|expmode
decl_stmt|,
name|r
decl_stmt|,
name|tostdout
decl_stmt|,
name|workstatstat
decl_stmt|;
name|int
name|Ttimeflag
decl_stmt|;
name|struct
name|buf
name|numericrev
decl_stmt|;
comment|/* expanded revision number	*/
name|char
name|finaldate
index|[
name|datesize
index|]
decl_stmt|;
if|#
directive|if
name|OPEN_O_BINARY
name|int
name|stdout_mode
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|setrid
argument_list|()
expr_stmt|;
name|author
operator|=
name|date
operator|=
name|rev
operator|=
name|state
operator|=
literal|0
expr_stmt|;
name|joinflag
operator|=
literal|0
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|numericrev
argument_list|)
expr_stmt|;
name|expmode
operator|=
operator|-
literal|1
expr_stmt|;
name|suffixes
operator|=
name|X_DEFAULT
expr_stmt|;
name|tostdout
operator|=
name|false
expr_stmt|;
name|Ttimeflag
operator|=
name|false
expr_stmt|;
name|argc
operator|=
name|getRCSINIT
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|newargv
argument_list|)
expr_stmt|;
name|argv
operator|=
name|newargv
expr_stmt|;
while|while
condition|(
name|a
operator|=
operator|*
operator|++
name|argv
operator|,
literal|0
operator|<
operator|--
name|argc
operator|&&
operator|*
name|a
operator|++
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
operator|*
name|a
operator|++
condition|)
block|{
case|case
literal|'r'
case|:
name|revno
label|:
if|if
condition|(
operator|*
name|a
condition|)
block|{
if|if
condition|(
name|rev
condition|)
name|warn
argument_list|(
literal|"redefinition of revision number"
argument_list|)
expr_stmt|;
name|rev
operator|=
name|a
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
name|forceflag
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'l'
case|:
if|if
condition|(
name|lockflag
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"-u overridden by -l."
argument_list|)
expr_stmt|;
block|}
name|lockflag
operator|=
literal|1
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'u'
case|:
if|if
condition|(
literal|0
operator|<
name|lockflag
condition|)
block|{
name|warn
argument_list|(
literal|"-l overridden by -u."
argument_list|)
expr_stmt|;
block|}
name|lockflag
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'p'
case|:
name|tostdout
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'I'
case|:
name|interactiveflag
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'q'
case|:
name|quietflag
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'d'
case|:
if|if
condition|(
name|date
condition|)
name|redefined
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
name|str2date
argument_list|(
name|a
argument_list|,
name|finaldate
argument_list|)
expr_stmt|;
name|date
operator|=
name|finaldate
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
if|if
condition|(
operator|*
name|a
condition|)
block|{
if|if
condition|(
name|joinflag
condition|)
name|redefined
argument_list|(
literal|'j'
argument_list|)
expr_stmt|;
name|joinflag
operator|=
name|a
expr_stmt|;
block|}
break|break;
case|case
literal|'M'
case|:
name|mtimeflag
operator|=
name|true
expr_stmt|;
goto|goto
name|revno
goto|;
case|case
literal|'s'
case|:
if|if
condition|(
operator|*
name|a
condition|)
block|{
if|if
condition|(
name|state
condition|)
name|redefined
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
name|state
operator|=
name|a
expr_stmt|;
block|}
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
operator|*
name|a
condition|)
goto|goto
name|unknown
goto|;
name|Ttimeflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
name|author
condition|)
name|redefined
argument_list|(
literal|'w'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|a
condition|)
name|author
operator|=
name|a
expr_stmt|;
else|else
name|author
operator|=
name|getcaller
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|suffixarg
operator|=
operator|*
name|argv
expr_stmt|;
name|suffixes
operator|=
name|a
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|versionarg
operator|=
operator|*
name|argv
expr_stmt|;
name|setRCSversion
argument_list|(
name|versionarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|zonearg
operator|=
operator|*
name|argv
expr_stmt|;
name|zone_set
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/*  set keyword expand mode  */
name|expandarg
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|expmode
condition|)
name|redefined
argument_list|(
literal|'k'
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
operator|(
name|expmode
operator|=
name|str2expmode
argument_list|(
name|a
argument_list|)
operator|)
condition|)
break|break;
comment|/* fall into */
default|default:
name|unknown
label|:
name|error
argument_list|(
literal|"unknown option: %s%s"
argument_list|,
operator|*
name|argv
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
comment|/* end of option processing */
comment|/* Now handle all pathnames.  */
if|if
condition|(
name|nerror
condition|)
name|cleanup
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|faterror
argument_list|(
literal|"no input file%s"
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
literal|0
operator|<
name|argc
condition|;
name|cleanup
argument_list|()
operator|,
operator|++
name|argv
operator|,
operator|--
name|argc
control|)
block|{
name|ffree
argument_list|()
expr_stmt|;
if|if
condition|(
name|pairnames
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|lockflag
condition|?
name|rcswriteopen
else|:
name|rcsreadopen
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
operator|<=
literal|0
condition|)
continue|continue;
comment|/* 	 * RCSname contains the name of the RCS file, and finptr 	 * points at it.  workname contains the name of the working file. 	 * Also, RCSstat has been set.          */
name|diagnose
argument_list|(
literal|"%s  -->  %s\n"
argument_list|,
name|RCSname
argument_list|,
name|tostdout
condition|?
literal|"standard output"
else|:
name|workname
argument_list|)
expr_stmt|;
name|workstatstat
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|tostdout
condition|)
block|{
if|#
directive|if
name|OPEN_O_BINARY
name|int
name|newmode
init|=
name|Expand
operator|==
name|BINARY_EXPAND
condition|?
name|OPEN_O_BINARY
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|stdout_mode
operator|!=
name|newmode
condition|)
block|{
name|stdout_mode
operator|=
name|newmode
expr_stmt|;
name|oflush
argument_list|()
expr_stmt|;
name|VOID
name|setmode
parameter_list|(
name|STDOUT_FILENO
parameter_list|,
name|newmode
parameter_list|)
function_decl|;
block|}
endif|#
directive|endif
name|neworkname
operator|=
literal|0
expr_stmt|;
name|neworkptr
operator|=
name|workstdout
operator|=
name|stdout
expr_stmt|;
block|}
else|else
block|{
name|workstatstat
operator|=
name|stat
argument_list|(
name|workname
argument_list|,
operator|&
name|workstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|workstatstat
operator|==
literal|0
operator|&&
name|same_file
argument_list|(
name|RCSstat
argument_list|,
name|workstat
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|rcserror
argument_list|(
literal|"RCS file is the same as working file %s."
argument_list|,
name|workname
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|neworkname
operator|=
name|makedirtemp
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|neworkptr
operator|=
name|fopenSafer
argument_list|(
name|neworkname
argument_list|,
name|FOPEN_W_WORK
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EACCES
condition|)
name|workerror
argument_list|(
literal|"permission denied on parent directory"
argument_list|)
expr_stmt|;
else|else
name|eerror
argument_list|(
name|neworkname
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|gettree
argument_list|()
expr_stmt|;
comment|/* reads in the delta tree */
if|if
condition|(
operator|!
name|Head
condition|)
block|{
comment|/* no revisions; create empty file */
name|diagnose
argument_list|(
literal|"no revisions present; generating empty revision 0.0\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockflag
condition|)
name|warn
argument_list|(
literal|"no revisions, so nothing can be %slocked"
argument_list|,
name|lockflag
operator|<
literal|0
condition|?
literal|"un"
else|:
literal|""
argument_list|)
expr_stmt|;
name|Ozclose
argument_list|(
operator|&
name|fcopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|workstatstat
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|rmworkfile
argument_list|()
condition|)
continue|continue;
name|changelock
operator|=
literal|0
expr_stmt|;
name|newdate
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|locks
init|=
name|lockflag
condition|?
name|findlock
argument_list|(
name|false
argument_list|,
operator|&
name|targetdelta
argument_list|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|rev
condition|)
block|{
comment|/* expand symbolic revision number */
if|if
condition|(
operator|!
name|expandsym
argument_list|(
name|rev
argument_list|,
operator|&
name|numericrev
argument_list|)
condition|)
continue|continue;
block|}
else|else
block|{
switch|switch
condition|(
name|locks
condition|)
block|{
default|default:
continue|continue;
case|case
literal|0
case|:
name|bufscpy
argument_list|(
operator|&
name|numericrev
argument_list|,
name|Dbranch
condition|?
name|Dbranch
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|bufscpy
argument_list|(
operator|&
name|numericrev
argument_list|,
name|targetdelta
operator|->
name|num
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* get numbers of deltas to be generated */
if|if
condition|(
operator|!
operator|(
name|targetdelta
operator|=
name|genrevs
argument_list|(
name|numericrev
operator|.
name|string
argument_list|,
name|date
argument_list|,
name|author
argument_list|,
name|state
argument_list|,
operator|&
name|gendeltas
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* check reservations */
name|changelock
operator|=
name|lockflag
operator|<
literal|0
condition|?
name|rmlock
argument_list|(
name|targetdelta
argument_list|)
else|:
name|lockflag
operator|==
literal|0
condition|?
literal|0
else|:
name|addlock
argument_list|(
name|targetdelta
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|changelock
operator|<
literal|0
operator|||
operator|(
name|changelock
operator|&&
operator|!
name|checkaccesslist
argument_list|()
operator|)
operator|||
name|dorewrite
argument_list|(
name|lockflag
argument_list|,
name|changelock
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
literal|0
operator|<=
name|expmode
condition|)
name|Expand
operator|=
name|expmode
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|lockflag
operator|&&
name|Expand
operator|==
name|VAL_EXPAND
condition|)
block|{
name|rcserror
argument_list|(
literal|"cannot combine -kv and -l"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|joinflag
operator|&&
operator|!
name|preparejoin
argument_list|(
name|joinflag
argument_list|)
condition|)
continue|continue;
name|diagnose
argument_list|(
literal|"revision %s%s\n"
argument_list|,
name|targetdelta
operator|->
name|num
argument_list|,
literal|0
operator|<
name|lockflag
condition|?
literal|" (locked)"
else|:
name|lockflag
operator|<
literal|0
condition|?
literal|" (unlocked)"
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* Prepare to remove old working file if necessary.  */
if|if
condition|(
name|workstatstat
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|rmworkfile
argument_list|()
condition|)
continue|continue;
comment|/* skip description */
name|getdesc
argument_list|(
name|false
argument_list|)
expr_stmt|;
comment|/* don't echo*/
name|locker_expansion
operator|=
literal|0
operator|<
name|lockflag
expr_stmt|;
name|targetdelta
operator|->
name|name
operator|=
name|namedrev
argument_list|(
name|rev
argument_list|,
name|targetdelta
argument_list|)
expr_stmt|;
name|joinname
operator|=
name|buildrevision
argument_list|(
name|gendeltas
argument_list|,
name|targetdelta
argument_list|,
name|joinflag
operator|&&
name|tostdout
condition|?
operator|(
name|FILE
operator|*
operator|)
literal|0
else|:
name|neworkptr
argument_list|,
name|Expand
operator|<
name|MIN_UNEXPAND
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|large_memory
if|if
condition|(
name|fcopy
operator|==
name|neworkptr
condition|)
name|fcopy
operator|=
literal|0
expr_stmt|;
comment|/* Don't close it twice.  */
endif|#
directive|endif
name|if_advise_access
argument_list|(
name|changelock
operator|&&
name|gendeltas
operator|->
name|first
operator|!=
name|targetdelta
argument_list|,
name|finptr
argument_list|,
name|MADV_SEQUENTIAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|donerewrite
argument_list|(
name|changelock
argument_list|,
name|Ttimeflag
condition|?
name|RCSstat
operator|.
name|st_mtime
else|:
operator|(
name|time_t
operator|)
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|changelock
condition|)
block|{
name|locks
operator|+=
name|lockflag
expr_stmt|;
if|if
condition|(
literal|1
operator|<
name|locks
condition|)
name|rcswarn
argument_list|(
literal|"You now have %d locks."
argument_list|,
name|locks
argument_list|)
expr_stmt|;
block|}
name|newdate
operator|=
name|targetdelta
operator|->
name|date
expr_stmt|;
if|if
condition|(
name|joinflag
condition|)
block|{
name|newdate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|joinname
condition|)
block|{
name|aflush
argument_list|(
name|neworkptr
argument_list|)
expr_stmt|;
name|joinname
operator|=
name|neworkname
expr_stmt|;
block|}
if|if
condition|(
name|Expand
operator|==
name|BINARY_EXPAND
condition|)
name|workerror
argument_list|(
literal|"merging binary files"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buildjoin
argument_list|(
name|joinname
argument_list|)
condition|)
continue|continue;
block|}
block|}
if|if
condition|(
operator|!
name|tostdout
condition|)
block|{
name|mode_t
name|m
init|=
name|WORKMODE
argument_list|(
name|RCSstat
operator|.
name|st_mode
argument_list|,
operator|!
operator|(
name|Expand
operator|==
name|VAL_EXPAND
operator|||
operator|(
name|lockflag
operator|<=
literal|0
operator|&&
name|StrictLocks
operator|)
operator|)
argument_list|)
decl_stmt|;
name|time_t
name|t
init|=
name|mtimeflag
operator|&&
name|newdate
condition|?
name|date2time
argument_list|(
name|newdate
argument_list|)
else|:
operator|(
name|time_t
operator|)
operator|-
literal|1
decl_stmt|;
name|aflush
argument_list|(
name|neworkptr
argument_list|)
expr_stmt|;
name|ignoreints
argument_list|()
expr_stmt|;
name|r
operator|=
name|chnamemod
argument_list|(
operator|&
name|neworkptr
argument_list|,
name|neworkname
argument_list|,
name|workname
argument_list|,
literal|1
argument_list|,
name|m
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|keepdirtemp
argument_list|(
name|neworkname
argument_list|)
expr_stmt|;
name|restoreints
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|eerror
argument_list|(
name|workname
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"see %s"
argument_list|,
name|neworkname
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|diagnose
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|tempunlink
argument_list|()
expr_stmt|;
name|Ofclose
argument_list|(
name|workstdout
argument_list|)
expr_stmt|;
name|exitmain
argument_list|(
name|exitstatus
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end of main (co) */
end_comment

begin_function
specifier|static
name|void
name|cleanup
parameter_list|()
block|{
if|if
condition|(
name|nerror
condition|)
name|exitstatus
operator|=
name|EXIT_FAILURE
expr_stmt|;
name|Izclose
argument_list|(
operator|&
name|finptr
argument_list|)
expr_stmt|;
name|ORCSclose
argument_list|()
expr_stmt|;
if|#
directive|if
operator|!
name|large_memory
if|if
condition|(
name|fcopy
operator|!=
name|workstdout
condition|)
name|Ozclose
argument_list|(
operator|&
name|fcopy
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|neworkptr
operator|!=
name|workstdout
condition|)
name|Ozclose
argument_list|(
operator|&
name|neworkptr
argument_list|)
expr_stmt|;
name|dirtempunlink
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|RCS_lint
end_if

begin_define
define|#
directive|define
name|exiterr
value|coExit
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|exiterr
parameter_list|()
block|{
name|ORCSerror
argument_list|()
expr_stmt|;
name|dirtempunlink
argument_list|()
expr_stmt|;
name|tempunlink
argument_list|()
expr_stmt|;
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************  * The following routines are auxiliary routines  *****************************************************************/
end_comment

begin_function
specifier|static
name|int
name|rmworkfile
parameter_list|()
comment|/*  * Prepare to remove workname, if it exists, and if  * it is read-only.  * Otherwise (file writable):  *   if !quietmode asks the user whether to really delete it (default: fail);  *   otherwise failure.  * Returns true if permission is gotten.  */
block|{
if|if
condition|(
name|workstat
operator|.
name|st_mode
operator|&
operator|(
name|S_IWUSR
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
operator|&&
operator|!
name|forceflag
condition|)
block|{
comment|/* File is writable */
if|if
condition|(
operator|!
name|yesorno
argument_list|(
name|false
argument_list|,
literal|"writable %s exists%s; remove it? [ny](n): "
argument_list|,
name|workname
argument_list|,
name|myself
argument_list|(
name|workstat
operator|.
name|st_uid
argument_list|)
condition|?
literal|""
else|:
literal|", and you do not own it"
argument_list|)
condition|)
block|{
name|error
argument_list|(
operator|!
name|quietflag
operator|&&
name|ttystdin
argument_list|()
condition|?
literal|"checkout aborted"
else|:
literal|"writable %s exists; checkout aborted"
argument_list|,
name|workname
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
comment|/* Actual unlink is done later by caller. */
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rmlock
parameter_list|(
name|delta
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
comment|/* Function: removes the lock held by caller on delta.  * Returns -1 if someone else holds the lock,  * 0 if there is no lock on delta,  * and 1 if a lock was found and removed.  */
block|{
specifier|register
name|struct
name|rcslock
modifier|*
name|next
decl_stmt|,
modifier|*
name|trail
decl_stmt|;
name|char
specifier|const
modifier|*
name|num
decl_stmt|;
name|struct
name|rcslock
name|dummy
decl_stmt|;
name|int
name|whomatch
decl_stmt|,
name|nummatch
decl_stmt|;
name|num
operator|=
name|delta
operator|->
name|num
expr_stmt|;
name|dummy
operator|.
name|nextlock
operator|=
name|next
operator|=
name|Locks
expr_stmt|;
name|trail
operator|=
operator|&
name|dummy
expr_stmt|;
while|while
condition|(
name|next
condition|)
block|{
name|whomatch
operator|=
name|strcmp
argument_list|(
name|getcaller
argument_list|()
argument_list|,
name|next
operator|->
name|login
argument_list|)
expr_stmt|;
name|nummatch
operator|=
name|strcmp
argument_list|(
name|num
argument_list|,
name|next
operator|->
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|whomatch
operator|==
literal|0
operator|)
operator|&&
operator|(
name|nummatch
operator|==
literal|0
operator|)
condition|)
break|break;
comment|/*found a lock on delta by caller*/
if|if
condition|(
operator|(
name|whomatch
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|nummatch
operator|==
literal|0
operator|)
condition|)
block|{
name|rcserror
argument_list|(
literal|"revision %s locked by %s; use co -r or rcs -u"
argument_list|,
name|num
argument_list|,
name|next
operator|->
name|login
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|trail
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|nextlock
expr_stmt|;
block|}
if|if
condition|(
name|next
condition|)
block|{
comment|/*found one; delete it */
name|trail
operator|->
name|nextlock
operator|=
name|next
operator|->
name|nextlock
expr_stmt|;
name|Locks
operator|=
name|dummy
operator|.
name|nextlock
expr_stmt|;
name|next
operator|->
name|delta
operator|->
name|lockedby
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
comment|/*success*/
block|}
else|else
return|return
literal|0
return|;
comment|/*no lock on delta*/
block|}
end_function

begin_comment
comment|/*****************************************************************  * The rest of the routines are for handling joins  *****************************************************************/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|addjoin
parameter_list|(
name|joinrev
parameter_list|)
name|char
modifier|*
name|joinrev
decl_stmt|;
comment|/* Add joinrev's number to joinlist, yielding address of char past joinrev,  * or 0 if no such revision exists.  */
block|{
specifier|register
name|char
modifier|*
name|j
decl_stmt|;
specifier|register
name|struct
name|hshentry
modifier|*
name|d
decl_stmt|;
name|char
name|terminator
decl_stmt|;
name|struct
name|buf
name|numrev
decl_stmt|;
name|struct
name|hshentries
modifier|*
name|joindeltas
decl_stmt|;
name|j
operator|=
name|joinrev
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|j
operator|++
condition|)
block|{
default|default:
continue|continue;
case|case
literal|0
case|:
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
case|case
literal|':'
case|:
case|case
literal|','
case|:
case|case
literal|';'
case|:
break|break;
block|}
break|break;
block|}
name|terminator
operator|=
operator|*
operator|--
name|j
expr_stmt|;
operator|*
name|j
operator|=
literal|0
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|numrev
argument_list|)
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expandsym
argument_list|(
name|joinrev
argument_list|,
operator|&
name|numrev
argument_list|)
condition|)
name|d
operator|=
name|genrevs
argument_list|(
name|numrev
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|joindeltas
argument_list|)
expr_stmt|;
name|bufautoend
argument_list|(
operator|&
name|numrev
argument_list|)
expr_stmt|;
operator|*
name|j
operator|=
name|terminator
expr_stmt|;
if|if
condition|(
name|d
condition|)
block|{
name|joinlist
index|[
operator|++
name|lastjoin
index|]
operator|=
name|d
operator|->
name|num
expr_stmt|;
return|return
name|j
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|preparejoin
parameter_list|(
name|j
parameter_list|)
specifier|register
name|char
modifier|*
name|j
decl_stmt|;
comment|/* Parse join list J and place pointers to the  * revision numbers into joinlist.  */
block|{
name|lastjoin
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
operator|*
name|j
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|j
operator|==
literal|'\t'
operator|)
operator|||
operator|(
operator|*
name|j
operator|==
literal|','
operator|)
condition|)
name|j
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|j
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|lastjoin
operator|>=
name|joinlength
operator|-
literal|2
condition|)
block|{
name|joinlist
operator|=
operator|(
name|joinlength
operator|*=
literal|2
operator|)
operator|==
literal|0
condition|?
name|tnalloc
argument_list|(
name|char
specifier|const
operator|*
argument_list|,
name|joinlength
operator|=
literal|16
argument_list|)
else|:
name|trealloc
argument_list|(
name|char
specifier|const
operator|*
argument_list|,
name|joinlist
argument_list|,
name|joinlength
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|j
operator|=
name|addjoin
argument_list|(
name|j
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
while|while
condition|(
operator|(
operator|*
name|j
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|j
operator|==
literal|'\t'
operator|)
condition|)
name|j
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|j
operator|==
literal|':'
condition|)
block|{
name|j
operator|++
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|j
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|j
operator|==
literal|'\t'
operator|)
condition|)
name|j
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|j
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|j
operator|=
name|addjoin
argument_list|(
name|j
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
name|rcsfaterror
argument_list|(
literal|"join pair incomplete"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|lastjoin
operator|==
literal|0
condition|)
block|{
comment|/* first pair */
comment|/* common ancestor missing */
name|joinlist
index|[
literal|1
index|]
operator|=
name|joinlist
index|[
literal|0
index|]
expr_stmt|;
name|lastjoin
operator|=
literal|1
expr_stmt|;
comment|/*derive common ancestor*/
if|if
condition|(
operator|!
operator|(
name|joinlist
index|[
literal|0
index|]
operator|=
name|getancestor
argument_list|(
name|targetdelta
operator|->
name|num
argument_list|,
name|joinlist
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
return|return
name|false
return|;
block|}
else|else
block|{
name|rcsfaterror
argument_list|(
literal|"join pair incomplete"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|lastjoin
operator|<
literal|1
condition|)
name|rcsfaterror
argument_list|(
literal|"empty join"
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|char
specifier|const
modifier|*
name|getancestor
parameter_list|(
name|r1
parameter_list|,
name|r2
parameter_list|)
name|char
specifier|const
modifier|*
name|r1
decl_stmt|,
decl|*
name|r2
decl_stmt|;
end_function

begin_comment
comment|/* Yield the common ancestor of r1 and r2 if successful, 0 otherwise.  * Work reliably only if r1 and r2 are not branch numbers.  */
end_comment

begin_block
block|{
specifier|static
name|struct
name|buf
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|int
name|l1
decl_stmt|,
name|l2
decl_stmt|,
name|l3
decl_stmt|;
name|char
specifier|const
modifier|*
name|r
decl_stmt|;
name|l1
operator|=
name|countnumflds
argument_list|(
name|r1
argument_list|)
expr_stmt|;
name|l2
operator|=
name|countnumflds
argument_list|(
name|r2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
literal|2
operator|<
name|l1
operator|||
literal|2
operator|<
name|l2
operator|)
operator|&&
name|cmpnum
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* not on main trunk or identical */
name|l3
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cmpnumfld
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|,
name|l3
operator|+
literal|1
argument_list|)
operator|==
literal|0
operator|&&
name|cmpnumfld
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|,
name|l3
operator|+
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|l3
operator|+=
literal|2
expr_stmt|;
comment|/* This will terminate since r1 and r2 are not the same; see above. */
if|if
condition|(
name|l3
operator|==
literal|0
condition|)
block|{
comment|/* no common prefix; common ancestor on main trunk */
name|VOID
name|partialno
argument_list|(
operator|&
name|t1
argument_list|,
name|r1
argument_list|,
name|l1
operator|>
literal|2
condition|?
literal|2
else|:
name|l1
argument_list|)
decl_stmt|;
name|VOID
name|partialno
argument_list|(
operator|&
name|t2
argument_list|,
name|r2
argument_list|,
name|l2
operator|>
literal|2
condition|?
literal|2
else|:
name|l2
argument_list|)
decl_stmt|;
name|r
operator|=
name|cmpnum
argument_list|(
name|t1
operator|.
name|string
argument_list|,
name|t2
operator|.
name|string
argument_list|)
operator|<
literal|0
condition|?
name|t1
operator|.
name|string
else|:
name|t2
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|cmpnum
argument_list|(
name|r
argument_list|,
name|r1
argument_list|)
operator|!=
literal|0
operator|&&
name|cmpnum
argument_list|(
name|r
argument_list|,
name|r2
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|r
return|;
block|}
elseif|else
if|if
condition|(
name|cmpnumfld
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|,
name|l3
operator|+
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|partialno
argument_list|(
operator|&
name|t1
argument_list|,
name|r1
argument_list|,
name|l3
argument_list|)
return|;
block|}
name|rcserror
argument_list|(
literal|"common ancestor of %s and %s undefined"
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|buildjoin
parameter_list|(
name|initialfile
parameter_list|)
name|char
specifier|const
modifier|*
name|initialfile
decl_stmt|;
comment|/* Function: merge pairs of elements in joinlist into initialfile  * If workstdout is set, copy result to stdout.  * All unlinking of initialfile, rev2, and rev3 should be done by tempunlink().  */
block|{
name|struct
name|buf
name|commarg
decl_stmt|;
name|struct
name|buf
name|subs
decl_stmt|;
name|char
specifier|const
modifier|*
name|rev2
decl_stmt|,
modifier|*
name|rev3
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
specifier|const
modifier|*
name|cov
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|mergev
index|[
literal|11
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
modifier|*
name|p
decl_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|commarg
argument_list|)
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|subs
argument_list|)
expr_stmt|;
name|rev2
operator|=
name|maketemp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|rev3
operator|=
name|maketemp
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* buildrevision() may use 1 and 2 */
name|cov
index|[
literal|1
index|]
operator|=
name|CO
expr_stmt|;
comment|/* cov[2] setup below */
name|p
operator|=
operator|&
name|cov
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|expandarg
condition|)
operator|*
name|p
operator|++
operator|=
name|expandarg
expr_stmt|;
if|if
condition|(
name|suffixarg
condition|)
operator|*
name|p
operator|++
operator|=
name|suffixarg
expr_stmt|;
if|if
condition|(
name|versionarg
condition|)
operator|*
name|p
operator|++
operator|=
name|versionarg
expr_stmt|;
if|if
condition|(
name|zonearg
condition|)
operator|*
name|p
operator|++
operator|=
name|zonearg
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|quietarg
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|RCSname
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|mergev
index|[
literal|1
index|]
operator|=
name|MERGE
expr_stmt|;
name|mergev
index|[
literal|2
index|]
operator|=
name|mergev
index|[
literal|4
index|]
operator|=
literal|"-L"
expr_stmt|;
comment|/* rest of mergev setup below */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|lastjoin
condition|)
block|{
comment|/*prepare marker for merge*/
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|bufscpy
argument_list|(
operator|&
name|subs
argument_list|,
name|targetdelta
operator|->
name|num
argument_list|)
expr_stmt|;
else|else
block|{
name|bufscat
argument_list|(
operator|&
name|subs
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|bufscat
argument_list|(
operator|&
name|subs
argument_list|,
name|joinlist
index|[
name|i
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|bufscat
argument_list|(
operator|&
name|subs
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|bufscat
argument_list|(
operator|&
name|subs
argument_list|,
name|joinlist
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|diagnose
argument_list|(
literal|"revision %s\n"
argument_list|,
name|joinlist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bufscpy
argument_list|(
operator|&
name|commarg
argument_list|,
literal|"-p"
argument_list|)
expr_stmt|;
name|bufscat
argument_list|(
operator|&
name|commarg
argument_list|,
name|joinlist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cov
index|[
literal|2
index|]
operator|=
name|commarg
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|runv
argument_list|(
operator|-
literal|1
argument_list|,
name|rev2
argument_list|,
name|cov
argument_list|)
condition|)
goto|goto
name|badmerge
goto|;
name|diagnose
argument_list|(
literal|"revision %s\n"
argument_list|,
name|joinlist
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|bufscpy
argument_list|(
operator|&
name|commarg
argument_list|,
literal|"-p"
argument_list|)
expr_stmt|;
name|bufscat
argument_list|(
operator|&
name|commarg
argument_list|,
name|joinlist
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|cov
index|[
literal|2
index|]
operator|=
name|commarg
operator|.
name|string
expr_stmt|;
if|if
condition|(
name|runv
argument_list|(
operator|-
literal|1
argument_list|,
name|rev3
argument_list|,
name|cov
argument_list|)
condition|)
goto|goto
name|badmerge
goto|;
name|diagnose
argument_list|(
literal|"merging...\n"
argument_list|)
expr_stmt|;
name|mergev
index|[
literal|3
index|]
operator|=
name|subs
operator|.
name|string
expr_stmt|;
name|mergev
index|[
literal|5
index|]
operator|=
name|joinlist
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|p
operator|=
operator|&
name|mergev
index|[
literal|6
index|]
expr_stmt|;
if|if
condition|(
name|quietflag
condition|)
operator|*
name|p
operator|++
operator|=
name|quietarg
expr_stmt|;
if|if
condition|(
name|lastjoin
operator|<=
name|i
operator|+
literal|2
operator|&&
name|workstdout
condition|)
operator|*
name|p
operator|++
operator|=
literal|"-p"
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|initialfile
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|rev2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|rev3
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|runv
argument_list|(
operator|-
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|mergev
argument_list|)
condition|)
block|{
case|case
name|DIFF_FAILURE
case|:
case|case
name|DIFF_SUCCESS
case|:
break|break;
default|default:
goto|goto
name|badmerge
goto|;
block|}
name|i
operator|=
name|i
operator|+
literal|2
expr_stmt|;
block|}
name|bufautoend
argument_list|(
operator|&
name|commarg
argument_list|)
expr_stmt|;
name|bufautoend
argument_list|(
operator|&
name|subs
argument_list|)
expr_stmt|;
return|return
name|true
return|;
name|badmerge
label|:
name|nerror
operator|++
expr_stmt|;
name|bufautoend
argument_list|(
operator|&
name|commarg
argument_list|)
expr_stmt|;
name|bufautoend
argument_list|(
operator|&
name|subs
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

end_unit

