begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Identify RCS keyword strings in files.  */
end_comment

begin_comment
comment|/* Copyright 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991, 1992, 1993, 1994, 1995 Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/*  * Revision 5.9  1995/06/16 06:19:24  eggert  * Update FSF address.  *  * Revision 5.8  1995/06/01 16:23:43  eggert  * (exiterr, reportError): New functions, needed for DOS and OS/2 ports.  * (scanfile): Use them.  *  * Revision 5.7  1994/03/20 04:52:58  eggert  * Remove `exiting' from identExit.  *  * Revision 5.6  1993/11/09 17:40:15  eggert  * Add -V.  *  * Revision 5.5  1993/11/03 17:42:27  eggert  * Test for char == EOF, not char< 0.  *  * Revision 5.4  1992/01/24  18:44:19  eggert  * lint -> RCS_lint  *  * Revision 5.3  1991/09/10  22:15:46  eggert  * Open files with FOPEN_R, not FOPEN_R_WORK,  * because they might be executables, not working files.  *  * Revision 5.2  1991/08/19  03:13:55  eggert  * Report read errors immediately.  *  * Revision 5.1  1991/02/25  07:12:37  eggert  * Don't report empty keywords.  Check for I/O errors.  *  * Revision 5.0  1990/08/22  08:12:37  eggert  * Don't limit output to known keywords.  * Remove arbitrary limits and lint.  Ansify and Posixate.  *  * Revision 4.5  89/05/01  15:11:54  narten  * changed copyright header to reflect current distribution rules  *  * Revision 4.4  87/10/23  17:09:57  narten  * added exit(0) so exit return code would be non random  *  * Revision 4.3  87/10/18  10:23:55  narten  * Updating version numbers. Changes relative to 1.1 are actually relative  * to 4.1  *  * Revision 1.3  87/07/09  09:20:52  trinkle  * Added check to make sure there is at least one arg before comparing argv[1]  * with "-q".  This necessary on machines that don't allow dereferncing null  * pointers (i.e. Suns).  *  * Revision 1.2  87/03/27  14:21:47  jenkins  * Port to suns  *  * Revision 4.1  83/05/10  16:31:02  wft  * Added option -q and input from reading stdin.  * Marker matching is now done with trymatch() (independent of keywords).  *  * Revision 3.4  83/02/18  17:37:49  wft  * removed printing of new line after last file.  *  * Revision 3.3  82/12/04  12:48:55  wft  * Added LOCKER.  *  * Revision 3.2  82/11/28  18:24:17  wft  * removed Suffix; added ungetc to avoid skipping over trailing KDELIM.  *  * Revision 3.1  82/10/13  15:58:51  wft  * fixed type of variables receiving from getc() (char-->int). */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|match
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|scanfile
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
specifier|const
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reportError
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_macro
name|mainProg
argument_list|(
argument|identId
argument_list|,
literal|"ident"
argument_list|,
literal|"$FreeBSD$"
argument_list|)
end_macro

begin_comment
comment|/*  Ident searches the named files for all occurrences  *  of the pattern $@: text $ where @ is a keyword.  */
end_comment

begin_block
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|quiet
init|=
literal|0
decl_stmt|;
name|int
name|status
init|=
name|EXIT_SUCCESS
decl_stmt|;
name|char
specifier|const
modifier|*
name|a
decl_stmt|;
while|while
condition|(
operator|(
name|a
operator|=
operator|*
operator|++
name|argv
operator|)
operator|&&
operator|*
name|a
operator|==
literal|'-'
condition|)
while|while
condition|(
operator|*
operator|++
name|a
condition|)
switch|switch
condition|(
operator|*
name|a
condition|)
block|{
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|VOID
name|printf
argument_list|(
literal|"RCS version %s\n"
argument_list|,
name|RCS_version_string
argument_list|)
decl_stmt|;
name|quiet
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ident: usage: ident -{qV} [file...]\n"
argument_list|)
decl_stmt|;
name|exitmain
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
literal|0
operator|<=
name|quiet
condition|)
if|if
condition|(
operator|!
name|a
condition|)
name|VOID
name|scanfile
argument_list|(
name|stdin
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|quiet
argument_list|)
decl_stmt|;
else|else
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|a
argument_list|,
name|FOPEN_RB
argument_list|)
operator|)
condition|)
block|{
name|reportError
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|status
operator|=
name|EXIT_FAILURE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scanfile
argument_list|(
name|fp
argument_list|,
name|a
argument_list|,
name|quiet
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|argv
index|[
literal|1
index|]
operator|&&
name|putchar
argument_list|(
literal|'\n'
argument_list|)
operator|==
name|EOF
operator|)
condition|)
break|break;
block|}
do|while
condition|(
operator|(
name|a
operator|=
operator|*
operator|++
name|argv
operator|)
condition|)
do|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|fclose
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|reportError
argument_list|(
literal|"standard output"
argument_list|)
expr_stmt|;
name|status
operator|=
name|EXIT_FAILURE
expr_stmt|;
block|}
name|exitmain
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|RCS_lint
end_if

begin_define
define|#
directive|define
name|exiterr
value|identExit
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|exiterr
parameter_list|()
block|{
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|reportError
parameter_list|(
name|s
parameter_list|)
name|char
specifier|const
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s error: "
argument_list|,
name|cmdid
argument_list|)
decl_stmt|;
name|errno
operator|=
name|e
expr_stmt|;
name|perror
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|scanfile
parameter_list|(
name|file
parameter_list|,
name|name
parameter_list|,
name|quiet
parameter_list|)
specifier|register
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
name|int
name|quiet
decl_stmt|;
comment|/* Function: scan an open file with descriptor file for keywords.  * Return -1 if there's a write error; exit immediately on a read error.  */
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|VOID
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
name|name
operator|=
literal|"standard input"
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|EOF
operator|||
operator|!
operator|(
name|feof
argument_list|(
name|file
argument_list|)
operator||
name|ferror
argument_list|(
name|file
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|KDELIM
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|match
argument_list|(
name|file
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|quiet
operator|=
name|true
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|file
argument_list|)
operator|||
name|fclose
argument_list|(
name|file
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|reportError
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/*       * The following is equivalent to exit(EXIT_FAILURE), but we invoke       * exiterr to keep lint happy.  The DOS and OS/2 ports need exiterr.       */
name|VOID
name|fflush
argument_list|(
name|stderr
argument_list|)
decl_stmt|;
name|VOID
name|fflush
argument_list|(
name|stdout
argument_list|)
decl_stmt|;
name|exiterr
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s warning: no id keywords in %s\n"
argument_list|,
name|cmdid
argument_list|,
name|name
argument_list|)
decl_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|match
parameter_list|(
name|fp
parameter_list|)
comment|/* group substring between two KDELIM's; then do pattern match */
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|VDELIM
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
operator|&&
name|feof
argument_list|(
name|fp
argument_list|)
operator||
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
return|return
name|c
return|;
switch|switch
condition|(
name|ctab
index|[
name|c
index|]
condition|)
block|{
case|case
name|LETTER
case|:
case|case
name|Letter
case|:
case|case
name|DIGIT
case|:
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|tp
operator|<
name|line
operator|+
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|4
condition|)
break|break;
comment|/* fall into */
default|default:
return|return
name|c
condition|?
name|c
else|:
literal|'\n'
comment|/* anything but 0 or KDELIM or EOF */
return|;
block|}
block|}
if|if
condition|(
name|tp
operator|==
name|line
condition|)
return|return
name|c
return|;
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|' '
condition|)
return|return
name|c
condition|?
name|c
else|:
literal|'\n'
return|;
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|KDELIM
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
operator|&&
name|feof
argument_list|(
name|fp
argument_list|)
operator||
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
return|return
name|c
return|;
switch|switch
condition|(
name|ctab
index|[
name|c
index|]
condition|)
block|{
default|default:
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|tp
operator|<
name|line
operator|+
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|2
condition|)
break|break;
comment|/* fall into */
case|case
name|NEWLN
case|:
case|case
name|UNKN
case|:
return|return
name|c
condition|?
name|c
else|:
literal|'\n'
return|;
block|}
block|}
if|if
condition|(
name|tp
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
return|return
name|c
return|;
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
comment|/*append trailing KDELIM*/
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
name|VOID
name|printf
argument_list|(
literal|"     %c%s\n"
argument_list|,
name|KDELIM
argument_list|,
name|line
argument_list|)
decl_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

