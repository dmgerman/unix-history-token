begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (C) 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991 by Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/*  *                     RCS identification operation  */
end_comment

begin_comment
comment|/* $Log: ident.c,v $  * Revision 1.1.1.1  1993/06/18  04:22:11  jkh  * Updated GNU utilities  *  * Revision 5.3  1991/09/10  22:15:46  eggert  * Open files with FOPEN_R, not FOPEN_R_WORK,  * because they might be executables, not working files.  *  * Revision 5.2  1991/08/19  03:13:55  eggert  * Report read errors immediately.  *  * Revision 5.1  1991/02/25  07:12:37  eggert  * Don't report empty keywords.  Check for I/O errors.  *  * Revision 5.0  1990/08/22  08:12:37  eggert  * Don't limit output to known keywords.  * Remove arbitrary limits and lint.  Ansify and Posixate.  *  * Revision 4.5  89/05/01  15:11:54  narten  * changed copyright header to reflect current distribution rules  *  * Revision 4.4  87/10/23  17:09:57  narten  * added exit(0) so exit return code would be non random  *  * Revision 4.3  87/10/18  10:23:55  narten  * Updating version numbers. Changes relative to 1.1 are actually relative  * to 4.1  *  * Revision 1.3  87/07/09  09:20:52  trinkle  * Added check to make sure there is at least one arg before comparing argv[1]  * with "-q".  This necessary on machines that don't allow dereferncing null  * pointers (i.e. Suns).  *  * Revision 1.2  87/03/27  14:21:47  jenkins  * Port to suns  *  * Revision 4.1  83/05/10  16:31:02  wft  * Added option -q and input from reading stdin.  * Marker matching is now done with trymatch() (independent of keywords).  *  * Revision 3.4  83/02/18  17:37:49  wft  * removed printing of new line after last file.  *  * Revision 3.3  82/12/04  12:48:55  wft  * Added LOCKER.  *  * Revision 3.2  82/11/28  18:24:17  wft  * removed Suffix; added ungetc to avoid skipping over trailing KDELIM.  *  * Revision 3.1  82/10/13  15:58:51  wft  * fixed type of variables receiving from getc() (char-->int). */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|match
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scanfile
name|P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
specifier|const
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_macro
name|mainProg
argument_list|(
argument|identId
argument_list|,
literal|"ident"
argument_list|,
literal|"$Id: ident.c,v 1.1.1.1 1993/06/18 04:22:11 jkh Exp $"
argument_list|)
end_macro

begin_comment
comment|/*  Ident searches the named files for all occurrences  *  of the pattern $keyword:...$, where the keywords are  *  Author, Date, Header, Id, Log, RCSfile, Revision, Source, and State.  */
end_comment

begin_block
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|quiet
decl_stmt|;
name|int
name|status
init|=
name|EXIT_SUCCESS
decl_stmt|;
if|if
condition|(
operator|(
name|quiet
operator|=
name|argc
operator|>
literal|1
operator|&&
name|strcmp
argument_list|(
literal|"-q"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|scanfile
argument_list|(
name|stdin
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|fopen
argument_list|(
operator|*
operator|++
name|argv
argument_list|,
name|FOPEN_R
argument_list|)
operator|)
condition|)
block|{
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s error: can't open %s\n"
argument_list|,
name|cmdid
argument_list|,
operator|*
name|argv
argument_list|)
decl_stmt|;
name|status
operator|=
name|EXIT_FAILURE
expr_stmt|;
block|}
else|else
block|{
name|scanfile
argument_list|(
name|fp
argument_list|,
operator|*
name|argv
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|VOID
name|putchar
argument_list|(
literal|'\n'
argument_list|)
decl_stmt|;
block|}
block|}
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|fclose
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s error: write error\n"
argument_list|,
name|cmdid
argument_list|)
decl_stmt|;
name|status
operator|=
name|EXIT_FAILURE
expr_stmt|;
block|}
name|exitmain
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
name|lint
end_if

begin_function
name|exiting
name|void
name|identExit
parameter_list|()
block|{
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|scanfile
parameter_list|(
name|file
parameter_list|,
name|name
parameter_list|,
name|quiet
parameter_list|)
specifier|register
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
specifier|const
modifier|*
name|name
decl_stmt|;
name|int
name|quiet
decl_stmt|;
comment|/* Function: scan an open file with descriptor file for keywords.  * Return false if there's a read error.  */
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|name
condition|)
name|VOID
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
name|name
argument_list|)
decl_stmt|;
else|else
name|name
operator|=
literal|"input"
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|file
argument_list|)
condition|)
break|break;
if|if
condition|(
name|ferror
argument_list|(
name|file
argument_list|)
condition|)
goto|goto
name|read_error
goto|;
block|}
if|if
condition|(
name|c
operator|==
name|KDELIM
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|match
argument_list|(
name|file
argument_list|)
operator|)
condition|)
continue|continue;
name|quiet
operator|=
name|true
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s warning: no id keywords in %s\n"
argument_list|,
name|cmdid
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|file
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|read_error
label|:
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s error: %s: read error\n"
argument_list|,
name|cmdid
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|match
parameter_list|(
name|fp
parameter_list|)
comment|/* group substring between two KDELIM's; then do pattern match */
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
block|{
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|VDELIM
condition|)
block|{
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
name|c
return|;
switch|switch
condition|(
name|ctab
index|[
name|c
index|]
condition|)
block|{
case|case
name|LETTER
case|:
case|case
name|Letter
case|:
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|tp
operator|<
name|line
operator|+
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|4
condition|)
break|break;
comment|/* fall into */
default|default:
return|return
name|c
condition|?
name|c
else|:
literal|'\n'
comment|/* anything but 0 or KDELIM or EOF */
return|;
block|}
block|}
if|if
condition|(
name|tp
operator|==
name|line
condition|)
return|return
name|c
return|;
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|' '
condition|)
return|return
name|c
condition|?
name|c
else|:
literal|'\n'
return|;
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|KDELIM
condition|)
block|{
if|if
condition|(
name|c
operator|<
literal|0
operator|&&
name|feof
argument_list|(
name|fp
argument_list|)
operator||
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
return|return
name|c
return|;
switch|switch
condition|(
name|ctab
index|[
name|c
index|]
condition|)
block|{
default|default:
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|tp
operator|<
name|line
operator|+
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|2
condition|)
break|break;
comment|/* fall into */
case|case
name|NEWLN
case|:
case|case
name|UNKN
case|:
return|return
name|c
condition|?
name|c
else|:
literal|'\n'
return|;
block|}
block|}
if|if
condition|(
name|tp
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
return|return
name|c
return|;
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
comment|/*append trailing KDELIM*/
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"     %c%s\n"
argument_list|,
name|KDELIM
argument_list|,
name|line
argument_list|)
decl_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

