begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Change RCS file attributes.  */
end_comment

begin_comment
comment|/* Copyright 1982, 1988, 1989 Walter Tichy    Copyright 1990, 1991, 1992, 1993, 1994, 1995 Paul Eggert    Distributed under license by the Free Software Foundation, Inc.  This file is part of RCS.  RCS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  RCS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with RCS; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  Report problems and direct all questions to:      rcs-bugs@cs.purdue.edu  */
end_comment

begin_comment
comment|/*  * $Log: rcs.c,v $  * Revision 5.21  1995/06/16 06:19:24  eggert  * Update FSF address.  *  * Revision 5.20  1995/06/01 16:23:43  eggert  * (main): Warn if no options were given.  Punctuate messages properly.  *  * (sendmail): Rewind mailmess before flushing it.  * Output another warning if mail should work but fails.  *  * (buildeltatext): Pass "--binary" if -kb and if --binary makes a difference.  *  * Revision 5.19  1994/03/17 14:05:48  eggert  * Use ORCSerror to clean up after a fatal error.  Remove lint.  * Specify subprocess input via file descriptor, not file name.  Remove lint.  * Flush stderr after prompt.  *  * Revision 5.18  1993/11/09 17:40:15  eggert  * -V now prints version on stdout and exits.  Don't print usage twice.  *  * Revision 5.17  1993/11/03 17:42:27  eggert  * Add -z.  Don't lose track of -m or -t when there are no other changes.  * Don't discard ignored phrases.  Improve quality of diagnostics.  *  * Revision 5.16  1992/07/28  16:12:44  eggert  * rcs -l now asks whether you want to break the lock.  * Add -V.  Set RCS file's mode and time at right moment.  *  * Revision 5.15  1992/02/17  23:02:20  eggert  * Add -T.  *  * Revision 5.14  1992/01/27  16:42:53  eggert  * Add -M.  Avoid invoking umask(); it's one less thing to configure.  * Add support for bad_creat0.  lint -> RCS_lint  *  * Revision 5.13  1992/01/06  02:42:34  eggert  * Avoid changing RCS file in common cases where no change can occur.  *  * Revision 5.12  1991/11/20  17:58:08  eggert  * Don't read the delta tree from a nonexistent RCS file.  *  * Revision 5.11  1991/10/07  17:32:46  eggert  * Remove lint.  *  * Revision 5.10  1991/08/19  23:17:54  eggert  * Add -m, -r$, piece tables.  Revision separator is `:', not `-'.  Tune.  *  * Revision 5.9  1991/04/21  11:58:18  eggert  * Add -x, RCSINIT, MS-DOS support.  *  * Revision 5.8  1991/02/25  07:12:38  eggert  * strsave -> str_save (DG/UX name clash)  * 0444 -> S_IRUSR|S_IRGRP|S_IROTH for portability  *  * Revision 5.7  1990/12/18  17:19:21  eggert  * Fix bug with multiple -n and -N options.  *  * Revision 5.6  1990/12/04  05:18:40  eggert  * Use -I for prompts and -q for diagnostics.  *  * Revision 5.5  1990/11/11  00:06:35  eggert  * Fix `rcs -e' core dump.  *  * Revision 5.4  1990/11/01  05:03:33  eggert  * Add -I and new -t behavior.  Permit arbitrary data in logs.  *  * Revision 5.3  1990/10/04  06:30:16  eggert  * Accumulate exit status across files.  *  * Revision 5.2  1990/09/04  08:02:17  eggert  * Standardize yes-or-no procedure.  *  * Revision 5.1  1990/08/29  07:13:51  eggert  * Remove unused setuid support.  Clean old log messages too.  *  * Revision 5.0  1990/08/22  08:12:42  eggert  * Don't lose names when applying -a option to multiple files.  * Remove compile-time limits; use malloc instead.  Add setuid support.  * Permit dates past 1999/12/31.  Make lock and temp files faster and safer.  * Ansify and Posixate.  Add -V.  Fix umask bug.  Make linting easier.  Tune.  * Yield proper exit status.  Check diff's output.  *  * Revision 4.11  89/05/01  15:12:06  narten  * changed copyright header to reflect current distribution rules  *  * Revision 4.10  88/11/08  16:01:54  narten  * didn't install previous patch correctly  *  * Revision 4.9  88/11/08  13:56:01  narten  * removed include<sysexits.h> (not needed)  * minor fix for -A option  *  * Revision 4.8  88/08/09  19:12:27  eggert  * Don't access freed storage.  * Use execv(), not system(); yield proper exit status; remove lint.  *  * Revision 4.7  87/12/18  11:37:17  narten  * lint cleanups (Guy Harris)  *  * Revision 4.6  87/10/18  10:28:48  narten  * Updating verison numbers. Changes relative to 1.1 are actually  * relative to 4.3  *  * Revision 1.4  87/09/24  13:58:52  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf  * warnings)  *  * Revision 1.3  87/03/27  14:21:55  jenkins  * Port to suns  *  * Revision 1.2  85/12/17  13:59:09  albitz  * Changed setstate to rcs_setstate because of conflict with random.o.  *  * Revision 4.3  83/12/15  12:27:33  wft  * rcs -u now breaks most recent lock if it can't find a lock by the caller.  *  * Revision 4.2  83/12/05  10:18:20  wft  * Added conditional compilation for sending mail.  * Alternatives: V4_2BSD, V6, USG, and other.  *  * Revision 4.1  83/05/10  16:43:02  wft  * Simplified breaklock(); added calls to findlock() and getcaller().  * Added option -b (default branch). Updated -s and -w for -b.  * Removed calls to stat(); now done by pairfilenames().  * Replaced most catchints() calls with restoreints().  * Removed check for exit status of delivermail().  * Directed all interactive output to stderr.  *  * Revision 3.9.1.1  83/12/02  22:08:51  wft  * Added conditional compilation for 4.2 sendmail and 4.1 delivermail.  *  * Revision 3.9  83/02/15  15:38:39  wft  * Added call to fastcopy() to copy remainder of RCS file.  *  * Revision 3.8  83/01/18  17:37:51  wft  * Changed sendmail(): now uses delivermail, and asks whether to break the lock.  *  * Revision 3.7  83/01/15  18:04:25  wft  * Removed putree(); replaced with puttree() in rcssyn.c.  * Combined putdellog() and scanlogtext(); deleted putdellog().  * Cleaned up diagnostics and error messages. Fixed problem with  * mutilated files in case of deletions in 2 files in a single command.  * Changed marking of selector from 'D' to DELETE.  *  * Revision 3.6  83/01/14  15:37:31  wft  * Added ignoring of interrupts while new RCS file is renamed;  * Avoids deletion of RCS files by interrupts.  *  * Revision 3.5  82/12/10  21:11:39  wft  * Removed unused variables, fixed checking of return code from diff,  * introduced variant COMPAT2 for skipping Suffix on -A files.  *  * Revision 3.4  82/12/04  13:18:20  wft  * Replaced getdelta() with gettree(), changed breaklock to update  * field lockedby, added some diagnostics.  *  * Revision 3.3  82/12/03  17:08:04  wft  * Replaced getlogin() with getpwuid(), flcose() with ffclose(),  * /usr/ucb/Mail with macro MAIL. Removed handling of Suffix (-x).  * fixed -u for missing revno. Disambiguated structure members.  *  * Revision 3.2  82/10/18  21:05:07  wft  * rcs -i now generates a file mode given by the umask minus write permission;  * otherwise, rcs keeps the mode, but removes write permission.  * I added a check for write error, fixed call to getlogin(), replaced  * curdir() with getfullRCSname(), cleaned up handling -U/L, and changed  * conflicting, long identifiers.  *  * Revision 3.1  82/10/13  16:11:07  wft  * fixed type of variables receiving from getc() (char -> int).  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_struct
struct|struct
name|Lockrev
block|{
name|char
specifier|const
modifier|*
name|revno
decl_stmt|;
name|struct
name|Lockrev
modifier|*
name|nextrev
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Symrev
block|{
name|char
specifier|const
modifier|*
name|revno
decl_stmt|;
name|char
specifier|const
modifier|*
name|ssymbol
decl_stmt|;
name|int
name|override
decl_stmt|;
name|struct
name|Symrev
modifier|*
name|nextsym
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Message
block|{
name|char
specifier|const
modifier|*
name|revno
decl_stmt|;
name|struct
name|cbuf
name|message
decl_stmt|;
name|struct
name|Message
modifier|*
name|nextmessage
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Status
block|{
name|char
specifier|const
modifier|*
name|revno
decl_stmt|;
name|char
specifier|const
modifier|*
name|status
decl_stmt|;
name|struct
name|Status
modifier|*
name|nextstatus
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|changeaccess
block|{
name|append
block|,
name|erase
block|}
enum|;
end_enum

begin_struct
struct|struct
name|chaccess
block|{
name|char
specifier|const
modifier|*
name|login
decl_stmt|;
name|enum
name|changeaccess
name|command
decl_stmt|;
name|struct
name|chaccess
modifier|*
name|nextchaccess
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|delrevpair
block|{
name|char
specifier|const
modifier|*
name|strt
decl_stmt|;
name|char
specifier|const
modifier|*
name|end
decl_stmt|;
name|int
name|code
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|branchpoint
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|,
expr|struct
name|hshentry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|breaklock
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|buildeltatext
name|P
argument_list|(
operator|(
expr|struct
name|hshentries
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|doaccess
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|doassoc
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dolocks
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|domessages
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rcs_setstate
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|removerevs
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sendmail
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setlock
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|Lockrev
modifier|*
modifier|*
name|rmnewlocklst
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hshentry
modifier|*
name|searchcutpt
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
name|int
operator|,
expr|struct
name|hshentries
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|buildtree
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cleanup
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getaccessor
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|enum
name|changeaccess
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getassoclst
name|P
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getchaccess
name|P
argument_list|(
operator|(
name|char
specifier|const
operator|*
operator|,
expr|enum
name|changeaccess
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getdelrev
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getmessage
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getstates
name|P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scanlogtext
name|P
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|buf
name|numrev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
name|headstate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|chgheadstate
decl_stmt|,
name|exitstatus
decl_stmt|,
name|lockhead
decl_stmt|,
name|unlockcaller
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|suppress_mail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|Lockrev
modifier|*
name|newlocklst
decl_stmt|,
modifier|*
name|rmvlocklst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|Message
modifier|*
name|messagelst
decl_stmt|,
modifier|*
modifier|*
name|nextmessage
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|Status
modifier|*
name|statelst
decl_stmt|,
modifier|*
modifier|*
name|nextstate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|Symrev
modifier|*
name|assoclst
decl_stmt|,
modifier|*
modifier|*
name|nextassoc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|chaccess
modifier|*
name|chaccess
decl_stmt|,
modifier|*
modifier|*
name|nextchaccess
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|delrevpair
name|delrev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hshentry
modifier|*
name|cuthead
decl_stmt|,
modifier|*
name|cuttail
decl_stmt|,
modifier|*
name|delstrt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hshentries
modifier|*
name|gendeltas
decl_stmt|;
end_decl_stmt

begin_macro
name|mainProg
argument_list|(
argument|rcsId
argument_list|,
literal|"rcs"
argument_list|,
literal|"$Id: rcs.c,v 5.21 1995/06/16 06:19:24 eggert Exp $"
argument_list|)
end_macro

begin_block
block|{
specifier|static
name|char
specifier|const
name|cmdusage
index|[]
init|=
literal|"\nrcs usage: rcs -{ae}logins -Afile -{blu}[rev] -cstring -{iILqTU} -ksubst -mrev:msg -{nN}name[:[rev]] -orange -sstate[:rev] -t[text] -Vn -xsuff -zzone file ..."
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
modifier|*
name|newargv
decl_stmt|,
modifier|*
name|textfile
decl_stmt|;
name|char
specifier|const
modifier|*
name|branchsym
decl_stmt|,
modifier|*
name|commsyml
decl_stmt|;
name|int
name|branchflag
decl_stmt|,
name|changed
decl_stmt|,
name|expmode
decl_stmt|,
name|initflag
decl_stmt|;
name|int
name|strictlock
decl_stmt|,
name|strict_selected
decl_stmt|,
name|textflag
decl_stmt|;
name|int
name|keepRCStime
decl_stmt|,
name|Ttimeflag
decl_stmt|;
name|size_t
name|commsymlen
decl_stmt|;
name|struct
name|buf
name|branchnum
decl_stmt|;
name|struct
name|Lockrev
modifier|*
name|lockpt
decl_stmt|;
name|struct
name|Lockrev
modifier|*
modifier|*
name|curlock
decl_stmt|,
modifier|*
modifier|*
name|rmvlock
decl_stmt|;
name|struct
name|Status
modifier|*
name|curstate
decl_stmt|;
name|nosetid
argument_list|()
expr_stmt|;
name|nextassoc
operator|=
operator|&
name|assoclst
expr_stmt|;
name|nextchaccess
operator|=
operator|&
name|chaccess
expr_stmt|;
name|nextmessage
operator|=
operator|&
name|messagelst
expr_stmt|;
name|nextstate
operator|=
operator|&
name|statelst
expr_stmt|;
name|branchsym
operator|=
name|commsyml
operator|=
name|textfile
operator|=
literal|0
expr_stmt|;
name|branchflag
operator|=
name|strictlock
operator|=
name|false
expr_stmt|;
name|bufautobegin
argument_list|(
operator|&
name|branchnum
argument_list|)
expr_stmt|;
name|commsymlen
operator|=
literal|0
expr_stmt|;
name|curlock
operator|=
operator|&
name|newlocklst
expr_stmt|;
name|rmvlock
operator|=
operator|&
name|rmvlocklst
expr_stmt|;
name|expmode
operator|=
operator|-
literal|1
expr_stmt|;
name|suffixes
operator|=
name|X_DEFAULT
expr_stmt|;
name|initflag
operator|=
name|textflag
operator|=
name|false
expr_stmt|;
name|strict_selected
operator|=
literal|0
expr_stmt|;
name|Ttimeflag
operator|=
name|false
expr_stmt|;
comment|/*  preprocessing command options    */
if|if
condition|(
literal|1
operator|<
name|argc
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
name|warn
argument_list|(
literal|"No options were given; this usage is obsolescent."
argument_list|)
expr_stmt|;
name|argc
operator|=
name|getRCSINIT
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|newargv
argument_list|)
expr_stmt|;
name|argv
operator|=
name|newargv
expr_stmt|;
while|while
condition|(
name|a
operator|=
operator|*
operator|++
name|argv
operator|,
literal|0
operator|<
operator|--
name|argc
operator|&&
operator|*
name|a
operator|++
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
operator|*
name|a
operator|++
condition|)
block|{
case|case
literal|'i'
case|:
comment|/*  initial version  */
name|initflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* change default branch */
if|if
condition|(
name|branchflag
condition|)
name|redefined
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
name|branchflag
operator|=
name|true
expr_stmt|;
name|branchsym
operator|=
name|a
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/*  change comment symbol   */
if|if
condition|(
name|commsyml
condition|)
name|redefined
argument_list|(
literal|'c'
argument_list|)
expr_stmt|;
name|commsyml
operator|=
name|a
expr_stmt|;
name|commsymlen
operator|=
name|strlen
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/*  add new accessor   */
name|getaccessor
argument_list|(
operator|*
name|argv
operator|+
literal|1
argument_list|,
name|append
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
comment|/*  append access list according to accessfile  */
if|if
condition|(
operator|!
operator|*
name|a
condition|)
block|{
name|error
argument_list|(
literal|"missing pathname after -A"
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|argv
operator|=
name|a
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|pairnames
argument_list|(
literal|1
argument_list|,
name|argv
argument_list|,
name|rcsreadopen
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
condition|)
block|{
while|while
condition|(
name|AccessList
condition|)
block|{
name|getchaccess
argument_list|(
name|str_save
argument_list|(
name|AccessList
operator|->
name|login
argument_list|)
argument_list|,
name|append
argument_list|)
expr_stmt|;
name|AccessList
operator|=
name|AccessList
operator|->
name|nextaccess
expr_stmt|;
block|}
name|Izclose
argument_list|(
operator|&
name|finptr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'e'
case|:
comment|/*  remove accessors   */
name|getaccessor
argument_list|(
operator|*
name|argv
operator|+
literal|1
argument_list|,
name|erase
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/*   lock a revision if it is unlocked   */
if|if
condition|(
operator|!
operator|*
name|a
condition|)
block|{
comment|/* Lock head or default branch.  */
name|lockhead
operator|=
name|true
expr_stmt|;
break|break;
block|}
operator|*
name|curlock
operator|=
name|lockpt
operator|=
name|talloc
argument_list|(
expr|struct
name|Lockrev
argument_list|)
expr_stmt|;
name|lockpt
operator|->
name|revno
operator|=
name|a
expr_stmt|;
name|lockpt
operator|->
name|nextrev
operator|=
literal|0
expr_stmt|;
name|curlock
operator|=
operator|&
name|lockpt
operator|->
name|nextrev
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/*  release lock of a locked revision   */
if|if
condition|(
operator|!
operator|*
name|a
condition|)
block|{
name|unlockcaller
operator|=
name|true
expr_stmt|;
break|break;
block|}
operator|*
name|rmvlock
operator|=
name|lockpt
operator|=
name|talloc
argument_list|(
expr|struct
name|Lockrev
argument_list|)
expr_stmt|;
name|lockpt
operator|->
name|revno
operator|=
name|a
expr_stmt|;
name|lockpt
operator|->
name|nextrev
operator|=
literal|0
expr_stmt|;
name|rmvlock
operator|=
operator|&
name|lockpt
operator|->
name|nextrev
expr_stmt|;
name|curlock
operator|=
name|rmnewlocklst
argument_list|(
name|lockpt
operator|->
name|revno
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/*  set strict locking */
if|if
condition|(
name|strict_selected
condition|)
block|{
if|if
condition|(
operator|!
name|strictlock
condition|)
comment|/* Already selected -U? */
name|warn
argument_list|(
literal|"-U overridden by -L"
argument_list|)
expr_stmt|;
block|}
name|strictlock
operator|=
name|true
expr_stmt|;
name|strict_selected
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/*  release strict locking */
if|if
condition|(
name|strict_selected
condition|)
block|{
if|if
condition|(
name|strictlock
condition|)
comment|/* Already selected -L? */
name|warn
argument_list|(
literal|"-L overridden by -U"
argument_list|)
expr_stmt|;
block|}
name|strict_selected
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/*  add new association: error, if name exists */
if|if
condition|(
operator|!
operator|*
name|a
condition|)
block|{
name|error
argument_list|(
literal|"missing symbolic name after -n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|getassoclst
argument_list|(
name|false
argument_list|,
operator|(
operator|*
name|argv
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/*  add or change association   */
if|if
condition|(
operator|!
operator|*
name|a
condition|)
block|{
name|error
argument_list|(
literal|"missing symbolic name after -N"
argument_list|)
expr_stmt|;
break|break;
block|}
name|getassoclst
argument_list|(
name|true
argument_list|,
operator|(
operator|*
name|argv
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/*  change log message  */
name|getmessage
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/*  do not send mail */
name|suppress_mail
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/*  delete revisions  */
if|if
condition|(
name|delrev
operator|.
name|strt
condition|)
name|redefined
argument_list|(
literal|'o'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|a
condition|)
block|{
name|error
argument_list|(
literal|"missing revision range after -o"
argument_list|)
expr_stmt|;
break|break;
block|}
name|getdelrev
argument_list|(
operator|(
operator|*
name|argv
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/*  change state attribute of a revision  */
if|if
condition|(
operator|!
operator|*
name|a
condition|)
block|{
name|error
argument_list|(
literal|"state missing after -s"
argument_list|)
expr_stmt|;
break|break;
block|}
name|getstates
argument_list|(
operator|(
operator|*
name|argv
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/*  change descriptive text   */
name|textflag
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|*
name|a
condition|)
block|{
if|if
condition|(
name|textfile
condition|)
name|redefined
argument_list|(
literal|'t'
argument_list|)
expr_stmt|;
name|textfile
operator|=
name|a
expr_stmt|;
block|}
break|break;
case|case
literal|'T'
case|:
comment|/*  do not update last-mod time for minor changes */
if|if
condition|(
operator|*
name|a
condition|)
goto|goto
name|unknown
goto|;
name|Ttimeflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|interactiveflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quietflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|suffixes
operator|=
name|a
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|setRCSversion
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|zone_set
argument_list|(
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/*  set keyword expand mode  */
if|if
condition|(
literal|0
operator|<=
name|expmode
condition|)
name|redefined
argument_list|(
literal|'k'
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
operator|(
name|expmode
operator|=
name|str2expmode
argument_list|(
name|a
argument_list|)
operator|)
condition|)
break|break;
comment|/* fall into */
default|default:
name|unknown
label|:
name|error
argument_list|(
literal|"unknown option: %s%s"
argument_list|,
operator|*
name|argv
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
comment|/* end processing of options */
comment|/* Now handle all pathnames.  */
if|if
condition|(
name|nerror
condition|)
name|cleanup
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|faterror
argument_list|(
literal|"no input file%s"
argument_list|,
name|cmdusage
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
literal|0
operator|<
name|argc
condition|;
name|cleanup
argument_list|()
operator|,
operator|++
name|argv
operator|,
operator|--
name|argc
control|)
block|{
name|ffree
argument_list|()
expr_stmt|;
if|if
condition|(
name|initflag
condition|)
block|{
switch|switch
condition|(
name|pairnames
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|rcswriteopen
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
break|break;
comment|/*  not exist; ok */
case|case
literal|0
case|:
continue|continue;
comment|/*  error         */
case|case
literal|1
case|:
name|rcserror
argument_list|(
literal|"already exists"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|pairnames
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|rcswriteopen
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
continue|continue;
comment|/*  not exist      */
case|case
literal|0
case|:
continue|continue;
comment|/*  errors         */
case|case
literal|1
case|:
break|break;
comment|/*  file exists; ok*/
block|}
block|}
comment|/* 	 * RCSname contains the name of the RCS file, and 	 * workname contains the name of the working file.          * if !initflag, finptr contains the file descriptor for the          * RCS file. The admin node is initialized.          */
name|diagnose
argument_list|(
literal|"RCS file: %s\n"
argument_list|,
name|RCSname
argument_list|)
expr_stmt|;
name|changed
operator|=
name|initflag
operator||
name|textflag
expr_stmt|;
name|keepRCStime
operator|=
name|Ttimeflag
expr_stmt|;
if|if
condition|(
operator|!
name|initflag
condition|)
block|{
if|if
condition|(
operator|!
name|checkaccesslist
argument_list|()
condition|)
continue|continue;
name|gettree
argument_list|()
expr_stmt|;
comment|/* Read the delta tree.  */
block|}
comment|/*  update admin. node    */
if|if
condition|(
name|strict_selected
condition|)
block|{
name|changed
operator||=
name|StrictLocks
operator|^
name|strictlock
expr_stmt|;
name|StrictLocks
operator|=
name|strictlock
expr_stmt|;
block|}
if|if
condition|(
name|commsyml
operator|&&
operator|(
name|commsymlen
operator|!=
name|Comment
operator|.
name|size
operator|||
name|memcmp
argument_list|(
name|commsyml
argument_list|,
name|Comment
operator|.
name|string
argument_list|,
name|commsymlen
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|Comment
operator|.
name|string
operator|=
name|commsyml
expr_stmt|;
name|Comment
operator|.
name|size
operator|=
name|strlen
argument_list|(
name|commsyml
argument_list|)
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|<=
name|expmode
operator|&&
name|Expand
operator|!=
name|expmode
condition|)
block|{
name|Expand
operator|=
name|expmode
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
comment|/* update default branch */
if|if
condition|(
name|branchflag
operator|&&
name|expandsym
argument_list|(
name|branchsym
argument_list|,
operator|&
name|branchnum
argument_list|)
condition|)
block|{
if|if
condition|(
name|countnumflds
argument_list|(
name|branchnum
operator|.
name|string
argument_list|)
condition|)
block|{
if|if
condition|(
name|cmpnum
argument_list|(
name|Dbranch
argument_list|,
name|branchnum
operator|.
name|string
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Dbranch
operator|=
name|branchnum
operator|.
name|string
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|Dbranch
condition|)
block|{
name|Dbranch
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
block|}
name|changed
operator||=
name|doaccess
argument_list|()
expr_stmt|;
comment|/* Update access list.  */
name|changed
operator||=
name|doassoc
argument_list|()
expr_stmt|;
comment|/* Update association list.  */
name|changed
operator||=
name|dolocks
argument_list|()
expr_stmt|;
comment|/* Update locks.  */
name|changed
operator||=
name|domessages
argument_list|()
expr_stmt|;
comment|/* Update log messages.  */
comment|/*  update state attribution  */
if|if
condition|(
name|chgheadstate
condition|)
block|{
comment|/* change state of default branch or head */
if|if
condition|(
operator|!
name|Dbranch
condition|)
block|{
if|if
condition|(
operator|!
name|Head
condition|)
name|rcswarn
argument_list|(
literal|"can't change states in an empty tree"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|Head
operator|->
name|state
argument_list|,
name|headstate
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|Head
operator|->
name|state
operator|=
name|headstate
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
name|changed
operator||=
name|rcs_setstate
argument_list|(
name|Dbranch
argument_list|,
name|headstate
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|curstate
operator|=
name|statelst
init|;
name|curstate
condition|;
name|curstate
operator|=
name|curstate
operator|->
name|nextstatus
control|)
name|changed
operator||=
name|rcs_setstate
argument_list|(
name|curstate
operator|->
name|revno
argument_list|,
name|curstate
operator|->
name|status
argument_list|)
expr_stmt|;
name|cuthead
operator|=
name|cuttail
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|delrev
operator|.
name|strt
operator|&&
name|removerevs
argument_list|()
condition|)
block|{
comment|/*  rebuild delta tree if some deltas are deleted   */
if|if
condition|(
name|cuttail
condition|)
name|VOID
name|genrevs
argument_list|(
name|cuttail
operator|->
name|num
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|gendeltas
argument_list|)
decl_stmt|;
name|buildtree
argument_list|()
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
name|keepRCStime
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|nerror
condition|)
continue|continue;
name|putadmin
argument_list|()
expr_stmt|;
if|if
condition|(
name|Head
condition|)
name|puttree
argument_list|(
name|Head
argument_list|,
name|frewrite
argument_list|)
expr_stmt|;
name|putdesc
argument_list|(
name|textflag
argument_list|,
name|textfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|Head
condition|)
block|{
if|if
condition|(
name|delrev
operator|.
name|strt
operator|||
name|messagelst
condition|)
block|{
if|if
condition|(
operator|!
name|cuttail
operator|||
name|buildeltatext
argument_list|(
name|gendeltas
argument_list|)
condition|)
block|{
name|advise_access
argument_list|(
name|finptr
argument_list|,
name|MADV_SEQUENTIAL
argument_list|)
expr_stmt|;
name|scanlogtext
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
literal|0
argument_list|,
name|false
argument_list|)
expr_stmt|;
comment|/* copy rest of delta text nodes that are not deleted      */
name|changed
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|initflag
condition|)
block|{
comment|/* Adjust things for donerewrite's sake.  */
if|if
condition|(
name|stat
argument_list|(
name|workname
argument_list|,
operator|&
name|RCSstat
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
name|bad_creat0
name|mode_t
name|m
init|=
name|umask
argument_list|(
literal|0
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|RCSstat
operator|.
name|st_mode
operator|=
operator|(
name|S_IRUSR
operator||
name|S_IRGRP
operator||
name|S_IROTH
operator|)
operator|&
operator|~
name|m
expr_stmt|;
else|#
directive|else
name|changed
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
name|RCSstat
operator|.
name|st_nlink
operator|=
literal|0
expr_stmt|;
name|keepRCStime
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|donerewrite
argument_list|(
name|changed
argument_list|,
name|keepRCStime
condition|?
name|RCSstat
operator|.
name|st_mtime
else|:
operator|(
name|time_t
operator|)
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|diagnose
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
block|}
name|tempunlink
argument_list|()
expr_stmt|;
name|exitmain
argument_list|(
name|exitstatus
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end of main (rcs) */
end_comment

begin_function
specifier|static
name|void
name|cleanup
parameter_list|()
block|{
if|if
condition|(
name|nerror
condition|)
name|exitstatus
operator|=
name|EXIT_FAILURE
expr_stmt|;
name|Izclose
argument_list|(
operator|&
name|finptr
argument_list|)
expr_stmt|;
name|Ozclose
argument_list|(
operator|&
name|fcopy
argument_list|)
expr_stmt|;
name|ORCSclose
argument_list|()
expr_stmt|;
name|dirtempunlink
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|exiterr
parameter_list|()
block|{
name|ORCSerror
argument_list|()
expr_stmt|;
name|dirtempunlink
argument_list|()
expr_stmt|;
name|tempunlink
argument_list|()
expr_stmt|;
name|_exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|getassoclst
parameter_list|(
name|flag
parameter_list|,
name|sp
parameter_list|)
name|int
name|flag
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|;
comment|/*  Function:   associate a symbolic name to a revision or branch,      */
comment|/*              and store in assoclst                                   */
block|{
name|struct
name|Symrev
modifier|*
name|pt
decl_stmt|;
name|char
specifier|const
modifier|*
name|temp
decl_stmt|;
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|sp
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
continue|continue;
name|temp
operator|=
name|sp
expr_stmt|;
name|sp
operator|=
name|checksym
argument_list|(
name|sp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
comment|/*  check for invalid symbolic name  */
name|c
operator|=
operator|*
name|sp
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
name|c
operator|=
operator|*
operator|++
name|sp
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|':'
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|error
argument_list|(
literal|"invalid string %s after option -n or -N"
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return;
block|}
name|pt
operator|=
name|talloc
argument_list|(
expr|struct
name|Symrev
argument_list|)
expr_stmt|;
name|pt
operator|->
name|ssymbol
operator|=
name|temp
expr_stmt|;
name|pt
operator|->
name|override
operator|=
name|flag
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
comment|/*  delete symbol  */
name|pt
operator|->
name|revno
operator|=
literal|0
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|sp
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
continue|continue;
name|pt
operator|->
name|revno
operator|=
name|sp
expr_stmt|;
block|}
name|pt
operator|->
name|nextsym
operator|=
literal|0
expr_stmt|;
operator|*
name|nextassoc
operator|=
name|pt
expr_stmt|;
name|nextassoc
operator|=
operator|&
name|pt
operator|->
name|nextsym
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|getchaccess
parameter_list|(
name|login
parameter_list|,
name|command
parameter_list|)
name|char
specifier|const
modifier|*
name|login
decl_stmt|;
name|enum
name|changeaccess
name|command
decl_stmt|;
block|{
specifier|register
name|struct
name|chaccess
modifier|*
name|pt
decl_stmt|;
name|pt
operator|=
name|talloc
argument_list|(
expr|struct
name|chaccess
argument_list|)
expr_stmt|;
name|pt
operator|->
name|login
operator|=
name|login
expr_stmt|;
name|pt
operator|->
name|command
operator|=
name|command
expr_stmt|;
name|pt
operator|->
name|nextchaccess
operator|=
literal|0
expr_stmt|;
operator|*
name|nextchaccess
operator|=
name|pt
expr_stmt|;
name|nextchaccess
operator|=
operator|&
name|pt
operator|->
name|nextchaccess
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|getaccessor
parameter_list|(
name|opt
parameter_list|,
name|command
parameter_list|)
name|char
modifier|*
name|opt
decl_stmt|;
name|enum
name|changeaccess
name|command
decl_stmt|;
comment|/*   Function:  get the accessor list of options -e and -a,     */
comment|/*		and store in chaccess				*/
block|{
specifier|register
name|c
expr_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|opt
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|sp
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|','
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|command
operator|==
name|erase
operator|&&
name|sp
operator|-
name|opt
operator|==
literal|1
condition|)
block|{
name|getchaccess
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|command
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
literal|"missing login name after option -a or -e"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|c
operator|!=
literal|'\0'
condition|)
block|{
name|getchaccess
argument_list|(
name|sp
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|sp
operator|=
name|checkid
argument_list|(
name|sp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|sp
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|','
condition|)
name|c
operator|=
operator|(
operator|*
operator|++
name|sp
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|getmessage
parameter_list|(
name|option
parameter_list|)
name|char
modifier|*
name|option
decl_stmt|;
block|{
name|struct
name|Message
modifier|*
name|pt
decl_stmt|;
name|struct
name|cbuf
name|cb
decl_stmt|;
name|char
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|=
name|strchr
argument_list|(
name|option
argument_list|,
literal|':'
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"-m option lacks revision number"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|m
operator|++
operator|=
literal|0
expr_stmt|;
name|cb
operator|=
name|cleanlogmsg
argument_list|(
name|m
argument_list|,
name|strlen
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cb
operator|.
name|size
condition|)
block|{
name|error
argument_list|(
literal|"-m option lacks log message"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pt
operator|=
name|talloc
argument_list|(
expr|struct
name|Message
argument_list|)
expr_stmt|;
name|pt
operator|->
name|revno
operator|=
name|option
expr_stmt|;
name|pt
operator|->
name|message
operator|=
name|cb
expr_stmt|;
name|pt
operator|->
name|nextmessage
operator|=
literal|0
expr_stmt|;
operator|*
name|nextmessage
operator|=
name|pt
expr_stmt|;
name|nextmessage
operator|=
operator|&
name|pt
operator|->
name|nextmessage
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|getstates
parameter_list|(
name|sp
parameter_list|)
name|char
modifier|*
name|sp
decl_stmt|;
comment|/*   Function:  get one state attribute and the corresponding   */
comment|/*              revision and store in statelst                  */
block|{
name|char
specifier|const
modifier|*
name|temp
decl_stmt|;
name|struct
name|Status
modifier|*
name|pt
decl_stmt|;
specifier|register
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|sp
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
continue|continue;
name|temp
operator|=
name|sp
expr_stmt|;
name|sp
operator|=
name|checkid
argument_list|(
name|sp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
comment|/* check for invalid state attribute */
name|c
operator|=
operator|*
name|sp
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
name|c
operator|=
operator|*
operator|++
name|sp
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/*  change state of def. branch or Head  */
name|chgheadstate
operator|=
name|true
expr_stmt|;
name|headstate
operator|=
name|temp
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|':'
condition|)
block|{
name|error
argument_list|(
literal|"missing ':' after state in option -s"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|sp
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
condition|)
continue|continue;
name|pt
operator|=
name|talloc
argument_list|(
expr|struct
name|Status
argument_list|)
expr_stmt|;
name|pt
operator|->
name|status
operator|=
name|temp
expr_stmt|;
name|pt
operator|->
name|revno
operator|=
name|sp
expr_stmt|;
name|pt
operator|->
name|nextstatus
operator|=
literal|0
expr_stmt|;
operator|*
name|nextstate
operator|=
name|pt
expr_stmt|;
name|nextstate
operator|=
operator|&
name|pt
operator|->
name|nextstatus
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|getdelrev
parameter_list|(
name|sp
parameter_list|)
name|char
modifier|*
name|sp
decl_stmt|;
comment|/*   Function:  get revision range or branch to be deleted,     */
comment|/*              and place in delrev                             */
block|{
name|int
name|c
decl_stmt|;
name|struct
name|delrevpair
modifier|*
name|pt
decl_stmt|;
name|int
name|separator
decl_stmt|;
name|pt
operator|=
operator|&
name|delrev
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|sp
operator|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
continue|continue;
comment|/* Support old ambiguous '-' syntax; this will go away.  */
if|if
condition|(
name|strchr
argument_list|(
name|sp
argument_list|,
literal|':'
argument_list|)
condition|)
name|separator
operator|=
literal|':'
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strchr
argument_list|(
name|sp
argument_list|,
literal|'-'
argument_list|)
operator|&&
name|VERSION
argument_list|(
literal|5
argument_list|)
operator|<=
name|RCSversion
condition|)
name|warn
argument_list|(
literal|"`-' is obsolete in `-o%s'; use `:' instead"
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|separator
operator|=
literal|'-'
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|separator
condition|)
block|{
comment|/* -o:rev */
while|while
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
operator|++
name|sp
operator|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
continue|continue;
name|pt
operator|->
name|strt
operator|=
name|sp
expr_stmt|;
name|pt
operator|->
name|code
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
name|c
operator|=
operator|(
operator|*
operator|++
name|sp
operator|)
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
name|pt
operator|->
name|end
operator|=
literal|0
expr_stmt|;
return|return;
block|}
else|else
block|{
name|pt
operator|->
name|strt
operator|=
name|sp
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
name|separator
condition|)
name|c
operator|=
operator|*
operator|++
name|sp
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
operator|*
operator|++
name|sp
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
comment|/*   -o rev or branch   */
name|pt
operator|->
name|code
operator|=
literal|0
expr_stmt|;
name|pt
operator|->
name|end
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c
operator|!=
name|separator
condition|)
block|{
name|error
argument_list|(
literal|"invalid range %s %s after -o"
argument_list|,
name|pt
operator|->
name|strt
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|sp
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\t'
condition|)
continue|continue;
if|if
condition|(
operator|!
name|c
condition|)
block|{
comment|/* -orev: */
name|pt
operator|->
name|code
operator|=
literal|2
expr_stmt|;
name|pt
operator|->
name|end
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
comment|/* -orev1:rev2 */
name|pt
operator|->
name|end
operator|=
name|sp
expr_stmt|;
name|pt
operator|->
name|code
operator|=
literal|3
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\0'
condition|)
name|c
operator|=
operator|*
operator|++
name|sp
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scanlogtext
parameter_list|(
name|delta
parameter_list|,
name|edit
parameter_list|)
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
name|int
name|edit
decl_stmt|;
comment|/* Function: Scans delta text nodes up to and including the one given  * by delta, or up to last one present, if !delta.  * For the one given by delta (if delta), the log message is saved into  * delta->log if delta==cuttail; the text is edited if EDIT is set, else copied.  * Assumes the initial lexeme must be read in first.  * Does not advance nexttok after it is finished, except if !delta.  */
block|{
name|struct
name|hshentry
specifier|const
modifier|*
name|nextdelta
decl_stmt|;
name|struct
name|cbuf
name|cb
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|foutptr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eoflex
argument_list|()
condition|)
block|{
if|if
condition|(
name|delta
condition|)
name|rcsfaterror
argument_list|(
literal|"can't find delta for revision %s"
argument_list|,
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
return|return;
comment|/* no more delta text nodes */
block|}
name|nextlex
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nextdelta
operator|=
name|getnum
argument_list|()
operator|)
condition|)
name|fatserror
argument_list|(
literal|"delta number corrupted"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextdelta
operator|->
name|selector
condition|)
block|{
name|foutptr
operator|=
name|frewrite
expr_stmt|;
name|aprintf
argument_list|(
name|frewrite
argument_list|,
name|DELNUMFORM
argument_list|,
name|nextdelta
operator|->
name|num
argument_list|,
name|Klog
argument_list|)
expr_stmt|;
block|}
name|getkeystring
argument_list|(
name|Klog
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextdelta
operator|==
name|cuttail
condition|)
block|{
name|cb
operator|=
name|savestring
argument_list|(
operator|&
name|curlogbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|delta
operator|->
name|log
operator|.
name|string
condition|)
name|delta
operator|->
name|log
operator|=
name|cleanlogmsg
argument_list|(
name|curlogbuf
operator|.
name|string
argument_list|,
name|cb
operator|.
name|size
argument_list|)
expr_stmt|;
name|nextlex
argument_list|()
expr_stmt|;
name|delta
operator|->
name|igtext
operator|=
name|getphrases
argument_list|(
name|Ktext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nextdelta
operator|->
name|log
operator|.
name|string
operator|&&
name|nextdelta
operator|->
name|selector
condition|)
block|{
name|foutptr
operator|=
literal|0
expr_stmt|;
name|readstring
argument_list|()
expr_stmt|;
name|foutptr
operator|=
name|frewrite
expr_stmt|;
name|putstring
argument_list|(
name|foutptr
argument_list|,
name|false
argument_list|,
name|nextdelta
operator|->
name|log
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|afputc
argument_list|(
name|nextc
argument_list|,
name|foutptr
argument_list|)
expr_stmt|;
block|}
else|else
name|readstring
argument_list|()
expr_stmt|;
name|ignorephrases
argument_list|(
name|Ktext
argument_list|)
expr_stmt|;
block|}
name|getkeystring
argument_list|(
name|Ktext
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|==
name|nextdelta
condition|)
break|break;
name|readstring
argument_list|()
expr_stmt|;
comment|/* skip over it */
block|}
comment|/* got the one we're looking for */
if|if
condition|(
name|edit
condition|)
name|editstring
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|enterstring
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|Lockrev
modifier|*
modifier|*
name|rmnewlocklst
parameter_list|(
name|which
parameter_list|)
name|char
specifier|const
modifier|*
name|which
decl_stmt|;
comment|/* Remove lock to revision WHICH from newlocklst.  */
block|{
name|struct
name|Lockrev
modifier|*
name|pt
decl_stmt|,
modifier|*
modifier|*
name|pre
decl_stmt|;
name|pre
operator|=
operator|&
name|newlocklst
expr_stmt|;
while|while
condition|(
operator|(
name|pt
operator|=
operator|*
name|pre
operator|)
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|pt
operator|->
name|revno
argument_list|,
name|which
argument_list|)
operator|!=
literal|0
condition|)
name|pre
operator|=
operator|&
name|pt
operator|->
name|nextrev
expr_stmt|;
else|else
block|{
operator|*
name|pre
operator|=
name|pt
operator|->
name|nextrev
expr_stmt|;
name|tfree
argument_list|(
name|pt
argument_list|)
expr_stmt|;
block|}
return|return
name|pre
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|doaccess
parameter_list|()
block|{
specifier|register
name|struct
name|chaccess
modifier|*
name|ch
decl_stmt|;
specifier|register
name|struct
name|access
modifier|*
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|changed
init|=
name|false
decl_stmt|;
for|for
control|(
name|ch
operator|=
name|chaccess
init|;
name|ch
condition|;
name|ch
operator|=
name|ch
operator|->
name|nextchaccess
control|)
block|{
switch|switch
condition|(
name|ch
operator|->
name|command
condition|)
block|{
case|case
name|erase
case|:
if|if
condition|(
operator|!
name|ch
operator|->
name|login
condition|)
block|{
if|if
condition|(
name|AccessList
condition|)
block|{
name|AccessList
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|p
operator|=
operator|&
name|AccessList
init|;
operator|(
name|t
operator|=
operator|*
name|p
operator|)
condition|;
name|p
operator|=
operator|&
name|t
operator|->
name|nextaccess
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|ch
operator|->
name|login
argument_list|,
name|t
operator|->
name|login
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|p
operator|=
name|t
operator|->
name|nextaccess
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|append
case|:
for|for
control|(
name|p
operator|=
operator|&
name|AccessList
init|;
condition|;
name|p
operator|=
operator|&
name|t
operator|->
name|nextaccess
control|)
if|if
condition|(
operator|!
operator|(
name|t
operator|=
operator|*
name|p
operator|)
condition|)
block|{
operator|*
name|p
operator|=
name|t
operator|=
name|ftalloc
argument_list|(
expr|struct
name|access
argument_list|)
expr_stmt|;
name|t
operator|->
name|login
operator|=
name|ch
operator|->
name|login
expr_stmt|;
name|t
operator|->
name|nextaccess
operator|=
literal|0
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ch
operator|->
name|login
argument_list|,
name|t
operator|->
name|login
argument_list|)
operator|==
literal|0
condition|)
break|break;
break|break;
block|}
block|}
return|return
name|changed
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sendmail
parameter_list|(
name|Delta
parameter_list|,
name|who
parameter_list|)
name|char
specifier|const
modifier|*
name|Delta
decl_stmt|,
decl|*
name|who
decl_stmt|;
end_function

begin_comment
comment|/*   Function:  mail to who, informing him that his lock on delta was  *   broken by caller. Ask first whether to go ahead. Return false on  *   error or if user decides not to break the lock.  */
end_comment

begin_block
block|{
ifdef|#
directive|ifdef
name|SENDMAIL
name|char
specifier|const
modifier|*
name|messagefile
decl_stmt|;
name|int
name|old1
decl_stmt|,
name|old2
decl_stmt|,
name|c
decl_stmt|,
name|status
decl_stmt|;
name|FILE
modifier|*
name|mailmess
decl_stmt|;
endif|#
directive|endif
name|aprintf
argument_list|(
name|stderr
argument_list|,
literal|"Revision %s is already locked by %s.\n"
argument_list|,
name|Delta
argument_list|,
name|who
argument_list|)
expr_stmt|;
if|if
condition|(
name|suppress_mail
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|!
name|yesorno
argument_list|(
name|false
argument_list|,
literal|"Do you want to break the lock? [ny](n): "
argument_list|)
condition|)
return|return
name|false
return|;
comment|/* go ahead with breaking  */
ifdef|#
directive|ifdef
name|SENDMAIL
name|messagefile
operator|=
name|maketemp
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mailmess
operator|=
name|fopenSafer
argument_list|(
name|messagefile
argument_list|,
literal|"w+"
argument_list|)
operator|)
condition|)
block|{
name|efaterror
argument_list|(
name|messagefile
argument_list|)
expr_stmt|;
block|}
name|aprintf
argument_list|(
name|mailmess
argument_list|,
literal|"Subject: Broken lock on %s\n\nYour lock on revision %s of file %s\nhas been broken by %s for the following reason:\n"
argument_list|,
name|basefilename
argument_list|(
name|RCSname
argument_list|)
argument_list|,
name|Delta
argument_list|,
name|getfullRCSname
argument_list|()
argument_list|,
name|getcaller
argument_list|()
argument_list|)
expr_stmt|;
name|aputs
argument_list|(
literal|"State the reason for breaking the lock:\n(terminate with single '.' or end of file)\n>> "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|eflush
argument_list|()
expr_stmt|;
name|old1
operator|=
literal|'\n'
expr_stmt|;
name|old2
operator|=
literal|' '
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getcstdin
argument_list|()
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
name|aprintf
argument_list|(
name|mailmess
argument_list|,
literal|"%c\n"
argument_list|,
name|old1
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|old1
operator|==
literal|'.'
operator|&&
name|old2
operator|==
literal|'\n'
condition|)
break|break;
else|else
block|{
name|afputc
argument_list|(
name|old1
argument_list|,
name|mailmess
argument_list|)
expr_stmt|;
name|old2
operator|=
name|old1
expr_stmt|;
name|old1
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|aputs
argument_list|(
literal|">> "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|eflush
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|Orewind
argument_list|(
name|mailmess
argument_list|)
expr_stmt|;
name|aflush
argument_list|(
name|mailmess
argument_list|)
expr_stmt|;
name|status
operator|=
name|run
argument_list|(
name|fileno
argument_list|(
name|mailmess
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|SENDMAIL
argument_list|,
name|who
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|Ozclose
argument_list|(
operator|&
name|mailmess
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
return|return
name|true
return|;
name|warn
argument_list|(
literal|"Mail failed."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|warn
argument_list|(
literal|"Mail notification of broken locks is not available."
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"Please tell `%s' why you broke the lock."
argument_list|,
name|who
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|breaklock
parameter_list|(
name|delta
parameter_list|)
name|struct
name|hshentry
specifier|const
modifier|*
name|delta
decl_stmt|;
comment|/* function: Finds the lock held by caller on delta,  * and removes it.  * Sends mail if a lock different from the caller's is broken.  * Prints an error message if there is no such lock or error.  */
block|{
specifier|register
name|struct
name|rcslock
modifier|*
name|next
decl_stmt|,
modifier|*
modifier|*
name|trail
decl_stmt|;
name|char
specifier|const
modifier|*
name|num
decl_stmt|;
name|num
operator|=
name|delta
operator|->
name|num
expr_stmt|;
for|for
control|(
name|trail
operator|=
operator|&
name|Locks
init|;
operator|(
name|next
operator|=
operator|*
name|trail
operator|)
condition|;
name|trail
operator|=
operator|&
name|next
operator|->
name|nextlock
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|num
argument_list|,
name|next
operator|->
name|delta
operator|->
name|num
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|getcaller
argument_list|()
argument_list|,
name|next
operator|->
name|login
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|sendmail
argument_list|(
name|num
argument_list|,
name|next
operator|->
name|login
argument_list|)
condition|)
block|{
name|rcserror
argument_list|(
literal|"revision %s still locked by %s"
argument_list|,
name|num
argument_list|,
name|next
operator|->
name|login
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|diagnose
argument_list|(
literal|"%s unlocked\n"
argument_list|,
name|next
operator|->
name|delta
operator|->
name|num
argument_list|)
expr_stmt|;
operator|*
name|trail
operator|=
name|next
operator|->
name|nextlock
expr_stmt|;
name|next
operator|->
name|delta
operator|->
name|lockedby
operator|=
literal|0
expr_stmt|;
return|return
name|true
return|;
block|}
name|rcserror
argument_list|(
literal|"no lock set on revision %s"
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|hshentry
modifier|*
name|searchcutpt
parameter_list|(
name|object
parameter_list|,
name|length
parameter_list|,
name|store
parameter_list|)
name|char
specifier|const
modifier|*
name|object
decl_stmt|;
name|int
name|length
decl_stmt|;
name|struct
name|hshentries
modifier|*
name|store
decl_stmt|;
comment|/*   Function:  Search store and return entry with number being object. */
comment|/*		cuttail = 0, if the entry is Head; otherwise, cuttail   */
comment|/*              is the entry point to the one with number being object  */
block|{
name|cuthead
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|compartial
argument_list|(
name|store
operator|->
name|first
operator|->
name|num
argument_list|,
name|object
argument_list|,
name|length
argument_list|)
condition|)
block|{
name|cuthead
operator|=
name|store
operator|->
name|first
expr_stmt|;
name|store
operator|=
name|store
operator|->
name|rest
expr_stmt|;
block|}
return|return
name|store
operator|->
name|first
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|branchpoint
parameter_list|(
name|strt
parameter_list|,
name|tail
parameter_list|)
name|struct
name|hshentry
modifier|*
name|strt
decl_stmt|,
decl|*
name|tail
decl_stmt|;
end_function

begin_comment
comment|/*   Function: check whether the deltas between strt and tail	*/
end_comment

begin_comment
comment|/*		are locked or branch point, return 1 if any is  */
end_comment

begin_comment
comment|/*		locked or branch point; otherwise, return 0 and */
end_comment

begin_comment
comment|/*		mark deleted					*/
end_comment

begin_block
block|{
name|struct
name|hshentry
modifier|*
name|pt
decl_stmt|;
name|struct
name|rcslock
specifier|const
modifier|*
name|lockpt
decl_stmt|;
for|for
control|(
name|pt
operator|=
name|strt
init|;
name|pt
operator|!=
name|tail
condition|;
name|pt
operator|=
name|pt
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pt
operator|->
name|branches
condition|)
block|{
comment|/*  a branch point  */
name|rcserror
argument_list|(
literal|"can't remove branch point %s"
argument_list|,
name|pt
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
for|for
control|(
name|lockpt
operator|=
name|Locks
init|;
name|lockpt
condition|;
name|lockpt
operator|=
name|lockpt
operator|->
name|nextlock
control|)
if|if
condition|(
name|lockpt
operator|->
name|delta
operator|==
name|pt
condition|)
block|{
name|rcserror
argument_list|(
literal|"can't remove locked revision %s"
argument_list|,
name|pt
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|pt
operator|->
name|selector
operator|=
name|false
expr_stmt|;
name|diagnose
argument_list|(
literal|"deleting revision %s\n"
argument_list|,
name|pt
operator|->
name|num
argument_list|)
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|removerevs
parameter_list|()
comment|/*   Function:  get the revision range to be removed, and place the     */
comment|/*              first revision removed in delstrt, the revision before  */
comment|/*		delstrt in cuthead (0, if delstrt is head), and the	*/
comment|/*		revision after the last removed revision in cuttail (0	*/
comment|/*              if the last is a leaf                                   */
block|{
name|struct
name|hshentry
modifier|*
name|target
decl_stmt|,
modifier|*
name|target2
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|cmp
decl_stmt|;
if|if
condition|(
operator|!
name|expandsym
argument_list|(
name|delrev
operator|.
name|strt
argument_list|,
operator|&
name|numrev
argument_list|)
condition|)
return|return
literal|0
return|;
name|target
operator|=
name|genrevs
argument_list|(
name|numrev
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|gendeltas
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
return|return
literal|0
return|;
name|cmp
operator|=
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|numrev
operator|.
name|string
argument_list|)
expr_stmt|;
name|length
operator|=
name|countnumflds
argument_list|(
name|numrev
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|delrev
operator|.
name|code
operator|==
literal|0
condition|)
block|{
comment|/*  -o  rev    or    -o  branch   */
if|if
condition|(
name|length
operator|&
literal|1
condition|)
name|temp
operator|=
name|searchcutpt
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|length
operator|+
literal|1
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cmp
condition|)
block|{
name|rcserror
argument_list|(
literal|"Revision %s doesn't exist."
argument_list|,
name|numrev
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|temp
operator|=
name|searchcutpt
argument_list|(
name|numrev
operator|.
name|string
argument_list|,
name|length
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
name|cuttail
operator|=
name|target
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|branchpoint
argument_list|(
name|temp
argument_list|,
name|cuttail
argument_list|)
condition|)
block|{
name|cuttail
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|delstrt
operator|=
name|temp
expr_stmt|;
comment|/* first revision to be removed   */
return|return
literal|1
return|;
block|}
if|if
condition|(
name|length
operator|&
literal|1
condition|)
block|{
comment|/*  invalid branch after -o   */
name|rcserror
argument_list|(
literal|"invalid branch range %s after -o"
argument_list|,
name|numrev
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|delrev
operator|.
name|code
operator|==
literal|1
condition|)
block|{
comment|/*  -o  -rev   */
if|if
condition|(
name|length
operator|>
literal|2
condition|)
block|{
name|temp
operator|=
name|searchcutpt
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|length
operator|-
literal|1
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
name|cuttail
operator|=
name|target
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|temp
operator|=
name|searchcutpt
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|length
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
name|cuttail
operator|=
name|target
expr_stmt|;
while|while
condition|(
name|cuttail
operator|&&
operator|!
name|cmpnumfld
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|cuttail
operator|->
name|num
argument_list|,
literal|1
argument_list|)
condition|)
name|cuttail
operator|=
name|cuttail
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|branchpoint
argument_list|(
name|temp
argument_list|,
name|cuttail
argument_list|)
condition|)
block|{
name|cuttail
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|delstrt
operator|=
name|temp
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|delrev
operator|.
name|code
operator|==
literal|2
condition|)
block|{
comment|/*  -o  rev-   */
if|if
condition|(
name|length
operator|==
literal|2
condition|)
block|{
name|temp
operator|=
name|searchcutpt
argument_list|(
name|target
operator|->
name|num
argument_list|,
literal|1
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
condition|)
name|cuttail
operator|=
name|target
expr_stmt|;
else|else
name|cuttail
operator|=
name|target
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cmp
condition|)
block|{
name|cuthead
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|temp
operator|=
name|target
operator|->
name|next
operator|)
condition|)
return|return
literal|0
return|;
block|}
else|else
name|temp
operator|=
name|searchcutpt
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|length
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
name|getbranchno
argument_list|(
name|temp
operator|->
name|num
argument_list|,
operator|&
name|numrev
argument_list|)
expr_stmt|;
comment|/* get branch number */
name|VOID
name|genrevs
argument_list|(
name|numrev
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|gendeltas
argument_list|)
decl_stmt|;
block|}
if|if
condition|(
name|branchpoint
argument_list|(
name|temp
argument_list|,
name|cuttail
argument_list|)
condition|)
block|{
name|cuttail
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|delstrt
operator|=
name|temp
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*   -o   rev1-rev2   */
if|if
condition|(
operator|!
name|expandsym
argument_list|(
name|delrev
operator|.
name|end
argument_list|,
operator|&
name|numrev
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|length
operator|!=
name|countnumflds
argument_list|(
name|numrev
operator|.
name|string
argument_list|)
operator|||
operator|(
name|length
operator|>
literal|2
operator|&&
name|compartial
argument_list|(
name|numrev
operator|.
name|string
argument_list|,
name|target
operator|->
name|num
argument_list|,
name|length
operator|-
literal|1
argument_list|)
operator|)
condition|)
block|{
name|rcserror
argument_list|(
literal|"invalid revision range %s-%s"
argument_list|,
name|target
operator|->
name|num
argument_list|,
name|numrev
operator|.
name|string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|target2
operator|=
name|genrevs
argument_list|(
name|numrev
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|gendeltas
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target2
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|length
operator|>
literal|2
condition|)
block|{
comment|/* delete revisions on branches  */
if|if
condition|(
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|target2
operator|->
name|num
argument_list|)
operator|>
literal|0
condition|)
block|{
name|cmp
operator|=
name|cmpnum
argument_list|(
name|target2
operator|->
name|num
argument_list|,
name|numrev
operator|.
name|string
argument_list|)
expr_stmt|;
name|temp
operator|=
name|target
expr_stmt|;
name|target
operator|=
name|target2
expr_stmt|;
name|target2
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|cmp
condition|)
block|{
if|if
condition|(
operator|!
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|target2
operator|->
name|num
argument_list|)
condition|)
block|{
name|rcserror
argument_list|(
literal|"Revisions %s-%s don't exist."
argument_list|,
name|delrev
operator|.
name|strt
argument_list|,
name|delrev
operator|.
name|end
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cuthead
operator|=
name|target
expr_stmt|;
name|temp
operator|=
name|target
operator|->
name|next
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|searchcutpt
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|length
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
name|cuttail
operator|=
name|target2
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
comment|/*  delete revisions on trunk  */
if|if
condition|(
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|target2
operator|->
name|num
argument_list|)
operator|<
literal|0
condition|)
block|{
name|temp
operator|=
name|target
expr_stmt|;
name|target
operator|=
name|target2
expr_stmt|;
name|target2
operator|=
name|temp
expr_stmt|;
block|}
else|else
name|cmp
operator|=
name|cmpnum
argument_list|(
name|target2
operator|->
name|num
argument_list|,
name|numrev
operator|.
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
condition|)
block|{
if|if
condition|(
operator|!
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|target2
operator|->
name|num
argument_list|)
condition|)
block|{
name|rcserror
argument_list|(
literal|"Revisions %s-%s don't exist."
argument_list|,
name|delrev
operator|.
name|strt
argument_list|,
name|delrev
operator|.
name|end
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cuttail
operator|=
name|target2
expr_stmt|;
block|}
else|else
name|cuttail
operator|=
name|target2
operator|->
name|next
expr_stmt|;
name|temp
operator|=
name|searchcutpt
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|length
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|branchpoint
argument_list|(
name|temp
argument_list|,
name|cuttail
argument_list|)
condition|)
block|{
name|cuttail
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|delstrt
operator|=
name|temp
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|doassoc
parameter_list|()
comment|/* Add or delete (if !revno) association that is stored in assoclst.  */
block|{
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
name|int
name|changed
init|=
name|false
decl_stmt|;
name|struct
name|Symrev
specifier|const
modifier|*
name|curassoc
decl_stmt|;
name|struct
name|assoc
modifier|*
modifier|*
name|pre
decl_stmt|,
modifier|*
name|pt
decl_stmt|;
comment|/*  add new associations   */
for|for
control|(
name|curassoc
operator|=
name|assoclst
init|;
name|curassoc
condition|;
name|curassoc
operator|=
name|curassoc
operator|->
name|nextsym
control|)
block|{
name|char
specifier|const
modifier|*
name|ssymbol
init|=
name|curassoc
operator|->
name|ssymbol
decl_stmt|;
if|if
condition|(
operator|!
name|curassoc
operator|->
name|revno
condition|)
block|{
comment|/* delete symbol  */
for|for
control|(
name|pre
operator|=
operator|&
name|Symbols
init|;
condition|;
name|pre
operator|=
operator|&
name|pt
operator|->
name|nextassoc
control|)
if|if
condition|(
operator|!
operator|(
name|pt
operator|=
operator|*
name|pre
operator|)
condition|)
block|{
name|rcswarn
argument_list|(
literal|"can't delete nonexisting symbol %s"
argument_list|,
name|ssymbol
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|pt
operator|->
name|symbol
argument_list|,
name|ssymbol
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|pre
operator|=
name|pt
operator|->
name|nextassoc
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|curassoc
operator|->
name|revno
index|[
literal|0
index|]
condition|)
block|{
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expandsym
argument_list|(
name|curassoc
operator|->
name|revno
argument_list|,
operator|&
name|numrev
argument_list|)
condition|)
name|p
operator|=
name|fstr_save
argument_list|(
name|numrev
operator|.
name|string
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|tiprev
argument_list|()
operator|)
condition|)
name|rcserror
argument_list|(
literal|"no latest revision to associate with symbol %s"
argument_list|,
name|ssymbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|changed
operator||=
name|addsymbol
argument_list|(
name|p
argument_list|,
name|ssymbol
argument_list|,
name|curassoc
operator|->
name|override
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|changed
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dolocks
parameter_list|()
comment|/* Function: remove lock for caller or first lock if unlockcaller is set;  *           remove locks which are stored in rmvlocklst,  *           add new locks which are stored in newlocklst,  *           add lock for Dbranch or Head if lockhead is set.  */
block|{
name|struct
name|Lockrev
specifier|const
modifier|*
name|lockpt
decl_stmt|;
name|struct
name|hshentry
modifier|*
name|target
decl_stmt|;
name|int
name|changed
init|=
name|false
decl_stmt|;
if|if
condition|(
name|unlockcaller
condition|)
block|{
comment|/*  find lock for caller  */
if|if
condition|(
name|Head
condition|)
block|{
if|if
condition|(
name|Locks
condition|)
block|{
switch|switch
condition|(
name|findlock
argument_list|(
name|true
argument_list|,
operator|&
name|target
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* remove most recent lock */
name|changed
operator||=
name|breaklock
argument_list|(
name|Locks
operator|->
name|delta
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|diagnose
argument_list|(
literal|"%s unlocked\n"
argument_list|,
name|target
operator|->
name|num
argument_list|)
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|rcswarn
argument_list|(
literal|"No locks are set."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rcswarn
argument_list|(
literal|"can't unlock an empty tree"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  remove locks which are stored in rmvlocklst   */
for|for
control|(
name|lockpt
operator|=
name|rmvlocklst
init|;
name|lockpt
condition|;
name|lockpt
operator|=
name|lockpt
operator|->
name|nextrev
control|)
if|if
condition|(
name|expandsym
argument_list|(
name|lockpt
operator|->
name|revno
argument_list|,
operator|&
name|numrev
argument_list|)
condition|)
block|{
name|target
operator|=
name|genrevs
argument_list|(
name|numrev
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|gendeltas
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
if|if
condition|(
operator|!
operator|(
name|countnumflds
argument_list|(
name|numrev
operator|.
name|string
argument_list|)
operator|&
literal|1
operator|)
operator|&&
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|numrev
operator|.
name|string
argument_list|)
condition|)
name|rcserror
argument_list|(
literal|"can't unlock nonexisting revision %s"
argument_list|,
name|lockpt
operator|->
name|revno
argument_list|)
expr_stmt|;
else|else
name|changed
operator||=
name|breaklock
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|/* breaklock does its own diagnose */
block|}
comment|/*  add new locks which stored in newlocklst  */
for|for
control|(
name|lockpt
operator|=
name|newlocklst
init|;
name|lockpt
condition|;
name|lockpt
operator|=
name|lockpt
operator|->
name|nextrev
control|)
name|changed
operator||=
name|setlock
argument_list|(
name|lockpt
operator|->
name|revno
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockhead
condition|)
comment|/*  lock default branch or head  */
if|if
condition|(
name|Dbranch
condition|)
name|changed
operator||=
name|setlock
argument_list|(
name|Dbranch
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|Head
condition|)
name|changed
operator||=
name|setlock
argument_list|(
name|Head
operator|->
name|num
argument_list|)
expr_stmt|;
else|else
name|rcswarn
argument_list|(
literal|"can't lock an empty tree"
argument_list|)
expr_stmt|;
return|return
name|changed
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setlock
parameter_list|(
name|rev
parameter_list|)
name|char
specifier|const
modifier|*
name|rev
decl_stmt|;
comment|/* Function: Given a revision or branch number, finds the corresponding  * delta and locks it for caller.  */
block|{
name|struct
name|hshentry
modifier|*
name|target
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|expandsym
argument_list|(
name|rev
argument_list|,
operator|&
name|numrev
argument_list|)
condition|)
block|{
name|target
operator|=
name|genrevs
argument_list|(
name|numrev
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|gendeltas
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
if|if
condition|(
operator|!
operator|(
name|countnumflds
argument_list|(
name|numrev
operator|.
name|string
argument_list|)
operator|&
literal|1
operator|)
operator|&&
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|numrev
operator|.
name|string
argument_list|)
condition|)
name|rcserror
argument_list|(
literal|"can't lock nonexisting revision %s"
argument_list|,
name|numrev
operator|.
name|string
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|r
operator|=
name|addlock
argument_list|(
name|target
argument_list|,
name|false
argument_list|)
operator|)
operator|<
literal|0
operator|&&
name|breaklock
argument_list|(
name|target
argument_list|)
condition|)
name|r
operator|=
name|addlock
argument_list|(
name|target
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|r
condition|)
block|{
if|if
condition|(
name|r
condition|)
name|diagnose
argument_list|(
literal|"%s locked\n"
argument_list|,
name|target
operator|->
name|num
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|domessages
parameter_list|()
block|{
name|struct
name|hshentry
modifier|*
name|target
decl_stmt|;
name|struct
name|Message
modifier|*
name|p
decl_stmt|;
name|int
name|changed
init|=
name|false
decl_stmt|;
for|for
control|(
name|p
operator|=
name|messagelst
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextmessage
control|)
if|if
condition|(
name|expandsym
argument_list|(
name|p
operator|->
name|revno
argument_list|,
operator|&
name|numrev
argument_list|)
operator|&&
operator|(
name|target
operator|=
name|genrevs
argument_list|(
name|numrev
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|gendeltas
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * We can't check the old log -- it's much later in the file. 		 * We pessimistically assume that it changed. 		 */
name|target
operator|->
name|log
operator|=
name|p
operator|->
name|message
expr_stmt|;
name|changed
operator|=
name|true
expr_stmt|;
block|}
return|return
name|changed
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rcs_setstate
parameter_list|(
name|rev
parameter_list|,
name|status
parameter_list|)
name|char
specifier|const
modifier|*
name|rev
decl_stmt|,
decl|*
name|status
decl_stmt|;
end_function

begin_comment
comment|/* Function: Given a revision or branch number, finds the corresponding delta  * and sets its state to status.  */
end_comment

begin_block
block|{
name|struct
name|hshentry
modifier|*
name|target
decl_stmt|;
if|if
condition|(
name|expandsym
argument_list|(
name|rev
argument_list|,
operator|&
name|numrev
argument_list|)
condition|)
block|{
name|target
operator|=
name|genrevs
argument_list|(
name|numrev
operator|.
name|string
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|gendeltas
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
condition|)
if|if
condition|(
operator|!
operator|(
name|countnumflds
argument_list|(
name|numrev
operator|.
name|string
argument_list|)
operator|&
literal|1
operator|)
operator|&&
name|cmpnum
argument_list|(
name|target
operator|->
name|num
argument_list|,
name|numrev
operator|.
name|string
argument_list|)
condition|)
name|rcserror
argument_list|(
literal|"can't set state of nonexisting revision %s"
argument_list|,
name|numrev
operator|.
name|string
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|target
operator|->
name|state
argument_list|,
name|status
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|target
operator|->
name|state
operator|=
name|status
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|false
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|buildeltatext
parameter_list|(
name|deltas
parameter_list|)
name|struct
name|hshentries
specifier|const
modifier|*
name|deltas
decl_stmt|;
comment|/*   Function:  put the delta text on frewrite and make necessary   */
comment|/*              change to delta text                                */
block|{
specifier|register
name|FILE
modifier|*
name|fcut
decl_stmt|;
comment|/* temporary file to rebuild delta tree */
name|char
specifier|const
modifier|*
name|cutname
decl_stmt|;
name|fcut
operator|=
literal|0
expr_stmt|;
name|cuttail
operator|->
name|selector
operator|=
name|false
expr_stmt|;
name|scanlogtext
argument_list|(
name|deltas
operator|->
name|first
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|cuthead
condition|)
block|{
name|cutname
operator|=
name|maketemp
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fcut
operator|=
name|fopenSafer
argument_list|(
name|cutname
argument_list|,
name|FOPEN_WPLUS_WORK
argument_list|)
operator|)
condition|)
block|{
name|efaterror
argument_list|(
name|cutname
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|deltas
operator|->
name|first
operator|!=
name|cuthead
condition|)
block|{
name|deltas
operator|=
name|deltas
operator|->
name|rest
expr_stmt|;
name|scanlogtext
argument_list|(
name|deltas
operator|->
name|first
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|snapshotedit
argument_list|(
name|fcut
argument_list|)
expr_stmt|;
name|Orewind
argument_list|(
name|fcut
argument_list|)
expr_stmt|;
name|aflush
argument_list|(
name|fcut
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|deltas
operator|->
name|first
operator|!=
name|cuttail
condition|)
name|scanlogtext
argument_list|(
operator|(
name|deltas
operator|=
name|deltas
operator|->
name|rest
operator|)
operator|->
name|first
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|finishedit
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|Ozclose
argument_list|(
operator|&
name|fcopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcut
condition|)
block|{
name|char
specifier|const
modifier|*
name|diffname
init|=
name|maketemp
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|char
specifier|const
modifier|*
name|diffv
index|[
literal|6
operator|+
operator|!
operator|!
name|OPEN_O_BINARY
index|]
decl_stmt|;
name|char
specifier|const
modifier|*
modifier|*
name|diffp
init|=
name|diffv
decl_stmt|;
operator|*
operator|++
name|diffp
operator|=
name|DIFF
expr_stmt|;
operator|*
operator|++
name|diffp
operator|=
name|DIFFFLAGS
expr_stmt|;
if|#
directive|if
name|OPEN_O_BINARY
if|if
condition|(
name|Expand
operator|==
name|BINARY_EXPAND
condition|)
operator|*
operator|++
name|diffp
operator|==
literal|"--binary"
expr_stmt|;
endif|#
directive|endif
operator|*
operator|++
name|diffp
operator|=
literal|"-"
expr_stmt|;
operator|*
operator|++
name|diffp
operator|=
name|resultname
expr_stmt|;
operator|*
operator|++
name|diffp
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|runv
argument_list|(
name|fileno
argument_list|(
name|fcut
argument_list|)
argument_list|,
name|diffname
argument_list|,
name|diffv
argument_list|)
condition|)
block|{
case|case
name|DIFF_FAILURE
case|:
case|case
name|DIFF_SUCCESS
case|:
break|break;
default|default:
name|rcsfaterror
argument_list|(
literal|"diff failed"
argument_list|)
expr_stmt|;
block|}
name|Ofclose
argument_list|(
name|fcut
argument_list|)
expr_stmt|;
return|return
name|putdtext
argument_list|(
name|cuttail
argument_list|,
name|diffname
argument_list|,
name|frewrite
argument_list|,
name|true
argument_list|)
return|;
block|}
else|else
return|return
name|putdtext
argument_list|(
name|cuttail
argument_list|,
name|resultname
argument_list|,
name|frewrite
argument_list|,
name|false
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|buildtree
parameter_list|()
comment|/*   Function:  actually removes revisions whose selector field  */
comment|/*		is false, and rebuilds the linkage of deltas.	 */
comment|/*              asks for reconfirmation if deleting last revision*/
block|{
name|struct
name|hshentry
modifier|*
name|Delta
decl_stmt|;
name|struct
name|branchhead
modifier|*
name|pt
decl_stmt|,
modifier|*
name|pre
decl_stmt|;
if|if
condition|(
name|cuthead
condition|)
if|if
condition|(
name|cuthead
operator|->
name|next
operator|==
name|delstrt
condition|)
name|cuthead
operator|->
name|next
operator|=
name|cuttail
expr_stmt|;
else|else
block|{
name|pre
operator|=
name|pt
operator|=
name|cuthead
operator|->
name|branches
expr_stmt|;
while|while
condition|(
name|pt
operator|&&
name|pt
operator|->
name|hsh
operator|!=
name|delstrt
condition|)
block|{
name|pre
operator|=
name|pt
expr_stmt|;
name|pt
operator|=
name|pt
operator|->
name|nextbranch
expr_stmt|;
block|}
if|if
condition|(
name|cuttail
condition|)
name|pt
operator|->
name|hsh
operator|=
name|cuttail
expr_stmt|;
elseif|else
if|if
condition|(
name|pt
operator|==
name|pre
condition|)
name|cuthead
operator|->
name|branches
operator|=
name|pt
operator|->
name|nextbranch
expr_stmt|;
else|else
name|pre
operator|->
name|nextbranch
operator|=
name|pt
operator|->
name|nextbranch
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|cuttail
operator|&&
operator|!
name|quietflag
condition|)
block|{
if|if
condition|(
operator|!
name|yesorno
argument_list|(
name|false
argument_list|,
literal|"Do you really want to delete all revisions? [ny](n): "
argument_list|)
condition|)
block|{
name|rcserror
argument_list|(
literal|"No revision deleted"
argument_list|)
expr_stmt|;
name|Delta
operator|=
name|delstrt
expr_stmt|;
while|while
condition|(
name|Delta
condition|)
block|{
name|Delta
operator|->
name|selector
operator|=
name|true
expr_stmt|;
name|Delta
operator|=
name|Delta
operator|->
name|next
expr_stmt|;
block|}
return|return;
block|}
block|}
name|Head
operator|=
name|cuttail
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|RCS_lint
end_if

begin_comment
comment|/* This lets us lint everything all at once. */
end_comment

begin_decl_stmt
name|char
specifier|const
name|cmdid
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|go
parameter_list|(
name|p
parameter_list|,
name|e
parameter_list|)
value|{int p P((int,char**)); void e P((void)); if(*argv)return p(argc,argv);if(*argv[1])e();}
end_define

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|go
argument_list|(
name|ciId
argument_list|,
name|ciExit
argument_list|)
expr_stmt|;
name|go
argument_list|(
name|coId
argument_list|,
name|coExit
argument_list|)
expr_stmt|;
name|go
argument_list|(
name|identId
argument_list|,
name|identExit
argument_list|)
expr_stmt|;
name|go
argument_list|(
name|mergeId
argument_list|,
name|mergeExit
argument_list|)
expr_stmt|;
name|go
argument_list|(
name|rcsId
argument_list|,
name|exiterr
argument_list|)
expr_stmt|;
name|go
argument_list|(
name|rcscleanId
argument_list|,
name|rcscleanExit
argument_list|)
expr_stmt|;
name|go
argument_list|(
name|rcsdiffId
argument_list|,
name|rdiffExit
argument_list|)
expr_stmt|;
name|go
argument_list|(
name|rcsmergeId
argument_list|,
name|rmergeExit
argument_list|)
expr_stmt|;
name|go
argument_list|(
name|rlogId
argument_list|,
name|rlogExit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

