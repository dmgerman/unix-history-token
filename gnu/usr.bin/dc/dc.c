begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * `dc' desk calculator utility.  *  * Copyright (C) 1984, 1993 Free Software Foundation, Inc.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2, or (at your option)  * any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, you can either send email to this  * program's author (see below) or write to: The Free Software Foundation,  * Inc.; 675 Mass Ave. Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"decimal.h"
end_include

begin_comment
comment|/* definitions for our decimal arithmetic package */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|open_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file now open */
end_comment

begin_decl_stmt
name|int
name|file_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of input files not yet opened */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|next_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to vector of names of input files left */
end_comment

begin_struct
struct|struct
name|regstack
block|{
name|decimal
name|value
decl_stmt|;
comment|/* Saved value of register */
name|struct
name|regstack
modifier|*
name|rest
decl_stmt|;
comment|/* Tail of list */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|regstack
modifier|*
name|regstack
typedef|;
end_typedef

begin_decl_stmt
name|regstack
name|freeregstacks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chain of free regstack structures for fast realloc */
end_comment

begin_decl_stmt
name|decimal
name|regs
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "registers", with single-character names */
end_comment

begin_decl_stmt
name|regstack
name|regstacks
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For each register, a stack of previous values */
end_comment

begin_decl_stmt
name|int
name|stacktop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index of last used element in stack */
end_comment

begin_decl_stmt
name|int
name|stacksize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current allocates size of stack */
end_comment

begin_decl_stmt
name|decimal
modifier|*
name|stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to computation stack */
end_comment

begin_comment
comment|/* A decimal number can be regarded as a string by  treating its contents as characters and ignoring the  position of its decimal point.  Decimal numbers are marked as strings by having an `after' field of -1  One use of strings is to execute them as macros. */
end_comment

begin_define
define|#
directive|define
name|STRING
value|-1
end_define

begin_decl_stmt
name|int
name|macrolevel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current macro nesting; 0 if taking keyboard input */
end_comment

begin_decl_stmt
name|int
name|macrostacksize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current allocated size of macrostack and macroindex */
end_comment

begin_decl_stmt
name|decimal
modifier|*
name|macrostack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to macro stack array */
end_comment

begin_decl_stmt
name|int
modifier|*
name|macroindex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to index-within-macro stack array */
end_comment

begin_comment
comment|/* Note that an empty macro is popped from the stack 	   only when an trying to read a character from it 	   or trying to push another macro.  */
end_comment

begin_decl_stmt
name|int
name|ibase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Radix for numeric input.  */
end_comment

begin_decl_stmt
name|int
name|obase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Radix for numeric output.  */
end_comment

begin_decl_stmt
name|int
name|precision
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of digits to keep in multiply and divide.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address of buffer used for reading numbers */
end_comment

begin_decl_stmt
name|int
name|bufsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current size of buffer (made bigger when nec) */
end_comment

begin_function_decl
name|decimal
name|dec_read
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|regstack
name|get_regstack
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|fetch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|fgetchar
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|concat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pushsqrt
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|condop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|setibase
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|setobase
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|setprecision
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pushmacro
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|decimal
name|read_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pushlength
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pushscale
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|unfetch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|popmacros
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|popmacro
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|popstack
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_obj
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|free_regstack
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pushreg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|execute
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fputchar
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|push
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|incref
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|decref
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|binop
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|env
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
decl|*
modifier|*
name|env
decl_stmt|;
end_function

begin_block
block|{
name|ibase
operator|=
literal|10
expr_stmt|;
name|obase
operator|=
literal|10
expr_stmt|;
name|precision
operator|=
literal|0
expr_stmt|;
name|freeregstacks
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|regs
argument_list|,
sizeof|sizeof
name|regs
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|regstacks
argument_list|,
sizeof|sizeof
name|regstacks
argument_list|)
expr_stmt|;
name|bufsize
operator|=
literal|40
expr_stmt|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|40
argument_list|)
expr_stmt|;
name|stacksize
operator|=
literal|40
expr_stmt|;
name|stack
operator|=
operator|(
name|decimal
operator|*
operator|)
name|xmalloc
argument_list|(
name|stacksize
operator|*
sizeof|sizeof
argument_list|(
name|decimal
argument_list|)
argument_list|)
expr_stmt|;
name|stacktop
operator|=
operator|-
literal|1
expr_stmt|;
name|macrostacksize
operator|=
literal|40
expr_stmt|;
name|macrostack
operator|=
operator|(
name|decimal
operator|*
operator|)
name|xmalloc
argument_list|(
name|macrostacksize
operator|*
sizeof|sizeof
argument_list|(
name|decimal
argument_list|)
argument_list|)
expr_stmt|;
name|macroindex
operator|=
operator|(
name|int
operator|*
operator|)
name|xmalloc
argument_list|(
name|macrostacksize
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|macrolevel
operator|=
literal|0
expr_stmt|;
comment|/* Initialize for reading input files if any */
name|open_file
operator|=
literal|0
expr_stmt|;
name|file_count
operator|=
name|argc
operator|-
literal|1
expr_stmt|;
name|next_file
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|execute
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Read and execute one command from the current source of input */
end_comment

begin_function
name|void
name|execute
parameter_list|()
block|{
name|int
name|c
init|=
name|fetch
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'+'
case|:
comment|/* Arithmetic operators... */
name|binop
argument_list|(
name|decimal_add
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|binop
argument_list|(
name|decimal_sub
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|binop
argument_list|(
name|decimal_mul_dc
argument_list|)
expr_stmt|;
comment|/* Like decimal_mul but hairy 				      way of deciding precision to keep */
break|break;
case|case
literal|'/'
case|:
name|binop
argument_list|(
name|decimal_div
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|binop
argument_list|(
name|decimal_rem
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|binop
argument_list|(
name|decimal_expt
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
comment|/* Begin a negative decimal constant */
block|{
name|decimal
name|tem
init|=
name|dec_read
argument_list|(
name|stdin
argument_list|)
decl_stmt|;
name|tem
operator|->
name|sign
operator|=
operator|!
name|tem
operator|->
name|sign
expr_stmt|;
name|push
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'.'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* All these begin decimal constants */
name|unfetch
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|dec_read
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
name|unfetch
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|dec_read
argument_list|(
name|stdin
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Clear the stack */
while|while
condition|(
name|stacktop
operator|>=
literal|0
condition|)
name|decref
argument_list|(
name|stack
index|[
name|stacktop
operator|--
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* Duplicate top of stack */
if|if
condition|(
name|stacktop
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"stack empty"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|push
argument_list|(
name|stack
index|[
name|stacktop
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Describe all registers and stack contents */
block|{
name|int
name|regno
decl_stmt|;
name|int
name|somereg
init|=
literal|0
decl_stmt|;
comment|/* set to 1 if we print any registers */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|128
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|regs
index|[
name|regno
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"register %c: "
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|print_obj
argument_list|(
name|regs
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
name|somereg
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|somereg
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stacktop
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"stack empty\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"stack:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|stacktop
condition|;
name|i
operator|++
control|)
block|{
name|print_obj
argument_list|(
name|stack
index|[
name|stacktop
operator|-
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|'i'
case|:
comment|/* ibase<- top of stack */
name|popstack
argument_list|(
name|setibase
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Push current ibase */
name|push
argument_list|(
name|decimal_from_int
argument_list|(
name|ibase
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/* like i, I but for precision instead of ibase */
name|popstack
argument_list|(
name|setprecision
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|push
argument_list|(
name|decimal_from_int
argument_list|(
name|precision
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* l<x> load register<x> onto stack */
block|{
name|char
name|c1
init|=
name|fetch
argument_list|()
decl_stmt|;
if|if
condition|(
name|c1
operator|<
literal|0
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|regs
index|[
name|c1
index|]
condition|)
name|error
argument_list|(
literal|"register %c empty"
argument_list|,
name|c1
argument_list|)
expr_stmt|;
else|else
name|push
argument_list|(
name|regs
index|[
name|c1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'L'
case|:
comment|/* L<x> load register<x> to stack, pop<x>'s own stack */
block|{
name|char
name|c1
init|=
name|fetch
argument_list|()
decl_stmt|;
if|if
condition|(
name|c1
operator|<
literal|0
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|regstacks
index|[
name|c1
index|]
condition|)
name|error
argument_list|(
literal|"nothing pushed on register %c"
argument_list|,
name|c1
argument_list|)
expr_stmt|;
else|else
block|{
name|regstack
name|r
init|=
name|regstacks
index|[
name|c1
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|regs
index|[
name|c1
index|]
condition|)
name|error
argument_list|(
literal|"register %c empty after pop"
argument_list|,
name|c1
argument_list|)
expr_stmt|;
else|else
name|push
argument_list|(
name|regs
index|[
name|c1
index|]
argument_list|)
expr_stmt|;
name|regs
index|[
name|c1
index|]
operator|=
name|r
operator|->
name|value
expr_stmt|;
name|regstacks
index|[
name|c1
index|]
operator|=
name|r
operator|->
name|rest
expr_stmt|;
name|free_regstack
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'o'
case|:
comment|/* o, O like i, I but for obase instead of ibase */
name|popstack
argument_list|(
name|setobase
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|push
argument_list|(
name|decimal_from_int
argument_list|(
name|obase
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* Print tos, don't pop, do print newline afterward */
if|if
condition|(
name|stacktop
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"stack empty"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|print_obj
argument_list|(
name|stack
index|[
name|stacktop
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'P'
case|:
comment|/* Print tos, do pop, no newline afterward */
name|popstack
argument_list|(
name|print_obj
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* Exit */
if|if
condition|(
name|macrolevel
condition|)
block|{
name|popmacro
argument_list|()
expr_stmt|;
name|popmacro
argument_list|()
expr_stmt|;
block|}
comment|/* decrease recursion level by 2 */
else|else
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* If not in a macro, exit the program.  */
break|break;
case|case
literal|'Q'
case|:
comment|/* Tos says how many levels to exit */
name|popstack
argument_list|(
name|popmacros
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* s<x> -- Pop stack and set register<x> */
if|if
condition|(
name|stacktop
operator|<
literal|0
condition|)
name|empty
argument_list|()
expr_stmt|;
else|else
block|{
name|int
name|c1
init|=
name|fetch
argument_list|()
decl_stmt|;
if|if
condition|(
name|c1
operator|<
literal|0
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
index|[
name|c1
index|]
condition|)
name|decref
argument_list|(
name|regs
index|[
name|c1
index|]
argument_list|)
expr_stmt|;
name|regs
index|[
name|c1
index|]
operator|=
name|stack
index|[
name|stacktop
operator|--
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|'S'
case|:
comment|/* S<x> -- pop stack and push as new value of register<x> */
if|if
condition|(
name|stacktop
operator|<
literal|0
condition|)
name|empty
argument_list|()
expr_stmt|;
else|else
block|{
name|int
name|c1
init|=
name|fetch
argument_list|()
decl_stmt|;
if|if
condition|(
name|c1
operator|<
literal|0
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pushreg
argument_list|(
name|c1
argument_list|)
expr_stmt|;
name|regs
index|[
name|c1
index|]
operator|=
name|stack
index|[
name|stacktop
operator|--
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
comment|/* tos gets square root of tos */
name|popstack
argument_list|(
name|pushsqrt
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* pop stack , call as macro */
name|popstack
argument_list|(
name|pushmacro
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* Pop stack, get # fraction digits, push that */
name|popstack
argument_list|(
name|pushscale
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
comment|/* Compute depth of stack, push that */
name|push
argument_list|(
name|decimal_from_int
argument_list|(
name|stacktop
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
comment|/* Pop stack, get # digits, push that */
name|popstack
argument_list|(
name|pushlength
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
comment|/* Conditional: pop two numbers, compare, maybe execute register */
comment|/* Note: for no obvious reason, the standard Unix `dc' 	     considers< to be true if the top of stack is less 	     than the next-to-top of stack, 	     and vice versa for>. 	     This seems backwards to me, but I am preserving compatibility.  */
name|condop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|condop
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|condop
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
comment|/* Read expression from terminal and execute it */
comment|/* First ignore any leading newlines */
block|{
name|int
name|c1
decl_stmt|;
while|while
condition|(
operator|(
name|c1
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|'\n'
condition|)
empty_stmt|;
name|ungetc
argument_list|(
name|c1
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
block|}
comment|/* Read a line from the terminal and execute it.  */
name|pushmacro
argument_list|(
name|read_string
argument_list|(
literal|'\n'
argument_list|,
name|fgetchar
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
comment|/* Begin string constant */
name|push
argument_list|(
name|read_string
argument_list|(
literal|']'
argument_list|,
name|fetch
argument_list|,
literal|'['
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'\n'
case|:
break|break;
default|default:
name|error
argument_list|(
literal|"undefined command %c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functionals for performing arithmetic, etc */
end_comment

begin_comment
comment|/* Call the function `op', with the top of stack value as argument,  and then pop the stack.  If the stack is empty, print a message and do not call `op'.  */
end_comment

begin_function_decl
name|void
name|popstack
function_decl|(
name|op
function_decl|)
name|void
argument_list|(
argument|*op
argument_list|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
if|if
condition|(
name|stacktop
operator|<
literal|0
condition|)
name|empty
argument_list|()
expr_stmt|;
else|else
block|{
name|decimal
name|value
init|=
name|stack
index|[
name|stacktop
operator|--
index|]
decl_stmt|;
name|op
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|decref
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Call the function `op' with two arguments taken from the stack top,  then pop those arguments and push the value returned by `op'.  `op' is assumed to return a decimal number.  If there are not two values on the stack, print a message  and do not call `op'.  */
end_comment

begin_function_decl
name|void
name|binop
function_decl|(
name|op
function_decl|)
name|decimal
argument_list|(
argument|*op
argument_list|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
if|if
condition|(
name|stacktop
operator|<
literal|1
condition|)
name|error
argument_list|(
literal|"stack empty"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|stack
index|[
name|stacktop
index|]
operator|->
name|after
operator|==
name|STRING
operator|||
name|stack
index|[
name|stacktop
operator|-
literal|1
index|]
operator|->
name|after
operator|==
name|STRING
condition|)
name|error
argument_list|(
literal|"operands not both numeric"
argument_list|)
expr_stmt|;
else|else
block|{
name|decimal
name|arg2
init|=
name|stack
index|[
name|stacktop
operator|--
index|]
decl_stmt|;
name|decimal
name|arg1
init|=
name|stack
index|[
name|stacktop
operator|--
index|]
decl_stmt|;
name|push
argument_list|(
name|op
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|,
name|precision
argument_list|)
argument_list|)
expr_stmt|;
name|decref
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|decref
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|void
name|condop
parameter_list|(
name|cond
parameter_list|)
name|int
name|cond
decl_stmt|;
block|{
name|int
name|regno
init|=
name|fetch
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|regs
index|[
name|regno
index|]
condition|)
name|error
argument_list|(
literal|"register %c is empty"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|stacktop
operator|<
literal|1
condition|)
name|empty
argument_list|()
expr_stmt|;
else|else
block|{
name|decimal
name|arg2
init|=
name|stack
index|[
name|stacktop
operator|--
index|]
decl_stmt|;
name|decimal
name|arg1
init|=
name|stack
index|[
name|stacktop
operator|--
index|]
decl_stmt|;
name|int
name|relation
init|=
name|decimal_compare
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
decl_stmt|;
name|decref
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|decref
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|cond
operator|==
name|relation
operator|||
operator|(
name|cond
operator|<
literal|0
operator|&&
name|relation
operator|<
literal|0
operator|)
operator|||
operator|(
name|cond
operator|>
literal|0
operator|&&
name|relation
operator|>
literal|0
operator|)
condition|)
name|pushmacro
argument_list|(
name|regs
index|[
name|regno
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle the command input source */
end_comment

begin_comment
comment|/* Fetch the next command character from a macro or from the terminal */
end_comment

begin_function
name|int
name|fetch
parameter_list|()
block|{
name|int
name|c
init|=
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|macrolevel
operator|&&
name|LENGTH
argument_list|(
name|macrostack
index|[
name|macrolevel
operator|-
literal|1
index|]
argument_list|)
operator|==
name|macroindex
index|[
name|macrolevel
operator|-
literal|1
index|]
condition|)
name|popmacro
argument_list|()
expr_stmt|;
if|if
condition|(
name|macrolevel
condition|)
return|return
name|macrostack
index|[
name|macrolevel
operator|-
literal|1
index|]
operator|->
name|contents
index|[
name|macroindex
index|[
name|macrolevel
operator|-
literal|1
index|]
operator|++
index|]
return|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|open_file
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|open_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
break|break;
name|fclose
argument_list|(
name|open_file
argument_list|)
expr_stmt|;
name|open_file
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|file_count
condition|)
block|{
name|open_file
operator|=
name|fopen
argument_list|(
operator|*
name|next_file
operator|++
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|file_count
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|open_file
condition|)
name|perror_with_name
argument_list|(
operator|*
operator|(
name|next_file
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
return|return
name|c
return|;
return|return
name|getc
argument_list|(
name|stdin
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Unread character c on command input stream, whatever it is */
end_comment

begin_function
name|void
name|unfetch
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
if|if
condition|(
name|macrolevel
condition|)
name|macroindex
index|[
name|macrolevel
operator|-
literal|1
index|]
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|open_file
condition|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|open_file
argument_list|)
expr_stmt|;
else|else
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Begin execution of macro m.  */
end_comment

begin_function
name|void
name|pushmacro
parameter_list|(
name|m
parameter_list|)
name|decimal
name|m
decl_stmt|;
block|{
while|while
condition|(
name|macrolevel
operator|&&
name|LENGTH
argument_list|(
name|macrostack
index|[
name|macrolevel
operator|-
literal|1
index|]
argument_list|)
operator|==
name|macroindex
index|[
name|macrolevel
operator|-
literal|1
index|]
condition|)
name|popmacro
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|after
operator|==
name|STRING
condition|)
block|{
if|if
condition|(
name|macrolevel
operator|==
name|macrostacksize
condition|)
block|{
name|macrostacksize
operator|*=
literal|2
expr_stmt|;
name|macrostack
operator|=
operator|(
name|decimal
operator|*
operator|)
name|xrealloc
argument_list|(
name|macrostack
argument_list|,
name|macrostacksize
operator|*
sizeof|sizeof
argument_list|(
name|decimal
argument_list|)
argument_list|)
expr_stmt|;
name|macroindex
operator|=
operator|(
name|int
operator|*
operator|)
name|xrealloc
argument_list|(
name|macroindex
argument_list|,
name|macrostacksize
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|macroindex
index|[
name|macrolevel
index|]
operator|=
literal|0
expr_stmt|;
name|macrostack
index|[
name|macrolevel
operator|++
index|]
operator|=
name|m
expr_stmt|;
name|incref
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Number supplied as a macro!  */
name|push
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Its effect wouyld be to push the number.  */
block|}
block|}
end_function

begin_comment
comment|/* Pop a specified number of levels of macro execution.  The number of levels is specified by a decimal number d.  */
end_comment

begin_function
name|void
name|popmacros
parameter_list|(
name|d
parameter_list|)
name|decimal
name|d
decl_stmt|;
block|{
name|int
name|num_pops
init|=
name|decimal_to_int
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_pops
condition|;
name|i
operator|++
control|)
name|popmacro
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Exit one level of macro execution.  */
end_comment

begin_function
name|void
name|popmacro
parameter_list|()
block|{
if|if
condition|(
operator|!
name|macrolevel
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|decref
argument_list|(
name|macrostack
index|[
operator|--
name|macrolevel
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|push
parameter_list|(
name|d
parameter_list|)
name|decimal
name|d
decl_stmt|;
block|{
if|if
condition|(
name|stacktop
operator|==
name|stacksize
operator|-
literal|1
condition|)
name|stack
operator|=
operator|(
name|decimal
operator|*
operator|)
name|xrealloc
argument_list|(
name|stack
argument_list|,
operator|(
name|stacksize
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|decimal
argument_list|)
argument_list|)
expr_stmt|;
name|incref
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|stack
index|[
operator|++
name|stacktop
index|]
operator|=
name|d
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reference counting and storage freeing */
end_comment

begin_function
name|void
name|decref
parameter_list|(
name|d
parameter_list|)
name|decimal
name|d
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|--
name|d
operator|->
name|refcnt
condition|)
name|free
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|incref
parameter_list|(
name|d
parameter_list|)
name|decimal
name|d
decl_stmt|;
block|{
name|d
operator|->
name|refcnt
operator|++
expr_stmt|;
block|}
end_function

begin_macro
name|empty
argument_list|()
end_macro

begin_block
block|{
name|error
argument_list|(
literal|"stack empty"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|regstack
name|get_regstack
parameter_list|()
block|{
if|if
condition|(
name|freeregstacks
condition|)
block|{
name|regstack
name|r
init|=
name|freeregstacks
decl_stmt|;
name|freeregstacks
operator|=
name|r
operator|->
name|rest
expr_stmt|;
return|return
name|r
return|;
block|}
else|else
return|return
operator|(
name|regstack
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|regstack
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|free_regstack
parameter_list|(
name|r
parameter_list|)
name|regstack
name|r
decl_stmt|;
block|{
name|r
operator|->
name|rest
operator|=
name|freeregstacks
expr_stmt|;
name|freeregstacks
operator|=
name|r
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pushreg
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
name|regstack
name|r
init|=
name|get_regstack
argument_list|()
decl_stmt|;
name|r
operator|->
name|rest
operator|=
name|regstacks
index|[
name|c
index|]
expr_stmt|;
name|r
operator|->
name|value
operator|=
name|regs
index|[
name|c
index|]
expr_stmt|;
name|regstacks
index|[
name|c
index|]
operator|=
name|r
expr_stmt|;
name|regs
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Input of numbers and strings */
end_comment

begin_comment
comment|/* Return a character read from the terminal.  */
end_comment

begin_macro
name|fgetchar
argument_list|()
end_macro

begin_block
block|{
return|return
name|getchar
argument_list|()
return|;
block|}
end_block

begin_function_decl
name|void
name|fputchar
parameter_list|(
name|c
parameter_list|)
function_decl|char
parameter_list|(
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_block
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Read text from command input source up to a close-bracket,    make a string out of it, and return it.    If STARTC is nonzero, then it and STOPC must balance when nested.  */
end_comment

begin_decl_stmt
name|decimal
name|read_string
argument_list|(
name|stopc
argument_list|,
name|inputfn
argument_list|,
name|startc
argument_list|)
name|char
name|stopc
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|inputfn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|startc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
name|decimal
name|result
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|inputfn
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
operator|||
operator|(
name|c
operator|==
name|stopc
operator|&&
name|count
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Unmatched `%c'"
argument_list|,
name|startc
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
name|stopc
condition|)
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|startc
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|>=
name|bufsize
condition|)
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|bufsize
operator|*=
literal|2
argument_list|)
expr_stmt|;
name|buffer
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|result
operator|=
name|make_decimal
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|->
name|after
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Mark it as a string */
name|result
operator|->
name|before
operator|++
expr_stmt|;
comment|/* but keep the length unchanged */
name|bcopy
argument_list|(
name|buffer
argument_list|,
name|result
operator|->
name|contents
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/* Read a number from the current input source */
end_comment

begin_function
name|decimal
name|dec_read
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|fetch
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
operator|)
operator|||
name|c
operator|==
literal|'.'
operator|)
condition|)
break|break;
if|if
condition|(
name|i
operator|+
literal|1
operator|>=
name|bufsize
condition|)
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|bufsize
operator|*=
literal|2
argument_list|)
expr_stmt|;
name|buffer
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|buffer
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|unfetch
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|decimal_parse
argument_list|(
name|buffer
argument_list|,
name|ibase
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output of numbers and strings */
end_comment

begin_comment
comment|/* Print the contents of obj, either numerically or as a string,  according to what obj says it is.  */
end_comment

begin_function
name|void
name|print_obj
parameter_list|(
name|obj
parameter_list|)
name|decimal
name|obj
decl_stmt|;
block|{
if|if
condition|(
name|obj
operator|->
name|after
operator|==
name|STRING
condition|)
name|print_string
argument_list|(
name|obj
argument_list|)
expr_stmt|;
else|else
name|decimal_print
argument_list|(
name|obj
argument_list|,
name|fputchar
argument_list|,
name|obase
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the contents of the decimal number `string', treated as a string.  */
end_comment

begin_function
name|void
name|print_string
parameter_list|(
name|string
parameter_list|)
name|decimal
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|string
operator|->
name|contents
decl_stmt|;
name|int
name|len
init|=
name|LENGTH
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|putchar
argument_list|(
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set the input radix from the value of the decimal number d, if valid.  */
end_comment

begin_function
name|void
name|setibase
parameter_list|(
name|d
parameter_list|)
name|decimal
name|d
decl_stmt|;
block|{
name|int
name|value
init|=
name|decimal_to_int
argument_list|(
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|<
literal|2
operator|||
name|value
operator|>
literal|36
condition|)
name|error
argument_list|(
literal|"input radix must be from 2 to 36"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ibase
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the output radix from the value of the decimal number d, if valid.  */
end_comment

begin_function
name|void
name|setobase
parameter_list|(
name|d
parameter_list|)
name|decimal
name|d
decl_stmt|;
block|{
name|int
name|value
init|=
name|decimal_to_int
argument_list|(
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|<
literal|2
operator|||
name|value
operator|>
literal|36
condition|)
name|error
argument_list|(
literal|"output radix must be from 2 to 36"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|obase
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the precision for mul and div from the value of the decimal number d, if valid.  */
end_comment

begin_function
name|void
name|setprecision
parameter_list|(
name|d
parameter_list|)
name|decimal
name|d
decl_stmt|;
block|{
name|int
name|value
init|=
name|decimal_to_int
argument_list|(
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|<
literal|0
operator|||
name|value
operator|>
literal|30000
condition|)
name|error
argument_list|(
literal|"precision must be nonnegative and< 30000"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|precision
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push the number of digits in decimal number d, as a decimal number.  */
end_comment

begin_function
name|void
name|pushlength
parameter_list|(
name|d
parameter_list|)
name|decimal
name|d
decl_stmt|;
block|{
name|push
argument_list|(
name|decimal_from_int
argument_list|(
name|LENGTH
argument_list|(
name|d
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push the number of fraction digits in d.  */
end_comment

begin_function
name|void
name|pushscale
parameter_list|(
name|d
parameter_list|)
name|decimal
name|d
decl_stmt|;
block|{
name|push
argument_list|(
name|decimal_from_int
argument_list|(
name|d
operator|->
name|after
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push the square root of decimal number d.  */
end_comment

begin_function
name|void
name|pushsqrt
parameter_list|(
name|d
parameter_list|)
name|decimal
name|d
decl_stmt|;
block|{
name|push
argument_list|(
name|decimal_sqrt
argument_list|(
name|d
argument_list|,
name|precision
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print error message and exit.  */
end_comment

begin_macro
name|fatal
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|error
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print error message.  `s1' is printf control string, `s2' is arg for it. */
end_comment

begin_macro
name|error
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"dc: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|decimal_error
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|error
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|perror_with_name
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|,
name|sys_nerr
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
name|s
operator|=
name|concat
argument_list|(
literal|""
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|,
literal|" for %s"
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
literal|"cannot open %s"
expr_stmt|;
name|error
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return a newly-allocated string whose contents concatenate those of s1, s2, s3.  */
end_comment

begin_function
name|char
modifier|*
name|concat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
name|int
name|len1
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
decl_stmt|,
name|len2
init|=
name|strlen
argument_list|(
name|s2
argument_list|)
decl_stmt|,
name|len3
init|=
name|strlen
argument_list|(
name|s3
argument_list|)
decl_stmt|;
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len1
operator|+
name|len2
operator|+
name|len3
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
operator|+
name|len2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
operator|*
operator|(
name|result
operator|+
name|len1
operator|+
name|len2
operator|+
name|len3
operator|)
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/* Like malloc but get fatal error if memory is exhausted.  */
end_comment

begin_function
name|int
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|int
name|result
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|xrealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|int
name|result
init|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

end_unit

