begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Arbitrary precision decimal arithmetic.  *  * Copyright (C) 1984 Free Software Foundation, Inc.  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2, or (at your option)  * any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, you can either send email to this  * program's author (see below) or write to: The Free Software Foundation,  * Inc.; 675 Mass Ave. Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Some known problems:  	Another problem with decimal_div is found when you try to 	divide a number with> scale fraction digits by 1.  The 	expected result is simply truncation, but all sorts of things 	happen instead.  An example is that the result of .99999998/1 	with scale set to 6 is .000001  	There are some problems in the behavior of the decimal package 	related to printing and parsing.  The 	printer is weird about very large output radices, tending to want 	to output single ASCII characters for any and all digits (even 	in radices> 127).  The UNIX bc approach is to print digit groups 	separated by spaces.  There is a rather overwrought workaround in 	the function decputc() in bcmisc.c, but it would be better if 	decimal.c got a fix for this.  */
end_comment

begin_comment
comment|/* For stand-alone testing, compile with -DTEST.    This DTESTable feature defines a `main' function    which is a simple loop that accepts input of the form    number space op space number newline    where op is +, -, *, /, %, p or r,    and performs the operation and prints the operands and result.    `p' means print the first number in the radix spec'd by the second.    `r' means read the first one in the radix specified by the second    (and print the result in decimal).    Divide in this test keeps three fraction digits. */
end_comment

begin_include
include|#
directive|include
file|"decimal.h"
end_include

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)> (b) ? (a) : (b)))
end_define

begin_comment
comment|/* Some constant decimal numbers */
end_comment

begin_decl_stmt
name|struct
name|decimal
name|decimal_zero
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|decimal
name|decimal_one
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*** Assumes RADIX is even ***/
end_comment

begin_decl_stmt
name|struct
name|decimal
name|decimal_half
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|RADIX
operator|/
literal|2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|decimal
specifier|static
name|decimal_add1
argument_list|()
decl_stmt|,
name|decimal_sub1
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|add_scaled
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|subtract_scaled
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Create and return a decimal number that has `before' digits before    the decimal point and `after' digits after.  The digits themselves are    initialized to zero.  */
end_comment

begin_function
name|decimal
name|make_decimal
parameter_list|(
name|before
parameter_list|,
name|after
parameter_list|)
name|int
name|before
decl_stmt|,
name|after
decl_stmt|;
block|{
name|decimal
name|result
decl_stmt|;
if|if
condition|(
name|before
operator|>=
literal|1
operator|<<
literal|16
condition|)
block|{
name|decimal_error
argument_list|(
literal|"%d too many decimal digits"
argument_list|,
name|before
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|after
operator|>=
literal|1
operator|<<
literal|15
condition|)
block|{
name|decimal_error
argument_list|(
literal|"%d too many decimal digits"
argument_list|,
name|after
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|result
operator|=
operator|(
name|decimal
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|decimal
argument_list|)
operator|+
name|before
operator|+
name|after
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|->
name|sign
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|before
operator|=
name|before
expr_stmt|;
name|result
operator|->
name|after
operator|=
name|after
expr_stmt|;
name|result
operator|->
name|refcnt
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|result
operator|->
name|contents
argument_list|,
name|before
operator|+
name|after
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Create a copy of the decimal number `b' and return it.  */
end_comment

begin_function
name|decimal
name|decimal_copy
parameter_list|(
name|b
parameter_list|)
name|decimal
name|b
decl_stmt|;
block|{
name|decimal
name|result
init|=
name|make_decimal
argument_list|(
name|b
operator|->
name|before
argument_list|,
name|b
operator|->
name|after
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|b
operator|->
name|contents
argument_list|,
name|result
operator|->
name|contents
argument_list|,
name|LENGTH
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|sign
operator|=
name|b
operator|->
name|sign
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Copy a decimal number `b' but extend or truncate to exactly    `digits' fraction digits. */
end_comment

begin_function
specifier|static
name|decimal
name|decimal_copy_1
parameter_list|(
name|b
parameter_list|,
name|digits
parameter_list|)
name|decimal
name|b
decl_stmt|;
name|int
name|digits
decl_stmt|;
block|{
if|if
condition|(
name|digits
operator|>
name|b
operator|->
name|after
condition|)
block|{
name|decimal
name|result
init|=
name|make_decimal
argument_list|(
name|b
operator|->
name|before
argument_list|,
name|digits
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|b
operator|->
name|contents
argument_list|,
name|result
operator|->
name|contents
operator|+
operator|(
name|digits
operator|-
operator|(
name|int
operator|)
name|b
operator|->
name|after
operator|)
argument_list|,
name|LENGTH
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
return|return
name|decimal_trunc_digits
argument_list|(
name|b
argument_list|,
name|digits
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* flush specified number `digits' of trailing fraction digits,    and flush any trailing fraction zero digits exposed after they are gone.    The number `b' is actually modified; no new storage is allocated.    That is why this is not global.  */
end_comment

begin_function
specifier|static
name|void
name|flush_trailing_digits
parameter_list|(
name|b
parameter_list|,
name|digits
parameter_list|)
name|decimal
name|b
decl_stmt|;
name|int
name|digits
decl_stmt|;
block|{
name|int
name|flush
init|=
name|digits
decl_stmt|;
name|int
name|maxdig
init|=
name|b
operator|->
name|after
decl_stmt|;
while|while
condition|(
name|flush
operator|<
name|maxdig
operator|&&
operator|!
name|b
operator|->
name|contents
index|[
name|flush
index|]
condition|)
name|flush
operator|++
expr_stmt|;
if|if
condition|(
name|flush
condition|)
block|{
name|int
name|i
decl_stmt|;
name|b
operator|->
name|after
operator|-=
name|flush
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LENGTH
argument_list|(
name|b
argument_list|)
condition|;
name|i
operator|++
control|)
name|b
operator|->
name|contents
index|[
name|i
index|]
operator|=
name|b
operator|->
name|contents
index|[
name|flush
operator|+
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return nonzero integer if the value of decimal number `b' is zero.  */
end_comment

begin_function
name|int
name|decimal_zerop
parameter_list|(
name|b
parameter_list|)
name|decimal
name|b
decl_stmt|;
block|{
return|return
operator|!
name|LENGTH
argument_list|(
name|b
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare two decimal numbers arithmetically.    The value is< 0 if b1< b2,> 0 if b1> b2, 0 if b1 = b2.    This is the same way that `strcmp' reports the result of comparing    strings.  */
end_comment

begin_function
name|int
name|decimal_compare
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|)
name|decimal
name|b1
decl_stmt|,
name|b2
decl_stmt|;
block|{
name|int
name|l1
decl_stmt|,
name|l2
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If signs differ, deduce result from the signs */
if|if
condition|(
name|b2
operator|->
name|sign
operator|&&
operator|!
name|b1
operator|->
name|sign
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|b1
operator|->
name|sign
operator|&&
operator|!
name|b2
operator|->
name|sign
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If same sign but number of nonfraction digits differs,      the one with more of them is farther from zero.  */
if|if
condition|(
name|b1
operator|->
name|before
operator|!=
name|b2
operator|->
name|before
condition|)
if|if
condition|(
name|b1
operator|->
name|sign
condition|)
return|return
call|(
name|int
call|)
argument_list|(
name|b2
operator|->
name|before
operator|-
name|b1
operator|->
name|before
argument_list|)
return|;
else|else
return|return
call|(
name|int
call|)
argument_list|(
name|b1
operator|->
name|before
operator|-
name|b2
operator|->
name|before
argument_list|)
return|;
comment|/* Else compare the numbers digit by digit from high end */
name|l1
operator|=
name|LENGTH
argument_list|(
name|b1
argument_list|)
expr_stmt|;
name|l2
operator|=
name|LENGTH
argument_list|(
name|b2
argument_list|)
expr_stmt|;
name|s1
operator|=
name|b1
operator|->
name|contents
expr_stmt|;
comment|/* Start of number -- don't back up digit pointer past here */
name|s2
operator|=
name|b2
operator|->
name|contents
expr_stmt|;
name|p1
operator|=
name|b1
operator|->
name|contents
operator|+
name|l1
expr_stmt|;
comment|/* Scanning pointer, for fetching digits.  */
name|p2
operator|=
name|b2
operator|->
name|contents
operator|+
name|l2
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MAX
argument_list|(
name|l1
argument_list|,
name|l2
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|r
init|=
operator|(
operator|(
name|p1
operator|!=
name|s1
operator|)
condition|?
operator|*
operator|--
name|p1
else|:
literal|0
operator|)
operator|-
operator|(
operator|(
name|p2
operator|!=
name|s2
operator|)
condition|?
operator|*
operator|--
name|p2
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|r
condition|)
return|return
name|b1
operator|->
name|sign
condition|?
operator|-
name|r
else|:
name|r
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the number of digits stored in decimal number `b' */
end_comment

begin_function
name|int
name|decimal_length
parameter_list|(
name|b
parameter_list|)
name|decimal
name|b
decl_stmt|;
block|{
return|return
name|LENGTH
argument_list|(
name|b
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the number of fraction digits stored in decimal number `b'.  */
end_comment

begin_function
name|int
name|decimal_after
parameter_list|(
name|b
parameter_list|)
name|decimal
name|b
decl_stmt|;
block|{
return|return
name|b
operator|->
name|after
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Round decimal number `b' to have only `digits' fraction digits.    Result is rounded to nearest unit in the last remaining digit.    Return the result, another decimal number.  */
end_comment

begin_function
name|decimal
name|decimal_round_digits
parameter_list|(
name|b
parameter_list|,
name|digits
parameter_list|)
name|decimal
name|b
decl_stmt|;
name|int
name|digits
decl_stmt|;
block|{
name|decimal
name|result
decl_stmt|;
name|int
name|old
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|after
operator|<=
name|digits
condition|)
return|return
name|decimal_copy
argument_list|(
name|b
argument_list|)
return|;
if|if
condition|(
name|digits
operator|<
literal|0
condition|)
block|{
name|decimal_error
argument_list|(
literal|"request to keep negative number of digits %d"
argument_list|,
name|digits
argument_list|)
expr_stmt|;
return|return
name|decimal_copy
argument_list|(
name|b
argument_list|)
return|;
block|}
name|result
operator|=
name|make_decimal
argument_list|(
name|b
operator|->
name|before
operator|+
literal|1
argument_list|,
name|b
operator|->
name|after
argument_list|)
expr_stmt|;
name|result
operator|->
name|sign
operator|=
name|b
operator|->
name|sign
expr_stmt|;
name|bcopy
argument_list|(
name|b
operator|->
name|contents
argument_list|,
name|result
operator|->
name|contents
argument_list|,
name|LENGTH
argument_list|(
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|old
operator|=
name|result
operator|->
name|after
expr_stmt|;
comment|/* Add .5 * last place to keep, so that we round rather than truncate */
comment|/* Note this ignores sign of result, so if result is negative      it is subtracting */
name|add_scaled
argument_list|(
name|result
argument_list|,
name|DECIMAL_HALF
argument_list|,
literal|1
argument_list|,
name|old
operator|-
name|digits
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Flush desired digits, and any trailing zeros exposed by them.  */
name|flush_trailing_digits
argument_list|(
name|result
argument_list|,
name|old
operator|-
name|digits
argument_list|)
expr_stmt|;
comment|/* Flush leading digits -- always is one, unless was a carry into it */
while|while
condition|(
name|result
operator|->
name|before
operator|>
literal|0
operator|&&
name|result
operator|->
name|contents
index|[
name|LENGTH
argument_list|(
name|result
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
name|result
operator|->
name|before
operator|--
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Truncate decimal number `b' to have only `digits' fraction digits.    Any fraction digits in `b' beyond that are dropped and ignored.    Truncation is toward zero.    Return the result, another decimal number.  */
end_comment

begin_function
name|decimal
name|decimal_trunc_digits
parameter_list|(
name|b
parameter_list|,
name|digits
parameter_list|)
name|decimal
name|b
decl_stmt|;
name|int
name|digits
decl_stmt|;
block|{
name|decimal
name|result
init|=
name|decimal_copy
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|int
name|old
init|=
name|result
operator|->
name|after
decl_stmt|;
if|if
condition|(
name|old
operator|<=
name|digits
condition|)
return|return
name|result
return|;
if|if
condition|(
name|digits
operator|<
literal|0
condition|)
block|{
name|decimal_error
argument_list|(
literal|"request to keep negative number of digits %d"
argument_list|,
name|digits
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
name|flush_trailing_digits
argument_list|(
name|result
argument_list|,
name|old
operator|-
name|digits
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return the fractional part of decimal number `b':    that is, `b' - decimal_trunc_digits (`b') */
end_comment

begin_function
name|decimal
name|decimal_fraction
parameter_list|(
name|b
parameter_list|)
name|decimal
name|b
decl_stmt|;
block|{
name|decimal
name|result
init|=
name|make_decimal
argument_list|(
literal|0
argument_list|,
name|b
operator|->
name|after
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|b
operator|->
name|contents
argument_list|,
name|result
operator|->
name|contents
argument_list|,
name|b
operator|->
name|after
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* return an integer whose value is that of decimal `b', sans its fraction.  */
end_comment

begin_function
name|int
name|decimal_to_int
parameter_list|(
name|b
parameter_list|)
name|decimal
name|b
decl_stmt|;
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|end
init|=
name|b
operator|->
name|after
decl_stmt|;
for|for
control|(
name|i
operator|=
name|LENGTH
argument_list|(
name|b
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
name|end
condition|;
name|i
operator|--
control|)
block|{
name|result
operator|*=
name|RADIX
expr_stmt|;
name|result
operator|+=
name|b
operator|->
name|contents
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* return a decimal whose value is the integer i.  */
end_comment

begin_function
name|decimal
name|decimal_from_int
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|int
name|log
decl_stmt|,
name|tem
decl_stmt|;
name|decimal
name|result
decl_stmt|;
for|for
control|(
name|log
operator|=
literal|0
operator|,
name|tem
operator|=
operator|(
name|i
operator|>
literal|0
condition|?
name|i
else|:
operator|-
name|i
operator|)
init|;
name|tem
condition|;
name|log
operator|++
operator|,
name|tem
operator|/=
name|RADIX
control|)
empty_stmt|;
name|result
operator|=
name|make_decimal
argument_list|(
name|log
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|log
operator|=
literal|0
operator|,
name|tem
operator|=
operator|(
name|i
operator|>
literal|0
condition|?
name|i
else|:
operator|-
name|i
operator|)
init|;
name|tem
condition|;
name|log
operator|++
operator|,
name|tem
operator|/=
name|RADIX
control|)
name|result
operator|->
name|contents
index|[
name|log
index|]
operator|=
name|tem
operator|%
name|RADIX
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|result
operator|->
name|sign
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return (as an integer) the result of dividing decimal number `b' by    integer `divisor'.    This is used in printing decimal numbers in other radices. */
end_comment

begin_function
name|int
name|decimal_int_rem
parameter_list|(
name|b
parameter_list|,
name|divisor
parameter_list|)
name|decimal
name|b
decl_stmt|;
name|int
name|divisor
decl_stmt|;
block|{
name|int
name|len
init|=
name|LENGTH
argument_list|(
name|b
argument_list|)
decl_stmt|;
name|int
name|end
init|=
name|b
operator|->
name|after
decl_stmt|;
name|int
name|accum
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
name|end
condition|;
name|i
operator|--
control|)
block|{
name|accum
operator|%=
name|divisor
expr_stmt|;
name|accum
operator|*=
name|RADIX
expr_stmt|;
name|accum
operator|+=
name|b
operator|->
name|contents
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|accum
operator|%
name|divisor
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert digit `digit' to a character and output it by calling    `charout' with it as arg. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|print_digit
argument_list|(
name|digit
argument_list|,
name|charout
argument_list|)
name|int
name|digit
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|charout
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
if|if
condition|(
name|digit
operator|<
literal|10
condition|)
name|charout
argument_list|(
literal|'0'
operator|+
name|digit
argument_list|)
expr_stmt|;
else|else
name|charout
argument_list|(
literal|'A'
operator|+
name|digit
operator|-
literal|10
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* print decimal number `b' in radix `radix', assuming it is an integer.    `r' is `radix' expressed as a decimal number. */
end_comment

begin_expr_stmt
specifier|static
name|decimal_print_1
argument_list|(
argument|b
argument_list|,
argument|r
argument_list|,
argument|radix
argument_list|,
argument|charout
argument_list|)
name|decimal
name|b
operator|,
name|r
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|radix
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|charout
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|int
name|digit
init|=
name|decimal_int_rem
argument_list|(
name|b
argument_list|,
name|radix
argument_list|)
decl_stmt|;
name|decimal
name|rest
init|=
name|decimal_div
argument_list|(
name|b
argument_list|,
name|r
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|decimal_zerop
argument_list|(
name|rest
argument_list|)
condition|)
name|decimal_print_1
argument_list|(
name|rest
argument_list|,
name|r
argument_list|,
name|radix
argument_list|,
name|charout
argument_list|)
expr_stmt|;
name|print_digit
argument_list|(
name|digit
argument_list|,
name|charout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rest
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* User entry: print decimal number `b' in radix `radix' (an integer),    outputting characters by calling `charout'.  */
end_comment

begin_decl_stmt
name|void
name|decimal_print
argument_list|(
name|b
argument_list|,
name|charout
argument_list|,
name|radix
argument_list|)
name|decimal
name|b
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|charout
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|radix
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|b
operator|->
name|sign
condition|)
name|charout
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|radix
operator|==
name|RADIX
condition|)
block|{
comment|/* decimal output => just print the digits, inserting a point in 	 the proper place.  */
name|int
name|i
decl_stmt|;
name|int
name|before
init|=
name|b
operator|->
name|before
decl_stmt|;
name|int
name|len
init|=
name|before
operator|+
name|b
operator|->
name|after
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|before
condition|)
name|charout
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
comment|/* Broken if RADIX /= 10 	     charout ('0' + b->contents [len - 1 - i]); */
name|print_digit
argument_list|(
name|b
operator|->
name|contents
index|[
name|len
operator|-
literal|1
operator|-
name|i
index|]
argument_list|,
name|charout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|len
condition|)
name|charout
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* nonstandard radix: must use multiply and divide to determine the 	 digits of the number in that radix.  */
name|int
name|i
decl_stmt|;
specifier|extern
name|double
name|log10
parameter_list|()
function_decl|;
comment|/* Compute the number of fraction digits we want to have in the          new radix.  They should contain the same amount of          information as the decimal digits we have.  */
name|int
name|nfrac
init|=
operator|(
name|b
operator|->
name|after
operator|/
name|log10
argument_list|(
operator|(
name|double
operator|)
name|radix
argument_list|)
operator|+
literal|.99
operator|)
decl_stmt|;
name|decimal
name|r
init|=
name|decimal_from_int
argument_list|(
name|radix
argument_list|)
decl_stmt|;
name|decimal
name|intpart
init|=
name|decimal_trunc_digits
argument_list|(
name|b
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* print integer part */
name|decimal_print_1
argument_list|(
name|intpart
argument_list|,
name|r
argument_list|,
name|radix
argument_list|,
name|charout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|intpart
argument_list|)
expr_stmt|;
comment|/* print fraction part */
if|if
condition|(
name|nfrac
condition|)
block|{
name|decimal
name|tem1
decl_stmt|,
name|tem2
decl_stmt|;
name|tem1
operator|=
name|decimal_fraction
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|charout
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
comment|/* repeatedly multiply by `radix', print integer part as one digit, 	     and flush the integer part.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfrac
condition|;
name|i
operator|++
control|)
block|{
name|tem2
operator|=
name|decimal_mul
argument_list|(
name|tem1
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tem1
argument_list|)
expr_stmt|;
name|print_digit
argument_list|(
name|decimal_to_int
argument_list|(
name|tem2
argument_list|)
argument_list|,
name|charout
argument_list|)
expr_stmt|;
name|tem1
operator|=
name|decimal_fraction
argument_list|(
name|tem2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tem2
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|tem1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_function
specifier|static
name|int
name|decode_digit
parameter_list|(
name|digitchar
parameter_list|)
name|char
name|digitchar
decl_stmt|;
block|{
if|if
condition|(
literal|'0'
operator|<=
name|digitchar
operator|&&
name|digitchar
operator|<=
literal|'9'
condition|)
return|return
name|digitchar
operator|-
literal|'0'
return|;
if|if
condition|(
literal|'a'
operator|<=
name|digitchar
operator|&&
name|digitchar
operator|<=
literal|'z'
condition|)
return|return
name|digitchar
operator|-
literal|'a'
operator|+
literal|10
return|;
if|if
condition|(
literal|'A'
operator|<=
name|digitchar
operator|&&
name|digitchar
operator|<=
literal|'Z'
condition|)
return|return
name|digitchar
operator|-
literal|'A'
operator|+
literal|10
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Parse string `s' into a number using radix `radix'    and return result as a decimal number.  */
end_comment

begin_function
name|decimal
name|decimal_parse
parameter_list|(
name|s
parameter_list|,
name|radix
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|radix
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|before
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|decimal
name|result
decl_stmt|;
name|int
name|negative
init|=
literal|0
decl_stmt|;
name|int
name|excess_digit
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
name|s
operator|++
expr_stmt|;
name|negative
operator|=
literal|1
expr_stmt|;
block|}
comment|/* First scan for valid characters.      Count total num digits, and count num before the decimal point.  */
name|p
operator|=
name|s
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|before
operator|>=
literal|0
condition|)
name|decimal_error
argument_list|(
literal|"two decimal points in %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|before
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'0'
operator|&&
operator|!
name|i
operator|&&
name|before
operator|<
literal|0
condition|)
name|s
operator|++
expr_stmt|;
comment|/* Discard leading zeros */
elseif|else
if|if
condition|(
name|decode_digit
argument_list|(
name|c
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|decode_digit
argument_list|(
name|c
argument_list|)
operator|>
name|RADIX
condition|)
name|excess_digit
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|decimal_error
argument_list|(
literal|"invalid number %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|before
operator|<
literal|0
condition|)
name|before
operator|=
name|i
expr_stmt|;
name|p
operator|=
name|s
expr_stmt|;
comment|/* Now parse those digits */
if|if
condition|(
name|radix
operator|!=
name|RADIX
operator|||
name|excess_digit
condition|)
block|{
name|decimal
name|r
init|=
name|decimal_from_int
argument_list|(
name|radix
argument_list|)
decl_stmt|;
specifier|extern
name|double
name|log10
parameter_list|()
function_decl|;
name|int
name|digits
init|=
operator|(
name|len
operator|-
name|before
operator|)
operator|*
name|log10
argument_list|(
operator|(
name|double
operator|)
name|radix
argument_list|)
operator|+
literal|.99
decl_stmt|;
name|result
operator|=
name|decimal_copy
argument_list|(
name|DECIMAL_ZERO
argument_list|)
expr_stmt|;
comment|/* Parse all the digits into an integer, ignoring decimal point, 	 by multiplying by `radix'.  */
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'.'
condition|)
block|{
name|decimal
name|newdig
init|=
name|decimal_from_int
argument_list|(
name|decode_digit
argument_list|(
name|c
argument_list|)
argument_list|)
decl_stmt|;
name|decimal
name|prod
init|=
name|decimal_mul
argument_list|(
name|result
argument_list|,
name|r
argument_list|)
decl_stmt|;
name|decimal
name|newresult
init|=
name|decimal_add
argument_list|(
name|newdig
argument_list|,
name|prod
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|newdig
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|prod
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|newresult
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
block|}
comment|/* Now put decimal point in right place 	 by dividing by `radix' once for each digit 	 that really should have followed the decimal point.  */
for|for
control|(
name|i
operator|=
name|before
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|decimal
name|newresult
init|=
name|decimal_div
argument_list|(
name|result
argument_list|,
name|r
argument_list|,
name|digits
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|newresult
expr_stmt|;
block|}
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* radix is standard - just copy the digits into a decimal number.  */
name|int
name|tem
decl_stmt|;
name|result
operator|=
name|make_decimal
argument_list|(
name|before
argument_list|,
name|len
operator|-
name|before
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
operator|(
name|c
operator|=
operator|*
name|p
operator|++
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|!=
literal|'.'
operator|)
operator|&&
operator|(
operator|(
name|tem
operator|=
name|decode_digit
argument_list|(
name|c
argument_list|)
operator|)
operator|>=
literal|0
operator|)
condition|)
name|result
operator|->
name|contents
index|[
operator|--
name|i
index|]
operator|=
name|tem
expr_stmt|;
block|}
block|}
if|if
condition|(
name|negative
condition|)
name|result
operator|->
name|sign
operator|=
literal|1
expr_stmt|;
name|flush_trailing_digits
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add b1 and b2, considering their signs */
end_comment

begin_function
name|decimal
name|decimal_add
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|)
name|decimal
name|b1
decl_stmt|,
name|b2
decl_stmt|;
block|{
name|decimal
name|v
decl_stmt|;
if|if
condition|(
name|b1
operator|->
name|sign
operator|!=
name|b2
operator|->
name|sign
condition|)
name|v
operator|=
name|decimal_sub1
argument_list|(
name|b1
argument_list|,
name|b2
argument_list|)
expr_stmt|;
else|else
name|v
operator|=
name|decimal_add1
argument_list|(
name|b1
argument_list|,
name|b2
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|->
name|sign
operator|&&
operator|!
name|decimal_zerop
argument_list|(
name|v
argument_list|)
condition|)
name|v
operator|->
name|sign
operator|=
operator|!
name|v
operator|->
name|sign
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Add b1 and minus b2, considering their signs */
end_comment

begin_function
name|decimal
name|decimal_sub
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|)
name|decimal
name|b1
decl_stmt|,
name|b2
decl_stmt|;
block|{
name|decimal
name|v
decl_stmt|;
if|if
condition|(
name|b1
operator|->
name|sign
operator|!=
name|b2
operator|->
name|sign
condition|)
name|v
operator|=
name|decimal_add1
argument_list|(
name|b1
argument_list|,
name|b2
argument_list|)
expr_stmt|;
else|else
name|v
operator|=
name|decimal_sub1
argument_list|(
name|b1
argument_list|,
name|b2
argument_list|)
expr_stmt|;
if|if
condition|(
name|b1
operator|->
name|sign
operator|&&
operator|!
name|decimal_zerop
argument_list|(
name|v
argument_list|)
condition|)
name|v
operator|->
name|sign
operator|=
operator|!
name|v
operator|->
name|sign
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Return the negation of b2.  */
end_comment

begin_function
name|decimal
name|decimal_neg
parameter_list|(
name|b2
parameter_list|)
name|decimal
name|b2
decl_stmt|;
block|{
name|decimal
name|v
init|=
name|decimal_copy
argument_list|(
name|b2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|decimal_zerop
argument_list|(
name|v
argument_list|)
condition|)
name|v
operator|->
name|sign
operator|=
operator|!
name|v
operator|->
name|sign
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* add magnitudes of b1 and b2, ignoring their signs. */
end_comment

begin_function
specifier|static
name|decimal
name|decimal_add1
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|)
name|decimal
name|b1
decl_stmt|,
name|b2
decl_stmt|;
block|{
name|int
name|before
init|=
name|MAX
argument_list|(
name|b1
operator|->
name|before
argument_list|,
name|b2
operator|->
name|before
argument_list|)
decl_stmt|;
name|int
name|after
init|=
name|MAX
argument_list|(
name|b1
operator|->
name|after
argument_list|,
name|b2
operator|->
name|after
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|before
operator|+
name|after
operator|+
literal|1
decl_stmt|;
name|decimal
name|result
init|=
name|make_decimal
argument_list|(
name|before
operator|+
literal|1
argument_list|,
name|after
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s1
init|=
name|b1
operator|->
name|contents
decl_stmt|;
name|char
modifier|*
name|s2
init|=
name|b2
operator|->
name|contents
decl_stmt|;
name|char
modifier|*
name|p1
init|=
name|s1
operator|+
name|b1
operator|->
name|after
operator|-
name|after
decl_stmt|;
name|char
modifier|*
name|p2
init|=
name|s2
operator|+
name|b2
operator|->
name|after
operator|-
name|after
decl_stmt|;
name|char
modifier|*
name|e1
init|=
name|s1
operator|+
name|b1
operator|->
name|before
operator|+
name|b1
operator|->
name|after
decl_stmt|;
name|char
modifier|*
name|e2
init|=
name|s2
operator|+
name|b2
operator|->
name|before
operator|+
name|b2
operator|->
name|after
decl_stmt|;
name|char
modifier|*
name|pr
init|=
name|result
operator|->
name|contents
decl_stmt|;
name|int
name|accum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|p1
operator|++
operator|,
name|p2
operator|++
control|)
block|{
name|accum
operator|/=
name|RADIX
expr_stmt|;
if|if
condition|(
name|p1
operator|>=
name|s1
operator|&&
name|p1
operator|<
name|e1
condition|)
name|accum
operator|+=
operator|*
name|p1
expr_stmt|;
if|if
condition|(
name|p2
operator|>=
name|s2
operator|&&
name|p2
operator|<
name|e2
condition|)
name|accum
operator|+=
operator|*
name|p2
expr_stmt|;
operator|*
name|pr
operator|++
operator|=
name|accum
operator|%
name|RADIX
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|accum
condition|)
operator|(
name|result
operator|->
name|before
operator|)
operator|--
expr_stmt|;
name|flush_trailing_digits
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* subtract magnitude of b2 from that or b1, returning signed decimal    number. */
end_comment

begin_function
specifier|static
name|decimal
name|decimal_sub1
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|)
name|decimal
name|b1
decl_stmt|,
name|b2
decl_stmt|;
block|{
name|int
name|before
init|=
name|MAX
argument_list|(
name|b1
operator|->
name|before
argument_list|,
name|b2
operator|->
name|before
argument_list|)
decl_stmt|;
name|int
name|after
init|=
name|MAX
argument_list|(
name|b1
operator|->
name|after
argument_list|,
name|b2
operator|->
name|after
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|before
operator|+
name|after
decl_stmt|;
name|decimal
name|result
init|=
name|make_decimal
argument_list|(
name|before
argument_list|,
name|after
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|s1
init|=
name|b1
operator|->
name|contents
decl_stmt|;
name|char
modifier|*
name|s2
init|=
name|b2
operator|->
name|contents
decl_stmt|;
name|char
modifier|*
name|p1
init|=
name|s1
operator|+
name|b1
operator|->
name|after
operator|-
name|after
decl_stmt|;
name|char
modifier|*
name|p2
init|=
name|s2
operator|+
name|b2
operator|->
name|after
operator|-
name|after
decl_stmt|;
name|char
modifier|*
name|e1
init|=
name|s1
operator|+
name|b1
operator|->
name|before
operator|+
name|b1
operator|->
name|after
decl_stmt|;
name|char
modifier|*
name|e2
init|=
name|s2
operator|+
name|b2
operator|->
name|before
operator|+
name|b2
operator|->
name|after
decl_stmt|;
name|char
modifier|*
name|pr
init|=
name|result
operator|->
name|contents
decl_stmt|;
name|int
name|accum
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|p1
operator|++
operator|,
name|p2
operator|++
control|)
block|{
if|if
condition|(
name|p1
operator|>=
name|s1
operator|&&
name|p1
operator|<
name|e1
condition|)
name|accum
operator|+=
operator|*
name|p1
expr_stmt|;
if|if
condition|(
name|p2
operator|>=
name|s2
operator|&&
name|p2
operator|<
name|e2
condition|)
name|accum
operator|-=
operator|*
name|p2
expr_stmt|;
if|if
condition|(
name|accum
operator|<
literal|0
operator|&&
name|accum
operator|%
name|RADIX
condition|)
operator|*
name|pr
operator|=
name|RADIX
operator|-
operator|(
operator|-
name|accum
operator|)
operator|%
name|RADIX
expr_stmt|;
else|else
operator|*
name|pr
operator|=
name|accum
operator|%
name|RADIX
expr_stmt|;
name|accum
operator|-=
operator|*
name|pr
operator|++
expr_stmt|;
name|accum
operator|/=
name|RADIX
expr_stmt|;
block|}
comment|/* If result is negative, subtract it from RADIX**length      so that we get the right digits for sign-magnitude      rather than RADIX-complement */
if|if
condition|(
name|accum
condition|)
block|{
name|result
operator|->
name|sign
operator|=
literal|1
expr_stmt|;
name|pr
operator|=
name|result
operator|->
name|contents
expr_stmt|;
name|accum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|accum
operator|-=
operator|*
name|pr
expr_stmt|;
if|if
condition|(
name|accum
condition|)
operator|*
name|pr
operator|=
name|accum
operator|+
name|RADIX
expr_stmt|;
else|else
operator|*
name|pr
operator|=
literal|0
expr_stmt|;
name|accum
operator|-=
operator|*
name|pr
operator|++
expr_stmt|;
name|accum
operator|/=
name|RADIX
expr_stmt|;
block|}
block|}
comment|/* flush leading nonfraction zero digits */
while|while
condition|(
name|result
operator|->
name|before
operator|&&
operator|*
operator|--
name|pr
operator|==
literal|0
condition|)
operator|(
name|result
operator|->
name|before
operator|)
operator|--
expr_stmt|;
name|flush_trailing_digits
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* multiply b1 and b2 keeping `digits' fraction digits */
end_comment

begin_function
name|decimal
name|decimal_mul_rounded
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|,
name|digits
parameter_list|)
name|decimal
name|b1
decl_stmt|,
name|b2
decl_stmt|;
name|int
name|digits
decl_stmt|;
block|{
name|decimal
name|tem
init|=
name|decimal_mul
argument_list|(
name|b1
argument_list|,
name|b2
argument_list|)
decl_stmt|;
name|decimal
name|result
init|=
name|decimal_round_digits
argument_list|(
name|tem
argument_list|,
name|digits
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|tem
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* multiply b1 and b2 keeping the right number of fraction digits    for the `dc' program with precision = `digits'.  */
end_comment

begin_function
name|decimal
name|decimal_mul_dc
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|,
name|digits
parameter_list|)
name|decimal
name|b1
decl_stmt|,
name|b2
decl_stmt|;
name|int
name|digits
decl_stmt|;
block|{
name|decimal
name|tem
init|=
name|decimal_mul
argument_list|(
name|b1
argument_list|,
name|b2
argument_list|)
decl_stmt|;
name|decimal
name|result
init|=
name|decimal_round_digits
argument_list|(
name|tem
argument_list|,
name|MAX
argument_list|(
name|digits
argument_list|,
name|MAX
argument_list|(
name|b1
operator|->
name|after
argument_list|,
name|b2
operator|->
name|after
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|tem
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* multiply b1 and b2 as decimal error-free values;    keep LENGTH(b1) plus LENGTH(b2) significant figures. */
end_comment

begin_function
name|decimal
name|decimal_mul
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|)
name|decimal
name|b1
decl_stmt|,
name|b2
decl_stmt|;
block|{
name|decimal
name|result
init|=
name|make_decimal
argument_list|(
name|b1
operator|->
name|before
operator|+
name|b2
operator|->
name|before
argument_list|,
name|b1
operator|->
name|after
operator|+
name|b2
operator|->
name|after
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|length2
init|=
name|LENGTH
argument_list|(
name|b2
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length2
condition|;
name|i
operator|++
control|)
name|add_scaled
argument_list|(
name|result
argument_list|,
name|b1
argument_list|,
name|b2
operator|->
name|contents
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* flush leading nonfraction zero digits */
name|pr
operator|=
name|result
operator|->
name|contents
operator|+
name|LENGTH
argument_list|(
name|result
argument_list|)
expr_stmt|;
while|while
condition|(
name|result
operator|->
name|before
operator|&&
operator|*
operator|--
name|pr
operator|==
literal|0
condition|)
operator|(
name|result
operator|->
name|before
operator|)
operator|--
expr_stmt|;
name|flush_trailing_digits
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* flush trailing zeros */
comment|/* Set sign properly */
if|if
condition|(
name|b1
operator|->
name|sign
operator|!=
name|b2
operator|->
name|sign
operator|&&
name|LENGTH
argument_list|(
name|result
argument_list|)
condition|)
name|result
operator|->
name|sign
operator|=
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Modify decimal number `into' by adding `from',    multiplied by `factor' (which should be nonnegative and less than RADIX)    and shifted left `scale' digits at the least significant end. */
end_comment

begin_function
specifier|static
name|void
name|add_scaled
parameter_list|(
name|into
parameter_list|,
name|from
parameter_list|,
name|factor
parameter_list|,
name|scale
parameter_list|)
name|decimal
name|into
decl_stmt|,
name|from
decl_stmt|;
name|int
name|factor
decl_stmt|,
name|scale
decl_stmt|;
block|{
name|char
modifier|*
name|pf
init|=
name|from
operator|->
name|contents
decl_stmt|;
name|char
modifier|*
name|pi
init|=
name|into
operator|->
name|contents
operator|+
name|scale
decl_stmt|;
name|int
name|lengthf
init|=
name|LENGTH
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|int
name|lengthi
init|=
name|LENGTH
argument_list|(
name|into
argument_list|)
operator|-
name|scale
decl_stmt|;
name|int
name|accum
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lengthi
condition|;
name|i
operator|++
control|)
block|{
name|accum
operator|/=
name|RADIX
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|lengthf
condition|)
name|accum
operator|+=
operator|*
name|pf
operator|++
operator|*
name|factor
expr_stmt|;
name|accum
operator|+=
operator|*
name|pi
expr_stmt|;
operator|*
name|pi
operator|++
operator|=
name|accum
operator|%
name|RADIX
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Divide decimal number `b1' by `b2', keeping at most `digits'    fraction digits.    Returns the result as a decimal number.     When division is not exact, the quotient is truncated toward zero.  */
end_comment

begin_function
name|decimal
name|decimal_div
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|,
name|digits
parameter_list|)
name|decimal
name|b1
decl_stmt|,
name|b2
decl_stmt|;
name|int
name|digits
decl_stmt|;
block|{
name|decimal
name|result
init|=
name|make_decimal
argument_list|(
name|MAX
argument_list|(
literal|1
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|1
operator|+
name|b1
operator|->
name|before
operator|-
name|b2
operator|->
name|before
argument_list|)
argument_list|)
argument_list|,
name|digits
argument_list|)
decl_stmt|;
comment|/* b1copy holds what is left of the dividend,      that is not accounted for by the quotient digits already known */
name|decimal
name|b1copy
init|=
name|decimal_copy_1
argument_list|(
name|b1
argument_list|,
name|b2
operator|->
name|after
operator|+
name|digits
argument_list|)
decl_stmt|;
name|int
name|length1
init|=
name|LENGTH
argument_list|(
name|b1copy
argument_list|)
decl_stmt|;
name|int
name|length2
init|=
name|LENGTH
argument_list|(
name|b2
argument_list|)
decl_stmt|;
name|int
name|lengthr
init|=
name|LENGTH
argument_list|(
name|result
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* leading_divisor_digits contains the first two divisor digits, as      an integer */
name|int
name|leading_divisor_digits
init|=
name|b2
operator|->
name|contents
index|[
name|length2
operator|-
literal|1
index|]
operator|*
name|RADIX
decl_stmt|;
if|if
condition|(
name|length2
operator|>
literal|1
condition|)
name|leading_divisor_digits
operator|+=
name|b2
operator|->
name|contents
index|[
name|length2
operator|-
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|decimal_zerop
argument_list|(
name|b2
argument_list|)
condition|)
block|{
name|decimal_error
argument_list|(
literal|"divisor is zero"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decimal_copy
argument_list|(
name|DECIMAL_ZERO
argument_list|)
return|;
block|}
comment|/*   if (lengthr<= (length1 - length2))     abort(); */
comment|/* My reasoning says this cannot happen, I hope */
for|for
control|(
name|i
operator|=
name|length1
operator|-
name|length2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Guess the next quotient digit (in order of decreasing significance) 	 using integer division */
name|int
name|guess
decl_stmt|;
name|int
name|trial_dividend
init|=
name|b1copy
operator|->
name|contents
index|[
name|length2
operator|+
name|i
operator|-
literal|1
index|]
operator|*
name|RADIX
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|length1
operator|-
name|length2
condition|)
name|trial_dividend
operator|+=
name|b1copy
operator|->
name|contents
index|[
name|length2
operator|+
name|i
index|]
operator|*
name|RADIX
operator|*
name|RADIX
expr_stmt|;
if|if
condition|(
name|length2
operator|+
name|i
operator|>
literal|1
condition|)
name|trial_dividend
operator|+=
name|b1copy
operator|->
name|contents
index|[
name|length2
operator|+
name|i
operator|-
literal|2
index|]
expr_stmt|;
name|guess
operator|=
name|trial_dividend
operator|/
name|leading_divisor_digits
expr_stmt|;
comment|/* Remove the quotient times this digit from the dividend left */
comment|/* We may find that the quotient digit is too large, 	 when we consider the entire divisor. 	 Then we decrement the quotient digit and add the divisor back in */
if|if
condition|(
name|guess
operator|&&
literal|0
operator|>
name|subtract_scaled
argument_list|(
name|b1copy
argument_list|,
name|b2
argument_list|,
name|guess
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|guess
operator|--
expr_stmt|;
name|add_scaled
argument_list|(
name|b1copy
argument_list|,
name|b2
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|guess
operator|>=
name|RADIX
condition|)
block|{
name|result
operator|->
name|contents
index|[
name|i
operator|+
literal|1
index|]
operator|+=
name|guess
operator|/
name|RADIX
expr_stmt|;
name|guess
operator|%=
name|RADIX
expr_stmt|;
block|}
name|result
operator|->
name|contents
index|[
name|i
index|]
operator|=
name|guess
expr_stmt|;
block|}
name|free
argument_list|(
name|b1copy
argument_list|)
expr_stmt|;
name|result
operator|->
name|sign
operator|=
operator|(
name|b1
operator|->
name|sign
operator|!=
name|b2
operator|->
name|sign
operator|)
expr_stmt|;
comment|/* flush leading nonfraction zero digits */
block|{
name|char
modifier|*
name|pr
init|=
name|result
operator|->
name|contents
operator|+
name|lengthr
decl_stmt|;
while|while
condition|(
name|result
operator|->
name|before
operator|&&
operator|*
operator|--
name|pr
operator|==
literal|0
condition|)
operator|(
name|result
operator|->
name|before
operator|)
operator|--
expr_stmt|;
block|}
name|flush_trailing_digits
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Flush trailing zero fraction digits */
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* The remainder for the above division.    Same as `b1' - (`b1' / `b2') * 'b2'.    Note that the value depends on the number of fraction digits    that were kept in computing `b1' / `b2';    the argument `digits' specifies this.     The remainder has the same sign as the dividend.    The divisor's sign is ignored.  */
end_comment

begin_function
name|decimal
name|decimal_rem
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|,
name|digits
parameter_list|)
name|decimal
name|b1
decl_stmt|,
name|b2
decl_stmt|;
name|int
name|digits
decl_stmt|;
block|{
name|decimal
name|b1copy
init|=
name|decimal_copy_1
argument_list|(
name|b1
argument_list|,
name|b2
operator|->
name|after
operator|+
name|digits
argument_list|)
decl_stmt|;
name|int
name|length1
init|=
name|LENGTH
argument_list|(
name|b1copy
argument_list|)
decl_stmt|;
name|int
name|length2
init|=
name|LENGTH
argument_list|(
name|b2
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|leading_divisor_digits
init|=
name|b2
operator|->
name|contents
index|[
name|length2
operator|-
literal|1
index|]
operator|*
name|RADIX
decl_stmt|;
if|if
condition|(
name|length2
operator|>
literal|1
condition|)
name|leading_divisor_digits
operator|+=
name|b2
operator|->
name|contents
index|[
name|length2
operator|-
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|decimal_zerop
argument_list|(
name|b2
argument_list|)
condition|)
block|{
name|decimal_error
argument_list|(
literal|"divisor is zero"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decimal_copy
argument_list|(
name|DECIMAL_ZERO
argument_list|)
return|;
block|}
comment|/* Do like division, above, but throw away the quotient.      Keep only the final `rest of dividend', which becomes the remainder.  */
for|for
control|(
name|i
operator|=
name|length1
operator|-
name|length2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|guess
decl_stmt|;
name|int
name|trial_dividend
init|=
name|b1copy
operator|->
name|contents
index|[
name|length2
operator|+
name|i
operator|-
literal|1
index|]
operator|*
name|RADIX
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|length1
operator|-
name|length2
condition|)
name|trial_dividend
operator|+=
name|b1copy
operator|->
name|contents
index|[
name|length2
operator|+
name|i
index|]
operator|*
name|RADIX
operator|*
name|RADIX
expr_stmt|;
if|if
condition|(
name|length2
operator|+
name|i
operator|>
literal|1
condition|)
name|trial_dividend
operator|+=
name|b1copy
operator|->
name|contents
index|[
name|length2
operator|+
name|i
operator|-
literal|2
index|]
expr_stmt|;
name|guess
operator|=
name|trial_dividend
operator|/
name|leading_divisor_digits
expr_stmt|;
if|if
condition|(
name|guess
operator|&&
literal|0
operator|>
name|subtract_scaled
argument_list|(
name|b1copy
argument_list|,
name|b2
argument_list|,
name|guess
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|guess
operator|--
expr_stmt|;
name|add_scaled
argument_list|(
name|b1copy
argument_list|,
name|b2
argument_list|,
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* No need to check whether guess exceeds RADIX 	 since we are not saving guess.  */
block|}
comment|/* flush leading nonfraction zero digits */
block|{
name|char
modifier|*
name|pr
init|=
name|b1copy
operator|->
name|contents
operator|+
name|length1
decl_stmt|;
while|while
condition|(
name|b1copy
operator|->
name|before
operator|&&
operator|*
operator|--
name|pr
operator|==
literal|0
condition|)
operator|(
name|b1copy
operator|->
name|before
operator|)
operator|--
expr_stmt|;
block|}
name|flush_trailing_digits
argument_list|(
name|b1copy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|b1copy
return|;
block|}
end_function

begin_comment
comment|/* returns negative number if we chose factor too large */
end_comment

begin_function
specifier|static
name|int
name|subtract_scaled
parameter_list|(
name|into
parameter_list|,
name|from
parameter_list|,
name|factor
parameter_list|,
name|scale
parameter_list|)
name|decimal
name|into
decl_stmt|,
name|from
decl_stmt|;
name|int
name|factor
decl_stmt|,
name|scale
decl_stmt|;
block|{
name|char
modifier|*
name|pf
init|=
name|from
operator|->
name|contents
decl_stmt|;
name|char
modifier|*
name|pi
init|=
name|into
operator|->
name|contents
operator|+
name|scale
decl_stmt|;
name|int
name|lengthf
init|=
name|LENGTH
argument_list|(
name|from
argument_list|)
decl_stmt|;
name|int
name|lengthi
init|=
name|LENGTH
argument_list|(
name|into
argument_list|)
operator|-
name|scale
decl_stmt|;
name|int
name|accum
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lengthi
operator|&&
name|i
operator|<=
name|lengthf
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|lengthf
condition|)
name|accum
operator|-=
operator|*
name|pf
operator|++
operator|*
name|factor
expr_stmt|;
name|accum
operator|+=
operator|*
name|pi
expr_stmt|;
if|if
condition|(
name|accum
operator|<
literal|0
operator|&&
name|accum
operator|%
name|RADIX
condition|)
operator|*
name|pi
operator|=
name|RADIX
operator|-
operator|(
operator|-
name|accum
operator|)
operator|%
name|RADIX
expr_stmt|;
else|else
operator|*
name|pi
operator|=
name|accum
operator|%
name|RADIX
expr_stmt|;
name|accum
operator|-=
operator|*
name|pi
operator|++
expr_stmt|;
name|accum
operator|/=
name|RADIX
expr_stmt|;
block|}
return|return
name|accum
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the square root of decimal number D, using Newton's method.    Number of fraction digits returned is max of FRAC_DIGITS    and D's number of fraction digits.  */
end_comment

begin_function
name|decimal
name|decimal_sqrt
parameter_list|(
name|d
parameter_list|,
name|frac_digits
parameter_list|)
name|decimal
name|d
decl_stmt|;
name|int
name|frac_digits
decl_stmt|;
block|{
name|decimal
name|guess
decl_stmt|;
name|int
name|notdone
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|decimal_zerop
argument_list|(
name|d
argument_list|)
condition|)
return|return
name|d
return|;
if|if
condition|(
name|d
operator|->
name|sign
condition|)
block|{
name|decimal_error
argument_list|(
literal|"square root argument negative"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|decimal_copy
argument_list|(
name|DECIMAL_ZERO
argument_list|)
return|;
block|}
name|frac_digits
operator|=
name|MAX
argument_list|(
name|frac_digits
argument_list|,
name|d
operator|->
name|after
argument_list|)
expr_stmt|;
comment|/* Compute an initial guess by taking the square root      of a nearby power of RADIX.  */
if|if
condition|(
name|d
operator|->
name|before
condition|)
block|{
name|guess
operator|=
name|make_decimal
argument_list|(
operator|(
name|d
operator|->
name|before
operator|+
literal|1
operator|)
operator|/
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|guess
operator|->
name|contents
index|[
name|guess
operator|->
name|before
operator|-
literal|1
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Arg is less than 1; compute nearest power of RADIX */
name|char
modifier|*
name|p
init|=
name|d
operator|->
name|contents
operator|+
name|LENGTH
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|char
modifier|*
name|sp
init|=
name|p
decl_stmt|;
while|while
condition|(
operator|!
operator|*
operator|--
name|p
condition|)
empty_stmt|;
comment|/* Find most significant nonzero digit */
if|if
condition|(
name|sp
operator|-
name|p
operator|==
literal|1
condition|)
block|{
comment|/* Arg is bigger than 1/RADIX; use 1 as a guess */
name|guess
operator|=
name|decimal_copy
argument_list|(
name|DECIMAL_ONE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|guess
operator|=
name|make_decimal
argument_list|(
literal|0
argument_list|,
operator|(
name|sp
operator|-
name|p
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|guess
operator|->
name|contents
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Iterate doing guess = (guess + d/guess) / 2  */
while|while
condition|(
name|notdone
condition|)
block|{
name|decimal
name|tem1
init|=
name|decimal_div
argument_list|(
name|d
argument_list|,
name|guess
argument_list|,
name|frac_digits
operator|+
literal|1
argument_list|)
decl_stmt|;
name|decimal
name|tem2
init|=
name|decimal_add
argument_list|(
name|guess
argument_list|,
name|tem1
argument_list|)
decl_stmt|;
name|decimal
name|tem3
init|=
name|decimal_mul_rounded
argument_list|(
name|tem2
argument_list|,
name|DECIMAL_HALF
argument_list|,
name|frac_digits
argument_list|)
decl_stmt|;
name|notdone
operator|=
name|decimal_compare
argument_list|(
name|guess
argument_list|,
name|tem3
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tem1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tem2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|guess
argument_list|)
expr_stmt|;
name|guess
operator|=
name|tem3
expr_stmt|;
if|if
condition|(
name|decimal_zerop
argument_list|(
name|guess
argument_list|)
condition|)
return|return
name|guess
return|;
comment|/* Avoid divide-by-zero */
block|}
return|return
name|guess
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Raise decimal number `base' to power of integer part of decimal    number `expt'.    This function depends on using radix 10.    It is too hard to write it to work for any value of RADIX,    so instead it is simply not available if RADIX is not ten.  */
end_comment

begin_if
if|#
directive|if
operator|!
operator|(
name|RADIX
operator|-
literal|10
operator|)
end_if

begin_function
name|decimal
name|decimal_expt
parameter_list|(
name|base
parameter_list|,
name|expt
parameter_list|,
name|frac_digits
parameter_list|)
name|decimal
name|base
decl_stmt|,
name|expt
decl_stmt|;
name|int
name|frac_digits
decl_stmt|;
block|{
name|decimal
name|accum
init|=
name|decimal_copy
argument_list|(
name|DECIMAL_ONE
argument_list|)
decl_stmt|;
name|decimal
name|basis1
init|=
name|base
decl_stmt|;
name|int
name|digits
init|=
name|expt
operator|->
name|before
decl_stmt|;
name|int
name|dig
init|=
literal|0
decl_stmt|;
comment|/* Expt digit being processed */
if|if
condition|(
name|expt
operator|->
name|sign
condition|)
comment|/* If negative power, take reciprocal first thing      so that fraction digit truncation won't destroy      what will ultimately be nonfraction digits.  */
name|basis1
operator|=
name|decimal_div
argument_list|(
name|DECIMAL_ONE
argument_list|,
name|base
argument_list|,
name|frac_digits
argument_list|)
expr_stmt|;
while|while
condition|(
name|dig
operator|<
name|digits
condition|)
block|{
name|decimal
name|basis2
decl_stmt|,
name|basis4
decl_stmt|,
name|basis8
decl_stmt|,
name|basis10
decl_stmt|;
name|int
name|thisdigit
init|=
name|expt
operator|->
name|contents
index|[
name|expt
operator|->
name|after
operator|+
name|dig
index|]
decl_stmt|;
comment|/* Compute factors to multiply in for each bit of this digit */
name|basis2
operator|=
name|decimal_mul_rounded
argument_list|(
name|basis1
argument_list|,
name|basis1
argument_list|,
name|frac_digits
argument_list|)
expr_stmt|;
name|basis4
operator|=
name|decimal_mul_rounded
argument_list|(
name|basis2
argument_list|,
name|basis2
argument_list|,
name|frac_digits
argument_list|)
expr_stmt|;
name|basis8
operator|=
name|decimal_mul_rounded
argument_list|(
name|basis4
argument_list|,
name|basis4
argument_list|,
name|frac_digits
argument_list|)
expr_stmt|;
comment|/* Now accumulate the factors this digit value selects */
if|if
condition|(
name|thisdigit
operator|&
literal|1
condition|)
block|{
name|decimal
name|accum1
init|=
name|decimal_mul_rounded
argument_list|(
name|accum
argument_list|,
name|basis1
argument_list|,
name|frac_digits
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|accum
argument_list|)
expr_stmt|;
name|accum
operator|=
name|accum1
expr_stmt|;
block|}
if|if
condition|(
name|thisdigit
operator|&
literal|2
condition|)
block|{
name|decimal
name|accum1
init|=
name|decimal_mul_rounded
argument_list|(
name|accum
argument_list|,
name|basis2
argument_list|,
name|frac_digits
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|accum
argument_list|)
expr_stmt|;
name|accum
operator|=
name|accum1
expr_stmt|;
block|}
if|if
condition|(
name|thisdigit
operator|&
literal|4
condition|)
block|{
name|decimal
name|accum1
init|=
name|decimal_mul_rounded
argument_list|(
name|accum
argument_list|,
name|basis4
argument_list|,
name|frac_digits
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|accum
argument_list|)
expr_stmt|;
name|accum
operator|=
name|accum1
expr_stmt|;
block|}
if|if
condition|(
name|thisdigit
operator|&
literal|8
condition|)
block|{
name|decimal
name|accum1
init|=
name|decimal_mul_rounded
argument_list|(
name|accum
argument_list|,
name|basis8
argument_list|,
name|frac_digits
argument_list|)
decl_stmt|;
name|free
argument_list|(
name|accum
argument_list|)
expr_stmt|;
name|accum
operator|=
name|accum1
expr_stmt|;
block|}
comment|/* If there are further digits, compute the basis1 for the next digit */
if|if
condition|(
operator|++
name|dig
operator|<
name|digits
condition|)
name|basis10
operator|=
name|decimal_mul_rounded
argument_list|(
name|basis2
argument_list|,
name|basis8
argument_list|,
name|frac_digits
argument_list|)
expr_stmt|;
comment|/* Free intermediate results */
if|if
condition|(
name|basis1
operator|!=
name|base
condition|)
name|free
argument_list|(
name|basis1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|basis2
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|basis4
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|basis8
argument_list|)
expr_stmt|;
name|basis1
operator|=
name|basis10
expr_stmt|;
block|}
return|return
name|accum
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_macro
name|fputchar
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Top level that can be used to test the arithmetic functions */
end_comment

begin_function
name|main
parameter_list|()
block|{
name|char
name|s1
index|[
literal|40
index|]
decl_stmt|,
name|s2
index|[
literal|40
index|]
decl_stmt|;
name|decimal
name|b1
decl_stmt|,
name|b2
decl_stmt|,
name|b3
decl_stmt|;
name|char
name|c
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|scanf
argument_list|(
literal|"%s %c %s"
argument_list|,
name|s1
argument_list|,
operator|&
name|c
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|b1
operator|=
name|decimal_parse
argument_list|(
name|s1
argument_list|,
name|RADIX
argument_list|)
expr_stmt|;
name|b2
operator|=
name|decimal_parse
argument_list|(
name|s2
argument_list|,
name|RADIX
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
name|c
operator|=
literal|'+'
expr_stmt|;
case|case
literal|'+'
case|:
name|b3
operator|=
name|decimal_add
argument_list|(
name|b1
argument_list|,
name|b2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|b3
operator|=
name|decimal_mul
argument_list|(
name|b1
argument_list|,
name|b2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|b3
operator|=
name|decimal_div
argument_list|(
name|b1
argument_list|,
name|b2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|b3
operator|=
name|decimal_rem
argument_list|(
name|b1
argument_list|,
name|b2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|decimal_print
argument_list|(
name|b1
argument_list|,
name|fputchar
argument_list|,
name|RADIX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" printed in base %d is "
argument_list|,
name|decimal_to_int
argument_list|(
name|b2
argument_list|)
argument_list|)
expr_stmt|;
name|decimal_print
argument_list|(
name|b1
argument_list|,
name|fputchar
argument_list|,
name|decimal_to_int
argument_list|(
name|b2
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
name|printf
argument_list|(
literal|"%s read in base %d is "
argument_list|,
name|s1
argument_list|,
name|decimal_to_int
argument_list|(
name|b2
argument_list|)
argument_list|)
expr_stmt|;
name|decimal_print
argument_list|(
name|decimal_parse
argument_list|(
name|s1
argument_list|,
name|decimal_to_int
argument_list|(
name|b2
argument_list|)
argument_list|)
argument_list|,
name|fputchar
argument_list|,
name|RADIX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|decimal_print
argument_list|(
name|b1
argument_list|,
name|fputchar
argument_list|,
name|RADIX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %c "
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|decimal_print
argument_list|(
name|b2
argument_list|,
name|fputchar
argument_list|,
name|RADIX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
name|decimal_print
argument_list|(
name|b3
argument_list|,
name|fputchar
argument_list|,
name|RADIX
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|decimal_error
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|pbi
parameter_list|(
name|b
parameter_list|)
name|int
name|b
decl_stmt|;
block|{
name|decimal_print
argument_list|(
operator|(
name|decimal
operator|)
name|b
argument_list|,
name|fputchar
argument_list|,
name|RADIX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pb
parameter_list|(
name|b
parameter_list|)
name|decimal
name|b
decl_stmt|;
block|{
name|decimal_print
argument_list|(
name|b
argument_list|,
name|fputchar
argument_list|,
name|RADIX
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

