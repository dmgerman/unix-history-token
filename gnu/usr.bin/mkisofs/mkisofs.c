begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Program mkisofs.c - generate iso9660 filesystem  based upon directory  * tree on hard disk.     Written by Eric Youngdale (1993).     Copyright 1993 Yggdrasil Computing, Incorporated     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* ADD_FILES changes made by Ross Biro biro@yggdrasil.com 2/23/95 */
end_comment

begin_include
include|#
directive|include
file|"mkisofs.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|linux
end_ifdef

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"iso9660.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"vms.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"exclude.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|directory
modifier|*
name|root
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|version_string
index|[]
init|=
literal|"mkisofs v1.04"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|discimage
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|next_extent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|last_extent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|path_table_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|path_table
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|path_blocks
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iso_directory_record
name|root_record
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|timezone_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|extension_record
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|extension_record_extent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|extension_record_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These variables are associated with command line options */
end_comment

begin_decl_stmt
name|int
name|use_RockRidge
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|all_files
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|follow_links
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|generate_tables
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|preparer
init|=
name|PREPARER_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|publisher
init|=
name|PUBLISHER_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|appid
init|=
name|APPID_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|copyright
init|=
name|COPYRIGHT_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|biblio
init|=
name|BIBLIO_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|abstract
init|=
name|ABSTRACT_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|volset_id
init|=
name|VOLSET_ID_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|volume_id
init|=
name|VOLUME_ID_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|system_id
init|=
name|SYSTEM_ID_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|omit_period
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Violates iso9660, but these are a pain */
end_comment

begin_decl_stmt
name|int
name|transparent_compression
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* So far only works with linux */
end_comment

begin_decl_stmt
name|int
name|omit_version_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* May violate iso9660, but noone uses vers*/
end_comment

begin_decl_stmt
name|int
name|RR_relocation_depth
init|=
literal|6
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Violates iso9660, but most systems work */
end_comment

begin_decl_stmt
name|int
name|full_iso9660_filenames
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used with Amiga.  Disc will not work with 				  DOS */
end_comment

begin_decl_stmt
name|int
name|allow_leading_dots
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DOS cannot read names with leading dots */
end_comment

begin_struct
struct|struct
name|rcopts
block|{
name|char
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
modifier|*
name|variable
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|rcopts
name|rcopt
index|[]
init|=
block|{
block|{
literal|"PREP"
block|,
operator|&
name|preparer
block|}
block|,
block|{
literal|"PUBL"
block|,
operator|&
name|publisher
block|}
block|,
block|{
literal|"APPI"
block|,
operator|&
name|appid
block|}
block|,
block|{
literal|"COPY"
block|,
operator|&
name|copyright
block|}
block|,
block|{
literal|"BIBL"
block|,
operator|&
name|biblio
block|}
block|,
block|{
literal|"ABST"
block|,
operator|&
name|abstract
block|}
block|,
block|{
literal|"VOLS"
block|,
operator|&
name|volset_id
block|}
block|,
block|{
literal|"VOLI"
block|,
operator|&
name|volume_id
block|}
block|,
block|{
literal|"SYSI"
block|,
operator|&
name|system_id
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ultrix
end_ifdef

begin_function
name|char
modifier|*
name|strdup
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|c
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
condition|)
name|strcpy
argument_list|(
name|c
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|FDECL1
parameter_list|(
name|read_rcfile
parameter_list|,
name|char
modifier|*
parameter_list|,
name|appname
parameter_list|)
block|{
name|FILE
modifier|*
name|rcfile
decl_stmt|;
name|struct
name|rcopts
modifier|*
name|rco
decl_stmt|;
name|char
modifier|*
name|pnt
decl_stmt|,
modifier|*
name|pnt1
decl_stmt|;
name|char
name|linebuffer
index|[
literal|256
index|]
decl_stmt|;
name|rcfile
operator|=
name|fopen
argument_list|(
literal|".mkisofsrc"
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rcfile
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|appname
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|".mkisofsrc"
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|linebuffer
argument_list|)
condition|)
return|return;
name|strcpy
argument_list|(
name|linebuffer
argument_list|,
name|appname
argument_list|)
expr_stmt|;
name|pnt
operator|=
name|strrchr
argument_list|(
name|linebuffer
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pnt
condition|)
return|return;
name|pnt
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|pnt
argument_list|,
literal|".mkisofsrc"
argument_list|)
expr_stmt|;
name|rcfile
operator|=
name|fopen
argument_list|(
name|linebuffer
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using %s.\n"
argument_list|,
name|linebuffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using ./.mkisofsrc.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rcfile
condition|)
return|return;
comment|/* OK, we got it.  Now read in the lines and parse them */
while|while
condition|(
operator|!
name|feof
argument_list|(
name|rcfile
argument_list|)
condition|)
block|{
name|fgets
argument_list|(
name|linebuffer
argument_list|,
sizeof|sizeof
argument_list|(
name|linebuffer
argument_list|)
argument_list|,
name|rcfile
argument_list|)
expr_stmt|;
name|pnt
operator|=
name|linebuffer
expr_stmt|;
while|while
condition|(
literal|1
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|pnt
operator|==
literal|' '
operator|||
operator|*
name|pnt
operator|==
literal|'\t'
operator|||
operator|*
name|pnt
operator|==
literal|'\n'
operator|||
operator|*
name|pnt
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|islower
argument_list|(
operator|*
name|pnt
argument_list|)
condition|)
operator|*
name|pnt
operator|=
name|toupper
argument_list|(
operator|*
name|pnt
argument_list|)
expr_stmt|;
name|pnt
operator|++
expr_stmt|;
block|}
comment|/* OK, now find the '=' sign */
while|while
condition|(
operator|*
name|pnt
operator|&&
operator|*
name|pnt
operator|!=
literal|'='
operator|&&
operator|*
name|pnt
operator|!=
literal|'#'
condition|)
name|pnt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'#'
condition|)
continue|continue;
comment|/* SKip comment */
if|if
condition|(
operator|*
name|pnt
operator|!=
literal|'='
condition|)
continue|continue;
comment|/* Skip to next line */
name|pnt
operator|++
expr_stmt|;
comment|/* Skip past '=' sign */
while|while
condition|(
operator|*
name|pnt
operator|==
literal|' '
operator|||
operator|*
name|pnt
operator|==
literal|'\t'
condition|)
name|pnt
operator|++
expr_stmt|;
comment|/* And skip past whitespace */
comment|/* Now get rid of trailing newline */
name|pnt1
operator|=
name|pnt
expr_stmt|;
while|while
condition|(
operator|*
name|pnt1
condition|)
block|{
if|if
condition|(
operator|*
name|pnt1
operator|==
literal|'\n'
condition|)
operator|*
name|pnt1
operator|=
literal|0
expr_stmt|;
else|else
name|pnt1
operator|++
expr_stmt|;
block|}
empty_stmt|;
name|pnt1
operator|=
name|linebuffer
expr_stmt|;
while|while
condition|(
operator|*
name|pnt1
operator|==
literal|' '
operator|||
operator|*
name|pnt1
operator|==
literal|'\t'
condition|)
name|pnt1
operator|++
expr_stmt|;
comment|/* OK, now figure out which option we have */
for|for
control|(
name|rco
operator|=
name|rcopt
init|;
name|rco
operator|->
name|tag
condition|;
name|rco
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|rco
operator|->
name|tag
argument_list|,
name|pnt1
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|rco
operator|->
name|variable
operator|=
name|strdup
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|rcfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|char
modifier|*
name|path_table_l
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|path_table_m
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|goof
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mkisofs [-o outfile] [-R] [-V volid] [-v] [-a] \ [-T]\n [-l] [-d] [-V] [-D] [-L] [-p preparer] \ [-P publisher] [ -A app_id ] [-z] \ [-x path -x path ...] path\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|get_iso9660_timezone_offset
parameter_list|()
block|{
name|struct
name|tm
name|gm
decl_stmt|;
name|struct
name|tm
modifier|*
name|pt
decl_stmt|;
name|time_t
name|ctime
decl_stmt|;
name|int
name|local_min
decl_stmt|,
name|gmt_min
decl_stmt|;
name|time
argument_list|(
operator|&
name|ctime
argument_list|)
expr_stmt|;
name|pt
operator|=
name|gmtime
argument_list|(
operator|&
name|ctime
argument_list|)
expr_stmt|;
name|gm
operator|=
operator|*
name|pt
expr_stmt|;
name|pt
operator|=
name|localtime
argument_list|(
operator|&
name|ctime
argument_list|)
expr_stmt|;
if|if
condition|(
name|gm
operator|.
name|tm_year
operator|<
name|pt
operator|->
name|tm_year
condition|)
name|gm
operator|.
name|tm_yday
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|gm
operator|.
name|tm_year
operator|>
name|pt
operator|->
name|tm_year
condition|)
name|pt
operator|->
name|tm_yday
operator|=
operator|-
literal|1
expr_stmt|;
name|gmt_min
operator|=
name|gm
operator|.
name|tm_min
operator|+
literal|60
operator|*
operator|(
name|gm
operator|.
name|tm_hour
operator|+
literal|24
operator|*
name|gm
operator|.
name|tm_yday
operator|)
expr_stmt|;
name|local_min
operator|=
name|pt
operator|->
name|tm_min
operator|+
literal|60
operator|*
operator|(
name|pt
operator|->
name|tm_hour
operator|+
literal|24
operator|*
name|pt
operator|->
name|tm_yday
operator|)
expr_stmt|;
return|return
operator|(
name|gmt_min
operator|-
name|local_min
operator|)
operator|/
literal|15
return|;
block|}
end_function

begin_comment
comment|/* Fill in date in the iso9660 format */
end_comment

begin_function
name|int
name|FDECL2
parameter_list|(
name|iso9660_date
parameter_list|,
name|char
modifier|*
parameter_list|,
name|result
parameter_list|,
name|time_t
parameter_list|,
name|ctime
parameter_list|)
block|{
name|struct
name|tm
modifier|*
name|local
decl_stmt|;
name|local
operator|=
name|localtime
argument_list|(
operator|&
name|ctime
argument_list|)
expr_stmt|;
name|result
index|[
literal|0
index|]
operator|=
name|local
operator|->
name|tm_year
expr_stmt|;
name|result
index|[
literal|1
index|]
operator|=
name|local
operator|->
name|tm_mon
operator|+
literal|1
expr_stmt|;
name|result
index|[
literal|2
index|]
operator|=
name|local
operator|->
name|tm_mday
expr_stmt|;
name|result
index|[
literal|3
index|]
operator|=
name|local
operator|->
name|tm_hour
expr_stmt|;
name|result
index|[
literal|4
index|]
operator|=
name|local
operator|->
name|tm_min
expr_stmt|;
name|result
index|[
literal|5
index|]
operator|=
name|local
operator|->
name|tm_sec
expr_stmt|;
name|result
index|[
literal|6
index|]
operator|=
name|timezone_offset
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|FDECL3
parameter_list|(
name|iso9660_file_length
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|name
parameter_list|,
name|struct
name|directory_entry
modifier|*
parameter_list|,
name|sresult
parameter_list|,
name|int
parameter_list|,
name|dirflag
parameter_list|)
block|{
name|int
name|seen_dot
init|=
literal|0
decl_stmt|;
name|int
name|seen_semic
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
name|int
name|priority
init|=
literal|32767
decl_stmt|;
name|int
name|tildes
init|=
literal|0
decl_stmt|;
name|int
name|ignore
init|=
literal|0
decl_stmt|;
name|int
name|extra
init|=
literal|0
decl_stmt|;
name|int
name|current_length
init|=
literal|0
decl_stmt|;
name|int
name|chars_after_dot
init|=
literal|0
decl_stmt|;
name|int
name|chars_before_dot
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|pnt
decl_stmt|;
name|result
operator|=
name|sresult
operator|->
name|isorec
operator|.
name|name
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|result
condition|)
operator|*
name|result
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
empty_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|result
condition|)
block|{
operator|*
name|result
operator|++
operator|=
literal|1
expr_stmt|;
operator|*
name|result
operator|++
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
empty_stmt|;
name|pnt
operator|=
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|pnt
condition|)
block|{
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
name|strcmp
argument_list|(
name|pnt
argument_list|,
literal|".DIR;1"
argument_list|)
operator|==
literal|0
condition|)
break|break;
endif|#
directive|endif
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'#'
condition|)
block|{
name|priority
operator|=
literal|1
expr_stmt|;
name|pnt
operator|++
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'~'
condition|)
block|{
name|priority
operator|=
literal|1
expr_stmt|;
name|tildes
operator|++
expr_stmt|;
name|pnt
operator|++
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|';'
condition|)
block|{
name|seen_semic
operator|=
literal|1
expr_stmt|;
operator|*
name|result
operator|++
operator|=
operator|*
name|pnt
operator|++
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
if|if
condition|(
name|ignore
condition|)
block|{
name|pnt
operator|++
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
if|if
condition|(
name|seen_semic
condition|)
block|{
if|if
condition|(
operator|*
name|pnt
operator|>=
literal|'0'
operator|&&
operator|*
name|pnt
operator|<=
literal|'9'
condition|)
operator|*
name|result
operator|++
operator|=
operator|*
name|pnt
expr_stmt|;
name|extra
operator|++
expr_stmt|;
name|pnt
operator|++
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
if|if
condition|(
name|full_iso9660_filenames
condition|)
block|{
comment|/* Here we allow a more relaxed syntax. */
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|seen_dot
condition|)
block|{
name|ignore
operator|++
expr_stmt|;
continue|continue;
block|}
name|seen_dot
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|current_length
operator|<
literal|30
condition|)
operator|*
name|result
operator|++
operator|=
operator|(
name|islower
argument_list|(
operator|*
name|pnt
argument_list|)
condition|?
name|toupper
argument_list|(
operator|*
name|pnt
argument_list|)
else|:
operator|*
name|pnt
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Dos style filenames */
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|!
name|chars_before_dot
operator|&&
operator|!
name|allow_leading_dots
condition|)
block|{
comment|/* DOS can't read files with dot first */
name|chars_before_dot
operator|++
expr_stmt|;
if|if
condition|(
name|result
condition|)
operator|*
name|result
operator|++
operator|=
literal|'_'
expr_stmt|;
comment|/* Substitute underscore */
block|}
else|else
block|{
if|if
condition|(
name|seen_dot
condition|)
block|{
name|ignore
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|result
condition|)
operator|*
name|result
operator|++
operator|=
literal|'.'
expr_stmt|;
name|seen_dot
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|seen_dot
condition|)
block|{
if|if
condition|(
name|chars_after_dot
operator|<
literal|3
condition|)
block|{
name|chars_after_dot
operator|++
expr_stmt|;
if|if
condition|(
name|result
condition|)
operator|*
name|result
operator|++
operator|=
operator|(
name|islower
argument_list|(
operator|*
name|pnt
argument_list|)
condition|?
name|toupper
argument_list|(
operator|*
name|pnt
argument_list|)
else|:
operator|*
name|pnt
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|chars_before_dot
operator|<
literal|8
condition|)
block|{
name|chars_before_dot
operator|++
expr_stmt|;
if|if
condition|(
name|result
condition|)
operator|*
name|result
operator|++
operator|=
operator|(
name|islower
argument_list|(
operator|*
name|pnt
argument_list|)
condition|?
name|toupper
argument_list|(
operator|*
name|pnt
argument_list|)
else|:
operator|*
name|pnt
operator|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
name|current_length
operator|++
expr_stmt|;
name|pnt
operator|++
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|tildes
operator|==
literal|2
condition|)
block|{
name|int
name|prio1
init|=
literal|0
decl_stmt|;
name|pnt
operator|=
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|pnt
operator|&&
operator|*
name|pnt
operator|!=
literal|'~'
condition|)
name|pnt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
condition|)
name|pnt
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|pnt
operator|&&
operator|*
name|pnt
operator|!=
literal|'~'
condition|)
block|{
name|prio1
operator|=
literal|10
operator|*
name|prio1
operator|+
operator|*
name|pnt
operator|-
literal|'0'
expr_stmt|;
name|pnt
operator|++
expr_stmt|;
block|}
empty_stmt|;
name|priority
operator|=
name|prio1
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|!
name|dirflag
condition|)
block|{
if|if
condition|(
operator|!
name|seen_dot
operator|&&
operator|!
name|omit_period
condition|)
block|{
if|if
condition|(
name|result
condition|)
operator|*
name|result
operator|++
operator|=
literal|'.'
expr_stmt|;
name|extra
operator|++
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|!
name|omit_version_number
operator|&&
operator|!
name|seen_semic
condition|)
block|{
if|if
condition|(
name|result
condition|)
block|{
operator|*
name|result
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|result
operator|++
operator|=
literal|'1'
expr_stmt|;
block|}
empty_stmt|;
name|extra
operator|+=
literal|2
expr_stmt|;
block|}
block|}
empty_stmt|;
if|if
condition|(
name|result
condition|)
operator|*
name|result
operator|++
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|1
comment|/* WALNUT CREEK HACKS -- rab 950126 */
block|{
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|r
decl_stmt|;
name|assert
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|omit_version_number
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|omit_period
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|extra
operator|==
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
name|sresult
operator|->
name|isorec
operator|.
name|name
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|assert
argument_list|(
name|seen_dot
operator|&&
name|chars_after_dot
operator|==
literal|0
argument_list|)
expr_stmt|;
name|r
index|[
operator|--
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|seen_dot
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|c
operator|=
name|r
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|dirflag
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"changing DIR %s to "
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|r
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|chars_after_dot
operator|=
literal|0
expr_stmt|;
name|seen_dot
operator|=
literal|0
expr_stmt|;
name|extra
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'_'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"changing %s to "
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|r
index|[
name|i
index|]
operator|=
literal|'_'
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
name|sresult
operator|->
name|priority
operator|=
name|priority
expr_stmt|;
return|return
name|chars_before_dot
operator|+
name|chars_after_dot
operator|+
name|seen_dot
operator|+
name|extra
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ADD_FILES
end_ifdef

begin_decl_stmt
name|struct
name|file_adds
modifier|*
name|root_file_adds
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|FDECL2
parameter_list|(
name|add_one_file
parameter_list|,
name|char
modifier|*
parameter_list|,
name|addpath
parameter_list|,
name|char
modifier|*
parameter_list|,
name|path
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|file_adds
modifier|*
name|f
decl_stmt|;
name|struct
name|file_adds
modifier|*
name|tmp
decl_stmt|;
name|f
operator|=
name|root_file_adds
expr_stmt|;
name|tmp
operator|=
name|NULL
expr_stmt|;
name|name
operator|=
name|rindex
argument_list|(
name|addpath
argument_list|,
name|PATH_SEPARATOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|name
operator|=
name|addpath
expr_stmt|;
block|}
else|else
block|{
name|name
operator|++
expr_stmt|;
block|}
name|cp
operator|=
name|strtok
argument_list|(
name|addpath
argument_list|,
name|SPATH_SEPARATOR
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|cp
argument_list|)
condition|)
block|{
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|root_file_adds
operator|=
name|e_malloc
argument_list|(
sizeof|sizeof
expr|*
name|root_file_adds
argument_list|)
expr_stmt|;
name|f
operator|=
name|root_file_adds
expr_stmt|;
name|f
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|child
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|add_count
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|adds
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|used
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|->
name|child
condition|)
block|{
for|for
control|(
name|tmp
operator|=
name|f
operator|->
name|child
init|;
name|tmp
operator|->
name|next
operator|!=
name|NULL
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tmp
operator|->
name|name
argument_list|,
name|cp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|f
operator|=
name|tmp
expr_stmt|;
goto|goto
name|next
goto|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|tmp
operator|->
name|name
argument_list|,
name|cp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|f
operator|=
name|tmp
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* add a new node. */
name|tmp
operator|->
name|next
operator|=
name|e_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tmp
operator|->
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
name|f
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|f
operator|->
name|child
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|add_count
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|adds
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|used
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* no children. */
name|f
operator|->
name|child
operator|=
name|e_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|f
operator|->
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
name|f
operator|->
name|child
expr_stmt|;
name|f
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|f
operator|->
name|child
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|add_count
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|adds
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|used
operator|=
literal|0
expr_stmt|;
block|}
name|next
label|:
name|cp
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
name|SPATH_SEPARATOR
argument_list|)
expr_stmt|;
block|}
comment|/* Now f if non-null points to where we should add things */
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|root_file_adds
operator|=
name|e_malloc
argument_list|(
sizeof|sizeof
expr|*
name|root_file_adds
argument_list|)
expr_stmt|;
name|f
operator|=
name|root_file_adds
expr_stmt|;
name|f
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|child
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|f
operator|->
name|add_count
operator|=
literal|0
expr_stmt|;
name|f
operator|->
name|adds
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now f really points to where we should add this name. */
name|f
operator|->
name|add_count
operator|++
expr_stmt|;
name|f
operator|->
name|adds
operator|=
name|realloc
argument_list|(
name|f
operator|->
name|adds
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
operator|->
name|adds
argument_list|)
operator|*
name|f
operator|->
name|add_count
argument_list|)
expr_stmt|;
name|f
operator|->
name|adds
index|[
name|f
operator|->
name|add_count
operator|-
literal|1
index|]
operator|.
name|path
operator|=
name|strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|f
operator|->
name|adds
index|[
name|f
operator|->
name|add_count
operator|-
literal|1
index|]
operator|.
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|FDECL3
parameter_list|(
name|add_file_list
parameter_list|,
name|int
parameter_list|,
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|argv
parameter_list|,
name|int
parameter_list|,
name|ind
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|dup_arg
decl_stmt|;
while|while
condition|(
name|ind
operator|<
name|argc
condition|)
block|{
name|dup_arg
operator|=
name|strdup
argument_list|(
name|argv
index|[
name|ind
index|]
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|index
argument_list|(
name|dup_arg
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dup_arg
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
name|add_one_file
argument_list|(
name|dup_arg
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dup_arg
argument_list|)
expr_stmt|;
name|ind
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|FDECL1
parameter_list|(
name|add_file
parameter_list|,
name|char
modifier|*
parameter_list|,
name|filename
parameter_list|)
block|{
name|char
name|buff
index|[
literal|1024
index|]
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|p2
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|f
operator|=
name|stdin
expr_stmt|;
block|}
else|else
block|{
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"fopen"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buff
argument_list|,
literal|1024
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|ptr
operator|=
name|buff
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'#'
condition|)
continue|continue;
if|if
condition|(
name|ptr
index|[
name|strlen
argument_list|(
name|ptr
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|ptr
index|[
name|strlen
argument_list|(
name|ptr
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|p2
operator|=
name|index
argument_list|(
name|ptr
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error in line %d: %s\n"
argument_list|,
name|count
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|p2
operator|=
literal|0
expr_stmt|;
name|p2
operator|++
expr_stmt|;
name|add_one_file
argument_list|(
name|ptr
argument_list|,
name|p2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|FDECL2
argument_list|(
expr|main
argument_list|,
name|int
argument_list|,
name|argc
argument_list|,
name|char
operator|*
operator|*
argument_list|,
name|argv
argument_list|)
block|{
name|char
modifier|*
name|outfile
decl_stmt|;
name|struct
name|directory_entry
name|de
decl_stmt|;
name|unsigned
name|int
name|mem_start
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|char
modifier|*
name|scan_tree
decl_stmt|;
name|int
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|ADD_FILES
name|char
modifier|*
name|add_file_file
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* Get the defaults from the .mkisofsrc file */
name|read_rcfile
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|outfile
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"i:o:V:RfvaTp:P:x:dDlLNzA:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'p'
case|:
name|preparer
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|preparer
argument_list|)
operator|>
literal|128
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Preparer string too long\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
case|case
literal|'P'
case|:
name|publisher
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|publisher
argument_list|)
operator|>
literal|128
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Publisher string too long\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
case|case
literal|'A'
case|:
name|appid
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|appid
argument_list|)
operator|>
literal|128
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Application-id string too long\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
case|case
literal|'d'
case|:
name|omit_period
operator|++
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|RR_relocation_depth
operator|=
literal|32767
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|full_iso9660_filenames
operator|++
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|allow_leading_dots
operator|++
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|omit_version_number
operator|++
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|outfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|follow_links
operator|++
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|use_RockRidge
operator|++
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|volume_id
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|all_files
operator|++
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|generate_tables
operator|++
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
ifdef|#
directive|ifdef
name|VMS
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Transparent compression not supported with VMS\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|transparent_compression
operator|++
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'x'
case|:
name|exclude
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
ifdef|#
directive|ifdef
name|ADD_FILES
name|add_file_file
operator|=
name|optarg
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__NetBSD__
block|{
name|int
name|resource
decl_stmt|;
name|struct
name|rlimit
name|rlp
decl_stmt|;
if|if
condition|(
name|getrlimit
argument_list|(
name|RLIMIT_DATA
argument_list|,
operator|&
name|rlp
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
literal|"Warning: getrlimit"
argument_list|)
expr_stmt|;
else|else
block|{
name|rlp
operator|.
name|rlim_cur
operator|=
literal|33554432
expr_stmt|;
if|if
condition|(
name|setrlimit
argument_list|(
name|RLIMIT_DATA
argument_list|,
operator|&
name|rlp
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
literal|"Warning: setrlimit"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|mem_start
operator|=
operator|(
name|unsigned
name|int
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
comment|/* Now find the timezone offset */
name|timezone_offset
operator|=
name|get_iso9660_timezone_offset
argument_list|()
expr_stmt|;
comment|/*  The first step is to scan the directory tree, and take some notes */
name|scan_tree
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|ADD_FILES
if|if
condition|(
name|add_file_file
condition|)
block|{
name|add_file
argument_list|(
name|add_file_file
argument_list|)
expr_stmt|;
block|}
name|add_file_list
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|optind
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|scan_tree
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
ifndef|#
directive|ifndef
name|VMS
if|if
condition|(
name|scan_tree
index|[
name|strlen
argument_list|(
name|scan_tree
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|scan_tree
operator|=
operator|(
name|char
operator|*
operator|)
name|e_malloc
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|scan_tree
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|scan_tree
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
endif|#
directive|endif
if|if
condition|(
name|use_RockRidge
condition|)
block|{
if|#
directive|if
literal|1
name|extension_record
operator|=
name|generate_rr_extension_record
argument_list|(
literal|"RRIP_1991A"
argument_list|,
literal|"THE ROCK RIDGE INTERCHANGE PROTOCOL PROVIDES SUPPORT FOR POSIX FILE SYSTEM SEMANTICS"
argument_list|,
literal|"PLEASE CONTACT DISC PUBLISHER FOR SPECIFICATION SOURCE.  SEE PUBLISHER IDENTIFIER IN PRIMARY VOLUME DESCRIPTOR FOR CONTACT INFORMATION."
argument_list|,
operator|&
name|extension_record_size
argument_list|)
expr_stmt|;
else|#
directive|else
name|extension_record
operator|=
name|generate_rr_extension_record
argument_list|(
literal|"IEEE_P1282"
argument_list|,
literal|"THE IEEE P1282 PROTOCOL PROVIDES SUPPORT FOR POSIX FILE SYSTEM SEMANTICS"
argument_list|,
literal|"PLEASE CONTACT THE IEEE STANDARDS DEPARTMENT, PISCATAWAY, NJ, USA FOR THE P1282 SPECIFICATION."
argument_list|,
operator|&
name|extension_record_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
empty_stmt|;
name|stat
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
name|add_directory_hash
argument_list|(
name|statbuf
operator|.
name|st_dev
argument_list|,
name|STAT_INODE
argument_list|(
name|statbuf
argument_list|)
argument_list|)
expr_stmt|;
name|de
operator|.
name|filedir
operator|=
name|root
expr_stmt|;
comment|/* We need this to bootstrap */
name|scan_directory_tree
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
operator|&
name|de
argument_list|)
expr_stmt|;
name|root
operator|->
name|self
operator|=
name|root
operator|->
name|contents
expr_stmt|;
comment|/* Fix this up so that the path tables get done right */
if|if
condition|(
name|reloc_dir
condition|)
name|sort_n_finish
argument_list|(
name|reloc_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|goof
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
condition|)
block|{
name|discimage
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|discimage
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to open disc image file\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
else|else
name|discimage
operator|=
name|stdout
expr_stmt|;
comment|/* Now assign addresses on the disc for the path table. */
name|path_blocks
operator|=
operator|(
name|path_table_size
operator|+
operator|(
name|SECTOR_SIZE
operator|-
literal|1
operator|)
operator|)
operator|>>
literal|11
expr_stmt|;
if|if
condition|(
name|path_blocks
operator|&
literal|1
condition|)
name|path_blocks
operator|++
expr_stmt|;
name|path_table
index|[
literal|0
index|]
operator|=
literal|0x14
expr_stmt|;
name|path_table
index|[
literal|1
index|]
operator|=
name|path_table
index|[
literal|0
index|]
operator|+
name|path_blocks
expr_stmt|;
name|path_table
index|[
literal|2
index|]
operator|=
name|path_table
index|[
literal|1
index|]
operator|+
name|path_blocks
expr_stmt|;
name|path_table
index|[
literal|3
index|]
operator|=
name|path_table
index|[
literal|2
index|]
operator|+
name|path_blocks
expr_stmt|;
name|last_extent
operator|=
name|path_table
index|[
literal|3
index|]
operator|+
name|path_blocks
expr_stmt|;
comment|/* The next free block */
comment|/* The next step is to go through the directory tree and assign extent      numbers for all of the directories */
name|assign_directory_addresses
argument_list|(
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
name|extension_record
condition|)
block|{
name|struct
name|directory_entry
modifier|*
name|s_entry
decl_stmt|;
name|extension_record_extent
operator|=
name|last_extent
operator|++
expr_stmt|;
name|s_entry
operator|=
name|root
operator|->
name|contents
expr_stmt|;
name|set_733
argument_list|(
name|s_entry
operator|->
name|rr_attributes
operator|+
name|s_entry
operator|->
name|rr_attr_size
operator|-
literal|24
argument_list|,
name|extension_record_extent
argument_list|)
expr_stmt|;
name|set_733
argument_list|(
name|s_entry
operator|->
name|rr_attributes
operator|+
name|s_entry
operator|->
name|rr_attr_size
operator|-
literal|8
argument_list|,
name|extension_record_size
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|use_RockRidge
operator|&&
name|reloc_dir
condition|)
name|finish_cl_pl_entries
argument_list|()
expr_stmt|;
comment|/* Now we generate the path tables that are used by DOS to improve directory      access times. */
name|generate_path_tables
argument_list|()
expr_stmt|;
comment|/* Generate root record for volume descriptor. */
name|generate_root_record
argument_list|()
expr_stmt|;
name|dump_tree
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|iso_write
argument_list|(
name|discimage
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Max brk space used %x\n"
argument_list|,
operator|(
operator|(
name|unsigned
name|int
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
operator|)
operator|-
name|mem_start
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d extents written (%d Mb)\n"
argument_list|,
name|last_extent
argument_list|,
name|last_extent
operator|>>
literal|9
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
return|return
literal|1
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_function
name|void
modifier|*
name|e_malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|pt
decl_stmt|;
if|if
condition|(
operator|(
name|pt
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Not enougth memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|pt
return|;
block|}
end_function

end_unit

