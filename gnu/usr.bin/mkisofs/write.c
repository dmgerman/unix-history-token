begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Program write.c - dump memory  structures to  file for iso9660 filesystem.     Written by Eric Youngdale (1993).     Copyright 1993 Yggdrasil Computing, Incorporated     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"mkisofs.h"
end_include

begin_include
include|#
directive|include
file|"iso9660.h"
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__svr4__
end_ifdef

begin_function_decl
specifier|extern
name|char
modifier|*
name|strdup
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_function_decl
specifier|extern
name|char
modifier|*
name|strdup
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Max number of sectors we will write at  one time */
end_comment

begin_define
define|#
directive|define
name|NSECT
value|16
end_define

begin_comment
comment|/* Counters for statistics */
end_comment

begin_decl_stmt
specifier|static
name|int
name|table_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|total_dir_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rockridge_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|directory
modifier|*
modifier|*
name|pathlist
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|next_path_index
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Used to fill in some  of the information in the volume descriptor. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|tm
modifier|*
name|local
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Routines to actually write the disc.  We write sequentially so that    we could write a tape, or write the disc directly */
end_comment

begin_define
define|#
directive|define
name|FILL_SPACE
parameter_list|(
name|X
parameter_list|)
value|memset(vol_desc.X, ' ', sizeof(vol_desc.X))
end_define

begin_function
name|void
name|FDECL2
parameter_list|(
name|set_721
parameter_list|,
name|char
modifier|*
parameter_list|,
name|pnt
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|i
parameter_list|)
block|{
name|pnt
index|[
literal|0
index|]
operator|=
name|i
operator|&
literal|0xff
expr_stmt|;
name|pnt
index|[
literal|1
index|]
operator|=
operator|(
name|i
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_function
name|void
name|FDECL2
parameter_list|(
name|set_722
parameter_list|,
name|char
modifier|*
parameter_list|,
name|pnt
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|i
parameter_list|)
block|{
name|pnt
index|[
literal|0
index|]
operator|=
operator|(
name|i
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|pnt
index|[
literal|1
index|]
operator|=
name|i
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_function
name|void
name|FDECL2
parameter_list|(
name|set_723
parameter_list|,
name|char
modifier|*
parameter_list|,
name|pnt
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|i
parameter_list|)
block|{
name|pnt
index|[
literal|3
index|]
operator|=
name|pnt
index|[
literal|0
index|]
operator|=
name|i
operator|&
literal|0xff
expr_stmt|;
name|pnt
index|[
literal|2
index|]
operator|=
name|pnt
index|[
literal|1
index|]
operator|=
operator|(
name|i
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_function
name|void
name|FDECL2
parameter_list|(
name|set_731
parameter_list|,
name|char
modifier|*
parameter_list|,
name|pnt
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|i
parameter_list|)
block|{
name|pnt
index|[
literal|0
index|]
operator|=
name|i
operator|&
literal|0xff
expr_stmt|;
name|pnt
index|[
literal|1
index|]
operator|=
operator|(
name|i
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|pnt
index|[
literal|2
index|]
operator|=
operator|(
name|i
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|pnt
index|[
literal|3
index|]
operator|=
operator|(
name|i
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_function
name|void
name|FDECL2
parameter_list|(
name|set_732
parameter_list|,
name|char
modifier|*
parameter_list|,
name|pnt
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|i
parameter_list|)
block|{
name|pnt
index|[
literal|3
index|]
operator|=
name|i
operator|&
literal|0xff
expr_stmt|;
name|pnt
index|[
literal|2
index|]
operator|=
operator|(
name|i
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|pnt
index|[
literal|1
index|]
operator|=
operator|(
name|i
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|pnt
index|[
literal|0
index|]
operator|=
operator|(
name|i
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_function
name|int
name|FDECL1
parameter_list|(
name|get_733
parameter_list|,
name|char
modifier|*
parameter_list|,
name|p
parameter_list|)
block|{
return|return
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|(
name|p
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|p
index|[
literal|2
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|p
index|[
literal|3
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|24
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|FDECL2
parameter_list|(
name|set_733
parameter_list|,
name|char
modifier|*
parameter_list|,
name|pnt
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|i
parameter_list|)
block|{
name|pnt
index|[
literal|7
index|]
operator|=
name|pnt
index|[
literal|0
index|]
operator|=
name|i
operator|&
literal|0xff
expr_stmt|;
name|pnt
index|[
literal|6
index|]
operator|=
name|pnt
index|[
literal|1
index|]
operator|=
operator|(
name|i
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|pnt
index|[
literal|5
index|]
operator|=
name|pnt
index|[
literal|2
index|]
operator|=
operator|(
name|i
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|pnt
index|[
literal|4
index|]
operator|=
name|pnt
index|[
literal|3
index|]
operator|=
operator|(
name|i
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|FDECL4
argument_list|(
argument|xfwrite
argument_list|,
argument|void *
argument_list|,
argument|buffer
argument_list|,
argument|int
argument_list|,
argument|count
argument_list|,
argument|int
argument_list|,
argument|size
argument_list|,
argument|FILE *
argument_list|,
argument|file
argument_list|)
block|{
while|while
condition|(
name|count
condition|)
block|{
name|int
name|got
init|=
name|fwrite
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|,
name|count
argument_list|,
name|file
argument_list|)
decl_stmt|;
if|if
condition|(
name|got
operator|<=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot fwrite %d*%d\n"
argument_list|,
name|size
argument_list|,
name|count
argument_list|)
operator|,
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|count
operator|-=
name|got
operator|,
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|buffer
operator|+=
name|size
operator|*
name|got
expr_stmt|;
block|}
end_expr_stmt

begin_macro
unit|}  struct
name|deferred_write
end_macro

begin_block
block|{
name|struct
name|deferred_write
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|table
decl_stmt|;
name|unsigned
name|int
name|extent
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|static
name|struct
name|deferred_write
modifier|*
name|dw_head
init|=
name|NULL
decl_stmt|,
modifier|*
name|dw_tail
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|directory_entry
modifier|*
name|sort_dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|last_extent_written
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|iso_primary_descriptor
name|vol_desc
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|path_table_index
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* We recursively walk through all of the directories and assign extent    numbers to them.  We have already assigned extent numbers to everything that    goes in front of them */
end_comment

begin_function
name|void
name|FDECL1
parameter_list|(
name|assign_directory_addresses
parameter_list|,
name|struct
name|directory
modifier|*
parameter_list|,
name|node
parameter_list|)
block|{
name|struct
name|directory
modifier|*
name|dpnt
decl_stmt|;
name|int
name|dir_size
decl_stmt|;
name|dpnt
operator|=
name|node
expr_stmt|;
while|while
condition|(
name|dpnt
condition|)
block|{
name|dpnt
operator|->
name|extent
operator|=
name|last_extent
expr_stmt|;
name|dpnt
operator|->
name|path_index
operator|=
name|next_path_index
operator|++
expr_stmt|;
name|dir_size
operator|=
operator|(
name|dpnt
operator|->
name|size
operator|+
operator|(
name|SECTOR_SIZE
operator|-
literal|1
operator|)
operator|)
operator|>>
literal|11
expr_stmt|;
name|last_extent
operator|+=
name|dir_size
expr_stmt|;
comment|/* Leave room for the CE entries for this directory.  Keep them        close to the reference directory so that access will be quick. */
if|if
condition|(
name|dpnt
operator|->
name|ce_bytes
condition|)
name|last_extent
operator|+=
name|ROUND_UP
argument_list|(
name|dpnt
operator|->
name|ce_bytes
argument_list|)
operator|>>
literal|11
expr_stmt|;
if|if
condition|(
name|dpnt
operator|->
name|subdir
condition|)
name|assign_directory_addresses
argument_list|(
name|dpnt
operator|->
name|subdir
argument_list|)
expr_stmt|;
name|dpnt
operator|=
name|dpnt
operator|->
name|next
expr_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|FDECL3
parameter_list|(
name|write_one_file
parameter_list|,
name|char
modifier|*
parameter_list|,
name|filename
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|size
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|outfile
parameter_list|)
block|{
name|FILE
modifier|*
name|infile
decl_stmt|;
name|char
name|buffer
index|[
name|SECTOR_SIZE
operator|*
name|NSECT
index|]
decl_stmt|;
name|int
name|use
decl_stmt|;
name|int
name|remain
decl_stmt|;
if|if
condition|(
operator|(
name|infile
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"rb"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|sun
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot open %s: (%d)\n"
argument_list|,
name|filename
argument_list|,
name|errno
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot open %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|remain
operator|=
name|size
expr_stmt|;
while|while
condition|(
name|remain
operator|>
literal|0
condition|)
block|{
name|use
operator|=
operator|(
name|remain
operator|>
name|SECTOR_SIZE
operator|*
name|NSECT
operator|-
literal|1
condition|?
name|NSECT
operator|*
name|SECTOR_SIZE
else|:
name|remain
operator|)
expr_stmt|;
name|use
operator|=
name|ROUND_UP
argument_list|(
name|use
argument_list|)
expr_stmt|;
comment|/* Round up to nearest sector boundary */
name|memset
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|use
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|use
argument_list|,
name|infile
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot read from %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|xfwrite
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|use
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|last_extent_written
operator|+=
name|use
operator|/
name|SECTOR_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|last_extent_written
operator|%
literal|1000
operator|)
operator|<
name|use
operator|/
name|SECTOR_SIZE
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d.."
argument_list|,
name|last_extent_written
argument_list|)
expr_stmt|;
name|remain
operator|-=
name|use
expr_stmt|;
block|}
empty_stmt|;
name|fclose
argument_list|(
name|infile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|FDECL1
parameter_list|(
name|write_files
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|outfile
parameter_list|)
block|{
name|struct
name|deferred_write
modifier|*
name|dwpnt
decl_stmt|,
modifier|*
name|dwnext
decl_stmt|;
name|dwpnt
operator|=
name|dw_head
expr_stmt|;
while|while
condition|(
name|dwpnt
condition|)
block|{
if|if
condition|(
name|dwpnt
operator|->
name|table
condition|)
block|{
name|xfwrite
argument_list|(
name|dwpnt
operator|->
name|table
argument_list|,
literal|1
argument_list|,
name|ROUND_UP
argument_list|(
name|dwpnt
operator|->
name|size
argument_list|)
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|last_extent_written
operator|+=
name|ROUND_UP
argument_list|(
name|dwpnt
operator|->
name|size
argument_list|)
operator|/
name|SECTOR_SIZE
expr_stmt|;
name|table_size
operator|+=
name|dwpnt
operator|->
name|size
expr_stmt|;
comment|/*		  fprintf(stderr,"Size %d ", dwpnt->size); */
name|free
argument_list|(
name|dwpnt
operator|->
name|table
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|VMS
name|vms_write_one_file
argument_list|(
name|dwpnt
operator|->
name|name
argument_list|,
name|dwpnt
operator|->
name|size
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
else|#
directive|else
name|write_one_file
argument_list|(
name|dwpnt
operator|->
name|name
argument_list|,
name|dwpnt
operator|->
name|size
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|dwpnt
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|dwnext
operator|=
name|dwpnt
expr_stmt|;
name|dwpnt
operator|=
name|dwpnt
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|dwnext
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void dump_filelist(){   struct deferred_write * dwpnt;   dwpnt = dw_head;   while(dwpnt){     fprintf(stderr, "File %s\n",dwpnt->name);     dwpnt = dwpnt->next;   };   fprintf(stderr,"\n"); };
endif|#
directive|endif
end_endif

begin_function
name|int
name|FDECL2
parameter_list|(
name|compare_dirs
parameter_list|,
name|struct
name|directory_entry
modifier|*
modifier|*
parameter_list|,
name|r
parameter_list|,
name|struct
name|directory_entry
modifier|*
modifier|*
parameter_list|,
name|l
parameter_list|)
block|{
name|char
modifier|*
name|rpnt
decl_stmt|,
modifier|*
name|lpnt
decl_stmt|;
name|rpnt
operator|=
operator|(
operator|*
name|r
operator|)
operator|->
name|isorec
operator|.
name|name
expr_stmt|;
name|lpnt
operator|=
operator|(
operator|*
name|l
operator|)
operator|->
name|isorec
operator|.
name|name
expr_stmt|;
while|while
condition|(
operator|*
name|rpnt
operator|&&
operator|*
name|lpnt
condition|)
block|{
if|if
condition|(
operator|*
name|rpnt
operator|==
literal|';'
operator|&&
operator|*
name|lpnt
operator|!=
literal|';'
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|*
name|rpnt
operator|!=
literal|';'
operator|&&
operator|*
name|lpnt
operator|==
literal|';'
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|*
name|rpnt
operator|==
literal|';'
operator|&&
operator|*
name|lpnt
operator|==
literal|';'
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|rpnt
operator|<
operator|*
name|lpnt
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|*
name|rpnt
operator|>
operator|*
name|lpnt
condition|)
return|return
literal|1
return|;
name|rpnt
operator|++
expr_stmt|;
name|lpnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|rpnt
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|*
name|lpnt
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|FDECL1
parameter_list|(
name|sort_directory
parameter_list|,
name|struct
name|directory_entry
modifier|*
modifier|*
parameter_list|,
name|sort_dir
parameter_list|)
block|{
name|int
name|dcount
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|directory_entry
modifier|*
name|s_entry
decl_stmt|;
name|struct
name|directory_entry
modifier|*
modifier|*
name|sortlist
decl_stmt|;
name|s_entry
operator|=
operator|*
name|sort_dir
expr_stmt|;
while|while
condition|(
name|s_entry
condition|)
block|{
name|dcount
operator|++
expr_stmt|;
name|s_entry
operator|=
name|s_entry
operator|->
name|next
expr_stmt|;
block|}
empty_stmt|;
comment|/* OK, now we know how many there are.  Build a vector for sorting. */
name|sortlist
operator|=
operator|(
expr|struct
name|directory_entry
operator|*
operator|*
operator|)
name|e_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|directory_entry
operator|*
argument_list|)
operator|*
name|dcount
argument_list|)
expr_stmt|;
name|dcount
operator|=
literal|0
expr_stmt|;
name|s_entry
operator|=
operator|*
name|sort_dir
expr_stmt|;
while|while
condition|(
name|s_entry
condition|)
block|{
name|sortlist
index|[
name|dcount
index|]
operator|=
name|s_entry
expr_stmt|;
name|len
operator|=
name|s_entry
operator|->
name|isorec
operator|.
name|name_len
index|[
literal|0
index|]
expr_stmt|;
name|s_entry
operator|->
name|isorec
operator|.
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|dcount
operator|++
expr_stmt|;
name|s_entry
operator|=
name|s_entry
operator|->
name|next
expr_stmt|;
block|}
empty_stmt|;
name|qsort
argument_list|(
name|sortlist
argument_list|,
name|dcount
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|directory_entry
operator|*
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|compare_dirs
argument_list|)
expr_stmt|;
comment|/* Now reassemble the linked list in the proper sorted order */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dcount
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|sortlist
index|[
name|i
index|]
operator|->
name|next
operator|=
name|sortlist
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|sortlist
index|[
name|dcount
operator|-
literal|1
index|]
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|sort_dir
operator|=
name|sortlist
index|[
literal|0
index|]
expr_stmt|;
name|free
argument_list|(
name|sortlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|generate_root_record
parameter_list|()
block|{
name|time_t
name|ctime
decl_stmt|;
name|time
argument_list|(
operator|&
name|ctime
argument_list|)
expr_stmt|;
name|local
operator|=
name|localtime
argument_list|(
operator|&
name|ctime
argument_list|)
expr_stmt|;
name|root_record
operator|.
name|length
index|[
literal|0
index|]
operator|=
literal|1
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|iso_directory_record
argument_list|)
expr_stmt|;
name|root_record
operator|.
name|ext_attr_length
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|set_733
argument_list|(
name|root_record
operator|.
name|extent
argument_list|,
name|root
operator|->
name|extent
argument_list|)
expr_stmt|;
name|set_733
argument_list|(
name|root_record
operator|.
name|size
argument_list|,
name|ROUND_UP
argument_list|(
name|root
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|iso9660_date
argument_list|(
name|root_record
operator|.
name|date
argument_list|,
name|ctime
argument_list|)
expr_stmt|;
name|root_record
operator|.
name|flags
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|root_record
operator|.
name|file_unit_size
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|root_record
operator|.
name|interleave
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|set_723
argument_list|(
name|root_record
operator|.
name|volume_sequence_number
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|root_record
operator|.
name|name_len
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|FDECL1
parameter_list|(
name|assign_file_addresses
parameter_list|,
name|struct
name|directory
modifier|*
parameter_list|,
name|dpnt
parameter_list|)
block|{
name|struct
name|directory
modifier|*
name|finddir
decl_stmt|;
name|struct
name|directory_entry
modifier|*
name|s_entry
decl_stmt|;
name|struct
name|file_hash
modifier|*
name|s_hash
decl_stmt|;
name|struct
name|deferred_write
modifier|*
name|dwpnt
decl_stmt|;
name|char
name|whole_path
index|[
literal|1024
index|]
decl_stmt|;
while|while
condition|(
name|dpnt
condition|)
block|{
name|s_entry
operator|=
name|dpnt
operator|->
name|contents
expr_stmt|;
for|for
control|(
name|s_entry
operator|=
name|dpnt
operator|->
name|contents
init|;
name|s_entry
condition|;
name|s_entry
operator|=
name|s_entry
operator|->
name|next
control|)
block|{
comment|/* This saves some space if there are symlinks present */
name|s_hash
operator|=
name|find_hash
argument_list|(
name|s_entry
operator|->
name|dev
argument_list|,
name|s_entry
operator|->
name|inode
argument_list|)
expr_stmt|;
if|if
condition|(
name|s_hash
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cache hit for %s%s%s\n"
argument_list|,
name|s_entry
operator|->
name|filedir
operator|->
name|de_name
argument_list|,
name|SPATH_SEPARATOR
argument_list|,
name|s_entry
operator|->
name|name
argument_list|)
expr_stmt|;
name|set_733
argument_list|(
name|s_entry
operator|->
name|isorec
operator|.
name|extent
argument_list|,
name|s_hash
operator|->
name|starting_block
argument_list|)
expr_stmt|;
name|set_733
argument_list|(
name|s_entry
operator|->
name|isorec
operator|.
name|size
argument_list|,
name|s_hash
operator|->
name|size
argument_list|)
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s_entry
operator|->
name|name
argument_list|,
literal|"."
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|s_entry
operator|->
name|name
argument_list|,
literal|".."
argument_list|)
operator|&&
name|s_entry
operator|->
name|isorec
operator|.
name|flags
index|[
literal|0
index|]
operator|==
literal|2
condition|)
block|{
name|finddir
operator|=
name|dpnt
operator|->
name|subdir
expr_stmt|;
while|while
condition|(
literal|1
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|finddir
operator|->
name|self
operator|==
name|s_entry
condition|)
break|break;
name|finddir
operator|=
name|finddir
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|finddir
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Fatal goof\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
name|set_733
argument_list|(
name|s_entry
operator|->
name|isorec
operator|.
name|extent
argument_list|,
name|finddir
operator|->
name|extent
argument_list|)
expr_stmt|;
name|s_entry
operator|->
name|starting_block
operator|=
name|finddir
operator|->
name|extent
expr_stmt|;
name|s_entry
operator|->
name|size
operator|=
name|ROUND_UP
argument_list|(
name|finddir
operator|->
name|size
argument_list|)
expr_stmt|;
name|total_dir_size
operator|+=
name|s_entry
operator|->
name|size
expr_stmt|;
name|add_hash
argument_list|(
name|s_entry
argument_list|)
expr_stmt|;
name|set_733
argument_list|(
name|s_entry
operator|->
name|isorec
operator|.
name|size
argument_list|,
name|ROUND_UP
argument_list|(
name|finddir
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s_entry
operator|->
name|name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|s_entry
operator|->
name|name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s_entry
operator|->
name|name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|set_733
argument_list|(
name|s_entry
operator|->
name|isorec
operator|.
name|extent
argument_list|,
name|dpnt
operator|->
name|extent
argument_list|)
expr_stmt|;
comment|/* Set these so that the hash table has the correct information */
name|s_entry
operator|->
name|starting_block
operator|=
name|dpnt
operator|->
name|extent
expr_stmt|;
name|s_entry
operator|->
name|size
operator|=
name|ROUND_UP
argument_list|(
name|dpnt
operator|->
name|size
argument_list|)
expr_stmt|;
name|add_hash
argument_list|(
name|s_entry
argument_list|)
expr_stmt|;
name|s_entry
operator|->
name|starting_block
operator|=
name|dpnt
operator|->
name|extent
expr_stmt|;
name|set_733
argument_list|(
name|s_entry
operator|->
name|isorec
operator|.
name|size
argument_list|,
name|ROUND_UP
argument_list|(
name|dpnt
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dpnt
operator|==
name|root
condition|)
name|total_dir_size
operator|+=
name|root
operator|->
name|size
expr_stmt|;
name|set_733
argument_list|(
name|s_entry
operator|->
name|isorec
operator|.
name|extent
argument_list|,
name|dpnt
operator|->
name|parent
operator|->
name|extent
argument_list|)
expr_stmt|;
comment|/* Set these so that the hash table has the correct information */
name|s_entry
operator|->
name|starting_block
operator|=
name|dpnt
operator|->
name|parent
operator|->
name|extent
expr_stmt|;
name|s_entry
operator|->
name|size
operator|=
name|ROUND_UP
argument_list|(
name|dpnt
operator|->
name|parent
operator|->
name|size
argument_list|)
expr_stmt|;
name|add_hash
argument_list|(
name|s_entry
argument_list|)
expr_stmt|;
name|s_entry
operator|->
name|starting_block
operator|=
name|dpnt
operator|->
name|parent
operator|->
name|extent
expr_stmt|;
name|set_733
argument_list|(
name|s_entry
operator|->
name|isorec
operator|.
name|size
argument_list|,
name|ROUND_UP
argument_list|(
name|dpnt
operator|->
name|parent
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
else|else
block|{
comment|/* Now we schedule the file to be written.  This is all quite 	     straightforward, just make a list and assign extents as we go. 	     Once we get through writing all of the directories, we should 	     be ready write out these files */
if|if
condition|(
name|s_entry
operator|->
name|size
condition|)
block|{
name|dwpnt
operator|=
operator|(
expr|struct
name|deferred_write
operator|*
operator|)
name|e_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|deferred_write
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dw_tail
condition|)
block|{
name|dw_tail
operator|->
name|next
operator|=
name|dwpnt
expr_stmt|;
name|dw_tail
operator|=
name|dwpnt
expr_stmt|;
block|}
else|else
block|{
name|dw_head
operator|=
name|dwpnt
expr_stmt|;
name|dw_tail
operator|=
name|dwpnt
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|s_entry
operator|->
name|inode
operator|==
name|TABLE_INODE
condition|)
block|{
name|dwpnt
operator|->
name|table
operator|=
name|s_entry
operator|->
name|table
expr_stmt|;
name|dwpnt
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|dwpnt
operator|->
name|table
operator|=
name|NULL
expr_stmt|;
name|strcpy
argument_list|(
name|whole_path
argument_list|,
name|s_entry
operator|->
name|filedir
operator|->
name|whole_name
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
if|if
condition|(
name|strlen
argument_list|(
name|whole_path
argument_list|)
condition|)
name|strcat
argument_list|(
name|whole_path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcat
argument_list|(
name|whole_path
argument_list|,
name|s_entry
operator|->
name|name
argument_list|)
expr_stmt|;
name|dwpnt
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|whole_path
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|dwpnt
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|dwpnt
operator|->
name|size
operator|=
name|s_entry
operator|->
name|size
expr_stmt|;
name|dwpnt
operator|->
name|extent
operator|=
name|last_extent
expr_stmt|;
name|set_733
argument_list|(
name|s_entry
operator|->
name|isorec
operator|.
name|extent
argument_list|,
name|last_extent
argument_list|)
expr_stmt|;
name|s_entry
operator|->
name|starting_block
operator|=
name|last_extent
expr_stmt|;
name|add_hash
argument_list|(
name|s_entry
argument_list|)
expr_stmt|;
name|last_extent
operator|+=
name|ROUND_UP
argument_list|(
name|s_entry
operator|->
name|size
argument_list|)
operator|>>
literal|11
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d %d %s\n"
argument_list|,
name|s_entry
operator|->
name|starting_block
argument_list|,
name|last_extent
operator|-
literal|1
argument_list|,
name|whole_path
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBG_ISO
if|if
condition|(
operator|(
name|ROUND_UP
argument_list|(
name|s_entry
operator|->
name|size
argument_list|)
operator|>>
literal|11
operator|)
operator|>
literal|500
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: large file %s\n"
argument_list|,
name|whole_path
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Starting block is %d\n"
argument_list|,
name|s_entry
operator|->
name|starting_block
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reported file size is %d extents\n"
argument_list|,
name|s_entry
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
endif|#
directive|endif
if|if
condition|(
name|last_extent
operator|>
operator|(
literal|700000000
operator|>>
literal|11
operator|)
condition|)
block|{
comment|/* More than 700Mb? Punt */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Extent overflow processing file %s\n"
argument_list|,
name|whole_path
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Starting block is %d\n"
argument_list|,
name|s_entry
operator|->
name|starting_block
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Reported file size is %d extents\n"
argument_list|,
name|s_entry
operator|->
name|size
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
else|else
name|set_733
argument_list|(
name|s_entry
operator|->
name|isorec
operator|.
name|extent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|dpnt
operator|->
name|subdir
condition|)
name|assign_file_addresses
argument_list|(
name|dpnt
operator|->
name|subdir
argument_list|)
expr_stmt|;
name|dpnt
operator|=
name|dpnt
operator|->
name|next
expr_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_function
name|void
name|FDECL2
parameter_list|(
name|generate_one_directory
parameter_list|,
name|struct
name|directory
modifier|*
parameter_list|,
name|dpnt
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|outfile
parameter_list|)
block|{
name|unsigned
name|int
name|total_size
decl_stmt|,
name|ce_size
decl_stmt|;
name|char
modifier|*
name|directory_buffer
decl_stmt|;
name|char
modifier|*
name|ce_buffer
decl_stmt|;
name|unsigned
name|int
name|ce_address
decl_stmt|;
name|struct
name|directory_entry
modifier|*
name|s_entry
decl_stmt|,
modifier|*
name|s_entry_d
decl_stmt|;
name|int
name|new_reclen
decl_stmt|;
name|unsigned
name|int
name|dir_index
decl_stmt|,
name|ce_index
decl_stmt|;
name|total_size
operator|=
operator|(
name|dpnt
operator|->
name|size
operator|+
operator|(
name|SECTOR_SIZE
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|SECTOR_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|directory_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|e_malloc
argument_list|(
name|total_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|directory_buffer
argument_list|,
literal|0
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
name|dir_index
operator|=
literal|0
expr_stmt|;
name|ce_size
operator|=
operator|(
name|dpnt
operator|->
name|ce_bytes
operator|+
operator|(
name|SECTOR_SIZE
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|SECTOR_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|ce_buffer
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ce_size
condition|)
block|{
name|ce_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|e_malloc
argument_list|(
name|ce_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ce_buffer
argument_list|,
literal|0
argument_list|,
name|ce_size
argument_list|)
expr_stmt|;
name|ce_index
operator|=
literal|0
expr_stmt|;
comment|/* Absolute byte address of CE entries for this directory */
name|ce_address
operator|=
name|last_extent_written
operator|+
operator|(
name|total_size
operator|>>
literal|11
operator|)
expr_stmt|;
name|ce_address
operator|=
name|ce_address
operator|<<
literal|11
expr_stmt|;
block|}
name|s_entry
operator|=
name|dpnt
operator|->
name|contents
expr_stmt|;
while|while
condition|(
name|s_entry
condition|)
block|{
comment|/* We do not allow directory entries to cross sector boundaries.  Simply        pad, and then start the next entry at the next sector */
name|new_reclen
operator|=
name|s_entry
operator|->
name|isorec
operator|.
name|length
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|dir_index
operator|&
operator|(
name|SECTOR_SIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|new_reclen
operator|>=
name|SECTOR_SIZE
condition|)
name|dir_index
operator|=
operator|(
name|dir_index
operator|+
operator|(
name|SECTOR_SIZE
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|SECTOR_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|directory_buffer
operator|+
name|dir_index
argument_list|,
operator|&
name|s_entry
operator|->
name|isorec
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iso_directory_record
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|s_entry
operator|->
name|isorec
operator|.
name|name
argument_list|)
operator|+
name|s_entry
operator|->
name|isorec
operator|.
name|name_len
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dir_index
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|iso_directory_record
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|s_entry
operator|->
name|isorec
operator|.
name|name
argument_list|)
operator|+
name|s_entry
operator|->
name|isorec
operator|.
name|name_len
index|[
literal|0
index|]
expr_stmt|;
comment|/* Add the Rock Ridge attributes, if present */
if|if
condition|(
name|s_entry
operator|->
name|rr_attr_size
condition|)
block|{
if|if
condition|(
name|dir_index
operator|&
literal|1
condition|)
name|directory_buffer
index|[
name|dir_index
operator|++
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If the RR attributes were too long, then write the CE records, 	 as required. */
if|if
condition|(
name|s_entry
operator|->
name|rr_attr_size
operator|!=
name|s_entry
operator|->
name|total_rr_attr_size
condition|)
block|{
name|unsigned
name|char
modifier|*
name|pnt
decl_stmt|;
name|int
name|len
decl_stmt|,
name|nbytes
decl_stmt|;
comment|/* Go through the entire record and fix up the CE entries 	   so that the extent and offset are correct */
name|pnt
operator|=
name|s_entry
operator|->
name|rr_attributes
expr_stmt|;
name|len
operator|=
name|s_entry
operator|->
name|total_rr_attr_size
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|3
condition|)
block|{
if|if
condition|(
name|pnt
index|[
literal|0
index|]
operator|==
literal|'C'
operator|&&
name|pnt
index|[
literal|1
index|]
operator|==
literal|'E'
condition|)
block|{
name|nbytes
operator|=
name|get_733
argument_list|(
name|pnt
operator|+
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ce_index
operator|&
operator|(
name|SECTOR_SIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|nbytes
operator|>=
name|SECTOR_SIZE
condition|)
name|ce_index
operator|=
name|ROUND_UP
argument_list|(
name|ce_index
argument_list|)
expr_stmt|;
name|set_733
argument_list|(
name|pnt
operator|+
literal|4
argument_list|,
operator|(
name|ce_address
operator|+
name|ce_index
operator|)
operator|>>
literal|11
argument_list|)
expr_stmt|;
name|set_733
argument_list|(
name|pnt
operator|+
literal|12
argument_list|,
operator|(
name|ce_address
operator|+
name|ce_index
operator|)
operator|&
operator|(
name|SECTOR_SIZE
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Now store the block in the ce buffer */
name|memcpy
argument_list|(
name|ce_buffer
operator|+
name|ce_index
argument_list|,
name|pnt
operator|+
name|pnt
index|[
literal|2
index|]
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|ce_index
operator|+=
name|nbytes
expr_stmt|;
if|if
condition|(
name|ce_index
operator|&
literal|1
condition|)
name|ce_index
operator|++
expr_stmt|;
block|}
empty_stmt|;
name|len
operator|-=
name|pnt
index|[
literal|2
index|]
expr_stmt|;
name|pnt
operator|+=
name|pnt
index|[
literal|2
index|]
expr_stmt|;
block|}
empty_stmt|;
block|}
name|rockridge_size
operator|+=
name|s_entry
operator|->
name|total_rr_attr_size
expr_stmt|;
name|memcpy
argument_list|(
name|directory_buffer
operator|+
name|dir_index
argument_list|,
name|s_entry
operator|->
name|rr_attributes
argument_list|,
name|s_entry
operator|->
name|rr_attr_size
argument_list|)
expr_stmt|;
name|dir_index
operator|+=
name|s_entry
operator|->
name|rr_attr_size
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|dir_index
operator|&
literal|1
condition|)
name|directory_buffer
index|[
name|dir_index
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|s_entry_d
operator|=
name|s_entry
expr_stmt|;
name|s_entry
operator|=
name|s_entry
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|s_entry_d
operator|->
name|rr_attributes
condition|)
name|free
argument_list|(
name|s_entry_d
operator|->
name|rr_attributes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s_entry_d
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s_entry_d
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|sort_dir
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dpnt
operator|->
name|size
operator|!=
name|dir_index
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unexpected directory length %d %d %s\n"
argument_list|,
name|dpnt
operator|->
name|size
argument_list|,
name|dir_index
argument_list|,
name|dpnt
operator|->
name|de_name
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|directory_buffer
argument_list|,
literal|1
argument_list|,
name|total_size
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|last_extent_written
operator|+=
name|total_size
operator|>>
literal|11
expr_stmt|;
name|free
argument_list|(
name|directory_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce_size
condition|)
block|{
if|if
condition|(
name|ce_index
operator|!=
name|dpnt
operator|->
name|ce_bytes
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Continuation entry record length mismatch (%d %d).\n"
argument_list|,
name|ce_index
argument_list|,
name|dpnt
operator|->
name|ce_bytes
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|ce_buffer
argument_list|,
literal|1
argument_list|,
name|ce_size
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|last_extent_written
operator|+=
name|ce_size
operator|>>
literal|11
expr_stmt|;
name|free
argument_list|(
name|ce_buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|FDECL1
parameter_list|(
name|build_pathlist
parameter_list|,
name|struct
name|directory
modifier|*
parameter_list|,
name|node
parameter_list|)
block|{
name|struct
name|directory
modifier|*
name|dpnt
decl_stmt|;
name|dpnt
operator|=
name|node
expr_stmt|;
while|while
condition|(
name|dpnt
condition|)
block|{
name|pathlist
index|[
name|dpnt
operator|->
name|path_index
index|]
operator|=
name|dpnt
expr_stmt|;
if|if
condition|(
name|dpnt
operator|->
name|subdir
condition|)
name|build_pathlist
argument_list|(
name|dpnt
operator|->
name|subdir
argument_list|)
expr_stmt|;
name|dpnt
operator|=
name|dpnt
operator|->
name|next
expr_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_function
name|int
name|FDECL2
parameter_list|(
name|compare_paths
parameter_list|,
specifier|const
name|struct
name|directory
modifier|*
modifier|*
parameter_list|,
name|r
parameter_list|,
specifier|const
name|struct
name|directory
modifier|*
modifier|*
parameter_list|,
name|l
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|*
name|r
operator|)
operator|->
name|parent
operator|->
name|path_index
operator|<
operator|(
operator|*
name|l
operator|)
operator|->
name|parent
operator|->
name|path_index
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
operator|*
name|r
operator|)
operator|->
name|parent
operator|->
name|path_index
operator|>
operator|(
operator|*
name|l
operator|)
operator|->
name|parent
operator|->
name|path_index
condition|)
return|return
literal|1
return|;
return|return
name|strcmp
argument_list|(
operator|(
operator|*
name|r
operator|)
operator|->
name|self
operator|->
name|isorec
operator|.
name|name
argument_list|,
operator|(
operator|*
name|l
operator|)
operator|->
name|self
operator|->
name|isorec
operator|.
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|generate_path_tables
parameter_list|()
block|{
name|struct
name|directory
modifier|*
name|dpnt
decl_stmt|;
name|char
modifier|*
name|npnt
decl_stmt|,
modifier|*
name|npnt1
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|struct
name|directory_entry
modifier|*
name|de
decl_stmt|;
name|int
name|fix
decl_stmt|;
name|int
name|tablesize
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* First allocate memory for the tables and initialize the memory */
name|tablesize
operator|=
name|path_blocks
operator|<<
literal|11
expr_stmt|;
name|path_table_m
operator|=
operator|(
name|char
operator|*
operator|)
name|e_malloc
argument_list|(
name|tablesize
argument_list|)
expr_stmt|;
name|path_table_l
operator|=
operator|(
name|char
operator|*
operator|)
name|e_malloc
argument_list|(
name|tablesize
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|path_table_l
argument_list|,
literal|0
argument_list|,
name|tablesize
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|path_table_m
argument_list|,
literal|0
argument_list|,
name|tablesize
argument_list|)
expr_stmt|;
comment|/* Now start filling in the path tables.  Start with root directory */
name|path_table_index
operator|=
literal|0
expr_stmt|;
name|pathlist
operator|=
operator|(
expr|struct
name|directory
operator|*
operator|*
operator|)
name|e_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|directory
operator|*
argument_list|)
operator|*
name|next_path_index
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pathlist
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|directory
operator|*
argument_list|)
operator|*
name|next_path_index
argument_list|)
expr_stmt|;
name|build_pathlist
argument_list|(
name|root
argument_list|)
expr_stmt|;
do|do
block|{
name|fix
operator|=
literal|0
expr_stmt|;
name|qsort
argument_list|(
operator|&
name|pathlist
index|[
literal|1
index|]
argument_list|,
name|next_path_index
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|directory
operator|*
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|compare_paths
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|next_path_index
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|pathlist
index|[
name|j
index|]
operator|->
name|path_index
operator|!=
name|j
condition|)
block|{
name|pathlist
index|[
name|j
index|]
operator|->
name|path_index
operator|=
name|j
expr_stmt|;
name|fix
operator|++
expr_stmt|;
block|}
empty_stmt|;
block|}
do|while
condition|(
name|fix
condition|)
do|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|next_path_index
condition|;
name|j
operator|++
control|)
block|{
name|dpnt
operator|=
name|pathlist
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|dpnt
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Entry %d not in path tables\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|npnt
operator|=
name|dpnt
operator|->
name|de_name
expr_stmt|;
if|if
condition|(
operator|*
name|npnt
operator|==
literal|0
operator|||
name|dpnt
operator|==
name|root
condition|)
name|npnt
operator|=
literal|"."
expr_stmt|;
comment|/* So the root comes out OK */
name|npnt1
operator|=
name|strrchr
argument_list|(
name|npnt
argument_list|,
name|PATH_SEPARATOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|npnt1
condition|)
name|npnt
operator|=
name|npnt1
operator|+
literal|1
expr_stmt|;
name|de
operator|=
name|dpnt
operator|->
name|self
expr_stmt|;
if|if
condition|(
operator|!
name|de
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Fatal goof\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|namelen
operator|=
name|de
operator|->
name|isorec
operator|.
name|name_len
index|[
literal|0
index|]
expr_stmt|;
name|path_table_l
index|[
name|path_table_index
index|]
operator|=
name|namelen
expr_stmt|;
name|path_table_m
index|[
name|path_table_index
index|]
operator|=
name|namelen
expr_stmt|;
name|path_table_index
operator|+=
literal|2
expr_stmt|;
name|set_731
argument_list|(
name|path_table_l
operator|+
name|path_table_index
argument_list|,
name|dpnt
operator|->
name|extent
argument_list|)
expr_stmt|;
name|set_732
argument_list|(
name|path_table_m
operator|+
name|path_table_index
argument_list|,
name|dpnt
operator|->
name|extent
argument_list|)
expr_stmt|;
name|path_table_index
operator|+=
literal|4
expr_stmt|;
name|set_721
argument_list|(
name|path_table_l
operator|+
name|path_table_index
argument_list|,
name|dpnt
operator|->
name|parent
operator|->
name|path_index
argument_list|)
expr_stmt|;
name|set_722
argument_list|(
name|path_table_m
operator|+
name|path_table_index
argument_list|,
name|dpnt
operator|->
name|parent
operator|->
name|path_index
argument_list|)
expr_stmt|;
name|path_table_index
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|namelen
condition|;
name|i
operator|++
control|)
block|{
name|path_table_l
index|[
name|path_table_index
index|]
operator|=
name|de
operator|->
name|isorec
operator|.
name|name
index|[
name|i
index|]
expr_stmt|;
name|path_table_m
index|[
name|path_table_index
index|]
operator|=
name|de
operator|->
name|isorec
operator|.
name|name
index|[
name|i
index|]
expr_stmt|;
name|path_table_index
operator|++
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|path_table_index
operator|&
literal|1
condition|)
name|path_table_index
operator|++
expr_stmt|;
comment|/* For odd lengths we pad */
block|}
empty_stmt|;
name|free
argument_list|(
name|pathlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_table_index
operator|!=
name|path_table_size
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Path table lengths do not match %d %d\n"
argument_list|,
name|path_table_index
argument_list|,
name|path_table_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|FDECL1
parameter_list|(
name|iso_write
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|outfile
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|2048
index|]
decl_stmt|;
name|char
name|iso_time
index|[
literal|17
index|]
decl_stmt|;
name|int
name|should_write
decl_stmt|;
name|int
name|i
decl_stmt|;
name|assign_file_addresses
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This will break  in the year  2000, I supose, but there is no good way      to get the top two digits of the year. */
name|sprintf
argument_list|(
name|iso_time
argument_list|,
literal|"%4.4d%2.2d%2.2d%2.2d%2.2d%2.2d00"
argument_list|,
literal|1900
operator|+
name|local
operator|->
name|tm_year
argument_list|,
name|local
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|local
operator|->
name|tm_mday
argument_list|,
name|local
operator|->
name|tm_hour
argument_list|,
name|local
operator|->
name|tm_min
argument_list|,
name|local
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
comment|/* First, we output 16 sectors of all zero */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|xfwrite
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|last_extent_written
operator|+=
literal|16
expr_stmt|;
comment|/* Next we write out the primary descriptor for the disc */
name|memset
argument_list|(
operator|&
name|vol_desc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|vol_desc
argument_list|)
argument_list|)
expr_stmt|;
name|vol_desc
operator|.
name|type
index|[
literal|0
index|]
operator|=
name|ISO_VD_PRIMARY
expr_stmt|;
name|memcpy
argument_list|(
name|vol_desc
operator|.
name|id
argument_list|,
name|ISO_STANDARD_ID
argument_list|,
sizeof|sizeof
argument_list|(
name|ISO_STANDARD_ID
argument_list|)
argument_list|)
expr_stmt|;
name|vol_desc
operator|.
name|version
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
name|vol_desc
operator|.
name|system_id
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
name|vol_desc
operator|.
name|system_id
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|vol_desc
operator|.
name|system_id
argument_list|,
name|system_id
argument_list|,
name|strlen
argument_list|(
name|system_id
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|vol_desc
operator|.
name|volume_id
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
name|vol_desc
operator|.
name|volume_id
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|vol_desc
operator|.
name|volume_id
argument_list|,
name|volume_id
argument_list|,
name|strlen
argument_list|(
name|volume_id
argument_list|)
argument_list|)
expr_stmt|;
name|should_write
operator|=
name|last_extent
expr_stmt|;
name|set_733
argument_list|(
name|vol_desc
operator|.
name|volume_space_size
argument_list|,
name|last_extent
argument_list|)
expr_stmt|;
name|set_723
argument_list|(
name|vol_desc
operator|.
name|volume_set_size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_723
argument_list|(
name|vol_desc
operator|.
name|volume_sequence_number
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_723
argument_list|(
name|vol_desc
operator|.
name|logical_block_size
argument_list|,
literal|2048
argument_list|)
expr_stmt|;
comment|/* The path tables are used by DOS based machines to cache directory      locations */
name|set_733
argument_list|(
name|vol_desc
operator|.
name|path_table_size
argument_list|,
name|path_table_size
argument_list|)
expr_stmt|;
name|set_731
argument_list|(
name|vol_desc
operator|.
name|type_l_path_table
argument_list|,
name|path_table
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|set_731
argument_list|(
name|vol_desc
operator|.
name|opt_type_l_path_table
argument_list|,
name|path_table
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|set_732
argument_list|(
name|vol_desc
operator|.
name|type_m_path_table
argument_list|,
name|path_table
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|set_732
argument_list|(
name|vol_desc
operator|.
name|opt_type_m_path_table
argument_list|,
name|path_table
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* Now we copy the actual root directory record */
name|memcpy
argument_list|(
name|vol_desc
operator|.
name|root_directory_record
argument_list|,
operator|&
name|root_record
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iso_directory_record
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* The rest is just fluff.  It looks nice to fill in many of these fields,      though */
name|FILL_SPACE
argument_list|(
name|volume_set_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|volset_id
condition|)
name|memcpy
argument_list|(
name|vol_desc
operator|.
name|volume_set_id
argument_list|,
name|volset_id
argument_list|,
name|strlen
argument_list|(
name|volset_id
argument_list|)
argument_list|)
expr_stmt|;
name|FILL_SPACE
argument_list|(
name|publisher_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|publisher
condition|)
name|memcpy
argument_list|(
name|vol_desc
operator|.
name|publisher_id
argument_list|,
name|publisher
argument_list|,
name|strlen
argument_list|(
name|publisher
argument_list|)
argument_list|)
expr_stmt|;
name|FILL_SPACE
argument_list|(
name|preparer_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|preparer
condition|)
name|memcpy
argument_list|(
name|vol_desc
operator|.
name|preparer_id
argument_list|,
name|preparer
argument_list|,
name|strlen
argument_list|(
name|preparer
argument_list|)
argument_list|)
expr_stmt|;
name|FILL_SPACE
argument_list|(
name|application_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|appid
condition|)
name|memcpy
argument_list|(
name|vol_desc
operator|.
name|application_id
argument_list|,
name|appid
argument_list|,
name|strlen
argument_list|(
name|appid
argument_list|)
argument_list|)
expr_stmt|;
name|FILL_SPACE
argument_list|(
name|copyright_file_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|appid
condition|)
name|memcpy
argument_list|(
name|vol_desc
operator|.
name|copyright_file_id
argument_list|,
name|appid
argument_list|,
name|strlen
argument_list|(
name|appid
argument_list|)
argument_list|)
expr_stmt|;
name|FILL_SPACE
argument_list|(
name|abstract_file_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|appid
condition|)
name|memcpy
argument_list|(
name|vol_desc
operator|.
name|abstract_file_id
argument_list|,
name|appid
argument_list|,
name|strlen
argument_list|(
name|appid
argument_list|)
argument_list|)
expr_stmt|;
name|FILL_SPACE
argument_list|(
name|bibliographic_file_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|appid
condition|)
name|memcpy
argument_list|(
name|vol_desc
operator|.
name|bibliographic_file_id
argument_list|,
name|appid
argument_list|,
name|strlen
argument_list|(
name|appid
argument_list|)
argument_list|)
expr_stmt|;
name|FILL_SPACE
argument_list|(
name|creation_date
argument_list|)
expr_stmt|;
name|FILL_SPACE
argument_list|(
name|modification_date
argument_list|)
expr_stmt|;
name|FILL_SPACE
argument_list|(
name|expiration_date
argument_list|)
expr_stmt|;
name|FILL_SPACE
argument_list|(
name|effective_date
argument_list|)
expr_stmt|;
name|vol_desc
operator|.
name|file_structure_version
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|FILL_SPACE
argument_list|(
name|application_data
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|vol_desc
operator|.
name|creation_date
argument_list|,
name|iso_time
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|vol_desc
operator|.
name|modification_date
argument_list|,
name|iso_time
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|vol_desc
operator|.
name|expiration_date
argument_list|,
literal|"0000000000000000"
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|vol_desc
operator|.
name|effective_date
argument_list|,
name|iso_time
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* For some reason, Young Minds writes this twice.  Aw, what the heck */
name|xfwrite
argument_list|(
operator|&
name|vol_desc
argument_list|,
literal|1
argument_list|,
literal|2048
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
operator|&
name|vol_desc
argument_list|,
literal|1
argument_list|,
literal|2048
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|last_extent_written
operator|+=
literal|2
expr_stmt|;
comment|/* Now write the end volume descriptor.  Much simpler than the other one */
name|memset
argument_list|(
operator|&
name|vol_desc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|vol_desc
argument_list|)
argument_list|)
expr_stmt|;
name|vol_desc
operator|.
name|type
index|[
literal|0
index|]
operator|=
name|ISO_VD_END
expr_stmt|;
name|memcpy
argument_list|(
name|vol_desc
operator|.
name|id
argument_list|,
name|ISO_STANDARD_ID
argument_list|,
sizeof|sizeof
argument_list|(
name|ISO_STANDARD_ID
argument_list|)
argument_list|)
expr_stmt|;
name|vol_desc
operator|.
name|version
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|xfwrite
argument_list|(
operator|&
name|vol_desc
argument_list|,
literal|1
argument_list|,
literal|2048
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
operator|&
name|vol_desc
argument_list|,
literal|1
argument_list|,
literal|2048
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|last_extent_written
operator|+=
literal|2
expr_stmt|;
comment|/* Next we write the path tables */
name|xfwrite
argument_list|(
name|path_table_l
argument_list|,
literal|1
argument_list|,
name|path_blocks
operator|<<
literal|11
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|path_table_l
argument_list|,
literal|1
argument_list|,
name|path_blocks
operator|<<
literal|11
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|path_table_m
argument_list|,
literal|1
argument_list|,
name|path_blocks
operator|<<
literal|11
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|xfwrite
argument_list|(
name|path_table_m
argument_list|,
literal|1
argument_list|,
name|path_blocks
operator|<<
literal|11
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|last_extent_written
operator|+=
literal|4
operator|*
name|path_blocks
expr_stmt|;
name|free
argument_list|(
name|path_table_l
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path_table_m
argument_list|)
expr_stmt|;
name|path_table_l
operator|=
name|NULL
expr_stmt|;
name|path_table_m
operator|=
name|NULL
expr_stmt|;
comment|/* OK, all done with that crap.  Now write out the directories.      This is where the fur starts to fly, because we need to keep track of      each file as we find it and keep track of where we put it. */
ifdef|#
directive|ifdef
name|DBG_ISO
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total directory extents being written = %d\n"
argument_list|,
name|last_extent
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|generate_one_directory(root, outfile);
endif|#
directive|endif
name|generate_iso9660_directories
argument_list|(
name|root
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|extension_record
condition|)
block|{
name|xfwrite
argument_list|(
name|extension_record
argument_list|,
literal|1
argument_list|,
name|SECTOR_SIZE
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|last_extent_written
operator|++
expr_stmt|;
block|}
comment|/* Now write all of the files that we need. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total extents scheduled to be written = %d\n"
argument_list|,
name|last_extent
argument_list|)
expr_stmt|;
name|write_files
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total extents actually written = %d\n"
argument_list|,
name|last_extent_written
argument_list|)
expr_stmt|;
comment|/* Hard links throw us off here */
if|if
condition|(
name|should_write
operator|!=
name|last_extent
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Number of extents written not what was predicted.  Please fix.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Predicted = %d, written = %d\n"
argument_list|,
name|should_write
argument_list|,
name|last_extent
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total translation table size: %d\n"
argument_list|,
name|table_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total rockridge attributes bytes: %d\n"
argument_list|,
name|rockridge_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total directory bytes: %d\n"
argument_list|,
name|total_dir_size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Path table size(bytes): %d\n"
argument_list|,
name|path_table_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"next extent, last_extent, last_extent_written %d %d %d\n"
argument_list|,
name|next_extent
argument_list|,
name|last_extent
argument_list|,
name|last_extent_written
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

end_unit

