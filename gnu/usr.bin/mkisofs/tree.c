begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * File tree.c - scan directory  tree and build memory structures for iso9660  * filesystem     Written by Eric Youngdale (1993).     Copyright 1993 Yggdrasil Computing, Incorporated     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HASSYSMACROS
end_ifdef

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<vms/fabdef.h>
end_include

begin_include
include|#
directive|include
file|"vms.h"
end_include

begin_function_decl
specifier|extern
name|char
modifier|*
name|strdup
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"mkisofs.h"
end_include

begin_include
include|#
directive|include
file|"iso9660.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"exclude.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NON_UNIXFS
end_ifdef

begin_define
define|#
directive|define
name|S_ISLNK
parameter_list|(
name|m
parameter_list|)
value|(0)
end_define

begin_define
define|#
directive|define
name|S_ISSOCK
parameter_list|(
name|m
parameter_list|)
value|(0)
end_define

begin_define
define|#
directive|define
name|S_ISFIFO
parameter_list|(
name|m
parameter_list|)
value|(0)
end_define

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISLNK
end_ifndef

begin_define
define|#
directive|define
name|S_ISLNK
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFLNK)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISSOCK
end_ifndef

begin_define
define|#
directive|define
name|S_ISSOCK
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFSOCK)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__svr4__
end_ifdef

begin_function_decl
specifier|extern
name|char
modifier|*
name|strdup
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  WALNUT CREEK CDROM HACK  -- rab 950126 */
end_comment

begin_decl_stmt
specifier|static
name|char
name|trans_tbl
index|[]
init|=
literal|"00_TRANS.TBL"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|symlink_buff
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|stat
name|fstatbuf
init|=
block|{
literal|0
block|,}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We use this for the artificial entries we create */
end_comment

begin_decl_stmt
name|struct
name|stat
name|root_statbuf
init|=
block|{
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stat buffer for root directory */
end_comment

begin_decl_stmt
name|struct
name|directory
modifier|*
name|reloc_dir
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|FDECL1
parameter_list|(
name|sort_n_finish
parameter_list|,
name|struct
name|directory
modifier|*
parameter_list|,
name|this_dir
parameter_list|)
block|{
name|struct
name|directory_entry
modifier|*
name|s_entry
decl_stmt|,
modifier|*
name|s_entry1
decl_stmt|;
name|time_t
name|current_time
decl_stmt|;
name|struct
name|directory_entry
modifier|*
name|table
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|new_reclen
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|;
name|int
name|tablesize
init|=
literal|0
decl_stmt|;
name|char
name|newname
index|[
literal|34
index|]
decl_stmt|,
name|rootname
index|[
literal|34
index|]
decl_stmt|;
comment|/* Here we can take the opportunity to toss duplicate entries from the      directory.  */
name|table
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fstatbuf
operator|.
name|st_ctime
operator|==
literal|0
condition|)
block|{
name|time
argument_list|(
operator|&
name|current_time
argument_list|)
expr_stmt|;
name|fstatbuf
operator|.
name|st_uid
operator|=
literal|0
expr_stmt|;
name|fstatbuf
operator|.
name|st_gid
operator|=
literal|0
expr_stmt|;
name|fstatbuf
operator|.
name|st_ctime
operator|=
name|current_time
expr_stmt|;
name|fstatbuf
operator|.
name|st_mtime
operator|=
name|current_time
expr_stmt|;
name|fstatbuf
operator|.
name|st_atime
operator|=
name|current_time
expr_stmt|;
block|}
empty_stmt|;
name|flush_file_hash
argument_list|()
expr_stmt|;
name|s_entry
operator|=
name|this_dir
operator|->
name|contents
expr_stmt|;
while|while
condition|(
name|s_entry
condition|)
block|{
comment|/* First assume no conflict, and handle this case */
if|if
condition|(
operator|!
operator|(
name|s_entry1
operator|=
name|find_file_hash
argument_list|(
name|s_entry
operator|->
name|isorec
operator|.
name|name
argument_list|)
operator|)
condition|)
block|{
name|add_file_hash
argument_list|(
name|s_entry
argument_list|)
expr_stmt|;
name|s_entry
operator|=
name|s_entry
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
if|if
condition|(
name|s_entry1
operator|==
name|s_entry
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Fatal goof\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* OK, handle the conflicts.  Try substitute names until we come 	     up with a winner */
name|strcpy
argument_list|(
name|rootname
argument_list|,
name|s_entry
operator|->
name|isorec
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|full_iso9660_filenames
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|rootname
argument_list|)
operator|>
literal|27
condition|)
name|rootname
index|[
literal|27
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|c
operator|=
name|strchr
argument_list|(
name|rootname
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
operator|*
name|c
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|count
operator|<
literal|1000
condition|)
block|{
name|sprintf
argument_list|(
name|newname
argument_list|,
literal|"%s.%3.3d%s"
argument_list|,
name|rootname
argument_list|,
name|count
argument_list|,
operator|(
name|s_entry
operator|->
name|isorec
operator|.
name|flags
index|[
literal|0
index|]
operator|==
literal|2
operator|||
name|omit_version_number
condition|?
literal|""
else|:
literal|";1"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
comment|/* Sigh.  VAXCRTL seems to be broken here */
block|{
name|int
name|ijk
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|newname
index|[
name|ijk
index|]
condition|)
block|{
if|if
condition|(
name|newname
index|[
name|ijk
index|]
operator|==
literal|' '
condition|)
name|newname
index|[
name|ijk
index|]
operator|=
literal|'0'
expr_stmt|;
name|ijk
operator|++
expr_stmt|;
block|}
empty_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|find_file_hash
argument_list|(
name|newname
argument_list|)
condition|)
break|break;
name|count
operator|++
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|count
operator|>=
literal|1000
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to  generate unique  name for file %s\n"
argument_list|,
name|s_entry
operator|->
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* OK, now we have a good replacement name.  Now decide which one 	     of these two beasts should get the name changed */
if|if
condition|(
name|s_entry
operator|->
name|priority
operator|<
name|s_entry1
operator|->
name|priority
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using %s for  %s%s%s (%s)\n"
argument_list|,
name|newname
argument_list|,
name|this_dir
operator|->
name|whole_name
argument_list|,
name|SPATH_SEPARATOR
argument_list|,
name|s_entry
operator|->
name|name
argument_list|,
name|s_entry1
operator|->
name|name
argument_list|)
expr_stmt|;
name|s_entry
operator|->
name|isorec
operator|.
name|name_len
index|[
literal|0
index|]
operator|=
name|strlen
argument_list|(
name|newname
argument_list|)
expr_stmt|;
name|new_reclen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|iso_directory_record
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|s_entry
operator|->
name|isorec
operator|.
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|newname
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_RockRidge
condition|)
block|{
if|if
condition|(
name|new_reclen
operator|&
literal|1
condition|)
name|new_reclen
operator|++
expr_stmt|;
comment|/* Pad to an even byte */
name|new_reclen
operator|+=
name|s_entry
operator|->
name|rr_attr_size
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|new_reclen
operator|&
literal|1
condition|)
name|new_reclen
operator|++
expr_stmt|;
comment|/* Pad to an even byte */
name|s_entry
operator|->
name|isorec
operator|.
name|length
index|[
literal|0
index|]
operator|=
name|new_reclen
expr_stmt|;
name|strcpy
argument_list|(
name|s_entry
operator|->
name|isorec
operator|.
name|name
argument_list|,
name|newname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|delete_file_hash
argument_list|(
name|s_entry1
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using %s for  %s%s%s (%s)\n"
argument_list|,
name|newname
argument_list|,
name|this_dir
operator|->
name|whole_name
argument_list|,
name|SPATH_SEPARATOR
argument_list|,
name|s_entry1
operator|->
name|name
argument_list|,
name|s_entry
operator|->
name|name
argument_list|)
expr_stmt|;
name|s_entry1
operator|->
name|isorec
operator|.
name|name_len
index|[
literal|0
index|]
operator|=
name|strlen
argument_list|(
name|newname
argument_list|)
expr_stmt|;
name|new_reclen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|iso_directory_record
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|s_entry1
operator|->
name|isorec
operator|.
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|newname
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_RockRidge
condition|)
block|{
if|if
condition|(
name|new_reclen
operator|&
literal|1
condition|)
name|new_reclen
operator|++
expr_stmt|;
comment|/* Pad to an even byte */
name|new_reclen
operator|+=
name|s_entry1
operator|->
name|rr_attr_size
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|new_reclen
operator|&
literal|1
condition|)
name|new_reclen
operator|++
expr_stmt|;
comment|/* Pad to an even byte */
name|s_entry1
operator|->
name|isorec
operator|.
name|length
index|[
literal|0
index|]
operator|=
name|new_reclen
expr_stmt|;
name|strcpy
argument_list|(
name|s_entry1
operator|->
name|isorec
operator|.
name|name
argument_list|,
name|newname
argument_list|)
expr_stmt|;
name|add_file_hash
argument_list|(
name|s_entry1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|add_file_hash
argument_list|(
name|s_entry
argument_list|)
expr_stmt|;
name|s_entry
operator|=
name|s_entry
operator|->
name|next
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|generate_tables
operator|&&
operator|!
name|find_file_hash
argument_list|(
name|trans_tbl
argument_list|)
operator|&&
operator|(
name|reloc_dir
operator|!=
name|this_dir
operator|)
condition|)
block|{
comment|/* First we need to figure out how big this table is */
for|for
control|(
name|s_entry
operator|=
name|this_dir
operator|->
name|contents
init|;
name|s_entry
condition|;
name|s_entry
operator|=
name|s_entry
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s_entry
operator|->
name|name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|s_entry
operator|->
name|name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|s_entry
operator|->
name|table
condition|)
name|tablesize
operator|+=
literal|35
operator|+
name|strlen
argument_list|(
name|s_entry
operator|->
name|table
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|table
operator|=
operator|(
expr|struct
name|directory_entry
operator|*
operator|)
name|e_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|directory_entry
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|table
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|directory_entry
argument_list|)
argument_list|)
expr_stmt|;
name|table
operator|->
name|table
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|next
operator|=
name|this_dir
operator|->
name|contents
expr_stmt|;
name|this_dir
operator|->
name|contents
operator|=
name|table
expr_stmt|;
name|table
operator|->
name|filedir
operator|=
name|root
expr_stmt|;
name|table
operator|->
name|isorec
operator|.
name|flags
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|table
operator|->
name|priority
operator|=
literal|32768
expr_stmt|;
name|iso9660_date
argument_list|(
name|table
operator|->
name|isorec
operator|.
name|date
argument_list|,
name|fstatbuf
operator|.
name|st_ctime
argument_list|)
expr_stmt|;
name|table
operator|->
name|inode
operator|=
name|TABLE_INODE
expr_stmt|;
name|table
operator|->
name|dev
operator|=
operator|(
name|dev_t
operator|)
name|UNCACHED_DEVICE
expr_stmt|;
name|set_723
argument_list|(
name|table
operator|->
name|isorec
operator|.
name|volume_sequence_number
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_733
argument_list|(
name|table
operator|->
name|isorec
operator|.
name|size
argument_list|,
name|tablesize
argument_list|)
expr_stmt|;
name|table
operator|->
name|size
operator|=
name|tablesize
expr_stmt|;
name|table
operator|->
name|filedir
operator|=
name|this_dir
expr_stmt|;
name|table
operator|->
name|name
operator|=
name|strdup
argument_list|(
literal|"<translation table>"
argument_list|)
expr_stmt|;
name|table
operator|->
name|table
operator|=
operator|(
name|char
operator|*
operator|)
name|e_malloc
argument_list|(
name|ROUND_UP
argument_list|(
name|tablesize
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|table
operator|->
name|table
argument_list|,
literal|0
argument_list|,
name|ROUND_UP
argument_list|(
name|tablesize
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* WALNUT CREEK -- 950126 */
name|iso9660_file_length
argument_list|(
name|trans_tbl
argument_list|,
name|table
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|iso9660_file_length
argument_list|(
name|trans_tbl
argument_list|,
name|table
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|use_RockRidge
condition|)
block|{
name|fstatbuf
operator|.
name|st_mode
operator|=
literal|0444
operator||
name|S_IFREG
expr_stmt|;
name|fstatbuf
operator|.
name|st_nlink
operator|=
literal|1
expr_stmt|;
name|generate_rock_ridge_attributes
argument_list|(
literal|""
argument_list|,
name|trans_tbl
argument_list|,
name|table
argument_list|,
operator|&
name|fstatbuf
argument_list|,
operator|&
name|fstatbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
for|for
control|(
name|s_entry
operator|=
name|this_dir
operator|->
name|contents
init|;
name|s_entry
condition|;
name|s_entry
operator|=
name|s_entry
operator|->
name|next
control|)
block|{
name|new_reclen
operator|=
name|strlen
argument_list|(
name|s_entry
operator|->
name|isorec
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|s_entry
operator|->
name|isorec
operator|.
name|flags
index|[
literal|0
index|]
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|s_entry
operator|->
name|name
argument_list|,
literal|"."
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|s_entry
operator|->
name|name
argument_list|,
literal|".."
argument_list|)
condition|)
block|{
name|path_table_size
operator|+=
name|new_reclen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|iso_path_table
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|new_reclen
operator|&
literal|1
condition|)
name|path_table_size
operator|++
expr_stmt|;
block|}
else|else
block|{
name|new_reclen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|this_dir
operator|==
name|root
operator|&&
name|strlen
argument_list|(
name|s_entry
operator|->
name|name
argument_list|)
operator|==
literal|1
condition|)
name|path_table_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|iso_path_table
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
if|if
condition|(
name|path_table_size
operator|&
literal|1
condition|)
name|path_table_size
operator|++
expr_stmt|;
comment|/* For odd lengths we pad */
name|s_entry
operator|->
name|isorec
operator|.
name|name_len
index|[
literal|0
index|]
operator|=
name|new_reclen
expr_stmt|;
name|new_reclen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|iso_directory_record
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|s_entry
operator|->
name|isorec
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_reclen
operator|&
literal|1
condition|)
name|new_reclen
operator|++
expr_stmt|;
if|if
condition|(
name|use_RockRidge
condition|)
block|{
name|new_reclen
operator|+=
name|s_entry
operator|->
name|rr_attr_size
expr_stmt|;
if|if
condition|(
name|new_reclen
operator|&
literal|1
condition|)
name|new_reclen
operator|++
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|new_reclen
operator|>
literal|0xff
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Fatal error - RR overflow for file %s\n"
argument_list|,
name|s_entry
operator|->
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|s_entry
operator|->
name|isorec
operator|.
name|length
index|[
literal|0
index|]
operator|=
name|new_reclen
expr_stmt|;
block|}
empty_stmt|;
name|sort_directory
argument_list|(
operator|&
name|this_dir
operator|->
name|contents
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
condition|)
block|{
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|s_entry
operator|=
name|this_dir
operator|->
name|contents
init|;
name|s_entry
condition|;
name|s_entry
operator|=
name|s_entry
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s_entry
operator|==
name|table
condition|)
continue|continue;
if|if
condition|(
operator|!
name|s_entry
operator|->
name|table
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|s_entry
operator|->
name|name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|s_entry
operator|->
name|name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"%c %-34s%s"
argument_list|,
name|s_entry
operator|->
name|table
index|[
literal|0
index|]
argument_list|,
name|s_entry
operator|->
name|isorec
operator|.
name|name
argument_list|,
name|s_entry
operator|->
name|table
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|table
operator|->
name|table
operator|+
name|count
argument_list|,
name|buffer
argument_list|,
name|strlen
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|+=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s_entry
operator|->
name|table
argument_list|)
expr_stmt|;
name|s_entry
operator|->
name|table
operator|=
name|NULL
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|count
operator|!=
name|tablesize
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Translation table size mismatch %d %d\n"
argument_list|,
name|count
argument_list|,
name|tablesize
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/* Now go through the directory and figure out how large this one will be.      Do not split a directory entry across a sector boundary */
name|s_entry
operator|=
name|this_dir
operator|->
name|contents
expr_stmt|;
name|this_dir
operator|->
name|ce_bytes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|s_entry
condition|)
block|{
name|new_reclen
operator|=
name|s_entry
operator|->
name|isorec
operator|.
name|length
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|this_dir
operator|->
name|size
operator|&
operator|(
name|SECTOR_SIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|new_reclen
operator|>=
name|SECTOR_SIZE
condition|)
name|this_dir
operator|->
name|size
operator|=
operator|(
name|this_dir
operator|->
name|size
operator|+
operator|(
name|SECTOR_SIZE
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|SECTOR_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|this_dir
operator|->
name|size
operator|+=
name|new_reclen
expr_stmt|;
comment|/* See if continuation entries were used on disc */
if|if
condition|(
name|use_RockRidge
operator|&&
name|s_entry
operator|->
name|rr_attr_size
operator|!=
name|s_entry
operator|->
name|total_rr_attr_size
condition|)
block|{
name|unsigned
name|char
modifier|*
name|pnt
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|pnt
operator|=
name|s_entry
operator|->
name|rr_attributes
expr_stmt|;
name|len
operator|=
name|s_entry
operator|->
name|total_rr_attr_size
expr_stmt|;
comment|/* We make sure that each continuation entry record is not 	       split across sectors, but each file could in theory have more 	       than one CE, so we scan through and figure out what we need. */
while|while
condition|(
name|len
operator|>
literal|3
condition|)
block|{
if|if
condition|(
name|pnt
index|[
literal|0
index|]
operator|==
literal|'C'
operator|&&
name|pnt
index|[
literal|1
index|]
operator|==
literal|'E'
condition|)
block|{
name|nbytes
operator|=
name|get_733
argument_list|(
name|pnt
operator|+
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|this_dir
operator|->
name|ce_bytes
operator|&
operator|(
name|SECTOR_SIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|nbytes
operator|>=
name|SECTOR_SIZE
condition|)
name|this_dir
operator|->
name|ce_bytes
operator|=
name|ROUND_UP
argument_list|(
name|this_dir
operator|->
name|ce_bytes
argument_list|)
expr_stmt|;
comment|/* Now store the block in the ce buffer */
name|this_dir
operator|->
name|ce_bytes
operator|+=
name|nbytes
expr_stmt|;
if|if
condition|(
name|this_dir
operator|->
name|ce_bytes
operator|&
literal|1
condition|)
name|this_dir
operator|->
name|ce_bytes
operator|++
expr_stmt|;
block|}
empty_stmt|;
name|len
operator|-=
name|pnt
index|[
literal|2
index|]
expr_stmt|;
name|pnt
operator|+=
name|pnt
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
name|s_entry
operator|=
name|s_entry
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|generate_reloc_directory
parameter_list|()
block|{
name|int
name|new_reclen
decl_stmt|;
name|time_t
name|current_time
decl_stmt|;
name|struct
name|directory_entry
modifier|*
name|s_entry
decl_stmt|;
comment|/* Create an  entry for our internal tree */
name|time
argument_list|(
operator|&
name|current_time
argument_list|)
expr_stmt|;
name|reloc_dir
operator|=
operator|(
expr|struct
name|directory
operator|*
operator|)
name|e_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|directory
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|reloc_dir
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|directory
argument_list|)
argument_list|)
expr_stmt|;
name|reloc_dir
operator|->
name|parent
operator|=
name|root
expr_stmt|;
name|reloc_dir
operator|->
name|next
operator|=
name|root
operator|->
name|subdir
expr_stmt|;
name|root
operator|->
name|subdir
operator|=
name|reloc_dir
expr_stmt|;
name|reloc_dir
operator|->
name|depth
operator|=
literal|1
expr_stmt|;
name|reloc_dir
operator|->
name|whole_name
operator|=
name|strdup
argument_list|(
literal|"./rr_moved"
argument_list|)
expr_stmt|;
name|reloc_dir
operator|->
name|de_name
operator|=
name|strdup
argument_list|(
literal|"rr_moved"
argument_list|)
expr_stmt|;
name|reloc_dir
operator|->
name|extent
operator|=
literal|0
expr_stmt|;
name|new_reclen
operator|=
name|strlen
argument_list|(
name|reloc_dir
operator|->
name|de_name
argument_list|)
expr_stmt|;
comment|/* Now create an actual directory  entry */
name|s_entry
operator|=
operator|(
expr|struct
name|directory_entry
operator|*
operator|)
name|e_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|directory_entry
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|s_entry
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|directory_entry
argument_list|)
argument_list|)
expr_stmt|;
name|s_entry
operator|->
name|next
operator|=
name|root
operator|->
name|contents
expr_stmt|;
name|reloc_dir
operator|->
name|self
operator|=
name|s_entry
expr_stmt|;
name|root
operator|->
name|contents
operator|=
name|s_entry
expr_stmt|;
name|root
operator|->
name|contents
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|reloc_dir
operator|->
name|de_name
argument_list|)
expr_stmt|;
name|root
operator|->
name|contents
operator|->
name|filedir
operator|=
name|root
expr_stmt|;
name|root
operator|->
name|contents
operator|->
name|isorec
operator|.
name|flags
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|root
operator|->
name|contents
operator|->
name|priority
operator|=
literal|32768
expr_stmt|;
name|iso9660_date
argument_list|(
name|root
operator|->
name|contents
operator|->
name|isorec
operator|.
name|date
argument_list|,
name|current_time
argument_list|)
expr_stmt|;
name|root
operator|->
name|contents
operator|->
name|inode
operator|=
name|UNCACHED_INODE
expr_stmt|;
name|root
operator|->
name|contents
operator|->
name|dev
operator|=
operator|(
name|dev_t
operator|)
name|UNCACHED_DEVICE
expr_stmt|;
name|set_723
argument_list|(
name|root
operator|->
name|contents
operator|->
name|isorec
operator|.
name|volume_sequence_number
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|iso9660_file_length
argument_list|(
name|reloc_dir
operator|->
name|de_name
argument_list|,
name|root
operator|->
name|contents
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_RockRidge
condition|)
block|{
name|fstatbuf
operator|.
name|st_mode
operator|=
literal|0555
operator||
name|S_IFDIR
expr_stmt|;
name|fstatbuf
operator|.
name|st_nlink
operator|=
literal|2
expr_stmt|;
name|generate_rock_ridge_attributes
argument_list|(
literal|""
argument_list|,
literal|"rr_moved"
argument_list|,
name|s_entry
argument_list|,
operator|&
name|fstatbuf
argument_list|,
operator|&
name|fstatbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* Now create the . and .. entries in rr_moved */
comment|/* Now create an actual directory  entry */
name|s_entry
operator|=
operator|(
expr|struct
name|directory_entry
operator|*
operator|)
name|e_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|directory_entry
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s_entry
argument_list|,
name|root
operator|->
name|contents
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|directory_entry
argument_list|)
argument_list|)
expr_stmt|;
name|s_entry
operator|->
name|name
operator|=
name|strdup
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|iso9660_file_length
argument_list|(
literal|"."
argument_list|,
name|s_entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s_entry
operator|->
name|filedir
operator|=
name|reloc_dir
expr_stmt|;
name|reloc_dir
operator|->
name|contents
operator|=
name|s_entry
expr_stmt|;
if|if
condition|(
name|use_RockRidge
condition|)
block|{
name|fstatbuf
operator|.
name|st_mode
operator|=
literal|0555
operator||
name|S_IFDIR
expr_stmt|;
name|fstatbuf
operator|.
name|st_nlink
operator|=
literal|2
expr_stmt|;
name|generate_rock_ridge_attributes
argument_list|(
literal|""
argument_list|,
literal|"."
argument_list|,
name|s_entry
argument_list|,
operator|&
name|fstatbuf
argument_list|,
operator|&
name|fstatbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|s_entry
operator|=
operator|(
expr|struct
name|directory_entry
operator|*
operator|)
name|e_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|directory_entry
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s_entry
argument_list|,
name|root
operator|->
name|contents
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|directory_entry
argument_list|)
argument_list|)
expr_stmt|;
name|s_entry
operator|->
name|name
operator|=
name|strdup
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
name|iso9660_file_length
argument_list|(
literal|".."
argument_list|,
name|s_entry
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s_entry
operator|->
name|filedir
operator|=
name|root
expr_stmt|;
name|reloc_dir
operator|->
name|contents
operator|->
name|next
operator|=
name|s_entry
expr_stmt|;
name|reloc_dir
operator|->
name|contents
operator|->
name|next
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|use_RockRidge
condition|)
block|{
name|fstatbuf
operator|.
name|st_mode
operator|=
literal|0555
operator||
name|S_IFDIR
expr_stmt|;
name|fstatbuf
operator|.
name|st_nlink
operator|=
literal|2
expr_stmt|;
name|generate_rock_ridge_attributes
argument_list|(
literal|""
argument_list|,
literal|".."
argument_list|,
name|s_entry
argument_list|,
operator|&
name|root_statbuf
argument_list|,
operator|&
name|root_statbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|FDECL1
parameter_list|(
name|increment_nlink
parameter_list|,
name|struct
name|directory_entry
modifier|*
parameter_list|,
name|s_entry
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|pnt
decl_stmt|;
name|int
name|len
decl_stmt|,
name|nlink
decl_stmt|;
name|pnt
operator|=
name|s_entry
operator|->
name|rr_attributes
expr_stmt|;
name|len
operator|=
name|s_entry
operator|->
name|total_rr_attr_size
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|pnt
index|[
literal|0
index|]
operator|==
literal|'P'
operator|&&
name|pnt
index|[
literal|1
index|]
operator|==
literal|'X'
condition|)
block|{
name|nlink
operator|=
name|get_733
argument_list|(
name|pnt
operator|+
literal|12
argument_list|)
expr_stmt|;
name|set_733
argument_list|(
name|pnt
operator|+
literal|12
argument_list|,
name|nlink
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|len
operator|-=
name|pnt
index|[
literal|2
index|]
expr_stmt|;
name|pnt
operator|+=
name|pnt
index|[
literal|2
index|]
expr_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_function
name|void
name|finish_cl_pl_entries
parameter_list|()
block|{
name|struct
name|directory_entry
modifier|*
name|s_entry
decl_stmt|,
modifier|*
name|s_entry1
decl_stmt|;
name|struct
name|directory
modifier|*
name|d_entry
decl_stmt|;
name|s_entry
operator|=
name|reloc_dir
operator|->
name|contents
expr_stmt|;
name|s_entry
operator|=
name|s_entry
operator|->
name|next
operator|->
name|next
expr_stmt|;
comment|/* Skip past . and .. */
for|for
control|(
init|;
name|s_entry
condition|;
name|s_entry
operator|=
name|s_entry
operator|->
name|next
control|)
block|{
name|d_entry
operator|=
name|reloc_dir
operator|->
name|subdir
expr_stmt|;
while|while
condition|(
name|d_entry
condition|)
block|{
if|if
condition|(
name|d_entry
operator|->
name|self
operator|==
name|s_entry
condition|)
break|break;
name|d_entry
operator|=
name|d_entry
operator|->
name|next
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|!
name|d_entry
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to locate directory parent\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* First fix the PL pointer in the directory in the rr_reloc dir */
name|s_entry1
operator|=
name|d_entry
operator|->
name|contents
operator|->
name|next
expr_stmt|;
name|set_733
argument_list|(
name|s_entry1
operator|->
name|rr_attributes
operator|+
name|s_entry1
operator|->
name|total_rr_attr_size
operator|-
literal|8
argument_list|,
name|s_entry
operator|->
name|filedir
operator|->
name|extent
argument_list|)
expr_stmt|;
comment|/* Now fix the CL pointer */
name|s_entry1
operator|=
name|s_entry
operator|->
name|parent_rec
expr_stmt|;
name|set_733
argument_list|(
name|s_entry1
operator|->
name|rr_attributes
operator|+
name|s_entry1
operator|->
name|total_rr_attr_size
operator|-
literal|8
argument_list|,
name|d_entry
operator|->
name|extent
argument_list|)
expr_stmt|;
name|s_entry
operator|->
name|filedir
operator|=
name|reloc_dir
expr_stmt|;
comment|/* Now we can fix this */
block|}
comment|/* Next we need to modify the NLINK terms in the assorted root directory records      to account for the presence of the RR_MOVED directory */
name|increment_nlink
argument_list|(
name|root
operator|->
name|self
argument_list|)
expr_stmt|;
name|increment_nlink
argument_list|(
name|root
operator|->
name|self
operator|->
name|next
argument_list|)
expr_stmt|;
name|d_entry
operator|=
name|root
operator|->
name|subdir
expr_stmt|;
while|while
condition|(
name|d_entry
condition|)
block|{
name|increment_nlink
argument_list|(
name|d_entry
operator|->
name|contents
operator|->
name|next
argument_list|)
expr_stmt|;
name|d_entry
operator|=
name|d_entry
operator|->
name|next
expr_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function scans the directory tree, looking for files, and it makes  * note of everything that is found.  We also begin to construct the ISO9660  * directory entries, so that we can determine how large each directory is.  */
end_comment

begin_function
name|int
name|FDECL2
parameter_list|(
name|scan_directory_tree
parameter_list|,
name|char
modifier|*
parameter_list|,
name|path
parameter_list|,
name|struct
name|directory_entry
modifier|*
parameter_list|,
name|de
parameter_list|)
block|{
name|DIR
modifier|*
name|current_dir
decl_stmt|;
name|char
name|whole_path
index|[
literal|1024
index|]
decl_stmt|;
name|struct
name|dirent
modifier|*
name|d_entry
decl_stmt|;
name|struct
name|directory_entry
modifier|*
name|s_entry
decl_stmt|,
modifier|*
name|s_entry1
decl_stmt|;
name|struct
name|directory
modifier|*
name|this_dir
decl_stmt|,
modifier|*
name|next_brother
decl_stmt|,
modifier|*
name|parent
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|,
name|lstatbuf
decl_stmt|;
name|int
name|status
decl_stmt|,
name|dflag
decl_stmt|;
name|char
modifier|*
name|cpnt
decl_stmt|;
name|int
name|new_reclen
decl_stmt|;
name|int
name|deep_flag
decl_stmt|;
name|current_dir
operator|=
name|opendir
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|d_entry
operator|=
name|NULL
expr_stmt|;
comment|/* Apparently NFS sometimes allows you to open the directory, but      then refuses to allow you to read the contents.  Allow for this */
if|if
condition|(
name|current_dir
condition|)
name|d_entry
operator|=
name|readdir
argument_list|(
name|current_dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current_dir
operator|||
operator|!
name|d_entry
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to open directory %s\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|de
operator|->
name|isorec
operator|.
name|flags
index|[
literal|0
index|]
operator|&=
operator|~
literal|2
expr_stmt|;
comment|/* Mark as not a directory */
if|if
condition|(
name|current_dir
condition|)
name|closedir
argument_list|(
name|current_dir
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
empty_stmt|;
name|parent
operator|=
name|de
operator|->
name|filedir
expr_stmt|;
comment|/* Set up the struct for the current directory, and insert it into the      tree */
ifdef|#
directive|ifdef
name|VMS
name|vms_path_fixup
argument_list|(
name|path
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|this_dir
operator|=
operator|(
expr|struct
name|directory
operator|*
operator|)
name|e_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|directory
argument_list|)
argument_list|)
expr_stmt|;
name|this_dir
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|new_reclen
operator|=
literal|0
expr_stmt|;
name|this_dir
operator|->
name|subdir
operator|=
name|NULL
expr_stmt|;
name|this_dir
operator|->
name|self
operator|=
name|de
expr_stmt|;
name|this_dir
operator|->
name|contents
operator|=
name|NULL
expr_stmt|;
name|this_dir
operator|->
name|whole_name
operator|=
name|strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|cpnt
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
name|PATH_SEPARATOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpnt
condition|)
name|cpnt
operator|++
expr_stmt|;
else|else
name|cpnt
operator|=
name|path
expr_stmt|;
name|this_dir
operator|->
name|de_name
operator|=
name|strdup
argument_list|(
name|cpnt
argument_list|)
expr_stmt|;
name|this_dir
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|this_dir
operator|->
name|extent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|parent
operator|||
name|parent
operator|==
name|root
condition|)
block|{
if|if
condition|(
operator|!
name|root
condition|)
block|{
name|root
operator|=
name|this_dir
expr_stmt|;
comment|/* First time through for root directory only */
name|root
operator|->
name|depth
operator|=
literal|0
expr_stmt|;
name|root
operator|->
name|parent
operator|=
name|root
expr_stmt|;
block|}
else|else
block|{
name|this_dir
operator|->
name|depth
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|root
operator|->
name|subdir
condition|)
name|root
operator|->
name|subdir
operator|=
name|this_dir
expr_stmt|;
else|else
block|{
name|next_brother
operator|=
name|root
operator|->
name|subdir
expr_stmt|;
while|while
condition|(
name|next_brother
operator|->
name|next
condition|)
name|next_brother
operator|=
name|next_brother
operator|->
name|next
expr_stmt|;
name|next_brother
operator|->
name|next
operator|=
name|this_dir
expr_stmt|;
block|}
empty_stmt|;
name|this_dir
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
block|}
empty_stmt|;
block|}
else|else
block|{
comment|/* Come through here for  normal traversal of  tree */
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s(%d) "
argument_list|,
name|path
argument_list|,
name|this_dir
operator|->
name|depth
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|parent
operator|->
name|depth
operator|>
name|RR_relocation_depth
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Directories too deep  %s\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|this_dir
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|this_dir
operator|->
name|depth
operator|=
name|parent
operator|->
name|depth
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|parent
operator|->
name|subdir
condition|)
name|parent
operator|->
name|subdir
operator|=
name|this_dir
expr_stmt|;
else|else
block|{
name|next_brother
operator|=
name|parent
operator|->
name|subdir
expr_stmt|;
while|while
condition|(
name|next_brother
operator|->
name|next
condition|)
name|next_brother
operator|=
name|next_brother
operator|->
name|next
expr_stmt|;
name|next_brother
operator|->
name|next
operator|=
name|this_dir
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/* Now we scan the directory itself, and look at what is inside of it. */
name|dflag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
operator|==
literal|1
condition|)
block|{
comment|/* The first time through, skip this, since we already asked for        the first entry when we opened the directory. */
if|if
condition|(
name|dflag
condition|)
name|d_entry
operator|=
name|readdir
argument_list|(
name|current_dir
argument_list|)
expr_stmt|;
name|dflag
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|d_entry
condition|)
break|break;
comment|/* OK, got a valid entry */
comment|/* If we do not want all files, then pitch the backups. */
if|if
condition|(
operator|!
name|all_files
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|d_entry
operator|->
name|d_name
argument_list|,
literal|'~'
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|strchr
argument_list|(
name|d_entry
operator|->
name|d_name
argument_list|,
literal|'#'
argument_list|)
condition|)
continue|continue;
block|}
empty_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
name|strlen
argument_list|(
name|d_entry
operator|->
name|d_name
argument_list|)
operator|+
literal|2
operator|>
sizeof|sizeof
argument_list|(
name|whole_path
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Overflow of stat buffer\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* Generate the complete ASCII path for this file */
name|strcpy
argument_list|(
name|whole_path
argument_list|,
name|path
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
if|if
condition|(
name|whole_path
index|[
name|strlen
argument_list|(
name|whole_path
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|strcat
argument_list|(
name|whole_path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcat
argument_list|(
name|whole_path
argument_list|,
name|d_entry
operator|->
name|d_name
argument_list|)
expr_stmt|;
comment|/* Should we exclude this file? */
if|if
condition|(
name|is_excluded
argument_list|(
name|whole_path
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Excluded: %s\n"
argument_list|,
name|whole_path
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|#
directive|if
literal|0
block|if (verbose)  fprintf(stderr, "%s\n",whole_path);
endif|#
directive|endif
name|status
operator|=
name|stat
argument_list|(
name|whole_path
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
name|lstat
argument_list|(
name|whole_path
argument_list|,
operator|&
name|lstatbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_dir
operator|==
name|root
operator|&&
name|strcmp
argument_list|(
name|d_entry
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
name|root_statbuf
operator|=
name|statbuf
expr_stmt|;
comment|/* Save this for later on */
comment|/* We do this to make sure that the root entries are consistent */
if|if
condition|(
name|this_dir
operator|==
name|root
operator|&&
name|strcmp
argument_list|(
name|d_entry
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|statbuf
operator|=
name|root_statbuf
expr_stmt|;
name|lstatbuf
operator|=
name|root_statbuf
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|S_ISLNK
argument_list|(
name|lstatbuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* Here we decide how to handle the symbolic links.  Here we 	       handle the general case - if we are not following links or there is an 	       error, then we must change something.  If RR is in use, it is easy, we 	       let RR describe the file.  If not, then we punt the file. */
if|if
condition|(
operator|(
name|status
operator|||
operator|!
name|follow_links
operator|)
condition|)
block|{
if|if
condition|(
name|use_RockRidge
condition|)
block|{
name|status
operator|=
literal|0
expr_stmt|;
name|statbuf
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|STAT_INODE
argument_list|(
name|statbuf
argument_list|)
operator|=
name|UNCACHED_INODE
expr_stmt|;
name|statbuf
operator|.
name|st_dev
operator|=
operator|(
name|dev_t
operator|)
name|UNCACHED_DEVICE
expr_stmt|;
name|statbuf
operator|.
name|st_mode
operator|=
operator|(
name|statbuf
operator|.
name|st_mode
operator|&
operator|~
name|S_IFMT
operator|)
operator||
name|S_IFREG
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|follow_links
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to stat file %s - ignoring and continuing.\n"
argument_list|,
name|whole_path
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Symlink %s ignored - continuing.\n"
argument_list|,
name|whole_path
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Non Rock Ridge discs - ignore all symlinks */
block|}
empty_stmt|;
block|}
comment|/* Here we handle a different kind of case.  Here we have a symlink, 	       but we want to follow symlinks.  If we run across a directory loop, 	       then we need to pretend that we are not following symlinks for this file. 	       If this is the first time we have seen this, then make this seem 	       as if there was no symlink there in the first place */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|d_entry
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|d_entry
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
condition|)
block|{
if|if
condition|(
name|find_directory_hash
argument_list|(
name|statbuf
operator|.
name|st_dev
argument_list|,
name|STAT_INODE
argument_list|(
name|statbuf
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Infinite loop detected (%s)\n"
argument_list|,
name|whole_path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|use_RockRidge
condition|)
continue|continue;
name|statbuf
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|STAT_INODE
argument_list|(
name|statbuf
argument_list|)
operator|=
name|UNCACHED_INODE
expr_stmt|;
name|statbuf
operator|.
name|st_dev
operator|=
operator|(
name|dev_t
operator|)
name|UNCACHED_DEVICE
expr_stmt|;
name|statbuf
operator|.
name|st_mode
operator|=
operator|(
name|statbuf
operator|.
name|st_mode
operator|&
operator|~
name|S_IFMT
operator|)
operator||
name|S_IFREG
expr_stmt|;
block|}
else|else
block|{
name|lstatbuf
operator|=
name|statbuf
expr_stmt|;
name|add_directory_hash
argument_list|(
name|statbuf
operator|.
name|st_dev
argument_list|,
name|STAT_INODE
argument_list|(
name|statbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
ifdef|#
directive|ifdef
name|VMS
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|lstatbuf
operator|.
name|st_mode
argument_list|)
operator|&&
operator|(
name|statbuf
operator|.
name|st_fab_rfm
operator|!=
name|FAB$C_FIX
operator|&&
name|statbuf
operator|.
name|st_fab_rfm
operator|!=
name|FAB$C_STMLF
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning - file %s has an unsupported VMS record"
literal|" format (%d)\n"
argument_list|,
name|whole_path
argument_list|,
name|statbuf
operator|.
name|st_fab_rfm
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
endif|#
directive|endif
if|if
condition|(
name|S_ISREG
argument_list|(
name|lstatbuf
operator|.
name|st_mode
argument_list|)
operator|&&
operator|(
name|status
operator|=
name|access
argument_list|(
name|whole_path
argument_list|,
name|R_OK
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"File %s is not readable (errno = %d) - ignoring\n"
argument_list|,
name|whole_path
argument_list|,
name|errno
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Add this so that we can detect directory loops with hard links.      If we are set up to follow symlinks, then we skip this checking. */
if|if
condition|(
operator|!
name|follow_links
operator|&&
name|S_ISDIR
argument_list|(
name|lstatbuf
operator|.
name|st_mode
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|d_entry
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|d_entry
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
condition|)
block|{
if|if
condition|(
name|find_directory_hash
argument_list|(
name|statbuf
operator|.
name|st_dev
argument_list|,
name|STAT_INODE
argument_list|(
name|statbuf
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Directory loop - fatal goof (%s %x %d).\n"
argument_list|,
name|whole_path
argument_list|,
name|statbuf
operator|.
name|st_dev
argument_list|,
name|STAT_INODE
argument_list|(
name|statbuf
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|add_directory_hash
argument_list|(
name|statbuf
operator|.
name|st_dev
argument_list|,
name|STAT_INODE
argument_list|(
name|statbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|!
name|S_ISCHR
argument_list|(
name|lstatbuf
operator|.
name|st_mode
argument_list|)
operator|&&
operator|!
name|S_ISBLK
argument_list|(
name|lstatbuf
operator|.
name|st_mode
argument_list|)
operator|&&
operator|!
name|S_ISFIFO
argument_list|(
name|lstatbuf
operator|.
name|st_mode
argument_list|)
operator|&&
operator|!
name|S_ISSOCK
argument_list|(
name|lstatbuf
operator|.
name|st_mode
argument_list|)
operator|&&
operator|!
name|S_ISLNK
argument_list|(
name|lstatbuf
operator|.
name|st_mode
argument_list|)
operator|&&
operator|!
name|S_ISREG
argument_list|(
name|lstatbuf
operator|.
name|st_mode
argument_list|)
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|lstatbuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown file type %s - ignoring and continuing.\n"
argument_list|,
name|whole_path
argument_list|)
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
comment|/* Who knows what trash this is - ignore and continue */
if|if
condition|(
name|status
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to stat file %s - ignoring and continuing.\n"
argument_list|,
name|whole_path
argument_list|)
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
name|s_entry
operator|=
operator|(
expr|struct
name|directory_entry
operator|*
operator|)
name|e_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|directory_entry
argument_list|)
argument_list|)
expr_stmt|;
name|s_entry
operator|->
name|next
operator|=
name|this_dir
operator|->
name|contents
expr_stmt|;
name|this_dir
operator|->
name|contents
operator|=
name|s_entry
expr_stmt|;
name|deep_flag
operator|=
literal|0
expr_stmt|;
name|s_entry
operator|->
name|table
operator|=
name|NULL
expr_stmt|;
name|s_entry
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|d_entry
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|s_entry
operator|->
name|filedir
operator|=
name|this_dir
expr_stmt|;
name|s_entry
operator|->
name|isorec
operator|.
name|flags
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|s_entry
operator|->
name|isorec
operator|.
name|ext_attr_length
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|iso9660_date
argument_list|(
name|s_entry
operator|->
name|isorec
operator|.
name|date
argument_list|,
name|statbuf
operator|.
name|st_ctime
argument_list|)
expr_stmt|;
name|s_entry
operator|->
name|isorec
operator|.
name|file_unit_size
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|s_entry
operator|->
name|isorec
operator|.
name|interleave
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|parent
operator|&&
name|parent
operator|==
name|reloc_dir
operator|&&
name|strcmp
argument_list|(
name|d_entry
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s_entry
operator|->
name|inode
operator|=
name|UNCACHED_INODE
expr_stmt|;
name|s_entry
operator|->
name|dev
operator|=
operator|(
name|dev_t
operator|)
name|UNCACHED_DEVICE
expr_stmt|;
name|deep_flag
operator|=
name|NEED_PL
expr_stmt|;
block|}
else|else
block|{
name|s_entry
operator|->
name|inode
operator|=
name|STAT_INODE
argument_list|(
name|statbuf
argument_list|)
expr_stmt|;
name|s_entry
operator|->
name|dev
operator|=
name|statbuf
operator|.
name|st_dev
expr_stmt|;
block|}
empty_stmt|;
name|set_723
argument_list|(
name|s_entry
operator|->
name|isorec
operator|.
name|volume_sequence_number
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|iso9660_file_length
argument_list|(
name|d_entry
operator|->
name|d_name
argument_list|,
name|s_entry
argument_list|,
name|S_ISDIR
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
argument_list|)
expr_stmt|;
name|s_entry
operator|->
name|rr_attr_size
operator|=
literal|0
expr_stmt|;
name|s_entry
operator|->
name|total_rr_attr_size
operator|=
literal|0
expr_stmt|;
name|s_entry
operator|->
name|rr_attributes
operator|=
name|NULL
expr_stmt|;
comment|/* Directories are assigned sizes later on */
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|set_733
argument_list|(
name|s_entry
operator|->
name|isorec
operator|.
name|size
argument_list|,
name|statbuf
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISCHR
argument_list|(
name|lstatbuf
operator|.
name|st_mode
argument_list|)
operator|||
name|S_ISBLK
argument_list|(
name|lstatbuf
operator|.
name|st_mode
argument_list|)
operator|||
name|S_ISFIFO
argument_list|(
name|lstatbuf
operator|.
name|st_mode
argument_list|)
operator|||
name|S_ISSOCK
argument_list|(
name|lstatbuf
operator|.
name|st_mode
argument_list|)
operator|||
name|S_ISLNK
argument_list|(
name|lstatbuf
operator|.
name|st_mode
argument_list|)
condition|)
name|s_entry
operator|->
name|size
operator|=
literal|0
expr_stmt|;
else|else
name|s_entry
operator|->
name|size
operator|=
name|statbuf
operator|.
name|st_size
expr_stmt|;
block|}
else|else
name|s_entry
operator|->
name|isorec
operator|.
name|flags
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|d_entry
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|d_entry
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|&&
name|S_ISDIR
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
operator|&&
name|this_dir
operator|->
name|depth
operator|>
name|RR_relocation_depth
condition|)
block|{
if|if
condition|(
operator|!
name|reloc_dir
condition|)
name|generate_reloc_directory
argument_list|()
expr_stmt|;
name|s_entry1
operator|=
operator|(
expr|struct
name|directory_entry
operator|*
operator|)
name|e_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|directory_entry
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s_entry1
argument_list|,
name|this_dir
operator|->
name|contents
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|directory_entry
argument_list|)
argument_list|)
expr_stmt|;
name|s_entry1
operator|->
name|table
operator|=
name|NULL
expr_stmt|;
name|s_entry1
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|this_dir
operator|->
name|contents
operator|->
name|name
argument_list|)
expr_stmt|;
name|s_entry1
operator|->
name|next
operator|=
name|reloc_dir
operator|->
name|contents
expr_stmt|;
name|reloc_dir
operator|->
name|contents
operator|=
name|s_entry1
expr_stmt|;
name|s_entry1
operator|->
name|priority
operator|=
literal|32768
expr_stmt|;
name|s_entry1
operator|->
name|parent_rec
operator|=
name|this_dir
operator|->
name|contents
expr_stmt|;
name|deep_flag
operator|=
name|NEED_RE
expr_stmt|;
if|if
condition|(
name|use_RockRidge
condition|)
block|{
name|generate_rock_ridge_attributes
argument_list|(
name|whole_path
argument_list|,
name|d_entry
operator|->
name|d_name
argument_list|,
name|s_entry1
argument_list|,
operator|&
name|statbuf
argument_list|,
operator|&
name|lstatbuf
argument_list|,
name|deep_flag
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|deep_flag
operator|=
literal|0
expr_stmt|;
comment|/* We need to set this temporarily so that the parent to this is correctly 		     determined. */
name|s_entry1
operator|->
name|filedir
operator|=
name|reloc_dir
expr_stmt|;
name|scan_directory_tree
argument_list|(
name|whole_path
argument_list|,
name|s_entry1
argument_list|)
expr_stmt|;
name|s_entry1
operator|->
name|filedir
operator|=
name|this_dir
expr_stmt|;
name|statbuf
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|statbuf
operator|.
name|st_mode
operator|&=
literal|0777
expr_stmt|;
name|set_733
argument_list|(
name|s_entry
operator|->
name|isorec
operator|.
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s_entry
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|s_entry
operator|->
name|isorec
operator|.
name|flags
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|s_entry
operator|->
name|inode
operator|=
name|UNCACHED_INODE
expr_stmt|;
name|deep_flag
operator|=
name|NEED_CL
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|generate_tables
operator|&&
name|strcmp
argument_list|(
name|s_entry
operator|->
name|name
argument_list|,
literal|"."
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|s_entry
operator|->
name|name
argument_list|,
literal|".."
argument_list|)
condition|)
block|{
name|char
name|buffer
index|[
literal|2048
index|]
decl_stmt|;
switch|switch
condition|(
name|lstatbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFDIR
case|:
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"D\t%s\n"
argument_list|,
name|s_entry
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NON_UNIXFS
case|case
name|S_IFBLK
case|:
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"B\t%s\t%d %d\n"
argument_list|,
name|s_entry
operator|->
name|name
argument_list|,
name|major
argument_list|(
name|statbuf
operator|.
name|st_rdev
argument_list|)
argument_list|,
name|minor
argument_list|(
name|statbuf
operator|.
name|st_rdev
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFIFO
case|:
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"P\t%s\n"
argument_list|,
name|s_entry
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFCHR
case|:
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"C\t%s\t%d %d\n"
argument_list|,
name|s_entry
operator|->
name|name
argument_list|,
name|major
argument_list|(
name|statbuf
operator|.
name|st_rdev
argument_list|)
argument_list|,
name|minor
argument_list|(
name|statbuf
operator|.
name|st_rdev
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFLNK
case|:
name|readlink
argument_list|(
name|whole_path
argument_list|,
name|symlink_buff
argument_list|,
sizeof|sizeof
argument_list|(
name|symlink_buff
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"L\t%s\t%s\n"
argument_list|,
name|s_entry
operator|->
name|name
argument_list|,
name|symlink_buff
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFSOCK
case|:
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"S\t%s\n"
argument_list|,
name|s_entry
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* NON_UNIXFS */
case|case
name|S_IFREG
case|:
default|default:
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"F\t%s\n"
argument_list|,
name|s_entry
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|s_entry
operator|->
name|table
operator|=
name|strdup
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|int
name|dflag
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|d_entry
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|d_entry
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
condition|)
block|{
name|dflag
operator|=
name|scan_directory_tree
argument_list|(
name|whole_path
argument_list|,
name|s_entry
argument_list|)
expr_stmt|;
comment|/* If unable to scan directory, mark this as a non-directory */
if|if
condition|(
operator|!
name|dflag
condition|)
name|lstatbuf
operator|.
name|st_mode
operator|=
operator|(
name|lstatbuf
operator|.
name|st_mode
operator|&
operator|~
name|S_IFMT
operator|)
operator||
name|S_IFREG
expr_stmt|;
block|}
block|}
empty_stmt|;
if|if
condition|(
name|use_RockRidge
operator|&&
name|this_dir
operator|==
name|root
operator|&&
name|strcmp
argument_list|(
name|s_entry
operator|->
name|name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
name|deep_flag
operator||=
name|NEED_CE
operator||
name|NEED_SP
expr_stmt|;
comment|/* For extension record */
comment|/* Now figure out how much room this file will take in the directory */
if|if
condition|(
name|use_RockRidge
condition|)
block|{
name|generate_rock_ridge_attributes
argument_list|(
name|whole_path
argument_list|,
name|d_entry
operator|->
name|d_name
argument_list|,
name|s_entry
argument_list|,
operator|&
name|statbuf
argument_list|,
operator|&
name|lstatbuf
argument_list|,
name|deep_flag
argument_list|)
expr_stmt|;
block|}
block|}
name|closedir
argument_list|(
name|current_dir
argument_list|)
expr_stmt|;
name|sort_n_finish
argument_list|(
name|this_dir
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|FDECL2
parameter_list|(
name|generate_iso9660_directories
parameter_list|,
name|struct
name|directory
modifier|*
parameter_list|,
name|node
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|outfile
parameter_list|)
block|{
name|struct
name|directory
modifier|*
name|dpnt
decl_stmt|;
name|dpnt
operator|=
name|node
expr_stmt|;
while|while
condition|(
name|dpnt
condition|)
block|{
name|generate_one_directory
argument_list|(
name|dpnt
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpnt
operator|->
name|subdir
condition|)
name|generate_iso9660_directories
argument_list|(
name|dpnt
operator|->
name|subdir
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|dpnt
operator|=
name|dpnt
operator|->
name|next
expr_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_function
name|void
name|FDECL1
parameter_list|(
name|dump_tree
parameter_list|,
name|struct
name|directory
modifier|*
parameter_list|,
name|node
parameter_list|)
block|{
name|struct
name|directory
modifier|*
name|dpnt
decl_stmt|;
name|dpnt
operator|=
name|node
expr_stmt|;
while|while
condition|(
name|dpnt
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%4d %5d %s\n"
argument_list|,
name|dpnt
operator|->
name|extent
argument_list|,
name|dpnt
operator|->
name|size
argument_list|,
name|dpnt
operator|->
name|de_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpnt
operator|->
name|subdir
condition|)
name|dump_tree
argument_list|(
name|dpnt
operator|->
name|subdir
argument_list|)
expr_stmt|;
name|dpnt
operator|=
name|dpnt
operator|->
name|next
expr_stmt|;
block|}
empty_stmt|;
block|}
end_function

end_unit

