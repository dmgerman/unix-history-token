begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* expr.c -operands, expressions-    Copyright (C) 1987, 1990, 1991, 1992 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_comment
comment|/*  * This is really a branch office of as-read.c. I split it out to clearly  * distinguish the world of expressions from the world of statements.  * (It also gives smaller files to re-compile.)  * Here, "operand"s are of expressions, not instructions.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_if
if|#
directive|if
name|__STDC__
operator|==
literal|1
end_if

begin_function_decl
specifier|static
name|void
name|clean_up_expression
parameter_list|(
name|expressionS
modifier|*
name|expressionP
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __STDC__ */
end_comment

begin_function_decl
specifier|static
name|void
name|clean_up_expression
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Internal. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __STDC__ */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|char
name|EXP_CHARS
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* JF hide MD floating pt stuff all the same place */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|char
name|FLT_CHARS
index|[]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|LOCAL_LABELS_DOLLAR
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|local_label_defined
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Build any floating-point literal here.  * Also build any bignum literal here.  */
end_comment

begin_comment
comment|/* LITTLENUM_TYPE	generic_buffer[6]; */
end_comment

begin_comment
comment|/* JF this is a hack */
end_comment

begin_comment
comment|/* Seems atof_machine can backscan through generic_bignum and hit whatever    happens to be loaded before it in memory.  And its way too complicated    for me to fix right.  Thus a hack.  JF:  Just make generic_bignum bigger,    and never write into the early words, thus they'll always be zero.    I hate Dean's floating-point code.  Bleh.    */
end_comment

begin_decl_stmt
name|LITTLENUM_TYPE
name|generic_bignum
index|[
name|SIZE_OF_LARGE_NUMBER
operator|+
literal|6
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FLONUM_TYPE
name|generic_floating_point_number
init|=
block|{
operator|&
name|generic_bignum
index|[
literal|6
index|]
block|,
comment|/* low (JF: Was 0) */
operator|&
name|generic_bignum
index|[
name|SIZE_OF_LARGE_NUMBER
operator|+
literal|6
operator|-
literal|1
index|]
block|,
comment|/* high JF: (added +6) */
literal|0
block|,
comment|/* leader */
literal|0
block|,
comment|/* exponent */
literal|0
comment|/* sign */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, we've been asked to assemble nan, +inf or -inf */
end_comment

begin_decl_stmt
name|int
name|generic_floating_point_magic
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  * Summary of operand().  *  * in:	Input_line_pointer points to 1st char of operand, which may  *	be a space.  *  * out:	A expressionS. X_seg determines how to understand the rest of the  *	expressionS.  *	The operand may have been empty: in this case X_seg == SEG_ABSENT.  *	Input_line_pointer->(next non-blank) char after operand.  *  */
end_comment

begin_escape
end_escape

begin_function
specifier|static
name|segT
name|operand
parameter_list|(
name|expressionP
parameter_list|)
specifier|register
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
comment|/* points to name of symbol */
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* Points to symbol */
specifier|extern
specifier|const
name|char
name|hex_value
index|[]
decl_stmt|;
comment|/* In hex_value.c */
ifdef|#
directive|ifdef
name|PIC
comment|/* XXX */
name|expressionP
operator|->
name|X_got_symbol
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* Leading whitespace is part of operand. */
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* Input_line_pointer->past char in c. */
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|c
operator|==
literal|'H'
operator|&&
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'\''
operator|)
condition|)
block|{
specifier|register
name|valueT
name|number
decl_stmt|;
comment|/* offset or (absolute) value */
specifier|register
name|short
name|int
name|digit
decl_stmt|;
comment|/* value of next digit in current radix */
comment|/* invented for humans only, hope */
comment|/* optimising compiler flushes it! */
specifier|register
name|short
name|int
name|radix
decl_stmt|;
comment|/* 2, 8, 10 or 16 */
comment|/* 0 means we saw start of a floating- */
comment|/* point constant. */
specifier|register
name|short
name|int
name|maxdig
init|=
literal|0
decl_stmt|;
comment|/* Highest permitted digit value. */
specifier|register
name|int
name|too_many_digits
init|=
literal|0
decl_stmt|;
comment|/* If we see>= this number of */
comment|/* digits, assume it is a bignum. */
specifier|register
name|char
modifier|*
name|digit_2
decl_stmt|;
comment|/*->2nd digit of number. */
name|int
name|small
decl_stmt|;
comment|/* TRUE if fits in 32 bits. */
if|if
condition|(
name|c
operator|==
literal|'H'
operator|||
name|c
operator|==
literal|'0'
condition|)
block|{
comment|/* non-decimal radix */
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
operator|)
operator|==
literal|'x'
operator|||
name|c
operator|==
literal|'X'
operator|||
name|c
operator|==
literal|'\''
condition|)
block|{
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* read past "0x" or "0X" or H' */
name|maxdig
operator|=
name|radix
operator|=
literal|16
expr_stmt|;
name|too_many_digits
operator|=
literal|9
expr_stmt|;
block|}
else|else
block|{
comment|/* If it says '0f' and the line ends or it DOESN'T look like 		   a floating point #, its a local label ref.  DTRT */
comment|/* likewise for the b's.  xoxorich. */
if|if
condition|(
operator|(
name|c
operator|==
literal|'f'
operator|||
name|c
operator|==
literal|'b'
operator|||
name|c
operator|==
literal|'B'
operator|)
operator|&&
operator|(
operator|!
operator|*
name|input_line_pointer
operator|||
operator|(
operator|!
name|strchr
argument_list|(
literal|"+-.0123456789iInN"
argument_list|,
operator|*
name|input_line_pointer
argument_list|)
operator|&&
operator|!
name|strchr
argument_list|(
name|EXP_CHARS
argument_list|,
operator|*
name|input_line_pointer
argument_list|)
operator|)
operator|)
condition|)
block|{
name|maxdig
operator|=
name|radix
operator|=
literal|10
expr_stmt|;
name|too_many_digits
operator|=
literal|11
expr_stmt|;
name|c
operator|=
literal|'0'
expr_stmt|;
name|input_line_pointer
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'b'
operator|||
name|c
operator|==
literal|'B'
condition|)
block|{
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
name|maxdig
operator|=
name|radix
operator|=
literal|2
expr_stmt|;
name|too_many_digits
operator|=
literal|33
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|&&
name|strchr
argument_list|(
name|FLT_CHARS
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|radix
operator|=
literal|0
expr_stmt|;
comment|/* Start of floating-point constant. */
comment|/* input_line_pointer->1st char of number. */
name|expressionP
operator|->
name|X_add_number
operator|=
operator|-
operator|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|?
name|tolower
argument_list|(
name|c
argument_list|)
else|:
name|c
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* By elimination, assume octal radix. */
name|radix
operator|=
name|maxdig
operator|=
literal|8
expr_stmt|;
name|too_many_digits
operator|=
literal|11
expr_stmt|;
block|}
block|}
comment|/* c == char after "0" or "0x" or "0X" or "0e" etc. */
block|}
else|else
block|{
name|maxdig
operator|=
name|radix
operator|=
literal|10
expr_stmt|;
name|too_many_digits
operator|=
literal|11
expr_stmt|;
block|}
comment|/* if operand starts with a zero */
if|if
condition|(
name|radix
condition|)
block|{
comment|/* Fixed-point integer constant. */
comment|/* May be bignum, or may fit in 32 bits. */
comment|/* 	     * Most numbers fit into 32 bits, and we want this case to be fast. 	     * So we pretend it will fit into 32 bits. If, after making up a 32 	     * bit number, we realise that we have scanned more digits than 	     * comfortably fit into 32 bits, we re-scan the digits coding 	     * them into a bignum. For decimal and octal numbers we are conservative: some 	     * numbers may be assumed bignums when in fact they do fit into 32 bits. 	     * Numbers of any radix can have excess leading zeros: we strive 	     * to recognise this and cast them back into 32 bits. 	     * We must check that the bignum really is more than 32 	     * bits, and change it back to a 32-bit number if it fits. 	     * The number we are looking for is expected to be positive, but 	     * if it fits into 32 bits as an unsigned number, we let it be a 32-bit 	     * number. The cavalier approach is for speed in ordinary cases. 	     */
name|digit_2
operator|=
name|input_line_pointer
expr_stmt|;
for|for
control|(
name|number
operator|=
literal|0
init|;
operator|(
name|digit
operator|=
name|hex_value
index|[
name|c
index|]
operator|)
operator|<
name|maxdig
condition|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
control|)
block|{
name|number
operator|=
name|number
operator|*
name|radix
operator|+
name|digit
expr_stmt|;
block|}
comment|/* C contains character after number. */
comment|/* Input_line_pointer->char after C. */
name|small
operator|=
name|input_line_pointer
operator|-
name|digit_2
operator|<
name|too_many_digits
expr_stmt|;
if|if
condition|(
operator|!
name|small
condition|)
block|{
comment|/* 		 * We saw a lot of digits. Manufacture a bignum the hard way. 		 */
name|LITTLENUM_TYPE
modifier|*
name|leader
decl_stmt|;
comment|/*->high order littlenum of the bignum. */
name|LITTLENUM_TYPE
modifier|*
name|pointer
decl_stmt|;
comment|/*->littlenum we are frobbing now. */
name|long
name|carry
decl_stmt|;
name|leader
operator|=
name|generic_bignum
expr_stmt|;
name|generic_bignum
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|generic_bignum
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* We could just use digit_2, but lets be mnemonic. */
name|input_line_pointer
operator|=
operator|--
name|digit_2
expr_stmt|;
comment|/*->1st digit. */
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
for|for
control|(
init|;
operator|(
name|carry
operator|=
name|hex_value
index|[
name|c
index|]
operator|)
operator|<
name|maxdig
condition|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
control|)
block|{
for|for
control|(
name|pointer
operator|=
name|generic_bignum
init|;
name|pointer
operator|<=
name|leader
condition|;
name|pointer
operator|++
control|)
block|{
name|long
name|work
decl_stmt|;
name|work
operator|=
name|carry
operator|+
name|radix
operator|*
operator|*
name|pointer
expr_stmt|;
operator|*
name|pointer
operator|=
name|work
operator|&
name|LITTLENUM_MASK
expr_stmt|;
name|carry
operator|=
name|work
operator|>>
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
block|}
if|if
condition|(
name|carry
condition|)
block|{
if|if
condition|(
name|leader
operator|<
name|generic_bignum
operator|+
name|SIZE_OF_LARGE_NUMBER
operator|-
literal|1
condition|)
block|{
comment|/* Room to grow a longer bignum. */
operator|*
operator|++
name|leader
operator|=
name|carry
expr_stmt|;
block|}
block|}
block|}
comment|/* Again, C is char after number, */
comment|/* input_line_pointer->after C. */
name|know
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|8
operator|==
literal|32
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|LITTLENUM_NUMBER_OF_BITS
operator|==
literal|16
argument_list|)
expr_stmt|;
comment|/* Hence the constant "2" in the next line. */
if|if
condition|(
name|leader
operator|<
name|generic_bignum
operator|+
literal|2
condition|)
block|{
comment|/* Will fit into 32 bits. */
name|number
operator|=
operator|(
operator|(
name|generic_bignum
index|[
literal|1
index|]
operator|&
name|LITTLENUM_MASK
operator|)
operator|<<
name|LITTLENUM_NUMBER_OF_BITS
operator|)
operator||
operator|(
name|generic_bignum
index|[
literal|0
index|]
operator|&
name|LITTLENUM_MASK
operator|)
expr_stmt|;
name|small
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|number
operator|=
name|leader
operator|-
name|generic_bignum
operator|+
literal|1
expr_stmt|;
comment|/* Number of littlenums in the bignum. */
block|}
block|}
if|if
condition|(
name|small
condition|)
block|{
comment|/* 		 * Here with number, in correct radix. c is the next char. 		 * Note that unlike Un*x, we allow "011f" "0x9f" to 		 * both mean the same as the (conventional) "9f". This is simply easier 		 * than checking for strict canonical form. Syntax sux! 		 */
if|if
condition|(
name|number
operator|<
literal|10
condition|)
block|{
if|if
condition|(
literal|0
ifdef|#
directive|ifdef
name|LOCAL_LABELS_FB
operator|||
name|c
operator|==
literal|'b'
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOCAL_LABELS_DOLLAR
operator|||
operator|(
name|c
operator|==
literal|'$'
operator|&&
name|local_label_defined
index|[
name|number
index|]
operator|)
endif|#
directive|endif
condition|)
block|{
comment|/* 			 * Backward ref to local label. 			 * Because it is backward, expect it to be DEFINED. 			 */
comment|/* 			 * Construct a local label. 			 */
name|name
operator|=
name|local_label_name
argument_list|(
operator|(
name|int
operator|)
name|number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
comment|/* seen before */
operator|&&
operator|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|)
condition|)
comment|/* symbol is defined: OK */
block|{
comment|/* Expected path: symbol defined. */
comment|/* Local labels are never absolute. Don't waste time checking absoluteness. */
name|know
argument_list|(
name|SEG_NORMAL
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|symbolP
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|expressionP
operator|->
name|X_seg
operator|=
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Either not seen or not defined. */
name|as_bad
argument_list|(
literal|"Backw. ref to unknown label \"%d:\", 0 assumed."
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|expressionP
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
literal|0
ifdef|#
directive|ifdef
name|LOCAL_LABELS_FB
operator|||
name|c
operator|==
literal|'f'
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOCAL_LABELS_DOLLAR
operator|||
operator|(
name|c
operator|==
literal|'$'
operator|&&
operator|!
name|local_label_defined
index|[
name|number
index|]
operator|)
endif|#
directive|endif
condition|)
block|{
comment|/* 			     * Forward reference. Expect symbol to be undefined or 			     * unknown. Undefined: seen it before. Unknown: never seen 			     * it in this pass. 			     * Construct a local label name, then an undefined symbol. 			     * Don't create a XSEG frag for it: caller may do that. 			     * Just return it as never seen before. 			     */
name|name
operator|=
name|local_label_name
argument_list|(
operator|(
name|int
operator|)
name|number
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* We have no need to check symbol properties. */
ifndef|#
directive|ifndef
name|MANY_SEGMENTS
comment|/* Since "know" puts its arg into a "string", we 			       can't have newlines in the argument.  */
name|know
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_UNKNOWN
operator|||
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_TEXT
operator|||
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_DATA
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|symbolP
expr_stmt|;
name|expressionP
operator|->
name|X_seg
operator|=
name|SEG_UNKNOWN
expr_stmt|;
name|expressionP
operator|->
name|X_subtract_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Really a number, not a local label. */
name|expressionP
operator|->
name|X_add_number
operator|=
name|number
expr_stmt|;
name|expressionP
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Restore following character. */
block|}
comment|/* if (c == 'f') */
block|}
comment|/* if (c == 'b') */
block|}
else|else
block|{
comment|/* Really a number. */
name|expressionP
operator|->
name|X_add_number
operator|=
name|number
expr_stmt|;
name|expressionP
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Restore following character. */
block|}
comment|/* if (number<10) */
block|}
else|else
block|{
name|expressionP
operator|->
name|X_add_number
operator|=
name|number
expr_stmt|;
name|expressionP
operator|->
name|X_seg
operator|=
name|SEG_BIG
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/*->char following number. */
block|}
comment|/* if (small) */
block|}
comment|/* (If integer constant) */
else|else
block|{
comment|/* input_line_pointer->*/
comment|/* floating-point constant. */
name|int
name|error_code
decl_stmt|;
name|error_code
operator|=
name|atof_generic
argument_list|(
operator|&
name|input_line_pointer
argument_list|,
literal|"."
argument_list|,
name|EXP_CHARS
argument_list|,
operator|&
name|generic_floating_point_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_code
condition|)
block|{
if|if
condition|(
name|error_code
operator|==
name|ERROR_EXPONENT_OVERFLOW
condition|)
block|{
name|as_bad
argument_list|(
literal|"Bad floating-point constant: exponent overflow, probably assembling junk"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|"Bad floating-point constant: unknown error code=%d."
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
block|}
block|}
name|expressionP
operator|->
name|X_seg
operator|=
name|SEG_BIG
expr_stmt|;
comment|/* input_line_pointer->just after constant, */
comment|/* which may point to whitespace. */
name|know
argument_list|(
name|expressionP
operator|->
name|X_add_number
operator|<
literal|0
argument_list|)
expr_stmt|;
comment|/*< 0 means "floating point". */
block|}
comment|/* if (not floating-point constant) */
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'.'
operator|&&
operator|!
name|is_part_of_name
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
specifier|extern
name|struct
name|obstack
name|frags
decl_stmt|;
comment|/* 	  JF:  '.' is pseudo symbol with value of current location in current 	  segment... 	  */
name|symbolP
operator|=
name|symbol_new
argument_list|(
literal|"\001L0"
argument_list|,
name|now_seg
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|)
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|symbolP
expr_stmt|;
name|expressionP
operator|->
name|X_seg
operator|=
name|now_seg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_name_beginner
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* here if did not begin with a digit */
comment|/* 	     * Identifier begins here. 	     * This is kludged for speed, so code is repeated. 	     */
name|name
operator|=
name|input_line_pointer
operator|-
literal|1
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* 	     * If we have an absolute symbol or a reg, then we know its value now. 	     */
name|expressionP
operator|->
name|X_seg
operator|=
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|expressionP
operator|->
name|X_seg
condition|)
block|{
case|case
name|SEG_ABSOLUTE
case|:
case|case
name|SEG_REGISTER
case|:
name|expressionP
operator|->
name|X_add_number
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
break|break;
default|default:
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PIC
if|if
condition|(
name|symbolP
operator|==
name|GOT_symbol
condition|)
block|{
name|expressionP
operator|->
name|X_got_symbol
operator|=
name|symbolP
expr_stmt|;
name|got_referenced
operator|=
literal|1
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|symbolP
expr_stmt|;
block|}
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|expressionP
operator|->
name|X_subtract_symbol
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'('
operator|||
name|c
operator|==
literal|'['
condition|)
block|{
comment|/* didn't begin with digit& not a name */
operator|(
name|void
operator|)
name|expression
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
comment|/* Expression() will pass trailing whitespace */
if|if
condition|(
name|c
operator|==
literal|'('
operator|&&
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|')'
operator|||
name|c
operator|==
literal|'['
operator|&&
operator|*
name|input_line_pointer
operator|++
operator|!=
literal|']'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Missing ')' assumed"
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
block|}
comment|/* here with input_line_pointer->char after "(...)" */
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'~'
operator|||
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'+'
condition|)
block|{
comment|/* unary operator: hope for SEG_ABSOLUTE */
switch|switch
condition|(
name|operand
argument_list|(
name|expressionP
argument_list|)
condition|)
block|{
case|case
name|SEG_ABSOLUTE
case|:
comment|/* input_line_pointer->char after operand */
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
name|expressionP
operator|->
name|X_add_number
operator|=
operator|-
name|expressionP
operator|->
name|X_add_number
expr_stmt|;
comment|/* 		 * Notice: '-' may  overflow: no warning is given. This is compatible 		 * with other people's assemblers. Sigh. 		 */
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'~'
condition|)
block|{
name|expressionP
operator|->
name|X_add_number
operator|=
operator|~
name|expressionP
operator|->
name|X_add_number
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'+'
condition|)
block|{
name|know
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* switch on unary operator */
break|break;
default|default:
comment|/* unary on non-absolute is unsuported */
if|if
condition|(
operator|!
name|SEG_NORMAL
argument_list|(
name|operand
argument_list|(
name|expressionP
argument_list|)
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Unary operator %c ignored because bad operand follows"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through for normal segments ****/
case|case
name|SEG_PASS1
case|:
case|case
name|SEG_UNKNOWN
case|:
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
block|{
comment|/* JF I hope this hack works */
name|expressionP
operator|->
name|X_subtract_symbol
operator|=
name|expressionP
operator|->
name|X_add_symbol
expr_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|=
literal|0
expr_stmt|;
name|expressionP
operator|->
name|X_seg
operator|=
name|SEG_DIFFERENCE
expr_stmt|;
break|break;
block|}
comment|/* Expression undisturbed from operand(). */
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
block|{
comment|/* 	 * Warning: to conform to other people's assemblers NO ESCAPEMENT is permitted 	 * for a single quote. The next character, parity errors and all, is taken 	 * as the value of the operand. VERY KINKY. 	 */
name|expressionP
operator|->
name|X_add_number
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
name|expressionP
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
block|}
else|else
block|{
comment|/* can't imagine any other kind of operand */
name|expressionP
operator|->
name|X_seg
operator|=
name|SEG_ABSENT
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
name|md_operand
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
block|}
comment|/*      * It is more 'efficient' to clean up the expressions when they are created.      * Doing it here saves lines of code.      */
name|clean_up_expression
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/*->1st char after operand. */
name|know
argument_list|(
operator|*
name|input_line_pointer
operator|!=
literal|' '
argument_list|)
expr_stmt|;
return|return
operator|(
name|expressionP
operator|->
name|X_seg
operator|)
return|;
block|}
end_function

begin_comment
comment|/* operand() */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Internal. Simplify a struct expression for use by expr() */
end_comment

begin_comment
comment|/*  * In:	address of a expressionS.  *	The X_seg field of the expressionS may only take certain values.  *	Now, we permit SEG_PASS1 to make code smaller& faster.  *	Elsewise we waste time special-case testing. Sigh. Ditto SEG_ABSENT.  * Out:	expressionS may have been modified:  *	'foo-foo' symbol references cancelled to 0,  *		which changes X_seg from SEG_DIFFERENCE to SEG_ABSOLUTE;  *	Unused fields zeroed to help expr().  */
end_comment

begin_function
specifier|static
name|void
name|clean_up_expression
parameter_list|(
name|expressionP
parameter_list|)
specifier|register
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
switch|switch
condition|(
name|expressionP
operator|->
name|X_seg
condition|)
block|{
case|case
name|SEG_ABSENT
case|:
case|case
name|SEG_PASS1
case|:
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_subtract_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SEG_BIG
case|:
case|case
name|SEG_ABSOLUTE
case|:
name|expressionP
operator|->
name|X_subtract_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|SEG_UNKNOWN
case|:
name|expressionP
operator|->
name|X_subtract_symbol
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|SEG_DIFFERENCE
case|:
comment|/* 	 * It does not hurt to 'cancel' NULL == NULL 	 * when comparing symbols for 'eq'ness. 	 * It is faster to re-cancel them to NULL 	 * than to check for this special case. 	 */
if|if
condition|(
name|expressionP
operator|->
name|X_subtract_symbol
operator|==
name|expressionP
operator|->
name|X_add_symbol
operator|||
operator|(
name|expressionP
operator|->
name|X_subtract_symbol
operator|&&
name|expressionP
operator|->
name|X_add_symbol
operator|&&
name|expressionP
operator|->
name|X_subtract_symbol
operator|->
name|sy_frag
operator|==
name|expressionP
operator|->
name|X_add_symbol
operator|->
name|sy_frag
operator|&&
name|S_GET_VALUE
argument_list|(
name|expressionP
operator|->
name|X_subtract_symbol
argument_list|)
operator|==
name|S_GET_VALUE
argument_list|(
name|expressionP
operator|->
name|X_add_symbol
argument_list|)
operator|)
condition|)
block|{
name|expressionP
operator|->
name|X_subtract_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
block|}
break|break;
case|case
name|SEG_REGISTER
case|:
name|expressionP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expressionP
operator|->
name|X_subtract_symbol
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|SEG_NORMAL
argument_list|(
name|expressionP
operator|->
name|X_seg
argument_list|)
condition|)
block|{
name|expressionP
operator|->
name|X_subtract_symbol
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|BAD_CASE
argument_list|(
name|expressionP
operator|->
name|X_seg
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* clean_up_expression() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			expr_part ()  *  * Internal. Made a function because this code is used in 2 places.  * Generate error or correct X_?????_symbol of expressionS.  */
end_comment

begin_comment
comment|/*  * symbol_1 += symbol_2 ... well ... sort of.  */
end_comment

begin_function
specifier|static
name|segT
name|expr_part
parameter_list|(
name|symbol_1_PP
parameter_list|,
name|symbol_2_P
parameter_list|)
name|symbolS
modifier|*
modifier|*
name|symbol_1_PP
decl_stmt|;
name|symbolS
modifier|*
name|symbol_2_P
decl_stmt|;
block|{
name|segT
name|return_value
decl_stmt|;
ifndef|#
directive|ifndef
name|MANY_SEGMENTS
name|know
argument_list|(
operator|(
operator|*
name|symbol_1_PP
operator|)
operator|==
name|NULL
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
operator|*
name|symbol_1_PP
argument_list|)
operator|==
name|SEG_TEXT
operator|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
operator|*
name|symbol_1_PP
argument_list|)
operator|==
name|SEG_DATA
operator|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
operator|*
name|symbol_1_PP
argument_list|)
operator|==
name|SEG_BSS
operator|)
operator|||
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
operator|*
name|symbol_1_PP
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|symbol_2_P
operator|==
name|NULL
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbol_2_P
argument_list|)
operator|==
name|SEG_TEXT
operator|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbol_2_P
argument_list|)
operator|==
name|SEG_DATA
operator|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbol_2_P
argument_list|)
operator|==
name|SEG_BSS
operator|)
operator|||
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbol_2_P
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|symbol_1_PP
condition|)
block|{
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
operator|*
name|symbol_1_PP
argument_list|)
condition|)
block|{
if|if
condition|(
name|symbol_2_P
condition|)
block|{
name|return_value
operator|=
name|SEG_PASS1
expr_stmt|;
operator|*
name|symbol_1_PP
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|know
argument_list|(
operator|!
name|S_IS_DEFINED
argument_list|(
operator|*
name|symbol_1_PP
argument_list|)
argument_list|)
expr_stmt|;
name|return_value
operator|=
name|SEG_UNKNOWN
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|symbol_2_P
condition|)
block|{
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbol_2_P
argument_list|)
condition|)
block|{
operator|*
name|symbol_1_PP
operator|=
name|NULL
expr_stmt|;
name|return_value
operator|=
name|SEG_PASS1
expr_stmt|;
block|}
else|else
block|{
comment|/* {seg1} - {seg2} */
name|as_bad
argument_list|(
literal|"Expression too complex, 2 symbols forgotten: \"%s\" \"%s\""
argument_list|,
name|S_GET_NAME
argument_list|(
operator|*
name|symbol_1_PP
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbol_2_P
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|symbol_1_PP
operator|=
name|NULL
expr_stmt|;
name|return_value
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
block|}
block|}
else|else
block|{
name|return_value
operator|=
name|S_GET_SEGMENT
argument_list|(
operator|*
name|symbol_1_PP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* (* symbol_1_PP) == NULL */
if|if
condition|(
name|symbol_2_P
condition|)
block|{
operator|*
name|symbol_1_PP
operator|=
name|symbol_2_P
expr_stmt|;
name|return_value
operator|=
name|S_GET_SEGMENT
argument_list|(
name|symbol_2_P
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|symbol_1_PP
operator|=
name|NULL
expr_stmt|;
name|return_value
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|MANY_SEGMENTS
name|know
argument_list|(
name|return_value
operator|==
name|SEG_ABSOLUTE
operator|||
name|return_value
operator|==
name|SEG_TEXT
operator|||
name|return_value
operator|==
name|SEG_DATA
operator|||
name|return_value
operator|==
name|SEG_BSS
operator|||
name|return_value
operator|==
name|SEG_UNKNOWN
operator|||
name|return_value
operator|==
name|SEG_PASS1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|know
argument_list|(
operator|(
operator|*
name|symbol_1_PP
operator|)
operator|==
name|NULL
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
operator|*
name|symbol_1_PP
argument_list|)
operator|==
name|return_value
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|return_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* expr_part() */
end_comment

begin_escape
end_escape

begin_function
name|void
name|ps
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s type %s%s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|s
argument_list|)
argument_list|,
name|S_IS_EXTERNAL
argument_list|(
name|s
argument_list|)
condition|?
literal|"EXTERNAL "
else|:
literal|""
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pe
parameter_list|(
name|e
parameter_list|)
name|expressionS
modifier|*
name|e
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    segment       %s\n"
argument_list|,
name|segment_name
argument_list|(
name|e
operator|->
name|X_seg
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    add_number    %ld (%lx)\n"
argument_list|,
name|e
operator|->
name|X_add_number
argument_list|,
name|e
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_add_symbol
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    add_symbol    "
argument_list|)
expr_stmt|;
name|ps
argument_list|(
name|e
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|X_subtract_symbol
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    sub_symbol    "
argument_list|)
expr_stmt|;
name|ps
argument_list|(
name|e
operator|->
name|X_subtract_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Expression parser. */
end_comment

begin_comment
comment|/*  * We allow an empty expression, and just assume (absolute,0) silently.  * Unary operators and parenthetical expressions are treated as operands.  * As usual, Q == quantity == operand, O == operator, X == expression mnemonics.  *  * We used to do a aho/ullman shift-reduce parser, but the logic got so  * warped that I flushed it and wrote a recursive-descent parser instead.  * Now things are stable, would anybody like to write a fast parser?  * Most expressions are either register (which does not even reach here)  * or 1 symbol. Then "symbol+constant" and "symbol-symbol" are common.  * So I guess it doesn't really matter how inefficient more complex expressions  * are parsed.  *  * After expr(RANK,resultP) input_line_pointer->operator of rank<= RANK.  * Also, we have consumed any leading or trailing spaces (operand does that)  * and done all intervening operators.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|O_illegal
block|,
comment|/* (0)  what we get for illegal op */
name|O_multiply
block|,
comment|/* (1)  * */
name|O_divide
block|,
comment|/* (2)  / */
name|O_modulus
block|,
comment|/* (3)  % */
name|O_left_shift
block|,
comment|/* (4)< */
name|O_right_shift
block|,
comment|/* (5)> */
name|O_bit_inclusive_or
block|,
comment|/* (6)  | */
name|O_bit_or_not
block|,
comment|/* (7)  ! */
name|O_bit_exclusive_or
block|,
comment|/* (8)  ^ */
name|O_bit_and
block|,
comment|/* (9)& */
name|O_add
block|,
comment|/* (10) + */
name|O_subtract
comment|/* (11) - */
block|}
name|operatorT
typedef|;
end_typedef

begin_define
define|#
directive|define
name|__
value|O_illegal
end_define

begin_decl_stmt
specifier|static
specifier|const
name|operatorT
name|op_encoding
index|[
literal|256
index|]
init|=
block|{
comment|/* maps ASCII->operators */
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|O_bit_or_not
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|O_modulus
block|,
name|O_bit_and
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|O_multiply
block|,
name|O_add
block|,
name|__
block|,
name|O_subtract
block|,
name|__
block|,
name|O_divide
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|O_left_shift
block|,
name|__
block|,
name|O_right_shift
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|O_bit_exclusive_or
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|O_bit_inclusive_or
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|,
name|__
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Rank	Examples  *	0	operand, (expression)  *	1	+ -  *	2& ^ ! |  *	3	* / %<<>>  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|operator_rankT
name|op_rank
index|[]
init|=
block|{
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return resultP->X_seg. */
end_comment

begin_function
name|segT
name|expr
parameter_list|(
name|rank
parameter_list|,
name|resultP
parameter_list|)
specifier|register
name|operator_rankT
name|rank
decl_stmt|;
comment|/* Larger # is higher rank. */
specifier|register
name|expressionS
modifier|*
name|resultP
decl_stmt|;
comment|/* Deliver result here. */
block|{
name|expressionS
name|right
decl_stmt|;
specifier|register
name|operatorT
name|op_left
decl_stmt|;
specifier|register
name|char
name|c_left
decl_stmt|;
comment|/* 1st operator character. */
specifier|register
name|operatorT
name|op_right
decl_stmt|;
specifier|register
name|char
name|c_right
decl_stmt|;
name|know
argument_list|(
name|rank
operator|>=
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|operand
argument_list|(
name|resultP
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|*
name|input_line_pointer
operator|!=
literal|' '
argument_list|)
expr_stmt|;
comment|/* Operand() gobbles spaces. */
name|c_left
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
comment|/* Potential operator character. */
name|op_left
operator|=
name|op_encoding
index|[
name|c_left
index|]
expr_stmt|;
while|while
condition|(
name|op_left
operator|!=
name|O_illegal
operator|&&
name|op_rank
index|[
operator|(
name|int
operator|)
name|op_left
index|]
operator|>
name|rank
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
comment|/*->after 1st character of operator. */
comment|/* Operators "<<" and ">>" have 2 characters. */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
name|c_left
operator|&&
operator|(
name|c_left
operator|==
literal|'<'
operator|||
name|c_left
operator|==
literal|'>'
operator|)
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
block|}
comment|/*->after operator. */
if|if
condition|(
name|SEG_ABSENT
operator|==
name|expr
argument_list|(
name|op_rank
index|[
operator|(
name|int
operator|)
name|op_left
index|]
argument_list|,
operator|&
name|right
argument_list|)
condition|)
block|{
name|as_warn
argument_list|(
literal|"Missing operand value assumed absolute 0."
argument_list|)
expr_stmt|;
name|resultP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|resultP
operator|->
name|X_subtract_symbol
operator|=
name|NULL
expr_stmt|;
name|resultP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|resultP
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
block|}
name|know
argument_list|(
operator|*
name|input_line_pointer
operator|!=
literal|' '
argument_list|)
expr_stmt|;
name|c_right
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
name|op_right
operator|=
name|op_encoding
index|[
name|c_right
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
name|c_right
operator|&&
operator|(
name|c_right
operator|==
literal|'<'
operator|||
name|c_right
operator|==
literal|'>'
operator|)
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
block|}
comment|/*->after operator. */
name|know
argument_list|(
operator|(
name|int
operator|)
name|op_right
operator|==
literal|0
operator|||
name|op_rank
index|[
operator|(
name|int
operator|)
name|op_right
index|]
operator|<=
name|op_rank
index|[
operator|(
name|int
operator|)
name|op_left
index|]
argument_list|)
expr_stmt|;
comment|/* input_line_pointer->after right-hand quantity. */
comment|/* left-hand quantity in resultP */
comment|/* right-hand quantity in right. */
comment|/* operator in op_left. */
if|if
condition|(
name|resultP
operator|->
name|X_seg
operator|==
name|SEG_PASS1
operator|||
name|right
operator|.
name|X_seg
operator|==
name|SEG_PASS1
condition|)
block|{
name|resultP
operator|->
name|X_seg
operator|=
name|SEG_PASS1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|resultP
operator|->
name|X_seg
operator|==
name|SEG_BIG
condition|)
block|{
name|as_warn
argument_list|(
literal|"Left operand of %c is a %s.  Integer 0 assumed."
argument_list|,
name|c_left
argument_list|,
name|resultP
operator|->
name|X_add_number
operator|>
literal|0
condition|?
literal|"bignum"
else|:
literal|"float"
argument_list|)
expr_stmt|;
name|resultP
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|resultP
operator|->
name|X_add_symbol
operator|=
literal|0
expr_stmt|;
name|resultP
operator|->
name|X_subtract_symbol
operator|=
literal|0
expr_stmt|;
name|resultP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|right
operator|.
name|X_seg
operator|==
name|SEG_BIG
condition|)
block|{
name|as_warn
argument_list|(
literal|"Right operand of %c is a %s.  Integer 0 assumed."
argument_list|,
name|c_left
argument_list|,
name|right
operator|.
name|X_add_number
operator|>
literal|0
condition|?
literal|"bignum"
else|:
literal|"float"
argument_list|)
expr_stmt|;
name|right
operator|.
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|right
operator|.
name|X_add_symbol
operator|=
literal|0
expr_stmt|;
name|right
operator|.
name|X_subtract_symbol
operator|=
literal|0
expr_stmt|;
name|right
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|op_left
operator|==
name|O_subtract
condition|)
block|{
comment|/* 				 * Convert - into + by exchanging symbols and negating number. 				 * I know -infinity can't be negated in 2's complement: 				 * but then it can't be subtracted either. This trick 				 * does not cause any further inaccuracy. 				 */
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|right
operator|.
name|X_add_number
operator|=
operator|-
name|right
operator|.
name|X_add_number
expr_stmt|;
name|symbolP
operator|=
name|right
operator|.
name|X_add_symbol
expr_stmt|;
name|right
operator|.
name|X_add_symbol
operator|=
name|right
operator|.
name|X_subtract_symbol
expr_stmt|;
name|right
operator|.
name|X_subtract_symbol
operator|=
name|symbolP
expr_stmt|;
if|if
condition|(
name|symbolP
condition|)
block|{
name|right
operator|.
name|X_seg
operator|=
name|SEG_DIFFERENCE
expr_stmt|;
block|}
name|op_left
operator|=
name|O_add
expr_stmt|;
block|}
if|if
condition|(
name|op_left
operator|==
name|O_add
condition|)
block|{
name|segT
name|seg1
decl_stmt|;
name|segT
name|seg2
decl_stmt|;
ifndef|#
directive|ifndef
name|MANY_SEGMENTS
name|know
argument_list|(
name|resultP
operator|->
name|X_seg
operator|==
name|SEG_DATA
operator|||
name|resultP
operator|->
name|X_seg
operator|==
name|SEG_TEXT
operator|||
name|resultP
operator|->
name|X_seg
operator|==
name|SEG_BSS
operator|||
name|resultP
operator|->
name|X_seg
operator|==
name|SEG_UNKNOWN
operator|||
name|resultP
operator|->
name|X_seg
operator|==
name|SEG_DIFFERENCE
operator|||
name|resultP
operator|->
name|X_seg
operator|==
name|SEG_ABSOLUTE
operator|||
name|resultP
operator|->
name|X_seg
operator|==
name|SEG_PASS1
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|right
operator|.
name|X_seg
operator|==
name|SEG_DATA
operator|||
name|right
operator|.
name|X_seg
operator|==
name|SEG_TEXT
operator|||
name|right
operator|.
name|X_seg
operator|==
name|SEG_BSS
operator|||
name|right
operator|.
name|X_seg
operator|==
name|SEG_UNKNOWN
operator|||
name|right
operator|.
name|X_seg
operator|==
name|SEG_DIFFERENCE
operator|||
name|right
operator|.
name|X_seg
operator|==
name|SEG_ABSOLUTE
operator|||
name|right
operator|.
name|X_seg
operator|==
name|SEG_PASS1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|clean_up_expression
argument_list|(
operator|&
name|right
argument_list|)
expr_stmt|;
name|clean_up_expression
argument_list|(
name|resultP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PIC
comment|/* XXX - kludge here to accomodate "_GLOBAL_OFFSET_TABLE + (x - y)"  * expressions: this only works for this special case, the  * _GLOBAL_OFFSET_TABLE thing *must* be the left operand, the whole  * expression is given the segment of right expression (always a DIFFERENCE,  * which should get resolved by fixup_segment())  */
if|if
condition|(
name|resultP
operator|->
name|X_got_symbol
condition|)
block|{
name|resultP
operator|->
name|X_add_symbol
operator|=
name|right
operator|.
name|X_add_symbol
expr_stmt|;
name|resultP
operator|->
name|X_subtract_symbol
operator|=
name|right
operator|.
name|X_subtract_symbol
expr_stmt|;
name|seg1
operator|=
name|S_GET_SEGMENT
argument_list|(
name|right
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|seg2
operator|=
name|S_GET_SEGMENT
argument_list|(
name|right
operator|.
name|X_subtract_symbol
argument_list|)
expr_stmt|;
name|resultP
operator|->
name|X_seg
operator|=
name|right
operator|.
name|X_seg
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|seg1
operator|=
name|expr_part
argument_list|(
operator|&
name|resultP
operator|->
name|X_add_symbol
argument_list|,
name|right
operator|.
name|X_add_symbol
argument_list|)
expr_stmt|;
name|seg2
operator|=
name|expr_part
argument_list|(
operator|&
name|resultP
operator|->
name|X_subtract_symbol
argument_list|,
name|right
operator|.
name|X_subtract_symbol
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PIC
block|}
endif|#
directive|endif
if|if
condition|(
name|seg1
operator|==
name|SEG_PASS1
operator|||
name|seg2
operator|==
name|SEG_PASS1
condition|)
block|{
name|need_pass_2
operator|=
literal|1
expr_stmt|;
name|resultP
operator|->
name|X_seg
operator|=
name|SEG_PASS1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|seg2
operator|==
name|SEG_ABSOLUTE
condition|)
name|resultP
operator|->
name|X_seg
operator|=
name|seg1
expr_stmt|;
elseif|else
if|if
condition|(
name|seg1
operator|!=
name|SEG_UNKNOWN
operator|&&
name|seg1
operator|!=
name|SEG_ABSOLUTE
operator|&&
name|seg2
operator|!=
name|SEG_UNKNOWN
operator|&&
name|seg1
operator|!=
name|seg2
condition|)
block|{
name|know
argument_list|(
name|seg2
operator|!=
name|SEG_ABSOLUTE
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|resultP
operator|->
name|X_subtract_symbol
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MANY_SEGMENTS
name|know
argument_list|(
name|seg1
operator|==
name|SEG_TEXT
operator|||
name|seg1
operator|==
name|SEG_DATA
operator|||
name|seg1
operator|==
name|SEG_BSS
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|seg2
operator|==
name|SEG_TEXT
operator|||
name|seg2
operator|==
name|SEG_DATA
operator|||
name|seg2
operator|==
name|SEG_BSS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|know
argument_list|(
name|resultP
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|resultP
operator|->
name|X_subtract_symbol
argument_list|)
expr_stmt|;
name|as_bad
argument_list|(
literal|"Expression too complex: forgetting %s - %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|resultP
operator|->
name|X_add_symbol
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|resultP
operator|->
name|X_subtract_symbol
argument_list|)
argument_list|)
expr_stmt|;
name|resultP
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
comment|/* Clean_up_expression() will do the rest. */
block|}
else|else
name|resultP
operator|->
name|X_seg
operator|=
name|SEG_DIFFERENCE
expr_stmt|;
name|resultP
operator|->
name|X_add_number
operator|+=
name|right
operator|.
name|X_add_number
expr_stmt|;
name|clean_up_expression
argument_list|(
name|resultP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Not +. */
if|if
condition|(
name|resultP
operator|->
name|X_seg
operator|==
name|SEG_UNKNOWN
operator|||
name|right
operator|.
name|X_seg
operator|==
name|SEG_UNKNOWN
condition|)
block|{
name|resultP
operator|->
name|X_seg
operator|=
name|SEG_PASS1
expr_stmt|;
name|need_pass_2
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|resultP
operator|->
name|X_subtract_symbol
operator|=
name|NULL
expr_stmt|;
name|resultP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
comment|/* Will be SEG_ABSOLUTE. */
if|if
condition|(
name|resultP
operator|->
name|X_seg
operator|!=
name|SEG_ABSOLUTE
operator|||
name|right
operator|.
name|X_seg
operator|!=
name|SEG_ABSOLUTE
condition|)
block|{
name|as_bad
argument_list|(
literal|"Relocation error. Absolute 0 assumed."
argument_list|)
expr_stmt|;
name|resultP
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|resultP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|op_left
condition|)
block|{
case|case
name|O_bit_inclusive_or
case|:
name|resultP
operator|->
name|X_add_number
operator||=
name|right
operator|.
name|X_add_number
expr_stmt|;
break|break;
case|case
name|O_modulus
case|:
if|if
condition|(
name|right
operator|.
name|X_add_number
condition|)
block|{
name|resultP
operator|->
name|X_add_number
operator|%=
name|right
operator|.
name|X_add_number
expr_stmt|;
block|}
else|else
block|{
name|as_warn
argument_list|(
literal|"Division by 0. 0 assumed."
argument_list|)
expr_stmt|;
name|resultP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|O_bit_and
case|:
name|resultP
operator|->
name|X_add_number
operator|&=
name|right
operator|.
name|X_add_number
expr_stmt|;
break|break;
case|case
name|O_multiply
case|:
name|resultP
operator|->
name|X_add_number
operator|*=
name|right
operator|.
name|X_add_number
expr_stmt|;
break|break;
case|case
name|O_divide
case|:
if|if
condition|(
name|right
operator|.
name|X_add_number
condition|)
block|{
name|resultP
operator|->
name|X_add_number
operator|/=
name|right
operator|.
name|X_add_number
expr_stmt|;
block|}
else|else
block|{
name|as_warn
argument_list|(
literal|"Division by 0. 0 assumed."
argument_list|)
expr_stmt|;
name|resultP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|O_left_shift
case|:
name|resultP
operator|->
name|X_add_number
operator|<<=
name|right
operator|.
name|X_add_number
expr_stmt|;
break|break;
case|case
name|O_right_shift
case|:
name|resultP
operator|->
name|X_add_number
operator|>>=
name|right
operator|.
name|X_add_number
expr_stmt|;
break|break;
case|case
name|O_bit_exclusive_or
case|:
name|resultP
operator|->
name|X_add_number
operator|^=
name|right
operator|.
name|X_add_number
expr_stmt|;
break|break;
case|case
name|O_bit_or_not
case|:
name|resultP
operator|->
name|X_add_number
operator||=
operator|~
name|right
operator|.
name|X_add_number
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|op_left
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch (operator) */
block|}
block|}
comment|/* If we have to force need_pass_2. */
block|}
comment|/* If operator was +. */
block|}
comment|/* If we didn't set need_pass_2. */
name|op_left
operator|=
name|op_right
expr_stmt|;
block|}
comment|/* While next operator is>= this rank. */
return|return
operator|(
name|resultP
operator|->
name|X_seg
operator|)
return|;
block|}
end_function

begin_comment
comment|/* expr() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			get_symbol_end()  *  * This lives here because it belongs equally in expr.c& read.c.  * Expr.c is just a branch office read.c anyway, and putting it  * here lessens the crowd at read.c.  *  * Assume input_line_pointer is at start of symbol name.  * Advance input_line_pointer past symbol name.  * Turn that character into a '\0', returning its former value.  * This allows a string compare (RMS wants symbol names to be strings)  * of the symbol name.  * There will always be a char following symbol name, because all good  * lines end in end-of-line.  */
end_comment

begin_function
name|char
name|get_symbol_end
parameter_list|()
block|{
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
name|is_part_of_name
argument_list|(
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
argument_list|)
condition|)
empty_stmt|;
empty_stmt|;
operator|*
operator|--
name|input_line_pointer
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|get_single_number
parameter_list|()
block|{
name|expressionS
name|exp
decl_stmt|;
name|operand
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
return|return
name|exp
operator|.
name|X_add_number
return|;
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * comment-column: 0  * fill-column: 131  * End:  */
end_comment

begin_comment
comment|/* end of expr.c */
end_comment

end_unit

