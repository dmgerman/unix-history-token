begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* hash.c - hash table lookup strings -    Copyright (C) 1987, 1990, 1991, 1992 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*  * BUGS, GRIPES, APOLOGIA etc.  *  * A typical user doesn't need ALL this: I intend to make a library out  * of it one day - Dean Elsner.  * Also, I want to change the definition of a symbol to (address,length)  * so I can put arbitrary binary in the names stored. [see hsh.c for that]  *  * This slime is common coupled inside the module. Com-coupling (and other  * vandalism) was done to speed running time. The interfaces at the  * module's edges are adequately clean.  *  * There is no way to (a) run a test script through this heap and (b)  * compare results with previous scripts, to see if we have broken any  * code. Use GNU (f)utilities to do this. A few commands assist test.  * The testing is awkward: it tries to be both batch& interactive.  * For now, interactive rules!  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *  The idea is to implement a symbol table. A test jig is here.  *  Symbols are arbitrary strings; they can't contain '\0'.  *	[See hsh.c for a more general symbol flavour.]  *  Each symbol is associated with a char*, which can point to anything  *  you want, allowing an arbitrary property list for each symbol.  *  *  The basic operations are:  *  *    new                     creates symbol table, returns handle  *    find (symbol)           returns char*  *    insert (symbol,char*)   error if symbol already in table  *    delete (symbol)         returns char* if symbol was in table  *    apply                   so you can delete all symbols before die()  *    die                     destroy symbol table (free up memory)  *  *  Supplementary functions include:  *  *    say                     how big? what % full?  *    replace (symbol,newval) report previous value  *    jam (symbol,value)      assert symbol:=value  *  *  You, the caller, have control over errors: this just reports them.  *  *  This package requires malloc(), free().  *  Malloc(size) returns NULL or address of char[size].  *  Free(address) frees same.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *  The code and its structures are re-enterent.  *  Before you do anything else, you must call hash_new() which will  *  return the address of a hash-table-control-block (or NULL if there  *  is not enough memory). You then use this address as a handle of the  *  symbol table by passing it to all the other hash_...() functions.  *  The only approved way to recover the memory used by the symbol table  *  is to call hash_die() with the handle of the symbol table.  *  *  Before you call hash_die() you normally delete anything pointed to  *  by individual symbols. After hash_die() you can't use that symbol  *  table again.  *  *  The char* you associate with a symbol may not be NULL (0) because  *  NULL is returned whenever a symbol is not in the table. Any other  *  value is OK, except DELETED, #defined below.  *  *  When you supply a symbol string for insertion, YOU MUST PRESERVE THE  *  STRING until that symbol is deleted from the table. The reason is that  *  only the address you supply, NOT the symbol string itself, is stored  *  in the symbol table.  *  *  You may delete and add symbols arbitrarily.  *  Any or all symbols may have the same 'value' (char *). In fact, these  *  routines don't do anything with your symbol values.  *  *  You have no right to know where the symbol:char* mapping is stored,  *  because it moves around in memory; also because we may change how it  *  works and we don't want to break your code do we? However the handle  *  (address of struct hash_control) is never changed in  *  the life of the symbol table.  *  *  What you CAN find out about a symbol table is:  *    how many slots are in the hash table?  *    how many slots are filled with symbols?  *    (total hashes,collisions) for (reads,writes) (*)  *  All of the above values vary in time.  *  (*) some of these numbers will not be meaningful if we change the  *  internals.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *  I N T E R N A L  *  *  Hash table is an array of hash_entries; each entry is a pointer to a  *  a string and a user-supplied value 1 char* wide.  *  *  The array always has 2 ** n elements, n>0, n integer.  *  There is also a 'wall' entry after the array, which is always empty  *  and acts as a sentinel to stop running off the end of the array.  *  When the array gets too full, we create a new array twice as large  *  and re-hash the symbols into the new array, then forget the old array.  *  (Of course, we copy the values into the new array before we junk the  *  old array!)  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef

begin_define
define|#
directive|define
name|FALSE
value|(0)
end_define

begin_define
define|#
directive|define
name|TRUE
value|(!FALSE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no FALSE yet */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_define
define|#
directive|define
name|error
value|as_fatal
end_define

begin_define
define|#
directive|define
name|DELETED
value|((char *)1)
end_define

begin_comment
comment|/* guarenteed invalid address */
end_comment

begin_define
define|#
directive|define
name|START_POWER
value|(11)
end_define

begin_comment
comment|/* power of two: size of new hash table */
end_comment

begin_comment
comment|/* JF was 6 */
end_comment

begin_comment
comment|/* JF These next two aren't used any more. */
end_comment

begin_comment
comment|/* #define START_SIZE    (64)	/ * 2 ** START_POWER */
end_comment

begin_comment
comment|/* #define START_FULL    (32)      / * number of entries before table expands */
end_comment

begin_define
define|#
directive|define
name|islive
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->hash_string&& ptr->hash_string != DELETED)
end_define

begin_comment
comment|/* above TRUE if a symbol is in entry @ ptr */
end_comment

begin_define
define|#
directive|define
name|STAT_SIZE
value|(0)
end_define

begin_comment
comment|/* number of slots in hash table */
end_comment

begin_comment
comment|/* the wall does not count here */
end_comment

begin_comment
comment|/* we expect this is always a power of 2 */
end_comment

begin_define
define|#
directive|define
name|STAT_ACCESS
value|(1)
end_define

begin_comment
comment|/* number of hash_ask()s */
end_comment

begin_define
define|#
directive|define
name|STAT__READ
value|(0)
end_define

begin_comment
comment|/* reading */
end_comment

begin_define
define|#
directive|define
name|STAT__WRITE
value|(1)
end_define

begin_comment
comment|/* writing */
end_comment

begin_define
define|#
directive|define
name|STAT_COLLIDE
value|(3)
end_define

begin_comment
comment|/* number of collisions (total) */
end_comment

begin_comment
comment|/* this may exceed STAT_ACCESS if we have */
end_comment

begin_comment
comment|/* lots of collisions/access */
end_comment

begin_define
define|#
directive|define
name|STAT_USED
value|(5)
end_define

begin_comment
comment|/* slots used right now */
end_comment

begin_define
define|#
directive|define
name|STATLENGTH
value|(6)
end_define

begin_comment
comment|/* size of statistics block */
end_comment

begin_if
if|#
directive|if
name|STATLENGTH
operator|!=
name|HASH_STATLENGTH
end_if

begin_expr_stmt
name|Panic
operator|!
name|Please
name|make
operator|#
name|include
literal|"stat.h"
name|agree
name|with
name|previous
name|definitions
operator|!
endif|#
directive|endif
comment|/* #define SUSPECT to do runtime checks */
comment|/* #define TEST to be a test jig for hash...() */
ifdef|#
directive|ifdef
name|TEST
comment|/* TEST: use smaller hash table */
undef|#
directive|undef
name|START_POWER
define|#
directive|define
name|START_POWER
value|(3)
undef|#
directive|undef
name|START_SIZE
define|#
directive|define
name|START_SIZE
value|(8)
undef|#
directive|undef
name|START_FULL
define|#
directive|define
name|START_FULL
value|(4)
endif|#
directive|endif
comment|/*------------------ plan ---------------------------------- i = internal    struct hash_control * c;   struct hash_entry   * e;                                                    i   int                   b[z];     buffer for statistics   z         size of b   char                * s;        symbol string (address) [ key ]   char                * v;        value string (address)  [datum]   boolean               f;        TRUE if we found s in hash table            i   char                * t;        error string; "" means OK   int                   a;        access type [0...n)                         i    c=hash_new       ()             create new hash_control    hash_die         (c)            destroy hash_control (and hash table)   table should be empty.   doesn't check if table is empty.   c has no meaning after this.    hash_say         (c,b,z)        report statistics of hash_control.   also report number of available statistics.    v=hash_delete    (c,s)          delete symbol, return old value if any.   ask()                       NULL means no old value.   f    v=hash_replace   (c,s,v)        replace old value of s with v.   ask()                       NULL means no old value: no table change.   f    t=hash_insert    (c,s,v)        insert (s,v) in c.   ask()                       return error string.   f                           it is an error to insert if s is already   in table.   if any error, c is unchanged.    t=hash_jam       (c,s,v)        assert that new value of s will be v.       i   ask()                       it may decide to GROW the table.            i   f                                                                       i   grow()                                                                  i   t=hash_grow      (c)            grow the hash table.                        i   jam()                       will invoke JAM.                            i    ?=hash_apply     (c,y)          apply y() to every symbol in c.   y                           evtries visited in 'unspecified' order.    v=hash_find      (c,s)          return value of s, or NULL if s not in c.   ask()   f    f,e=hash_ask()   (c,s,a)        return slot where s SHOULD live.            i   code()                      maintain collision stats in c.              i    .=hash_code      (c,s)          compute hash-code for s,                    i   from parameters of c.                       i    */
specifier|static
name|char
name|hash_found
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* returned by hash_ask() to stop extra */
end_comment

begin_comment
comment|/* testing. hash_ask() wants to return both */
end_comment

begin_comment
comment|/* a slot and a status. This is the status. */
end_comment

begin_comment
comment|/* TRUE: found symbol */
end_comment

begin_comment
comment|/* FALSE: absent: empty or deleted slot */
end_comment

begin_comment
comment|/* Also returned by hash_jam(). */
end_comment

begin_comment
comment|/* TRUE: we replaced a value */
end_comment

begin_comment
comment|/* FALSE: we inserted a value */
end_comment

begin_function_decl
specifier|static
name|struct
name|hash_entry
modifier|*
name|hash_ask
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hash_code
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|hash_grow
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/*  *             h a s h _ n e w ( )  *  */
end_comment

begin_function
name|struct
name|hash_control
modifier|*
name|hash_new
parameter_list|()
comment|/* create a new hash table */
comment|/* return NULL if failed */
comment|/* return handle (address of struct hash) */
block|{
specifier|register
name|struct
name|hash_control
modifier|*
name|retval
decl_stmt|;
specifier|register
name|struct
name|hash_entry
modifier|*
name|room
decl_stmt|;
comment|/* points to hash table */
specifier|register
name|struct
name|hash_entry
modifier|*
name|wall
decl_stmt|;
specifier|register
name|struct
name|hash_entry
modifier|*
name|entry
decl_stmt|;
specifier|register
name|int
modifier|*
name|ip
decl_stmt|;
comment|/* scan stats block of struct hash_control */
specifier|register
name|int
modifier|*
name|nd
decl_stmt|;
comment|/* limit of stats block */
if|if
condition|(
operator|(
name|room
operator|=
operator|(
expr|struct
name|hash_entry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hash_entry
argument_list|)
operator|*
operator|(
operator|(
literal|1
operator|<<
name|START_POWER
operator|)
operator|+
literal|1
operator|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
comment|/* +1 for the wall entry */
block|{
if|if
condition|(
operator|(
name|retval
operator|=
operator|(
expr|struct
name|hash_control
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hash_control
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|nd
operator|=
name|retval
operator|->
name|hash_stat
operator|+
name|STATLENGTH
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|retval
operator|->
name|hash_stat
init|;
name|ip
operator|<
name|nd
condition|;
name|ip
operator|++
control|)
block|{
operator|*
name|ip
operator|=
literal|0
expr_stmt|;
block|}
name|retval
operator|->
name|hash_stat
index|[
name|STAT_SIZE
index|]
operator|=
literal|1
operator|<<
name|START_POWER
expr_stmt|;
name|retval
operator|->
name|hash_mask
operator|=
operator|(
literal|1
operator|<<
name|START_POWER
operator|)
operator|-
literal|1
expr_stmt|;
name|retval
operator|->
name|hash_sizelog
operator|=
name|START_POWER
expr_stmt|;
comment|/* works for 1's compl ok */
name|retval
operator|->
name|hash_where
operator|=
name|room
expr_stmt|;
name|retval
operator|->
name|hash_wall
operator|=
name|wall
operator|=
name|room
operator|+
operator|(
literal|1
operator|<<
name|START_POWER
operator|)
expr_stmt|;
name|retval
operator|->
name|hash_full
operator|=
operator|(
literal|1
operator|<<
name|START_POWER
operator|)
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|room
init|;
name|entry
operator|<=
name|wall
condition|;
name|entry
operator|++
control|)
block|{
name|entry
operator|->
name|hash_string
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|retval
operator|=
name|NULL
expr_stmt|;
comment|/* no room for table: fake a failure */
block|}
return|return
operator|(
name|retval
operator|)
return|;
comment|/* return NULL or set-up structs */
block|}
end_function

begin_comment
comment|/*  *           h a s h _ d i e ( )  *  * Table should be empty, but this is not checked.  * To empty the table, try hash_apply()ing a symbol deleter.  * Return to free memory both the hash table and it's control  * block.  * 'handle' has no meaning after this function.  * No errors are recoverable.  */
end_comment

begin_function
name|void
name|hash_die
parameter_list|(
name|handle
parameter_list|)
name|struct
name|hash_control
modifier|*
name|handle
decl_stmt|;
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|handle
operator|->
name|hash_where
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|handle
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *           h a s h _ s a y ( )  *  * Return the size of the statistics table, and as many statistics as  * we can until either (a) we have run out of statistics or (b) caller  * has run out of buffer.  * NOTE: hash_say treats all statistics alike.  * These numbers may change with time, due to insertions, deletions  * and expansions of the table.  * The first "statistic" returned is the length of hash_stat[].  * Then contents of hash_stat[] are read out (in ascending order)  * until your buffer or hash_stat[] is exausted.  */
end_comment

begin_function
name|void
name|hash_say
parameter_list|(
name|handle
parameter_list|,
name|buffer
parameter_list|,
name|bufsiz
parameter_list|)
specifier|register
name|struct
name|hash_control
modifier|*
name|handle
decl_stmt|;
specifier|register
name|int
name|buffer
index|[
comment|/*bufsiz*/
index|]
decl_stmt|;
specifier|register
name|int
name|bufsiz
decl_stmt|;
block|{
specifier|register
name|int
modifier|*
name|nd
decl_stmt|;
comment|/* limit of statistics block */
specifier|register
name|int
modifier|*
name|ip
decl_stmt|;
comment|/* scan statistics */
name|ip
operator|=
name|handle
operator|->
name|hash_stat
expr_stmt|;
name|nd
operator|=
name|ip
operator|+
name|min
argument_list|(
name|bufsiz
operator|-
literal|1
argument_list|,
name|STATLENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufsiz
operator|>
literal|0
condition|)
comment|/* trust nothing! bufsiz<= 0 is dangerous */
block|{
operator|*
name|buffer
operator|++
operator|=
name|STATLENGTH
expr_stmt|;
for|for
control|(
init|;
name|ip
operator|<
name|nd
condition|;
name|ip
operator|++
operator|,
name|buffer
operator|++
control|)
block|{
operator|*
name|buffer
operator|=
operator|*
name|ip
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *           h a s h _ d e l e t e ( )  *  * Try to delete a symbol from the table.  * If it was there, return its value (and adjust STAT_USED).  * Otherwise, return NULL.  * Anyway, the symbol is not present after this function.  *  */
end_comment

begin_function
name|char
modifier|*
comment|/* NULL if string not in table, else */
comment|/* returns value of deleted symbol */
name|hash_delete
parameter_list|(
name|handle
parameter_list|,
name|string
parameter_list|)
specifier|register
name|struct
name|hash_control
modifier|*
name|handle
decl_stmt|;
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|retval
decl_stmt|;
comment|/* NULL if string not in table */
specifier|register
name|struct
name|hash_entry
modifier|*
name|entry
decl_stmt|;
comment|/* NULL or entry of this symbol */
name|entry
operator|=
name|hash_ask
argument_list|(
name|handle
argument_list|,
name|string
argument_list|,
name|STAT__WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_found
condition|)
block|{
name|retval
operator|=
name|entry
operator|->
name|hash_value
expr_stmt|;
name|entry
operator|->
name|hash_string
operator|=
name|DELETED
expr_stmt|;
comment|/* mark as deleted */
name|handle
operator|->
name|hash_stat
index|[
name|STAT_USED
index|]
operator|-=
literal|1
expr_stmt|;
comment|/* slots-in-use count */
ifdef|#
directive|ifdef
name|SUSPECT
if|if
condition|(
name|handle
operator|->
name|hash_stat
index|[
name|STAT_USED
index|]
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"hash_delete"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* def SUSPECT */
block|}
else|else
block|{
name|retval
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *                   h a s h _ r e p l a c e ( )  *  * Try to replace the old value of a symbol with a new value.  * Normally return the old value.  * Return NULL and don't change the table if the symbol is not already  * in the table.  */
end_comment

begin_function
name|char
modifier|*
name|hash_replace
parameter_list|(
name|handle
parameter_list|,
name|string
parameter_list|,
name|value
parameter_list|)
specifier|register
name|struct
name|hash_control
modifier|*
name|handle
decl_stmt|;
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
specifier|register
name|char
modifier|*
name|value
decl_stmt|;
block|{
specifier|register
name|struct
name|hash_entry
modifier|*
name|entry
decl_stmt|;
specifier|register
name|char
modifier|*
name|retval
decl_stmt|;
name|entry
operator|=
name|hash_ask
argument_list|(
name|handle
argument_list|,
name|string
argument_list|,
name|STAT__WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_found
condition|)
block|{
name|retval
operator|=
name|entry
operator|->
name|hash_value
expr_stmt|;
name|entry
operator|->
name|hash_value
operator|=
name|value
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|NULL
expr_stmt|;
block|}
empty_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *                   h a s h _ i n s e r t ( )  *  * Insert a (symbol-string, value) into the hash table.  * Return an error string, "" means OK.  * It is an 'error' to insert an existing symbol.  */
end_comment

begin_function
name|char
modifier|*
comment|/* return error string */
name|hash_insert
parameter_list|(
name|handle
parameter_list|,
name|string
parameter_list|,
name|value
parameter_list|)
specifier|register
name|struct
name|hash_control
modifier|*
name|handle
decl_stmt|;
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
specifier|register
name|char
modifier|*
name|value
decl_stmt|;
block|{
specifier|register
name|struct
name|hash_entry
modifier|*
name|entry
decl_stmt|;
specifier|register
name|char
modifier|*
name|retval
decl_stmt|;
name|retval
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|hash_stat
index|[
name|STAT_USED
index|]
operator|>
name|handle
operator|->
name|hash_full
condition|)
block|{
name|retval
operator|=
name|hash_grow
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|retval
condition|)
block|{
name|entry
operator|=
name|hash_ask
argument_list|(
name|handle
argument_list|,
name|string
argument_list|,
name|STAT__WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_found
condition|)
block|{
name|retval
operator|=
literal|"exists"
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|->
name|hash_value
operator|=
name|value
expr_stmt|;
name|entry
operator|->
name|hash_string
operator|=
name|string
expr_stmt|;
name|handle
operator|->
name|hash_stat
index|[
name|STAT_USED
index|]
operator|+=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *               h a s h _ j a m ( )  *  * Regardless of what was in the symbol table before, after hash_jam()  * the named symbol has the given value. The symbol is either inserted or  * (its value is) relpaced.  * An error message string is returned, "" means OK.  *  * WARNING: this may decide to grow the hashed symbol table.  * To do this, we call hash_grow(), WHICH WILL recursively CALL US.  *  * We report status internally: hash_found is TRUE if we replaced, but  * false if we inserted.  */
end_comment

begin_function
name|char
modifier|*
name|hash_jam
parameter_list|(
name|handle
parameter_list|,
name|string
parameter_list|,
name|value
parameter_list|)
specifier|register
name|struct
name|hash_control
modifier|*
name|handle
decl_stmt|;
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
specifier|register
name|char
modifier|*
name|value
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|retval
decl_stmt|;
specifier|register
name|struct
name|hash_entry
modifier|*
name|entry
decl_stmt|;
name|retval
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|handle
operator|->
name|hash_stat
index|[
name|STAT_USED
index|]
operator|>
name|handle
operator|->
name|hash_full
condition|)
block|{
name|retval
operator|=
name|hash_grow
argument_list|(
name|handle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|retval
condition|)
block|{
name|entry
operator|=
name|hash_ask
argument_list|(
name|handle
argument_list|,
name|string
argument_list|,
name|STAT__WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hash_found
condition|)
block|{
name|entry
operator|->
name|hash_string
operator|=
name|string
expr_stmt|;
name|handle
operator|->
name|hash_stat
index|[
name|STAT_USED
index|]
operator|+=
literal|1
expr_stmt|;
block|}
name|entry
operator|->
name|hash_value
operator|=
name|value
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *               h a s h _ g r o w ( )  *  * Grow a new (bigger) hash table from the old one.  * We choose to double the hash table's size.  * Return a human-scrutible error string: "" if OK.  * Warning! This uses hash_jam(), which had better not recurse  * back here! Hash_jam() conditionally calls us, but we ALWAYS  * call hash_jam()!  * Internal.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|hash_grow
parameter_list|(
name|handle
parameter_list|)
comment|/* make a hash table grow */
name|struct
name|hash_control
modifier|*
name|handle
decl_stmt|;
block|{
specifier|register
name|struct
name|hash_entry
modifier|*
name|newwall
decl_stmt|;
specifier|register
name|struct
name|hash_entry
modifier|*
name|newwhere
decl_stmt|;
name|struct
name|hash_entry
modifier|*
name|newtrack
decl_stmt|;
specifier|register
name|struct
name|hash_entry
modifier|*
name|oldtrack
decl_stmt|;
specifier|register
name|struct
name|hash_entry
modifier|*
name|oldwhere
decl_stmt|;
specifier|register
name|struct
name|hash_entry
modifier|*
name|oldwall
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|;
name|int
name|newsize
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|retval
decl_stmt|;
ifdef|#
directive|ifdef
name|SUSPECT
name|int
name|oldused
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * capture info about old hash table 	 */
name|oldwhere
operator|=
name|handle
operator|->
name|hash_where
expr_stmt|;
name|oldwall
operator|=
name|handle
operator|->
name|hash_wall
expr_stmt|;
ifdef|#
directive|ifdef
name|SUSPECT
name|oldused
operator|=
name|handle
operator|->
name|hash_stat
index|[
name|STAT_USED
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * attempt to get enough room for a hash table twice as big 	 */
name|temp
operator|=
name|handle
operator|->
name|hash_stat
index|[
name|STAT_SIZE
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|newwhere
operator|=
operator|(
expr|struct
name|hash_entry
operator|*
operator|)
name|xmalloc
argument_list|(
call|(
name|long
call|)
argument_list|(
operator|(
name|temp
operator|+
name|temp
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hash_entry
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
comment|/* +1 for wall slot */
block|{
name|retval
operator|=
literal|""
expr_stmt|;
comment|/* assume success until proven otherwise */
comment|/* 		     * have enough room: now we do all the work. 		     * double the size of everything in handle, 		     * note: hash_mask frob works for 1's& for 2's complement machines 		     */
name|handle
operator|->
name|hash_mask
operator|=
name|handle
operator|->
name|hash_mask
operator|+
name|handle
operator|->
name|hash_mask
operator|+
literal|1
expr_stmt|;
name|handle
operator|->
name|hash_stat
index|[
name|STAT_SIZE
index|]
operator|<<=
literal|1
expr_stmt|;
name|newsize
operator|=
name|handle
operator|->
name|hash_stat
index|[
name|STAT_SIZE
index|]
expr_stmt|;
name|handle
operator|->
name|hash_where
operator|=
name|newwhere
expr_stmt|;
name|handle
operator|->
name|hash_full
operator|<<=
literal|1
expr_stmt|;
name|handle
operator|->
name|hash_sizelog
operator|+=
literal|1
expr_stmt|;
name|handle
operator|->
name|hash_stat
index|[
name|STAT_USED
index|]
operator|=
literal|0
expr_stmt|;
name|handle
operator|->
name|hash_wall
operator|=
name|newwall
operator|=
name|newwhere
operator|+
name|newsize
expr_stmt|;
comment|/* 		     * set all those pesky new slots to vacant. 		     */
for|for
control|(
name|newtrack
operator|=
name|newwhere
init|;
name|newtrack
operator|<=
name|newwall
condition|;
name|newtrack
operator|++
control|)
block|{
name|newtrack
operator|->
name|hash_string
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		     * we will do a scan of the old table, the hard way, using the 		     * new control block to re-insert the data into new hash table. 		     */
name|handle
operator|->
name|hash_stat
index|[
name|STAT_USED
index|]
operator|=
literal|0
expr_stmt|;
comment|/* inserts will bump it up to correct */
for|for
control|(
name|oldtrack
operator|=
name|oldwhere
init|;
name|oldtrack
operator|<
name|oldwall
condition|;
name|oldtrack
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|string
operator|=
name|oldtrack
operator|->
name|hash_string
operator|)
operator|!=
name|NULL
operator|)
operator|&&
name|string
operator|!=
name|DELETED
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|retval
operator|=
name|hash_jam
argument_list|(
name|handle
argument_list|,
name|string
argument_list|,
name|oldtrack
operator|->
name|hash_value
argument_list|)
operator|)
condition|)
block|{
break|break;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|SUSPECT
if|if
condition|(
operator|!
operator|*
name|retval
operator|&&
name|handle
operator|->
name|hash_stat
index|[
name|STAT_USED
index|]
operator|!=
name|oldused
condition|)
block|{
name|retval
operator|=
literal|"hash_used"
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
operator|*
name|retval
condition|)
block|{
comment|/* 				 * we have a completely faked up control block. 				 * return the old hash table. 				 */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|oldwhere
argument_list|)
expr_stmt|;
comment|/* 				 * Here with success. retval is already "". 				 */
block|}
block|}
else|else
block|{
name|retval
operator|=
literal|"no room"
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *          h a s h _ a p p l y ( )  *  * Use this to scan each entry in symbol table.  * For each symbol, this calls (applys) a nominated function supplying the  * symbol's value (and the symbol's name).  * The idea is you use this to destroy whatever is associted with  * any values in the table BEFORE you destroy the table with hash_die.  * Of course, you can use it for other jobs; whenever you need to  * visit all extant symbols in the table.  *  * We choose to have a call-you-back idea for two reasons:  *  asthetic: it is a neater idea to use apply than an explicit loop  *  sensible: if we ever had to grow the symbol table (due to insertions)  *            then we would lose our place in the table when we re-hashed  *            symbols into the new table in a different order.  *  * The order symbols are visited depends entirely on the hashing function.  * Whenever you insert a (symbol, value) you risk expanding the table. If  * you do expand the table, then the hashing function WILL change, so you  * MIGHT get a different order of symbols visited. In other words, if you  * want the same order of visiting symbols as the last time you used  * hash_apply() then you better not have done any hash_insert()s or  * hash_jam()s since the last time you used hash_apply().  *  * In future we may use the value returned by your nominated function.  * One idea is to abort the scan if, after applying the function to a  * certain node, the function returns a certain code.  * To be safe, please make your functions of type char *. If you always  * return NULL, then the scan will complete, visiting every symbol in  * the table exactly once. ALL OTHER RETURNED VALUES have no meaning yet!  * Caveat Actor!  *  * The function you supply should be of the form:  *      char * myfunct(string,value)  *              char * string;        |* the symbol's name *|  *              char * value;         |* the symbol's value *|  *      {  *        |* ... *|  *        return(NULL);  *      }  *  * The returned value of hash_apply() is (char*)NULL. In future it may return  * other values. NULL means "completed scan OK". Other values have no meaning  * yet. (The function has no graceful failures.)  */
end_comment

begin_function
name|char
modifier|*
name|hash_apply
parameter_list|(
name|handle
parameter_list|,
name|function
parameter_list|)
name|struct
name|hash_control
modifier|*
name|handle
decl_stmt|;
function|char*
parameter_list|(
function|*function
end_function

begin_expr_stmt
unit|)
operator|(
operator|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|hash_entry
modifier|*
name|entry
decl_stmt|;
specifier|register
name|struct
name|hash_entry
modifier|*
name|wall
decl_stmt|;
name|wall
operator|=
name|handle
operator|->
name|hash_wall
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|handle
operator|->
name|hash_where
init|;
name|entry
operator|<
name|wall
condition|;
name|entry
operator|++
control|)
block|{
if|if
condition|(
name|islive
argument_list|(
name|entry
argument_list|)
condition|)
comment|/* silly code: tests entry->string twice! */
block|{
call|(
modifier|*
name|function
call|)
argument_list|(
name|entry
operator|->
name|hash_string
argument_list|,
name|entry
operator|->
name|hash_value
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *          h a s h _ f i n d ( )  *  * Given symbol string, find value (if any).  * Return found value or NULL.  */
end_comment

begin_function
name|char
modifier|*
name|hash_find
parameter_list|(
name|handle
parameter_list|,
name|string
parameter_list|)
comment|/* return char* or NULL */
name|struct
name|hash_control
modifier|*
name|handle
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|struct
name|hash_entry
modifier|*
name|entry
decl_stmt|;
specifier|register
name|char
modifier|*
name|retval
decl_stmt|;
name|entry
operator|=
name|hash_ask
argument_list|(
name|handle
argument_list|,
name|string
argument_list|,
name|STAT__READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_found
condition|)
block|{
name|retval
operator|=
name|entry
operator|->
name|hash_value
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *          h a s h _ a s k ( )  *  * Searches for given symbol string.  * Return the slot where it OUGHT to live. It may be there.  * Return hash_found: TRUE only if symbol is in that slot.  * Access argument is to help keep statistics in control block.  * Internal.  */
end_comment

begin_function
specifier|static
name|struct
name|hash_entry
modifier|*
comment|/* string slot, may be empty or deleted */
name|hash_ask
parameter_list|(
name|handle
parameter_list|,
name|string
parameter_list|,
name|access
parameter_list|)
name|struct
name|hash_control
modifier|*
name|handle
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|access
decl_stmt|;
comment|/* access type */
block|{
specifier|register
name|char
modifier|*
name|string1
decl_stmt|;
comment|/* JF avoid strcmp calls */
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|struct
name|hash_entry
modifier|*
name|slot
decl_stmt|;
specifier|register
name|int
name|collision
decl_stmt|;
comment|/* count collisions */
name|slot
operator|=
name|handle
operator|->
name|hash_where
operator|+
name|hash_code
argument_list|(
name|handle
argument_list|,
name|string
argument_list|)
expr_stmt|;
comment|/* start looking here */
name|handle
operator|->
name|hash_stat
index|[
name|STAT_ACCESS
operator|+
name|access
index|]
operator|+=
literal|1
expr_stmt|;
name|collision
operator|=
literal|0
expr_stmt|;
name|hash_found
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|s
operator|=
name|slot
operator|->
name|hash_string
operator|)
operator|!=
name|NULL
operator|)
operator|&&
name|s
operator|!=
name|DELETED
condition|)
block|{
for|for
control|(
name|string1
operator|=
name|string
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|string1
condition|)
name|hash_found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|string1
operator|++
operator|!=
name|c
condition|)
break|break;
block|}
if|if
condition|(
name|hash_found
condition|)
break|break;
name|collision
operator|++
expr_stmt|;
name|slot
operator|++
expr_stmt|;
block|}
comment|/* 	 * slot:                                                      return: 	 *       in use:     we found string                           slot 	 *       at empty: 	 *                   at wall:        we fell off: wrap round   ???? 	 *                   in table:       dig here                  slot 	 *       at DELETED: dig here                                  slot 	 */
if|if
condition|(
name|slot
operator|==
name|handle
operator|->
name|hash_wall
condition|)
block|{
name|slot
operator|=
name|handle
operator|->
name|hash_where
expr_stmt|;
comment|/* now look again */
while|while
condition|(
operator|(
operator|(
name|s
operator|=
name|slot
operator|->
name|hash_string
operator|)
operator|!=
name|NULL
operator|)
operator|&&
name|s
operator|!=
name|DELETED
condition|)
block|{
for|for
control|(
name|string1
operator|=
name|string
init|;
operator|*
name|s
condition|;
name|string1
operator|++
operator|,
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|string1
operator|!=
operator|*
name|s
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|s
operator|==
operator|*
name|string1
condition|)
block|{
name|hash_found
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|collision
operator|++
expr_stmt|;
name|slot
operator|++
expr_stmt|;
block|}
comment|/* 		     * slot:                                                   return: 		     *       in use: we found it                                slot 		     *       empty:  wall:         ERROR IMPOSSIBLE             !!!! 		     *               in table:     dig here                     slot 		     *       DELETED:dig here                                   slot 		     */
block|}
comment|/*   fprintf(stderr,"hash_ask(%s)->%d(%d)\n",string,hash_code(handle,string),collision); */
name|handle
operator|->
name|hash_stat
index|[
name|STAT_COLLIDE
operator|+
name|access
index|]
operator|+=
name|collision
expr_stmt|;
return|return
operator|(
name|slot
operator|)
return|;
comment|/* also return hash_found */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *           h a s h _ c o d e  *  * Does hashing of symbol string to hash number.  * Internal.  */
end_comment

begin_function
specifier|static
name|int
name|hash_code
parameter_list|(
name|handle
parameter_list|,
name|string
parameter_list|)
name|struct
name|hash_control
modifier|*
name|handle
decl_stmt|;
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|long
name|h
decl_stmt|;
comment|/* hash code built here */
specifier|register
name|long
name|c
decl_stmt|;
comment|/* each character lands here */
specifier|register
name|int
name|n
decl_stmt|;
comment|/* Amount to shift h by */
name|n
operator|=
operator|(
name|handle
operator|->
name|hash_sizelog
operator|-
literal|3
operator|)
expr_stmt|;
name|h
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|string
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
name|h
operator|+=
name|c
expr_stmt|;
name|h
operator|=
operator|(
name|h
operator|<<
literal|3
operator|)
operator|+
operator|(
name|h
operator|>>
name|n
operator|)
operator|+
name|c
expr_stmt|;
block|}
return|return
operator|(
name|h
operator|&
name|handle
operator|->
name|hash_mask
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Here is a test program to exercise above.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_define
define|#
directive|define
name|TABLES
value|(6)
end_define

begin_comment
comment|/* number of hash tables to maintain */
end_comment

begin_comment
comment|/* (at once) in any testing */
end_comment

begin_define
define|#
directive|define
name|STATBUFSIZE
value|(12)
end_define

begin_comment
comment|/* we can have 12 statistics */
end_comment

begin_decl_stmt
name|int
name|statbuf
index|[
name|STATBUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* display statistics here */
end_comment

begin_decl_stmt
name|char
name|answer
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* human farts here */
end_comment

begin_decl_stmt
name|char
modifier|*
name|hashtable
index|[
name|TABLES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* we test many hash tables at once */
end_comment

begin_decl_stmt
name|char
modifier|*
name|h
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* points to curent hash_control */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|value
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|used
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|command
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number 0:TABLES-1 of current hashed */
end_comment

begin_comment
comment|/* symbol table */
end_comment

begin_function
name|main
parameter_list|()
block|{
name|char
argument_list|(
operator|*
name|applicatee
argument_list|()
argument_list|)
expr_stmt|;
name|char
modifier|*
name|hash_find
parameter_list|()
function_decl|;
name|char
modifier|*
name|destroy
parameter_list|()
function_decl|;
name|char
modifier|*
name|what
parameter_list|()
function_decl|;
name|struct
name|hash_control
modifier|*
name|hash_new
parameter_list|()
function_decl|;
name|char
modifier|*
name|hash_replace
parameter_list|()
function_decl|;
name|int
modifier|*
name|ip
decl_stmt|;
name|number
operator|=
literal|0
expr_stmt|;
name|h
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"type h<RETURN> for help\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"hash_test command: "
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|answer
argument_list|,
literal|100
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|command
operator|=
name|answer
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|command
argument_list|)
condition|)
name|command
operator|=
name|tolower
argument_list|(
name|command
argument_list|)
expr_stmt|;
comment|/* ecch! */
switch|switch
condition|(
name|command
condition|)
block|{
case|case
literal|'#'
case|:
name|printf
argument_list|(
literal|"old hash table #=%d.\n"
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|whattable
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
for|for
control|(
name|pp
operator|=
name|hashtable
init|;
name|pp
operator|<
name|hashtable
operator|+
name|TABLES
condition|;
name|pp
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"address of hash table #%d control block is %xx\n"
argument_list|,
name|pp
operator|-
name|hashtable
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'a'
case|:
name|hash_apply
argument_list|(
name|h
argument_list|,
name|applicatee
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|hash_apply
argument_list|(
name|h
argument_list|,
name|destroy
argument_list|)
expr_stmt|;
name|hash_die
argument_list|(
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|p
operator|=
name|hash_find
argument_list|(
name|h
argument_list|,
name|name
operator|=
name|what
argument_list|(
literal|"symbol"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"value of \"%s\" is \"%s\"\n"
argument_list|,
name|name
argument_list|,
name|p
condition|?
name|p
else|:
literal|"NOT-PRESENT"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|printf
argument_list|(
literal|"# show old, select new default hash table number\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"? display all hashtable control block addresses\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"a apply a simple display-er to each symbol in table\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"d die: destroy hashtable\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"f find value of nominated symbol\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"h this help\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"i insert value into symbol\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"j jam value into symbol\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"n new hashtable\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"r replace a value with another\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"s say what %% of table is used\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"q exit this program\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"x delete a symbol from table, report its value\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|p
operator|=
name|hash_insert
argument_list|(
name|h
argument_list|,
name|name
operator|=
name|what
argument_list|(
literal|"symbol"
argument_list|)
argument_list|,
name|value
operator|=
name|what
argument_list|(
literal|"value"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|printf
argument_list|(
literal|"symbol=\"%s\"  value=\"%s\"  error=%s\n"
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'j'
case|:
name|p
operator|=
name|hash_jam
argument_list|(
name|h
argument_list|,
name|name
operator|=
name|what
argument_list|(
literal|"symbol"
argument_list|)
argument_list|,
name|value
operator|=
name|what
argument_list|(
literal|"value"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|printf
argument_list|(
literal|"symbol=\"%s\"  value=\"%s\"  error=%s\n"
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
name|h
operator|=
name|hashtable
index|[
name|number
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|hash_new
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|exit
argument_list|()
expr_stmt|;
case|case
literal|'r'
case|:
name|p
operator|=
name|hash_replace
argument_list|(
name|h
argument_list|,
name|name
operator|=
name|what
argument_list|(
literal|"symbol"
argument_list|)
argument_list|,
name|value
operator|=
name|what
argument_list|(
literal|"value"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"old value was \"%s\"\n"
argument_list|,
name|p
condition|?
name|p
else|:
literal|"{}"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|hash_say
argument_list|(
name|h
argument_list|,
name|statbuf
argument_list|,
name|STATBUFSIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|statbuf
init|;
name|ip
operator|<
name|statbuf
operator|+
name|STATBUFSIZE
condition|;
name|ip
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%d "
argument_list|,
operator|*
name|ip
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|p
operator|=
name|hash_delete
argument_list|(
name|h
argument_list|,
name|name
operator|=
name|what
argument_list|(
literal|"symbol"
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"old value was \"%s\"\n"
argument_list|,
name|p
condition|?
name|p
else|:
literal|"{}"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"I can't understand command \"%c\"\n"
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|what
parameter_list|(
name|description
parameter_list|)
name|char
modifier|*
name|description
decl_stmt|;
block|{
name|char
modifier|*
name|retval
decl_stmt|;
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
name|printf
argument_list|(
literal|"   %s : "
argument_list|,
name|description
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|answer
argument_list|,
literal|100
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
comment|/* will one day clean up answer here */
name|retval
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|answer
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retval
condition|)
block|{
name|error
argument_list|(
literal|"room"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|retval
argument_list|,
name|answer
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|destroy
parameter_list|(
name|string
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|free
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|applicatee
parameter_list|(
name|string
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"%.20s-%.20s\n"
argument_list|,
name|string
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_macro
name|whattable
argument_list|()
end_macro

begin_comment
comment|/* determine number: what hash table to use */
end_comment

begin_comment
comment|/* also determine h: points to hash_control */
end_comment

begin_block
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"   what hash table (%d:%d) ?  "
argument_list|,
literal|0
argument_list|,
name|TABLES
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|answer
argument_list|,
literal|100
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
name|answer
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|number
operator|>=
literal|0
operator|&&
name|number
operator|<
name|TABLES
condition|)
block|{
name|h
operator|=
name|hashtable
index|[
name|number
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|h
condition|)
block|{
name|printf
argument_list|(
literal|"warning: current hash-table-#%d. has no hash-control\n"
argument_list|,
name|number
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"invalid hash table number: %d\n"
argument_list|,
name|number
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #ifdef TEST */
end_comment

begin_comment
comment|/* end of hash.c */
end_comment

end_unit

