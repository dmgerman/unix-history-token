begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* obstack.c - subroutines used implicitly by object stack macros    Copyright (C) 1988 Free Software Foundation, Inc.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|POINTER
value|void *
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|POINTER
value|char *
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Determine default alignment.  */
end_comment

begin_struct
struct|struct
name|fooalign
block|{
name|char
name|x
decl_stmt|;
name|double
name|d
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DEFAULT_ALIGNMENT
value|((char *)&((struct fooalign *) 0)->d - (char *)0)
end_define

begin_comment
comment|/* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.    But in fact it might be less smart and round addresses to as much as    DEFAULT_ROUNDING.  So we prepare for it to do that.  */
end_comment

begin_union
union|union
name|fooround
block|{
name|long
name|x
decl_stmt|;
name|double
name|d
decl_stmt|;
block|}
union|;
end_union

begin_define
define|#
directive|define
name|DEFAULT_ROUNDING
value|(sizeof (union fooround))
end_define

begin_comment
comment|/* When we copy a long block of data, this is the unit to do it with.    On some machines, copying successive ints does not work;    in such a case, redefine COPYING_UNIT to `long' (if that works)    or `char' as a last resort.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|COPYING_UNIT
end_ifndef

begin_define
define|#
directive|define
name|COPYING_UNIT
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The non-GNU-C macros copy the obstack into this global variable    to avoid multiple evaluation.  */
end_comment

begin_decl_stmt
name|struct
name|obstack
modifier|*
name|_obstack
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).    Objects start on multiples of ALIGNMENT (0 means use default).    CHUNKFUN is the function to use to allocate chunks,    and FREEFUN the function to free them.  */
end_comment

begin_decl_stmt
name|void
name|_obstack_begin
argument_list|(
name|h
argument_list|,
name|size
argument_list|,
name|alignment
argument_list|,
name|chunkfun
argument_list|,
name|freefun
argument_list|)
decl|struct
name|obstack
modifier|*
name|h
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|alignment
decl_stmt|;
end_decl_stmt

begin_function_decl
name|POINTER
function_decl|(
modifier|*
name|chunkfun
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|freefun
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|chunk
decl_stmt|;
comment|/* points to new chunk */
if|if
condition|(
name|alignment
operator|==
literal|0
condition|)
name|alignment
operator|=
name|DEFAULT_ALIGNMENT
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
comment|/* Default size is what GNU malloc can fit in a 4096-byte block.  */
block|{
comment|/* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc. 	 Use the values for range checking, because if range checking is off, 	 the extra bytes won't be missed terribly, but if range checking is on 	 and we used a larger request, a whole extra 4096 bytes would be 	 allocated.  	 These number are irrelevant to the new GNU malloc.  I suspect it is 	 less sensitive to the size of the request.  */
name|int
name|extra
init|=
operator|(
operator|(
operator|(
operator|(
literal|12
operator|+
name|DEFAULT_ROUNDING
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|DEFAULT_ROUNDING
operator|-
literal|1
operator|)
operator|)
operator|+
literal|4
operator|+
name|DEFAULT_ROUNDING
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|DEFAULT_ROUNDING
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
name|size
operator|=
literal|4096
operator|-
name|extra
expr_stmt|;
block|}
name|h
operator|->
name|chunkfun
operator|=
operator|(
expr|struct
name|_obstack_chunk
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|chunkfun
expr_stmt|;
name|h
operator|->
name|freefun
operator|=
name|freefun
expr_stmt|;
name|h
operator|->
name|chunk_size
operator|=
name|size
expr_stmt|;
name|h
operator|->
name|alignment_mask
operator|=
name|alignment
operator|-
literal|1
expr_stmt|;
name|chunk
operator|=
name|h
operator|->
name|chunk
operator|=
call|(
modifier|*
name|h
operator|->
name|chunkfun
call|)
argument_list|(
name|h
operator|->
name|chunk_size
argument_list|)
expr_stmt|;
name|h
operator|->
name|next_free
operator|=
name|h
operator|->
name|object_base
operator|=
name|chunk
operator|->
name|contents
expr_stmt|;
name|h
operator|->
name|chunk_limit
operator|=
name|chunk
operator|->
name|limit
operator|=
operator|(
name|char
operator|*
operator|)
name|chunk
operator|+
name|h
operator|->
name|chunk_size
expr_stmt|;
name|chunk
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
comment|/* The initial chunk now contains no empty object.  */
name|h
operator|->
name|maybe_empty_object
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Allocate a new current chunk for the obstack *H    on the assumption that LENGTH bytes need to be added    to the current object, or a new object of length LENGTH allocated.    Copies any partial object from the end of the old chunk    to the beginning of the new one.  */
end_comment

begin_function
name|void
name|_obstack_newchunk
parameter_list|(
name|h
parameter_list|,
name|length
parameter_list|)
name|struct
name|obstack
modifier|*
name|h
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|old_chunk
init|=
name|h
operator|->
name|chunk
decl_stmt|;
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|new_chunk
decl_stmt|;
specifier|register
name|long
name|new_size
decl_stmt|;
specifier|register
name|int
name|obj_size
init|=
name|h
operator|->
name|next_free
operator|-
name|h
operator|->
name|object_base
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|already
decl_stmt|;
comment|/* Compute size for new chunk.  */
name|new_size
operator|=
operator|(
name|obj_size
operator|+
name|length
operator|)
operator|+
operator|(
name|obj_size
operator|>>
literal|3
operator|)
operator|+
literal|100
expr_stmt|;
if|if
condition|(
name|new_size
operator|<
name|h
operator|->
name|chunk_size
condition|)
name|new_size
operator|=
name|h
operator|->
name|chunk_size
expr_stmt|;
comment|/* Allocate and initialize the new chunk.  */
name|new_chunk
operator|=
name|h
operator|->
name|chunk
operator|=
call|(
modifier|*
name|h
operator|->
name|chunkfun
call|)
argument_list|(
name|new_size
argument_list|)
expr_stmt|;
name|new_chunk
operator|->
name|prev
operator|=
name|old_chunk
expr_stmt|;
name|new_chunk
operator|->
name|limit
operator|=
name|h
operator|->
name|chunk_limit
operator|=
operator|(
name|char
operator|*
operator|)
name|new_chunk
operator|+
name|new_size
expr_stmt|;
comment|/* Move the existing object to the new chunk.      Word at a time is fast and is safe if the object      is sufficiently aligned.  */
if|if
condition|(
name|h
operator|->
name|alignment_mask
operator|+
literal|1
operator|>=
name|DEFAULT_ALIGNMENT
condition|)
block|{
for|for
control|(
name|i
operator|=
name|obj_size
operator|/
sizeof|sizeof
argument_list|(
name|COPYING_UNIT
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
operator|(
operator|(
name|COPYING_UNIT
operator|*
operator|)
name|new_chunk
operator|->
name|contents
operator|)
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|COPYING_UNIT
operator|*
operator|)
name|h
operator|->
name|object_base
operator|)
index|[
name|i
index|]
expr_stmt|;
comment|/* We used to copy the odd few remaining bytes as one extra COPYING_UNIT, 	 but that can cross a page boundary on a machine 	 which does not do strict alignment for COPYING_UNITS.  */
name|already
operator|=
name|obj_size
operator|/
sizeof|sizeof
argument_list|(
name|COPYING_UNIT
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|COPYING_UNIT
argument_list|)
expr_stmt|;
block|}
else|else
name|already
operator|=
literal|0
expr_stmt|;
comment|/* Copy remaining bytes one by one.  */
for|for
control|(
name|i
operator|=
name|already
init|;
name|i
operator|<
name|obj_size
condition|;
name|i
operator|++
control|)
name|new_chunk
operator|->
name|contents
index|[
name|i
index|]
operator|=
name|h
operator|->
name|object_base
index|[
name|i
index|]
expr_stmt|;
comment|/* If the object just copied was the only data in OLD_CHUNK,      free that chunk and remove it from the chain.      But not if that chunk might contain an empty object.  */
if|if
condition|(
name|h
operator|->
name|object_base
operator|==
name|old_chunk
operator|->
name|contents
operator|&&
operator|!
name|h
operator|->
name|maybe_empty_object
condition|)
block|{
name|new_chunk
operator|->
name|prev
operator|=
name|old_chunk
operator|->
name|prev
expr_stmt|;
call|(
modifier|*
name|h
operator|->
name|freefun
call|)
argument_list|(
name|old_chunk
argument_list|)
expr_stmt|;
block|}
name|h
operator|->
name|object_base
operator|=
name|new_chunk
operator|->
name|contents
expr_stmt|;
name|h
operator|->
name|next_free
operator|=
name|h
operator|->
name|object_base
operator|+
name|obj_size
expr_stmt|;
comment|/* The new chunk certainly contains no empty object yet.  */
name|h
operator|->
name|maybe_empty_object
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if object OBJ has been allocated from obstack H.    This is here for debugging.    If you use it in a program, you are probably losing.  */
end_comment

begin_function
name|int
name|_obstack_allocated_p
parameter_list|(
name|h
parameter_list|,
name|obj
parameter_list|)
name|struct
name|obstack
modifier|*
name|h
decl_stmt|;
name|POINTER
name|obj
decl_stmt|;
block|{
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|lp
decl_stmt|;
comment|/* below addr of any objects in this chunk */
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|plp
decl_stmt|;
comment|/* point to previous chunk if any */
name|lp
operator|=
operator|(
name|h
operator|)
operator|->
name|chunk
expr_stmt|;
comment|/* We use>= rather than> since the object cannot be exactly at      the beginning of the chunk but might be an empty object exactly      at the end of an adjacent chunk. */
while|while
condition|(
name|lp
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|POINTER
operator|)
name|lp
operator|>=
name|obj
operator|||
call|(
name|POINTER
call|)
argument_list|(
name|lp
argument_list|)
operator|->
name|limit
operator|<
name|obj
operator|)
condition|)
block|{
name|plp
operator|=
name|lp
operator|->
name|prev
expr_stmt|;
name|lp
operator|=
name|plp
expr_stmt|;
block|}
return|return
name|lp
operator|!=
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Free objects in obstack H, including OBJ and everything allocate    more recently than OBJ.  If OBJ is zero, free everything in H.  */
end_comment

begin_undef
undef|#
directive|undef
name|obstack_free
end_undef

begin_comment
comment|/* This function has two names with identical definitions.    This is the first one, called from non-ANSI code.  */
end_comment

begin_function
name|void
name|_obstack_free
parameter_list|(
name|h
parameter_list|,
name|obj
parameter_list|)
name|struct
name|obstack
modifier|*
name|h
decl_stmt|;
name|POINTER
name|obj
decl_stmt|;
block|{
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|lp
decl_stmt|;
comment|/* below addr of any objects in this chunk */
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|plp
decl_stmt|;
comment|/* point to previous chunk if any */
name|lp
operator|=
name|h
operator|->
name|chunk
expr_stmt|;
comment|/* We use>= because there cannot be an object at the beginning of a chunk.      But there can be an empty object at that address      at the end of another chunk.  */
while|while
condition|(
name|lp
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|POINTER
operator|)
name|lp
operator|>=
name|obj
operator|||
call|(
name|POINTER
call|)
argument_list|(
name|lp
argument_list|)
operator|->
name|limit
operator|<
name|obj
operator|)
condition|)
block|{
name|plp
operator|=
name|lp
operator|->
name|prev
expr_stmt|;
call|(
modifier|*
name|h
operator|->
name|freefun
call|)
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|lp
operator|=
name|plp
expr_stmt|;
comment|/* If we switch chunks, we can't tell whether the new current 	 chunk contains an empty object, so assume that it may.  */
name|h
operator|->
name|maybe_empty_object
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|lp
condition|)
block|{
name|h
operator|->
name|object_base
operator|=
name|h
operator|->
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|obj
operator|)
expr_stmt|;
name|h
operator|->
name|chunk_limit
operator|=
name|lp
operator|->
name|limit
expr_stmt|;
name|h
operator|->
name|chunk
operator|=
name|lp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|!=
literal|0
condition|)
comment|/* obj is not in any of the chunks! */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is used from ANSI code.  */
end_comment

begin_function
name|void
name|obstack_free
parameter_list|(
name|h
parameter_list|,
name|obj
parameter_list|)
name|struct
name|obstack
modifier|*
name|h
decl_stmt|;
name|POINTER
name|obj
decl_stmt|;
block|{
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|lp
decl_stmt|;
comment|/* below addr of any objects in this chunk */
specifier|register
name|struct
name|_obstack_chunk
modifier|*
name|plp
decl_stmt|;
comment|/* point to previous chunk if any */
name|lp
operator|=
name|h
operator|->
name|chunk
expr_stmt|;
comment|/* We use>= because there cannot be an object at the beginning of a chunk.      But there can be an empty object at that address      at the end of another chunk.  */
while|while
condition|(
name|lp
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|POINTER
operator|)
name|lp
operator|>=
name|obj
operator|||
call|(
name|POINTER
call|)
argument_list|(
name|lp
argument_list|)
operator|->
name|limit
operator|<
name|obj
operator|)
condition|)
block|{
name|plp
operator|=
name|lp
operator|->
name|prev
expr_stmt|;
call|(
modifier|*
name|h
operator|->
name|freefun
call|)
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|lp
operator|=
name|plp
expr_stmt|;
comment|/* If we switch chunks, we can't tell whether the new current 	 chunk contains an empty object, so assume that it may.  */
name|h
operator|->
name|maybe_empty_object
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|lp
condition|)
block|{
name|h
operator|->
name|object_base
operator|=
name|h
operator|->
name|next_free
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|obj
operator|)
expr_stmt|;
name|h
operator|->
name|chunk_limit
operator|=
name|lp
operator|->
name|limit
expr_stmt|;
name|h
operator|->
name|chunk
operator|=
name|lp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|obj
operator|!=
literal|0
condition|)
comment|/* obj is not in any of the chunks! */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* These are now turned off because the applications do not use it    and it uses bcopy via obstack_grow, which causes trouble on sysV.  */
end_comment

begin_comment
comment|/* Now define the functional versions of the obstack macros.    Define them to simply use the corresponding macros to do the job.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_comment
comment|/* These function definitions do not work with non-ANSI preprocessors;    they won't pass through the macro names in parentheses.  */
end_comment

begin_comment
comment|/* The function names appear in parentheses in order to prevent    the macro-definitions of the names from being expanded there.  */
end_comment

begin_endif
unit|POINTER (obstack_base) (obstack)      struct obstack *obstack; {   return obstack_base (obstack); }  POINTER (obstack_next_free) (obstack)      struct obstack *obstack; {   return obstack_next_free (obstack); }  int (obstack_object_size) (obstack)      struct obstack *obstack; {   return obstack_object_size (obstack); }  int (obstack_room) (obstack)      struct obstack *obstack; {   return obstack_room (obstack); }  void (obstack_grow) (obstack, pointer, length)      struct obstack *obstack;      POINTER pointer;      int length; {   obstack_grow (obstack, pointer, length); }  void (obstack_grow0) (obstack, pointer, length)      struct obstack *obstack;      POINTER pointer;      int length; {   obstack_grow0 (obstack, pointer, length); }  void (obstack_1grow) (obstack, character)      struct obstack *obstack;      int character; {   obstack_1grow (obstack, character); }  void (obstack_blank) (obstack, length)      struct obstack *obstack;      int length; {   obstack_blank (obstack, length); }  void (obstack_1grow_fast) (obstack, character)      struct obstack *obstack;      int character; {   obstack_1grow_fast (obstack, character); }  void (obstack_blank_fast) (obstack, length)      struct obstack *obstack;      int length; {   obstack_blank_fast (obstack, length); }  POINTER (obstack_finish) (obstack)      struct obstack *obstack; {   return obstack_finish (obstack); }  POINTER (obstack_alloc) (obstack, length)      struct obstack *obstack;      int length; {   return obstack_alloc (obstack, length); }  POINTER (obstack_copy) (obstack, pointer, length)      struct obstack *obstack;      POINTER pointer;      int length; {   return obstack_copy (obstack, pointer, length); }  POINTER (obstack_copy0) (obstack, pointer, length)      struct obstack *obstack;      POINTER pointer;      int length; {   return obstack_copy0 (obstack, pointer, length); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* __STDC__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

end_unit

