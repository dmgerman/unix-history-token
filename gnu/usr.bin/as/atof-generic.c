begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* atof_generic.c - turn a string of digits into a Flonum    Copyright (C) 1987, 1990, 1991, 1992 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|sparc
end_ifdef

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #define FALSE (0) */
end_comment

begin_comment
comment|/* #define TRUE  (1) */
end_comment

begin_comment
comment|/***********************************************************************\  *									*  *	Given a string of decimal digits , with optional decimal	*  *	mark and optional decimal exponent (place value) of the		*  *	lowest_order decimal digit: produce a floating point		*  *	number. The number is 'generic' floating point: our		*  *	caller will encode it for a specific machine architecture.	*  *									*  *	Assumptions							*  *		uses base (radix) 2					*  *		this machine uses 2's complement binary integers	*  *		target flonums use "      "         "       "		*  *		target flonums exponents fit in a long		*  *									*  \***********************************************************************/
end_comment

begin_comment
comment|/*    Syntax:<flonum> ::=<optional-sign><decimal-number><optional-exponent><optional-sign> ::= '+' | '-' | {empty}<decimal-number> ::=<integer>   |<integer><radix-character>   |<integer><radix-character><integer>   |<radix-character><integer><optional-exponent> ::= {empty}   |<exponent-character><optional-sign><integer><integer> ::=<digit> |<digit><integer><digit> ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'<exponent-character> ::= {one character from "string_of_decimal_exponent_marks"}<radix-character> ::= {one character from "string_of_decimal_marks"}    */
end_comment

begin_function
name|int
comment|/* 0 if OK */
name|atof_generic
parameter_list|(
name|address_of_string_pointer
parameter_list|,
comment|/* return pointer to just 						AFTER number we read. */
name|string_of_decimal_marks
parameter_list|,
comment|/* At most one per number. */
name|string_of_decimal_exponent_marks
parameter_list|,
name|address_of_generic_floating_point_number
parameter_list|)
name|char
modifier|*
modifier|*
name|address_of_string_pointer
decl_stmt|;
specifier|const
name|char
modifier|*
name|string_of_decimal_marks
decl_stmt|;
specifier|const
name|char
modifier|*
name|string_of_decimal_exponent_marks
decl_stmt|;
name|FLONUM_TYPE
modifier|*
name|address_of_generic_floating_point_number
decl_stmt|;
block|{
name|int
name|return_value
decl_stmt|;
comment|/* 0 means OK. */
name|char
modifier|*
name|first_digit
decl_stmt|;
comment|/* char *last_digit; JF unused */
name|int
name|number_of_digits_before_decimal
decl_stmt|;
name|int
name|number_of_digits_after_decimal
decl_stmt|;
name|long
name|decimal_exponent
decl_stmt|;
name|int
name|number_of_digits_available
decl_stmt|;
name|char
name|digits_sign_char
decl_stmt|;
comment|/* 	 * Scan the input string, abstracting (1)digits (2)decimal mark (3) exponent. 	 * It would be simpler to modify the string, but we don't; just to be nice 	 * to caller. 	 * We need to know how many digits we have, so we can allocate space for 	 * the digits' value. 	 */
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|seen_significant_digit
decl_stmt|;
name|first_digit
operator|=
operator|*
name|address_of_string_pointer
expr_stmt|;
name|c
operator|=
operator|*
name|first_digit
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
operator|||
name|c
operator|==
literal|'+'
condition|)
block|{
name|digits_sign_char
operator|=
name|c
expr_stmt|;
name|first_digit
operator|++
expr_stmt|;
block|}
else|else
name|digits_sign_char
operator|=
literal|'+'
expr_stmt|;
if|if
condition|(
operator|(
name|first_digit
index|[
literal|0
index|]
operator|==
literal|'n'
operator|||
name|first_digit
index|[
literal|0
index|]
operator|==
literal|'N'
operator|)
operator|&&
operator|(
name|first_digit
index|[
literal|1
index|]
operator|==
literal|'a'
operator|||
name|first_digit
index|[
literal|1
index|]
operator|==
literal|'A'
operator|)
operator|&&
operator|(
name|first_digit
index|[
literal|2
index|]
operator|==
literal|'n'
operator|||
name|first_digit
index|[
literal|2
index|]
operator|==
literal|'N'
operator|)
condition|)
block|{
name|address_of_generic_floating_point_number
operator|->
name|sign
operator|=
literal|0
expr_stmt|;
name|address_of_generic_floating_point_number
operator|->
name|exponent
operator|=
literal|0
expr_stmt|;
name|address_of_generic_floating_point_number
operator|->
name|leader
operator|=
name|address_of_generic_floating_point_number
operator|->
name|low
expr_stmt|;
operator|*
name|address_of_string_pointer
operator|=
name|first_digit
operator|+
literal|3
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 99e999 is a "special" token to some older, broken compilers.  */
if|if
condition|(
operator|(
name|first_digit
index|[
literal|0
index|]
operator|==
literal|'i'
operator|||
name|first_digit
index|[
literal|0
index|]
operator|==
literal|'I'
operator|)
operator|&&
operator|(
name|first_digit
index|[
literal|1
index|]
operator|==
literal|'n'
operator|||
name|first_digit
index|[
literal|1
index|]
operator|==
literal|'N'
operator|)
operator|&&
operator|(
name|first_digit
index|[
literal|2
index|]
operator|==
literal|'f'
operator|||
name|first_digit
index|[
literal|2
index|]
operator|==
literal|'F'
operator|)
condition|)
block|{
name|address_of_generic_floating_point_number
operator|->
name|sign
operator|=
name|digits_sign_char
operator|==
literal|'+'
condition|?
literal|'P'
else|:
literal|'N'
expr_stmt|;
name|address_of_generic_floating_point_number
operator|->
name|exponent
operator|=
literal|0
expr_stmt|;
name|address_of_generic_floating_point_number
operator|->
name|leader
operator|=
name|address_of_generic_floating_point_number
operator|->
name|low
expr_stmt|;
if|if
condition|(
operator|(
name|first_digit
index|[
literal|3
index|]
operator|==
literal|'i'
operator|||
name|first_digit
index|[
literal|3
index|]
operator|==
literal|'I'
operator|)
operator|&&
operator|(
name|first_digit
index|[
literal|4
index|]
operator|==
literal|'n'
operator|||
name|first_digit
index|[
literal|4
index|]
operator|==
literal|'N'
operator|)
operator|&&
operator|(
name|first_digit
index|[
literal|5
index|]
operator|==
literal|'i'
operator|||
name|first_digit
index|[
literal|5
index|]
operator|==
literal|'I'
operator|)
operator|&&
operator|(
name|first_digit
index|[
literal|6
index|]
operator|==
literal|'t'
operator|||
name|first_digit
index|[
literal|6
index|]
operator|==
literal|'T'
operator|)
operator|&&
operator|(
name|first_digit
index|[
literal|7
index|]
operator|==
literal|'y'
operator|||
name|first_digit
index|[
literal|7
index|]
operator|==
literal|'Y'
operator|)
condition|)
block|{
operator|*
name|address_of_string_pointer
operator|=
name|first_digit
operator|+
literal|8
expr_stmt|;
block|}
else|else
block|{
operator|*
name|address_of_string_pointer
operator|=
name|first_digit
operator|+
literal|3
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|first_digit
argument_list|,
literal|"99e999"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|address_of_generic_floating_point_number
operator|->
name|sign
operator|=
name|digits_sign_char
operator|==
literal|'+'
condition|?
literal|'P'
else|:
literal|'N'
expr_stmt|;
name|address_of_generic_floating_point_number
operator|->
name|exponent
operator|=
literal|0
expr_stmt|;
name|address_of_generic_floating_point_number
operator|->
name|leader
operator|=
name|address_of_generic_floating_point_number
operator|->
name|low
expr_stmt|;
operator|*
name|address_of_string_pointer
operator|=
name|first_digit
operator|+
literal|6
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|number_of_digits_before_decimal
operator|=
literal|0
expr_stmt|;
name|number_of_digits_after_decimal
operator|=
literal|0
expr_stmt|;
name|decimal_exponent
operator|=
literal|0
expr_stmt|;
name|seen_significant_digit
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|first_digit
init|;
operator|(
operator|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|!
name|c
operator|||
operator|!
name|strchr
argument_list|(
name|string_of_decimal_marks
argument_list|,
name|c
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|c
operator|||
operator|!
name|strchr
argument_list|(
name|string_of_decimal_exponent_marks
argument_list|,
name|c
argument_list|)
operator|)
operator|)
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|seen_significant_digit
operator|||
name|c
operator|>
literal|'0'
condition|)
block|{
operator|++
name|number_of_digits_before_decimal
expr_stmt|;
name|seen_significant_digit
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|first_digit
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
break|break;
comment|/* p -> char after pre-decimal digits. */
block|}
block|}
comment|/* For each digit before decimal mark. */
ifndef|#
directive|ifndef
name|OLD_FLOAT_READS
comment|/* Ignore trailing 0's after the decimal point.  The original code here 	 * (ifdef'd out) does not do this, and numbers like 	 *	4.29496729600000000000e+09	(2**31) 	 * come out inexact for some reason related to length of the digit 	 * string. 	 */
if|if
condition|(
name|c
operator|&&
name|strchr
argument_list|(
name|string_of_decimal_marks
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|int
name|zeros
init|=
literal|0
decl_stmt|;
comment|/* Length of current string of zeros */
for|for
control|(
name|p
operator|++
init|;
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|&&
name|isdigit
argument_list|(
name|c
argument_list|)
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
block|{
name|zeros
operator|++
expr_stmt|;
block|}
else|else
block|{
name|number_of_digits_after_decimal
operator|+=
literal|1
operator|+
name|zeros
expr_stmt|;
name|zeros
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|#
directive|else
if|if
condition|(
name|c
operator|&&
name|strchr
argument_list|(
name|string_of_decimal_marks
argument_list|,
name|c
argument_list|)
condition|)
block|{
for|for
control|(
name|p
operator|++
init|;
operator|(
operator|(
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|!
name|c
operator|||
operator|!
name|strchr
argument_list|(
name|string_of_decimal_exponent_marks
argument_list|,
name|c
argument_list|)
operator|)
operator|)
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|number_of_digits_after_decimal
operator|++
expr_stmt|;
comment|/* This may be retracted below. */
if|if
condition|(
comment|/* seen_significant_digit || */
name|c
operator|>
literal|'0'
condition|)
block|{
name|seen_significant_digit
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|seen_significant_digit
condition|)
block|{
name|number_of_digits_after_decimal
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* For each digit after decimal mark. */
block|}
while|while
condition|(
name|number_of_digits_after_decimal
operator|&&
name|first_digit
index|[
name|number_of_digits_before_decimal
operator|+
name|number_of_digits_after_decimal
index|]
operator|==
literal|'0'
condition|)
operator|--
name|number_of_digits_after_decimal
expr_stmt|;
comment|/* last_digit = p; JF unused */
endif|#
directive|endif
if|if
condition|(
name|c
operator|&&
name|strchr
argument_list|(
name|string_of_decimal_exponent_marks
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|char
name|digits_exponent_sign_char
decl_stmt|;
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|c
operator|&&
name|strchr
argument_list|(
literal|"+-"
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|digits_exponent_sign_char
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|*
operator|++
name|p
expr_stmt|;
block|}
else|else
block|{
name|digits_exponent_sign_char
operator|=
literal|'+'
expr_stmt|;
block|}
for|for
control|(
init|;
operator|(
name|c
operator|)
condition|;
name|c
operator|=
operator|*
operator|++
name|p
control|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|decimal_exponent
operator|=
name|decimal_exponent
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
comment|/* 				 * BUG! If we overflow here, we lose! 				 */
block|}
else|else
block|{
break|break;
block|}
block|}
if|if
condition|(
name|digits_exponent_sign_char
operator|==
literal|'-'
condition|)
block|{
name|decimal_exponent
operator|=
operator|-
name|decimal_exponent
expr_stmt|;
block|}
block|}
operator|*
name|address_of_string_pointer
operator|=
name|p
expr_stmt|;
name|number_of_digits_available
operator|=
name|number_of_digits_before_decimal
operator|+
name|number_of_digits_after_decimal
expr_stmt|;
name|return_value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|number_of_digits_available
operator|==
literal|0
condition|)
block|{
name|address_of_generic_floating_point_number
operator|->
name|exponent
operator|=
literal|0
expr_stmt|;
comment|/* Not strictly necessary */
name|address_of_generic_floating_point_number
operator|->
name|leader
operator|=
operator|-
literal|1
operator|+
name|address_of_generic_floating_point_number
operator|->
name|low
expr_stmt|;
name|address_of_generic_floating_point_number
operator|->
name|sign
operator|=
name|digits_sign_char
expr_stmt|;
comment|/* We have just concocted (+/-)0.0E0 */
block|}
else|else
block|{
name|int
name|count
decl_stmt|;
comment|/* Number of useful digits left to scan. */
name|LITTLENUM_TYPE
modifier|*
name|digits_binary_low
decl_stmt|;
name|int
name|precision
decl_stmt|;
name|int
name|maximum_useful_digits
decl_stmt|;
name|int
name|number_of_digits_to_use
decl_stmt|;
name|int
name|more_than_enough_bits_for_digits
decl_stmt|;
name|int
name|more_than_enough_littlenums_for_digits
decl_stmt|;
name|int
name|size_of_digits_in_littlenums
decl_stmt|;
name|int
name|size_of_digits_in_chars
decl_stmt|;
name|FLONUM_TYPE
name|power_of_10_flonum
decl_stmt|;
name|FLONUM_TYPE
name|digits_flonum
decl_stmt|;
name|precision
operator|=
operator|(
name|address_of_generic_floating_point_number
operator|->
name|high
operator|-
name|address_of_generic_floating_point_number
operator|->
name|low
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Number of destination littlenums. */
comment|/* Includes guard bits (two littlenums worth) */
name|maximum_useful_digits
operator|=
operator|(
operator|(
call|(
name|double
call|)
argument_list|(
name|precision
operator|-
literal|2
argument_list|)
operator|)
operator|*
operator|(
call|(
name|double
call|)
argument_list|(
name|LITTLENUM_NUMBER_OF_BITS
argument_list|)
operator|)
operator|/
operator|(
name|LOG_TO_BASE_2_OF_10
operator|)
operator|)
operator|+
literal|2
expr_stmt|;
comment|/* 2 :: guard digits. */
if|if
condition|(
name|number_of_digits_available
operator|>
name|maximum_useful_digits
condition|)
block|{
name|number_of_digits_to_use
operator|=
name|maximum_useful_digits
expr_stmt|;
block|}
else|else
block|{
name|number_of_digits_to_use
operator|=
name|number_of_digits_available
expr_stmt|;
block|}
name|decimal_exponent
operator|+=
name|number_of_digits_before_decimal
operator|-
name|number_of_digits_to_use
expr_stmt|;
name|more_than_enough_bits_for_digits
operator|=
operator|(
operator|(
operator|(
operator|(
name|double
operator|)
name|number_of_digits_to_use
operator|)
operator|*
name|LOG_TO_BASE_2_OF_10
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
name|more_than_enough_littlenums_for_digits
operator|=
operator|(
name|more_than_enough_bits_for_digits
operator|/
name|LITTLENUM_NUMBER_OF_BITS
operator|)
operator|+
literal|2
expr_stmt|;
comment|/* 		 * Compute (digits) part. In "12.34E56" this is the "1234" part. 		 * Arithmetic is exact here. If no digits are supplied then 		 * this part is a 0 valued binary integer. 		 * Allocate room to build up the binary number as littlenums. 		 * We want this memory to disappear when we leave this function. 		 * Assume no alignment problems => (room for n objects) == 		 * n * (room for 1 object). 		 */
name|size_of_digits_in_littlenums
operator|=
name|more_than_enough_littlenums_for_digits
expr_stmt|;
name|size_of_digits_in_chars
operator|=
name|size_of_digits_in_littlenums
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
name|digits_binary_low
operator|=
operator|(
name|LITTLENUM_TYPE
operator|*
operator|)
name|alloca
argument_list|(
name|size_of_digits_in_chars
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|digits_binary_low
argument_list|,
literal|'\0'
argument_list|,
name|size_of_digits_in_chars
argument_list|)
expr_stmt|;
comment|/* Digits_binary_low[] is allocated and zeroed. */
comment|/* 		 * Parse the decimal digits as if * digits_low was in the units position. 		 * Emit a binary number into digits_binary_low[]. 		 * 		 * Use a large-precision version of: 		 * (((1st-digit) * 10 + 2nd-digit) * 10 + 3rd-digit ...) * 10 + last-digit 		 */
for|for
control|(
name|p
operator|=
name|first_digit
operator|,
name|count
operator|=
name|number_of_digits_to_use
init|;
name|count
condition|;
name|p
operator|++
operator|,
operator|--
name|count
control|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* 				 * Multiply by 10. Assume can never overflow. 				 * Add this digit to digits_binary_low[]. 				 */
name|long
name|carry
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|littlenum_pointer
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|littlenum_limit
decl_stmt|;
name|littlenum_limit
operator|=
name|digits_binary_low
operator|+
name|more_than_enough_littlenums_for_digits
operator|-
literal|1
expr_stmt|;
name|carry
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
comment|/* char -> binary */
for|for
control|(
name|littlenum_pointer
operator|=
name|digits_binary_low
init|;
name|littlenum_pointer
operator|<=
name|littlenum_limit
condition|;
name|littlenum_pointer
operator|++
control|)
block|{
name|long
name|work
decl_stmt|;
name|work
operator|=
name|carry
operator|+
literal|10
operator|*
call|(
name|long
call|)
argument_list|(
operator|*
name|littlenum_pointer
argument_list|)
expr_stmt|;
operator|*
name|littlenum_pointer
operator|=
name|work
operator|&
name|LITTLENUM_MASK
expr_stmt|;
name|carry
operator|=
name|work
operator|>>
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
block|}
if|if
condition|(
name|carry
operator|!=
literal|0
condition|)
block|{
comment|/* 					 * We have a GROSS internal error. 					 * This should never happen. 					 */
name|as_fatal
argument_list|(
literal|"failed sanity check."
argument_list|)
expr_stmt|;
comment|/* RMS prefers abort() to any message. */
block|}
block|}
else|else
block|{
operator|++
name|count
expr_stmt|;
comment|/* '.' doesn't alter digits used count. */
block|}
comment|/* if valid digit */
block|}
comment|/* for each digit */
comment|/* 		 * Digits_binary_low[] properly encodes the value of the digits. 		 * Forget about any high-order littlenums that are 0. 		 */
while|while
condition|(
name|digits_binary_low
index|[
name|size_of_digits_in_littlenums
operator|-
literal|1
index|]
operator|==
literal|0
operator|&&
name|size_of_digits_in_littlenums
operator|>=
literal|2
condition|)
name|size_of_digits_in_littlenums
operator|--
expr_stmt|;
name|digits_flonum
operator|.
name|low
operator|=
name|digits_binary_low
expr_stmt|;
name|digits_flonum
operator|.
name|high
operator|=
name|digits_binary_low
operator|+
name|size_of_digits_in_littlenums
operator|-
literal|1
expr_stmt|;
name|digits_flonum
operator|.
name|leader
operator|=
name|digits_flonum
operator|.
name|high
expr_stmt|;
name|digits_flonum
operator|.
name|exponent
operator|=
literal|0
expr_stmt|;
comment|/* 		 * The value of digits_flonum.sign should not be important. 		 * We have already decided the output's sign. 		 * We trust that the sign won't influence the other parts of the number! 		 * So we give it a value for these reasons: 		 * (1) courtesy to humans reading/debugging 		 *     these numbers so they don't get excited about strange values 		 * (2) in future there may be more meaning attached to sign, 		 *     and what was 		 *     harmless noise may become disruptive, ill-conditioned (or worse) 		 *     input. 		 */
name|digits_flonum
operator|.
name|sign
operator|=
literal|'+'
expr_stmt|;
block|{
comment|/* 			 * Compute the mantssa (& exponent) of the power of 10. 			 * If sucessful, then multiply the power of 10 by the digits 			 * giving return_binary_mantissa and return_binary_exponent. 			 */
name|LITTLENUM_TYPE
modifier|*
name|power_binary_low
decl_stmt|;
name|int
name|decimal_exponent_is_negative
decl_stmt|;
comment|/* This refers to the "-56" in "12.34E-56". */
comment|/* FALSE: decimal_exponent is positive (or 0) */
comment|/* TRUE:  decimal_exponent is negative */
name|FLONUM_TYPE
name|temporary_flonum
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|temporary_binary_low
decl_stmt|;
name|int
name|size_of_power_in_littlenums
decl_stmt|;
name|int
name|size_of_power_in_chars
decl_stmt|;
name|size_of_power_in_littlenums
operator|=
name|precision
expr_stmt|;
comment|/* Precision has a built-in fudge factor so we get a few guard bits. */
name|decimal_exponent_is_negative
operator|=
name|decimal_exponent
operator|<
literal|0
expr_stmt|;
if|if
condition|(
name|decimal_exponent_is_negative
condition|)
block|{
name|decimal_exponent
operator|=
operator|-
name|decimal_exponent
expr_stmt|;
block|}
comment|/* From now on: the decimal exponent is> 0. Its sign is seperate. */
name|size_of_power_in_chars
operator|=
name|size_of_power_in_littlenums
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
operator|+
literal|2
expr_stmt|;
name|power_binary_low
operator|=
operator|(
name|LITTLENUM_TYPE
operator|*
operator|)
name|alloca
argument_list|(
name|size_of_power_in_chars
argument_list|)
expr_stmt|;
name|temporary_binary_low
operator|=
operator|(
name|LITTLENUM_TYPE
operator|*
operator|)
name|alloca
argument_list|(
name|size_of_power_in_chars
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|power_binary_low
argument_list|,
literal|'\0'
argument_list|,
name|size_of_power_in_chars
argument_list|)
expr_stmt|;
operator|*
name|power_binary_low
operator|=
literal|1
expr_stmt|;
name|power_of_10_flonum
operator|.
name|exponent
operator|=
literal|0
expr_stmt|;
name|power_of_10_flonum
operator|.
name|low
operator|=
name|power_binary_low
expr_stmt|;
name|power_of_10_flonum
operator|.
name|leader
operator|=
name|power_binary_low
expr_stmt|;
name|power_of_10_flonum
operator|.
name|high
operator|=
name|power_binary_low
operator|+
name|size_of_power_in_littlenums
operator|-
literal|1
expr_stmt|;
name|power_of_10_flonum
operator|.
name|sign
operator|=
literal|'+'
expr_stmt|;
name|temporary_flonum
operator|.
name|low
operator|=
name|temporary_binary_low
expr_stmt|;
name|temporary_flonum
operator|.
name|high
operator|=
name|temporary_binary_low
operator|+
name|size_of_power_in_littlenums
operator|-
literal|1
expr_stmt|;
comment|/* 			 * (power) == 1. 			 * Space for temporary_flonum allocated. 			 */
comment|/* 			 * ... 			 * 			 * WHILE	more bits 			 * DO	find next bit (with place value) 			 *	multiply into power mantissa 			 * OD 			 */
block|{
name|int
name|place_number_limit
decl_stmt|;
comment|/* Any 10^(2^n) whose "n" exceeds this */
comment|/* value will fall off the end of */
comment|/* flonum_XXXX_powers_of_ten[]. */
name|int
name|place_number
decl_stmt|;
specifier|const
name|FLONUM_TYPE
modifier|*
name|multiplicand
decl_stmt|;
comment|/* -> 10^(2^n) */
name|place_number_limit
operator|=
name|table_size_of_flonum_powers_of_ten
expr_stmt|;
name|multiplicand
operator|=
operator|(
name|decimal_exponent_is_negative
condition|?
name|flonum_negative_powers_of_ten
else|:
name|flonum_positive_powers_of_ten
operator|)
expr_stmt|;
for|for
control|(
name|place_number
operator|=
literal|1
init|;
comment|/* Place value of this bit of exponent. */
name|decimal_exponent
condition|;
comment|/* Quit when no more 1 bits in exponent. */
name|decimal_exponent
operator|>>=
literal|1
operator|,
name|place_number
operator|++
control|)
block|{
if|if
condition|(
name|decimal_exponent
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|place_number
operator|>
name|place_number_limit
condition|)
block|{
comment|/* 							 * The decimal exponent has a magnitude so great that 							 * our tables can't help us fragment it.  Although this 							 * routine is in error because it can't imagine a 							 * number that big, signal an error as if it is the 							 * user's fault for presenting such a big number. 							 */
name|return_value
operator|=
name|ERROR_EXPONENT_OVERFLOW
expr_stmt|;
comment|/* 							 * quit out of loop gracefully 							 */
name|decimal_exponent
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|TRACE
name|printf
argument_list|(
literal|"before multiply, place_number = %d., power_of_10_flonum:\n"
argument_list|,
name|place_number
argument_list|)
expr_stmt|;
name|flonum_print
argument_list|(
operator|&
name|power_of_10_flonum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|flonum_multip
argument_list|(
name|multiplicand
operator|+
name|place_number
argument_list|,
operator|&
name|power_of_10_flonum
argument_list|,
operator|&
name|temporary_flonum
argument_list|)
expr_stmt|;
name|flonum_copy
argument_list|(
operator|&
name|temporary_flonum
argument_list|,
operator|&
name|power_of_10_flonum
argument_list|)
expr_stmt|;
block|}
comment|/* If this bit of decimal_exponent was computable.*/
block|}
comment|/* If this bit of decimal_exponent was set. */
block|}
comment|/* For each bit of binary representation of exponent */
ifdef|#
directive|ifdef
name|TRACE
name|printf
argument_list|(
literal|" after computing power_of_10_flonum: "
argument_list|)
expr_stmt|;
name|flonum_print
argument_list|(
operator|&
name|power_of_10_flonum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* 		 * power_of_10_flonum is power of ten in binary (mantissa) , (exponent). 		 * It may be the number 1, in which case we don't NEED to multiply. 		 * 		 * Multiply (decimal digits) by power_of_10_flonum. 		 */
name|flonum_multip
argument_list|(
operator|&
name|power_of_10_flonum
argument_list|,
operator|&
name|digits_flonum
argument_list|,
name|address_of_generic_floating_point_number
argument_list|)
expr_stmt|;
comment|/* Assert sign of the number we made is '+'. */
name|address_of_generic_floating_point_number
operator|->
name|sign
operator|=
name|digits_sign_char
expr_stmt|;
block|}
comment|/* If we had any significant digits. */
return|return
operator|(
name|return_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* atof_generic () */
end_comment

begin_comment
comment|/* end of atof_generic.c */
end_comment

end_unit

