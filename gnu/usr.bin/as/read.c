begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* read.c - read a source file -     Copyright (C) 1986, 1987, 1990, 1991, 1992 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: read.c,v 1.11 1997/04/29 02:11:48 jdp Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MASK_CHAR
value|(0xFF)
end_define

begin_comment
comment|/* If your chars aren't 8 bits, you will 				   change this a bit.  But then, GNU isn't 				   spozed to run on your machine anyway. 				   (RMS is so shortsighted sometimes.) 				   */
end_comment

begin_define
define|#
directive|define
name|MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT
value|(16)
end_define

begin_comment
comment|/* This is the largest known floating point */
end_comment

begin_comment
comment|/* format (for now). It will grow when we */
end_comment

begin_comment
comment|/* do 4361 style flonums. */
end_comment

begin_comment
comment|/* Routines that read assembler source text to build spagetti in memory. */
end_comment

begin_comment
comment|/* Another group of these functions is in the as-expr.c module */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|input_line_pointer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*->next char of source file to parse. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOP_OPCODE
end_ifndef

begin_define
define|#
directive|define
name|NOP_OPCODE
value|0x00
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|BITS_PER_CHAR
operator|!=
literal|8
end_if

begin_expr_stmt
name|The
name|following
name|table
name|is
name|indexed
name|by
index|[
operator|(
name|char
operator|)
index|]
name|and
name|will
end_expr_stmt

begin_break
break|break if
name|a
name|char
name|does
name|not
name|have
name|exactly
break|256
name|states
break|(
name|hopefully
break|0:255!
end_break

begin_expr_stmt
unit|)
operator|!
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ALLOW_ATSIGN
define|#
directive|define
name|AT
value|2
else|#
directive|else
define|#
directive|define
name|AT
value|0
endif|#
directive|endif
ifndef|#
directive|ifndef
name|PIC
specifier|const
endif|#
directive|endif
name|char
comment|/* used by is_... macros. our ctype[] */
name|lex_type
index|[
literal|256
index|]
operator|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* @ABCDEFGHIJKLMNO */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* PQRSTUVWXYZ[\]^_ */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* _!"#$%&'()*+,-./ */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0123456789:;<=>? */
name|AT
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
comment|/* @ABCDEFGHIJKLMNO */
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
comment|/* PQRSTUVWXYZ[\]^_ */
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
comment|/* `abcdefghijklmno */
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* pqrstuvwxyz{|}~. */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * In: a character.  * Out: 1 if this character ends a line.  */
end_comment

begin_define
define|#
directive|define
name|_
value|(0)
end_define

begin_decl_stmt
name|char
name|is_end_of_line
index|[
literal|256
index|]
init|=
block|{
ifdef|#
directive|ifdef
name|CR_EOL
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
literal|99
block|,
name|_
block|,
name|_
block|,
literal|99
block|,
name|_
block|,
name|_
block|,
comment|/* @abcdefghijklmno */
else|#
directive|else
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
literal|99
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* @abcdefghijklmno */
endif|#
directive|endif
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
literal|99
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* 0123456789:;<=>? */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
comment|/* */
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|_
end_undef

begin_comment
comment|/* Functions private to this file. */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|char
name|line_comment_chars
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_separator_chars
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1st char of each buffer of lines is here. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buffer_limit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*->1 + last char in buffer. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bignum_low
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lowest char of bignum. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bignum_limit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1st illegal address of bignum. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bignum_high
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Highest char of bignum. */
end_comment

begin_comment
comment|/* May point to (bignum_start-1). */
end_comment

begin_comment
comment|/* Never>= bignum_limit. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|old_buffer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* JF a hack */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|old_input
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|old_limit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables for handling include file directory list. */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|include_dirs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of pointers to directories to 				   search for .include's */
end_comment

begin_decl_stmt
name|int
name|include_dir_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many are in the list */
end_comment

begin_decl_stmt
name|int
name|include_dir_maxlen
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length of longest in list */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
end_ifndef

begin_decl_stmt
name|struct
name|broken_word
modifier|*
name|broken_words
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|new_broken_words
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|__STDC__
operator|==
literal|1
end_if

begin_function_decl
specifier|static
name|char
modifier|*
name|demand_copy_string
parameter_list|(
name|int
modifier|*
name|lenP
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|is_it_end_of_statement
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|unsigned
name|int
name|next_char_of_string
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|segT
name|get_known_segmented_expression
parameter_list|(
name|expressionS
modifier|*
name|expP
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|grow_bignum
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pobegin
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|stringer
parameter_list|(
name|int
name|append_zero
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __STDC__ */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|demand_copy_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|is_it_end_of_statement
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|unsigned
name|int
name|next_char_of_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|segT
name|get_known_segmented_expression
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|grow_bignum
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pobegin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|stringer
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __STDC__ */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|listing
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|read_begin
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|pobegin
argument_list|()
expr_stmt|;
name|obj_read_begin_hook
argument_list|()
expr_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|notes
argument_list|,
literal|5000
argument_list|)
expr_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|cond_obstack
argument_list|,
literal|960
argument_list|)
expr_stmt|;
define|#
directive|define
name|BIGNUM_BEGIN_SIZE
value|(16)
name|bignum_low
operator|=
name|xmalloc
argument_list|(
operator|(
name|long
operator|)
name|BIGNUM_BEGIN_SIZE
argument_list|)
expr_stmt|;
name|bignum_limit
operator|=
name|bignum_low
operator|+
name|BIGNUM_BEGIN_SIZE
expr_stmt|;
comment|/* Use machine dependent syntax */
for|for
control|(
name|p
operator|=
name|line_separator_chars
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|is_end_of_line
index|[
operator|*
name|p
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Use more.  FIXME-SOMEDAY. */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* set up pseudo-op tables */
end_comment

begin_decl_stmt
name|struct
name|hash_control
modifier|*
name|po_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use before set up: NULL->address error */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|pseudo_typeS
name|potable
index|[]
init|=
block|{
block|{
literal|"abort"
block|,
name|s_abort
block|,
literal|0
block|}
block|,
block|{
literal|"align"
block|,
name|s_align_ptwo
block|,
literal|0
block|}
block|,
block|{
literal|"ascii"
block|,
name|stringer
block|,
literal|0
block|}
block|,
block|{
literal|"asciz"
block|,
name|stringer
block|,
literal|1
block|}
block|,
comment|/* block */
block|{
literal|"byte"
block|,
name|cons
block|,
literal|1
block|}
block|,
block|{
literal|"comm"
block|,
name|s_comm
block|,
literal|0
block|}
block|,
block|{
literal|"data"
block|,
name|s_data
block|,
literal|0
block|}
block|,
comment|/* dim */
block|{
literal|"double"
block|,
name|float_cons
block|,
literal|'d'
block|}
block|,
comment|/* dsect */
ifdef|#
directive|ifdef
name|NO_LISTING
block|{
literal|"eject"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* Formfeed listing */
else|#
directive|else
block|{
literal|"eject"
block|,
name|listing_eject
block|,
literal|0
block|}
block|,
comment|/* Formfeed listing */
endif|#
directive|endif
comment|/* NO_LISTING */
block|{
literal|"else"
block|,
name|s_else
block|,
literal|0
block|}
block|,
block|{
literal|"end"
block|,
name|s_end
block|,
literal|0
block|}
block|,
block|{
literal|"endif"
block|,
name|s_endif
block|,
literal|0
block|}
block|,
comment|/* endef */
block|{
literal|"equ"
block|,
name|s_set
block|,
literal|0
block|}
block|,
comment|/* err */
comment|/* extend */
block|{
literal|"extern"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* We treat all undef as ext */
block|{
literal|"appline"
block|,
name|s_app_line
block|,
literal|0
block|}
block|,
block|{
literal|"appfile"
block|,
name|s_app_file
block|,
literal|1
block|}
block|,
block|{
literal|"file"
block|,
name|s_app_file
block|,
literal|0
block|}
block|,
block|{
literal|"fill"
block|,
name|s_fill
block|,
literal|0
block|}
block|,
block|{
literal|"float"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"global"
block|,
name|s_globl
block|,
literal|0
block|}
block|,
block|{
literal|"globl"
block|,
name|s_globl
block|,
literal|0
block|}
block|,
block|{
literal|"hword"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"if"
block|,
name|s_if
block|,
literal|0
block|}
block|,
block|{
literal|"ifdef"
block|,
name|s_ifdef
block|,
literal|0
block|}
block|,
block|{
literal|"ifeqs"
block|,
name|s_ifeqs
block|,
literal|0
block|}
block|,
block|{
literal|"ifndef"
block|,
name|s_ifdef
block|,
literal|1
block|}
block|,
block|{
literal|"ifnes"
block|,
name|s_ifeqs
block|,
literal|1
block|}
block|,
block|{
literal|"ifnotdef"
block|,
name|s_ifdef
block|,
literal|1
block|}
block|,
block|{
literal|"include"
block|,
name|s_include
block|,
literal|0
block|}
block|,
block|{
literal|"int"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"lcomm"
block|,
name|s_lcomm
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|NO_LISTING
block|{
literal|"lflags"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* Listing flags */
block|{
literal|"list"
block|,
name|s_ignore
block|,
literal|1
block|}
block|,
comment|/* Turn listing on */
else|#
directive|else
block|{
literal|"lflags"
block|,
name|listing_flags
block|,
literal|0
block|}
block|,
comment|/* Listing flags */
block|{
literal|"list"
block|,
name|listing_list
block|,
literal|1
block|}
block|,
comment|/* Turn listing on */
endif|#
directive|endif
comment|/* NO_LISTING */
block|{
literal|"long"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"lsym"
block|,
name|s_lsym
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|NO_LISTING
block|{
literal|"nolist"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* Turn listing off */
else|#
directive|else
block|{
literal|"nolist"
block|,
name|listing_list
block|,
literal|0
block|}
block|,
comment|/* Turn listing off */
endif|#
directive|endif
comment|/* NO_LISTING */
block|{
literal|"octa"
block|,
name|big_cons
block|,
literal|16
block|}
block|,
block|{
literal|"org"
block|,
name|s_org
block|,
literal|0
block|}
block|,
block|{
literal|"p2align"
block|,
name|s_align_ptwo
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|NO_LISTING
block|{
literal|"psize"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* set paper size */
else|#
directive|else
block|{
literal|"psize"
block|,
name|listing_psize
block|,
literal|0
block|}
block|,
comment|/* set paper size */
endif|#
directive|endif
comment|/* NO_LISTING */
comment|/* print */
block|{
literal|"quad"
block|,
name|big_cons
block|,
literal|8
block|}
block|,
ifdef|#
directive|ifdef
name|NO_LISTING
block|{
literal|"sbttl"
block|,
name|s_ignore
block|,
literal|1
block|}
block|,
comment|/* Subtitle of listing */
else|#
directive|else
block|{
literal|"sbttl"
block|,
name|listing_title
block|,
literal|1
block|}
block|,
comment|/* Subtitle of listing */
endif|#
directive|endif
comment|/* NO_LISTING */
comment|/* scl */
comment|/* sect */
ifndef|#
directive|ifndef
name|TC_M88K
block|{
literal|"set"
block|,
name|s_set
block|,
literal|0
block|}
block|,
endif|#
directive|endif
comment|/* TC_M88K */
block|{
literal|"short"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"single"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
comment|/* size */
block|{
literal|"space"
block|,
name|s_space
block|,
literal|0
block|}
block|,
comment|/* tag */
block|{
literal|"text"
block|,
name|s_text
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|NO_LISTING
block|{
literal|"title"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* Listing title */
else|#
directive|else
block|{
literal|"title"
block|,
name|listing_title
block|,
literal|0
block|}
block|,
comment|/* Listing title */
endif|#
directive|endif
comment|/* NO_LISTING */
comment|/* type */
comment|/* use */
comment|/* val */
block|{
literal|"word"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
name|NULL
block|}
comment|/* end sentinel */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|pobegin
parameter_list|()
block|{
name|char
modifier|*
name|errtxt
decl_stmt|;
comment|/* error text */
specifier|const
name|pseudo_typeS
modifier|*
name|pop
decl_stmt|;
name|po_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* Do the target-specific pseudo ops. */
for|for
control|(
name|pop
operator|=
name|md_pseudo_table
init|;
name|pop
operator|->
name|poc_name
condition|;
name|pop
operator|++
control|)
block|{
name|errtxt
operator|=
name|hash_insert
argument_list|(
name|po_hash
argument_list|,
name|pop
operator|->
name|poc_name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pop
argument_list|)
expr_stmt|;
if|if
condition|(
name|errtxt
operator|&&
operator|*
name|errtxt
condition|)
block|{
name|as_fatal
argument_list|(
literal|"error constructing md pseudo-op table"
argument_list|)
expr_stmt|;
block|}
comment|/* on error */
block|}
comment|/* for each op */
comment|/* Now object specific.  Skip any that were in the target table. */
for|for
control|(
name|pop
operator|=
name|obj_pseudo_table
init|;
name|pop
operator|->
name|poc_name
condition|;
name|pop
operator|++
control|)
block|{
name|errtxt
operator|=
name|hash_insert
argument_list|(
name|po_hash
argument_list|,
name|pop
operator|->
name|poc_name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pop
argument_list|)
expr_stmt|;
if|if
condition|(
name|errtxt
operator|&&
operator|*
name|errtxt
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|errtxt
argument_list|,
literal|"exists"
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DIE_ON_OVERRIDES
name|as_fatal
argument_list|(
literal|"pseudo op \".%s\" overridden.\n"
argument_list|,
name|pop
operator|->
name|poc_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DIE_ON_OVERRIDES */
continue|continue;
comment|/* OK if target table overrides. */
block|}
else|else
block|{
name|as_fatal
argument_list|(
literal|"error constructing obj pseudo-op table"
argument_list|)
expr_stmt|;
block|}
comment|/* if overridden */
block|}
comment|/* on error */
block|}
comment|/* for each op */
comment|/* Now portable ones.  Skip any that we've seen already. */
for|for
control|(
name|pop
operator|=
name|potable
init|;
name|pop
operator|->
name|poc_name
condition|;
name|pop
operator|++
control|)
block|{
name|errtxt
operator|=
name|hash_insert
argument_list|(
name|po_hash
argument_list|,
name|pop
operator|->
name|poc_name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pop
argument_list|)
expr_stmt|;
if|if
condition|(
name|errtxt
operator|&&
operator|*
name|errtxt
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|errtxt
argument_list|,
literal|"exists"
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DIE_ON_OVERRIDES
name|as_fatal
argument_list|(
literal|"pseudo op \".%s\" overridden.\n"
argument_list|,
name|pop
operator|->
name|poc_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DIE_ON_OVERRIDES */
continue|continue;
comment|/* OK if target table overrides. */
block|}
else|else
block|{
name|as_fatal
argument_list|(
literal|"error constructing obj pseudo-op table"
argument_list|)
expr_stmt|;
block|}
comment|/* if overridden */
block|}
comment|/* on error */
block|}
comment|/* for each op */
return|return;
block|}
end_function

begin_comment
comment|/* pobegin() */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|HANDLE_CONDITIONAL_ASSEMBLY
parameter_list|()
define|\
value|if (ignore_input ())					\ {							\ 							    while (! is_end_of_line[*input_line_pointer++])	\ 								if (input_line_pointer == buffer_limit)		\ 								    break;					\ 									continue;						\ 								    }
end_define

begin_comment
comment|/*	read_a_source_file()  *  * We read the file, putting things into a web that  * represents what we have been reading.  */
end_comment

begin_function
name|void
name|read_a_source_file
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
comment|/* string of symbol, '\0' appended */
specifier|register
name|int
name|temp
decl_stmt|;
name|pseudo_typeS
modifier|*
name|pop
init|=
name|NULL
decl_stmt|;
name|buffer
operator|=
name|input_scrub_new_file
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|listing_file
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|listing_newline
argument_list|(
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|buffer_limit
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We have another line to parse. */
name|know
argument_list|(
name|buffer_limit
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Must have a sentinel. */
name|contin
label|:
comment|/* JF this goto is my fault I admit it.  Someone brave please re-write 		   the whole input section here?  Pleeze??? */
while|while
condition|(
name|input_line_pointer
operator|<
name|buffer_limit
condition|)
block|{
comment|/* We have more of this buffer to parse. */
comment|/* 			 * We now have input_line_pointer->1st char of next line. 			 * If input_line_pointer[-1] == '\n' then we just 			 * scanned another line: so bump line counters. 			 */
if|if
condition|(
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|bump_line_counters
argument_list|()
expr_stmt|;
block|}
comment|/* just passed a newline */
comment|/* 			 * We are at the begining of a line, or similar place. 			 * We expect a well-formed assembler statement. 			 * A "symbol-name:" is a statement. 			 * 			 * Depending on what compiler is used, the order of these tests 			 * may vary to catch most common case 1st. 			 * Each test is independent of all other tests at the (top) level. 			 * PLEASE make a compiler that doesn't use this assembler. 			 * It is crufty to waste a compiler's time encoding things for this 			 * assembler, which then wastes more time decoding it. 			 * (And communicating via (linear) files is silly! 			 * If you must pass stuff, please pass a tree!) 			 */
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
operator|)
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\f'
operator|||
name|c
operator|==
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
block|}
name|know
argument_list|(
name|c
operator|!=
literal|' '
argument_list|)
expr_stmt|;
comment|/* No further leading whitespace. */
name|LISTING_NEWLINE
argument_list|()
expr_stmt|;
comment|/* 			 * C is the 1st significant character. 			 * Input_line_pointer points after that character. 			 */
if|if
condition|(
name|is_name_beginner
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* want user-defined label or pseudo/opcode */
name|HANDLE_CONDITIONAL_ASSEMBLY
argument_list|()
expr_stmt|;
name|s
operator|=
name|input_line_pointer
operator|-
literal|1
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* name's delimiter */
comment|/* 				 * C is character after symbol. 				 * That character's place in the input line is now '\0'. 				 * S points to the beginning of the symbol. 				 *   [In case of pseudo-op, s->'.'.] 				 * Input_line_pointer->'\0' where c was. 				 */
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
name|colon
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* user-defined label */
operator|*
name|input_line_pointer
operator|++
operator|=
literal|':'
expr_stmt|;
comment|/* Put ':' back for error messages' sake. */
comment|/* Input_line_pointer->after ':'. */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'='
operator|||
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
comment|/* JF deal with FOO=BAR */
name|equals
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* expect pseudo-op or machine instruction */
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
ifdef|#
directive|ifdef
name|NO_DOT_PSEUDOS
operator|||
operator|(
name|pop
operator|=
operator|(
name|pseudo_typeS
operator|*
operator|)
name|hash_find
argument_list|(
name|po_hash
argument_list|,
name|s
argument_list|)
operator|)
endif|#
directive|endif
condition|)
block|{
comment|/* 						 * PSEUDO - OP. 						 * 						 * WARNING: c has next char, which may be end-of-line. 						 * We lookup the pseudo-op table with s+1 because we 						 * already know that the pseudo-op begins with a '.'. 						 */
ifdef|#
directive|ifdef
name|NO_DOT_PSEUDOS
if|if
condition|(
operator|*
name|s
operator|==
literal|'.'
condition|)
endif|#
directive|endif
name|pop
operator|=
operator|(
name|pseudo_typeS
operator|*
operator|)
name|hash_find
argument_list|(
name|po_hash
argument_list|,
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Print the error msg now, while we still can */
if|if
condition|(
operator|!
name|pop
condition|)
block|{
name|as_bad
argument_list|(
literal|"Unknown pseudo-op:  `%s'"
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|s_ignore
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Put it back for error messages etc. */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
comment|/* The following skip of whitespace is compulsory. */
comment|/* A well shaped space is sometimes all that separates keyword from operands. */
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
block|}
comment|/* Skip seperator after keyword. */
comment|/* 						 * Input_line is restored. 						 * Input_line_pointer->1st non-blank char 						 * after pseudo-operation. 						 */
if|if
condition|(
operator|!
name|pop
condition|)
block|{
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
break|break;
block|}
else|else
block|{
call|(
modifier|*
name|pop
operator|->
name|poc_handler
call|)
argument_list|(
name|pop
operator|->
name|poc_val
argument_list|)
expr_stmt|;
block|}
comment|/* if we have one */
block|}
else|else
block|{
comment|/* machine instruction */
comment|/* WARNING: c has char, which may be end-of-line. */
comment|/* Also: input_line_pointer->`\0` where c was. */
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
name|md_assemble
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Assemble 1 instruction. */
operator|*
name|input_line_pointer
operator|++
operator|=
name|c
expr_stmt|;
comment|/* We resume loop AFTER the end-of-line from this instruction */
block|}
comment|/* if (*s == '.') */
block|}
comment|/* if c == ':' */
continue|continue;
block|}
comment|/* if (is_name_beginner(c) */
if|if
condition|(
name|is_end_of_line
index|[
name|c
index|]
condition|)
block|{
continue|continue;
block|}
comment|/* empty statement */
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* local label  ("4:") */
name|HANDLE_CONDITIONAL_ASSEMBLY
argument_list|()
expr_stmt|;
name|temp
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCAL_LABELS_DOLLAR
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'$'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|input_line_pointer
operator|++
operator|==
literal|':'
condition|)
block|{
name|local_colon
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|"Spurious digit %d."
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* local label  ("4:") */
if|if
condition|(
name|c
operator|&&
name|strchr
argument_list|(
name|line_comment_chars
argument_list|,
name|c
argument_list|)
condition|)
block|{
comment|/* Its a comment.  Better say APP or NO_APP */
name|char
modifier|*
name|ends
decl_stmt|;
name|char
modifier|*
name|new_buf
decl_stmt|;
name|char
modifier|*
name|new_tmp
decl_stmt|;
name|int
name|new_length
decl_stmt|;
name|char
modifier|*
name|tmp_buf
init|=
literal|0
decl_stmt|;
specifier|extern
name|char
modifier|*
name|scrub_string
decl_stmt|,
modifier|*
name|scrub_last_string
decl_stmt|;
name|bump_line_counters
argument_list|()
expr_stmt|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"APP\n"
argument_list|,
literal|4
argument_list|)
condition|)
continue|continue;
comment|/* We ignore it */
name|s
operator|+=
literal|4
expr_stmt|;
name|ends
operator|=
name|strstr
argument_list|(
name|s
argument_list|,
literal|"#NO_APP\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ends
condition|)
block|{
name|int
name|tmp_len
decl_stmt|;
name|int
name|num
decl_stmt|;
comment|/* The end of the #APP wasn't in this buffer.  We 					   keep reading in buffers until we find the #NO_APP 					   that goes with this #APP  There is one.  The specs 					   guarentee it... */
name|tmp_len
operator|=
name|buffer_limit
operator|-
name|s
expr_stmt|;
name|tmp_buf
operator|=
name|xmalloc
argument_list|(
name|tmp_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmp_buf
argument_list|,
name|s
argument_list|,
name|tmp_len
argument_list|)
expr_stmt|;
do|do
block|{
name|new_tmp
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_tmp
condition|)
break|break;
else|else
name|buffer_limit
operator|=
name|new_tmp
expr_stmt|;
name|input_line_pointer
operator|=
name|buffer
expr_stmt|;
name|ends
operator|=
name|strstr
argument_list|(
name|buffer
argument_list|,
literal|"#NO_APP\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ends
condition|)
name|num
operator|=
name|ends
operator|-
name|buffer
expr_stmt|;
else|else
name|num
operator|=
name|buffer_limit
operator|-
name|buffer
expr_stmt|;
name|tmp_buf
operator|=
name|xrealloc
argument_list|(
name|tmp_buf
argument_list|,
name|tmp_len
operator|+
name|num
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tmp_buf
operator|+
name|tmp_len
argument_list|,
name|buffer
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|tmp_len
operator|+=
name|num
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|ends
condition|)
do|;
name|input_line_pointer
operator|=
name|ends
condition|?
name|ends
operator|+
literal|8
else|:
name|NULL
expr_stmt|;
name|s
operator|=
name|tmp_buf
expr_stmt|;
name|ends
operator|=
name|s
operator|+
name|tmp_len
expr_stmt|;
block|}
else|else
block|{
name|input_line_pointer
operator|=
name|ends
operator|+
literal|8
expr_stmt|;
block|}
name|new_buf
operator|=
name|xmalloc
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|new_length
operator|=
literal|100
expr_stmt|;
name|new_tmp
operator|=
name|new_buf
expr_stmt|;
name|scrub_string
operator|=
name|s
expr_stmt|;
name|scrub_last_string
operator|=
name|ends
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|ch
decl_stmt|;
name|ch
operator|=
name|do_scrub_next_char
argument_list|(
name|scrub_from_string
argument_list|,
name|scrub_to_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
break|break;
operator|*
name|new_tmp
operator|++
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|new_tmp
operator|==
name|new_buf
operator|+
name|new_length
condition|)
block|{
name|new_buf
operator|=
name|xrealloc
argument_list|(
name|new_buf
argument_list|,
name|new_length
operator|+
literal|100
argument_list|)
expr_stmt|;
name|new_tmp
operator|=
name|new_buf
operator|+
name|new_length
expr_stmt|;
name|new_length
operator|+=
literal|100
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tmp_buf
condition|)
name|free
argument_list|(
name|tmp_buf
argument_list|)
expr_stmt|;
name|old_buffer
operator|=
name|buffer
expr_stmt|;
name|old_input
operator|=
name|input_line_pointer
expr_stmt|;
name|old_limit
operator|=
name|buffer_limit
expr_stmt|;
name|buffer
operator|=
name|new_buf
expr_stmt|;
name|input_line_pointer
operator|=
name|new_buf
expr_stmt|;
name|buffer_limit
operator|=
name|new_tmp
expr_stmt|;
continue|continue;
block|}
name|HANDLE_CONDITIONAL_ASSEMBLY
argument_list|()
expr_stmt|;
comment|/* as_warn("Junk character %d.",c);  Now done by ignore_rest */
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Report unknown char as ignored. */
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
comment|/* while (input_line_pointer<buffer_limit) */
if|if
condition|(
name|old_buffer
condition|)
block|{
name|bump_line_counters
argument_list|()
expr_stmt|;
if|if
condition|(
name|old_input
operator|!=
literal|0
condition|)
block|{
name|buffer
operator|=
name|old_buffer
expr_stmt|;
name|input_line_pointer
operator|=
name|old_input
expr_stmt|;
name|buffer_limit
operator|=
name|old_limit
expr_stmt|;
name|old_buffer
operator|=
literal|0
expr_stmt|;
goto|goto
name|contin
goto|;
block|}
block|}
block|}
comment|/* while (more buffers to scan) */
name|input_scrub_close
argument_list|()
expr_stmt|;
comment|/* Close the input file */
block|}
end_function

begin_comment
comment|/* read_a_source_file() */
end_comment

begin_function
name|void
name|s_abort
parameter_list|()
block|{
name|as_fatal
argument_list|(
literal|".abort detected.  Abandoning ship."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_abort() */
end_comment

begin_comment
comment|/* For machines where ".align 4" means align to a 4 byte boundary. */
end_comment

begin_function
name|void
name|s_align_bytes
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|temp
decl_stmt|;
specifier|register
name|long
name|temp_fill
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|max_alignment
init|=
literal|1
operator|<<
literal|15
decl_stmt|;
if|if
condition|(
name|is_end_of_line
index|[
operator|*
name|input_line_pointer
index|]
condition|)
name|temp
operator|=
name|arg
expr_stmt|;
comment|/* Default value from pseudo-op table */
else|else
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|>
name|max_alignment
condition|)
block|{
name|as_bad
argument_list|(
literal|"Alignment too large: %d. assumed."
argument_list|,
name|temp
operator|=
name|max_alignment
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * For the sparc, `.align (1<<n)' actually means `.align n' 	 * so we have to convert it. 	 */
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|temp
operator|&
literal|1
operator|)
operator|==
literal|0
condition|;
name|temp
operator|>>=
literal|1
operator|,
operator|++
name|i
control|)
empty_stmt|;
block|}
if|if
condition|(
name|temp
operator|!=
literal|1
condition|)
name|as_bad
argument_list|(
literal|"Alignment not a power of 2"
argument_list|)
expr_stmt|;
name|temp
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|temp_fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|temp_fill
operator|=
name|NOP_OPCODE
expr_stmt|;
block|}
comment|/* Only make a frag if we HAVE to... */
if|if
condition|(
name|temp
operator|&&
operator|!
name|need_pass_2
condition|)
name|frag_align
argument_list|(
name|temp
argument_list|,
operator|(
name|int
operator|)
name|temp_fill
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_align_bytes() */
end_comment

begin_comment
comment|/* For machines where ".align 4" means align to 2**4 boundary. */
end_comment

begin_function
name|void
name|s_align_ptwo
parameter_list|()
block|{
specifier|register
name|int
name|temp
decl_stmt|;
specifier|register
name|long
name|temp_fill
decl_stmt|;
name|long
name|max_alignment
init|=
literal|15
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|>
name|max_alignment
condition|)
name|as_bad
argument_list|(
literal|"Alignment too large: %d. assumed."
argument_list|,
name|temp
operator|=
name|max_alignment
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"Alignment negative. 0 assumed."
argument_list|)
expr_stmt|;
name|temp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|temp_fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
else|else
name|temp_fill
operator|=
name|NOP_OPCODE
expr_stmt|;
comment|/* Only make a frag if we HAVE to... */
if|if
condition|(
name|temp
operator|&&
operator|!
name|need_pass_2
condition|)
name|frag_align
argument_list|(
name|temp
argument_list|,
operator|(
name|int
operator|)
name|temp_fill
argument_list|)
expr_stmt|;
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_align_ptwo() */
end_comment

begin_function
name|void
name|s_comm
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* just after name is now '\0' */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected comma after symbol-name: rest of line ignored."
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* skip ',' */
if|if
condition|(
operator|(
name|temp
operator|=
name|get_absolute_expression
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|".COMMon length (%d.)<0! Ignored."
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Ignoring attempt to re-define symbol"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|temp
condition|)
name|as_bad
argument_list|(
literal|"Length of .comm \"%s\" is already %d. Not changed to %d."
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OBJ_VMS
if|if
condition|(
operator|(
operator|!
name|temp
operator|)
operator|||
operator|!
name|flagseen
index|[
literal|'1'
index|]
condition|)
name|S_GET_OTHER
argument_list|(
name|symbolP
argument_list|)
operator|=
name|const_flag
expr_stmt|;
endif|#
directive|endif
comment|/* not OBJ_VMS */
name|know
argument_list|(
name|symbolP
operator|->
name|sy_frag
operator|==
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_comm() */
end_comment

begin_function
name|void
name|s_data
parameter_list|()
block|{
specifier|register
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_new
argument_list|(
name|SEG_DATA
argument_list|,
operator|(
name|subsegT
operator|)
name|temp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_VMS
name|const_flag
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* not OBJ_VMS */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle the .appfile pseudo-op.  This is automatically generated by    do_scrub_next_char when a preprocessor # line comment is seen with    a file name.  This default definition may be overridden by the    object or CPU specific pseudo-ops.  This function is also the    default definition for .file; the APPFILE argument is 1 for    .appfile, 0 for .file.  */
end_comment

begin_function
name|void
name|s_app_file
parameter_list|(
name|appfile
parameter_list|)
name|int
name|appfile
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* Some assemblers tolerate immediately following '"' */
if|if
condition|(
operator|(
name|s
operator|=
name|demand_copy_string
argument_list|(
operator|&
name|length
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* If this is a fake .appfile, a fake newline was inserted 		 * into the buffer.  Passing -2 to new_logical_line tells it 		 * to account for it. 		 */
name|new_logical_line
argument_list|(
name|s
argument_list|,
name|appfile
condition|?
operator|-
literal|2
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|LISTING
if|if
condition|(
name|listing
condition|)
name|listing_source_file
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|OBJ_COFF
name|c_dot_file_symbol
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_COFF */
block|}
end_function

begin_comment
comment|/* s_app_file() */
end_comment

begin_comment
comment|/* Handle the .appline pseudo-op.  This is automatically generated by    do_scrub_next_char when a preprocessor # line comment is seen.    This default definition may be overridden by the object or CPU    specific pseudo-ops.  */
end_comment

begin_function
name|void
name|s_app_line
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
name|int
name|l
decl_stmt|;
comment|/* The given number is that of the next line.  */
name|l
operator|=
name|get_absolute_expression
argument_list|()
operator|-
literal|1
expr_stmt|;
name|new_logical_line
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|l
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LISTING
if|if
condition|(
name|listing
condition|)
name|listing_source_line
argument_list|(
name|l
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_fill
parameter_list|()
block|{
name|long
name|temp_repeat
decl_stmt|;
name|long
name|temp_size
decl_stmt|;
specifier|register
name|long
name|temp_fill
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|temp_repeat
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Backup over what was not a ','. */
name|as_bad
argument_list|(
literal|"Expect comma after rep-size in .fill:"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|temp_size
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Backup over what was not a ','. */
name|as_bad
argument_list|(
literal|"Expected comma after size in .fill"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* 	 * This is to be compatible with BSD 4.2 AS, not for any rational reason. 	 */
define|#
directive|define
name|BSD_FILL_SIZE_CROCK_8
value|(8)
if|if
condition|(
name|temp_size
operator|>
name|BSD_FILL_SIZE_CROCK_8
condition|)
block|{
name|as_bad
argument_list|(
literal|".fill size clamped to %d."
argument_list|,
name|BSD_FILL_SIZE_CROCK_8
argument_list|)
expr_stmt|;
name|temp_size
operator|=
name|BSD_FILL_SIZE_CROCK_8
expr_stmt|;
block|}
if|if
condition|(
name|temp_size
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"Size negative: .fill ignored."
argument_list|)
expr_stmt|;
name|temp_size
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|temp_repeat
operator|<=
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"Repeat< 0, .fill ignored"
argument_list|)
expr_stmt|;
name|temp_size
operator|=
literal|0
expr_stmt|;
block|}
name|temp_fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp_size
operator|&&
operator|!
name|need_pass_2
condition|)
block|{
name|p
operator|=
name|frag_var
argument_list|(
name|rs_fill
argument_list|,
operator|(
name|int
operator|)
name|temp_size
argument_list|,
operator|(
name|int
operator|)
name|temp_size
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
name|temp_repeat
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|,
operator|(
name|int
operator|)
name|temp_size
argument_list|)
expr_stmt|;
comment|/* 		 * The magic number BSD_FILL_SIZE_CROCK_4 is from BSD 4.2 VAX flavoured AS. 		 * The following bizzare behaviour is to be compatible with above. 		 * I guess they tried to take up to 8 bytes from a 4-byte expression 		 * and they forgot to sign extend. Un*x Sux. 		 */
define|#
directive|define
name|BSD_FILL_SIZE_CROCK_4
value|(4)
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|temp_fill
argument_list|,
name|temp_size
operator|>
name|BSD_FILL_SIZE_CROCK_4
condition|?
name|BSD_FILL_SIZE_CROCK_4
else|:
operator|(
name|int
operator|)
name|temp_size
argument_list|)
expr_stmt|;
comment|/* 		 * Note: .fill (),0 emits no frag (since we are asked to .fill 0 bytes) 		 * but emits no error message because it seems a legal thing to do. 		 * It is a degenerate case of .fill but could be emitted by a compiler. 		 */
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_globl
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
do|do
block|{
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|==
literal|','
condition|)
do|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_globl() */
end_comment

begin_function
name|void
name|s_lcomm
parameter_list|(
name|needs_align
parameter_list|)
name|int
name|needs_align
decl_stmt|;
comment|/* 1 if this was a ".bss" directive, which may require 			 *	a 3rd argument (alignment). 			 * 0 if it was an ".lcomm" (2 args only) 			 */
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
specifier|const
name|int
name|max_alignment
init|=
literal|15
decl_stmt|;
name|int
name|align
init|=
literal|0
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected comma after name"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Missing size expression"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|temp
operator|=
name|get_absolute_expression
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"BSS length (%d.)<0! Ignored."
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|needs_align
condition|)
block|{
name|align
operator|=
literal|0
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected comma after size"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Missing alignment"
argument_list|)
expr_stmt|;
return|return;
block|}
name|align
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|align
operator|>
name|max_alignment
condition|)
block|{
name|align
operator|=
name|max_alignment
expr_stmt|;
name|as_warn
argument_list|(
literal|"Alignment too large: %d. assumed."
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|align
operator|<
literal|0
condition|)
block|{
name|align
operator|=
literal|0
expr_stmt|;
name|as_warn
argument_list|(
literal|"Alignment negative. 0 assumed."
argument_list|)
expr_stmt|;
block|}
name|record_alignment
argument_list|(
name|SEG_BSS
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
comment|/* if needs align */
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
if|#
directive|if
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
name|S_GET_OTHER
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
operator|&&
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
operator|&&
endif|#
directive|endif
comment|/* OBJ_AOUT or OBJ_BOUT */
operator|(
operator|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_BSS
operator|)
operator|&&
operator|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|==
name|local_bss_counter
operator|)
operator|)
operator|||
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|needs_align
condition|)
block|{
comment|/* Align */
name|align
operator|=
operator|~
operator|(
operator|(
operator|~
literal|0
operator|)
operator|<<
name|align
operator|)
expr_stmt|;
comment|/* Convert to a mask */
name|local_bss_counter
operator|=
operator|(
name|local_bss_counter
operator|+
name|align
operator|)
operator|&
operator|(
operator|~
name|align
operator|)
expr_stmt|;
block|}
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|local_bss_counter
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|SEG_BSS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_COFF
comment|/* The symbol may already have been created with a preceding 		 * ".globl" directive -- be careful not to step on storage 		 * class in that case.  Otherwise, set it to static. 		 */
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|C_EXT
condition|)
block|{
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_STAT
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* OBJ_COFF */
name|symbolP
operator|->
name|sy_frag
operator|=
operator|&
name|bss_address_frag
expr_stmt|;
name|local_bss_counter
operator|+=
name|temp
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|"Ignoring attempt to re-define symbol from %d. to %d."
argument_list|,
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|local_bss_counter
argument_list|)
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* s_lcomm() */
end_comment

begin_function
name|void
name|s_long
parameter_list|()
block|{
name|cons
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_int
parameter_list|()
block|{
name|cons
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|s_lsym
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|segT
name|segment
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* we permit ANY defined expression: BSD4.2 demands constants */
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
literal|"Expected comma after name \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
name|segment
operator|=
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|segment
operator|!=
name|SEG_ABSOLUTE
operator|&&
operator|!
name|SEG_NORMAL
argument_list|(
name|segment
argument_list|)
operator|&&
name|segment
operator|!=
name|SEG_REGISTER
condition|)
block|{
name|as_bad
argument_list|(
literal|"Bad expression: %s"
argument_list|,
name|segment_name
argument_list|(
name|segment
argument_list|)
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* FIXME-SOON I pulled a (&& symbolP->sy_other == 0&& symbolP->sy_desc == 0) out of this test 	   because coff doesn't have those fields, and I 	   can't see when they'd ever be tripped.  I don't 	   think I understand why they were here so I may 	   have introduced a bug. As recently as 1.37 didn't 	   have this test anyway.  xoxorich. */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_UNKNOWN
operator|&&
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* The name might be an undefined .global symbol; be 		   sure to keep the "external" bit. */
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|exp
operator|.
name|X_add_number
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|"Symbol %s already defined"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_lsym() */
end_comment

begin_function
name|void
name|s_org
parameter_list|()
block|{
specifier|register
name|segT
name|segment
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
specifier|register
name|long
name|temp_fill
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	 * Don't believe the documentation of BSD 4.2 AS. 	 * There is no such thing as a sub-segment-relative origin. 	 * Any absolute origin is given a warning, then assumed to be segment-relative. 	 * Any segmented origin expression ("foo+42") had better be in the right 	 * segment or the .org is ignored. 	 * 	 * BSD 4.2 AS warns if you try to .org backwards. We cannot because we 	 * never know sub-segment sizes when we are reading code. 	 * BSD will crash trying to emit -ve numbers of filler bytes in certain 	 * .orgs. We don't crash, but see as-write for that code. 	 */
comment|/* 	 * Don't make frag if need_pass_2 == 1. 	 */
name|segment
operator|=
name|get_known_segmented_expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|temp_fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
else|else
name|temp_fill
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|need_pass_2
condition|)
block|{
if|if
condition|(
name|segment
operator|!=
name|now_seg
operator|&&
name|segment
operator|!=
name|SEG_ABSOLUTE
condition|)
name|as_bad
argument_list|(
literal|"Invalid segment \"%s\". Segment \"%s\" assumed."
argument_list|,
name|segment_name
argument_list|(
name|segment
argument_list|)
argument_list|,
name|segment_name
argument_list|(
name|now_seg
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|exp
operator|.
name|X_add_number
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|temp_fill
expr_stmt|;
block|}
comment|/* if (ok to make frag) */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_org() */
end_comment

begin_function
name|void
name|s_set
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|delim
decl_stmt|;
specifier|register
name|char
modifier|*
name|end_name
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* 	 * Especial apologies for the random logic: 	 * this just grew, and could be parsed much more simply! 	 * Dean in haste. 	 */
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|delim
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|end_name
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
operator|*
name|end_name
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
literal|"Expected comma after name \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
operator|*
name|end_name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Turn '. = mumble' into a .org mumble */
specifier|register
name|segT
name|segment
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
name|segment
operator|=
name|get_known_segmented_expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|need_pass_2
condition|)
block|{
if|if
condition|(
name|segment
operator|!=
name|now_seg
operator|&&
name|segment
operator|!=
name|SEG_ABSOLUTE
condition|)
name|as_bad
argument_list|(
literal|"Invalid segment \"%s\". Segment \"%s\" assumed."
argument_list|,
name|segment_name
argument_list|(
name|segment
argument_list|)
argument_list|,
name|segment_name
argument_list|(
name|now_seg
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|exp
operator|.
name|X_add_number
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if (ok to make frag) */
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|symbolP
operator|=
name|md_undefined_symbol
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|SEG_UNKNOWN
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_COFF
comment|/* "set" symbols are local unless otherwise specified. */
name|SF_SET_LOCAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_COFF */
block|}
comment|/* make a new symbol */
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
operator|*
name|end_name
operator|=
name|delim
expr_stmt|;
name|pseudo_set
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_set() */
end_comment

begin_function
name|void
name|s_size
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* just after name is now '\0' */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected comma after symbol-name: rest of line ignored."
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* skip ',' */
if|if
condition|(
operator|(
name|exp
operator|=
operator|(
name|expressionS
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|expressionS
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
literal|"Virtual memory exhausted"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|get_known_segmented_expression
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|SEG_ABSOLUTE
case|:
break|break;
case|case
name|SEG_DIFFERENCE
case|:
if|if
condition|(
name|exp
operator|->
name|X_add_symbol
operator|==
name|NULL
operator|||
name|exp
operator|->
name|X_subtract_symbol
operator|==
name|NULL
operator|||
name|S_GET_SEGMENT
argument_list|(
name|exp
operator|->
name|X_add_symbol
argument_list|)
operator|!=
name|S_GET_SEGMENT
argument_list|(
name|exp
operator|->
name|X_subtract_symbol
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Illegal .size expression"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
break|break;
default|default:
name|as_bad
argument_list|(
literal|"Illegal .size expression"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|symbolP
operator|->
name|sy_sizexp
condition|)
block|{
name|as_warn
argument_list|(
literal|"\"%s\" already has a size"
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|symbolP
operator|->
name|sy_sizexp
operator|=
operator|(
name|void
operator|*
operator|)
name|exp
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_size() */
end_comment

begin_function
name|void
name|s_type
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|type
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|,
name|c1
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|int
name|aux
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* just after name is now '\0' */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected comma after symbol-name: rest of line ignored."
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* skip ',' */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
name|TYPE_OPERAND_FMT
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected `%c' as start of operand: rest of line ignored."
argument_list|,
name|TYPE_OPERAND_FMT
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* skip '@' */
name|type
operator|=
name|input_line_pointer
expr_stmt|;
name|c1
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"function"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|aux
operator|=
name|AUX_FUNC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"object"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|aux
operator|=
name|AUX_OBJECT
expr_stmt|;
block|}
else|else
block|{
name|as_warn
argument_list|(
literal|"Unrecognized .type operand: \"%s\": rest of line ignored."
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|input_line_pointer
operator|=
name|c1
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|symbolP
operator|->
name|sy_aux
operator|&&
name|symbolP
operator|->
name|sy_aux
operator|!=
name|aux
condition|)
block|{
name|as_bad
argument_list|(
literal|"Type of \"%s\" is already %d. Not changed to %d."
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|symbolP
operator|->
name|sy_aux
argument_list|,
name|aux
argument_list|)
expr_stmt|;
block|}
else|else
name|symbolP
operator|->
name|sy_aux
operator|=
name|aux
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_type() */
end_comment

begin_function
name|void
name|s_weak
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
do|do
block|{
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_bind
operator|=
name|BIND_WEAK
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|==
literal|','
condition|)
do|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_weak() */
end_comment

begin_function
name|void
name|s_space
parameter_list|()
block|{
name|long
name|temp_repeat
decl_stmt|;
specifier|register
name|long
name|temp_fill
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Just like .fill, but temp_size = 1 */
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|temp_repeat
argument_list|)
operator|==
literal|','
condition|)
block|{
name|temp_fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Backup over what was not a ','. */
name|temp_fill
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|temp_repeat
operator|<=
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"Repeat< 0, .space ignored"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|need_pass_2
condition|)
block|{
name|p
operator|=
name|frag_var
argument_list|(
name|rs_fill
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
name|temp_repeat
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|temp_fill
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_space() */
end_comment

begin_function
name|void
name|s_text
parameter_list|()
block|{
specifier|register
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_new
argument_list|(
name|SEG_TEXT
argument_list|,
operator|(
name|subsegT
operator|)
name|temp
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_text() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*(JF was static, but can't be if machine dependent pseudo-ops are to use it */
end_comment

begin_function
name|void
name|demand_empty_rest_of_line
parameter_list|()
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_end_of_line
index|[
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
comment|/* Return having already swallowed end-of-line. */
block|}
end_function

begin_comment
comment|/* Return pointing just after end-of-line. */
end_comment

begin_function
name|void
name|ignore_rest_of_line
parameter_list|()
comment|/* For suspect lines: gives warning. */
block|{
if|if
condition|(
operator|!
name|is_end_of_line
index|[
operator|*
name|input_line_pointer
index|]
condition|)
block|{
if|if
condition|(
name|isprint
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
name|as_bad
argument_list|(
literal|"Rest of line ignored. First ignored character is `%c'."
argument_list|,
operator|*
name|input_line_pointer
argument_list|)
expr_stmt|;
else|else
name|as_bad
argument_list|(
literal|"Rest of line ignored. First ignored character valued 0x%x."
argument_list|,
operator|*
name|input_line_pointer
argument_list|)
expr_stmt|;
while|while
condition|(
name|input_line_pointer
operator|<
name|buffer_limit
operator|&&
operator|!
name|is_end_of_line
index|[
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
block|}
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* Return pointing just after end-of-line. */
name|know
argument_list|(
name|is_end_of_line
index|[
name|input_line_pointer
index|[
operator|-
literal|1
index|]
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *			pseudo_set()  *  * In:	Pointer to a symbol.  *	Input_line_pointer->expression.  *  * Out:	Input_line_pointer->just after any whitespace after expression.  *	Tried to set symbol to value of expression.  *	Will change symbols type, value, and frag;  *	May set need_pass_2 == 1.  */
end_comment

begin_function
name|void
name|pseudo_set
parameter_list|(
name|symbolP
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
name|expressionS
name|exp
decl_stmt|;
specifier|register
name|segT
name|segment
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
name|int
name|ext
decl_stmt|;
endif|#
directive|endif
comment|/* OBJ_AOUT or OBJ_BOUT */
name|know
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
comment|/* NULL pointer is logic error. */
if|#
directive|if
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
name|ext
operator|=
name|S_IS_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_AOUT or OBJ_BOUT */
if|if
condition|(
operator|(
name|segment
operator|=
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
operator|)
operator|==
name|SEG_ABSENT
condition|)
block|{
name|as_bad
argument_list|(
literal|"Missing expression: absolute 0 assumed"
argument_list|)
expr_stmt|;
name|exp
operator|.
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|segment
condition|)
block|{
case|case
name|SEG_BIG
case|:
name|as_bad
argument_list|(
literal|"%s number invalid. Absolute 0 assumed."
argument_list|,
name|exp
operator|.
name|X_add_number
operator|>
literal|0
condition|?
literal|"Bignum"
else|:
literal|"Floating-Point"
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|SEG_ABSOLUTE
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
name|ext
condition|?
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
else|:
name|S_CLEAR_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_AOUT or OBJ_BOUT */
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
break|break;
case|case
name|SEG_ABSENT
case|:
name|as_warn
argument_list|(
literal|"No expression:  Using absolute 0"
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|SEG_ABSOLUTE
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
name|ext
condition|?
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
else|:
name|S_CLEAR_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_AOUT or OBJ_BOUT */
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
break|break;
case|case
name|SEG_DIFFERENCE
case|:
if|if
condition|(
name|exp
operator|.
name|X_add_symbol
operator|&&
name|exp
operator|.
name|X_subtract_symbol
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|exp
operator|.
name|X_add_symbol
argument_list|)
operator|==
name|S_GET_SEGMENT
argument_list|(
name|exp
operator|.
name|X_subtract_symbol
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|exp
operator|.
name|X_add_symbol
operator|->
name|sy_frag
operator|!=
name|exp
operator|.
name|X_subtract_symbol
operator|->
name|sy_frag
condition|)
block|{
name|as_bad
argument_list|(
literal|"Unknown expression: symbols %s and %s are in different frags."
argument_list|,
name|S_GET_NAME
argument_list|(
name|exp
operator|.
name|X_add_symbol
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|exp
operator|.
name|X_subtract_symbol
argument_list|)
argument_list|)
expr_stmt|;
name|need_pass_2
operator|++
expr_stmt|;
block|}
name|exp
operator|.
name|X_add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|exp
operator|.
name|X_add_symbol
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|exp
operator|.
name|X_subtract_symbol
argument_list|)
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
literal|"Complex expression. Absolute segment assumed."
argument_list|)
expr_stmt|;
case|case
name|SEG_ABSOLUTE
case|:
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|SEG_ABSOLUTE
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
name|ext
condition|?
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
else|:
name|S_CLEAR_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_AOUT or OBJ_BOUT */
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
break|break;
default|default:
name|know
argument_list|(
name|SEG_NORMAL
argument_list|(
name|segment
argument_list|)
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|segment
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
if|if
condition|(
name|ext
condition|)
block|{
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|S_CLEAR_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
comment|/* if external */
endif|#
directive|endif
comment|/* OBJ_AOUT or OBJ_BOUT */
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|exp
operator|.
name|X_add_number
operator|+
name|S_GET_VALUE
argument_list|(
name|exp
operator|.
name|X_add_symbol
argument_list|)
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
name|exp
operator|.
name|X_add_symbol
operator|->
name|sy_frag
expr_stmt|;
name|symbolP
operator|->
name|sy_aux
operator|=
name|exp
operator|.
name|X_add_symbol
operator|->
name|sy_aux
expr_stmt|;
break|break;
case|case
name|SEG_PASS1
case|:
comment|/* Not an error. Just try another pass. */
name|symbolP
operator|->
name|sy_forward
operator|=
name|exp
operator|.
name|X_add_symbol
expr_stmt|;
name|as_bad
argument_list|(
literal|"Unknown expression"
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|need_pass_2
operator|==
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEG_UNKNOWN
case|:
name|symbolP
operator|->
name|sy_forward
operator|=
name|exp
operator|.
name|X_add_symbol
expr_stmt|;
comment|/* as_warn("unknown symbol"); */
comment|/* need_pass_2 = 1; */
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			cons()  *  * CONStruct more frag of .bytes, or .words etc.  * Should need_pass_2 be 1 then emit no frag(s).  * This understands EXPRESSIONS, as opposed to big_cons().  *  * Bug (?)  *  * This has a split personality. We use expression() to read the  * value. We can detect if the value won't fit in a byte or word.  * But we can't detect if expression() discarded significant digits  * in the case of a long. Not worth the crocks required to fix it.  */
end_comment

begin_comment
comment|/* worker to do .byte etc statements */
end_comment

begin_comment
comment|/* clobbers input_line_pointer, checks */
end_comment

begin_comment
comment|/* end-of-line. */
end_comment

begin_function
name|void
name|cons
parameter_list|(
name|nbytes
parameter_list|)
specifier|register
name|unsigned
name|int
name|nbytes
decl_stmt|;
comment|/* 1=.byte, 2=.word, 4=.long */
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|long
name|mask
decl_stmt|;
comment|/* High-order bits we will left-truncate, */
comment|/* but includes sign bit also. */
specifier|register
name|long
name|get
decl_stmt|;
comment|/* what we get */
specifier|register
name|long
name|use
decl_stmt|;
comment|/* get after truncation. */
specifier|register
name|long
name|unmask
decl_stmt|;
comment|/* what bits we will store */
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|segT
name|segment
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
comment|/* 	 * Input_line_pointer->1st char after pseudo-op-code and could legally 	 * be a end-of-line. (Or, less legally an eof - which we cope with.) 	 */
comment|/* JF<< of>= number of bits in the object is undefined.  In particular 	   SPARC (Sun 4) has problems */
if|if
condition|(
name|nbytes
operator|>=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
block|{
name|mask
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
operator|~
literal|0
operator|<<
operator|(
name|BITS_PER_CHAR
operator|*
name|nbytes
operator|)
expr_stmt|;
comment|/* Don't store these bits. */
block|}
comment|/* bigger than a long */
name|unmask
operator|=
operator|~
name|mask
expr_stmt|;
comment|/* Do store these bits. */
ifdef|#
directive|ifdef
name|NEVER
literal|"Do this mod if you want every overflow check to assume SIGNED 2's complement data."
expr_stmt|;
name|mask
operator|=
operator|~
operator|(
name|unmask
operator|>>
literal|1
operator|)
expr_stmt|;
comment|/* Includes sign bit now. */
endif|#
directive|endif
comment|/* 	 * The following awkward logic is to parse ZERO or more expressions, 	 * comma seperated. Recall an expression includes its leading& 	 * trailing blanks. We fake a leading ',' if there is (supposed to 	 * be) a 1st expression, and keep demanding 1 expression for each ','. 	 */
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
comment|/* Skip loop. */
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* Matches end-of-loop 'correction'. */
block|}
else|else
block|{
name|c
operator|=
literal|','
expr_stmt|;
block|}
comment|/* if the end else fake it */
comment|/* Do loop. */
while|while
condition|(
name|c
operator|==
literal|','
condition|)
block|{
ifdef|#
directive|ifdef
name|WANT_BITFIELDS
name|unsigned
name|int
name|bits_available
init|=
name|BITS_PER_CHAR
operator|*
name|nbytes
decl_stmt|;
comment|/* used for error messages and rescanning */
name|char
modifier|*
name|hold
init|=
name|input_line_pointer
decl_stmt|;
endif|#
directive|endif
comment|/* WANT_BITFIELDS */
comment|/* At least scan over the expression. */
name|segment
operator|=
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WANT_BITFIELDS
comment|/* Some other assemblers, (eg, asm960), allow 		   bitfields after ".byte" as w:x,y:z, where w and 		   y are bitwidths and x and y are values.  They 		   then pack them all together. We do a little 		   better in that we allow them in words, longs, 		   etc. and we'll pack them in target byte order 		   for you.  		   The rules are: pack least significat bit first, 		   if a field doesn't entirely fit, put it in the 		   next unit.  Overflowing the bitfield is 		   explicitly *not* even a warning.  The bitwidth 		   should be considered a "mask".  		   FIXME-SOMEDAY: If this is considered generally 		   useful, this logic should probably be reworked. 		   xoxorich. */
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|':'
condition|)
block|{
comment|/* bitfields */
name|long
name|value
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|unsigned
name|long
name|width
decl_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|':'
condition|)
block|{
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
break|break;
block|}
comment|/* next piece is not a bitfield */
comment|/* In the general case, we can't allow 				   full expressions with symbol 				   differences and such.  The relocation 				   entries for symbols not defined in this 				   assembly would require arbitrary field 				   widths, positions, and masks which most 				   of our current object formats don't 				   support.  				   In the specific case where a symbol 				   *is* defined in this assembly, we 				   *could* build fixups and track it, but 				   this could lead to confusion for the 				   backends.  I'm lazy. I'll take any 				   SEG_ABSOLUTE. I think that means that 				   you can use a previous .set or 				   .equ type symbol.  xoxorich. */
if|if
condition|(
name|segment
operator|==
name|SEG_ABSENT
condition|)
block|{
name|as_warn
argument_list|(
literal|"Using a bit field width of zero."
argument_list|)
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|segment
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
block|}
comment|/* implied zero width bitfield */
if|if
condition|(
name|segment
operator|!=
name|SEG_ABSOLUTE
condition|)
block|{
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
name|as_bad
argument_list|(
literal|"Field width \"%s\" too complex for a bitfield.\n"
argument_list|,
name|hold
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|':'
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* too complex */
if|if
condition|(
operator|(
name|width
operator|=
name|exp
operator|.
name|X_add_number
operator|)
operator|>
operator|(
name|BITS_PER_CHAR
operator|*
name|nbytes
operator|)
condition|)
block|{
name|as_warn
argument_list|(
literal|"Field width %d too big to fit in %d bytes: truncated to %d bits."
argument_list|,
name|width
argument_list|,
name|nbytes
argument_list|,
operator|(
name|BITS_PER_CHAR
operator|*
name|nbytes
operator|)
argument_list|)
expr_stmt|;
name|width
operator|=
name|BITS_PER_CHAR
operator|*
name|nbytes
expr_stmt|;
block|}
comment|/* too big */
if|if
condition|(
name|width
operator|>
name|bits_available
condition|)
block|{
comment|/* FIXME-SOMEDAY: backing up and 					   reparsing is wasteful */
name|input_line_pointer
operator|=
name|hold
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
name|value
expr_stmt|;
break|break;
block|}
comment|/* won't fit */
name|hold
operator|=
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* skip ':' */
if|if
condition|(
operator|(
name|segment
operator|=
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
operator|)
operator|!=
name|SEG_ABSOLUTE
condition|)
block|{
name|char
name|cache
init|=
operator|*
name|input_line_pointer
decl_stmt|;
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
name|as_bad
argument_list|(
literal|"Field value \"%s\" too complex for a bitfield.\n"
argument_list|,
name|hold
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|cache
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* too complex */
name|value
operator||=
operator|(
operator|~
operator|(
operator|-
literal|1
operator|<<
name|width
operator|)
operator|&
name|exp
operator|.
name|X_add_number
operator|)
operator|<<
operator|(
operator|(
name|BITS_PER_CHAR
operator|*
name|nbytes
operator|)
operator|-
name|bits_available
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bits_available
operator|-=
name|width
operator|)
operator|==
literal|0
operator|||
name|is_it_end_of_statement
argument_list|()
operator|||
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
break|break;
block|}
comment|/* all the bitfields we're gonna get */
name|hold
operator|=
operator|++
name|input_line_pointer
expr_stmt|;
name|segment
operator|=
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
block|}
comment|/* forever loop */
name|exp
operator|.
name|X_add_number
operator|=
name|value
expr_stmt|;
name|segment
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
block|}
comment|/* if looks like a bitfield */
endif|#
directive|endif
comment|/* WANT_BITFIELDS */
if|if
condition|(
operator|!
name|need_pass_2
condition|)
block|{
comment|/* Still worthwhile making frags. */
comment|/* Don't call this if we are going to junk this pass anyway! */
name|know
argument_list|(
name|segment
operator|!=
name|SEG_PASS1
argument_list|)
expr_stmt|;
if|if
condition|(
name|segment
operator|==
name|SEG_DIFFERENCE
operator|&&
name|exp
operator|.
name|X_add_symbol
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
literal|"Subtracting symbol \"%s\"(segment\"%s\") is too hard. Absolute segment assumed."
argument_list|,
name|S_GET_NAME
argument_list|(
name|exp
operator|.
name|X_subtract_symbol
argument_list|)
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|exp
operator|.
name|X_subtract_symbol
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|segment
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
comment|/* Leave exp.X_add_number alone. */
block|}
name|p
operator|=
name|frag_more
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|segment
condition|)
block|{
case|case
name|SEG_BIG
case|:
name|as_bad
argument_list|(
literal|"%s number invalid. Absolute 0 assumed."
argument_list|,
name|exp
operator|.
name|X_add_number
operator|>
literal|0
condition|?
literal|"Bignum"
else|:
literal|"Floating-Point"
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEG_ABSENT
case|:
name|as_warn
argument_list|(
literal|"0 assumed for missing expression"
argument_list|)
expr_stmt|;
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|know
argument_list|(
name|exp
operator|.
name|X_add_symbol
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* fall into SEG_ABSOLUTE */
case|case
name|SEG_ABSOLUTE
case|:
name|get
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
name|use
operator|=
name|get
operator|&
name|unmask
expr_stmt|;
if|if
condition|(
operator|(
name|get
operator|&
name|mask
operator|)
operator|&&
operator|(
name|get
operator|&
name|mask
operator|)
operator|!=
name|mask
condition|)
block|{
comment|/* Leading bits contain both 0s& 1s. */
name|as_warn
argument_list|(
literal|"Value 0x%x truncated to 0x%x."
argument_list|,
name|get
argument_list|,
name|use
argument_list|)
expr_stmt|;
block|}
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|use
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
comment|/* put bytes in right order. */
break|break;
case|case
name|SEG_DIFFERENCE
case|:
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
if|if
condition|(
name|nbytes
operator|==
literal|2
condition|)
block|{
name|struct
name|broken_word
modifier|*
name|x
decl_stmt|;
name|x
operator|=
operator|(
expr|struct
name|broken_word
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|broken_word
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|->
name|next_broken_word
operator|=
name|broken_words
expr_stmt|;
name|broken_words
operator|=
name|x
expr_stmt|;
name|x
operator|->
name|frag
operator|=
name|frag_now
expr_stmt|;
name|x
operator|->
name|word_goes_here
operator|=
name|p
expr_stmt|;
name|x
operator|->
name|dispfrag
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|add
operator|=
name|exp
operator|.
name|X_add_symbol
expr_stmt|;
name|x
operator|->
name|sub
operator|=
name|exp
operator|.
name|X_subtract_symbol
expr_stmt|;
name|x
operator|->
name|addnum
operator|=
name|exp
operator|.
name|X_add_number
expr_stmt|;
name|x
operator|->
name|added
operator|=
literal|0
expr_stmt|;
name|new_broken_words
operator|++
expr_stmt|;
break|break;
block|}
comment|/* Else Fall through into... */
endif|#
directive|endif
default|default:
case|case
name|SEG_UNKNOWN
case|:
ifdef|#
directive|ifdef
name|TC_NS32K
name|fix_new_ns32k
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|nbytes
argument_list|,
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|exp
operator|.
name|X_subtract_symbol
argument_list|,
name|exp
operator|.
name|X_add_number
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|RELOC_32
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|PIC
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|nbytes
argument_list|,
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|exp
operator|.
name|X_subtract_symbol
argument_list|,
name|exp
operator|.
name|X_add_number
argument_list|,
literal|0
argument_list|,
name|RELOC_32
argument_list|,
name|exp
operator|.
name|X_got_symbol
argument_list|)
expr_stmt|;
else|#
directive|else
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|nbytes
argument_list|,
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|exp
operator|.
name|X_subtract_symbol
argument_list|,
name|exp
operator|.
name|X_add_number
argument_list|,
literal|0
argument_list|,
name|RELOC_32
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* TC_NS32K */
break|break;
block|}
comment|/* switch (segment) */
block|}
comment|/* if (!need_pass_2) */
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
block|}
comment|/* while (c == ',') */
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Put terminator back into stream. */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* cons() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			big_cons()  *  * CONStruct more frag(s) of .quads, or .octa etc.  * Makes 0 or more new frags.  * If need_pass_2 == 1, generate no frag.  * This understands only bignums, not expressions. Cons() understands  * expressions.  *  * Constants recognised are '0...'(octal) '0x...'(hex) '...'(decimal).  *  * This creates objects with struct obstack_control objs, destroying  * any context objs held about a partially completed object. Beware!  *  *  * I think it sucks to have 2 different types of integers, with 2  * routines to read them, store them etc.  * It would be nicer to permit bignums in expressions and only  * complain if the result overflowed. However, due to "efficiency"...  */
end_comment

begin_comment
comment|/* worker to do .quad etc statements */
end_comment

begin_comment
comment|/* clobbers input_line_pointer, checks */
end_comment

begin_comment
comment|/* end-of-line. */
end_comment

begin_comment
comment|/* 8=.quad 16=.octa ... */
end_comment

begin_function
name|void
name|big_cons
parameter_list|(
name|nbytes
parameter_list|)
specifier|register
name|int
name|nbytes
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|;
comment|/* input_line_pointer->c. */
specifier|register
name|int
name|radix
decl_stmt|;
specifier|register
name|long
name|length
decl_stmt|;
comment|/* Number of chars in an object. */
specifier|register
name|int
name|digit
decl_stmt|;
comment|/* Value of 1 digit. */
specifier|register
name|int
name|carry
decl_stmt|;
comment|/* For multi-precision arithmetic. */
specifier|register
name|int
name|work
decl_stmt|;
comment|/* For multi-precision arithmetic. */
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* For multi-precision arithmetic. */
specifier|extern
specifier|const
name|char
name|hex_value
index|[]
decl_stmt|;
comment|/* In hex_value.c. */
comment|/* 	 * The following awkward logic is to parse ZERO or more strings, 	 * comma seperated. Recall an expression includes its leading& 	 * trailing blanks. We fake a leading ',' if there is (supposed to 	 * be) a 1st expression, and keep demanding 1 expression for each ','. 	 */
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
comment|/* Skip loop. */
block|}
else|else
block|{
name|c
operator|=
literal|','
expr_stmt|;
comment|/* Do loop. */
operator|--
name|input_line_pointer
expr_stmt|;
block|}
while|while
condition|(
name|c
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
comment|/* C contains 1st non-blank character of what we hope is a number. */
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
block|{
name|c
operator|=
operator|*
operator|++
name|input_line_pointer
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'x'
operator|||
name|c
operator|==
literal|'X'
condition|)
block|{
name|c
operator|=
operator|*
operator|++
name|input_line_pointer
expr_stmt|;
name|radix
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
name|radix
operator|=
literal|8
expr_stmt|;
block|}
block|}
else|else
block|{
name|radix
operator|=
literal|10
expr_stmt|;
block|}
comment|/* 		     * This feature (?) is here to stop people worrying about 		     * mysterious zero constants: which is what they get when 		     * they completely omit digits. 		     */
if|if
condition|(
name|hex_value
index|[
name|c
index|]
operator|>=
name|radix
condition|)
block|{
name|as_bad
argument_list|(
literal|"Missing digits. 0 assumed."
argument_list|)
expr_stmt|;
block|}
name|bignum_high
operator|=
name|bignum_low
operator|-
literal|1
expr_stmt|;
comment|/* Start constant with 0 chars. */
for|for
control|(
init|;
operator|(
name|digit
operator|=
name|hex_value
index|[
name|c
index|]
operator|)
operator|<
name|radix
condition|;
name|c
operator|=
operator|*
operator|++
name|input_line_pointer
control|)
block|{
comment|/* Multiply existing number by radix, then add digit. */
name|carry
operator|=
name|digit
expr_stmt|;
for|for
control|(
name|p
operator|=
name|bignum_low
init|;
name|p
operator|<=
name|bignum_high
condition|;
name|p
operator|++
control|)
block|{
name|work
operator|=
operator|(
operator|*
name|p
operator|&
name|MASK_CHAR
operator|)
operator|*
name|radix
operator|+
name|carry
expr_stmt|;
operator|*
name|p
operator|=
name|work
operator|&
name|MASK_CHAR
expr_stmt|;
name|carry
operator|=
name|work
operator|>>
name|BITS_PER_CHAR
expr_stmt|;
block|}
if|if
condition|(
name|carry
condition|)
block|{
name|grow_bignum
argument_list|()
expr_stmt|;
operator|*
name|bignum_high
operator|=
name|carry
operator|&
name|MASK_CHAR
expr_stmt|;
name|know
argument_list|(
operator|(
name|carry
operator|&
operator|~
name|MASK_CHAR
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|length
operator|=
name|bignum_high
operator|-
name|bignum_low
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|nbytes
condition|)
block|{
name|as_warn
argument_list|(
literal|"Most significant bits truncated in integer constant."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|long
name|leading_zeroes
decl_stmt|;
for|for
control|(
name|leading_zeroes
operator|=
name|nbytes
operator|-
name|length
init|;
name|leading_zeroes
condition|;
name|leading_zeroes
operator|--
control|)
block|{
name|grow_bignum
argument_list|()
expr_stmt|;
operator|*
name|bignum_high
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|need_pass_2
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|bignum_low
argument_list|,
operator|(
name|int
operator|)
name|nbytes
argument_list|)
expr_stmt|;
block|}
comment|/* C contains character after number. */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
comment|/* C contains 1st non-blank character after number. */
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* big_cons() */
end_comment

begin_comment
comment|/* Extend bignum by 1 char. */
end_comment

begin_function
specifier|static
name|void
name|grow_bignum
parameter_list|()
block|{
specifier|register
name|long
name|length
decl_stmt|;
name|bignum_high
operator|++
expr_stmt|;
if|if
condition|(
name|bignum_high
operator|>=
name|bignum_limit
condition|)
block|{
name|length
operator|=
name|bignum_limit
operator|-
name|bignum_low
expr_stmt|;
name|bignum_low
operator|=
name|xrealloc
argument_list|(
name|bignum_low
argument_list|,
name|length
operator|+
name|length
argument_list|)
expr_stmt|;
name|bignum_high
operator|=
name|bignum_low
operator|+
name|length
expr_stmt|;
name|bignum_limit
operator|=
name|bignum_low
operator|+
name|length
operator|+
name|length
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* grow_bignum(); */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			float_cons()  *  * CONStruct some more frag chars of .floats .ffloats etc.  * Makes 0 or more new frags.  * If need_pass_2 == 1, no frags are emitted.  * This understands only floating literals, not expressions. Sorry.  *  * A floating constant is defined by atof_generic(), except it is preceded  * by 0d 0f 0g or 0h. After observing the STRANGE way my BSD AS does its  * reading, I decided to be incompatible. This always tries to give you  * rounded bits to the precision of the pseudo-op. Former AS did premature  * truncatation, restored noisy bits instead of trailing 0s AND gave you  * a choice of 2 flavours of noise according to which of 2 floating-point  * scanners you directed AS to use.  *  * In:	input_line_pointer->whitespace before, or '0' of flonum.  *  */
end_comment

begin_function
name|void
comment|/* JF was static, but can't be if VAX.C is goning to use it */
name|float_cons
parameter_list|(
name|float_type
parameter_list|)
comment|/* Worker to do .float etc statements. */
comment|/* Clobbers input_line-pointer, checks end-of-line. */
specifier|register
name|int
name|float_type
decl_stmt|;
comment|/* 'f':.ffloat ... 'F':.float ... */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* Number of chars in an object. */
specifier|register
name|char
modifier|*
name|err
decl_stmt|;
comment|/* Error from scanning floating literal. */
name|char
name|temp
index|[
name|MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT
index|]
decl_stmt|;
comment|/* 	 * The following awkward logic is to parse ZERO or more strings, 	 * comma seperated. Recall an expression includes its leading& 	 * trailing blanks. We fake a leading ',' if there is (supposed to 	 * be) a 1st expression, and keep demanding 1 expression for each ','. 	 */
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
comment|/* Skip loop. */
operator|++
name|input_line_pointer
expr_stmt|;
comment|/*->past termintor. */
block|}
else|else
block|{
name|c
operator|=
literal|','
expr_stmt|;
comment|/* Do loop. */
block|}
while|while
condition|(
name|c
operator|==
literal|','
condition|)
block|{
comment|/* input_line_pointer->1st char of a flonum (we hope!). */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
comment|/* Skip any 0{letter} that may be present. Don't even check if the 		 * letter is legal. Someone may invent a "z" format and this routine 		 * has no use for such information. Lusers beware: you get 		 * diagnostics if your input is ill-conditioned. 		 */
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|isalpha
argument_list|(
name|input_line_pointer
index|[
literal|1
index|]
argument_list|)
condition|)
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
name|err
operator|=
name|md_atof
argument_list|(
name|float_type
argument_list|,
name|temp
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|length
operator|<=
name|MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|length
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|err
condition|)
block|{
name|as_bad
argument_list|(
literal|"Bad floating literal: %s"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
comment|/* Input_line_pointer->just after end-of-line. */
name|c
operator|=
literal|0
expr_stmt|;
comment|/* Break out of loop. */
block|}
else|else
block|{
if|if
condition|(
operator|!
name|need_pass_2
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|temp
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* C contains 1st non-white character after number. */
comment|/* input_line_pointer->just after terminator (c). */
block|}
block|}
operator|--
name|input_line_pointer
expr_stmt|;
comment|/*->terminator (is not ','). */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* float_cons() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * stringer() Worker to do .ascii etc statements.  Checks end-of-line.  *  * We read 0 or more ',' seperated, double-quoted strings.  *  * Caller should have checked need_pass_2 is FALSE because we don't check it.  */
end_comment

begin_function
name|void
name|stringer
parameter_list|(
name|append_zero
parameter_list|)
name|int
name|append_zero
decl_stmt|;
comment|/* 0: don't append '\0', else 1 */
block|{
name|unsigned
name|int
name|c
decl_stmt|;
comment|/* 	 * The following awkward logic is to parse ZERO or more strings, 	 * comma seperated. Recall a string expression includes spaces 	 * before the opening '\"' and spaces after the closing '\"'. 	 * We fake a leading ',' if there is (supposed to be) 	 * a 1st, expression. We keep demanding expressions for each 	 * ','. 	 */
if|if
condition|(
name|is_it_end_of_statement
argument_list|()
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
comment|/* Skip loop. */
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* Compensate for end of loop. */
block|}
else|else
block|{
name|c
operator|=
literal|','
expr_stmt|;
comment|/* Do loop. */
block|}
while|while
condition|(
name|c
operator|==
literal|','
operator|||
name|c
operator|==
literal|'<'
operator|||
name|c
operator|==
literal|'"'
operator|||
operator|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
case|case
literal|'\"'
case|:
operator|++
name|input_line_pointer
expr_stmt|;
comment|/* ->1st char of string. */
while|while
condition|(
name|is_a_char
argument_list|(
name|c
operator|=
name|next_char_of_string
argument_list|()
argument_list|)
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|append_zero
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|know
argument_list|(
name|input_line_pointer
index|[
operator|-
literal|1
index|]
operator|==
literal|'\"'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|input_line_pointer
operator|++
expr_stmt|;
name|c
operator|=
name|get_single_number
argument_list|()
expr_stmt|;
name|FRAG_APPEND_1_CHAR
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'>'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected<nn>"
argument_list|)
expr_stmt|;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
break|break;
case|case
literal|','
case|:
name|input_line_pointer
operator|++
expr_stmt|;
break|break;
default|default:
name|i
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|FRAG_APPEND_1_CHAR
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch on next char */
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
block|}
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* stringer() */
end_comment

begin_escape
end_escape

begin_comment
comment|/* FIXME-SOMEDAY: I had trouble here on characters with the    high bits set.  We'll probably also have trouble with    multibyte chars, wide chars, etc.  Also be careful about    returning values bigger than 1 byte.  xoxorich. */
end_comment

begin_function
name|unsigned
name|int
name|next_char_of_string
parameter_list|()
block|{
specifier|register
name|unsigned
name|int
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
operator|&
name|CHAR_MASK
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\"'
case|:
name|c
operator|=
name|NOT_A_CHAR
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
switch|switch
condition|(
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
condition|)
block|{
case|case
literal|'b'
case|:
name|c
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|c
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|c
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|c
operator|=
literal|'\t'
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|BACKSLASH_V
case|case
literal|'v'
case|:
name|c
operator|=
literal|'\013'
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'\\'
case|:
case|case
literal|'"'
case|:
break|break;
comment|/* As itself. */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
block|{
name|long
name|number
decl_stmt|;
for|for
control|(
name|number
operator|=
literal|0
init|;
name|isdigit
argument_list|(
name|c
argument_list|)
condition|;
name|c
operator|=
operator|*
name|input_line_pointer
operator|++
control|)
block|{
name|number
operator|=
name|number
operator|*
literal|8
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
name|c
operator|=
name|number
operator|&
literal|0xff
expr_stmt|;
block|}
operator|--
name|input_line_pointer
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
comment|/* To be compatible with BSD 4.2 as: give the luser a linefeed!! */
name|as_warn
argument_list|(
literal|"Unterminated string: Newline inserted."
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|ONLY_STANDARD_ESCAPES
name|as_bad
argument_list|(
literal|"Bad escaped character in string, '?' assumed"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'?'
expr_stmt|;
endif|#
directive|endif
comment|/* ONLY_STANDARD_ESCAPES */
break|break;
block|}
comment|/* switch on escaped char */
break|break;
default|default:
break|break;
block|}
comment|/* switch on char */
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/* next_char_of_string() */
end_comment

begin_escape
end_escape

begin_function
specifier|static
name|segT
name|get_segmented_expression
parameter_list|(
name|expP
parameter_list|)
specifier|register
name|expressionS
modifier|*
name|expP
decl_stmt|;
block|{
specifier|register
name|segT
name|retval
decl_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|expression
argument_list|(
name|expP
argument_list|)
operator|)
operator|==
name|SEG_PASS1
operator|||
name|retval
operator|==
name|SEG_ABSENT
operator|||
name|retval
operator|==
name|SEG_BIG
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected address expression: absolute 0 assumed"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|expP
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|expP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|expP
operator|->
name|X_add_symbol
operator|=
name|expP
operator|->
name|X_subtract_symbol
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
comment|/* SEG_ ABSOLUTE,UNKNOWN,DATA,TEXT,BSS */
block|}
end_function

begin_function
specifier|static
name|segT
name|get_known_segmented_expression
parameter_list|(
name|expP
parameter_list|)
specifier|register
name|expressionS
modifier|*
name|expP
decl_stmt|;
block|{
specifier|register
name|segT
name|retval
decl_stmt|;
specifier|register
name|char
modifier|*
name|name1
decl_stmt|;
specifier|register
name|char
modifier|*
name|name2
decl_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|get_segmented_expression
argument_list|(
name|expP
argument_list|)
operator|)
operator|==
name|SEG_UNKNOWN
condition|)
block|{
name|name1
operator|=
name|expP
operator|->
name|X_add_symbol
condition|?
name|S_GET_NAME
argument_list|(
name|expP
operator|->
name|X_add_symbol
argument_list|)
else|:
literal|""
expr_stmt|;
name|name2
operator|=
name|expP
operator|->
name|X_subtract_symbol
condition|?
name|S_GET_NAME
argument_list|(
name|expP
operator|->
name|X_subtract_symbol
argument_list|)
else|:
literal|""
expr_stmt|;
if|if
condition|(
name|name1
operator|&&
name|name2
condition|)
block|{
name|as_warn
argument_list|(
literal|"Symbols \"%s\" \"%s\" are undefined: absolute 0 assumed."
argument_list|,
name|name1
argument_list|,
name|name2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_warn
argument_list|(
literal|"Symbol \"%s\" undefined: absolute 0 assumed."
argument_list|,
name|name1
condition|?
name|name1
else|:
name|name2
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
name|expP
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|expP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|expP
operator|->
name|X_add_symbol
operator|=
name|expP
operator|->
name|X_subtract_symbol
operator|=
name|NULL
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|MANY_SEGMENTS
name|know
argument_list|(
name|retval
operator|==
name|SEG_ABSOLUTE
operator|||
name|retval
operator|==
name|SEG_DATA
operator|||
name|retval
operator|==
name|SEG_TEXT
operator|||
name|retval
operator|==
name|SEG_BSS
operator|||
name|retval
operator|==
name|SEG_DIFFERENCE
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* get_known_segmented_expression() */
end_comment

begin_comment
comment|/* static */
end_comment

begin_function
name|long
comment|/* JF was static, but can't be if the MD pseudos are to use it */
name|get_absolute_expression
parameter_list|()
block|{
name|expressionS
name|exp
decl_stmt|;
specifier|register
name|segT
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|expression
argument_list|(
operator|&
name|exp
argument_list|)
operator|)
operator|!=
name|SEG_ABSOLUTE
condition|)
block|{
if|if
condition|(
name|s
operator|!=
name|SEG_ABSENT
condition|)
block|{
name|as_bad
argument_list|(
literal|"Bad Absolute Expression, absolute 0 assumed."
argument_list|)
expr_stmt|;
block|}
name|exp
operator|.
name|X_add_number
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|exp
operator|.
name|X_add_number
operator|)
return|;
block|}
end_function

begin_comment
comment|/* get_absolute_expression() */
end_comment

begin_function
name|char
comment|/* return terminator */
name|get_absolute_expression_and_terminator
parameter_list|(
name|val_pointer
parameter_list|)
name|long
modifier|*
name|val_pointer
decl_stmt|;
comment|/* return value of expression */
block|{
operator|*
name|val_pointer
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
return|return
operator|(
operator|*
name|input_line_pointer
operator|++
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			demand_copy_C_string()  *  * Like demand_copy_string, but return NULL if the string contains any '\0's.  * Give a warning if that happens.  */
end_comment

begin_function
name|char
modifier|*
name|demand_copy_C_string
parameter_list|(
name|len_pointer
parameter_list|)
name|int
modifier|*
name|len_pointer
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|demand_copy_string
argument_list|(
name|len_pointer
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|register
name|int
name|len
decl_stmt|;
for|for
control|(
name|len
operator|=
operator|*
name|len_pointer
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|--
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|0
condition|)
block|{
name|s
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
operator|*
name|len_pointer
operator|=
literal|0
expr_stmt|;
name|as_bad
argument_list|(
literal|"This string may not contain \'\\0\'"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			demand_copy_string()  *  * Demand string, but return a safe (=private) copy of the string.  * Return NULL if we can't read a string here.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|demand_copy_string
parameter_list|(
name|lenP
parameter_list|)
name|int
modifier|*
name|lenP
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|retval
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\"'
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* Skip opening quote. */
while|while
condition|(
name|is_a_char
argument_list|(
name|c
operator|=
name|next_char_of_string
argument_list|()
argument_list|)
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|notes
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
comment|/* JF this next line is so demand_copy_C_string will return a null 		   termanated string. */
name|obstack_1grow
argument_list|(
operator|&
name|notes
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|retval
operator|=
name|obstack_finish
argument_list|(
operator|&
name|notes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_warn
argument_list|(
literal|"Missing string"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|NULL
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
operator|*
name|lenP
operator|=
name|len
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* demand_copy_string() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *		is_it_end_of_statement()  *  * In:	Input_line_pointer->next character.  *  * Do:	Skip input_line_pointer over all whitespace.  *  * Out:	1 if input_line_pointer->end-of-line.  */
end_comment

begin_function
name|int
name|is_it_end_of_statement
parameter_list|()
block|{
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
return|return
operator|(
name|is_end_of_line
index|[
operator|*
name|input_line_pointer
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* is_it_end_of_statement() */
end_comment

begin_function
name|void
name|equals
parameter_list|(
name|sym_name
parameter_list|)
name|char
modifier|*
name|sym_name
decl_stmt|;
block|{
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* symbol we are working with */
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'='
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|input_line_pointer
operator|==
literal|' '
operator|||
operator|*
name|input_line_pointer
operator|==
literal|'\t'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
name|sym_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|sym_name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Turn '. = mumble' into a .org mumble */
specifier|register
name|segT
name|segment
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|segment
operator|=
name|get_known_segmented_expression
argument_list|(
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|need_pass_2
condition|)
block|{
if|if
condition|(
name|segment
operator|!=
name|now_seg
operator|&&
name|segment
operator|!=
name|SEG_ABSOLUTE
condition|)
name|as_warn
argument_list|(
literal|"Illegal segment \"%s\". Segment \"%s\" assumed."
argument_list|,
name|segment_name
argument_list|(
name|segment
argument_list|)
argument_list|,
name|segment_name
argument_list|(
name|now_seg
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_var
argument_list|(
name|rs_org
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|exp
operator|.
name|X_add_number
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if (ok to make frag) */
block|}
else|else
block|{
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|sym_name
argument_list|)
expr_stmt|;
name|pseudo_set
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* equals() */
end_comment

begin_comment
comment|/* .include -- include a file at this point. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|s_include
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|newbuf
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|try
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|filename
operator|=
name|demand_copy_string
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
name|path
operator|=
name|xmalloc
argument_list|(
name|i
operator|+
name|include_dir_maxlen
operator|+
literal|5
comment|/* slop */
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|include_dir_count
condition|;
name|i
operator|++
control|)
block|{
name|strcpy
argument_list|(
name|path
argument_list|,
name|include_dirs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|!=
operator|(
name|try
operator|=
name|fopen
argument_list|(
name|path
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
name|fclose
argument_list|(
name|try
argument_list|)
expr_stmt|;
goto|goto
name|gotit
goto|;
block|}
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|path
operator|=
name|filename
expr_stmt|;
name|gotit
label|:
comment|/* malloc Storage leak when file is found on path.  FIXME-SOMEDAY. */
name|newbuf
operator|=
name|input_scrub_include_file
argument_list|(
name|path
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
name|buffer_limit
operator|=
name|input_scrub_next_buffer
argument_list|(
operator|&
name|input_line_pointer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_include() */
end_comment

begin_function
name|void
name|add_include_dir
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|include_dir_count
operator|==
literal|0
condition|)
block|{
name|include_dirs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|include_dirs
argument_list|)
argument_list|)
expr_stmt|;
name|include_dirs
index|[
literal|0
index|]
operator|=
literal|"."
expr_stmt|;
comment|/* Current dir */
name|include_dir_count
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|include_dir_count
operator|++
expr_stmt|;
name|include_dirs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|include_dirs
argument_list|,
name|include_dir_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|include_dirs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|include_dirs
index|[
name|include_dir_count
operator|-
literal|1
index|]
operator|=
name|path
expr_stmt|;
comment|/* New one */
name|i
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|include_dir_maxlen
condition|)
name|include_dir_maxlen
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* add_include_dir() */
end_comment

begin_function
name|void
name|s_ignore
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|*
name|input_line_pointer
index|]
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* s_ignore() */
end_comment

begin_comment
comment|/*  * Local Variables:  * comment-column: 0  * fill-column: 131  * End:  */
end_comment

begin_comment
comment|/* end of read.c */
end_comment

end_unit

