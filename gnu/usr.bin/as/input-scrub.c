begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* input_scrub.c - Break up input buffers into whole numbers of lines.    Copyright (C) 1987, 1990, 1991, 1992 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* Need this to make errno declaration right */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"input-file.h"
end_include

begin_comment
comment|/*  * O/S independent module to supply buffers of sanitised source code  * to rest of assembler. We get sanitized input data of arbitrary length.  * We break these buffers on line boundaries, recombine pieces that  * were broken across buffers, and return a buffer of full lines to  * the caller.  * The last partial line begins the next buffer we build and return to caller.  * The buffer returned to caller is preceeded by BEFORE_STRING and followed  * by AFTER_STRING, as sentinels. The last character before AFTER_STRING  * is a newline.  * Also looks after line numbers, for e.g. error messages.  */
end_comment

begin_comment
comment|/*  * We don't care how filthy our buffers are, but our callers assume  * that the following sanitation has already been done.  *  * No comments, reduce a comment to a space.  * Reduce a tab to a space unless it is 1st char of line.  * All multiple tabs and spaces collapsed into 1 char. Tab only  *   legal if 1st char of line.  * # line file statements converted to .line x;.file y; statements.  * Escaped newlines at end of line: remove them but add as many newlines  *   to end of statement as you removed in the middle, to synch line numbers.  */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|BEFORE_STRING
value|("\n")
end_define

begin_define
define|#
directive|define
name|AFTER_STRING
value|("\0")
end_define

begin_comment
comment|/* memcpy of 0 chars might choke. */
end_comment

begin_define
define|#
directive|define
name|BEFORE_SIZE
value|(1)
end_define

begin_define
define|#
directive|define
name|AFTER_SIZE
value|(1)
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|buffer_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*->1st char of full buffer area. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|partial_where
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*->after last full line in buffer. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|partial_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*>=0. Number of chars in partial line in buffer. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|save_source
index|[
name|AFTER_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Because we need AFTER_STRING just after last */
end_comment

begin_comment
comment|/* full line, it clobbers 1st part of partial */
end_comment

begin_comment
comment|/* line. So we preserve 1st part of partial */
end_comment

begin_comment
comment|/* line here. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|buffer_length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* What is the largest size buffer that */
end_comment

begin_comment
comment|/* input_file_give_next_buffer() could */
end_comment

begin_comment
comment|/* return to us? */
end_comment

begin_comment
comment|/* Saved information about the file that .include'd this one.  When we hit EOF,    we automatically pop to that file. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|next_saved_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We can have more than one source file open at once, though the info for all    but the latest one are saved off in a struct input_save.  These files remain    open, so we are limited by the number of open files allowed by the    underlying OS. We may also sequentially read more than one source file in an    assembly. */
end_comment

begin_comment
comment|/* We must track the physical file and line number for error messages. We also    track a "logical" file and line number corresponding to (C?)  compiler    source line numbers.  Whenever we open a file we must fill in    physical_input_file. So if it is NULL we have not opened any files yet. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|physical_input_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|logical_input_file
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|unsigned
name|int
name|line_numberT
typedef|;
end_typedef

begin_comment
comment|/* 1-origin line number in a source file. */
end_comment

begin_comment
comment|/* A line ends in '\n' or eof. */
end_comment

begin_decl_stmt
specifier|static
name|line_numberT
name|physical_input_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|logical_input_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Struct used to save the state of the input handler during include files */
end_comment

begin_struct
struct|struct
name|input_save
block|{
name|char
modifier|*
name|buffer_start
decl_stmt|;
name|char
modifier|*
name|partial_where
decl_stmt|;
name|int
name|partial_size
decl_stmt|;
name|char
name|save_source
index|[
name|AFTER_SIZE
index|]
decl_stmt|;
name|unsigned
name|int
name|buffer_length
decl_stmt|;
name|char
modifier|*
name|physical_input_file
decl_stmt|;
name|char
modifier|*
name|logical_input_file
decl_stmt|;
name|line_numberT
name|physical_input_line
decl_stmt|;
name|int
name|logical_input_line
decl_stmt|;
name|char
modifier|*
name|next_saved_file
decl_stmt|;
comment|/* Chain of input_saves */
name|char
modifier|*
name|input_file_save
decl_stmt|;
comment|/* Saved state of input routines */
name|char
modifier|*
name|saved_position
decl_stmt|;
comment|/* Caller's saved position in buf */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
modifier|*
name|input_scrub_push
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|saved_position
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|input_scrub_pop
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|as_1_char
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
name|c
operator|,
name|FILE
operator|*
name|stream
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Push the state of input reading and scrubbing so that we can #include.    The return value is a 'void *' (fudged for old compilers) to a save    area, which can be restored by passing it to input_scrub_pop(). */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|input_scrub_push
parameter_list|(
name|saved_position
parameter_list|)
name|char
modifier|*
name|saved_position
decl_stmt|;
block|{
specifier|register
name|struct
name|input_save
modifier|*
name|saved
decl_stmt|;
name|saved
operator|=
operator|(
expr|struct
name|input_save
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|saved
argument_list|)
expr_stmt|;
name|saved
operator|->
name|saved_position
operator|=
name|saved_position
expr_stmt|;
name|saved
operator|->
name|buffer_start
operator|=
name|buffer_start
expr_stmt|;
name|saved
operator|->
name|partial_where
operator|=
name|partial_where
expr_stmt|;
name|saved
operator|->
name|partial_size
operator|=
name|partial_size
expr_stmt|;
name|saved
operator|->
name|buffer_length
operator|=
name|buffer_length
expr_stmt|;
name|saved
operator|->
name|physical_input_file
operator|=
name|physical_input_file
expr_stmt|;
name|saved
operator|->
name|logical_input_file
operator|=
name|logical_input_file
expr_stmt|;
name|saved
operator|->
name|physical_input_line
operator|=
name|physical_input_line
expr_stmt|;
name|saved
operator|->
name|logical_input_line
operator|=
name|logical_input_line
expr_stmt|;
name|memcpy
argument_list|(
name|saved
operator|->
name|save_source
argument_list|,
name|save_source
argument_list|,
sizeof|sizeof
argument_list|(
name|save_source
argument_list|)
argument_list|)
expr_stmt|;
name|saved
operator|->
name|next_saved_file
operator|=
name|next_saved_file
expr_stmt|;
name|saved
operator|->
name|input_file_save
operator|=
name|input_file_push
argument_list|()
expr_stmt|;
name|input_file_begin
argument_list|()
expr_stmt|;
comment|/* Reinitialize! */
name|logical_input_line
operator|=
operator|-
literal|1
expr_stmt|;
name|logical_input_file
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|buffer_length
operator|=
name|input_file_buffer_size
argument_list|()
expr_stmt|;
name|buffer_start
operator|=
name|xmalloc
argument_list|(
operator|(
name|BEFORE_SIZE
operator|+
name|buffer_length
operator|+
name|buffer_length
operator|+
name|AFTER_SIZE
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buffer_start
argument_list|,
name|BEFORE_STRING
argument_list|,
operator|(
name|int
operator|)
name|BEFORE_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|saved
operator|)
return|;
block|}
end_function

begin_comment
comment|/* input_scrub_push() */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|input_scrub_pop
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|struct
name|input_save
modifier|*
name|saved
decl_stmt|;
name|char
modifier|*
name|saved_position
decl_stmt|;
name|input_scrub_end
argument_list|()
expr_stmt|;
comment|/* Finish off old buffer */
name|saved
operator|=
operator|(
expr|struct
name|input_save
operator|*
operator|)
name|arg
expr_stmt|;
name|input_file_pop
argument_list|(
name|saved
operator|->
name|input_file_save
argument_list|)
expr_stmt|;
name|saved_position
operator|=
name|saved
operator|->
name|saved_position
expr_stmt|;
name|buffer_start
operator|=
name|saved
operator|->
name|buffer_start
expr_stmt|;
name|buffer_length
operator|=
name|saved
operator|->
name|buffer_length
expr_stmt|;
name|physical_input_file
operator|=
name|saved
operator|->
name|physical_input_file
expr_stmt|;
name|logical_input_file
operator|=
name|saved
operator|->
name|logical_input_file
expr_stmt|;
name|physical_input_line
operator|=
name|saved
operator|->
name|physical_input_line
expr_stmt|;
name|logical_input_line
operator|=
name|saved
operator|->
name|logical_input_line
expr_stmt|;
name|partial_where
operator|=
name|saved
operator|->
name|partial_where
expr_stmt|;
name|partial_size
operator|=
name|saved
operator|->
name|partial_size
expr_stmt|;
name|next_saved_file
operator|=
name|saved
operator|->
name|next_saved_file
expr_stmt|;
name|memcpy
argument_list|(
name|save_source
argument_list|,
name|saved
operator|->
name|save_source
argument_list|,
sizeof|sizeof
argument_list|(
name|save_source
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
name|saved_position
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|input_scrub_begin
parameter_list|()
block|{
name|know
argument_list|(
name|strlen
argument_list|(
name|BEFORE_STRING
argument_list|)
operator|==
name|BEFORE_SIZE
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|strlen
argument_list|(
name|AFTER_STRING
argument_list|)
operator|==
name|AFTER_SIZE
operator|||
operator|(
name|AFTER_STRING
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|AFTER_SIZE
operator|==
literal|1
operator|)
argument_list|)
expr_stmt|;
name|input_file_begin
argument_list|()
expr_stmt|;
name|buffer_length
operator|=
name|input_file_buffer_size
argument_list|()
expr_stmt|;
name|buffer_start
operator|=
name|xmalloc
argument_list|(
operator|(
name|BEFORE_SIZE
operator|+
name|buffer_length
operator|+
name|buffer_length
operator|+
name|AFTER_SIZE
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buffer_start
argument_list|,
name|BEFORE_STRING
argument_list|,
operator|(
name|int
operator|)
name|BEFORE_SIZE
argument_list|)
expr_stmt|;
comment|/* Line number things. */
name|logical_input_line
operator|=
operator|-
literal|1
expr_stmt|;
name|logical_input_file
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|physical_input_file
operator|=
name|NULL
expr_stmt|;
comment|/* No file read yet. */
name|next_saved_file
operator|=
name|NULL
expr_stmt|;
comment|/* At EOF, don't pop to any other file */
name|do_scrub_begin
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|input_scrub_end
parameter_list|()
block|{
if|if
condition|(
name|buffer_start
condition|)
block|{
name|free
argument_list|(
name|buffer_start
argument_list|)
expr_stmt|;
name|buffer_start
operator|=
literal|0
expr_stmt|;
name|input_file_end
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Start reading input from a new file. */
end_comment

begin_function
name|char
modifier|*
comment|/* Return start of caller's part of buffer. */
name|input_scrub_new_file
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|input_file_open
argument_list|(
name|filename
argument_list|,
operator|!
name|flagseen
index|[
literal|'f'
index|]
argument_list|)
expr_stmt|;
name|physical_input_file
operator|=
name|filename
index|[
literal|0
index|]
condition|?
name|filename
else|:
literal|"{standard input}"
expr_stmt|;
name|physical_input_line
operator|=
literal|0
expr_stmt|;
name|partial_size
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|buffer_start
operator|+
name|BEFORE_SIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Include a file from the current file.  Save our state, cause it to    be restored on EOF, and begin handling a new file.  Same result as    input_scrub_new_file. */
end_comment

begin_function
name|char
modifier|*
name|input_scrub_include_file
parameter_list|(
name|filename
parameter_list|,
name|position
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|position
decl_stmt|;
block|{
name|next_saved_file
operator|=
name|input_scrub_push
argument_list|(
name|position
argument_list|)
expr_stmt|;
return|return
name|input_scrub_new_file
argument_list|(
name|filename
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|input_scrub_close
parameter_list|()
block|{
name|input_file_close
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|input_scrub_next_buffer
parameter_list|(
name|bufp
parameter_list|)
name|char
modifier|*
modifier|*
name|bufp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|limit
decl_stmt|;
comment|/*->just after last char of buffer. */
operator|*
name|bufp
operator|=
name|buffer_start
operator|+
name|BEFORE_SIZE
expr_stmt|;
if|if
condition|(
name|partial_size
condition|)
block|{
name|memcpy
argument_list|(
name|buffer_start
operator|+
name|BEFORE_SIZE
argument_list|,
name|partial_where
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|partial_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buffer_start
operator|+
name|BEFORE_SIZE
argument_list|,
name|save_source
argument_list|,
name|AFTER_SIZE
argument_list|)
expr_stmt|;
block|}
name|limit
operator|=
name|input_file_give_next_buffer
argument_list|(
name|buffer_start
operator|+
name|BEFORE_SIZE
operator|+
name|partial_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Find last newline. */
for|for
control|(
name|p
operator|=
name|limit
init|;
operator|*
operator|--
name|p
operator|!=
literal|'\n'
condition|;
control|)
empty_stmt|;
empty_stmt|;
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|<=
name|buffer_start
operator|+
name|BEFORE_SIZE
condition|)
block|{
name|as_fatal
argument_list|(
literal|"Source line too long. Please change file %s then rebuild assembler."
argument_list|,
name|__FILE__
argument_list|)
expr_stmt|;
block|}
name|partial_where
operator|=
name|p
expr_stmt|;
name|partial_size
operator|=
name|limit
operator|-
name|p
expr_stmt|;
name|memcpy
argument_list|(
name|save_source
argument_list|,
name|partial_where
argument_list|,
operator|(
name|int
operator|)
name|AFTER_SIZE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|partial_where
argument_list|,
name|AFTER_STRING
argument_list|,
operator|(
name|int
operator|)
name|AFTER_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|partial_where
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|partial_size
operator|>
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"Partial line at end of file ignored"
argument_list|)
expr_stmt|;
block|}
comment|/* If we should pop to another file at EOF, do it. */
if|if
condition|(
name|next_saved_file
condition|)
block|{
operator|*
name|bufp
operator|=
name|input_scrub_pop
argument_list|(
name|next_saved_file
argument_list|)
expr_stmt|;
comment|/* Pop state */
comment|/* partial_where is now correct to return, since we popped it. */
block|}
block|}
return|return
operator|(
name|partial_where
operator|)
return|;
block|}
end_function

begin_comment
comment|/* input_scrub_next_buffer() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * The remaining part of this file deals with line numbers, error  * messages and so on.  */
end_comment

begin_function
name|int
name|seen_at_least_1_file
parameter_list|()
comment|/* TRUE if we opened any file. */
block|{
return|return
operator|(
name|physical_input_file
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|bump_line_counters
parameter_list|()
block|{
operator|++
name|physical_input_line
expr_stmt|;
if|if
condition|(
name|logical_input_line
operator|>=
literal|0
condition|)
operator|++
name|logical_input_line
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			new_logical_line()  *  * Tells us what the new logical line number and file are.  * If the line_number is -1, we don't change the current logical line  * number.  If it is -2, we decrement the logical line number (this is  * to support the .appfile pseudo-op inserted into the stream by  * do_scrub_next_char).  * If the fname is NULL, we don't change the current logical file name.  */
end_comment

begin_function
name|void
name|new_logical_line
parameter_list|(
name|fname
parameter_list|,
name|line_number
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* DON'T destroy it! We point to it! */
name|int
name|line_number
decl_stmt|;
block|{
if|if
condition|(
name|fname
condition|)
block|{
name|logical_input_file
operator|=
name|fname
expr_stmt|;
block|}
comment|/* if we have a file name */
if|if
condition|(
name|line_number
operator|>=
literal|0
condition|)
name|logical_input_line
operator|=
name|line_number
expr_stmt|;
elseif|else
if|if
condition|(
name|line_number
operator|==
operator|-
literal|2
operator|&&
name|logical_input_line
operator|>
literal|0
condition|)
operator|--
name|logical_input_line
expr_stmt|;
block|}
end_function

begin_comment
comment|/* new_logical_line() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			a s _ w h e r e ()  *  * Return the current file name and line number.  * namep should be char * const *, but there are compilers which screw  * up declarations like that, and it's easier to avoid it.  */
end_comment

begin_function
name|void
name|as_where
parameter_list|(
name|namep
parameter_list|,
name|linep
parameter_list|)
name|char
modifier|*
modifier|*
name|namep
decl_stmt|;
name|unsigned
name|int
modifier|*
name|linep
decl_stmt|;
block|{
if|if
condition|(
name|logical_input_file
operator|!=
name|NULL
operator|&&
operator|(
name|linep
operator|==
name|NULL
operator|||
name|logical_input_line
operator|>=
literal|0
operator|)
condition|)
block|{
operator|*
name|namep
operator|=
name|logical_input_file
expr_stmt|;
if|if
condition|(
name|linep
operator|!=
name|NULL
condition|)
operator|*
name|linep
operator|=
name|logical_input_line
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|physical_input_file
operator|!=
name|NULL
condition|)
block|{
operator|*
name|namep
operator|=
name|physical_input_file
expr_stmt|;
if|if
condition|(
name|linep
operator|!=
name|NULL
condition|)
operator|*
name|linep
operator|=
name|physical_input_line
expr_stmt|;
block|}
else|else
block|{
operator|*
name|namep
operator|=
operator|(
name|char
operator|*
operator|)
literal|"*unknown*"
expr_stmt|;
if|if
condition|(
name|linep
operator|!=
name|NULL
condition|)
operator|*
name|linep
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* as_where() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			a s _ h o w m u c h ()  *  * Output to given stream how much of line we have scanned so far.  * Assumes we have scanned up to and including input_line_pointer.  * No free '\n' at end of line.  */
end_comment

begin_function
name|void
name|as_howmuch
parameter_list|(
name|stream
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
comment|/* Opened for write please. */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Scan input line. */
comment|/* register char c; JF unused */
for|for
control|(
name|p
operator|=
name|input_line_pointer
operator|-
literal|1
init|;
operator|*
name|p
operator|!=
literal|'\n'
condition|;
operator|--
name|p
control|)
block|{     }
operator|++
name|p
expr_stmt|;
comment|/* p->1st char of line. */
for|for
control|(
init|;
name|p
operator|<=
name|input_line_pointer
condition|;
name|p
operator|++
control|)
block|{
comment|/* Assume ASCII. EBCDIC& other micro-computer char sets ignored. */
comment|/* c = *p& 0xFF; JF unused */
name|as_1_char
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|as_1_char
parameter_list|(
name|c
parameter_list|,
name|stream
parameter_list|)
name|unsigned
name|int
name|c
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|>
literal|127
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'%'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|c
operator|-=
literal|128
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|32
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'^'
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|c
operator|+=
literal|'@'
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|putc
argument_list|(
name|c
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of input_scrub.c */
end_comment

end_unit

