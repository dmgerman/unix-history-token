begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* symbols.c -symbol table-     Copyright (C) 1987, 1990, 1991, 1992 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* For "symbols.h" */
end_comment

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|new_broken_words
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|sy_hash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbol-name => struct symbol pointer */
end_comment

begin_comment
comment|/* Below are commented in "symbols.h". */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|local_bss_counter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|symbol_rootP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|symbol_lastP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
name|abs_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|dot_text_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|dot_data_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|dot_bss_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|obstack
name|notes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Un*x idea of local labels. They are made by "n:" where n  * is any decimal digit. Refer to them with  *  "nb" for previous (backward) n:  *  or "nf" for next (forward) n:.  *  * Like Un*x AS, we have one set of local label counters for entire assembly,  * not one set per (sub)segment like in most assemblers. This implies that  * one can refer to a label in another segment, and indeed some crufty  * compilers have done just that.  *  * I document the symbol names here to save duplicating words elsewhere.  * The mth occurence of label n: is turned into the symbol "Ln^Am" where  * n is a digit and m is a decimal number. "L" makes it a label discarded  * unless debugging and "^A"('\1') ensures no ordinary symbol SHOULD get the  * same name as a local label symbol. The first "4:" is "L4^A1" - the m  * numbers begin at 1.  */
end_comment

begin_typedef
typedef|typedef
name|short
name|unsigned
name|int
name|local_label_countT
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|local_label_countT
name|local_label_counter
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
comment|/* Returned to caller, then copied. */
name|char
name|symbol_name_build
index|[
literal|12
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used for created names ("4f") */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LOCAL_LABELS_DOLLAR
end_ifdef

begin_decl_stmt
name|int
name|local_label_defined
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
name|void
name|symbol_begin
parameter_list|()
block|{
name|symbol_lastP
operator|=
name|NULL
expr_stmt|;
name|symbol_rootP
operator|=
name|NULL
expr_stmt|;
comment|/* In case we have 0 symbols (!!) */
name|sy_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|abs_symbol
operator|)
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|abs_symbol
argument_list|)
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
operator|&
name|abs_symbol
argument_list|,
name|SEG_ABSOLUTE
argument_list|)
expr_stmt|;
comment|/* Can't initialise a union. Sigh. */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|local_label_counter
operator|)
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|local_label_counter
argument_list|)
argument_list|)
expr_stmt|;
name|local_bss_counter
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			local_label_name()  *  * Caller must copy returned name: we re-use the area for the next name.  */
end_comment

begin_function
name|char
modifier|*
comment|/* Return local label name. */
name|local_label_name
parameter_list|(
name|n
parameter_list|,
name|augend
parameter_list|)
specifier|register
name|int
name|n
decl_stmt|;
comment|/* we just saw "n:", "nf" or "nb" : n a digit */
specifier|register
name|int
name|augend
decl_stmt|;
comment|/* 0 for nb, 1 for n:, nf */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
name|char
name|symbol_name_temporary
index|[
literal|10
index|]
decl_stmt|;
comment|/* build up a number, BACKWARDS */
name|know
argument_list|(
name|n
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|augend
operator|==
literal|0
operator|||
name|augend
operator|==
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|symbol_name_build
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|1
expr_stmt|;
comment|/* ^A */
operator|*
name|p
operator|++
operator|=
literal|'L'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|n
operator|+
literal|'0'
expr_stmt|;
comment|/* Make into ASCII */
name|n
operator|=
name|local_label_counter
index|[
name|n
index|]
operator|+
name|augend
expr_stmt|;
comment|/* version number of this local label */
comment|/* 	 * Next code just does sprintf( {}, "%d", n); 	 * It is more elegant to do the next part recursively, but a procedure 	 * call for each digit emitted is considered too costly. 	 */
name|q
operator|=
name|symbol_name_temporary
expr_stmt|;
for|for
control|(
operator|*
name|q
operator|++
operator|=
literal|0
init|;
name|n
condition|;
name|q
operator|++
control|)
comment|/* emits NOTHING if n starts as 0 */
block|{
name|know
argument_list|(
name|n
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* We expect n> 0 always */
operator|*
name|q
operator|=
name|n
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|n
operator|/=
literal|10
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
operator|*
operator|--
name|q
operator|)
operator|!=
literal|'\0'
condition|)
empty_stmt|;
empty_stmt|;
comment|/* The label, as a '\0' ended string, starts at symbol_name_build. */
return|return
operator|(
name|symbol_name_build
operator|)
return|;
block|}
end_function

begin_comment
comment|/* local_label_name() */
end_comment

begin_function
name|void
name|local_colon
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
comment|/* just saw "n:" */
block|{
name|local_label_counter
index|[
name|n
index|]
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCAL_LABELS_DOLLAR
name|local_label_defined
index|[
name|n
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|colon
argument_list|(
name|local_label_name
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			symbol_new()  *  * Return a pointer to a new symbol.  * Die if we can't make a new symbol.  * Fill in the symbol's values.  * Add symbol to end of symbol chain.  *  *  * Please always call this to create a new symbol.  *  * Changes since 1985: Symbol names may not contain '\0'. Sigh.  * 2nd argument is now a SEG rather than a TYPE.  The mapping between  * segments and types is mostly encapsulated herein (actually, we inherit it  * from macros in struc-symbol.h).  */
end_comment

begin_function
name|symbolS
modifier|*
name|symbol_new
parameter_list|(
name|name
parameter_list|,
name|segment
parameter_list|,
name|value
parameter_list|,
name|frag
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* It is copied, the caller can destroy/modify */
name|segT
name|segment
decl_stmt|;
comment|/* Segment identifier (SEG_<something>) */
name|long
name|value
decl_stmt|;
comment|/* Symbol value */
name|fragS
modifier|*
name|frag
decl_stmt|;
comment|/* Associated fragment */
block|{
name|unsigned
name|int
name|name_length
decl_stmt|;
name|char
modifier|*
name|preserved_copy_of_name
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|name_length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* +1 for \0 */
name|obstack_grow
argument_list|(
operator|&
name|notes
argument_list|,
name|name
argument_list|,
name|name_length
argument_list|)
expr_stmt|;
name|preserved_copy_of_name
operator|=
name|obstack_finish
argument_list|(
operator|&
name|notes
argument_list|)
expr_stmt|;
name|symbolP
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
name|symbolS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* symbol must be born in some fixed state.  This seems as good as any. */
name|memset
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|symbolS
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STRIP_UNDERSCORE
name|S_SET_NAME
argument_list|(
name|symbolP
argument_list|,
operator|(
operator|*
name|preserved_copy_of_name
operator|==
literal|'_'
condition|?
name|preserved_copy_of_name
operator|+
literal|1
else|:
name|preserved_copy_of_name
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* STRIP_UNDERSCORE */
name|S_SET_NAME
argument_list|(
name|symbolP
argument_list|,
name|preserved_copy_of_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* STRIP_UNDERSCORE */
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|segment
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/*	symbol_clear_list_pointers(symbolP); uneeded if symbol is born zeroed. */
name|symbolP
operator|->
name|sy_frag
operator|=
name|frag
expr_stmt|;
comment|/* krm: uneeded if symbol is born zeroed. 	   symbolP->sy_forward = NULL; */
comment|/* JF */
name|symbolP
operator|->
name|sy_number
operator|=
operator|~
literal|0
expr_stmt|;
name|symbolP
operator|->
name|sy_name_offset
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* 	 * Link to end of symbol chain. 	 */
name|symbol_append
argument_list|(
name|symbolP
argument_list|,
name|symbol_lastP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|obj_symbol_new_hook
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/*	verify_symbol_chain(symbol_rootP, symbol_lastP); */
endif|#
directive|endif
comment|/* DEBUG */
return|return
operator|(
name|symbolP
operator|)
return|;
block|}
end_function

begin_comment
comment|/* symbol_new() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			colon()  *  * We have just seen "<name>:".  * Creates a struct symbol unless it already exists.  *  * Gripes if we are redefining a symbol incompatibly (and ignores it).  *  */
end_comment

begin_function
name|void
name|colon
parameter_list|(
name|sym_name
parameter_list|)
comment|/* just seen "x:" - rattle symbols& frags */
specifier|register
name|char
modifier|*
name|sym_name
decl_stmt|;
comment|/* symbol name, as a cannonical string */
comment|/* We copy this string: OK to alter later. */
block|{
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* symbol we are working with */
ifdef|#
directive|ifdef
name|LOCAL_LABELS_DOLLAR
comment|/* Sun local labels go out of scope whenever a non-local symbol is defined.  */
if|if
condition|(
operator|*
name|sym_name
operator|!=
literal|'L'
condition|)
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|local_label_defined
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|local_label_defined
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
if|if
condition|(
name|new_broken_words
condition|)
block|{
name|struct
name|broken_word
modifier|*
name|a
decl_stmt|;
name|int
name|possible_bytes
decl_stmt|;
name|fragS
modifier|*
name|frag_tmp
decl_stmt|;
name|char
modifier|*
name|frag_opcode
decl_stmt|;
extern|extern const md_short_jump_size;
extern|extern const md_long_jump_size;
name|possible_bytes
operator|=
name|md_short_jump_size
operator|+
name|new_broken_words
operator|*
name|md_long_jump_size
expr_stmt|;
name|frag_tmp
operator|=
name|frag_now
expr_stmt|;
name|frag_opcode
operator|=
name|frag_var
argument_list|(
name|rs_broken_word
argument_list|,
name|possible_bytes
argument_list|,
name|possible_bytes
argument_list|,
operator|(
name|relax_substateT
operator|)
literal|0
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
name|broken_words
argument_list|,
literal|0L
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* We want to store the pointer to where to insert the jump table in the 		   fr_opcode of the rs_broken_word frag.  This requires a little hackery */
while|while
condition|(
name|frag_tmp
operator|&&
operator|(
name|frag_tmp
operator|->
name|fr_type
operator|!=
name|rs_broken_word
operator|||
name|frag_tmp
operator|->
name|fr_opcode
operator|)
condition|)
name|frag_tmp
operator|=
name|frag_tmp
operator|->
name|fr_next
expr_stmt|;
name|know
argument_list|(
name|frag_tmp
argument_list|)
expr_stmt|;
name|frag_tmp
operator|->
name|fr_opcode
operator|=
name|frag_opcode
expr_stmt|;
name|new_broken_words
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|a
operator|=
name|broken_words
init|;
name|a
operator|&&
name|a
operator|->
name|dispfrag
operator|==
literal|0
condition|;
name|a
operator|=
name|a
operator|->
name|next_broken_word
control|)
name|a
operator|->
name|dispfrag
operator|=
name|frag_tmp
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|sym_name
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|OBJ_VMS
comment|/* 		 *	If the new symbol is .comm AND it has a size of zero, 		 *	we ignore it (i.e. the old symbol overrides it) 		 */
if|if
condition|(
operator|(
name|SEGMENT_TO_SYMBOL_TYPE
argument_list|(
operator|(
name|int
operator|)
name|now_seg
argument_list|)
operator|==
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|)
operator|&&
operator|(
operator|(
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
operator|==
literal|0
operator|)
condition|)
return|return;
comment|/* 		 *	If the old symbol is .comm and it has a size of zero, 		 *	we override it with the new symbol value. 		 */
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
operator|&&
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|symbolP
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
name|S_GET_OTHER
argument_list|(
name|symbolP
argument_list|)
operator|=
name|const_flag
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_symbol
operator|.
name|n_type
operator||=
name|SEGMENT_TO_SYMBOL_TYPE
argument_list|(
operator|(
name|int
operator|)
name|now_seg
argument_list|)
expr_stmt|;
comment|/* keep N_EXT bit */
return|return;
block|}
endif|#
directive|endif
comment|/* OBJ_VMS */
comment|/* 		 *	Now check for undefined symbols 		 */
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
condition|)
block|{
name|symbolP
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_VMS
name|S_GET_OTHER
argument_list|(
name|symbolP
argument_list|)
operator|=
name|const_flag
expr_stmt|;
endif|#
directive|endif
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|now_seg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|N_UNDF
name|know
argument_list|(
name|N_UNDF
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* if we have one, it better be zero. */
block|}
else|else
block|{
comment|/* 				 *	There are still several cases to check: 				 *		A .comm/.lcomm symbol being redefined as 				 *			initialized data is OK 				 *		A .comm/.lcomm symbol being redefined with 				 *			a larger size is also OK 				 * 				 * This only used to be allowed on VMS gas, but Sun cc 				 * on the sparc also depends on it. 				 */
comment|/*			  char New_Type = SEGMENT_TO_SYMBOL_TYPE((int) now_seg); */
if|if
condition|(
operator|(
operator|(
operator|!
name|S_IS_DEBUG
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
name|S_IS_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
operator|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_BSS
operator|)
operator|)
operator|&&
operator|(
operator|(
name|now_seg
operator|==
name|SEG_DATA
operator|)
operator|||
operator|(
name|now_seg
operator|==
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* 					 *	Select which of the 2 cases this is 					 */
if|if
condition|(
name|now_seg
operator|!=
name|SEG_DATA
condition|)
block|{
comment|/* 						 *   New .comm for prev .comm symbol. 						 *	If the new size is larger we just 						 *	change its value.  If the new size 						 *	is smaller, we ignore this symbol 						 */
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|<
operator|(
call|(
name|unsigned
call|)
argument_list|(
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|)
operator|)
condition|)
block|{
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 						 *	It is a .comm/.lcomm being converted 						 *	to initialized data. 						 */
name|symbolP
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_VMS
name|S_GET_OTHER
argument_list|(
name|symbolP
argument_list|)
operator|=
name|const_flag
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_VMS */
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|now_seg
argument_list|)
expr_stmt|;
comment|/* keep N_EXT bit */
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|OBJ_COFF
name|as_fatal
argument_list|(
literal|"Symbol \"%s\" is already defined as \"%s\"/%d."
argument_list|,
name|sym_name
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
argument_list|)
argument_list|,
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* OBJ_COFF */
name|as_fatal
argument_list|(
literal|"Symbol \"%s\" is already defined as \"%s\"/%d.%d.%d."
argument_list|,
name|sym_name
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
argument_list|)
argument_list|,
name|S_GET_OTHER
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_COFF */
block|}
block|}
comment|/* if the undefined symbol has no value */
block|}
else|else
block|{
comment|/* Don't blow up if the definition is the same */
if|if
condition|(
operator|!
operator|(
name|frag_now
operator|==
name|symbolP
operator|->
name|sy_frag
operator|&&
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|==
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|now_seg
operator|)
condition|)
name|as_fatal
argument_list|(
literal|"Symbol %s already defined."
argument_list|,
name|sym_name
argument_list|)
expr_stmt|;
block|}
comment|/* if this symbol is not yet defined */
block|}
else|else
block|{
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|sym_name
argument_list|,
name|now_seg
argument_list|,
call|(
name|valueT
call|)
argument_list|(
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|)
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_VMS
name|S_SET_OTHER
argument_list|(
name|symbolP
argument_list|,
name|const_flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_VMS */
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
comment|/* if we have seen this symbol before */
return|return;
block|}
end_function

begin_comment
comment|/* colon() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			symbol_table_insert()  *  * Die if we can't insert the symbol.  *  */
end_comment

begin_function
name|void
name|symbol_table_insert
parameter_list|(
name|symbolP
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|error_string
decl_stmt|;
name|know
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|error_string
operator|=
name|hash_jam
argument_list|(
name|sy_hash
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|symbolP
argument_list|)
operator|)
condition|)
block|{
name|as_fatal
argument_list|(
literal|"Inserting \"%s\" into symbol table failed: %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|error_string
argument_list|)
expr_stmt|;
block|}
comment|/* on error */
block|}
end_function

begin_comment
comment|/* symbol_table_insert() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			symbol_find_or_make()  *  * If a symbol name does not exist, create it as undefined, and insert  * it into the symbol table. Return a pointer to it.  */
end_comment

begin_function
name|symbolS
modifier|*
name|symbol_find_or_make
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolP
operator|=
name|symbol_find
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolP
operator|==
name|NULL
condition|)
block|{
name|symbolP
operator|=
name|symbol_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
comment|/* if symbol wasn't found */
return|return
operator|(
name|symbolP
operator|)
return|;
block|}
end_function

begin_comment
comment|/* symbol_find_or_make() */
end_comment

begin_function
name|symbolS
modifier|*
name|symbol_make
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* Let the machine description default it, e.g. for register names. */
name|symbolP
operator|=
name|md_undefined_symbol
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|symbolP
condition|)
block|{
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|SEG_UNKNOWN
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
block|}
comment|/* if md didn't build us a symbol */
return|return
operator|(
name|symbolP
operator|)
return|;
block|}
end_function

begin_comment
comment|/* symbol_make() */
end_comment

begin_comment
comment|/*  *			symbol_find()  *  * Implement symbol table lookup.  * In:	A symbol's name as a string: '\0' can't be part of a symbol name.  * Out:	NULL if the name was not in the symbol table, else the address  *	of a struct symbol associated with that name.  */
end_comment

begin_function
name|symbolS
modifier|*
name|symbol_find
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|STRIP_UNDERSCORE
return|return
operator|(
name|symbol_find_base
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
operator|)
return|;
else|#
directive|else
comment|/* STRIP_UNDERSCORE */
return|return
operator|(
name|symbol_find_base
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* STRIP_UNDERSCORE */
block|}
end_function

begin_comment
comment|/* symbol_find() */
end_comment

begin_function
name|symbolS
modifier|*
name|symbol_find_base
parameter_list|(
name|name
parameter_list|,
name|strip_underscore
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|strip_underscore
decl_stmt|;
block|{
if|if
condition|(
name|strip_underscore
operator|&&
operator|*
name|name
operator|==
literal|'_'
condition|)
name|name
operator|++
expr_stmt|;
return|return
operator|(
operator|(
name|symbolS
operator|*
operator|)
name|hash_find
argument_list|(
name|sy_hash
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Once upon a time, symbols were kept in a singly linked list.  At  * least coff needs to be able to rearrange them from time to time, for  * which a doubly linked list is much more convenient.  Loic did these  * as macros which seemed dangerous to me so they're now functions.  * xoxorich.  */
end_comment

begin_comment
comment|/* Link symbol ADDME after symbol TARGET in the chain. */
end_comment

begin_function
name|void
name|symbol_append
parameter_list|(
name|addme
parameter_list|,
name|target
parameter_list|,
name|rootPP
parameter_list|,
name|lastPP
parameter_list|)
name|symbolS
modifier|*
name|addme
decl_stmt|;
name|symbolS
modifier|*
name|target
decl_stmt|;
name|symbolS
modifier|*
modifier|*
name|rootPP
decl_stmt|;
name|symbolS
modifier|*
modifier|*
name|lastPP
decl_stmt|;
block|{
if|if
condition|(
name|target
operator|==
name|NULL
condition|)
block|{
name|know
argument_list|(
operator|*
name|rootPP
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|*
name|lastPP
operator|==
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|rootPP
operator|=
name|addme
expr_stmt|;
operator|*
name|lastPP
operator|=
name|addme
expr_stmt|;
return|return;
block|}
comment|/* if the list is empty */
if|if
condition|(
name|target
operator|->
name|sy_next
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SYMBOLS_NEED_BACKPOINTERS
name|target
operator|->
name|sy_next
operator|->
name|sy_previous
operator|=
name|addme
expr_stmt|;
endif|#
directive|endif
comment|/* SYMBOLS_NEED_BACKPOINTERS */
block|}
else|else
block|{
name|know
argument_list|(
operator|*
name|lastPP
operator|==
name|target
argument_list|)
expr_stmt|;
operator|*
name|lastPP
operator|=
name|addme
expr_stmt|;
block|}
comment|/* if we have a next */
name|addme
operator|->
name|sy_next
operator|=
name|target
operator|->
name|sy_next
expr_stmt|;
name|target
operator|->
name|sy_next
operator|=
name|addme
expr_stmt|;
ifdef|#
directive|ifdef
name|SYMBOLS_NEED_BACKPOINTERS
name|addme
operator|->
name|sy_previous
operator|=
name|target
expr_stmt|;
endif|#
directive|endif
comment|/* SYMBOLS_NEED_BACKPOINTERS */
ifdef|#
directive|ifdef
name|DEBUG
comment|/*	verify_symbol_chain(*rootPP, *lastPP); */
endif|#
directive|endif
comment|/* DEBUG */
return|return;
block|}
end_function

begin_comment
comment|/* symbol_append() */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYMBOLS_NEED_BACKPOINTERS
end_ifdef

begin_comment
comment|/* Remove SYMBOLP from the list. */
end_comment

begin_function
name|void
name|symbol_remove
parameter_list|(
name|symbolP
parameter_list|,
name|rootPP
parameter_list|,
name|lastPP
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolS
modifier|*
modifier|*
name|rootPP
decl_stmt|;
name|symbolS
modifier|*
modifier|*
name|lastPP
decl_stmt|;
block|{
if|if
condition|(
name|symbolP
operator|==
operator|*
name|rootPP
condition|)
block|{
operator|*
name|rootPP
operator|=
name|symbolP
operator|->
name|sy_next
expr_stmt|;
block|}
comment|/* if it was the root */
if|if
condition|(
name|symbolP
operator|==
operator|*
name|lastPP
condition|)
block|{
operator|*
name|lastPP
operator|=
name|symbolP
operator|->
name|sy_previous
expr_stmt|;
block|}
comment|/* if it was the tail */
if|if
condition|(
name|symbolP
operator|->
name|sy_next
operator|!=
name|NULL
condition|)
block|{
name|symbolP
operator|->
name|sy_next
operator|->
name|sy_previous
operator|=
name|symbolP
operator|->
name|sy_previous
expr_stmt|;
block|}
comment|/* if not last */
if|if
condition|(
name|symbolP
operator|->
name|sy_previous
operator|!=
name|NULL
condition|)
block|{
name|symbolP
operator|->
name|sy_previous
operator|->
name|sy_next
operator|=
name|symbolP
operator|->
name|sy_next
expr_stmt|;
block|}
comment|/* if not first */
ifdef|#
directive|ifdef
name|DEBUG
name|verify_symbol_chain
argument_list|(
operator|*
name|rootPP
argument_list|,
operator|*
name|lastPP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return;
block|}
end_function

begin_comment
comment|/* symbol_remove() */
end_comment

begin_comment
comment|/* Set the chain pointers of SYMBOL to null. */
end_comment

begin_function
name|void
name|symbol_clear_list_pointers
parameter_list|(
name|symbolP
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
name|symbolP
operator|->
name|sy_next
operator|=
name|NULL
expr_stmt|;
name|symbolP
operator|->
name|sy_previous
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* symbol_clear_list_pointers() */
end_comment

begin_comment
comment|/* Link symbol ADDME before symbol TARGET in the chain. */
end_comment

begin_function
name|void
name|symbol_insert
parameter_list|(
name|addme
parameter_list|,
name|target
parameter_list|,
name|rootPP
parameter_list|,
name|lastPP
parameter_list|)
name|symbolS
modifier|*
name|addme
decl_stmt|;
name|symbolS
modifier|*
name|target
decl_stmt|;
name|symbolS
modifier|*
modifier|*
name|rootPP
decl_stmt|;
name|symbolS
modifier|*
modifier|*
name|lastPP
decl_stmt|;
block|{
if|if
condition|(
name|target
operator|->
name|sy_previous
operator|!=
name|NULL
condition|)
block|{
name|target
operator|->
name|sy_previous
operator|->
name|sy_next
operator|=
name|addme
expr_stmt|;
block|}
else|else
block|{
name|know
argument_list|(
operator|*
name|rootPP
operator|==
name|target
argument_list|)
expr_stmt|;
operator|*
name|rootPP
operator|=
name|addme
expr_stmt|;
block|}
comment|/* if not first */
name|addme
operator|->
name|sy_previous
operator|=
name|target
operator|->
name|sy_previous
expr_stmt|;
name|target
operator|->
name|sy_previous
operator|=
name|addme
expr_stmt|;
name|addme
operator|->
name|sy_next
operator|=
name|target
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|verify_symbol_chain
argument_list|(
operator|*
name|rootPP
argument_list|,
operator|*
name|lastPP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return;
block|}
end_function

begin_comment
comment|/* symbol_insert() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYMBOLS_NEED_BACKPOINTERS */
end_comment

begin_function
name|void
name|verify_symbol_chain
parameter_list|(
name|rootP
parameter_list|,
name|lastP
parameter_list|)
name|symbolS
modifier|*
name|rootP
decl_stmt|;
name|symbolS
modifier|*
name|lastP
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
init|=
name|rootP
decl_stmt|;
if|if
condition|(
name|symbolP
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
comment|/* empty chain */
for|for
control|(
init|;
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|NULL
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
ifdef|#
directive|ifdef
name|SYMBOLS_NEED_BACKPOINTERS
comment|/*$if (symbolP->sy_previous) { 		  know(symbolP->sy_previous->sy_next == symbolP); 		  } else { 		  know(symbolP == rootP); 		  }$*/
comment|/* both directions */
name|know
argument_list|(
name|symbolP
operator|->
name|sy_next
operator|->
name|sy_previous
operator|==
name|symbolP
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SYMBOLS_NEED_BACKPOINTERS */
empty_stmt|;
endif|#
directive|endif
comment|/* SYMBOLS_NEED_BACKPOINTERS */
block|}
comment|/* verify pointers */
name|know
argument_list|(
name|lastP
operator|==
name|symbolP
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* verify_symbol_chain() */
end_comment

begin_comment
comment|/*  * decode name that may have been generated by local_label_name() above.  If  * the name wasn't generated by local_label_name(), then return it unaltered.  * This is used for error messages.  */
end_comment

begin_function
name|char
modifier|*
name|decode_local_label_name
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|symbol_decode
decl_stmt|;
name|int
name|label_number
decl_stmt|;
comment|/*	int label_version; */
name|char
modifier|*
name|message_format
init|=
literal|"\"%d\" (instance number %s of a local label)"
decl_stmt|;
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|!=
literal|'L'
operator|||
name|s
index|[
literal|2
index|]
operator|!=
literal|1
condition|)
block|{
return|return
operator|(
name|s
operator|)
return|;
block|}
comment|/* not a local_label_name() generated name. */
name|label_number
operator|=
name|s
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|symbol_decode
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
name|strlen
argument_list|(
name|s
operator|+
literal|3
argument_list|)
operator|+
name|strlen
argument_list|(
name|message_format
argument_list|)
operator|+
literal|10
argument_list|)
argument_list|,
name|message_format
argument_list|,
name|label_number
argument_list|,
name|s
operator|+
literal|3
argument_list|)
expr_stmt|;
return|return
operator|(
name|symbol_decode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* decode_local_label_name() */
end_comment

begin_comment
comment|/*  * Local Variables:  * comment-column: 0  * fill-column: 131  * End:  */
end_comment

begin_comment
comment|/* end of symbols.c */
end_comment

end_unit

