begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This is the Assembler Pre-Processor    Copyright (C) 1987, 1990, 1991, 1992, 1994 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Modified by Allen Wirfs-Brock, Instantiations Inc 2/90 */
end_comment

begin_comment
comment|/* App, the assembler pre-processor.  This pre-processor strips out excess    spaces, turns single-quoted characters into a decimal constant, and turns    #<number><filename><garbage> into a .line<number>\n.file<filename>    pair.  This needs better error-handling.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: app.c,v 1.3 1994/12/23 22:35:59 nate Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_comment
comment|/* For BAD_CASE() only */
end_comment

begin_if
if|#
directive|if
operator|(
name|__STDC__
operator|!=
literal|1
operator|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|const
end_ifndef

begin_define
define|#
directive|define
name|const
end_define

begin_comment
comment|/* empty */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|lex
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|symbol_chars
index|[]
init|=
literal|"$._ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LEX_IS_SYMBOL_COMPONENT
value|1
end_define

begin_define
define|#
directive|define
name|LEX_IS_WHITESPACE
value|2
end_define

begin_define
define|#
directive|define
name|LEX_IS_LINE_SEPARATOR
value|3
end_define

begin_define
define|#
directive|define
name|LEX_IS_COMMENT_START
value|4
end_define

begin_define
define|#
directive|define
name|LEX_IS_LINE_COMMENT_START
value|5
end_define

begin_define
define|#
directive|define
name|LEX_IS_TWOCHAR_COMMENT_1ST
value|6
end_define

begin_define
define|#
directive|define
name|LEX_IS_TWOCHAR_COMMENT_2ND
value|7
end_define

begin_define
define|#
directive|define
name|LEX_IS_STRINGQUOTE
value|8
end_define

begin_define
define|#
directive|define
name|LEX_IS_COLON
value|9
end_define

begin_define
define|#
directive|define
name|LEX_IS_NEWLINE
value|10
end_define

begin_define
define|#
directive|define
name|LEX_IS_ONECHAR_QUOTE
value|11
end_define

begin_define
define|#
directive|define
name|IS_SYMBOL_COMPONENT
parameter_list|(
name|c
parameter_list|)
value|(lex[c] == LEX_IS_SYMBOL_COMPONENT)
end_define

begin_define
define|#
directive|define
name|IS_WHITESPACE
parameter_list|(
name|c
parameter_list|)
value|(lex[c] == LEX_IS_WHITESPACE)
end_define

begin_define
define|#
directive|define
name|IS_LINE_SEPARATOR
parameter_list|(
name|c
parameter_list|)
value|(lex[c] == LEX_IS_LINE_SEPARATOR)
end_define

begin_define
define|#
directive|define
name|IS_COMMENT
parameter_list|(
name|c
parameter_list|)
value|(lex[c] == LEX_IS_COMMENT_START)
end_define

begin_define
define|#
directive|define
name|IS_LINE_COMMENT
parameter_list|(
name|c
parameter_list|)
value|(lex[c] == LEX_IS_LINE_COMMENT_START)
end_define

begin_define
define|#
directive|define
name|IS_NEWLINE
parameter_list|(
name|c
parameter_list|)
value|(lex[c] == LEX_IS_NEWLINE)
end_define

begin_decl_stmt
specifier|static
name|int
name|process_escape
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME-soon: The entire lexer/parser thingy should be    built statically at compile time rather than dynamically    each and every time the assembler is run.  xoxorich. */
end_comment

begin_function
name|void
name|do_scrub_begin
parameter_list|()
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|lex
index|[
literal|' '
index|]
operator|=
name|LEX_IS_WHITESPACE
expr_stmt|;
name|lex
index|[
literal|'\t'
index|]
operator|=
name|LEX_IS_WHITESPACE
expr_stmt|;
name|lex
index|[
literal|'\n'
index|]
operator|=
name|LEX_IS_NEWLINE
expr_stmt|;
name|lex
index|[
literal|';'
index|]
operator|=
name|LEX_IS_LINE_SEPARATOR
expr_stmt|;
name|lex
index|[
literal|'"'
index|]
operator|=
name|LEX_IS_STRINGQUOTE
expr_stmt|;
ifndef|#
directive|ifndef
name|TC_HPPA
name|lex
index|[
literal|'\''
index|]
operator|=
name|LEX_IS_ONECHAR_QUOTE
expr_stmt|;
endif|#
directive|endif
name|lex
index|[
literal|':'
index|]
operator|=
name|LEX_IS_COLON
expr_stmt|;
ifdef|#
directive|ifdef
name|SINGLE_QUOTE_STRINGS
name|lex
index|[
literal|'\''
index|]
operator|=
name|LEX_IS_STRINGQUOTE
expr_stmt|;
endif|#
directive|endif
comment|/* Note that these override the previous defaults, e.g. if ';' is a      comment char, then it isn't a line separator.  */
for|for
control|(
name|p
operator|=
name|symbol_chars
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
block|{
name|lex
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
operator|=
name|LEX_IS_SYMBOL_COMPONENT
expr_stmt|;
block|}
comment|/* declare symbol characters */
for|for
control|(
name|p
operator|=
name|comment_chars
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|lex
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
operator|=
name|LEX_IS_COMMENT_START
expr_stmt|;
block|}
comment|/* declare comment chars */
for|for
control|(
name|p
operator|=
name|line_comment_chars
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|lex
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
operator|=
name|LEX_IS_LINE_COMMENT_START
expr_stmt|;
block|}
comment|/* declare line comment chars */
for|for
control|(
name|p
operator|=
name|line_separator_chars
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
name|lex
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
index|]
operator|=
name|LEX_IS_LINE_SEPARATOR
expr_stmt|;
block|}
comment|/* declare line separators */
comment|/* Only allow slash-star comments if slash is not in use */
if|if
condition|(
name|lex
index|[
literal|'/'
index|]
operator|==
literal|0
condition|)
block|{
name|lex
index|[
literal|'/'
index|]
operator|=
name|LEX_IS_TWOCHAR_COMMENT_1ST
expr_stmt|;
block|}
comment|/* FIXME-soon.  This is a bad hack but otherwise, we can't do      c-style comments when '/' is a line comment char. xoxorich. */
if|if
condition|(
name|lex
index|[
literal|'*'
index|]
operator|==
literal|0
condition|)
block|{
name|lex
index|[
literal|'*'
index|]
operator|=
name|LEX_IS_TWOCHAR_COMMENT_2ND
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* do_scrub_begin() */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|scrub_file
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|scrub_from_file
parameter_list|()
block|{
return|return
name|getc
argument_list|(
name|scrub_file
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|scrub_to_file
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
name|ungetc
argument_list|(
name|ch
argument_list|,
name|scrub_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* scrub_to_file() */
end_comment

begin_decl_stmt
name|char
modifier|*
name|scrub_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|scrub_last_string
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|scrub_from_string
parameter_list|()
block|{
return|return
name|scrub_string
operator|==
name|scrub_last_string
condition|?
name|EOF
else|:
operator|*
name|scrub_string
operator|++
return|;
block|}
end_function

begin_comment
comment|/* scrub_from_string() */
end_comment

begin_function
name|void
name|scrub_to_string
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
operator|*
operator|--
name|scrub_string
operator|=
name|ch
expr_stmt|;
block|}
end_function

begin_comment
comment|/* scrub_to_string() */
end_comment

begin_comment
comment|/* Saved state of the scrubber */
end_comment

begin_decl_stmt
specifier|static
name|int
name|state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|old_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|out_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|out_buf
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_newlines
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data structure for saving the state of app across #include's.  Note that    app is called asynchronously to the parsing of the .include's, so our    state at the time .include is interpreted is completely unrelated.    That's why we have to save it all.  */
end_comment

begin_struct
struct|struct
name|app_save
block|{
name|int
name|state
decl_stmt|;
name|int
name|old_state
decl_stmt|;
name|char
modifier|*
name|out_string
decl_stmt|;
name|char
name|out_buf
index|[
sizeof|sizeof
argument_list|(
name|out_buf
argument_list|)
index|]
decl_stmt|;
name|int
name|add_newlines
decl_stmt|;
name|char
modifier|*
name|scrub_string
decl_stmt|;
name|char
modifier|*
name|scrub_last_string
decl_stmt|;
name|FILE
modifier|*
name|scrub_file
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|char
modifier|*
name|app_push
parameter_list|()
block|{
specifier|register
name|struct
name|app_save
modifier|*
name|saved
decl_stmt|;
name|saved
operator|=
operator|(
expr|struct
name|app_save
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|saved
argument_list|)
argument_list|)
expr_stmt|;
name|saved
operator|->
name|state
operator|=
name|state
expr_stmt|;
name|saved
operator|->
name|old_state
operator|=
name|old_state
expr_stmt|;
name|saved
operator|->
name|out_string
operator|=
name|out_string
expr_stmt|;
name|memcpy
argument_list|(
name|saved
operator|->
name|out_buf
argument_list|,
name|out_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|out_buf
argument_list|)
argument_list|)
expr_stmt|;
name|saved
operator|->
name|add_newlines
operator|=
name|add_newlines
expr_stmt|;
name|saved
operator|->
name|scrub_string
operator|=
name|scrub_string
expr_stmt|;
name|saved
operator|->
name|scrub_last_string
operator|=
name|scrub_last_string
expr_stmt|;
name|saved
operator|->
name|scrub_file
operator|=
name|scrub_file
expr_stmt|;
comment|/* do_scrub_begin() is not useful, just wastes time. */
return|return
operator|(
name|char
operator|*
operator|)
name|saved
return|;
block|}
end_function

begin_function
name|void
name|app_pop
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|struct
name|app_save
modifier|*
name|saved
init|=
operator|(
expr|struct
name|app_save
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* There is no do_scrub_end (). */
name|state
operator|=
name|saved
operator|->
name|state
expr_stmt|;
name|old_state
operator|=
name|saved
operator|->
name|old_state
expr_stmt|;
name|out_string
operator|=
name|saved
operator|->
name|out_string
expr_stmt|;
name|memcpy
argument_list|(
name|out_buf
argument_list|,
name|saved
operator|->
name|out_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|out_buf
argument_list|)
argument_list|)
expr_stmt|;
name|add_newlines
operator|=
name|saved
operator|->
name|add_newlines
expr_stmt|;
name|scrub_string
operator|=
name|saved
operator|->
name|scrub_string
expr_stmt|;
name|scrub_last_string
operator|=
name|saved
operator|->
name|scrub_last_string
expr_stmt|;
name|scrub_file
operator|=
name|saved
operator|->
name|scrub_file
expr_stmt|;
name|free
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* app_pop() */
end_comment

begin_comment
comment|/* @@ This assumes that \n&c are the same on host and target.  This is not    necessarily true.  */
end_comment

begin_function
specifier|static
name|int
name|process_escape
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'b'
case|:
return|return
literal|'\b'
return|;
case|case
literal|'f'
case|:
return|return
literal|'\f'
return|;
case|case
literal|'n'
case|:
return|return
literal|'\n'
return|;
case|case
literal|'r'
case|:
return|return
literal|'\r'
return|;
case|case
literal|'t'
case|:
return|return
literal|'\t'
return|;
case|case
literal|'\''
case|:
return|return
literal|'\''
return|;
case|case
literal|'"'
case|:
return|return
literal|'\"'
return|;
default|default:
return|return
name|ch
return|;
block|}
block|}
end_function

begin_decl_stmt
name|int
name|do_scrub_next_char
argument_list|(
name|get
argument_list|,
name|unget
argument_list|)
name|int
argument_list|(
operator|*
name|get
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|unget
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
comment|/*State 0: beginning of normal line 	  1: After first whitespace on line (flush more white) 	  2: After first non-white (opcode) on line (keep 1white) 	  3: after second white on line (into operands) (flush white) 	  4: after putting out a .line, put out digits 	  5: parsing a string, then go to old-state 	  6: putting out \ escape in a "d string. 	  7: After putting out a .appfile, put out string. 	  8: After putting out a .appfile string, flush until newline. 	  9: After seeing symbol char in state 3 (keep 1white after symchar) 	 10: After seeing whitespace in state 9 (keep white before symchar) 	 11: After seeing a symbol character in state 0 (eg a label definition) 	 -1: output string in out_string and go to the state in old_state 	 -2: flush text until a '*' '/' is seen, then go to state old_state 	  */
comment|/* I added states 9 and 10 because the MIPS ECOFF assembler uses      constructs like ``.loc 1 20''.  This was turning into ``.loc      120''.  States 9 and 10 ensure that a space is never dropped in      between characters which could appear in a identifier.  Ian      Taylor, ian@cygnus.com.       I added state 11 so that something like "Lfoo add %r25,%r26,%r27" works      correctly on the PA (and any other target where colons are optional).      Jeff Law, law@cs.utah.edu.  */
specifier|register
name|int
name|ch
decl_stmt|,
name|ch2
init|=
literal|0
decl_stmt|;
name|int
name|not_cpp_line
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|ch
operator|=
operator|*
name|out_string
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|out_string
operator|==
literal|0
condition|)
block|{
name|state
operator|=
name|old_state
expr_stmt|;
name|old_state
operator|=
literal|3
expr_stmt|;
block|}
return|return
name|ch
return|;
case|case
operator|-
literal|2
case|:
for|for
control|(
init|;
condition|;
control|)
block|{
do|do
block|{
name|ch
operator|=
call|(
modifier|*
name|get
call|)
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
literal|'*'
condition|)
do|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
operator|||
name|ch
operator|==
name|EOF
condition|)
return|return
name|ch
return|;
comment|/* At this point, ch must be a '*' */
while|while
condition|(
operator|(
name|ch
operator|=
call|(
modifier|*
name|get
call|)
argument_list|()
operator|)
operator|==
literal|'*'
condition|)
block|{
empty_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
name|EOF
operator|||
name|ch
operator|==
literal|'/'
condition|)
break|break;
call|(
modifier|*
name|unget
call|)
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|state
operator|=
name|old_state
expr_stmt|;
return|return
literal|' '
return|;
case|case
literal|4
case|:
name|ch
operator|=
call|(
modifier|*
name|get
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
operator|||
operator|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
operator|)
condition|)
return|return
name|ch
return|;
else|else
block|{
while|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|IS_WHITESPACE
argument_list|(
name|ch
argument_list|)
condition|)
name|ch
operator|=
call|(
modifier|*
name|get
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'"'
condition|)
block|{
call|(
modifier|*
name|unget
call|)
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|out_string
operator|=
literal|"\n\t.appfile "
expr_stmt|;
name|old_state
operator|=
literal|7
expr_stmt|;
name|state
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|*
name|out_string
operator|++
return|;
block|}
else|else
block|{
while|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
name|ch
operator|=
call|(
modifier|*
name|get
call|)
argument_list|()
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
return|return
name|ch
return|;
block|}
block|}
case|case
literal|5
case|:
name|ch
operator|=
call|(
modifier|*
name|get
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|lex
index|[
name|ch
index|]
operator|==
name|LEX_IS_STRINGQUOTE
condition|)
block|{
name|state
operator|=
name|old_state
expr_stmt|;
return|return
name|ch
return|;
block|}
ifndef|#
directive|ifndef
name|NO_STRING_ESCAPES
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
name|state
operator|=
literal|6
expr_stmt|;
return|return
name|ch
return|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|as_warn
argument_list|(
literal|"End of file in string: inserted '\"'"
argument_list|)
expr_stmt|;
name|state
operator|=
name|old_state
expr_stmt|;
call|(
modifier|*
name|unget
call|)
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return
literal|'"'
return|;
block|}
else|else
block|{
return|return
name|ch
return|;
block|}
case|case
literal|6
case|:
name|state
operator|=
literal|5
expr_stmt|;
name|ch
operator|=
call|(
modifier|*
name|get
call|)
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
comment|/* Handle strings broken across lines, by turning '\n' into 	     '\\' and 'n'.  */
case|case
literal|'\n'
case|:
call|(
modifier|*
name|unget
call|)
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
name|add_newlines
operator|++
expr_stmt|;
return|return
literal|'\\'
return|;
case|case
literal|'"'
case|:
case|case
literal|'\\'
case|:
case|case
literal|'b'
case|:
case|case
literal|'f'
case|:
case|case
literal|'n'
case|:
case|case
literal|'r'
case|:
case|case
literal|'t'
case|:
ifdef|#
directive|ifdef
name|BACKSLASH_V
case|case
literal|'v'
case|:
endif|#
directive|endif
comment|/* BACKSLASH_V */
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
break|break;
if|#
directive|if
name|defined
argument_list|(
name|IGNORE_NONSTANDARD_ESCAPES
argument_list|)
operator||
name|defined
argument_list|(
name|ONLY_STANDARD_ESCAPES
argument_list|)
default|default:
name|as_warn
argument_list|(
literal|"Unknown escape '\\%c' in string: Ignored"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
break|break;
else|#
directive|else
comment|/* ONLY_STANDARD_ESCAPES */
default|default:
comment|/* Accept \x as x for any x */
break|break;
endif|#
directive|endif
comment|/* ONLY_STANDARD_ESCAPES */
case|case
name|EOF
case|:
name|as_warn
argument_list|(
literal|"End of file in string: '\"' inserted"
argument_list|)
expr_stmt|;
return|return
literal|'"'
return|;
block|}
return|return
name|ch
return|;
case|case
literal|7
case|:
name|ch
operator|=
call|(
modifier|*
name|get
call|)
argument_list|()
expr_stmt|;
name|state
operator|=
literal|5
expr_stmt|;
name|old_state
operator|=
literal|8
expr_stmt|;
return|return
name|ch
return|;
case|case
literal|8
case|:
do|do
name|ch
operator|=
call|(
modifier|*
name|get
call|)
argument_list|()
expr_stmt|;
do|while
condition|(
name|ch
operator|!=
literal|'\n'
condition|)
do|;
name|state
operator|=
literal|0
expr_stmt|;
return|return
name|ch
return|;
block|}
comment|/* OK, we are somewhere in states 0 through 4 or 9 through 11 */
comment|/* flushchar: */
name|ch
operator|=
call|(
modifier|*
name|get
call|)
argument_list|()
expr_stmt|;
name|recycle
label|:
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|state
operator|!=
literal|0
condition|)
name|as_warn
argument_list|(
literal|"End of file not at end of a line: Newline inserted."
argument_list|)
expr_stmt|;
return|return
name|ch
return|;
block|}
switch|switch
condition|(
name|lex
index|[
name|ch
index|]
condition|)
block|{
case|case
name|LEX_IS_WHITESPACE
case|:
do|do
comment|/* Preserve a single whitespace character at the beginning of 	   a line.  */
if|if
condition|(
name|state
operator|==
literal|0
condition|)
block|{
name|state
operator|=
literal|1
expr_stmt|;
return|return
name|ch
return|;
block|}
else|else
name|ch
operator|=
call|(
modifier|*
name|get
call|)
argument_list|()
expr_stmt|;
do|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|IS_WHITESPACE
argument_list|(
name|ch
argument_list|)
condition|)
do|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
return|return
name|ch
return|;
if|if
condition|(
name|IS_COMMENT
argument_list|(
name|ch
argument_list|)
operator|||
operator|(
name|state
operator|==
literal|0
operator|&&
name|IS_LINE_COMMENT
argument_list|(
name|ch
argument_list|)
operator|)
operator|||
name|ch
operator|==
literal|'/'
operator|||
name|IS_LINE_SEPARATOR
argument_list|(
name|ch
argument_list|)
condition|)
block|{
comment|/* cpp never outputs a leading space before the #, so try to 	     avoid being confused.  */
name|not_cpp_line
operator|=
literal|1
expr_stmt|;
goto|goto
name|recycle
goto|;
block|}
ifdef|#
directive|ifdef
name|MRI
call|(
modifier|*
name|unget
call|)
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|/* Put back */
return|return
literal|' '
return|;
comment|/* Always return one space at start of line */
endif|#
directive|endif
comment|/* If we're in state 2 or 11, we've seen a non-white character 	 followed by whitespace.  If the next character is ':', this 	 is whitespace after a label name which we *must* ignore.  */
if|if
condition|(
operator|(
name|state
operator|==
literal|2
operator|||
name|state
operator|==
literal|11
operator|)
operator|&&
name|lex
index|[
name|ch
index|]
operator|==
name|LEX_IS_COLON
condition|)
block|{
name|state
operator|=
literal|1
expr_stmt|;
return|return
name|ch
return|;
block|}
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
name|state
operator|++
expr_stmt|;
goto|goto
name|recycle
goto|;
comment|/* Punted leading sp */
case|case
literal|1
case|:
comment|/* We can arrive here if we leave a leading whitespace character 	     at the beginning of a line.  */
goto|goto
name|recycle
goto|;
case|case
literal|2
case|:
name|state
operator|=
literal|3
expr_stmt|;
call|(
modifier|*
name|unget
call|)
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
literal|' '
return|;
comment|/* Sp after opco */
case|case
literal|3
case|:
goto|goto
name|recycle
goto|;
comment|/* Sp in operands */
case|case
literal|9
case|:
case|case
literal|10
case|:
name|state
operator|=
literal|10
expr_stmt|;
comment|/* Sp after symbol char */
goto|goto
name|recycle
goto|;
case|case
literal|11
case|:
name|state
operator|=
literal|1
expr_stmt|;
call|(
modifier|*
name|unget
call|)
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
literal|' '
return|;
comment|/* Sp after label definition.  */
default|default:
name|BAD_CASE
argument_list|(
name|state
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LEX_IS_TWOCHAR_COMMENT_1ST
case|:
name|ch2
operator|=
call|(
modifier|*
name|get
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch2
operator|!=
name|EOF
operator|&&
name|lex
index|[
name|ch2
index|]
operator|==
name|LEX_IS_TWOCHAR_COMMENT_2ND
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
do|do
block|{
name|ch2
operator|=
call|(
modifier|*
name|get
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch2
operator|!=
name|EOF
operator|&&
name|IS_NEWLINE
argument_list|(
name|ch2
argument_list|)
condition|)
name|add_newlines
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|ch2
operator|!=
name|EOF
operator|&&
operator|(
name|lex
index|[
name|ch2
index|]
operator|!=
name|LEX_IS_TWOCHAR_COMMENT_2ND
operator|)
condition|)
do|;
while|while
condition|(
name|ch2
operator|!=
name|EOF
operator|&&
operator|(
name|lex
index|[
name|ch2
index|]
operator|==
name|LEX_IS_TWOCHAR_COMMENT_2ND
operator|)
condition|)
block|{
name|ch2
operator|=
call|(
modifier|*
name|get
call|)
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ch2
operator|==
name|EOF
operator|||
name|lex
index|[
name|ch2
index|]
operator|==
name|LEX_IS_TWOCHAR_COMMENT_1ST
condition|)
break|break;
call|(
modifier|*
name|unget
call|)
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch2
operator|==
name|EOF
condition|)
name|as_warn
argument_list|(
literal|"End of file in multiline comment"
argument_list|)
expr_stmt|;
name|ch
operator|=
literal|' '
expr_stmt|;
goto|goto
name|recycle
goto|;
block|}
else|else
block|{
if|if
condition|(
name|ch2
operator|!=
name|EOF
condition|)
call|(
modifier|*
name|unget
call|)
argument_list|(
name|ch2
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
literal|9
operator|||
name|state
operator|==
literal|10
condition|)
name|state
operator|=
literal|3
expr_stmt|;
return|return
name|ch
return|;
block|}
break|break;
case|case
name|LEX_IS_STRINGQUOTE
case|:
if|if
condition|(
name|state
operator|==
literal|9
operator|||
name|state
operator|==
literal|10
condition|)
name|old_state
operator|=
literal|3
expr_stmt|;
else|else
name|old_state
operator|=
name|state
expr_stmt|;
name|state
operator|=
literal|5
expr_stmt|;
return|return
name|ch
return|;
ifndef|#
directive|ifndef
name|MRI
ifndef|#
directive|ifndef
name|IEEE_STYLE
case|case
name|LEX_IS_ONECHAR_QUOTE
case|:
name|ch
operator|=
call|(
modifier|*
name|get
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|as_warn
argument_list|(
literal|"End-of-file after a one-character quote; \\000 inserted"
argument_list|)
expr_stmt|;
name|ch
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
name|ch
operator|=
call|(
modifier|*
name|get
call|)
argument_list|()
expr_stmt|;
name|ch
operator|=
name|process_escape
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|out_buf
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
operator|(
name|unsigned
name|char
operator|)
name|ch
argument_list|)
expr_stmt|;
comment|/* None of these 'x constants for us.  We want 'x'.  */
if|if
condition|(
operator|(
name|ch
operator|=
call|(
modifier|*
name|get
call|)
argument_list|()
operator|)
operator|!=
literal|'\''
condition|)
block|{
ifdef|#
directive|ifdef
name|REQUIRE_CHAR_CLOSE_QUOTE
name|as_warn
argument_list|(
literal|"Missing close quote: (assumed)"
argument_list|)
expr_stmt|;
else|#
directive|else
call|(
modifier|*
name|unget
call|)
argument_list|(
name|ch
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|strlen
argument_list|(
name|out_buf
argument_list|)
operator|==
literal|1
condition|)
block|{
return|return
name|out_buf
index|[
literal|0
index|]
return|;
block|}
if|if
condition|(
name|state
operator|==
literal|9
operator|||
name|state
operator|==
literal|10
condition|)
name|old_state
operator|=
literal|3
expr_stmt|;
else|else
name|old_state
operator|=
name|state
expr_stmt|;
name|state
operator|=
operator|-
literal|1
expr_stmt|;
name|out_string
operator|=
name|out_buf
expr_stmt|;
return|return
operator|*
name|out_string
operator|++
return|;
endif|#
directive|endif
endif|#
directive|endif
case|case
name|LEX_IS_COLON
case|:
if|if
condition|(
name|state
operator|==
literal|9
operator|||
name|state
operator|==
literal|10
condition|)
name|state
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|!=
literal|3
condition|)
name|state
operator|=
literal|1
expr_stmt|;
return|return
name|ch
return|;
case|case
name|LEX_IS_NEWLINE
case|:
comment|/* Roll out a bunch of newlines from inside comments, etc.  */
if|if
condition|(
name|add_newlines
condition|)
block|{
operator|--
name|add_newlines
expr_stmt|;
call|(
modifier|*
name|unget
call|)
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
comment|/* fall thru into... */
case|case
name|LEX_IS_LINE_SEPARATOR
case|:
name|state
operator|=
literal|0
expr_stmt|;
return|return
name|ch
return|;
case|case
name|LEX_IS_LINE_COMMENT_START
case|:
if|if
condition|(
name|state
operator|==
literal|0
condition|)
comment|/* Only comment at start of line.  */
block|{
comment|/* FIXME-someday: The two character comment stuff was badly 	     thought out.  On i386, we want '/' as line comment start 	     AND we want C style comments.  hence this hack.  The 	     whole lexical process should be reworked.  xoxorich.  */
if|if
condition|(
name|ch
operator|==
literal|'/'
condition|)
block|{
name|ch2
operator|=
call|(
modifier|*
name|get
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch2
operator|==
literal|'*'
condition|)
block|{
name|state
operator|=
operator|-
literal|2
expr_stmt|;
return|return
operator|(
name|do_scrub_next_char
argument_list|(
name|get
argument_list|,
name|unget
argument_list|)
operator|)
return|;
block|}
else|else
block|{
call|(
modifier|*
name|unget
call|)
argument_list|(
name|ch2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* bad hack */
if|if
condition|(
name|ch
operator|!=
literal|'#'
condition|)
name|not_cpp_line
operator|=
literal|1
expr_stmt|;
do|do
name|ch
operator|=
call|(
modifier|*
name|get
call|)
argument_list|()
expr_stmt|;
do|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|IS_WHITESPACE
argument_list|(
name|ch
argument_list|)
condition|)
do|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|as_warn
argument_list|(
literal|"EOF in comment:  Newline inserted"
argument_list|)
expr_stmt|;
return|return
literal|'\n'
return|;
block|}
if|if
condition|(
name|ch
operator|<
literal|'0'
operator|||
name|ch
operator|>
literal|'9'
operator|||
name|not_cpp_line
condition|)
block|{
comment|/* Non-numerics:  Eat whole comment line */
while|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
operator|!
name|IS_NEWLINE
argument_list|(
name|ch
argument_list|)
condition|)
name|ch
operator|=
call|(
modifier|*
name|get
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
name|as_warn
argument_list|(
literal|"EOF in Comment: Newline inserted"
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
return|return
literal|'\n'
return|;
block|}
comment|/* Numerics begin comment.  Perhaps CPP `# 123 "filename"' */
call|(
modifier|*
name|unget
call|)
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|old_state
operator|=
literal|4
expr_stmt|;
name|state
operator|=
operator|-
literal|1
expr_stmt|;
name|out_string
operator|=
literal|"\t.appline "
expr_stmt|;
return|return
operator|*
name|out_string
operator|++
return|;
block|}
comment|/* We have a line comment character which is not at the start of 	 a line.  If this is also a normal comment character, fall 	 through.  Otherwise treat it as a default character.  */
if|if
condition|(
name|strchr
argument_list|(
name|comment_chars
argument_list|,
name|ch
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|de_fault
goto|;
comment|/* Fall through.  */
case|case
name|LEX_IS_COMMENT_START
case|:
do|do
name|ch
operator|=
call|(
modifier|*
name|get
call|)
argument_list|()
expr_stmt|;
do|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
operator|!
name|IS_NEWLINE
argument_list|(
name|ch
argument_list|)
condition|)
do|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
name|as_warn
argument_list|(
literal|"EOF in comment:  Newline inserted"
argument_list|)
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
return|return
literal|'\n'
return|;
case|case
name|LEX_IS_SYMBOL_COMPONENT
case|:
if|if
condition|(
name|state
operator|==
literal|10
condition|)
block|{
comment|/* This is a symbol character following another symbol 	     character, with whitespace in between.  We skipped the 	     whitespace earlier, so output it now.  */
call|(
modifier|*
name|unget
call|)
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|state
operator|=
literal|3
expr_stmt|;
return|return
literal|' '
return|;
block|}
if|if
condition|(
name|state
operator|==
literal|3
condition|)
name|state
operator|=
literal|9
expr_stmt|;
comment|/* Fall through.  */
default|default:
name|de_fault
label|:
comment|/* Some relatively `normal' character.  */
if|if
condition|(
name|state
operator|==
literal|0
condition|)
block|{
name|state
operator|=
literal|11
expr_stmt|;
comment|/* Now seeing label definition */
return|return
name|ch
return|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
literal|1
condition|)
block|{
name|state
operator|=
literal|2
expr_stmt|;
comment|/* Ditto */
return|return
name|ch
return|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
literal|9
condition|)
block|{
if|if
condition|(
name|lex
index|[
name|ch
index|]
operator|!=
name|LEX_IS_SYMBOL_COMPONENT
condition|)
name|state
operator|=
literal|3
expr_stmt|;
return|return
name|ch
return|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
literal|10
condition|)
block|{
name|state
operator|=
literal|3
expr_stmt|;
return|return
name|ch
return|;
block|}
else|else
block|{
return|return
name|ch
return|;
comment|/* Opcode or operands already */
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"|"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|()
block|{
name|int
name|ch
decl_stmt|;
name|app_begin
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|do_scrub_next_char
argument_list|(
name|stdin
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putc
argument_list|(
name|ch
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|as_warn
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fputs
argument_list|(
name|str
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* end of app.c */
end_comment

end_unit

