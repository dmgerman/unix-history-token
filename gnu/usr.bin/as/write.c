begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* write.c - emit .o file     Copyright (C) 1986, 1987, 1990, 1991, 1992 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This thing should be set up to do byteordering correctly.  But... */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"output-file.h"
end_include

begin_comment
comment|/* The NOP_OPCODE is for the alignment fill value.  * fill it a nop instruction so that the disassembler does not choke  * on it  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOP_OPCODE
end_ifndef

begin_define
define|#
directive|define
name|NOP_OPCODE
value|0x00
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MANY_SEGMENTS
end_ifndef

begin_decl_stmt
specifier|static
name|struct
name|frag
modifier|*
name|text_frag_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|frag
modifier|*
name|data_frag_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|frag
modifier|*
name|text_last_frag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last frag in segment. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|frag
modifier|*
name|data_last_frag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last frag in segment. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
end_ifndef

begin_decl_stmt
specifier|extern
specifier|const
name|int
name|md_short_jump_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|int
name|md_long_jump_size
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|object_headers
name|headers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|string_byte_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|the_object_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|next_object_file_charP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tracks object file bytes. */
end_comment

begin_comment
comment|/* static long		length; JF unused */
end_comment

begin_comment
comment|/* String length, including trailing '\0'. */
end_comment

begin_if
if|#
directive|if
name|__STDC__
operator|==
literal|1
end_if

begin_function_decl
specifier|static
name|int
name|is_dnrange
parameter_list|(
name|struct
name|frag
modifier|*
name|f1
parameter_list|,
name|struct
name|frag
modifier|*
name|f2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|fixup_segment
parameter_list|(
name|fixS
modifier|*
name|fixP
parameter_list|,
name|segT
name|this_segment_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|relax_addressT
name|relax_align
parameter_list|(
name|relax_addressT
name|address
parameter_list|,
name|long
name|alignment
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|relax_segment
parameter_list|(
name|struct
name|frag
modifier|*
name|segment_frag_root
parameter_list|,
name|segT
name|segment_type
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|int
name|is_dnrange
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|fixup_segment
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|relax_addressT
name|relax_align
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|relax_segment
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __STDC__ */
end_comment

begin_comment
comment|/*  *			fix_new()  *  * Create a fixS in obstack 'notes'.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PIC
end_ifdef

begin_function
name|fixS
modifier|*
name|fix_new
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|size
parameter_list|,
name|add_symbol
parameter_list|,
name|sub_symbol
parameter_list|,
name|offset
parameter_list|,
name|pcrel
parameter_list|,
name|r_type
parameter_list|,
name|got_symbol
parameter_list|)
else|#
directive|else
function|fixS *fix_new
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|size
parameter_list|,
name|add_symbol
parameter_list|,
name|sub_symbol
parameter_list|,
name|offset
parameter_list|,
name|pcrel
parameter_list|,
name|r_type
parameter_list|)
endif|#
directive|endif
name|fragS
modifier|*
name|frag
decl_stmt|;
comment|/* Which frag? */
name|int
name|where
decl_stmt|;
comment|/* Where in that frag? */
name|short
name|int
name|size
decl_stmt|;
comment|/* 1, 2, or 4 usually. */
name|symbolS
modifier|*
name|add_symbol
decl_stmt|;
comment|/* X_add_symbol. */
name|symbolS
modifier|*
name|sub_symbol
decl_stmt|;
comment|/* X_subtract_symbol. */
ifdef|#
directive|ifdef
name|PIC
name|symbolS
modifier|*
name|got_symbol
decl_stmt|;
comment|/* X_got. */
endif|#
directive|endif
name|long
name|offset
decl_stmt|;
comment|/* X_add_number. */
name|int
name|pcrel
decl_stmt|;
comment|/* TRUE if PC-relative relocation. */
name|enum
name|reloc_type
name|r_type
decl_stmt|;
comment|/* Relocation type */
block|{
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|fixP
operator|=
operator|(
name|fixS
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
name|fixS
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_frag
operator|=
name|frag
expr_stmt|;
name|fixP
operator|->
name|fx_where
operator|=
name|where
expr_stmt|;
name|fixP
operator|->
name|fx_size
operator|=
name|size
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|add_symbol
expr_stmt|;
name|fixP
operator|->
name|fx_subsy
operator|=
name|sub_symbol
expr_stmt|;
ifdef|#
directive|ifdef
name|PIC
name|fixP
operator|->
name|fx_gotsy
operator|=
name|got_symbol
expr_stmt|;
if|if
condition|(
name|got_symbol
condition|)
name|pcrel
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|fixP
operator|->
name|fx_offset
operator|=
name|offset
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel
operator|=
name|pcrel
expr_stmt|;
name|fixP
operator|->
name|fx_r_type
operator|=
name|r_type
expr_stmt|;
comment|/* JF these 'cuz of the NS32K stuff */
name|fixP
operator|->
name|fx_im_disp
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel_adjust
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_bsr
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_bit_fixP
operator|=
literal|0
expr_stmt|;
comment|/* usually, we want relocs sorted numerically, but while 	   comparing to older versions of gas that have relocs 	   reverse sorted, it is convenient to have this compile 	   time option.  xoxorich. */
ifdef|#
directive|ifdef
name|REVERSE_SORT_RELOCS
name|fixP
operator|->
name|fx_next
operator|=
operator|*
name|seg_fix_rootP
expr_stmt|;
operator|*
name|seg_fix_rootP
operator|=
name|fixP
expr_stmt|;
else|#
directive|else
comment|/* REVERSE_SORT_RELOCS */
name|fixP
operator|->
name|fx_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|seg_fix_tailP
condition|)
operator|(
operator|*
name|seg_fix_tailP
operator|)
operator|->
name|fx_next
operator|=
name|fixP
expr_stmt|;
else|else
operator|*
name|seg_fix_rootP
operator|=
name|fixP
expr_stmt|;
operator|*
name|seg_fix_tailP
operator|=
name|fixP
expr_stmt|;
endif|#
directive|endif
comment|/* REVERSE_SORT_RELOCS */
name|fixP
operator|->
name|fx_callj
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|fixP
operator|)
return|;
block|}
end_function

begin_comment
comment|/* fix_new() */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BFD
end_ifndef

begin_function
name|void
name|write_object_file
parameter_list|()
block|{
specifier|register
name|struct
name|frchain
modifier|*
name|frchainP
decl_stmt|;
comment|/* Track along all frchains. */
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
comment|/* Track along all frags. */
specifier|register
name|struct
name|frchain
modifier|*
name|next_frchainP
decl_stmt|;
specifier|register
name|fragS
modifier|*
modifier|*
name|prev_fragPP
decl_stmt|;
comment|/*  register char *		name; */
comment|/*  symbolS *symbolP; */
comment|/*  register symbolS **		symbolPP; */
comment|/* register fixS *		fixP; JF unused */
name|unsigned
name|int
name|data_siz
decl_stmt|;
name|long
name|object_file_size
decl_stmt|;
ifdef|#
directive|ifdef
name|OBJ_VMS
comment|/* 	 *	Under VMS we try to be compatible with VAX-11 "C".  Thus, we 	 *	call a routine to check for the definition of the procedure 	 *	"_main", and if so -- fix it up so that it can be program 	 *	entry point. 	 */
name|VMS_Check_For_Main
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_VMS */
comment|/* 	 * After every sub-segment, we fake an ".align ...". This conforms to BSD4.2 	 * brane-damage. We then fake ".fill 0" because that is the kind of frag 	 * that requires least thought. ".align" frags like to have a following 	 * frag since that makes calculating their intended length trivial. 	 */
ifndef|#
directive|ifndef
name|SUB_SEGMENT_ALIGN
define|#
directive|define
name|SUB_SEGMENT_ALIGN
value|(2)
endif|#
directive|endif
for|for
control|(
name|frchainP
operator|=
name|frchain_root
init|;
name|frchainP
condition|;
name|frchainP
operator|=
name|frchainP
operator|->
name|frch_next
control|)
block|{
ifdef|#
directive|ifdef
name|OBJ_VMS
comment|/* 		 *	Under VAX/VMS, the linker (and PSECT specifications) 		 *	take care of correctly aligning the segments. 		 *	Doing the alignment here (on initialized data) can 		 *	mess up the calculation of global data PSECT sizes. 		 */
undef|#
directive|undef
name|SUB_SEGMENT_ALIGN
define|#
directive|define
name|SUB_SEGMENT_ALIGN
value|((frchainP->frch_seg != SEG_DATA) ? 2 : 0)
endif|#
directive|endif
comment|/* OBJ_VMS */
name|subseg_new
argument_list|(
name|frchainP
operator|->
name|frch_seg
argument_list|,
name|frchainP
operator|->
name|frch_subseg
argument_list|)
expr_stmt|;
name|frag_align
argument_list|(
name|SUB_SEGMENT_ALIGN
argument_list|,
name|NOP_OPCODE
argument_list|)
expr_stmt|;
comment|/* frag_align will have left a new frag. */
comment|/* Use this last frag for an empty ".fill". */
comment|/* 		 * For this segment ... 		 * Create a last frag. Do not leave a "being filled in frag". 		 */
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|fr_fix
operator|=
literal|0
expr_stmt|;
name|know
argument_list|(
name|frag_now
operator|->
name|fr_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* know(frags.obstack_c_base == frags.obstack_c_next_free); */
comment|/* Above shows we haven't left a half-completed object on obstack. */
block|}
comment|/* walk the frag chain */
comment|/* 	 * From now on, we don't care about sub-segments. 	 * Build one frag chain for each segment. Linked thru fr_next. 	 * We know that there is at least 1 text frchain& at least 1 data frchain. 	 */
name|prev_fragPP
operator|=
operator|&
name|text_frag_root
expr_stmt|;
for|for
control|(
name|frchainP
operator|=
name|frchain_root
init|;
name|frchainP
condition|;
name|frchainP
operator|=
name|next_frchainP
control|)
block|{
name|know
argument_list|(
name|frchainP
operator|->
name|frch_root
argument_list|)
expr_stmt|;
operator|*
name|prev_fragPP
operator|=
name|frchainP
operator|->
name|frch_root
expr_stmt|;
name|prev_fragPP
operator|=
operator|&
name|frchainP
operator|->
name|frch_last
operator|->
name|fr_next
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|next_frchainP
operator|=
name|frchainP
operator|->
name|frch_next
operator|)
operator|==
name|NULL
operator|)
operator|||
name|next_frchainP
operator|==
name|data0_frchainP
condition|)
block|{
name|prev_fragPP
operator|=
operator|&
name|data_frag_root
expr_stmt|;
if|if
condition|(
name|next_frchainP
condition|)
block|{
name|text_last_frag
operator|=
name|frchainP
operator|->
name|frch_last
expr_stmt|;
block|}
else|else
block|{
name|data_last_frag
operator|=
name|frchainP
operator|->
name|frch_last
expr_stmt|;
block|}
block|}
block|}
comment|/* walk the frag chain */
comment|/* 	 * We have two segments. If user gave -R flag, then we must put the 	 * data frags into the text segment. Do this before relaxing so 	 * we know to take advantage of -R and make shorter addresses. 	 */
if|if
condition|(
name|flagseen
index|[
literal|'R'
index|]
condition|)
block|{
name|fixS
modifier|*
name|tmp
decl_stmt|;
name|text_last_frag
operator|->
name|fr_next
operator|=
name|data_frag_root
expr_stmt|;
name|text_last_frag
operator|=
name|data_last_frag
expr_stmt|;
name|data_last_frag
operator|=
name|NULL
expr_stmt|;
name|data_frag_root
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|text_fix_root
condition|)
block|{
for|for
control|(
name|tmp
operator|=
name|text_fix_root
init|;
name|tmp
operator|->
name|fx_next
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|fx_next
control|)
empty_stmt|;
empty_stmt|;
name|tmp
operator|->
name|fx_next
operator|=
name|data_fix_root
expr_stmt|;
block|}
else|else
name|text_fix_root
operator|=
name|data_fix_root
expr_stmt|;
name|data_fix_root
operator|=
name|NULL
expr_stmt|;
block|}
name|relax_segment
argument_list|(
name|text_frag_root
argument_list|,
name|SEG_TEXT
argument_list|)
expr_stmt|;
name|relax_segment
argument_list|(
name|data_frag_root
argument_list|,
name|SEG_DATA
argument_list|)
expr_stmt|;
comment|/* 	 * Now the addresses of frags are correct within the segment. 	 */
name|know
argument_list|(
name|text_last_frag
operator|->
name|fr_type
operator|==
name|rs_fill
operator|&&
name|text_last_frag
operator|->
name|fr_offset
operator|==
literal|0
argument_list|)
expr_stmt|;
name|H_SET_TEXT_SIZE
argument_list|(
operator|&
name|headers
argument_list|,
name|text_last_frag
operator|->
name|fr_address
argument_list|)
expr_stmt|;
name|text_last_frag
operator|->
name|fr_address
operator|=
name|H_GET_TEXT_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
expr_stmt|;
comment|/* 	 * Join the 2 segments into 1 huge segment. 	 * To do this, re-compute every rn_address in the SEG_DATA frags. 	 * Then join the data frags after the text frags. 	 * 	 * Determine a_data [length of data segment]. 	 */
if|if
condition|(
name|data_frag_root
condition|)
block|{
specifier|register
name|relax_addressT
name|slide
decl_stmt|;
name|know
argument_list|(
operator|(
name|text_last_frag
operator|->
name|fr_type
operator|==
name|rs_fill
operator|)
operator|&&
operator|(
name|text_last_frag
operator|->
name|fr_offset
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
name|H_SET_DATA_SIZE
argument_list|(
operator|&
name|headers
argument_list|,
name|data_last_frag
operator|->
name|fr_address
argument_list|)
expr_stmt|;
name|data_last_frag
operator|->
name|fr_address
operator|=
name|H_GET_DATA_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
expr_stmt|;
name|slide
operator|=
name|H_GET_TEXT_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
expr_stmt|;
comment|/*& in file of the data segment. */
for|for
control|(
name|fragP
operator|=
name|data_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
name|fragP
operator|->
name|fr_address
operator|+=
name|slide
expr_stmt|;
block|}
comment|/* for each data frag */
name|know
argument_list|(
name|text_last_frag
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|text_last_frag
operator|->
name|fr_next
operator|=
name|data_frag_root
expr_stmt|;
block|}
else|else
block|{
name|H_SET_DATA_SIZE
argument_list|(
operator|&
name|headers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|data_siz
operator|=
literal|0
expr_stmt|;
block|}
name|bss_address_frag
operator|.
name|fr_address
operator|=
operator|(
name|H_GET_TEXT_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_DATA_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|)
expr_stmt|;
name|H_SET_BSS_SIZE
argument_list|(
operator|&
name|headers
argument_list|,
name|local_bss_counter
argument_list|)
expr_stmt|;
comment|/* 	 * 	 * Crawl the symbol chain. 	 * 	 * For each symbol whose value depends on a frag, take the address of 	 * that frag and subsume it into the value of the symbol. 	 * After this, there is just one way to lookup a symbol value. 	 * Values are left in their final state for object file emission. 	 * We adjust the values of 'L' local symbols, even if we do 	 * not intend to emit them to the object file, because their values 	 * are needed for fix-ups. 	 * 	 * Unless we saw a -L flag, remove all symbols that begin with 'L' 	 * from the symbol chain.  (They are still pointed to by the fixes.) 	 * 	 * Count the remaining symbols. 	 * Assign a symbol number to each symbol. 	 * Count the number of string-table chars we will emit. 	 * Put this info into the headers as appropriate. 	 * 	 */
name|know
argument_list|(
name|zero_address_frag
operator|.
name|fr_address
operator|==
literal|0
argument_list|)
expr_stmt|;
name|string_byte_count
operator|=
sizeof|sizeof
argument_list|(
name|string_byte_count
argument_list|)
expr_stmt|;
name|obj_crawl_symbol_chain
argument_list|(
operator|&
name|headers
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_byte_count
operator|==
sizeof|sizeof
argument_list|(
name|string_byte_count
argument_list|)
condition|)
block|{
name|string_byte_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if no strings, then no count. */
name|H_SET_STRING_SIZE
argument_list|(
operator|&
name|headers
argument_list|,
name|string_byte_count
argument_list|)
expr_stmt|;
comment|/* 	 * Addresses of frags now reflect addresses we use in the object file. 	 * Symbol values are correct. 	 * Scan the frags, converting any ".org"s and ".align"s to ".fill"s. 	 * Also converting any machine-dependent frags using md_convert_frag(); 	 */
name|subseg_change
argument_list|(
name|SEG_TEXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|fragP
operator|=
name|text_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
switch|switch
condition|(
name|fragP
operator|->
name|fr_type
condition|)
block|{
case|case
name|rs_align
case|:
case|case
name|rs_org
case|:
name|fragP
operator|->
name|fr_type
operator|=
name|rs_fill
expr_stmt|;
name|know
argument_list|(
name|fragP
operator|->
name|fr_var
operator|==
literal|1
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|fragP
operator|->
name|fr_next
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_offset
operator|=
operator|(
name|fragP
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_fix
operator|)
expr_stmt|;
break|break;
case|case
name|rs_fill
case|:
break|break;
case|case
name|rs_machine_dependent
case|:
name|md_convert_frag
argument_list|(
operator|&
name|headers
argument_list|,
name|fragP
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|(
name|fragP
operator|->
name|fr_next
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|fragP
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_address
operator|)
operator|==
name|fragP
operator|->
name|fr_fix
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * After md_convert_frag, we make the frag into a ".space 0". 			 * Md_convert_frag() should set up any fixSs and constants 			 * required. 			 */
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
case|case
name|rs_broken_word
case|:
block|{
name|struct
name|broken_word
modifier|*
name|lie
decl_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
name|fragP
operator|->
name|fr_fix
operator|+=
name|md_short_jump_size
expr_stmt|;
for|for
control|(
name|lie
operator|=
operator|(
expr|struct
name|broken_word
operator|*
operator|)
operator|(
name|fragP
operator|->
name|fr_symbol
operator|)
init|;
name|lie
operator|&&
name|lie
operator|->
name|dispfrag
operator|==
name|fragP
condition|;
name|lie
operator|=
name|lie
operator|->
name|next_broken_word
control|)
if|if
condition|(
name|lie
operator|->
name|added
operator|==
literal|1
condition|)
name|fragP
operator|->
name|fr_fix
operator|+=
name|md_long_jump_size
expr_stmt|;
block|}
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_type
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch (fr_type) */
name|know
argument_list|(
operator|(
name|fragP
operator|->
name|fr_next
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|fragP
operator|->
name|fr_next
operator|->
name|fr_address
operator|-
name|fragP
operator|->
name|fr_address
operator|)
operator|==
operator|(
name|fragP
operator|->
name|fr_fix
operator|+
operator|(
name|fragP
operator|->
name|fr_offset
operator|*
name|fragP
operator|->
name|fr_var
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* for each frag. */
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
block|{
name|struct
name|broken_word
modifier|*
name|lie
decl_stmt|;
name|struct
name|broken_word
modifier|*
modifier|*
name|prevP
decl_stmt|;
name|prevP
operator|=
operator|&
name|broken_words
expr_stmt|;
for|for
control|(
name|lie
operator|=
name|broken_words
init|;
name|lie
condition|;
name|lie
operator|=
name|lie
operator|->
name|next_broken_word
control|)
if|if
condition|(
operator|!
name|lie
operator|->
name|added
condition|)
block|{
ifdef|#
directive|ifdef
name|TC_NS32K
name|fix_new_ns32k
argument_list|(
name|lie
operator|->
name|frag
argument_list|,
name|lie
operator|->
name|word_goes_here
operator|-
name|lie
operator|->
name|frag
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
name|lie
operator|->
name|add
argument_list|,
name|lie
operator|->
name|sub
argument_list|,
name|lie
operator|->
name|addnum
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* TC_NS32K */
ifdef|#
directive|ifdef
name|PIC
name|fix_new
argument_list|(
name|lie
operator|->
name|frag
argument_list|,
name|lie
operator|->
name|word_goes_here
operator|-
name|lie
operator|->
name|frag
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
name|lie
operator|->
name|add
argument_list|,
name|lie
operator|->
name|sub
argument_list|,
name|lie
operator|->
name|addnum
argument_list|,
literal|0
argument_list|,
name|NO_RELOC
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|fix_new
argument_list|(
name|lie
operator|->
name|frag
argument_list|,
name|lie
operator|->
name|word_goes_here
operator|-
name|lie
operator|->
name|frag
operator|->
name|fr_literal
argument_list|,
literal|2
argument_list|,
name|lie
operator|->
name|add
argument_list|,
name|lie
operator|->
name|sub
argument_list|,
name|lie
operator|->
name|addnum
argument_list|,
literal|0
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* TC_NS32K */
comment|/* md_number_to_chars(lie->word_goes_here, 			       S_GET_VALUE(lie->add) 			       + lie->addnum 			       - S_GET_VALUE(lie->sub), 			       2); */
operator|*
name|prevP
operator|=
name|lie
operator|->
name|next_broken_word
expr_stmt|;
block|}
else|else
name|prevP
operator|=
operator|&
operator|(
name|lie
operator|->
name|next_broken_word
operator|)
expr_stmt|;
for|for
control|(
name|lie
operator|=
name|broken_words
init|;
name|lie
condition|;
control|)
block|{
name|struct
name|broken_word
modifier|*
name|untruth
decl_stmt|;
name|char
modifier|*
name|table_ptr
decl_stmt|;
name|long
name|table_addr
decl_stmt|;
name|long
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|int
name|n
decl_stmt|,
name|m
decl_stmt|;
name|fragP
operator|=
name|lie
operator|->
name|dispfrag
expr_stmt|;
comment|/* Find out how many broken_words go here */
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|untruth
operator|=
name|lie
init|;
name|untruth
operator|&&
name|untruth
operator|->
name|dispfrag
operator|==
name|fragP
condition|;
name|untruth
operator|=
name|untruth
operator|->
name|next_broken_word
control|)
if|if
condition|(
name|untruth
operator|->
name|added
operator|==
literal|1
condition|)
name|n
operator|++
expr_stmt|;
name|table_ptr
operator|=
name|lie
operator|->
name|dispfrag
operator|->
name|fr_opcode
expr_stmt|;
name|table_addr
operator|=
name|lie
operator|->
name|dispfrag
operator|->
name|fr_address
operator|+
operator|(
name|table_ptr
operator|-
name|lie
operator|->
name|dispfrag
operator|->
name|fr_literal
operator|)
expr_stmt|;
comment|/* Create the jump around the long jumps */
comment|/* This is a short jump from table_ptr+0 to table_ptr+n*long_jump_size */
name|from_addr
operator|=
name|table_addr
expr_stmt|;
name|to_addr
operator|=
name|table_addr
operator|+
name|md_short_jump_size
operator|+
name|n
operator|*
name|md_long_jump_size
expr_stmt|;
name|md_create_short_jump
argument_list|(
name|table_ptr
argument_list|,
name|from_addr
argument_list|,
name|to_addr
argument_list|,
name|lie
operator|->
name|dispfrag
argument_list|,
name|lie
operator|->
name|add
argument_list|)
expr_stmt|;
name|table_ptr
operator|+=
name|md_short_jump_size
expr_stmt|;
name|table_addr
operator|+=
name|md_short_jump_size
expr_stmt|;
for|for
control|(
name|m
operator|=
literal|0
init|;
name|lie
operator|&&
name|lie
operator|->
name|dispfrag
operator|==
name|fragP
condition|;
name|m
operator|++
operator|,
name|lie
operator|=
name|lie
operator|->
name|next_broken_word
control|)
block|{
if|if
condition|(
name|lie
operator|->
name|added
operator|==
literal|2
condition|)
continue|continue;
comment|/* Patch the jump table */
comment|/* This is the offset from ??? to table_ptr+0 */
name|to_addr
operator|=
name|table_addr
operator|-
name|S_GET_VALUE
argument_list|(
name|lie
operator|->
name|sub
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|lie
operator|->
name|word_goes_here
argument_list|,
name|to_addr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|untruth
operator|=
name|lie
operator|->
name|next_broken_word
init|;
name|untruth
operator|&&
name|untruth
operator|->
name|dispfrag
operator|==
name|fragP
condition|;
name|untruth
operator|=
name|untruth
operator|->
name|next_broken_word
control|)
block|{
if|if
condition|(
name|untruth
operator|->
name|use_jump
operator|==
name|lie
condition|)
name|md_number_to_chars
argument_list|(
name|untruth
operator|->
name|word_goes_here
argument_list|,
name|to_addr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Install the long jump */
comment|/* this is a long jump from table_ptr+0 to the final target */
name|from_addr
operator|=
name|table_addr
expr_stmt|;
name|to_addr
operator|=
name|S_GET_VALUE
argument_list|(
name|lie
operator|->
name|add
argument_list|)
operator|+
name|lie
operator|->
name|addnum
expr_stmt|;
name|md_create_long_jump
argument_list|(
name|table_ptr
argument_list|,
name|from_addr
argument_list|,
name|to_addr
argument_list|,
name|lie
operator|->
name|dispfrag
argument_list|,
name|lie
operator|->
name|add
argument_list|)
expr_stmt|;
name|table_ptr
operator|+=
name|md_long_jump_size
expr_stmt|;
name|table_addr
operator|+=
name|md_long_jump_size
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* not WORKING_DOT_WORD */
ifndef|#
directive|ifndef
name|OBJ_VMS
block|{
comment|/* not vms */
comment|/* 		 * Scan every FixS performing fixups. We had to wait until now to do 		 * this because md_convert_frag() may have made some fixSs. 		 */
name|H_SET_RELOCATION_SIZE
argument_list|(
operator|&
name|headers
argument_list|,
name|md_reloc_size
operator|*
name|fixup_segment
argument_list|(
name|text_fix_root
argument_list|,
name|SEG_TEXT
argument_list|)
argument_list|,
name|md_reloc_size
operator|*
name|fixup_segment
argument_list|(
name|data_fix_root
argument_list|,
name|SEG_DATA
argument_list|)
argument_list|)
expr_stmt|;
name|obj_pre_write_hook
argument_list|(
operator|&
name|headers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|had_warnings
argument_list|()
operator|&&
name|flagseen
index|[
literal|'Z'
index|]
operator|)
operator|||
name|had_errors
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|flagseen
index|[
literal|'Z'
index|]
condition|)
block|{
name|as_warn
argument_list|(
literal|"%d error%s, %d warning%s, generating bad object file.\n"
argument_list|,
name|had_errors
argument_list|()
argument_list|,
name|had_errors
argument_list|()
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|had_warnings
argument_list|()
argument_list|,
name|had_warnings
argument_list|()
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_fatal
argument_list|(
literal|"%d error%s, %d warning%s, no object file generated.\n"
argument_list|,
name|had_errors
argument_list|()
argument_list|,
name|had_errors
argument_list|()
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|had_warnings
argument_list|()
argument_list|,
name|had_warnings
argument_list|()
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
comment|/* on want output */
block|}
comment|/* on error condition */
name|object_file_size
operator|=
name|H_GET_FILE_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
expr_stmt|;
name|next_object_file_charP
operator|=
name|the_object_file
operator|=
name|xmalloc
argument_list|(
name|object_file_size
argument_list|)
expr_stmt|;
name|output_file_create
argument_list|(
name|out_file_name
argument_list|)
expr_stmt|;
name|obj_header_append
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
operator|&
name|headers
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|(
name|next_object_file_charP
operator|-
name|the_object_file
operator|)
operator|==
name|H_GET_HEADER_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Emit code. 		 */
for|for
control|(
name|fragP
operator|=
name|text_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
specifier|register
name|long
name|count
decl_stmt|;
specifier|register
name|char
modifier|*
name|fill_literal
decl_stmt|;
specifier|register
name|long
name|fill_size
decl_stmt|;
name|know
argument_list|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_fill
argument_list|)
expr_stmt|;
name|append
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
name|fragP
operator|->
name|fr_literal
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|fragP
operator|->
name|fr_fix
argument_list|)
expr_stmt|;
name|fill_literal
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|fill_size
operator|=
name|fragP
operator|->
name|fr_var
expr_stmt|;
name|know
argument_list|(
name|fragP
operator|->
name|fr_offset
operator|>=
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
name|fragP
operator|->
name|fr_offset
init|;
name|count
condition|;
name|count
operator|--
control|)
block|{
name|append
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
name|fill_literal
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|fill_size
argument_list|)
expr_stmt|;
block|}
comment|/* for each  */
block|}
comment|/* for each code frag. */
name|know
argument_list|(
operator|(
name|next_object_file_charP
operator|-
name|the_object_file
operator|)
operator|==
operator|(
name|H_GET_HEADER_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_TEXT_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_DATA_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Emit relocations. 		 */
name|obj_emit_relocations
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
name|text_fix_root
argument_list|,
operator|(
name|relax_addressT
operator|)
literal|0
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|(
name|next_object_file_charP
operator|-
name|the_object_file
operator|)
operator|==
operator|(
name|H_GET_HEADER_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_TEXT_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_DATA_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_TEXT_RELOCATION_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_I960
comment|/* Make addresses in data relocation directives relative to beginning of 		 * first data fragment, not end of last text fragment:  alignment of the 		 * start of the data segment may place a gap between the segments. 		 */
name|obj_emit_relocations
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
name|data_fix_root
argument_list|,
name|data0_frchainP
operator|->
name|frch_root
operator|->
name|fr_address
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* TC_I960 */
name|obj_emit_relocations
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
name|data_fix_root
argument_list|,
name|text_last_frag
operator|->
name|fr_address
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TC_I960 */
name|know
argument_list|(
operator|(
name|next_object_file_charP
operator|-
name|the_object_file
operator|)
operator|==
operator|(
name|H_GET_HEADER_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_TEXT_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_DATA_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_TEXT_RELOCATION_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_DATA_RELOCATION_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Emit line number entries. 		 */
name|OBJ_EMIT_LINENO
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
name|lineno_rootP
argument_list|,
name|the_object_file
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|(
name|next_object_file_charP
operator|-
name|the_object_file
operator|)
operator|==
operator|(
name|H_GET_HEADER_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_TEXT_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_DATA_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_TEXT_RELOCATION_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_DATA_RELOCATION_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_LINENO_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Emit symbols. 		 */
name|obj_emit_symbols
argument_list|(
operator|&
name|next_object_file_charP
argument_list|,
name|symbol_rootP
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|(
name|next_object_file_charP
operator|-
name|the_object_file
operator|)
operator|==
operator|(
name|H_GET_HEADER_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_TEXT_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_DATA_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_TEXT_RELOCATION_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_DATA_RELOCATION_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_LINENO_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|+
name|H_GET_SYMBOL_TABLE_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Emit strings. 		 */
if|if
condition|(
name|string_byte_count
operator|>
literal|0
condition|)
block|{
name|obj_emit_strings
argument_list|(
operator|&
name|next_object_file_charP
argument_list|)
expr_stmt|;
block|}
comment|/* only if we have a string table */
comment|/*	  know((next_object_file_charP - the_object_file) == (H_GET_HEADER_SIZE(&headers) + H_GET_TEXT_SIZE(&headers) + H_GET_DATA_SIZE(&headers) + H_GET_TEXT_RELOCATION_SIZE(&headers) + H_GET_DATA_RELOCATION_SIZE(&headers) + H_GET_LINENO_SIZE(&headers) + H_GET_SYMBOL_TABLE_SIZE(&headers) + H_GET_STRING_SIZE(&headers))); 		 */
comment|/*	  know(next_object_file_charP == the_object_file + object_file_size);*/
ifdef|#
directive|ifdef
name|BFD_HEADERS
name|bfd_seek
argument_list|(
name|stdoutput
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
name|the_object_file
argument_list|,
literal|1
argument_list|,
name|object_file_size
argument_list|,
name|stdoutput
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Write the data to the file */
name|output_file_append
argument_list|(
name|the_object_file
argument_list|,
name|object_file_size
argument_list|,
name|out_file_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|output_file_close
argument_list|(
name|out_file_name
argument_list|)
expr_stmt|;
block|}
comment|/* non vms output */
else|#
directive|else
comment|/* OBJ_VMS */
comment|/* 	 *	Now do the VMS-dependent part of writing the object file 	 */
name|VMS_write_object_file
argument_list|(
name|H_GET_TEXT_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
argument_list|,
name|H_GET_DATA_SIZE
argument_list|(
operator|&
name|headers
argument_list|)
argument_list|,
name|text_frag_root
argument_list|,
name|data_frag_root
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_VMS */
block|}
end_function

begin_comment
comment|/* write_object_file() */
end_comment

begin_else
else|#
directive|else
end_else

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *			relax_segment()  *  * Now we have a segment, not a crowd of sub-segments, we can make fr_address  * values.  *  * Relax the frags.  *  * After this, all frags in this segment have addresses that are correct  * within the segment. Since segments live in different file addresses,  * these frag addresses may not be the same as final object-file addresses.  */
end_comment

begin_function
name|void
name|relax_segment
parameter_list|(
name|segment_frag_root
parameter_list|,
name|segment
parameter_list|)
name|struct
name|frag
modifier|*
name|segment_frag_root
decl_stmt|;
name|segT
name|segment
decl_stmt|;
comment|/* SEG_DATA or SEG_TEXT */
block|{
specifier|register
name|struct
name|frag
modifier|*
name|fragP
decl_stmt|;
specifier|register
name|relax_addressT
name|address
decl_stmt|;
comment|/* register relax_addressT	old_address; JF unused */
comment|/* register relax_addressT	new_address; JF unused */
ifndef|#
directive|ifndef
name|MANY_SEGMENTS
name|know
argument_list|(
name|segment
operator|==
name|SEG_DATA
operator|||
name|segment
operator|==
name|SEG_TEXT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* In case md_estimate_size_before_relax() wants to make fixSs. */
name|subseg_change
argument_list|(
name|segment
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * For each frag in segment: count and store  (a 1st guess of) fr_address. 	 */
name|address
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fragP
operator|=
name|segment_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
name|fragP
operator|->
name|fr_address
operator|=
name|address
expr_stmt|;
name|address
operator|+=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_type
condition|)
block|{
case|case
name|rs_fill
case|:
name|address
operator|+=
name|fragP
operator|->
name|fr_offset
operator|*
name|fragP
operator|->
name|fr_var
expr_stmt|;
break|break;
case|case
name|rs_align
case|:
name|address
operator|+=
name|relax_align
argument_list|(
name|address
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|rs_org
case|:
comment|/* 			 * Assume .org is nugatory. It will grow with 1st relax. 			 */
break|break;
case|case
name|rs_machine_dependent
case|:
name|address
operator|+=
name|md_estimate_size_before_relax
argument_list|(
name|fragP
argument_list|,
name|segment
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
comment|/* Broken words don't concern us yet */
case|case
name|rs_broken_word
case|:
break|break;
endif|#
directive|endif
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_type
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch (fr_type) */
block|}
comment|/* for each frag in the segment */
comment|/* 	 * Do relax(). 	 */
block|{
specifier|register
name|long
name|stretch
decl_stmt|;
comment|/* May be any size, 0 or negative. */
comment|/* Cumulative number of addresses we have */
comment|/* relaxed this pass. */
comment|/* We may have relaxed more than one address. */
specifier|register
name|long
name|stretched
decl_stmt|;
comment|/* Have we stretched on this pass? */
comment|/* This is 'cuz stretch may be zero, when, 		   in fact some piece of code grew, and 		   another shrank.  If a branch instruction 		   doesn't fit anymore, we could be scrod */
do|do
block|{
name|stretch
operator|=
name|stretched
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fragP
operator|=
name|segment_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
specifier|register
name|long
name|growth
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|long
name|was_address
decl_stmt|;
specifier|register
name|long
name|offset
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
specifier|register
name|long
name|target
decl_stmt|;
specifier|register
name|long
name|after
decl_stmt|;
specifier|register
name|long
name|aim
decl_stmt|;
name|was_address
operator|=
name|fragP
operator|->
name|fr_address
expr_stmt|;
name|address
operator|=
name|fragP
operator|->
name|fr_address
operator|+=
name|stretch
expr_stmt|;
name|symbolP
operator|=
name|fragP
operator|->
name|fr_symbol
expr_stmt|;
name|offset
operator|=
name|fragP
operator|->
name|fr_offset
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_type
condition|)
block|{
case|case
name|rs_fill
case|:
comment|/* .fill never relaxes. */
name|growth
operator|=
literal|0
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
comment|/* JF:  This is RMS's idea.  I do *NOT* want to be blamed 					   for it I do not want to write it.  I do not want to have 					   anything to do with it.  This is not the proper way to 					   implement this misfeature. */
case|case
name|rs_broken_word
case|:
block|{
name|struct
name|broken_word
modifier|*
name|lie
decl_stmt|;
name|struct
name|broken_word
modifier|*
name|untruth
decl_stmt|;
comment|/* Yes this is ugly (storing the broken_word pointer 					   in the symbol slot).  Still, this whole chunk of 					   code is ugly, and I don't feel like doing anything 					   about it.  Think of it as stubbornness in action */
name|growth
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lie
operator|=
operator|(
expr|struct
name|broken_word
operator|*
operator|)
operator|(
name|fragP
operator|->
name|fr_symbol
operator|)
init|;
name|lie
operator|&&
name|lie
operator|->
name|dispfrag
operator|==
name|fragP
condition|;
name|lie
operator|=
name|lie
operator|->
name|next_broken_word
control|)
block|{
if|if
condition|(
name|lie
operator|->
name|added
condition|)
continue|continue;
name|offset
operator|=
name|lie
operator|->
name|add
operator|->
name|sy_frag
operator|->
name|fr_address
operator|+
name|S_GET_VALUE
argument_list|(
name|lie
operator|->
name|add
argument_list|)
operator|+
name|lie
operator|->
name|addnum
operator|-
operator|(
name|lie
operator|->
name|sub
operator|->
name|sy_frag
operator|->
name|fr_address
operator|+
name|S_GET_VALUE
argument_list|(
name|lie
operator|->
name|sub
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<=
operator|-
literal|32768
operator|||
name|offset
operator|>=
literal|32767
condition|)
block|{
if|#
directive|if
literal|0
block|if (flagseen['K']) 							    as_warn(".word %s-%s+%ld didn't fit", 								    S_GET_NAME(lie->add), 								    S_GET_NAME(lie->sub), 								    lie->addnum);
endif|#
directive|endif
name|lie
operator|->
name|added
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_subtype
operator|==
literal|0
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|++
expr_stmt|;
name|growth
operator|+=
name|md_short_jump_size
expr_stmt|;
block|}
for|for
control|(
name|untruth
operator|=
name|lie
operator|->
name|next_broken_word
init|;
name|untruth
operator|&&
name|untruth
operator|->
name|dispfrag
operator|==
name|lie
operator|->
name|dispfrag
condition|;
name|untruth
operator|=
name|untruth
operator|->
name|next_broken_word
control|)
if|if
condition|(
operator|(
name|untruth
operator|->
name|add
operator|->
name|sy_frag
operator|==
name|lie
operator|->
name|add
operator|->
name|sy_frag
operator|)
operator|&&
name|S_GET_VALUE
argument_list|(
name|untruth
operator|->
name|add
argument_list|)
operator|==
name|S_GET_VALUE
argument_list|(
name|lie
operator|->
name|add
argument_list|)
condition|)
block|{
name|untruth
operator|->
name|added
operator|=
literal|2
expr_stmt|;
name|untruth
operator|->
name|use_jump
operator|=
name|lie
expr_stmt|;
block|}
name|growth
operator|+=
name|md_long_jump_size
expr_stmt|;
block|}
block|}
break|break;
block|}
comment|/* case rs_broken_word */
endif|#
directive|endif
case|case
name|rs_align
case|:
name|growth
operator|=
name|relax_align
argument_list|(
call|(
name|relax_addressT
call|)
argument_list|(
name|address
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|)
argument_list|,
name|offset
argument_list|)
operator|-
name|relax_align
argument_list|(
call|(
name|relax_addressT
call|)
argument_list|(
name|was_address
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|rs_org
case|:
name|target
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|symbolP
condition|)
block|{
ifdef|#
directive|ifdef
name|MANY_SEGMENTS
else|#
directive|else
name|know
argument_list|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_ABSOLUTE
operator|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_DATA
operator|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_TEXT
operator|)
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|symbolP
operator|->
name|sy_frag
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|!
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_ABSOLUTE
operator|)
operator|||
operator|(
name|symbolP
operator|->
name|sy_frag
operator|==
operator|&
name|zero_address_frag
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|target
operator|+=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|+
name|symbolP
operator|->
name|sy_frag
operator|->
name|fr_address
expr_stmt|;
block|}
comment|/* if we have a symbol */
name|know
argument_list|(
name|fragP
operator|->
name|fr_next
argument_list|)
expr_stmt|;
name|after
operator|=
name|fragP
operator|->
name|fr_next
operator|->
name|fr_address
expr_stmt|;
name|growth
operator|=
operator|(
operator|(
name|target
operator|-
name|after
operator|)
operator|>
literal|0
operator|)
condition|?
operator|(
name|target
operator|-
name|after
operator|)
else|:
literal|0
expr_stmt|;
comment|/* Growth may be -ve, but variable part */
comment|/* of frag cannot have< 0 chars. */
comment|/* That is, we can't .org backwards. */
name|growth
operator|-=
name|stretch
expr_stmt|;
comment|/* This is an absolute growth factor */
break|break;
case|case
name|rs_machine_dependent
case|:
block|{
specifier|register
specifier|const
name|relax_typeS
modifier|*
name|this_type
decl_stmt|;
specifier|register
specifier|const
name|relax_typeS
modifier|*
name|start_type
decl_stmt|;
specifier|register
name|relax_substateT
name|next_state
decl_stmt|;
specifier|register
name|relax_substateT
name|this_state
decl_stmt|;
name|start_type
operator|=
name|this_type
operator|=
name|md_relax_table
operator|+
operator|(
name|this_state
operator|=
name|fragP
operator|->
name|fr_subtype
operator|)
expr_stmt|;
name|target
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|symbolP
condition|)
block|{
ifndef|#
directive|ifndef
name|MANY_SEGMENTS
name|know
argument_list|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_ABSOLUTE
operator|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_DATA
operator|)
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_TEXT
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|know
argument_list|(
name|symbolP
operator|->
name|sy_frag
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|!
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_ABSOLUTE
operator|)
operator|||
name|symbolP
operator|->
name|sy_frag
operator|==
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|target
operator|+=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|+
name|symbolP
operator|->
name|sy_frag
operator|->
name|fr_address
expr_stmt|;
comment|/* If frag has yet to be reached on this pass, 						   assume it will move by STRETCH just as we did. 						   If this is not so, it will be because some frag 						   between grows, and that will force another pass.  */
comment|/* JF was just address */
comment|/* JF also added is_dnrange hack */
comment|/* There's gotta be a better/faster/etc way 						   to do this... */
comment|/* gnu@cygnus.com:  I changed this from> to>= 						   because I ran into a zero-length frag (fr_fix=0) 						   which was created when the obstack needed a new 						   chunk JUST AFTER the opcode of a branch.  Since 						   fr_fix is zero, fr_address of this frag is the same 						   as fr_address of the next frag.  This 						   zero-length frag was variable and jumped to .+2 						   (in the next frag), but since the> comparison 						   below failed (the two were =, not>), "stretch" 						   was not added to the target.  Stretch was 178, so 						   the offset appeared to be .-176 instead, which did 						   not fit into a byte branch, so the assembler 						   relaxed the branch to a word.  This didn't compare 						   with what happened when the same source file was 						   assembled on other machines, which is how I found it. 						   You might want to think about what other places have 						   trouble with zero length frags... */
if|if
condition|(
name|symbolP
operator|->
name|sy_frag
operator|->
name|fr_address
operator|>=
name|was_address
operator|&&
name|is_dnrange
argument_list|(
name|fragP
argument_list|,
name|symbolP
operator|->
name|sy_frag
argument_list|)
condition|)
block|{
name|target
operator|+=
name|stretch
expr_stmt|;
block|}
comment|/*  */
block|}
comment|/* if there's a symbol attached */
name|aim
operator|=
name|target
operator|-
name|address
operator|-
name|fragP
operator|->
name|fr_fix
expr_stmt|;
comment|/* The displacement is affected by the instruction size 					 * for the 32k architecture. I think we ought to be able 					 * to add fragP->fr_pcrel_adjust in all cases (it should be 					 * zero if not used), but just in case it breaks something 					 * else we'll put this inside #ifdef NS32K ... #endif 					 */
ifdef|#
directive|ifdef
name|TC_NS32K
name|aim
operator|+=
name|fragP
operator|->
name|fr_pcrel_adjust
expr_stmt|;
endif|#
directive|endif
comment|/* TC_NS32K */
if|if
condition|(
name|aim
operator|<
literal|0
condition|)
block|{
comment|/* Look backwards. */
for|for
control|(
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
init|;
name|next_state
condition|;
control|)
block|{
if|if
condition|(
name|aim
operator|>=
name|this_type
operator|->
name|rlx_backward
condition|)
block|{
name|next_state
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Grow to next state. */
name|this_type
operator|=
name|md_relax_table
operator|+
operator|(
name|this_state
operator|=
name|next_state
operator|)
expr_stmt|;
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DONTDEF
comment|/* JF these next few lines of code are for the mc68020 which can't handle short 						   offsets of zero in branch instructions.  What a kludge! */
if|if
condition|(
name|aim
operator|==
literal|0
operator|&&
name|this_state
operator|==
operator|(
literal|1
operator|<<
literal|2
operator|+
literal|0
operator|)
condition|)
block|{
comment|/* FOO hard encoded from m.c */
name|aim
operator|=
name|this_type
operator|->
name|rlx_forward
operator|+
literal|1
expr_stmt|;
comment|/* Force relaxation into word mode */
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|M68K_AIM_KLUDGE
name|M68K_AIM_KLUDGE
argument_list|(
name|aim
argument_list|,
name|this_state
argument_list|,
name|this_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* JF end of 68020 code */
comment|/* Look forwards. */
for|for
control|(
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
init|;
name|next_state
condition|;
control|)
block|{
if|if
condition|(
name|aim
operator|<=
name|this_type
operator|->
name|rlx_forward
condition|)
block|{
name|next_state
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Grow to next state. */
name|this_type
operator|=
name|md_relax_table
operator|+
operator|(
name|this_state
operator|=
name|next_state
operator|)
expr_stmt|;
name|next_state
operator|=
name|this_type
operator|->
name|rlx_more
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|growth
operator|=
name|this_type
operator|->
name|rlx_length
operator|-
name|start_type
operator|->
name|rlx_length
operator|)
operator|!=
literal|0
condition|)
name|fragP
operator|->
name|fr_subtype
operator|=
name|this_state
expr_stmt|;
break|break;
block|}
comment|/* case rs_machine_dependent */
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|growth
condition|)
block|{
name|stretch
operator|+=
name|growth
expr_stmt|;
name|stretched
operator|++
expr_stmt|;
block|}
block|}
comment|/* For each frag in the segment. */
block|}
do|while
condition|(
name|stretched
condition|)
do|;
comment|/* Until nothing further to relax. */
block|}
comment|/* do_relax */
comment|/* 	 * We now have valid fr_address'es for each frag. 	 */
comment|/* 	 * All fr_address's are correct, relative to their own segment. 	 * We have made all the fixS we will ever make. 	 */
block|}
end_function

begin_comment
comment|/* relax_segment() */
end_comment

begin_comment
comment|/*  * Relax_align. Advance location counter to next address that has 'alignment'  * lowest order bits all 0s.  */
end_comment

begin_comment
comment|/* How many addresses does the .align take? */
end_comment

begin_function
specifier|static
name|relax_addressT
name|relax_align
parameter_list|(
name|address
parameter_list|,
name|alignment
parameter_list|)
specifier|register
name|relax_addressT
name|address
decl_stmt|;
comment|/* Address now. */
specifier|register
name|long
name|alignment
decl_stmt|;
comment|/* Alignment (binary). */
block|{
name|relax_addressT
name|mask
decl_stmt|;
name|relax_addressT
name|new_address
decl_stmt|;
name|mask
operator|=
operator|~
operator|(
operator|(
operator|~
literal|0
operator|)
operator|<<
name|alignment
operator|)
expr_stmt|;
name|new_address
operator|=
operator|(
name|address
operator|+
name|mask
operator|)
operator|&
operator|(
operator|~
name|mask
operator|)
expr_stmt|;
return|return
operator|(
name|new_address
operator|-
name|address
operator|)
return|;
block|}
end_function

begin_comment
comment|/* relax_align() */
end_comment

begin_comment
comment|/* fixup_segment()     Go through all the fixS's in a segment and see which ones can be    handled now.  (These consist of fixS where we have since discovered    the value of a symbol, or the address of the frag involved.)    For each one, call md_apply_fix to put the fix into the frag data.     Result is a count of how many relocation structs will be needed to    handle the remaining fixS's that we couldn't completely handle here.    These will be output later by emit_relocations().  */
end_comment

begin_function
specifier|static
name|long
name|fixup_segment
parameter_list|(
name|fixP
parameter_list|,
name|this_segment_type
parameter_list|)
specifier|register
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|segT
name|this_segment_type
decl_stmt|;
comment|/* N_TYPE bits for segment. */
block|{
specifier|register
name|long
name|seg_reloc_count
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|add_symbolP
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|sub_symbolP
decl_stmt|;
specifier|register
name|long
name|add_number
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
specifier|register
name|char
modifier|*
name|place
decl_stmt|;
specifier|register
name|long
name|where
decl_stmt|;
specifier|register
name|char
name|pcrel
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
specifier|register
name|segT
name|add_symbol_segment
init|=
name|SEG_ABSOLUTE
decl_stmt|;
comment|/* FIXME: remove this line */
comment|/*	fixS *orig = fixP; */
name|seg_reloc_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
block|{
name|fragP
operator|=
name|fixP
operator|->
name|fx_frag
expr_stmt|;
name|know
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
name|where
operator|=
name|fixP
operator|->
name|fx_where
expr_stmt|;
name|place
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|where
expr_stmt|;
name|size
operator|=
name|fixP
operator|->
name|fx_size
expr_stmt|;
name|add_symbolP
operator|=
name|fixP
operator|->
name|fx_addsy
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_I960
if|if
condition|(
name|fixP
operator|->
name|fx_callj
operator|&&
name|TC_S_IS_CALLNAME
argument_list|(
name|add_symbolP
argument_list|)
condition|)
block|{
comment|/* Relocation should be done via the 			   associated 'bal' entry point 			   symbol. */
if|if
condition|(
operator|!
name|TC_S_IS_BALNAME
argument_list|(
name|tc_get_bal_of_call
argument_list|(
name|add_symbolP
argument_list|)
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"No 'bal' entry point for leafproc %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|add_symbolP
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fixP
operator|->
name|fx_addsy
operator|=
name|add_symbolP
operator|=
name|tc_get_bal_of_call
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
block|}
comment|/* callj relocation */
endif|#
directive|endif
name|sub_symbolP
operator|=
name|fixP
operator|->
name|fx_subsy
expr_stmt|;
name|add_number
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
name|pcrel
operator|=
name|fixP
operator|->
name|fx_pcrel
expr_stmt|;
if|if
condition|(
name|add_symbolP
condition|)
block|{
name|add_symbol_segment
operator|=
name|S_GET_SEGMENT
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
block|}
comment|/* if there is an addend */
if|if
condition|(
name|sub_symbolP
condition|)
block|{
if|if
condition|(
operator|!
name|add_symbolP
condition|)
block|{
comment|/* Its just -sym */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|sub_symbolP
argument_list|)
operator|!=
name|SEG_ABSOLUTE
condition|)
block|{
name|as_bad
argument_list|(
literal|"Negative of non-absolute symbol %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|sub_symbolP
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* not absolute */
name|add_number
operator|-=
name|S_GET_VALUE
argument_list|(
name|sub_symbolP
argument_list|)
expr_stmt|;
comment|/* if sub_symbol is in the same segment that add_symbol 				   and add_symbol is either in DATA, TEXT, BSS or ABSOLUTE */
block|}
elseif|else
if|if
condition|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|sub_symbolP
argument_list|)
operator|==
name|add_symbol_segment
operator|)
operator|&&
operator|(
name|SEG_NORMAL
argument_list|(
name|add_symbol_segment
argument_list|)
operator|||
operator|(
name|add_symbol_segment
operator|==
name|SEG_ABSOLUTE
operator|)
operator|)
condition|)
block|{
comment|/* Difference of 2 symbols from same segment. */
comment|/* Can't make difference of 2 undefineds: 'value' means */
comment|/* something different for N_UNDF. */
ifdef|#
directive|ifdef
name|TC_I960
comment|/* Makes no sense to use the difference of 2 arbitrary symbols 				 * as the target of a call instruction. 				 */
if|if
condition|(
name|fixP
operator|->
name|fx_callj
condition|)
block|{
name|as_bad
argument_list|(
literal|"callj to difference of 2 symbols"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TC_I960 */
ifdef|#
directive|ifdef
name|PIC
if|if
condition|(
name|picmode
operator|&&
name|S_IS_EXTERNAL
argument_list|(
name|add_symbolP
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Can't reduce difference of external symbols in PIC code"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|sub_symbolP
argument_list|)
expr_stmt|;
name|add_symbolP
operator|=
name|NULL
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Different segments in subtraction. */
name|know
argument_list|(
operator|!
operator|(
name|S_IS_EXTERNAL
argument_list|(
name|sub_symbolP
argument_list|)
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|sub_symbolP
argument_list|)
operator|==
name|SEG_ABSOLUTE
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|sub_symbolP
argument_list|)
operator|==
name|SEG_ABSOLUTE
operator|)
condition|)
block|{
name|add_number
operator|-=
name|S_GET_VALUE
argument_list|(
name|sub_symbolP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|"Can't emit reloc {- %s-seg symbol \"%s\"} @ file address %d."
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|sub_symbolP
argument_list|)
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sub_symbolP
argument_list|)
argument_list|,
name|fragP
operator|->
name|fr_address
operator|+
name|where
argument_list|)
expr_stmt|;
block|}
comment|/* if absolute */
block|}
block|}
comment|/* if sub_symbolP */
ifdef|#
directive|ifdef
name|PIC
comment|/* 		 * Bring _GLOBAL_OFFSET_TABLE_ forward, now we've had the 		 * chance to collapse any accompanying symbols into a number. 		 * This is the sequel of the hack in expr.c to parse operands 		 * of the form `_GLOBAL_OFFSET_TABLE_+(L1-L2)'. Note that 		 * _GLOBAL_OFFSET_TABLE_ can only be an "add symbol". 		 */
if|if
condition|(
name|add_symbolP
operator|==
name|NULL
operator|&&
name|fixP
operator|->
name|fx_gotsy
operator|!=
name|NULL
condition|)
block|{
name|add_symbolP
operator|=
name|fixP
operator|->
name|fx_addsy
operator|=
name|fixP
operator|->
name|fx_gotsy
expr_stmt|;
name|add_symbol_segment
operator|=
name|S_GET_SEGMENT
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|add_symbolP
condition|)
block|{
if|if
condition|(
name|add_symbol_segment
operator|==
name|this_segment_type
operator|&&
name|pcrel
condition|)
block|{
comment|/* 				 * This fixup was made when the symbol's segment was 				 * SEG_UNKNOWN, but it is now in the local segment. 				 * So we know how to do the address without relocation. 				 */
ifdef|#
directive|ifdef
name|TC_I960
comment|/* reloc_callj() may replace a 'call' with a 'calls' or a 'bal', 				 * in which cases it modifies *fixP as appropriate.  In the case 				 * of a 'calls', no further work is required, and *fixP has been 				 * set up to make the rest of the code below a no-op. 				 */
name|reloc_callj
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TC_I960 */
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
name|add_number
operator|-=
name|md_pcrel_from
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
name|pcrel
operator|=
literal|0
expr_stmt|;
comment|/* Lie. Don't want further pcrel processing. */
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
comment|/* No relocations please. */
block|}
else|else
block|{
switch|switch
condition|(
name|add_symbol_segment
condition|)
block|{
case|case
name|SEG_ABSOLUTE
case|:
ifdef|#
directive|ifdef
name|TC_I960
name|reloc_callj
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
comment|/* See comment about reloc_callj() above*/
endif|#
directive|endif
comment|/* TC_I960 */
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
name|add_symbolP
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|seg_reloc_count
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|PIC
comment|/* 					 * Do not fixup refs to global data 					 * even if defined here. 					 */
if|if
condition|(
operator|!
name|picmode
operator|||
ifdef|#
directive|ifdef
name|TC_NS32K
name|fixP
operator|->
name|fx_pcrel
operator|||
endif|#
directive|endif
operator|(
name|fixP
operator|->
name|fx_r_type
operator|!=
name|RELOC_GLOB_DAT
operator|&&
ifdef|#
directive|ifdef
name|TC_I386
comment|/* XXX - This must be rationalized */
name|fixP
operator|->
name|fx_r_type
operator|!=
name|RELOC_GOT
operator|&&
name|fixP
operator|->
name|fx_r_type
operator|!=
name|RELOC_GOTOFF
operator|&&
endif|#
directive|endif
operator|(
name|fixP
operator|->
name|fx_r_type
operator|!=
name|RELOC_32
operator|||
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|add_symbolP
argument_list|)
operator|)
operator|)
condition|)
endif|#
directive|endif
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEG_UNKNOWN
case|:
ifdef|#
directive|ifdef
name|TC_I960
if|if
condition|(
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_bit_fixP
operator|==
literal|13
condition|)
block|{
comment|/* This is a COBR instruction.  They have only a 						 * 13-bit displacement and are only to be used 						 * for local branches: flag as error, don't generate 						 * relocation. 						 */
name|as_bad
argument_list|(
literal|"can't use COBR format with external label"
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
comment|/* No relocations please. */
continue|continue;
block|}
comment|/* COBR */
endif|#
directive|endif
comment|/* TC_I960 */
ifdef|#
directive|ifdef
name|OBJ_COFF
ifdef|#
directive|ifdef
name|TE_I386AIX
if|if
condition|(
name|S_IS_COMMON
argument_list|(
name|add_symbolP
argument_list|)
condition|)
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TE_I386AIX */
endif|#
directive|endif
comment|/* OBJ_COFF */
operator|++
name|seg_reloc_count
expr_stmt|;
break|break;
block|}
comment|/* switch on symbol seg */
block|}
comment|/* if not in local seg */
block|}
comment|/* if there was a + symbol */
if|if
condition|(
name|pcrel
condition|)
block|{
name|add_number
operator|-=
name|md_pcrel_from
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_symbolP
operator|==
literal|0
condition|)
block|{
name|fixP
operator|->
name|fx_addsy
operator|=
operator|&
name|abs_symbol
expr_stmt|;
operator|++
name|seg_reloc_count
expr_stmt|;
block|}
comment|/* if there's an add_symbol */
block|}
comment|/* if pcrel */
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_bit_fixP
condition|)
block|{
if|if
condition|(
operator|(
name|size
operator|==
literal|1
operator|&&
operator|(
name|add_number
operator|&
operator|~
literal|0xFF
operator|)
operator|&&
operator|(
name|add_number
operator|&
operator|~
literal|0xFF
operator|!=
operator|(
operator|-
literal|1
operator|&
operator|~
literal|0xFF
operator|)
operator|)
operator|)
operator|||
operator|(
name|size
operator|==
literal|2
operator|&&
operator|(
name|add_number
operator|&
operator|~
literal|0xFFFF
operator|)
operator|&&
operator|(
name|add_number
operator|&
operator|~
literal|0xFFFF
operator|!=
operator|(
operator|-
literal|1
operator|&
operator|~
literal|0xFFFF
operator|)
operator|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Value of %d too large for field of %d bytes at 0x%x"
argument_list|,
name|add_number
argument_list|,
name|size
argument_list|,
name|fragP
operator|->
name|fr_address
operator|+
name|where
argument_list|)
expr_stmt|;
block|}
comment|/* generic error checking */
block|}
comment|/* not a bit fix */
name|md_apply_fix
argument_list|(
name|fixP
argument_list|,
name|add_number
argument_list|)
expr_stmt|;
block|}
comment|/* For each fixS in this segment. */
ifdef|#
directive|ifdef
name|OBJ_COFF
ifdef|#
directive|ifdef
name|TC_I960
block|{
name|fixS
modifier|*
name|topP
init|=
name|fixP
decl_stmt|;
comment|/* two relocs per callj under coff. */
for|for
control|(
name|fixP
operator|=
name|topP
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_callj
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|!=
literal|0
condition|)
block|{
operator|++
name|seg_reloc_count
expr_stmt|;
block|}
comment|/* if callj and not already fixed. */
block|}
comment|/* for each fix */
block|}
endif|#
directive|endif
comment|/* TC_I960 */
endif|#
directive|endif
comment|/* OBJ_COFF */
return|return
operator|(
name|seg_reloc_count
operator|)
return|;
block|}
end_function

begin_comment
comment|/* fixup_segment() */
end_comment

begin_function
specifier|static
name|int
name|is_dnrange
parameter_list|(
name|f1
parameter_list|,
name|f2
parameter_list|)
name|struct
name|frag
modifier|*
name|f1
decl_stmt|;
name|struct
name|frag
modifier|*
name|f2
decl_stmt|;
block|{
while|while
condition|(
name|f1
condition|)
block|{
if|if
condition|(
name|f1
operator|->
name|fr_next
operator|==
name|f2
condition|)
return|return
literal|1
return|;
name|f1
operator|=
name|f1
operator|->
name|fr_next
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* is_dnrange() */
end_comment

begin_comment
comment|/* Append a string onto another string, bumping the pointer along.  */
end_comment

begin_function
name|void
name|append
parameter_list|(
name|charPP
parameter_list|,
name|fromP
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
modifier|*
name|charPP
decl_stmt|;
name|char
modifier|*
name|fromP
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
block|{
if|if
condition|(
name|length
condition|)
block|{
comment|/* Don't trust memcpy() of 0 chars. */
name|memcpy
argument_list|(
operator|*
name|charPP
argument_list|,
name|fromP
argument_list|,
operator|(
name|int
operator|)
name|length
argument_list|)
expr_stmt|;
operator|*
name|charPP
operator|+=
name|length
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|int
name|section_alignment
index|[
name|SEG_MAXIMUM_ORDINAL
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This routine records the largest alignment seen for each segment.  * If the beginning of the segment is aligned on the worst-case  * boundary, all of the other alignments within it will work.  At  * least one object format really uses this info.  */
end_comment

begin_function
name|void
name|record_alignment
parameter_list|(
name|seg
parameter_list|,
name|align
parameter_list|)
name|segT
name|seg
decl_stmt|;
comment|/* Segment to which alignment pertains */
name|int
name|align
decl_stmt|;
comment|/* Alignment, as a power of 2 		 *	(e.g., 1 => 2-byte boundary, 2 => 4-byte boundary, etc.) 		 */
block|{
if|if
condition|(
name|align
operator|>
name|section_alignment
index|[
operator|(
name|int
operator|)
name|seg
index|]
condition|)
block|{
name|section_alignment
index|[
operator|(
name|int
operator|)
name|seg
index|]
operator|=
name|align
expr_stmt|;
block|}
comment|/* if highest yet */
return|return;
block|}
end_function

begin_comment
comment|/* record_alignment() */
end_comment

begin_comment
comment|/*  * Local Variables:  * comment-column: 0  * fill-column: 131  * End:  */
end_comment

begin_comment
comment|/* end of write.c */
end_comment

end_unit

