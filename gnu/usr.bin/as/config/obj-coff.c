begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* coff object file format    Copyright (C) 1989, 1990, 1991, 1992 Free Software Foundation, Inc.     This file is part of GAS.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_decl_stmt
name|lineno
modifier|*
name|lineno_rootP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|short
name|seg_N_TYPE
index|[]
init|=
block|{
comment|/* in: segT   out: N_TYPE bits */
name|C_ABS_SECTION
block|,
name|C_TEXT_SECTION
block|,
name|C_DATA_SECTION
block|,
name|C_BSS_SECTION
block|,
name|C_UNDEF_SECTION
block|,
comment|/* SEG_UNKNOWN */
name|C_UNDEF_SECTION
block|,
comment|/* SEG_ABSENT */
name|C_UNDEF_SECTION
block|,
comment|/* SEG_PASS1 */
name|C_UNDEF_SECTION
block|,
comment|/* SEG_GOOF */
name|C_UNDEF_SECTION
block|,
comment|/* SEG_BIG */
name|C_UNDEF_SECTION
block|,
comment|/* SEG_DIFFERENCE */
name|C_DEBUG_SECTION
block|,
comment|/* SEG_DEBUG */
name|C_NTV_SECTION
block|,
comment|/* SEG_NTV */
name|C_PTV_SECTION
block|,
comment|/* SEG_PTV */
name|C_REGISTER_SECTION
block|,
comment|/* SEG_REGISTER */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add 4 to the real value to get the index and compensate the negatives */
end_comment

begin_decl_stmt
specifier|const
name|segT
name|N_TYPE_seg
index|[
literal|32
index|]
init|=
block|{
name|SEG_PTV
block|,
comment|/* C_PTV_SECTION == -4 */
name|SEG_NTV
block|,
comment|/* C_NTV_SECTION == -3 */
name|SEG_DEBUG
block|,
comment|/* C_DEBUG_SECTION == -2 */
name|SEG_ABSOLUTE
block|,
comment|/* C_ABS_SECTION == -1 */
name|SEG_UNKNOWN
block|,
comment|/* C_UNDEF_SECTION == 0 */
name|SEG_TEXT
block|,
comment|/* C_TEXT_SECTION == 1 */
name|SEG_DATA
block|,
comment|/* C_DATA_SECTION == 2 */
name|SEG_BSS
block|,
comment|/* C_BSS_SECTION == 3 */
name|SEG_REGISTER
block|,
comment|/* C_REGISTER_SECTION == 4 */
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|__STDC__
operator|==
literal|1
end_if

begin_function_decl
name|char
modifier|*
name|s_get_name
parameter_list|(
name|symbolS
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|symbolS
modifier|*
name|tag_find_or_make
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|symbolS
modifier|*
name|tag_find
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_HEADERS
end_ifdef

begin_function_decl
specifier|static
name|void
name|obj_coff_section_header_append
parameter_list|(
name|char
modifier|*
modifier|*
name|where
parameter_list|,
name|struct
name|internal_scnhdr
modifier|*
name|header
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|obj_coff_section_header_append
parameter_list|(
name|char
modifier|*
modifier|*
name|where
parameter_list|,
name|SCNHDR
modifier|*
name|header
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|obj_coff_def
parameter_list|(
name|int
name|what
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|obj_coff_dim
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|obj_coff_endef
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|obj_coff_line
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|obj_coff_ln
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|obj_coff_scl
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|obj_coff_size
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|obj_coff_stab
parameter_list|(
name|int
name|what
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|obj_coff_tag
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|obj_coff_type
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|obj_coff_val
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tag_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tag_insert
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|symbolS
modifier|*
name|symbolP
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not __STDC__ */
end_comment

begin_function_decl
name|char
modifier|*
name|s_get_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|symbolS
modifier|*
name|tag_find
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|symbolS
modifier|*
name|tag_find_or_make
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|obj_coff_section_header_append
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|obj_coff_def
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|obj_coff_dim
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|obj_coff_endef
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|obj_coff_line
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|obj_coff_ln
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|obj_coff_scl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|obj_coff_size
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|obj_coff_stab
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|obj_coff_tag
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|obj_coff_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|obj_coff_val
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tag_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tag_insert
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __STDC__ */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|tag_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|def_symbol_in_progress
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|obj_pseudo_table
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|IGNORE_DEBUG
block|{
literal|"def"
block|,
name|obj_coff_def
block|,
literal|0
block|}
block|,
block|{
literal|"dim"
block|,
name|obj_coff_dim
block|,
literal|0
block|}
block|,
block|{
literal|"endef"
block|,
name|obj_coff_endef
block|,
literal|0
block|}
block|,
block|{
literal|"line"
block|,
name|obj_coff_line
block|,
literal|0
block|}
block|,
block|{
literal|"ln"
block|,
name|obj_coff_ln
block|,
literal|0
block|}
block|,
block|{
literal|"scl"
block|,
name|obj_coff_scl
block|,
literal|0
block|}
block|,
block|{
literal|"size"
block|,
name|obj_coff_size
block|,
literal|0
block|}
block|,
block|{
literal|"tag"
block|,
name|obj_coff_tag
block|,
literal|0
block|}
block|,
block|{
literal|"type"
block|,
name|obj_coff_type
block|,
literal|0
block|}
block|,
block|{
literal|"val"
block|,
name|obj_coff_val
block|,
literal|0
block|}
block|,
else|#
directive|else
block|{
literal|"def"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"dim"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"endef"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"line"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"ln"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"scl"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"size"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"tag"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"type"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"val"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
endif|#
directive|endif
comment|/* ignore debug */
block|{
literal|"ident"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* we don't yet handle this. */
comment|/* stabs aka a.out aka b.out directives for debug symbols. 	   Currently ignored silently.  Except for .line at which 	   we guess from context. */
block|{
literal|"desc"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* def */
comment|/*	{ "line",	s_ignore,		0	}, */
comment|/* source code line number */
block|{
literal|"stabd"
block|,
name|obj_coff_stab
block|,
literal|'d'
block|}
block|,
comment|/* stabs */
block|{
literal|"stabn"
block|,
name|obj_coff_stab
block|,
literal|'n'
block|}
block|,
comment|/* stabs */
block|{
literal|"stabs"
block|,
name|obj_coff_stab
block|,
literal|'s'
block|}
block|,
comment|/* stabs */
comment|/* stabs-in-coff (?) debug pseudos (ignored) */
block|{
literal|"optim"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* For sun386i cc (?) */
comment|/* other stuff */
block|{
literal|"ABORT"
block|,
name|s_abort
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|}
comment|/* end sentinel */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* obj_pseudo_table */
end_comment

begin_comment
comment|/* obj dependant output values */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_HEADERS
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|internal_scnhdr
name|bss_section_header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|internal_scnhdr
name|data_section_header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|internal_scnhdr
name|text_section_header
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|SCNHDR
name|bss_section_header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SCNHDR
name|data_section_header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SCNHDR
name|text_section_header
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Relocation. */
end_comment

begin_function
specifier|static
name|int
name|reloc_compare
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
ifdef|#
directive|ifdef
name|BFD_HEADERS
name|struct
name|internal_reloc
modifier|*
name|p1
decl_stmt|,
decl|*
name|p2
decl_stmt|;
end_function

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|RELOC
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
return|return
call|(
name|int
call|)
argument_list|(
name|p1
operator|->
name|r_vaddr
operator|-
name|p2
operator|->
name|r_vaddr
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/*  *		emit_relocations()  *  * Crawl along a fixS chain. Emit the segment's relocations.  */
end_comment

begin_function
name|void
name|obj_emit_relocations
parameter_list|(
name|where
parameter_list|,
name|fixP
parameter_list|,
name|segment_address_in_file
parameter_list|)
name|char
modifier|*
modifier|*
name|where
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/* Fixup chain for this segment. */
name|relax_addressT
name|segment_address_in_file
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD_HEADERS
name|struct
name|internal_reloc
modifier|*
name|ri_table
decl_stmt|;
else|#
directive|else
name|RELOC
modifier|*
name|ri_table
decl_stmt|;
endif|#
directive|endif
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|fixS
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|p
operator|=
name|fixP
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|fx_next
control|)
if|if
condition|(
name|p
operator|->
name|fx_addsy
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|count
condition|)
return|return;
ifdef|#
directive|ifdef
name|BFD_HEADERS
name|ri_table
operator|=
operator|(
expr|struct
name|internal_reloc
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ri_table
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
else|#
directive|else
name|ri_table
operator|=
operator|(
name|RELOC
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ri_table
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ri_table
condition|)
name|as_fatal
argument_list|(
literal|"obj_emit_relocations: Could not malloc relocation table"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_I960
name|callj_table
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|callj_table
condition|)
name|as_fatal
argument_list|(
literal|"obj_emit_relocations: Could not malloc callj table"
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
block|{
if|if
condition|(
name|symbolP
operator|=
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|TC_M68K
argument_list|)
name|ri_table
index|[
name|i
index|]
operator|.
name|r_type
operator|=
operator|(
name|fixP
operator|->
name|fx_pcrel
condition|?
operator|(
name|fixP
operator|->
name|fx_size
operator|==
literal|1
condition|?
name|R_PCRBYTE
else|:
name|fixP
operator|->
name|fx_size
operator|==
literal|2
condition|?
name|R_PCRWORD
else|:
name|R_PCRLONG
operator|)
else|:
operator|(
name|fixP
operator|->
name|fx_size
operator|==
literal|1
condition|?
name|R_RELBYTE
else|:
name|fixP
operator|->
name|fx_size
operator|==
literal|2
condition|?
name|R_RELWORD
else|:
name|R_RELLONG
operator|)
operator|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|TC_I386
argument_list|)
comment|/* FIXME-SOON R_OFF8& R_DIR16 are a vague guess, completly 			   untested. */
name|ri_table
index|[
name|i
index|]
operator|.
name|r_type
operator|=
operator|(
name|fixP
operator|->
name|fx_pcrel
condition|?
operator|(
name|fixP
operator|->
name|fx_size
operator|==
literal|1
condition|?
name|R_PCRBYTE
else|:
name|fixP
operator|->
name|fx_size
operator|==
literal|2
condition|?
name|R_PCRWORD
else|:
name|R_PCRLONG
operator|)
else|:
operator|(
name|fixP
operator|->
name|fx_size
operator|==
literal|1
condition|?
name|R_OFF8
else|:
name|fixP
operator|->
name|fx_size
operator|==
literal|2
condition|?
name|R_DIR16
else|:
name|R_DIR32
operator|)
operator|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|TC_I960
argument_list|)
name|ri_table
index|[
name|i
index|]
operator|.
name|r_type
operator|=
operator|(
name|fixP
operator|->
name|fx_pcrel
condition|?
name|R_IPRMED
else|:
name|R_RELLONG
operator|)
expr_stmt|;
name|callj_table
index|[
name|i
index|]
operator|=
name|fixP
operator|->
name|fx_callj
condition|?
literal|1
else|:
literal|0
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|TC_A29K
argument_list|)
name|ri_table
index|[
name|i
index|]
operator|.
name|r_type
operator|=
name|tc_coff_fix2rtype
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
error|you lose
endif|#
directive|endif
comment|/* TC_M68K || TC_I386 */
name|ri_table
index|[
name|i
index|]
operator|.
name|r_vaddr
operator|=
operator|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|)
expr_stmt|;
comment|/* If symbol associated to relocation entry is a bss symbol 			   or undefined symbol just remember the index of the symbol. 			   Otherwise store the index of the symbol describing the 			   section the symbol belong to. This heuristic speeds up ld. 			   */
comment|/* Local symbols can generate relocation information. In case 			   of structure return for instance. But they have no symbol 			   number because they won't be emitted in the final object. 			   In the case where they are in the BSS section, this leads 			   to an incorrect r_symndx. 			   Under bsd the loader do not care if the symbol reference 			   is incorrect. But the SYS V ld complains about this. To 			   avoid this we associate the symbol to the associated 			   section, *even* if it is the BSS section. */
comment|/* If someone can tell me why the other symbols of the bss 			   section are not associated with the .bss section entry, 			   I'd be gratefull. I guess that it has to do with the special 			   nature of the .bss section. Or maybe this is because the 			   bss symbols are declared in the common section and can 			   be resized later. Can it break code some where ? */
name|ri_table
index|[
name|i
index|]
operator|.
name|r_symndx
operator|=
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_TEXT
condition|?
name|dot_text_symbol
operator|->
name|sy_number
else|:
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_DATA
condition|?
name|dot_data_symbol
operator|->
name|sy_number
else|:
operator|(
operator|(
name|SF_GET_LOCAL
argument_list|(
name|symbolP
argument_list|)
condition|?
name|dot_bss_symbol
operator|->
name|sy_number
else|:
name|symbolP
operator|->
name|sy_number
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* bss or undefined */
comment|/* md_ri_to_chars((char *)&ri, ri); */
comment|/* Last step : write md f */
name|i
operator|++
expr_stmt|;
block|}
comment|/* if there's a symbol */
block|}
comment|/* for each fixP */
comment|/* 	 * AIX ld prefer to have the reloc table with r_vaddr sorted. 	 * But sorting it should not hurt any other ld. 	 */
name|qsort
argument_list|(
name|ri_table
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ri_table
argument_list|)
argument_list|,
name|reloc_compare
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|BFD_HEADERS
operator|*
name|where
operator|+=
name|bfd_coff_swap_reloc_out
argument_list|(
name|stdoutput
argument_list|,
operator|&
name|ri_table
index|[
name|i
index|]
argument_list|,
operator|*
name|where
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_A29K
comment|/* The 29k has a special kludge for the high 16 bit reloc. 		       Two relocations are emmited, R_IHIHALF, and R_IHCONST. 		       The second one doesn't contain a symbol, but uses the 		       value for offset */
if|if
condition|(
name|ri_table
index|[
name|i
index|]
operator|.
name|r_type
operator|==
name|R_IHIHALF
condition|)
block|{
comment|/* now emit the second bit */
name|ri_table
index|[
name|i
index|]
operator|.
name|r_type
operator|=
name|R_IHCONST
expr_stmt|;
name|ri_table
index|[
name|i
index|]
operator|.
name|r_symndx
operator|=
name|fixP
operator|->
name|fx_addnumber
expr_stmt|;
operator|*
name|where
operator|+=
name|bfd_coff_swap_reloc_out
argument_list|(
name|stdoutput
argument_list|,
operator|&
name|ri_table
index|[
name|i
index|]
argument_list|,
operator|*
name|where
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TC_A29K */
else|#
directive|else
comment|/* not BFD_HEADERS */
name|append
argument_list|(
name|where
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ri_table
index|[
name|i
index|]
argument_list|,
name|RELSZ
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not BFD_HEADERS */
ifdef|#
directive|ifdef
name|TC_I960
if|if
condition|(
name|callj_table
index|[
name|i
index|]
condition|)
block|{
name|ri_table
index|[
name|i
index|]
operator|.
name|r_type
operator|=
name|R_OPTCALL
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_HEADERS
operator|*
name|where
operator|+=
name|bfd_coff_swap_reloc_out
argument_list|(
name|stdoutput
argument_list|,
operator|&
name|ri_table
index|[
name|i
index|]
argument_list|,
operator|*
name|where
argument_list|)
expr_stmt|;
else|#
directive|else
name|append
argument_list|(
name|where
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ri_table
index|[
name|i
index|]
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|RELSZ
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BFD_HEADERS */
block|}
comment|/* if it's a callj, do it again for the opcode */
endif|#
directive|endif
comment|/* TC_I960 */
block|}
name|free
argument_list|(
name|ri_table
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_I960
name|free
argument_list|(
name|callj_table
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/* obj_emit_relocations() */
end_comment

begin_comment
comment|/* Coff file generation& utilities */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_HEADERS
end_ifdef

begin_function
name|void
name|obj_header_append
parameter_list|(
name|where
parameter_list|,
name|headers
parameter_list|)
name|char
modifier|*
modifier|*
name|where
decl_stmt|;
name|object_headers
modifier|*
name|headers
decl_stmt|;
block|{
name|tc_headers_hook
argument_list|(
name|headers
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
name|bfd_coff_swap_filehdr_out
argument_list|(
name|stdoutput
argument_list|,
operator|&
operator|(
name|headers
operator|->
name|filehdr
operator|)
argument_list|,
operator|*
name|where
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OBJ_COFF_OMIT_OPTIONAL_HEADER
operator|*
name|where
operator|+=
name|bfd_coff_swap_aouthdr_out
argument_list|(
name|stdoutput
argument_list|,
operator|&
operator|(
name|headers
operator|->
name|aouthdr
operator|)
argument_list|,
operator|*
name|where
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|obj_coff_section_header_append
argument_list|(
name|where
argument_list|,
operator|&
name|text_section_header
argument_list|)
expr_stmt|;
name|obj_coff_section_header_append
argument_list|(
name|where
argument_list|,
operator|&
name|data_section_header
argument_list|)
expr_stmt|;
name|obj_coff_section_header_append
argument_list|(
name|where
argument_list|,
operator|&
name|bss_section_header
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|obj_header_append
parameter_list|(
name|where
parameter_list|,
name|headers
parameter_list|)
name|char
modifier|*
modifier|*
name|where
decl_stmt|;
name|object_headers
modifier|*
name|headers
decl_stmt|;
block|{
name|tc_headers_hook
argument_list|(
name|headers
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CROSS_COMPILE
comment|/* Eventually swap bytes for cross compilation for file header */
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|filehdr
operator|.
name|f_magic
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|filehdr
operator|.
name|f_magic
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|filehdr
operator|.
name|f_magic
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|filehdr
operator|.
name|f_nscns
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|filehdr
operator|.
name|f_nscns
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|filehdr
operator|.
name|f_nscns
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|filehdr
operator|.
name|f_timdat
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|filehdr
operator|.
name|f_timdat
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|filehdr
operator|.
name|f_timdat
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|filehdr
operator|.
name|f_symptr
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|filehdr
operator|.
name|f_symptr
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|filehdr
operator|.
name|f_symptr
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|filehdr
operator|.
name|f_nsyms
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|filehdr
operator|.
name|f_nsyms
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|filehdr
operator|.
name|f_nsyms
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|filehdr
operator|.
name|f_opthdr
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|filehdr
operator|.
name|f_opthdr
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|filehdr
operator|.
name|f_opthdr
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|filehdr
operator|.
name|f_flags
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|filehdr
operator|.
name|f_flags
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|filehdr
operator|.
name|f_flags
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OBJ_COFF_OMIT_OPTIONAL_HEADER
comment|/* Eventually swap bytes for cross compilation for a.out header */
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|aouthdr
operator|.
name|magic
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|aouthdr
operator|.
name|magic
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|aouthdr
operator|.
name|magic
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|aouthdr
operator|.
name|vstamp
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|aouthdr
operator|.
name|vstamp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|aouthdr
operator|.
name|vstamp
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|aouthdr
operator|.
name|tsize
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|aouthdr
operator|.
name|tsize
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|aouthdr
operator|.
name|tsize
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|aouthdr
operator|.
name|dsize
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|aouthdr
operator|.
name|dsize
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|aouthdr
operator|.
name|dsize
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|aouthdr
operator|.
name|bsize
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|aouthdr
operator|.
name|bsize
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|aouthdr
operator|.
name|bsize
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|aouthdr
operator|.
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|aouthdr
operator|.
name|entry
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|aouthdr
operator|.
name|entry
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|aouthdr
operator|.
name|text_start
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|aouthdr
operator|.
name|text_start
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|aouthdr
operator|.
name|text_start
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|aouthdr
operator|.
name|data_start
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|aouthdr
operator|.
name|data_start
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|aouthdr
operator|.
name|data_start
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|headers
operator|->
name|aouthdr
operator|.
name|tagentries
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|aouthdr
operator|.
name|tagentries
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|aouthdr
operator|.
name|tagentries
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_COFF_OMIT_OPTIONAL_HEADER */
else|#
directive|else
comment|/* CROSS_COMPILE */
name|append
argument_list|(
name|where
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|headers
operator|->
name|filehdr
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|filehdr
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|OBJ_COFF_OMIT_OPTIONAL_HEADER
name|append
argument_list|(
name|where
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|headers
operator|->
name|aouthdr
argument_list|,
sizeof|sizeof
argument_list|(
name|headers
operator|->
name|aouthdr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_COFF_OMIT_OPTIONAL_HEADER */
endif|#
directive|endif
comment|/* CROSS_COMPILE */
comment|/* Output the section headers */
name|obj_coff_section_header_append
argument_list|(
name|where
argument_list|,
operator|&
name|text_section_header
argument_list|)
expr_stmt|;
name|obj_coff_section_header_append
argument_list|(
name|where
argument_list|,
operator|&
name|data_section_header
argument_list|)
expr_stmt|;
name|obj_coff_section_header_append
argument_list|(
name|where
argument_list|,
operator|&
name|bss_section_header
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_header_append() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|obj_symbol_to_chars
parameter_list|(
name|where
parameter_list|,
name|symbolP
parameter_list|)
name|char
modifier|*
modifier|*
name|where
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD_HEADERS
name|unsigned
name|int
name|numaux
init|=
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_entry
operator|.
name|n_numaux
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_REGISTER
condition|)
block|{
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|SEG_ABSOLUTE
argument_list|)
expr_stmt|;
block|}
operator|*
name|where
operator|+=
name|bfd_coff_swap_sym_out
argument_list|(
name|stdoutput
argument_list|,
operator|&
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_entry
argument_list|,
operator|*
name|where
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numaux
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|where
operator|+=
name|bfd_coff_swap_aux_out
argument_list|(
name|stdoutput
argument_list|,
operator|&
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_auxent
index|[
name|i
index|]
argument_list|,
name|S_GET_DATA_TYPE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|*
name|where
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* BFD_HEADERS */
name|SYMENT
modifier|*
name|syment
init|=
operator|&
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_entry
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|numaux
init|=
name|syment
operator|->
name|n_numaux
decl_stmt|;
name|unsigned
name|short
name|type
init|=
name|S_GET_DATA_TYPE
argument_list|(
name|symbolP
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|CROSS_COMPILE
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|syment
operator|->
name|n_value
argument_list|,
sizeof|sizeof
argument_list|(
name|syment
operator|->
name|n_value
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|syment
operator|->
name|n_value
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|syment
operator|->
name|n_scnum
argument_list|,
sizeof|sizeof
argument_list|(
name|syment
operator|->
name|n_scnum
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|syment
operator|->
name|n_scnum
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
comment|/* pad n_flags */
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|syment
operator|->
name|n_type
argument_list|,
sizeof|sizeof
argument_list|(
name|syment
operator|->
name|n_type
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|syment
operator|->
name|n_type
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|syment
operator|->
name|n_sclass
argument_list|,
sizeof|sizeof
argument_list|(
name|syment
operator|->
name|n_sclass
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|syment
operator|->
name|n_sclass
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|syment
operator|->
name|n_numaux
argument_list|,
sizeof|sizeof
argument_list|(
name|syment
operator|->
name|n_numaux
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|syment
operator|->
name|n_numaux
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* CROSS_COMPILE */
name|append
argument_list|(
name|where
argument_list|,
operator|(
name|char
operator|*
operator|)
name|syment
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|syment
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CROSS_COMPILE */
comment|/* Should do the following : if (.file entry) MD(..)... else if (static entry) MD(..) */
if|if
condition|(
name|numaux
operator|>
name|OBJ_COFF_MAX_AUXENTRIES
condition|)
block|{
name|as_bad
argument_list|(
literal|"Internal error? too many auxents for symbol"
argument_list|)
expr_stmt|;
block|}
comment|/* too many auxents */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numaux
condition|;
operator|++
name|i
control|)
block|{
ifdef|#
directive|ifdef
name|CROSS_COMPILE
if|#
directive|if
literal|0
comment|/* This code has never been tested */
comment|/* The most common case, x_sym entry. */
block|if ((SF_GET(symbolP)& (SF_FILE | SF_STATICS)) == 0) { 			md_number_to_chars(*where, auxP->x_sym.x_tagndx, sizeof(auxP->x_sym.x_tagndx)); 			*where += sizeof(auxP->x_sym.x_tagndx); 			if (ISFCN(type)) { 				md_number_to_chars(*where, auxP->x_sym.x_misc.x_fsize, sizeof(auxP->x_sym.x_misc.x_fsize)); 				*where += sizeof(auxP->x_sym.x_misc.x_fsize); 			} else { 				md_number_to_chars(*where, auxP->x_sym.x_misc.x_lnno, sizeof(auxP->x_sym.x_misc.x_lnno)); 				*where += sizeof(auxP->x_sym.x_misc.x_lnno); 				md_number_to_chars(*where, auxP->x_sym.x_misc.x_size, sizeof(auxP->x_sym.x_misc.x_size)); 				*where += sizeof(auxP->x_sym.x_misc.x_size); 			} 			if (ISARY(type)) { 				register int index; 				for (index = 0; index< DIMNUM; index++) 				    md_number_to_chars(*where, auxP->x_sym.x_fcnary.x_ary.x_dimen[index], sizeof(auxP->x_sym.x_fcnary.x_ary.x_dimen[index])); 				*where += sizeof(auxP->x_sym.x_fcnary.x_ary.x_dimen[index]); 			} else { 				md_number_to_chars(*where, auxP->x_sym.x_fcnary.x_fcn.x_lnnoptr, sizeof(auxP->x_sym.x_fcnary.x_fcn.x_lnnoptr)); 				*where += sizeof(auxP->x_sym.x_fcnary.x_fcn.x_lnnoptr); 				md_number_to_chars(*where, auxP->x_sym.x_fcnary.x_fcn.x_endndx, sizeof(auxP->x_sym.x_fcnary.x_fcn.x_endndx)); 				*where += sizeof(auxP->x_sym.x_fcnary.x_fcn.x_endndx); 			} 			md_number_to_chars(*where, auxP->x_sym.x_tvndx, sizeof(auxP->x_sym.x_tvndx)); 			*where += sizeof(auxP->x_sym.x_tvndx); 		} else if (SF_GET_FILE(symbolP)) {
comment|/* .file */
block|; 		} else if (SF_GET_STATICS(symbolP)) {
comment|/* .text, .data, .bss symbols */
block|md_number_to_chars(*where, auxP->x_scn.x_scnlen, sizeof(auxP->x_scn.x_scnlen)); 			*where += sizeof(auxP->x_scn.x_scnlen); 			md_number_to_chars(*where, auxP->x_scn.x_nreloc, sizeof(auxP->x_scn.x_nreloc)); 			*where += sizeof(auxP->x_scn.x_nreloc); 			md_number_to_chars(*where, auxP->x_scn.x_nlinno, sizeof(auxP->x_scn.x_nlinno)); 			*where += sizeof(auxP->x_scn.x_nlinno); 		}
endif|#
directive|endif
comment|/* 0 */
else|#
directive|else
comment|/* CROSS_COMPILE */
name|append
argument_list|(
name|where
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_auxent
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_auxent
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CROSS_COMPILE */
block|}
empty_stmt|;
comment|/* for each aux in use */
endif|#
directive|endif
comment|/* BFD_HEADERS */
return|return;
block|}
end_function

begin_comment
comment|/* obj_symbol_to_chars() */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BFD_HEADERS
end_ifdef

begin_function
specifier|static
name|void
name|obj_coff_section_header_append
parameter_list|(
name|where
parameter_list|,
name|header
parameter_list|)
name|char
modifier|*
modifier|*
name|where
decl_stmt|;
name|struct
name|internal_scnhdr
modifier|*
name|header
decl_stmt|;
block|{
operator|*
name|where
operator|+=
name|bfd_coff_swap_scnhdr_out
argument_list|(
name|stdoutput
argument_list|,
name|header
argument_list|,
operator|*
name|where
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|obj_coff_section_header_append
parameter_list|(
name|where
parameter_list|,
name|header
parameter_list|)
name|char
modifier|*
modifier|*
name|where
decl_stmt|;
name|SCNHDR
modifier|*
name|header
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|CROSS_COMPILE
name|memcpy
argument_list|(
operator|*
name|where
argument_list|,
name|header
operator|->
name|s_name
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|s_name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|header
operator|->
name|s_name
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|header
operator|->
name|s_paddr
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|s_paddr
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|header
operator|->
name|s_paddr
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|header
operator|->
name|s_vaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|s_vaddr
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|header
operator|->
name|s_vaddr
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|header
operator|->
name|s_size
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|s_size
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|header
operator|->
name|s_size
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|header
operator|->
name|s_scnptr
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|s_scnptr
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|header
operator|->
name|s_scnptr
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|header
operator|->
name|s_relptr
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|s_relptr
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|header
operator|->
name|s_relptr
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|header
operator|->
name|s_lnnoptr
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|s_lnnoptr
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|header
operator|->
name|s_lnnoptr
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|header
operator|->
name|s_nreloc
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|s_nreloc
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|header
operator|->
name|s_nreloc
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|header
operator|->
name|s_nlnno
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|s_nlnno
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|header
operator|->
name|s_nlnno
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|header
operator|->
name|s_flags
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|s_flags
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|header
operator|->
name|s_flags
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_I960
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|header
operator|->
name|s_align
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|s_align
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|header
operator|->
name|s_align
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TC_I960 */
else|#
directive|else
comment|/* CROSS_COMPILE */
name|append
argument_list|(
name|where
argument_list|,
operator|(
name|char
operator|*
operator|)
name|header
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CROSS_COMPILE */
return|return;
block|}
end_function

begin_comment
comment|/* obj_coff_section_header_append() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|obj_emit_symbols
parameter_list|(
name|where
parameter_list|,
name|symbol_rootP
parameter_list|)
name|char
modifier|*
modifier|*
name|where
decl_stmt|;
name|symbolS
modifier|*
name|symbol_rootP
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* 	 * Emit all symbols left in the symbol chain. 	 */
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
comment|/* Used to save the offset of the name. It is used to point 		   to the string in memory but must be a file offset. */
specifier|register
name|char
modifier|*
name|temp
decl_stmt|;
name|tc_coff_symbol_emit_hook
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|temp
operator|=
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|SF_GET_STRING
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|S_SET_OFFSET
argument_list|(
name|symbolP
argument_list|,
name|symbolP
operator|->
name|sy_name_offset
argument_list|)
expr_stmt|;
name|S_SET_ZEROES
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_entry
operator|.
name|n_name
argument_list|,
literal|'\0'
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_entry
operator|.
name|n_name
argument_list|,
name|temp
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
block|}
name|obj_symbol_to_chars
argument_list|(
name|where
argument_list|,
name|symbolP
argument_list|)
expr_stmt|;
name|S_SET_NAME
argument_list|(
name|symbolP
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* obj_emit_symbols() */
end_comment

begin_comment
comment|/* Merge a debug symbol containing debug information into a normal symbol. */
end_comment

begin_function
name|void
name|c_symbol_merge
parameter_list|(
name|debug
parameter_list|,
name|normal
parameter_list|)
name|symbolS
modifier|*
name|debug
decl_stmt|;
name|symbolS
modifier|*
name|normal
decl_stmt|;
block|{
name|S_SET_DATA_TYPE
argument_list|(
name|normal
argument_list|,
name|S_GET_DATA_TYPE
argument_list|(
name|debug
argument_list|)
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|normal
argument_list|,
name|S_GET_STORAGE_CLASS
argument_list|(
name|debug
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|debug
argument_list|)
operator|>
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|normal
argument_list|)
condition|)
block|{
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|normal
argument_list|,
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|debug
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* take the most we have */
if|if
condition|(
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|debug
argument_list|)
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|normal
operator|->
name|sy_symbol
operator|.
name|ost_auxent
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug
operator|->
name|sy_symbol
operator|.
name|ost_auxent
index|[
literal|0
index|]
argument_list|,
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|debug
argument_list|)
operator|*
name|AUXESZ
argument_list|)
expr_stmt|;
block|}
comment|/* Move all the auxiliary information */
comment|/* Move the debug flags. */
name|SF_SET_DEBUG_FIELD
argument_list|(
name|normal
argument_list|,
name|SF_GET_DEBUG_FIELD
argument_list|(
name|debug
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* c_symbol_merge() */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|previous_file_symbol
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|c_dot_file_symbol
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolP
operator|=
name|symbol_new
argument_list|(
literal|".file"
argument_list|,
name|SEG_DEBUG
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_FILE
argument_list|)
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SA_SET_FILE_FNAME
argument_list|(
name|symbolP
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|SF_SET_DEBUG
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|long
operator|)
name|previous_file_symbol
argument_list|)
expr_stmt|;
name|previous_file_symbol
operator|=
name|symbolP
expr_stmt|;
comment|/* Make sure that the symbol is first on the symbol chain */
if|if
condition|(
name|symbol_rootP
operator|!=
name|symbolP
condition|)
block|{
if|if
condition|(
name|symbolP
operator|==
name|symbol_lastP
condition|)
block|{
name|symbol_lastP
operator|=
name|symbol_lastP
operator|->
name|sy_previous
expr_stmt|;
block|}
comment|/* if it was the last thing on the list */
name|symbol_remove
argument_list|(
name|symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_insert
argument_list|(
name|symbolP
argument_list|,
name|symbol_rootP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_rootP
operator|=
name|symbolP
expr_stmt|;
block|}
comment|/* if not first on the list */
block|}
end_function

begin_comment
comment|/* c_dot_file_symbol() */
end_comment

begin_comment
comment|/*  * Build a 'section static' symbol.  */
end_comment

begin_function
name|char
modifier|*
name|c_section_symbol
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|,
name|length
parameter_list|,
name|nreloc
parameter_list|,
name|nlnno
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|long
name|value
decl_stmt|;
name|long
name|length
decl_stmt|;
name|unsigned
name|short
name|nreloc
decl_stmt|;
name|unsigned
name|short
name|nlnno
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'t'
condition|?
name|SEG_TEXT
else|:
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'d'
condition|?
name|SEG_DATA
else|:
name|SEG_BSS
operator|)
operator|)
argument_list|,
name|value
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_STAT
argument_list|)
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SA_SET_SCN_SCNLEN
argument_list|(
name|symbolP
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|SA_SET_SCN_NRELOC
argument_list|(
name|symbolP
argument_list|,
name|nreloc
argument_list|)
expr_stmt|;
name|SA_SET_SCN_NLINNO
argument_list|(
name|symbolP
argument_list|,
name|nlnno
argument_list|)
expr_stmt|;
name|SF_SET_STATICS
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|symbolP
return|;
block|}
end_function

begin_comment
comment|/* c_section_symbol() */
end_comment

begin_function
name|void
name|c_section_header
parameter_list|(
name|header
parameter_list|,
name|name
parameter_list|,
name|core_address
parameter_list|,
name|size
parameter_list|,
name|data_ptr
parameter_list|,
name|reloc_ptr
parameter_list|,
name|lineno_ptr
parameter_list|,
name|reloc_number
parameter_list|,
name|lineno_number
parameter_list|,
name|alignment
parameter_list|)
ifdef|#
directive|ifdef
name|BFD_HEADERS
name|struct
name|internal_scnhdr
modifier|*
name|header
decl_stmt|;
else|#
directive|else
name|SCNHDR
modifier|*
name|header
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|name
decl_stmt|;
name|long
name|core_address
decl_stmt|;
name|long
name|size
decl_stmt|;
name|long
name|data_ptr
decl_stmt|;
name|long
name|reloc_ptr
decl_stmt|;
name|long
name|lineno_ptr
decl_stmt|;
name|long
name|reloc_number
decl_stmt|;
name|long
name|lineno_number
decl_stmt|;
name|long
name|alignment
decl_stmt|;
block|{
name|strncpy
argument_list|(
name|header
operator|->
name|s_name
argument_list|,
name|name
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|header
operator|->
name|s_paddr
operator|=
name|header
operator|->
name|s_vaddr
operator|=
name|core_address
expr_stmt|;
name|header
operator|->
name|s_scnptr
operator|=
operator|(
operator|(
name|header
operator|->
name|s_size
operator|=
name|size
operator|)
operator|!=
literal|0
operator|)
condition|?
name|data_ptr
else|:
literal|0
expr_stmt|;
name|header
operator|->
name|s_relptr
operator|=
name|reloc_ptr
expr_stmt|;
name|header
operator|->
name|s_lnnoptr
operator|=
name|lineno_ptr
expr_stmt|;
name|header
operator|->
name|s_nreloc
operator|=
name|reloc_number
expr_stmt|;
name|header
operator|->
name|s_nlnno
operator|=
name|lineno_number
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_COFF_SECTION_HEADER_HAS_ALIGNMENT
ifdef|#
directive|ifdef
name|OBJ_COFF_BROKEN_ALIGNMENT
name|header
operator|->
name|s_align
operator|=
operator|(
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'b'
operator|||
operator|(
name|size
operator|>
literal|0
operator|)
operator|)
condition|?
literal|16
else|:
literal|0
operator|)
expr_stmt|;
else|#
directive|else
name|header
operator|->
name|s_align
operator|=
operator|(
operator|(
name|alignment
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
literal|1
operator|<<
name|alignment
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_COFF_BROKEN_ALIGNMENT */
endif|#
directive|endif
comment|/* OBJ_COFF_SECTION_HEADER_HAS_ALIGNMENT */
name|header
operator|->
name|s_flags
operator|=
name|STYP_REG
operator||
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'t'
condition|?
name|STYP_TEXT
else|:
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'d'
condition|?
name|STYP_DATA
else|:
operator|(
name|name
index|[
literal|1
index|]
operator|==
literal|'b'
condition|?
name|STYP_BSS
else|:
name|STYP_INFO
operator|)
operator|)
operator|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* c_section_header() */
end_comment

begin_comment
comment|/* Line number handling */
end_comment

begin_decl_stmt
name|int
name|function_lineoff
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offset in line#s where the last function 				   started (the odd entry for line #0) */
end_comment

begin_decl_stmt
name|int
name|text_lineno_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|our_lineno_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* we use this to build pointers from .bf's 				   into the linetable.  It should match 				   exactly the values that are later 				   assigned in text_lineno_number by 				   write.c. */
end_comment

begin_decl_stmt
name|lineno
modifier|*
name|lineno_lastP
init|=
operator|(
name|lineno
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|c_line_new
parameter_list|(
name|paddr
parameter_list|,
name|line_number
parameter_list|,
name|frag
parameter_list|)
name|long
name|paddr
decl_stmt|;
name|unsigned
name|short
name|line_number
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
block|{
name|lineno
modifier|*
name|new_line
init|=
operator|(
name|lineno
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|lineno
argument_list|)
argument_list|)
decl_stmt|;
name|new_line
operator|->
name|line
operator|.
name|l_addr
operator|.
name|l_paddr
operator|=
name|paddr
expr_stmt|;
name|new_line
operator|->
name|line
operator|.
name|l_lnno
operator|=
name|line_number
expr_stmt|;
name|new_line
operator|->
name|frag
operator|=
operator|(
name|char
operator|*
operator|)
name|frag
expr_stmt|;
name|new_line
operator|->
name|next
operator|=
operator|(
name|lineno
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|lineno_rootP
operator|==
operator|(
name|lineno
operator|*
operator|)
literal|0
condition|)
name|lineno_rootP
operator|=
name|new_line
expr_stmt|;
else|else
name|lineno_lastP
operator|->
name|next
operator|=
name|new_line
expr_stmt|;
name|lineno_lastP
operator|=
name|new_line
expr_stmt|;
return|return
name|LINESZ
operator|*
name|our_lineno_number
operator|++
return|;
block|}
end_function

begin_function
name|void
name|obj_emit_lineno
parameter_list|(
name|where
parameter_list|,
name|line
parameter_list|,
name|file_start
parameter_list|)
name|char
modifier|*
modifier|*
name|where
decl_stmt|;
name|lineno
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|file_start
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BFD_HEADERS
name|struct
name|bfd_internal_lineno
modifier|*
name|line_entry
decl_stmt|;
else|#
directive|else
name|LINENO
modifier|*
name|line_entry
decl_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
name|line
condition|;
name|line
operator|=
name|line
operator|->
name|next
control|)
block|{
name|line_entry
operator|=
operator|&
name|line
operator|->
name|line
expr_stmt|;
comment|/* FIXME-SOMEDAY Resolving the sy_number of function linno's used to be done in 		   write_object_file() but their symbols need a fileptr to the lnno, so 		   I moved this resolution check here.  xoxorich. */
if|if
condition|(
name|line_entry
operator|->
name|l_lnno
operator|==
literal|0
condition|)
block|{
comment|/* There is a good chance that the symbol pointed to 			   is not the one that will be emitted and that the 			   sy_number is not accurate. */
comment|/*			char *name; */
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolP
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|line_entry
operator|->
name|l_addr
operator|.
name|l_symndx
expr_stmt|;
name|line_entry
operator|->
name|l_addr
operator|.
name|l_symndx
operator|=
name|symbolP
operator|->
name|sy_number
expr_stmt|;
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_auxent
index|[
literal|0
index|]
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_fcn
operator|.
name|x_lnnoptr
operator|=
operator|*
name|where
operator|-
name|file_start
expr_stmt|;
block|}
comment|/* if this is a function linno */
ifdef|#
directive|ifdef
name|BFD_HEADERS
operator|*
name|where
operator|+=
name|bfd_coff_swap_lineno_out
argument_list|(
name|stdoutput
argument_list|,
name|line_entry
argument_list|,
operator|*
name|where
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* No matter which member of the union we process, they are 		   both long. */
ifdef|#
directive|ifdef
name|CROSS_COMPILE
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|line_entry
operator|->
name|l_addr
operator|.
name|l_paddr
argument_list|,
sizeof|sizeof
argument_list|(
name|line_entry
operator|->
name|l_addr
operator|.
name|l_paddr
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|line_entry
operator|->
name|l_addr
operator|.
name|l_paddr
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|line_entry
operator|->
name|l_lnno
argument_list|,
sizeof|sizeof
argument_list|(
name|line_entry
operator|->
name|l_lnno
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|line_entry
operator|->
name|l_lnno
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_I960
operator|*
operator|*
name|where
operator|=
literal|'0'
expr_stmt|;
operator|++
operator|*
name|where
expr_stmt|;
operator|*
operator|*
name|where
operator|=
literal|'0'
expr_stmt|;
operator|++
operator|*
name|where
expr_stmt|;
endif|#
directive|endif
comment|/* TC_I960 */
else|#
directive|else
comment|/* CROSS_COMPILE */
name|append
argument_list|(
name|where
argument_list|,
operator|(
name|char
operator|*
operator|)
name|line_entry
argument_list|,
name|LINESZ
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CROSS_COMPILE */
endif|#
directive|endif
comment|/* BFD_HEADERS */
block|}
comment|/* for each line number */
return|return ;
block|}
end_function

begin_comment
comment|/* obj_emit_lineno() */
end_comment

begin_function
name|void
name|obj_symbol_new_hook
parameter_list|(
name|symbolP
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
name|char
name|underscore
init|=
literal|0
decl_stmt|;
comment|/* Symbol has leading _ */
comment|/* Effective symbol */
comment|/* Store the pointer in the offset. */
name|S_SET_ZEROES
argument_list|(
name|symbolP
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|S_SET_DATA_TYPE
argument_list|(
name|symbolP
argument_list|,
name|T_NULL
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Additional information */
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_flags
operator|=
literal|0
expr_stmt|;
comment|/* Auxiliary entries */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_auxent
index|[
literal|0
index|]
argument_list|,
literal|'\0'
argument_list|,
name|AUXESZ
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STRIP_UNDERSCORE
comment|/* Remove leading underscore at the beginning of the symbol. 	 * This is to be compatible with the standard librairies. 	 */
if|if
condition|(
operator|*
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|'_'
condition|)
block|{
name|underscore
operator|=
literal|1
expr_stmt|;
name|S_SET_NAME
argument_list|(
name|symbolP
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* strip underscore */
endif|#
directive|endif
comment|/* STRIP_UNDERSCORE */
if|if
condition|(
name|S_IS_STRING
argument_list|(
name|symbolP
argument_list|)
condition|)
name|SF_SET_STRING
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|underscore
operator|&&
name|S_IS_LOCAL
argument_list|(
name|symbolP
argument_list|)
condition|)
name|SF_SET_LOCAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_symbol_new_hook() */
end_comment

begin_comment
comment|/* stack stuff */
end_comment

begin_function
name|stack
modifier|*
name|stack_init
parameter_list|(
name|chunk_size
parameter_list|,
name|element_size
parameter_list|)
name|unsigned
name|long
name|chunk_size
decl_stmt|;
name|unsigned
name|long
name|element_size
decl_stmt|;
block|{
name|stack
modifier|*
name|st
decl_stmt|;
if|if
condition|(
operator|(
name|st
operator|=
operator|(
name|stack
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|stack
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
name|stack
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
name|stack
operator|*
operator|)
literal|0
return|;
if|if
condition|(
operator|(
name|st
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|chunk_size
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return
operator|(
name|stack
operator|*
operator|)
literal|0
return|;
block|}
name|st
operator|->
name|pointer
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|size
operator|=
name|chunk_size
expr_stmt|;
name|st
operator|->
name|chunk_size
operator|=
name|chunk_size
expr_stmt|;
name|st
operator|->
name|element_size
operator|=
name|element_size
expr_stmt|;
return|return
name|st
return|;
block|}
end_function

begin_comment
comment|/* stack_init() */
end_comment

begin_function
name|void
name|stack_delete
parameter_list|(
name|st
parameter_list|)
name|stack
modifier|*
name|st
decl_stmt|;
block|{
name|free
argument_list|(
name|st
operator|->
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|stack_push
parameter_list|(
name|st
parameter_list|,
name|element
parameter_list|)
name|stack
modifier|*
name|st
decl_stmt|;
name|char
modifier|*
name|element
decl_stmt|;
block|{
if|if
condition|(
name|st
operator|->
name|pointer
operator|+
name|st
operator|->
name|element_size
operator|>=
name|st
operator|->
name|size
condition|)
block|{
name|st
operator|->
name|size
operator|+=
name|st
operator|->
name|chunk_size
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|->
name|data
operator|=
name|xrealloc
argument_list|(
name|st
operator|->
name|data
argument_list|,
name|st
operator|->
name|size
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|st
operator|->
name|data
operator|+
name|st
operator|->
name|pointer
argument_list|,
name|element
argument_list|,
name|st
operator|->
name|element_size
argument_list|)
expr_stmt|;
name|st
operator|->
name|pointer
operator|+=
name|st
operator|->
name|element_size
expr_stmt|;
return|return
name|st
operator|->
name|data
operator|+
name|st
operator|->
name|pointer
return|;
block|}
end_function

begin_comment
comment|/* stack_push() */
end_comment

begin_function
name|char
modifier|*
name|stack_pop
parameter_list|(
name|st
parameter_list|)
name|stack
modifier|*
name|st
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|st
operator|->
name|pointer
operator|-=
name|st
operator|->
name|element_size
operator|)
operator|<
literal|0
condition|)
block|{
name|st
operator|->
name|pointer
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
return|return
name|st
operator|->
name|data
operator|+
name|st
operator|->
name|pointer
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|stack_top
parameter_list|(
name|st
parameter_list|)
name|stack
modifier|*
name|st
decl_stmt|;
block|{
return|return
name|st
operator|->
name|data
operator|+
name|st
operator|->
name|pointer
operator|-
name|st
operator|->
name|element_size
return|;
block|}
end_function

begin_comment
comment|/*  * Handle .ln directives.  */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_ln
parameter_list|()
block|{
if|if
condition|(
name|def_symbol_in_progress
operator|!=
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
literal|".ln pseudo-op inside .def/.endef: ignored."
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* wrong context */
name|c_line_new
argument_list|(
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_coff_line() */
end_comment

begin_comment
comment|/*  *			def()  *  * Handle .def directives.  *  * One might ask : why can't we symbol_new if the symbol does not  * already exist and fill it with debug information.  Because of  * the C_EFCN special symbol. It would clobber the value of the  * function symbol before we have a chance to notice that it is  * a C_EFCN. And a second reason is that the code is more clear this  * way. (at least I think it is :-).  *  */
end_comment

begin_define
define|#
directive|define
name|SKIP_SEMI_COLON
parameter_list|()
value|while (*input_line_pointer++ != ';')
end_define

begin_define
define|#
directive|define
name|SKIP_WHITESPACES
parameter_list|()
value|while (*input_line_pointer == ' ' || \ 				       *input_line_pointer == '\t') \     input_line_pointer++;
end_define

begin_function
specifier|static
name|void
name|obj_coff_def
parameter_list|(
name|what
parameter_list|)
name|int
name|what
decl_stmt|;
block|{
name|char
name|name_end
decl_stmt|;
comment|/* Char after the end of name */
name|char
modifier|*
name|symbol_name
decl_stmt|;
comment|/* Name of the debug symbol */
name|char
modifier|*
name|symbol_name_copy
decl_stmt|;
comment|/* Temporary copy of the name */
name|unsigned
name|int
name|symbol_name_length
decl_stmt|;
comment|/*$char*	directiveP;$ */
comment|/* Name of the pseudo opcode */
comment|/*$char directive[MAX_DIRECTIVE];$ */
comment|/* Backup of the directive */
comment|/*$char end = 0;$ */
comment|/* If 1, stop parsing */
if|if
condition|(
name|def_symbol_in_progress
operator|!=
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
literal|".def pseudo-op used inside of .def/.endef: ignored."
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
name|SKIP_WHITESPACES
argument_list|()
expr_stmt|;
name|def_symbol_in_progress
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|def_symbol_in_progress
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|def_symbol_in_progress
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_name
operator|=
name|input_line_pointer
expr_stmt|;
name|name_end
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbol_name_length
operator|=
name|strlen
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
name|symbol_name_copy
operator|=
name|xmalloc
argument_list|(
name|symbol_name_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|symbol_name_copy
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
comment|/* Initialize the new symbol */
ifdef|#
directive|ifdef
name|STRIP_UNDERSCORE
name|S_SET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|(
operator|*
name|symbol_name_copy
operator|==
literal|'_'
condition|?
name|symbol_name_copy
operator|+
literal|1
else|:
name|symbol_name_copy
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* STRIP_UNDERSCORE */
name|S_SET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|symbol_name_copy
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* STRIP_UNDERSCORE */
comment|/* free(symbol_name_copy); */
name|def_symbol_in_progress
operator|->
name|sy_name_offset
operator|=
operator|~
literal|0
expr_stmt|;
name|def_symbol_in_progress
operator|->
name|sy_number
operator|=
operator|~
literal|0
expr_stmt|;
name|def_symbol_in_progress
operator|->
name|sy_frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
if|if
condition|(
name|S_IS_STRING
argument_list|(
name|def_symbol_in_progress
argument_list|)
condition|)
block|{
name|SF_SET_STRING
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
block|}
comment|/* "long" name */
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_coff_def() */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|dim_index
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|obj_coff_endef
parameter_list|()
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* DIM BUG FIX sac@cygnus.com */
name|dim_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
literal|".endef pseudo-op used outside of .def/.endef: ignored."
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
comment|/* Set the section number according to storage class. */
switch|switch
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
condition|)
block|{
case|case
name|C_STRTAG
case|:
case|case
name|C_ENTAG
case|:
case|case
name|C_UNTAG
case|:
name|SF_SET_TAG
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
comment|/* intentional fallthrough */
case|case
name|C_FILE
case|:
case|case
name|C_TPDEF
case|:
name|SF_SET_DEBUG
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|SEG_DEBUG
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_EFCN
case|:
name|SF_SET_LOCAL
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
comment|/* Do not emit this symbol. */
comment|/* intentional fallthrough */
case|case
name|C_BLOCK
case|:
name|SF_SET_PROCESS
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
comment|/* Will need processing before writing */
comment|/* intentional fallthrough */
case|case
name|C_FCN
case|:
name|S_SET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|SEG_TEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|->
name|sy_symbol
operator|.
name|ost_entry
operator|.
name|n_name
index|[
literal|1
index|]
operator|==
literal|'b'
condition|)
block|{
comment|/* .bf */
if|if
condition|(
name|function_lineoff
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"`.bf' symbol without preceding function\n"
argument_list|)
expr_stmt|;
block|}
comment|/* missing function symbol */
name|SA_GET_SYM_LNNOPTR
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|=
name|function_lineoff
expr_stmt|;
name|SF_SET_PROCESS
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
comment|/* Will need relocating */
name|function_lineoff
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|C_AUTOARG
case|case
name|C_AUTOARG
case|:
endif|#
directive|endif
comment|/* C_AUTOARG */
case|case
name|C_AUTO
case|:
case|case
name|C_REG
case|:
case|case
name|C_MOS
case|:
case|case
name|C_MOE
case|:
case|case
name|C_MOU
case|:
case|case
name|C_ARG
case|:
case|case
name|C_REGPARM
case|:
case|case
name|C_FIELD
case|:
case|case
name|C_EOS
case|:
name|SF_SET_DEBUG
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|SEG_ABSOLUTE
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_EXT
case|:
case|case
name|C_STAT
case|:
case|case
name|C_LABEL
case|:
comment|/* Valid but set somewhere else (s_comm, s_lcomm, colon) */
break|break;
case|case
name|C_USTATIC
case|:
case|case
name|C_EXTDEF
case|:
case|case
name|C_ULABEL
case|:
name|as_warn
argument_list|(
literal|"unexpected storage class %d"
argument_list|,
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch on storage class */
comment|/* Now that we have built a debug symbol, try to 	   find if we should merge with an existing symbol 	   or not.  If a symbol is C_EFCN or SEG_ABSOLUTE or 	   untagged SEG_DEBUG it never merges. */
comment|/* Two cases for functions.  Either debug followed 	   by definition or definition followed by debug. 	   For definition first, we will merge the debug 	   symbol into the definition.  For debug first, the 	   lineno entry MUST point to the definition 	   function or else it will point off into space 	   when obj_crawl_symbol_chain() merges the debug 	   symbol into the real symbol.  Therefor, let's 	   presume the debug symbol is a real function 	   reference. */
comment|/* FIXME-SOON If for some reason the definition 	   label/symbol is never seen, this will probably 	   leave an undefined symbol at link time. */
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
name|C_EFCN
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
name|SEG_DEBUG
operator|&&
operator|!
name|SF_GET_TAG
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
name|SEG_ABSOLUTE
operator|||
operator|(
name|symbolP
operator|=
name|symbol_find_base
argument_list|(
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|,
name|DO_NOT_STRIP
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|symbol_append
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|symbol_lastP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This symbol already exists, merge the 		   newly created symbol into the old one. 		   This is not mandatory. The linker can 		   handle duplicate symbols correctly. But I 		   guess that it save a *lot* of space if 		   the assembly file defines a lot of 		   symbols. [loic] */
comment|/* The debug entry (def_symbol_in_progress) 		   is merged into the previous definition. */
name|c_symbol_merge
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|symbolP
argument_list|)
expr_stmt|;
comment|/* FIXME-SOON Should *def_symbol_in_progress be free'd? xoxorich. */
name|def_symbol_in_progress
operator|=
name|symbolP
expr_stmt|;
if|if
condition|(
name|SF_GET_FUNCTION
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|||
name|SF_GET_TAG
argument_list|(
name|def_symbol_in_progress
argument_list|)
condition|)
block|{
comment|/* For functions, and tags, the symbol *must* be where the debug symbol 			   appears.  Move the existing symbol to the current place. */
comment|/* If it already is at the end of the symbol list, do nothing */
if|if
condition|(
name|def_symbol_in_progress
operator|!=
name|symbol_lastP
condition|)
block|{
name|symbol_remove
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_append
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|symbol_lastP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
comment|/* if not already in place */
block|}
comment|/* if function */
block|}
comment|/* normal or mergable */
if|if
condition|(
name|SF_GET_TAG
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|&&
name|symbol_find_base
argument_list|(
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|,
name|DO_NOT_STRIP
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|tag_insert
argument_list|(
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|,
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
block|}
comment|/* If symbol is a {structure,union} tag, associate symbol to its name. */
if|if
condition|(
name|SF_GET_FUNCTION
argument_list|(
name|def_symbol_in_progress
argument_list|)
condition|)
block|{
name|know
argument_list|(
sizeof|sizeof
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|function_lineoff
operator|=
name|c_line_new
argument_list|(
operator|(
name|long
operator|)
name|def_symbol_in_progress
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|SF_SET_PROCESS
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolP
operator|==
name|NULL
condition|)
block|{
comment|/* That is, if this is the first 			   time we've seen the function... */
name|symbol_table_insert
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
block|}
comment|/* definition follows debug */
block|}
comment|/* Create the line number entry pointing to the function being defined */
name|def_symbol_in_progress
operator|=
name|NULL
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_coff_endef() */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_dim
parameter_list|()
block|{
specifier|register
name|int
name|dim_index
decl_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
literal|".dim pseudo-op used outside of .def/.endef: ignored."
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|dim_index
operator|=
literal|0
init|;
name|dim_index
operator|<
name|DIMNUM
condition|;
name|dim_index
operator|++
control|)
block|{
name|SKIP_WHITESPACES
argument_list|()
expr_stmt|;
name|SA_SET_SYM_DIMEN
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|dim_index
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
case|case
literal|','
case|:
name|input_line_pointer
operator|++
expr_stmt|;
break|break;
default|default:
name|as_warn
argument_list|(
literal|"badly formed .dim directive ignored"
argument_list|)
expr_stmt|;
comment|/* intentional fallthrough */
case|case
literal|'\n'
case|:
case|case
literal|';'
case|:
name|dim_index
operator|=
name|DIMNUM
expr_stmt|;
break|break;
block|}
comment|/* switch on following character */
block|}
comment|/* for each dimension */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_coff_dim() */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_line
parameter_list|()
block|{
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|obj_coff_ln
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if it looks like a stabs style line */
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SA_SET_SYM_LNNO
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_coff_line() */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_size
parameter_list|()
block|{
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
literal|".size pseudo-op used outside of .def/.endef ignored."
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SA_SET_SYM_SIZE
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_coff_size() */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_scl
parameter_list|()
block|{
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
literal|".scl pseudo-op used outside of .def/.endef ignored."
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
name|S_SET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_coff_scl() */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_tag
parameter_list|()
block|{
name|char
modifier|*
name|symbol_name
decl_stmt|;
name|char
name|name_end
decl_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
literal|".tag pseudo-op used outside of .def/.endef ignored."
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|symbol_name
operator|=
name|input_line_pointer
expr_stmt|;
name|name_end
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Assume that the symbol referred to by .tag is always defined. */
comment|/* This was a bad assumption.  I've added find_or_make. xoxorich. */
name|SA_SET_SYM_TAGNDX
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|(
name|long
operator|)
name|tag_find_or_make
argument_list|(
name|symbol_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SA_GET_SYM_TAGNDX
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
literal|0L
condition|)
block|{
name|as_warn
argument_list|(
literal|"tag not found for .tag %s"
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
block|}
comment|/* not defined */
name|SF_SET_TAGGED
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_coff_tag() */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_type
parameter_list|()
block|{
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
literal|".type pseudo-op used outside of .def/.endef ignored."
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
name|S_SET_DATA_TYPE
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISFCN
argument_list|(
name|S_GET_DATA_TYPE
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|)
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|!=
name|C_TPDEF
condition|)
block|{
name|SF_SET_FUNCTION
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
block|}
comment|/* is a function */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_coff_type() */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_val
parameter_list|()
block|{
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
literal|".val pseudo-op used outside of .def/.endef ignored."
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
if|if
condition|(
name|is_name_beginner
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|char
modifier|*
name|symbol_name
init|=
name|input_line_pointer
decl_stmt|;
name|char
name|name_end
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|symbol_name
argument_list|,
literal|"."
argument_list|)
condition|)
block|{
name|def_symbol_in_progress
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|)
expr_stmt|;
comment|/* If the .val is != from the .def (e.g. statics) */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|,
name|symbol_name
argument_list|)
condition|)
block|{
name|def_symbol_in_progress
operator|->
name|sy_forward
operator|=
name|symbol_find_or_make
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
comment|/* If the segment is undefined when the forward 			   reference is solved, then copy the segment id 			   from the forward symbol. */
name|SF_SET_GET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, it is the name of a non debug symbol and its value will be calculated later. */
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
block|}
else|else
block|{
name|S_SET_VALUE
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* if symbol based */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_coff_val() */
end_comment

begin_comment
comment|/*  * Maintain a list of the tagnames of the structres.  */
end_comment

begin_function
specifier|static
name|void
name|tag_init
parameter_list|()
block|{
name|tag_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
return|return ;
block|}
end_function

begin_comment
comment|/* tag_init() */
end_comment

begin_function
specifier|static
name|void
name|tag_insert
parameter_list|(
name|name
parameter_list|,
name|symbolP
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|error_string
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|error_string
operator|=
name|hash_jam
argument_list|(
name|tag_hash
argument_list|,
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|symbolP
argument_list|)
operator|)
condition|)
block|{
name|as_fatal
argument_list|(
literal|"Inserting \"%s\" into structure table failed: %s"
argument_list|,
name|name
argument_list|,
name|error_string
argument_list|)
expr_stmt|;
block|}
return|return ;
block|}
end_function

begin_comment
comment|/* tag_insert() */
end_comment

begin_function
specifier|static
name|symbolS
modifier|*
name|tag_find_or_make
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
if|if
condition|(
operator|(
name|symbolP
operator|=
name|tag_find
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|SEG_UNKNOWN
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|tag_insert
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|symbolP
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
comment|/* not found */
return|return
operator|(
name|symbolP
operator|)
return|;
block|}
end_function

begin_comment
comment|/* tag_find_or_make() */
end_comment

begin_function
specifier|static
name|symbolS
modifier|*
name|tag_find
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|STRIP_UNDERSCORE
if|if
condition|(
operator|*
name|name
operator|==
literal|'_'
condition|)
name|name
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* STRIP_UNDERSCORE */
return|return
operator|(
operator|(
name|symbolS
operator|*
operator|)
name|hash_find
argument_list|(
name|tag_hash
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* tag_find() */
end_comment

begin_function
name|void
name|obj_read_begin_hook
parameter_list|()
block|{
comment|/* These had better be the same.  Usually 18 bytes. */
ifndef|#
directive|ifndef
name|BFD_HEADERS
name|know
argument_list|(
sizeof|sizeof
argument_list|(
name|SYMENT
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|AUXENT
argument_list|)
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|SYMESZ
operator|==
name|AUXESZ
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tag_init
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_read_begin_hook() */
end_comment

begin_function
name|void
name|obj_crawl_symbol_chain
parameter_list|(
name|headers
parameter_list|)
name|object_headers
modifier|*
name|headers
decl_stmt|;
block|{
name|int
name|symbol_number
init|=
literal|0
decl_stmt|;
name|lineno
modifier|*
name|lineP
decl_stmt|;
name|symbolS
modifier|*
name|last_functionP
init|=
name|NULL
decl_stmt|;
name|symbolS
modifier|*
name|last_tagP
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolS
modifier|*
name|symbol_externP
init|=
name|NULL
decl_stmt|;
name|symbolS
modifier|*
name|symbol_extern_lastP
init|=
name|NULL
decl_stmt|;
comment|/* Initialize the stack used to keep track of the matching .bb .be */
name|stack
modifier|*
name|block_stack
init|=
name|stack_init
argument_list|(
literal|512
argument_list|,
sizeof|sizeof
argument_list|(
name|symbolS
operator|*
argument_list|)
argument_list|)
decl_stmt|;
comment|/* JF deal with forward references first... */
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
if|if
condition|(
name|symbolP
operator|->
name|sy_forward
condition|)
block|{
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|+
name|S_GET_VALUE
argument_list|(
name|symbolP
operator|->
name|sy_forward
argument_list|)
operator|+
name|symbolP
operator|->
name|sy_forward
operator|->
name|sy_frag
operator|->
name|fr_address
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
ifndef|#
directive|ifndef
name|TE_I386AIX
name|SF_GET_GET_SEGMENT
argument_list|(
argument|symbolP
argument_list|)
else|#
directive|else
name|SF_GET_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_UNKNOWN
endif|#
directive|endif
comment|/* TE_I386AIX */
condition|)
block|{
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|S_GET_SEGMENT
argument_list|(
name|symbolP
operator|->
name|sy_forward
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* forward segment also */
name|symbolP
operator|->
name|sy_forward
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if it has a forward reference */
block|}
comment|/* walk the symbol chain */
name|tc_crawl_symbol_chain
argument_list|(
name|headers
argument_list|)
expr_stmt|;
comment|/* The symbol list should be ordered according to the following sequence 	 * order : 	 * . .file symbol 	 * . debug entries for functions 	 * . fake symbols for .text .data and .bss 	 * . defined symbols 	 * . undefined symbols 	 * But this is not mandatory. The only important point is to put the 	 * undefined symbols at the end of the list. 	 */
if|if
condition|(
name|symbol_rootP
operator|==
name|NULL
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbol_rootP
argument_list|)
operator|!=
name|C_FILE
condition|)
block|{
name|know
argument_list|(
operator|!
name|previous_file_symbol
argument_list|)
expr_stmt|;
name|c_dot_file_symbol
argument_list|(
literal|"fake"
argument_list|)
expr_stmt|;
block|}
comment|/* Is there a .file symbol ? If not insert one at the beginning. */
comment|/* 	 * Build up static symbols for .text, .data and .bss 	 */
name|dot_text_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|c_section_symbol
argument_list|(
literal|".text"
argument_list|,
literal|0
argument_list|,
name|H_GET_TEXT_SIZE
argument_list|(
name|headers
argument_list|)
argument_list|,
literal|0
comment|/*text_relocation_number */
argument_list|,
literal|0
comment|/*text_lineno_number */
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TE_I386AIX
name|symbol_remove
argument_list|(
name|dot_text_symbol
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_append
argument_list|(
name|dot_text_symbol
argument_list|,
name|previous_file_symbol
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TE_I386AIX */
name|dot_data_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|c_section_symbol
argument_list|(
literal|".data"
argument_list|,
name|H_GET_TEXT_SIZE
argument_list|(
name|headers
argument_list|)
argument_list|,
name|H_GET_DATA_SIZE
argument_list|(
name|headers
argument_list|)
argument_list|,
literal|0
comment|/*data_relocation_number */
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* There are no data lineno entries */
ifdef|#
directive|ifdef
name|TE_I386AIX
name|symbol_remove
argument_list|(
name|dot_data_symbol
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_append
argument_list|(
name|dot_data_symbol
argument_list|,
name|dot_text_symbol
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TE_I386AIX */
name|dot_bss_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|c_section_symbol
argument_list|(
literal|".bss"
argument_list|,
name|H_GET_TEXT_SIZE
argument_list|(
name|headers
argument_list|)
operator|+
name|H_GET_DATA_SIZE
argument_list|(
name|headers
argument_list|)
argument_list|,
name|H_GET_BSS_SIZE
argument_list|(
name|headers
argument_list|)
argument_list|,
literal|0
argument_list|,
comment|/* No relocation for a bss section. */
literal|0
argument_list|)
expr_stmt|;
comment|/* There are no bss lineno entries */
ifdef|#
directive|ifdef
name|TE_I386AIX
name|symbol_remove
argument_list|(
name|dot_bss_symbol
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_append
argument_list|(
name|dot_bss_symbol
argument_list|,
name|dot_data_symbol
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TE_I386AIX */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
name|verify_symbol_chain
argument_list|(
name|symbol_rootP
argument_list|,
name|symbol_lastP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* Three traversals of symbol chains here.  The 	   first traversal yanks externals into a temporary 	   chain, removing the externals from the global 	   chain, numbers symbols, and does some other guck. 	   The second traversal is on the temporary chain of 	   externals and just appends them to the global 	   chain again, numbering them as we go.  The third 	   traversal patches pointers to symbols (using sym 	   indexes).  The last traversal was once done as 	   part of the first pass, but that fails when a 	   reference preceeds a definition as the definition 	   has no number at the time we process the 	   reference. */
comment|/* Note that symbolP will be NULL at the end of a loop 	   if an external was at the beginning of the list (it 	   gets moved off the list).  Hence the weird check in 	   the loop control. 	   */
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbolP
condition|?
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
else|:
name|symbol_rootP
control|)
block|{
if|if
condition|(
operator|!
name|SF_GET_DEBUG
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* Debug symbols do not need all this rubbish */
name|symbolS
modifier|*
name|real_symbolP
decl_stmt|;
comment|/* L* and C_EFCN symbols never merge. */
if|if
condition|(
operator|!
name|SF_GET_LOCAL
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|(
name|real_symbolP
operator|=
name|symbol_find_base
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|DO_NOT_STRIP
argument_list|)
operator|)
operator|&&
name|real_symbolP
operator|!=
name|symbolP
condition|)
block|{
comment|/* FIXME-SOON: where do dups come from?  Maybe tag references before definitions? xoxorich. */
comment|/* Move the debug data from the debug symbol to the 				   real symbol. Do NOT do the oposite (i.e. move from 				   real symbol to debug symbol and remove real symbol from the 				   list.) Because some pointers refer to the real symbol 				   whereas no pointers refer to the debug symbol. */
name|c_symbol_merge
argument_list|(
name|symbolP
argument_list|,
name|real_symbolP
argument_list|)
expr_stmt|;
comment|/* Replace the current symbol by the real one */
comment|/* The symbols will never be the last or the first 				   because : 1st symbol is .file and 3 last symbols are 				   .text, .data, .bss */
name|symbol_remove
argument_list|(
name|real_symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_insert
argument_list|(
name|real_symbolP
argument_list|,
name|symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_remove
argument_list|(
name|symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|real_symbolP
expr_stmt|;
block|}
comment|/* if not local but dup'd */
if|if
condition|(
name|flagseen
index|[
literal|'R'
index|]
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_DATA
operator|)
condition|)
block|{
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|SEG_TEXT
argument_list|)
expr_stmt|;
block|}
comment|/* push data into text */
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|+
name|symbolP
operator|->
name|sy_frag
operator|->
name|fr_address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|SF_GET_LOCAL
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_NULL
condition|)
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_TEXT
condition|)
block|{
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_LABEL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_STAT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* no storage class yet */
comment|/* Mainly to speed up if not -g */
if|if
condition|(
name|SF_GET_PROCESS
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* Handle the nested blocks auxiliary info. */
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_BLOCK
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
literal|".bb"
argument_list|)
condition|)
name|stack_push
argument_list|(
name|block_stack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|symbolP
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* .eb */
specifier|register
name|symbolS
modifier|*
name|begin_symbolP
decl_stmt|;
name|begin_symbolP
operator|=
operator|*
operator|(
name|symbolS
operator|*
operator|*
operator|)
name|stack_pop
argument_list|(
name|block_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|begin_symbolP
operator|==
operator|(
name|symbolS
operator|*
operator|)
literal|0
condition|)
name|as_warn
argument_list|(
literal|"mismatched .eb"
argument_list|)
expr_stmt|;
else|else
name|SA_SET_SYM_ENDNDX
argument_list|(
name|begin_symbolP
argument_list|,
name|symbol_number
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we are able to identify the type of a function, and we 				   are out of a function (last_functionP == 0) then, the 				   function symbol will be associated with an auxiliary 				   entry. */
if|if
condition|(
name|last_functionP
operator|==
operator|(
name|symbolS
operator|*
operator|)
literal|0
operator|&&
name|SF_GET_FUNCTION
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|last_functionP
operator|=
name|symbolP
expr_stmt|;
if|if
condition|(
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|)
operator|<
literal|1
condition|)
block|{
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* make it at least 1 */
comment|/* Clobber possible stale .dim information. */
name|memset
argument_list|(
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_auxent
index|[
literal|0
index|]
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_auxent
index|[
literal|0
index|]
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The C_FCN doesn't need any additional information. 				   I don't even know if this is needed for sdb. But the 				   standard assembler generates it, so... 				   */
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_EFCN
condition|)
block|{
if|if
condition|(
name|last_functionP
operator|==
operator|(
name|symbolS
operator|*
operator|)
literal|0
condition|)
name|as_fatal
argument_list|(
literal|"C_EFCN symbol out of scope"
argument_list|)
expr_stmt|;
name|SA_SET_SYM_FSIZE
argument_list|(
name|last_functionP
argument_list|,
call|(
name|long
call|)
argument_list|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|last_functionP
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SA_SET_SYM_ENDNDX
argument_list|(
name|last_functionP
argument_list|,
name|symbol_number
argument_list|)
expr_stmt|;
name|last_functionP
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|SF_GET_TAG
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* First descriptor of a structure must point to 			   the first slot after the structure description. */
name|last_tagP
operator|=
name|symbolP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_EOS
condition|)
block|{
comment|/* +2 take in account the current symbol */
name|SA_SET_SYM_ENDNDX
argument_list|(
name|last_tagP
argument_list|,
name|symbol_number
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_FILE
condition|)
block|{
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|S_SET_VALUE
argument_list|(
operator|(
name|symbolS
operator|*
operator|)
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|symbol_number
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* no one points at the first .file symbol */
block|}
comment|/* if debug or tag or eos or file */
comment|/* We must put the external symbols apart. The loader 		   does not bomb if we do not. But the references in 		   the endndx field for a .bb symbol are not corrected 		   if an external symbol is removed between .bb and .be. 		   I.e in the following case : 		   [20] .bb endndx = 22 		   [21] foo external 		   [22] .be 		   ld will move the symbol 21 to the end of the list but 		   endndx will still be 22 instead of 21. */
if|if
condition|(
name|SF_GET_LOCAL
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* remove C_EFCN and LOCAL (L...) symbols */
comment|/* next pointer remains valid */
name|symbol_remove
argument_list|(
name|symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
ifdef|#
directive|ifdef
name|TE_I386AIX
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_EXT
operator|&&
operator|!
name|SF_GET_FUNCTION
argument_list|(
name|symbolP
argument_list|)
else|#
directive|else
comment|/* not TE_I386AIX */
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|S_IS_DEBUG
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|SF_GET_STATICS
argument_list|(
name|symbolP
argument_list|)
endif|#
directive|endif
comment|/* not TE_I386AIX */
condition|)
block|{
comment|/* if external, Remove from the list */
name|symbolS
modifier|*
name|hold
init|=
name|symbol_previous
argument_list|(
name|symbolP
argument_list|)
decl_stmt|;
name|symbol_remove
argument_list|(
name|symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_clear_list_pointers
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbol_append
argument_list|(
name|symbolP
argument_list|,
name|symbol_extern_lastP
argument_list|,
operator|&
name|symbol_externP
argument_list|,
operator|&
name|symbol_extern_lastP
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|hold
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SF_GET_STRING
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|symbolP
operator|->
name|sy_name_offset
operator|=
name|string_byte_count
expr_stmt|;
name|string_byte_count
operator|+=
name|strlen
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|symbolP
operator|->
name|sy_name_offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* fix "long" names */
name|symbolP
operator|->
name|sy_number
operator|=
name|symbol_number
expr_stmt|;
name|symbol_number
operator|+=
literal|1
operator|+
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
comment|/* if local symbol */
block|}
comment|/* traverse the symbol list */
for|for
control|(
name|symbolP
operator|=
name|symbol_externP
init|;
name|symbol_externP
condition|;
control|)
block|{
name|symbolS
modifier|*
name|tmp
init|=
name|symbol_externP
decl_stmt|;
comment|/* append */
name|symbol_remove
argument_list|(
name|tmp
argument_list|,
operator|&
name|symbol_externP
argument_list|,
operator|&
name|symbol_extern_lastP
argument_list|)
expr_stmt|;
name|symbol_append
argument_list|(
name|tmp
argument_list|,
name|symbol_lastP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
comment|/* and process */
if|if
condition|(
name|SF_GET_STRING
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|tmp
operator|->
name|sy_name_offset
operator|=
name|string_byte_count
expr_stmt|;
name|string_byte_count
operator|+=
name|strlen
argument_list|(
name|S_GET_NAME
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|->
name|sy_name_offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* fix "long" names */
name|tmp
operator|->
name|sy_number
operator|=
name|symbol_number
expr_stmt|;
name|symbol_number
operator|+=
literal|1
operator|+
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* append the entire extern chain */
comment|/* When a tag reference preceeds the tag definition, 	   the definition will not have a number at the time 	   we process the reference during the first 	   traversal.  Thus, a second traversal. */
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
if|if
condition|(
name|SF_GET_TAGGED
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|SA_SET_SYM_TAGNDX
argument_list|(
name|symbolP
argument_list|,
operator|(
operator|(
name|symbolS
operator|*
operator|)
name|SA_GET_SYM_TAGNDX
argument_list|(
name|symbolP
argument_list|)
operator|)
operator|->
name|sy_number
argument_list|)
expr_stmt|;
block|}
comment|/* If the symbol has a tagndx entry, resolve it */
block|}
comment|/* second traversal */
name|know
argument_list|(
name|symbol_externP
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|symbol_extern_lastP
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* FIXME-SOMEDAY I'm counting line no's here so we know what to put in the section 	   headers, and I'm resolving the addresses since I'm not sure how to 	   do it later. I am NOT resolving the linno's representing functions. 	   Their symbols need a fileptr pointing to this linno when emitted. 	   Thus, I resolve them on emit.  xoxorich. */
for|for
control|(
name|lineP
operator|=
name|lineno_rootP
init|;
name|lineP
condition|;
name|lineP
operator|=
name|lineP
operator|->
name|next
control|)
block|{
if|if
condition|(
name|lineP
operator|->
name|line
operator|.
name|l_lnno
operator|>
literal|0
condition|)
block|{
name|lineP
operator|->
name|line
operator|.
name|l_addr
operator|.
name|l_paddr
operator|+=
operator|(
operator|(
name|fragS
operator|*
operator|)
name|lineP
operator|->
name|frag
operator|)
operator|->
name|fr_address
expr_stmt|;
block|}
else|else
block|{
empty_stmt|;
block|}
name|text_lineno_number
operator|++
expr_stmt|;
block|}
comment|/* for each line number */
name|H_SET_SYMBOL_TABLE_SIZE
argument_list|(
name|headers
argument_list|,
name|symbol_number
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_crawl_symbol_chain() */
end_comment

begin_comment
comment|/*  * Find strings by crawling along symbol table chain.  */
end_comment

begin_function
name|void
name|obj_emit_strings
parameter_list|(
name|where
parameter_list|)
name|char
modifier|*
modifier|*
name|where
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
ifdef|#
directive|ifdef
name|CROSS_COMPILE
comment|/* Gotta do md_ byte-ordering stuff for string_byte_count first - KWK */
name|md_number_to_chars
argument_list|(
operator|*
name|where
argument_list|,
name|string_byte_count
argument_list|,
sizeof|sizeof
argument_list|(
name|string_byte_count
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|string_byte_count
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* CROSS_COMPILE */
name|append
argument_list|(
name|where
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|string_byte_count
argument_list|,
operator|(
name|unsigned
name|long
operator|)
sizeof|sizeof
argument_list|(
name|string_byte_count
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CROSS_COMPILE */
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
if|if
condition|(
name|SF_GET_STRING
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|append
argument_list|(
name|where
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|strlen
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* if it has a string */
block|}
comment|/* walk the symbol chain */
return|return;
block|}
end_function

begin_comment
comment|/* obj_emit_strings() */
end_comment

begin_function
name|void
name|obj_pre_write_hook
parameter_list|(
name|headers
parameter_list|)
name|object_headers
modifier|*
name|headers
decl_stmt|;
block|{
specifier|register
name|int
name|text_relocation_number
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|data_relocation_number
init|=
literal|0
decl_stmt|;
specifier|register
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|H_SET_MAGIC_NUMBER
argument_list|(
name|headers
argument_list|,
name|FILE_HEADER_MAGIC
argument_list|)
expr_stmt|;
name|H_SET_ENTRY_POINT
argument_list|(
name|headers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME-SOMEDAY this should be done at 	   fixup_segment time but I'm going to wait until I 	   do multiple segments.  xoxorich. */
comment|/* Count the number of relocation entries for text and data */
for|for
control|(
name|fixP
operator|=
name|text_fix_root
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
operator|++
name|text_relocation_number
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_I960
comment|/* two relocs per callj under coff. */
if|if
condition|(
name|fixP
operator|->
name|fx_callj
condition|)
block|{
operator|++
name|text_relocation_number
expr_stmt|;
block|}
comment|/* if callj and not already fixed. */
endif|#
directive|endif
comment|/* TC_I960 */
ifdef|#
directive|ifdef
name|TC_A29K
comment|/* Count 2 for a constH */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|RELOC_CONSTH
condition|)
block|{
operator|++
name|text_relocation_number
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* if not yet fixed */
block|}
comment|/* for each fix */
name|SA_SET_SCN_NRELOC
argument_list|(
name|dot_text_symbol
argument_list|,
name|text_relocation_number
argument_list|)
expr_stmt|;
comment|/* Assign the number of line number entries for the text section */
name|SA_SET_SCN_NLINNO
argument_list|(
name|dot_text_symbol
argument_list|,
name|text_lineno_number
argument_list|)
expr_stmt|;
comment|/* Assign the size of the section */
name|SA_SET_SCN_SCNLEN
argument_list|(
name|dot_text_symbol
argument_list|,
name|H_GET_TEXT_SIZE
argument_list|(
name|headers
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|fixP
operator|=
name|data_fix_root
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
operator|++
name|data_relocation_number
expr_stmt|;
block|}
comment|/* if still relocatable */
ifdef|#
directive|ifdef
name|TC_A29K
comment|/* Count 2 for a constH */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|RELOC_CONSTH
condition|)
block|{
operator|++
name|data_relocation_number
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* for each fix */
name|SA_SET_SCN_NRELOC
argument_list|(
name|dot_data_symbol
argument_list|,
name|data_relocation_number
argument_list|)
expr_stmt|;
comment|/* Assign the size of the section */
name|SA_SET_SCN_SCNLEN
argument_list|(
name|dot_data_symbol
argument_list|,
name|H_GET_DATA_SIZE
argument_list|(
name|headers
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Assign the size of the section */
name|SA_SET_SCN_SCNLEN
argument_list|(
name|dot_bss_symbol
argument_list|,
name|H_GET_BSS_SIZE
argument_list|(
name|headers
argument_list|)
argument_list|)
expr_stmt|;
comment|/* pre write hook can add relocs (for 960 and 29k coff) so */
name|headers
operator|->
name|relocation_size
operator|=
name|text_relocation_number
operator|*
name|RELSZ
operator|+
name|data_relocation_number
operator|*
name|RELSZ
expr_stmt|;
comment|/* Fill in extra coff fields */
comment|/* Initialize general line number information. */
name|H_SET_LINENO_SIZE
argument_list|(
name|headers
argument_list|,
name|text_lineno_number
operator|*
name|LINESZ
argument_list|)
expr_stmt|;
comment|/* filehdr */
name|H_SET_FILE_MAGIC_NUMBER
argument_list|(
name|headers
argument_list|,
name|FILE_HEADER_MAGIC
argument_list|)
expr_stmt|;
name|H_SET_NUMBER_OF_SECTIONS
argument_list|(
name|headers
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* text+data+bss */
ifndef|#
directive|ifndef
name|OBJ_COFF_OMIT_TIMESTAMP
name|H_SET_TIME_STAMP
argument_list|(
name|headers
argument_list|,
operator|(
name|long
operator|)
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* OBJ_COFF_OMIT_TIMESTAMP */
name|H_SET_TIME_STAMP
argument_list|(
name|headers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_COFF_OMIT_TIMESTAMP */
name|H_SET_SYMBOL_TABLE_POINTER
argument_list|(
name|headers
argument_list|,
name|H_GET_SYMBOL_TABLE_FILE_OFFSET
argument_list|(
name|headers
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("FILHSZ %x\n", FILHSZ); 	printf("OBJ_COFF_AOUTHDRSZ %x\n", OBJ_COFF_AOUTHDRSZ); 	printf("section headers %x\n", H_GET_NUMBER_OF_SECTIONS(headers)  * SCNHSZ); 	printf("get text size %x\n", H_GET_TEXT_SIZE(headers)); 	printf("get data size %x\n", H_GET_DATA_SIZE(headers)); 	printf("get relocation size %x\n", H_GET_RELOCATION_SIZE(headers)); 	printf("get lineno size %x\n", H_GET_LINENO_SIZE(headers));
endif|#
directive|endif
comment|/* symbol table size allready set */
name|H_SET_SIZEOF_OPTIONAL_HEADER
argument_list|(
name|headers
argument_list|,
name|OBJ_COFF_AOUTHDRSZ
argument_list|)
expr_stmt|;
comment|/* do not added the F_RELFLG for the standard COFF. 	 * The AIX linker complain on file with relocation info striped flag. 	 */
ifdef|#
directive|ifdef
name|KEEP_RELOC_INFO
name|H_SET_FLAGS
argument_list|(
name|headers
argument_list|,
operator|(
name|text_lineno_number
operator|==
literal|0
condition|?
name|F_LNNO
else|:
literal|0
operator|)
operator||
name|BYTE_ORDERING
argument_list|)
expr_stmt|;
else|#
directive|else
name|H_SET_FLAGS
argument_list|(
name|headers
argument_list|,
operator|(
name|text_lineno_number
operator|==
literal|0
condition|?
name|F_LNNO
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|text_relocation_number
operator|+
name|data_relocation_number
operator|)
condition|?
literal|0
else|:
name|F_RELFLG
operator|)
operator||
name|BYTE_ORDERING
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* aouthdr */
comment|/* magic number allready set */
name|H_SET_VERSION_STAMP
argument_list|(
name|headers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Text, data, bss size; entry point; text_start and data_start are already set */
comment|/* Build section headers */
name|c_section_header
argument_list|(
operator|&
name|text_section_header
argument_list|,
literal|".text"
argument_list|,
literal|0
argument_list|,
name|H_GET_TEXT_SIZE
argument_list|(
name|headers
argument_list|)
argument_list|,
name|H_GET_TEXT_FILE_OFFSET
argument_list|(
name|headers
argument_list|)
argument_list|,
operator|(
name|SA_GET_SCN_NRELOC
argument_list|(
name|dot_text_symbol
argument_list|)
condition|?
name|H_GET_RELOCATION_FILE_OFFSET
argument_list|(
name|headers
argument_list|)
else|:
literal|0
operator|)
argument_list|,
operator|(
name|text_lineno_number
condition|?
name|H_GET_LINENO_FILE_OFFSET
argument_list|(
name|headers
argument_list|)
else|:
literal|0
operator|)
argument_list|,
name|SA_GET_SCN_NRELOC
argument_list|(
name|dot_text_symbol
argument_list|)
argument_list|,
name|text_lineno_number
argument_list|,
name|section_alignment
index|[
operator|(
name|int
operator|)
name|SEG_TEXT
index|]
argument_list|)
expr_stmt|;
name|c_section_header
argument_list|(
operator|&
name|data_section_header
argument_list|,
literal|".data"
argument_list|,
name|H_GET_TEXT_SIZE
argument_list|(
name|headers
argument_list|)
argument_list|,
name|H_GET_DATA_SIZE
argument_list|(
name|headers
argument_list|)
argument_list|,
operator|(
name|H_GET_DATA_SIZE
argument_list|(
name|headers
argument_list|)
condition|?
name|H_GET_DATA_FILE_OFFSET
argument_list|(
name|headers
argument_list|)
else|:
literal|0
operator|)
argument_list|,
operator|(
name|SA_GET_SCN_NRELOC
argument_list|(
name|dot_data_symbol
argument_list|)
condition|?
operator|(
name|H_GET_RELOCATION_FILE_OFFSET
argument_list|(
name|headers
argument_list|)
operator|+
name|text_section_header
operator|.
name|s_nreloc
operator|*
name|RELSZ
operator|)
else|:
literal|0
operator|)
argument_list|,
literal|0
argument_list|,
comment|/* No line number information */
name|SA_GET_SCN_NRELOC
argument_list|(
name|dot_data_symbol
argument_list|)
argument_list|,
literal|0
argument_list|,
comment|/* No line number information */
name|section_alignment
index|[
operator|(
name|int
operator|)
name|SEG_DATA
index|]
argument_list|)
expr_stmt|;
name|c_section_header
argument_list|(
operator|&
name|bss_section_header
argument_list|,
literal|".bss"
argument_list|,
name|H_GET_TEXT_SIZE
argument_list|(
name|headers
argument_list|)
operator|+
name|H_GET_DATA_SIZE
argument_list|(
name|headers
argument_list|)
argument_list|,
name|H_GET_BSS_SIZE
argument_list|(
name|headers
argument_list|)
argument_list|,
literal|0
argument_list|,
comment|/* No file offset */
literal|0
argument_list|,
comment|/* No relocation information */
literal|0
argument_list|,
comment|/* No line number information */
literal|0
argument_list|,
comment|/* No relocation information */
literal|0
argument_list|,
comment|/* No line number information */
name|section_alignment
index|[
operator|(
name|int
operator|)
name|SEG_BSS
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_pre_write_hook() */
end_comment

begin_comment
comment|/* This is a copy from aout.  All I do is neglect to actually build the symbol. */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_stab
parameter_list|(
name|what
parameter_list|)
name|int
name|what
decl_stmt|;
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|expressionS
name|e
decl_stmt|;
name|int
name|goof
init|=
literal|0
decl_stmt|;
comment|/* TRUE if we have aborted. */
name|int
name|length
decl_stmt|;
name|int
name|saved_type
init|=
literal|0
decl_stmt|;
name|long
name|longint
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|what
operator|==
literal|'s'
condition|)
block|{
name|string
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|length
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|"I need a comma after symbol's name"
argument_list|)
expr_stmt|;
name|goof
operator|=
literal|1
expr_stmt|;
block|}
comment|/* better be a comma */
block|}
comment|/* skip the string */
comment|/* 	 * Input_line_pointer->after ','.  String->symbol name. 	 */
if|if
condition|(
operator|!
name|goof
condition|)
block|{
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|longint
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"I want a comma after the n_type expression"
argument_list|)
expr_stmt|;
name|goof
operator|=
literal|1
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Backup over a non-',' char. */
block|}
comment|/* on error */
block|}
comment|/* no error */
if|if
condition|(
operator|!
name|goof
condition|)
block|{
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|longint
argument_list|)
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"I want a comma after the n_other expression"
argument_list|)
expr_stmt|;
name|goof
operator|=
literal|1
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Backup over a non-',' char. */
block|}
comment|/* on error */
block|}
comment|/* no error */
if|if
condition|(
operator|!
name|goof
condition|)
block|{
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|what
operator|==
literal|'s'
operator|||
name|what
operator|==
literal|'n'
condition|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"I want a comma after the n_desc expression"
argument_list|)
expr_stmt|;
name|goof
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|input_line_pointer
operator|++
expr_stmt|;
block|}
comment|/* on goof */
block|}
comment|/* not stabd */
block|}
comment|/* no error */
name|expression
argument_list|(
operator|&
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|goof
condition|)
block|{
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
comment|/* on error */
block|}
end_function

begin_comment
comment|/* obj_coff_stab() */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/* for debugging */
end_comment

begin_function
name|char
modifier|*
name|s_get_name
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|s
operator|==
name|NULL
operator|)
condition|?
literal|"(NULL)"
else|:
name|S_GET_NAME
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* s_get_name() */
end_comment

begin_function
name|void
name|symbol_dump
parameter_list|()
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
name|printf
argument_list|(
literal|"%3ld: 0x%lx \"%s\" type = %ld, class = %d, segment = %d\n"
argument_list|,
name|symbolP
operator|->
name|sy_number
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|symbolP
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|S_GET_DATA_TYPE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* traverse symbols */
return|return;
block|}
end_function

begin_comment
comment|/* symbol_dump() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * Local Variables:  * comment-column: 0  * fill-column: 131  * End:  */
end_comment

begin_comment
comment|/* end of obj-coff.c */
end_comment

end_unit

