begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-i960.c - All the i80960-specific stuff    Copyright (C) 1989, 1990, 1991, 1992 Free Software Foundation, Inc.     This file is part of GAS.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* See comment on md_parse_option for 80960-specific invocation options. */
end_comment

begin_comment
comment|/******************************************************************************  * i80690 NOTE!!!:  *	Header, symbol, and relocation info will be used on the host machine  *	only -- only executable code is actually downloaded to the i80960.  *	Therefore, leave all such information in host byte order.  *  *	(That's a slight lie -- we DO download some header information, but  *	the downloader converts the file format and corrects the byte-ordering  *	of the relevant fields while doing so.)  *  ***************************************************************************** */
end_comment

begin_comment
comment|/* There are 4 different lengths of (potentially) symbol-based displacements  * in the 80960 instruction set, each of which could require address fix-ups  * and (in the case of external symbols) emission of relocation directives:  *  * 32-bit (MEMB)  *	This is a standard length for the base assembler and requires no  *	special action.  *  * 13-bit (COBR)  *	This is a non-standard length, but the base assembler has a hook for  *	bit field address fixups:  the fixS structure can point to a descriptor  *	of the field, in which case our md_number_to_field() routine gets called  *	to process it.  *  *	I made the hook a little cleaner by having fix_new() (in the base  *	assembler) return a pointer to the fixS in question.  And I made it a  *	little simpler by storing the field size (in this case 13) instead of  *	of a pointer to another structure:  80960 displacements are ALWAYS  *	stored in the low-order bits of a 4-byte word.  *  *	Since the target of a COBR cannot be external, no relocation directives  *	for this size displacement have to be generated.  But the base assembler  *	had to be modified to issue error messages if the symbol did turn out  *	to be external.  *  * 24-bit (CTRL)  *	Fixups are handled as for the 13-bit case (except that 24 is stored  *	in the fixS).  *  *	The relocation directive generated is the same as that for the 32-bit  *	displacement, except that it's PC-relative (the 32-bit displacement  *	never is).   The i80960 version of the linker needs a mod to  *	distinguish and handle the 24-bit case.  *  * 12-bit (MEMA)  *	MEMA formats are always promoted to MEMB (32-bit) if the displacement  *	is based on a symbol, because it could be relocated at link time.  *	The only time we use the 12-bit format is if an absolute value of  *	less than 4096 is specified, in which case we need neither a fixup nor  *	a relocation directive.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"opcode/i960.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|input_line_pointer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|hash_control
modifier|*
name|po_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|next_object_file_charP
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_COFF
end_ifdef

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|reloc
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* OBJ_COFF */
end_comment

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_COFF */
end_comment

begin_comment
comment|/***************************  *  Local i80960 routines  *  ************************** */
end_comment

begin_function_decl
specifier|static
name|void
name|brcnt_emit
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Emit branch-prediction instrumentation code */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|brlab_next
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Return next branch local label */
end_comment

begin_function_decl
name|void
name|brtab_emit
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Emit br-predict instrumentation table */
end_comment

begin_function_decl
specifier|static
name|void
name|cobr_fmt
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Generate COBR instruction */
end_comment

begin_function_decl
specifier|static
name|void
name|ctrl_fmt
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Generate CTRL instruction */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|emit
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Emit (internally) binary */
end_comment

begin_function_decl
specifier|static
name|int
name|get_args
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Break arguments out of comma-separated list */
end_comment

begin_function_decl
specifier|static
name|void
name|get_cdisp
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Handle COBR or CTRL displacement */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|get_ispec
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Find index specification string */
end_comment

begin_function_decl
specifier|static
name|int
name|get_regnum
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Translate text to register number */
end_comment

begin_function_decl
specifier|static
name|int
name|i_scan
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Lexical scan of instruction source */
end_comment

begin_function_decl
specifier|static
name|void
name|mem_fmt
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Generate MEMA or MEMB instruction */
end_comment

begin_function_decl
specifier|static
name|void
name|mema_to_memb
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Convert MEMA instruction to MEMB format */
end_comment

begin_function_decl
specifier|static
name|segT
name|parse_expr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Parse an expression */
end_comment

begin_function_decl
specifier|static
name|int
name|parse_ldconst
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Parse and replace a 'ldconst' pseudo-op */
end_comment

begin_function_decl
specifier|static
name|void
name|parse_memop
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Parse a memory operand */
end_comment

begin_function_decl
specifier|static
name|void
name|parse_po
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Parse machine-dependent pseudo-op */
end_comment

begin_function_decl
specifier|static
name|void
name|parse_regop
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Parse a register operand */
end_comment

begin_function_decl
specifier|static
name|void
name|reg_fmt
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Generate a REG format instruction */
end_comment

begin_function_decl
name|void
name|reloc_callj
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Relocate a 'callj' instruction */
end_comment

begin_function_decl
specifier|static
name|void
name|relax_cobr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* "De-optimize" cobr into compare/branch */
end_comment

begin_function_decl
specifier|static
name|void
name|s_leafproc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Process '.leafproc' pseudo-op */
end_comment

begin_function_decl
specifier|static
name|void
name|s_sysproc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Process '.sysproc' pseudo-op */
end_comment

begin_function_decl
specifier|static
name|int
name|shift_ok
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Will a 'shlo' substiture for a 'ldconst'? */
end_comment

begin_function_decl
specifier|static
name|void
name|syntax
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Give syntax error */
end_comment

begin_function_decl
specifier|static
name|int
name|targ_has_sfr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Target chip supports spec-func register? */
end_comment

begin_function_decl
specifier|static
name|int
name|targ_has_iclass
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Target chip supports instruction set? */
end_comment

begin_comment
comment|/* static void	unlink_sym(); */
end_comment

begin_comment
comment|/* Remove a symbol from the symbol list */
end_comment

begin_comment
comment|/* See md_parse_option() for meanings of these options */
end_comment

begin_decl_stmt
specifier|static
name|char
name|norelax
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if -norelax switch seen */
end_comment

begin_decl_stmt
specifier|static
name|char
name|instrument_branches
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if -b switch seen */
end_comment

begin_comment
comment|/* Characters that always start a comment.  * If the pre-processor is disabled, these aren't very useful.  */
end_comment

begin_decl_stmt
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters that only start a comment at the beginning of  * a line.  If the line seems to have the form '# 123 filename'  * .line and .file directives will appear in the pre-processed output.  *  * Note that input_file.c hand checks for '#' at the beginning of the  * first line of the input file.  This is because the compiler outputs  * #NO_APP at the beginning of its output.  */
end_comment

begin_comment
comment|/* Also note that comments started like this one will always work. */
end_comment

begin_decl_stmt
name|char
name|line_comment_chars
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums */
end_comment

begin_decl_stmt
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant,  * as in 0f12.456 or 0d1.2345e12  */
end_comment

begin_decl_stmt
name|char
name|FLT_CHARS
index|[]
init|=
literal|"fFdDtT"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table used by base assembler to relax addresses based on varying length  * instructions.  The fields are:  *   1) most positive reach of this state,  *   2) most negative reach of this state,  *   3) how many bytes this mode will add to the size of the current frag  *   4) which index into the table to try if we can't fit into this one.  *  * For i80960, the only application is the (de-)optimization of cobr  * instructions into separate compare and branch instructions when a 13-bit  * displacement won't hack it.  */
end_comment

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* State 0 => no more relaxation possible */
block|{
literal|4088
block|,
operator|-
literal|4096
block|,
literal|0
block|,
literal|2
block|}
block|,
comment|/* State 1: conditional branch (cobr) */
block|{
literal|0x800000
operator|-
literal|8
block|,
operator|-
literal|0x800000
block|,
literal|4
block|,
literal|0
block|}
block|,
comment|/* State 2: compare (reg)& branch (ctrl) */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are the machine dependent pseudo-ops.  *  * This table describes all the machine specific pseudo-ops the assembler  * has to support.  The fields are:  *	pseudo-op name without dot  *	function to call to execute this pseudo-op  *	integer arg to pass to the function  */
end_comment

begin_define
define|#
directive|define
name|S_LEAFPROC
value|1
end_define

begin_define
define|#
directive|define
name|S_SYSPROC
value|2
end_define

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"bss"
block|,
name|s_lcomm
block|,
literal|1
block|}
block|,
block|{
literal|"extended"
block|,
name|float_cons
block|,
literal|'t'
block|}
block|,
block|{
literal|"leafproc"
block|,
name|parse_po
block|,
name|S_LEAFPROC
block|}
block|,
block|{
literal|"sysproc"
block|,
name|parse_po
block|,
name|S_SYSPROC
block|}
block|,
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
literal|"quad"
block|,
name|big_cons
block|,
literal|16
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Macros to extract info from an 'expressionS' structure 'e' */
end_comment

begin_define
define|#
directive|define
name|adds
parameter_list|(
name|e
parameter_list|)
value|e.X_add_symbol
end_define

begin_define
define|#
directive|define
name|subs
parameter_list|(
name|e
parameter_list|)
value|e.X_subtract_symbol
end_define

begin_define
define|#
directive|define
name|offs
parameter_list|(
name|e
parameter_list|)
value|e.X_add_number
end_define

begin_define
define|#
directive|define
name|segs
parameter_list|(
name|e
parameter_list|)
value|e.X_seg
end_define

begin_comment
comment|/* Branch-prediction bits for CTRL/COBR format opcodes */
end_comment

begin_define
define|#
directive|define
name|BP_MASK
value|0x00000002
end_define

begin_comment
comment|/* Mask for branch-prediction bit */
end_comment

begin_define
define|#
directive|define
name|BP_TAKEN
value|0x00000000
end_define

begin_comment
comment|/* Value to OR in to predict branch */
end_comment

begin_define
define|#
directive|define
name|BP_NOT_TAKEN
value|0x00000002
end_define

begin_comment
comment|/* Value to OR in to predict no branch */
end_comment

begin_comment
comment|/* Some instruction opcodes that we need explicitly */
end_comment

begin_define
define|#
directive|define
name|BE
value|0x12000000
end_define

begin_define
define|#
directive|define
name|BG
value|0x11000000
end_define

begin_define
define|#
directive|define
name|BGE
value|0x13000000
end_define

begin_define
define|#
directive|define
name|BL
value|0x14000000
end_define

begin_define
define|#
directive|define
name|BLE
value|0x16000000
end_define

begin_define
define|#
directive|define
name|BNE
value|0x15000000
end_define

begin_define
define|#
directive|define
name|BNO
value|0x10000000
end_define

begin_define
define|#
directive|define
name|BO
value|0x17000000
end_define

begin_define
define|#
directive|define
name|CHKBIT
value|0x5a002700
end_define

begin_define
define|#
directive|define
name|CMPI
value|0x5a002080
end_define

begin_define
define|#
directive|define
name|CMPO
value|0x5a002000
end_define

begin_define
define|#
directive|define
name|B
value|0x08000000
end_define

begin_define
define|#
directive|define
name|BAL
value|0x0b000000
end_define

begin_define
define|#
directive|define
name|CALL
value|0x09000000
end_define

begin_define
define|#
directive|define
name|CALLS
value|0x66003800
end_define

begin_define
define|#
directive|define
name|RET
value|0x0a000000
end_define

begin_comment
comment|/* These masks are used to build up a set of MEMB mode bits. */
end_comment

begin_define
define|#
directive|define
name|A_BIT
value|0x0400
end_define

begin_define
define|#
directive|define
name|I_BIT
value|0x0800
end_define

begin_define
define|#
directive|define
name|MEMB_BIT
value|0x1000
end_define

begin_define
define|#
directive|define
name|D_BIT
value|0x2000
end_define

begin_comment
comment|/* Mask for the only mode bit in a MEMA instruction (if set, abase reg is used) */
end_comment

begin_define
define|#
directive|define
name|MEMA_ABASE
value|0x2000
end_define

begin_comment
comment|/* Info from which a MEMA or MEMB format instruction can be generated */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|long
name|opcode
decl_stmt|;
comment|/* (First) 32 bits of instruction */
name|int
name|disp
decl_stmt|;
comment|/* 0-(none), 12- or, 32-bit displacement needed */
name|char
modifier|*
name|e
decl_stmt|;
comment|/* The expression in the source instruction from 			 *	which the displacement should be determined 			 */
block|}
name|memS
typedef|;
end_typedef

begin_comment
comment|/* The two pieces of info we need to generate a register operand */
end_comment

begin_struct
struct|struct
name|regop
block|{
name|int
name|mode
decl_stmt|;
comment|/* 0 =>local/global/spec reg; 1=> literal or fp reg */
name|int
name|special
decl_stmt|;
comment|/* 0 =>not a sfr;  1=> is a sfr (not valid w/mode=0) */
name|int
name|n
decl_stmt|;
comment|/* Register number or literal value */
block|}
struct|;
end_struct

begin_comment
comment|/* Number and assembler mnemonic for all registers that can appear in operands */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|reg_name
decl_stmt|;
name|int
name|reg_num
decl_stmt|;
block|}
name|regnames
index|[]
init|=
block|{
block|{
literal|"pfp"
block|,
literal|0
block|}
block|,
block|{
literal|"sp"
block|,
literal|1
block|}
block|,
block|{
literal|"rip"
block|,
literal|2
block|}
block|,
block|{
literal|"r3"
block|,
literal|3
block|}
block|,
block|{
literal|"r4"
block|,
literal|4
block|}
block|,
block|{
literal|"r5"
block|,
literal|5
block|}
block|,
block|{
literal|"r6"
block|,
literal|6
block|}
block|,
block|{
literal|"r7"
block|,
literal|7
block|}
block|,
block|{
literal|"r8"
block|,
literal|8
block|}
block|,
block|{
literal|"r9"
block|,
literal|9
block|}
block|,
block|{
literal|"r10"
block|,
literal|10
block|}
block|,
block|{
literal|"r11"
block|,
literal|11
block|}
block|,
block|{
literal|"r12"
block|,
literal|12
block|}
block|,
block|{
literal|"r13"
block|,
literal|13
block|}
block|,
block|{
literal|"r14"
block|,
literal|14
block|}
block|,
block|{
literal|"r15"
block|,
literal|15
block|}
block|,
block|{
literal|"g0"
block|,
literal|16
block|}
block|,
block|{
literal|"g1"
block|,
literal|17
block|}
block|,
block|{
literal|"g2"
block|,
literal|18
block|}
block|,
block|{
literal|"g3"
block|,
literal|19
block|}
block|,
block|{
literal|"g4"
block|,
literal|20
block|}
block|,
block|{
literal|"g5"
block|,
literal|21
block|}
block|,
block|{
literal|"g6"
block|,
literal|22
block|}
block|,
block|{
literal|"g7"
block|,
literal|23
block|}
block|,
block|{
literal|"g8"
block|,
literal|24
block|}
block|,
block|{
literal|"g9"
block|,
literal|25
block|}
block|,
block|{
literal|"g10"
block|,
literal|26
block|}
block|,
block|{
literal|"g11"
block|,
literal|27
block|}
block|,
block|{
literal|"g12"
block|,
literal|28
block|}
block|,
block|{
literal|"g13"
block|,
literal|29
block|}
block|,
block|{
literal|"g14"
block|,
literal|30
block|}
block|,
block|{
literal|"fp"
block|,
literal|31
block|}
block|,
comment|/* Numbers for special-function registers are for assembler internal 	 * use only: they are scaled back to range [0-31] for binary output. 	 */
define|#
directive|define
name|SF0
value|32
block|{
literal|"sf0"
block|,
literal|32
block|}
block|,
block|{
literal|"sf1"
block|,
literal|33
block|}
block|,
block|{
literal|"sf2"
block|,
literal|34
block|}
block|,
block|{
literal|"sf3"
block|,
literal|35
block|}
block|,
block|{
literal|"sf4"
block|,
literal|36
block|}
block|,
block|{
literal|"sf5"
block|,
literal|37
block|}
block|,
block|{
literal|"sf6"
block|,
literal|38
block|}
block|,
block|{
literal|"sf7"
block|,
literal|39
block|}
block|,
block|{
literal|"sf8"
block|,
literal|40
block|}
block|,
block|{
literal|"sf9"
block|,
literal|41
block|}
block|,
block|{
literal|"sf10"
block|,
literal|42
block|}
block|,
block|{
literal|"sf11"
block|,
literal|43
block|}
block|,
block|{
literal|"sf12"
block|,
literal|44
block|}
block|,
block|{
literal|"sf13"
block|,
literal|45
block|}
block|,
block|{
literal|"sf14"
block|,
literal|46
block|}
block|,
block|{
literal|"sf15"
block|,
literal|47
block|}
block|,
block|{
literal|"sf16"
block|,
literal|48
block|}
block|,
block|{
literal|"sf17"
block|,
literal|49
block|}
block|,
block|{
literal|"sf18"
block|,
literal|50
block|}
block|,
block|{
literal|"sf19"
block|,
literal|51
block|}
block|,
block|{
literal|"sf20"
block|,
literal|52
block|}
block|,
block|{
literal|"sf21"
block|,
literal|53
block|}
block|,
block|{
literal|"sf22"
block|,
literal|54
block|}
block|,
block|{
literal|"sf23"
block|,
literal|55
block|}
block|,
block|{
literal|"sf24"
block|,
literal|56
block|}
block|,
block|{
literal|"sf25"
block|,
literal|57
block|}
block|,
block|{
literal|"sf26"
block|,
literal|58
block|}
block|,
block|{
literal|"sf27"
block|,
literal|59
block|}
block|,
block|{
literal|"sf28"
block|,
literal|60
block|}
block|,
block|{
literal|"sf29"
block|,
literal|61
block|}
block|,
block|{
literal|"sf30"
block|,
literal|62
block|}
block|,
block|{
literal|"sf31"
block|,
literal|63
block|}
block|,
comment|/* Numbers for floating point registers are for assembler internal use 	 * only: they are scaled back to [0-3] for binary output. 	 */
define|#
directive|define
name|FP0
value|64
block|{
literal|"fp0"
block|,
literal|64
block|}
block|,
block|{
literal|"fp1"
block|,
literal|65
block|}
block|,
block|{
literal|"fp2"
block|,
literal|66
block|}
block|,
block|{
literal|"fp3"
block|,
literal|67
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* END OF LIST */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|IS_RG_REG
parameter_list|(
name|n
parameter_list|)
value|((0<= (n))&& ((n)< SF0))
end_define

begin_define
define|#
directive|define
name|IS_SF_REG
parameter_list|(
name|n
parameter_list|)
value|((SF0<= (n))&& ((n)< FP0))
end_define

begin_define
define|#
directive|define
name|IS_FP_REG
parameter_list|(
name|n
parameter_list|)
value|((n)>= FP0)
end_define

begin_comment
comment|/* Number and assembler mnemonic for all registers that can appear as 'abase'  * (indirect addressing) registers.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|areg_name
decl_stmt|;
name|int
name|areg_num
decl_stmt|;
block|}
name|aregs
index|[]
init|=
block|{
block|{
literal|"(pfp)"
block|,
literal|0
block|}
block|,
block|{
literal|"(sp)"
block|,
literal|1
block|}
block|,
block|{
literal|"(rip)"
block|,
literal|2
block|}
block|,
block|{
literal|"(r3)"
block|,
literal|3
block|}
block|,
block|{
literal|"(r4)"
block|,
literal|4
block|}
block|,
block|{
literal|"(r5)"
block|,
literal|5
block|}
block|,
block|{
literal|"(r6)"
block|,
literal|6
block|}
block|,
block|{
literal|"(r7)"
block|,
literal|7
block|}
block|,
block|{
literal|"(r8)"
block|,
literal|8
block|}
block|,
block|{
literal|"(r9)"
block|,
literal|9
block|}
block|,
block|{
literal|"(r10)"
block|,
literal|10
block|}
block|,
block|{
literal|"(r11)"
block|,
literal|11
block|}
block|,
block|{
literal|"(r12)"
block|,
literal|12
block|}
block|,
block|{
literal|"(r13)"
block|,
literal|13
block|}
block|,
block|{
literal|"(r14)"
block|,
literal|14
block|}
block|,
block|{
literal|"(r15)"
block|,
literal|15
block|}
block|,
block|{
literal|"(g0)"
block|,
literal|16
block|}
block|,
block|{
literal|"(g1)"
block|,
literal|17
block|}
block|,
block|{
literal|"(g2)"
block|,
literal|18
block|}
block|,
block|{
literal|"(g3)"
block|,
literal|19
block|}
block|,
block|{
literal|"(g4)"
block|,
literal|20
block|}
block|,
block|{
literal|"(g5)"
block|,
literal|21
block|}
block|,
block|{
literal|"(g6)"
block|,
literal|22
block|}
block|,
block|{
literal|"(g7)"
block|,
literal|23
block|}
block|,
block|{
literal|"(g8)"
block|,
literal|24
block|}
block|,
block|{
literal|"(g9)"
block|,
literal|25
block|}
block|,
block|{
literal|"(g10)"
block|,
literal|26
block|}
block|,
block|{
literal|"(g11)"
block|,
literal|27
block|}
block|,
block|{
literal|"(g12)"
block|,
literal|28
block|}
block|,
block|{
literal|"(g13)"
block|,
literal|29
block|}
block|,
block|{
literal|"(g14)"
block|,
literal|30
block|}
block|,
block|{
literal|"(fp)"
block|,
literal|31
block|}
block|,
define|#
directive|define
name|IPREL
value|32
comment|/* for assembler internal use only: this number never appears in binary 	 * output. 	 */
block|{
literal|"(ip)"
block|,
name|IPREL
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|,
comment|/* END OF LIST */
block|}
struct|;
end_struct

begin_comment
comment|/* Hash tables */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Opcode mnemonics */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|reg_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register name hash table */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|areg_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Abase register hash table */
end_comment

begin_comment
comment|/* Architecture for which we are assembling */
end_comment

begin_define
define|#
directive|define
name|ARCH_ANY
value|0
end_define

begin_comment
comment|/* Default: no architecture checking done */
end_comment

begin_define
define|#
directive|define
name|ARCH_KA
value|1
end_define

begin_define
define|#
directive|define
name|ARCH_KB
value|2
end_define

begin_define
define|#
directive|define
name|ARCH_MC
value|3
end_define

begin_define
define|#
directive|define
name|ARCH_CA
value|4
end_define

begin_decl_stmt
name|int
name|architecture
init|=
name|ARCH_ANY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Architecture requested on invocation line */
end_comment

begin_decl_stmt
name|int
name|iclasses_seen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* OR of instruction classes (I_* constants) 				 *	for which we've actually assembled 				 *	instructions. 				 */
end_comment

begin_comment
comment|/* BRANCH-PREDICTION INSTRUMENTATION  *  *	The following supports generation of branch-prediction instrumentation  *	(turned on by -b switch).  The instrumentation collects counts  *	of branches taken/not-taken for later input to a utility that will  *	set the branch prediction bits of the instructions in accordance with  *	the behavior observed.  (Note that the KX series does not have  *	brach-prediction.)  *  *	The instrumentation consists of:  *  *	(1) before and after each conditional branch, a call to an external  *	    routine that increments and steps over an inline counter.  The  *	    counter itself, initialized to 0, immediately follows the call  *	    instruction.  For each branch, the counter following the branch  *	    is the number of times the branch was not taken, and the difference  *	    between the counters is the number of times it was taken.  An  *	    example of an instrumented conditional branch:  *  *				call	BR_CNT_FUNC  *				.word	0  *		LBRANCH23:	be	label  *				call	BR_CNT_FUNC  *				.word	0  *  *	(2) a table of pointers to the instrumented branches, so that an  *	    external postprocessing routine can locate all of the counters.  *	    the table begins with a 2-word header: a pointer to the next in  *	    a linked list of such tables (initialized to 0);  and a count  *	    of the number of entries in the table (exclusive of the header.  *  *	    Note that input source code is expected to already contain calls  *	    an external routine that will link the branch local table into a  *	    list of such tables.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|br_cnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of branches instrumented so far. 				 * Also used to generate unique local labels 				 * for each instrumented branch 				 */
end_comment

begin_define
define|#
directive|define
name|BR_LABEL_BASE
value|"LBRANCH"
end_define

begin_comment
comment|/* Basename of local labels on instrumented  * branches, to avoid conflict with compiler-  * generated local labels.  */
end_comment

begin_define
define|#
directive|define
name|BR_CNT_FUNC
value|"__inc_branch"
end_define

begin_comment
comment|/* Name of the external routine that will  * increment (and step over) an inline counter.  */
end_comment

begin_define
define|#
directive|define
name|BR_TAB_NAME
value|"__BRANCH_TABLE__"
end_define

begin_comment
comment|/* Name of the table of pointers to branches.  * A local (i.e., non-external) symbol.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*****************************************************************************  * md_begin:  One-time initialization.  *  *	Set up hash tables.  *  **************************************************************************** */
end_comment

begin_function
name|void
name|md_begin
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* Loop counter */
specifier|const
name|struct
name|i960_opcode
modifier|*
name|oP
decl_stmt|;
comment|/* Pointer into opcode table */
name|char
modifier|*
name|retval
decl_stmt|;
comment|/* Value returned by hash functions */
if|if
condition|(
operator|(
operator|(
name|op_hash
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|reg_hash
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|areg_hash
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|as_fatal
argument_list|(
literal|"virtual memory exceeded"
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|""
expr_stmt|;
comment|/* For some reason, the base assembler uses an empty 			 * string for "no error message", instead of a NULL 			 * pointer. 			 */
for|for
control|(
name|oP
operator|=
name|i960_opcodes
init|;
name|oP
operator|->
name|name
operator|&&
operator|!
operator|*
name|retval
condition|;
name|oP
operator|++
control|)
block|{
name|retval
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|oP
operator|->
name|name
argument_list|,
name|oP
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|regnames
index|[
name|i
index|]
operator|.
name|reg_name
operator|&&
operator|!
operator|*
name|retval
condition|;
name|i
operator|++
control|)
block|{
name|retval
operator|=
name|hash_insert
argument_list|(
name|reg_hash
argument_list|,
name|regnames
index|[
name|i
index|]
operator|.
name|reg_name
argument_list|,
operator|&
name|regnames
index|[
name|i
index|]
operator|.
name|reg_num
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|aregs
index|[
name|i
index|]
operator|.
name|areg_name
operator|&&
operator|!
operator|*
name|retval
condition|;
name|i
operator|++
control|)
block|{
name|retval
operator|=
name|hash_insert
argument_list|(
name|areg_hash
argument_list|,
name|aregs
index|[
name|i
index|]
operator|.
name|areg_name
argument_list|,
operator|&
name|aregs
index|[
name|i
index|]
operator|.
name|areg_num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|retval
condition|)
block|{
name|as_fatal
argument_list|(
literal|"Hashing returned \"%s\"."
argument_list|,
name|retval
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* md_begin() */
end_comment

begin_comment
comment|/*****************************************************************************  * md_end:  One-time final cleanup  *  *	None necessary  *  **************************************************************************** */
end_comment

begin_function
name|void
name|md_end
parameter_list|()
block|{ }
end_function

begin_comment
comment|/*****************************************************************************  * md_assemble:  Assemble an instruction  *  * Assumptions about the passed-in text:  *	- all comments, labels removed  *	- text is an instruction  *	- all white space compressed to single blanks  *	- all character constants have been replaced with decimal  *  **************************************************************************** */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|textP
parameter_list|)
name|char
modifier|*
name|textP
decl_stmt|;
comment|/* Source text of instruction */
block|{
name|char
modifier|*
name|args
index|[
literal|4
index|]
decl_stmt|;
comment|/* Parsed instruction text, containing NO whitespace: 			 *	arg[0]->opcode mnemonic 			 *	arg[1-3]->operands, with char constants 			 *			replaced by decimal numbers 			 */
name|int
name|n_ops
decl_stmt|;
comment|/* Number of instruction operands */
name|struct
name|i960_opcode
modifier|*
name|oP
decl_stmt|;
comment|/* Pointer to instruction description */
name|int
name|branch_predict
decl_stmt|;
comment|/* TRUE iff opcode mnemonic included branch-prediction 	 *	suffix (".f" or ".t") 	 */
name|long
name|bp_bits
decl_stmt|;
comment|/* Setting of branch-prediction bit(s) to be OR'd 			 *	into instruction opcode of CTRL/COBR format 			 *	instructions. 			 */
name|int
name|n
decl_stmt|;
comment|/* Offset of last character in opcode mnemonic */
specifier|static
specifier|const
name|char
name|bp_error_msg
index|[]
init|=
literal|"branch prediction invalid on this opcode"
decl_stmt|;
comment|/* Parse instruction into opcode and operands */
name|memset
argument_list|(
name|args
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|n_ops
operator|=
name|i_scan
argument_list|(
name|textP
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_ops
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
comment|/* Error message already issued */
block|}
comment|/* Do "macro substitution" (sort of) on 'ldconst' pseudo-instruction */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
literal|"ldconst"
argument_list|)
condition|)
block|{
name|n_ops
operator|=
name|parse_ldconst
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_ops
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
block|}
block|}
comment|/* Check for branch-prediction suffix on opcode mnemonic, strip it off */
name|n
operator|=
name|strlen
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
name|branch_predict
operator|=
literal|0
expr_stmt|;
name|bp_bits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|0
index|]
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|args
index|[
literal|0
index|]
index|[
name|n
index|]
operator|==
literal|'t'
operator|||
name|args
index|[
literal|0
index|]
index|[
name|n
index|]
operator|==
literal|'f'
operator|)
condition|)
block|{
comment|/* We could check here to see if the target architecture 		 * supports branch prediction, but why bother?  The bit 		 * will just be ignored by processors that don't use it. 		 */
name|branch_predict
operator|=
literal|1
expr_stmt|;
name|bp_bits
operator|=
operator|(
name|args
index|[
literal|0
index|]
index|[
name|n
index|]
operator|==
literal|'t'
operator|)
condition|?
name|BP_TAKEN
else|:
name|BP_NOT_TAKEN
expr_stmt|;
name|args
index|[
literal|0
index|]
index|[
name|n
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Strip suffix from opcode mnemonic */
block|}
comment|/* Look up opcode mnemonic in table and check number of operands. 	 * Check that opcode is legal for the target architecture. 	 * If all looks good, assemble instruction. 	 */
name|oP
operator|=
operator|(
expr|struct
name|i960_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oP
operator|||
operator|!
name|targ_has_iclass
argument_list|(
name|oP
operator|->
name|iclass
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"invalid opcode, \"%s\"."
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n_ops
operator|!=
name|oP
operator|->
name|num_ops
condition|)
block|{
name|as_bad
argument_list|(
literal|"improper number of operands.  expecting %d, got %d"
argument_list|,
name|oP
operator|->
name|num_ops
argument_list|,
name|n_ops
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|oP
operator|->
name|format
condition|)
block|{
case|case
name|FBRA
case|:
case|case
name|CTRL
case|:
name|ctrl_fmt
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
name|oP
operator|->
name|opcode
operator||
name|bp_bits
argument_list|,
name|oP
operator|->
name|num_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|oP
operator|->
name|format
operator|==
name|FBRA
condition|)
block|{
comment|/* Now generate a 'bno' to same arg */
name|ctrl_fmt
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
name|BNO
operator||
name|bp_bits
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|COBR
case|:
case|case
name|COJ
case|:
name|cobr_fmt
argument_list|(
name|args
argument_list|,
name|oP
operator|->
name|opcode
operator||
name|bp_bits
argument_list|,
name|oP
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG
case|:
if|if
condition|(
name|branch_predict
condition|)
block|{
name|as_warn
argument_list|(
name|bp_error_msg
argument_list|)
expr_stmt|;
block|}
name|reg_fmt
argument_list|(
name|args
argument_list|,
name|oP
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM1
case|:
case|case
name|MEM2
case|:
case|case
name|MEM4
case|:
case|case
name|MEM8
case|:
case|case
name|MEM12
case|:
case|case
name|MEM16
case|:
if|if
condition|(
name|branch_predict
condition|)
block|{
name|as_warn
argument_list|(
name|bp_error_msg
argument_list|)
expr_stmt|;
block|}
name|mem_fmt
argument_list|(
name|args
argument_list|,
name|oP
argument_list|)
expr_stmt|;
break|break;
case|case
name|CALLJ
case|:
if|if
condition|(
name|branch_predict
condition|)
block|{
name|as_warn
argument_list|(
name|bp_error_msg
argument_list|)
expr_stmt|;
block|}
comment|/* Output opcode& set up "fixup" (relocation); 			 * flag relocation as 'callj' type. 			 */
name|know
argument_list|(
name|oP
operator|->
name|num_ops
operator|==
literal|1
argument_list|)
expr_stmt|;
name|get_cdisp
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
literal|"CTRL"
argument_list|,
name|oP
operator|->
name|opcode
argument_list|,
literal|24
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|oP
operator|->
name|format
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* md_assemble() */
end_comment

begin_comment
comment|/*****************************************************************************  * md_number_to_chars:  convert a number to target byte order  *  **************************************************************************** */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|buf
parameter_list|,
name|value
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Put output here */
name|long
name|value
decl_stmt|;
comment|/* The integer to be converted */
name|int
name|n
decl_stmt|;
comment|/* Number of bytes to output (significant bytes 		 *	in 'value') 		 */
block|{
while|while
condition|(
name|n
operator|--
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
name|value
expr_stmt|;
name|value
operator|>>=
literal|8
expr_stmt|;
block|}
comment|/* XXX line number probably botched for this warning message. */
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|value
operator|!=
operator|-
literal|1
condition|)
block|{
name|as_bad
argument_list|(
literal|"Displacement too long for instruction field length."
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* md_number_to_chars() */
end_comment

begin_comment
comment|/*****************************************************************************  * md_chars_to_number:  convert from target byte order to host byte order.  *  **************************************************************************** */
end_comment

begin_function
name|int
name|md_chars_to_number
parameter_list|(
name|val
parameter_list|,
name|n
parameter_list|)
name|unsigned
name|char
modifier|*
name|val
decl_stmt|;
comment|/* Value in target byte order */
name|int
name|n
decl_stmt|;
comment|/* Number of bytes in the input */
block|{
name|int
name|retval
decl_stmt|;
for|for
control|(
name|retval
operator|=
literal|0
init|;
name|n
operator|--
condition|;
control|)
block|{
name|retval
operator|<<=
literal|8
expr_stmt|;
name|retval
operator||=
name|val
index|[
name|n
index|]
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_define
define|#
directive|define
name|LNUM_SIZE
value|sizeof(LITTLENUM_TYPE)
end_define

begin_comment
comment|/*****************************************************************************  * md_atof:	convert ascii to floating point  *  * Turn a string at input_line_pointer into a floating point constant of type  * 'type', and store the appropriate bytes at *litP.  The number of LITTLENUMS  * emitted is returned at 'sizeP'.  An error message is returned, or a pointer  * to an empty message if OK.  *  * Note we call the i386 floating point routine, rather than complicating  * things with more files or symbolic links.  *  **************************************************************************** */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|int
name|prec
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|atof_ieee
parameter_list|()
function_decl|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
case|case
literal|'T'
case|:
name|prec
operator|=
literal|5
expr_stmt|;
name|type
operator|=
literal|'x'
expr_stmt|;
comment|/* That's what atof_ieee() understands */
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
literal|"Bad call to md_atof()"
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|input_line_pointer
operator|=
name|t
expr_stmt|;
block|}
operator|*
name|sizeP
operator|=
name|prec
operator|*
name|LNUM_SIZE
expr_stmt|;
comment|/* Output the LITTLENUMs in REVERSE order in accord with i80960 	 * word-order.  (Dunno why atof_ieee doesn't do it in the right 	 * order in the first place -- probably because it's a hack of 	 * atof_m68k.) 	 */
for|for
control|(
name|wordP
operator|=
name|words
operator|+
name|prec
operator|-
literal|1
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|wordP
operator|--
argument_list|)
argument_list|,
name|LNUM_SIZE
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
comment|/* Someone should teach Dean about null pointers */
block|}
end_function

begin_comment
comment|/*****************************************************************************  * md_number_to_imm  *  **************************************************************************** */
end_comment

begin_function
name|void
name|md_number_to_imm
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * md_number_to_disp  *  **************************************************************************** */
end_comment

begin_function
name|void
name|md_number_to_disp
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * md_number_to_field:  *  *	Stick a value (an address fixup) into a bit field of  *	previously-generated instruction.  *  **************************************************************************** */
end_comment

begin_function
name|void
name|md_number_to_field
parameter_list|(
name|instrP
parameter_list|,
name|val
parameter_list|,
name|bfixP
parameter_list|)
name|char
modifier|*
name|instrP
decl_stmt|;
comment|/* Pointer to instruction to be fixed */
name|long
name|val
decl_stmt|;
comment|/* Address fixup value */
name|bit_fixS
modifier|*
name|bfixP
decl_stmt|;
comment|/* Description of bit field to be fixed up */
block|{
name|int
name|numbits
decl_stmt|;
comment|/* Length of bit field to be fixed */
name|long
name|instr
decl_stmt|;
comment|/* 32-bit instruction to be fixed-up */
name|long
name|sign
decl_stmt|;
comment|/* 0 or -1, according to sign bit of 'val' */
comment|/* Convert instruction back to host byte order 	 */
name|instr
operator|=
name|md_chars_to_number
argument_list|(
name|instrP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Surprise! -- we stored the number of bits 	 * to be modified rather than a pointer to a structure. 	 */
name|numbits
operator|=
operator|(
name|int
operator|)
name|bfixP
expr_stmt|;
if|if
condition|(
name|numbits
operator|==
literal|1
condition|)
block|{
comment|/* This is a no-op, stuck here by reloc_callj() */
return|return;
block|}
name|know
argument_list|(
operator|(
name|numbits
operator|==
literal|13
operator|)
operator|||
operator|(
name|numbits
operator|==
literal|24
operator|)
argument_list|)
expr_stmt|;
comment|/* Propagate sign bit of 'val' for the given number of bits. 	 * Result should be all 0 or all 1 	 */
name|sign
operator|=
name|val
operator|>>
operator|(
operator|(
name|int
operator|)
name|numbits
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|val
operator|<
literal|0
operator|)
operator|&&
operator|(
name|sign
operator|!=
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|val
operator|>
literal|0
operator|)
operator|&&
operator|(
name|sign
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Fixup of %d too large for field width of %d"
argument_list|,
name|val
argument_list|,
name|numbits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Put bit field into instruction and write back in target 		 * byte order. 		 */
name|val
operator|&=
operator|~
operator|(
operator|-
literal|1
operator|<<
operator|(
name|int
operator|)
name|numbits
operator|)
expr_stmt|;
comment|/* Clear unused sign bits */
name|instr
operator||=
name|val
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|instrP
argument_list|,
name|instr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* md_number_to_field() */
end_comment

begin_comment
comment|/*****************************************************************************  * md_parse_option  *	Invocation line includes a switch not recognized by the base assembler.  *	See if it's a processor-specific option.  For the 960, these are:  *  *	-norelax:  *		Conditional branch instructions that require displacements  *		greater than 13 bits (or that have external targets) should  *		generate errors.  The default is to replace each such  *		instruction with the corresponding compare (or chkbit) and  *		branch instructions.  Note that the Intel "j" cobr directives  *		are ALWAYS "de-optimized" in this way when necessary,  *		regardless of the setting of this option.  *  *	-b:  *		Add code to collect information about branches taken, for  *		later optimization of branch prediction bits by a separate  *		tool.  COBR and CNTL format instructions have branch  *		prediction bits (in the CX architecture);  if "BR" represents  *		an instruction in one of these classes, the following rep-  *		resents the code generated by the assembler:  *  *			call<increment routine>  *			.word	0	# pre-counter  *		Label:  BR  *			call<increment routine>  *			.word	0	# post-counter  *  *		A table of all such "Labels" is also generated.  *  *  *	-AKA, -AKB, -AKC, -ASA, -ASB, -AMC, -ACA:  *		Select the 80960 architecture.  Instructions or features not  *		supported by the selected architecture cause fatal errors.  *		The default is to generate code for any instruction or feature  *		that is supported by SOME version of the 960 (even if this  *		means mixing architectures!).  *  **************************************************************************** */
end_comment

begin_function
name|int
name|md_parse_option
parameter_list|(
name|argP
parameter_list|,
name|cntP
parameter_list|,
name|vecP
parameter_list|)
name|char
modifier|*
modifier|*
name|argP
decl_stmt|;
name|int
modifier|*
name|cntP
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|vecP
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
struct|struct
name|tabentry
block|{
name|char
modifier|*
name|flag
decl_stmt|;
name|int
name|arch
decl_stmt|;
block|}
struct|;
specifier|static
name|struct
name|tabentry
name|arch_tab
index|[]
init|=
block|{
literal|"KA"
block|,
name|ARCH_KA
block|,
literal|"KB"
block|,
name|ARCH_KB
block|,
literal|"SA"
block|,
name|ARCH_KA
block|,
comment|/* Synonym for KA */
literal|"SB"
block|,
name|ARCH_KB
block|,
comment|/* Synonym for KB */
literal|"KC"
block|,
name|ARCH_MC
block|,
comment|/* Synonym for MC */
literal|"MC"
block|,
name|ARCH_MC
block|,
literal|"CA"
block|,
name|ARCH_CA
block|,
name|NULL
block|,
literal|0
block|}
decl_stmt|;
name|struct
name|tabentry
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argP
argument_list|,
literal|"norelax"
argument_list|)
condition|)
block|{
name|norelax
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|argP
operator|==
literal|'b'
condition|)
block|{
name|instrument_branches
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|argP
operator|==
literal|'A'
condition|)
block|{
name|p
operator|=
operator|(
operator|*
name|argP
operator|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|arch_tab
init|;
name|tp
operator|->
name|flag
operator|!=
name|NULL
condition|;
name|tp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
name|tp
operator|->
name|flag
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|tp
operator|->
name|flag
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
literal|"unknown architecture: %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|architecture
operator|=
name|tp
operator|->
name|arch
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Unknown option */
operator|(
operator|*
name|argP
operator|)
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
operator|*
name|argP
operator|=
literal|'\0'
expr_stmt|;
comment|/* Done parsing this switch */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * md_convert_frag:  *	Called by base assembler after address relaxation is finished:  modify  *	variable fragments according to how much relaxation was done.  *  *	If the fragment substate is still 1, a 13-bit displacement was enough  *	to reach the symbol in question.  Set up an address fixup, but otherwise  *	leave the cobr instruction alone.  *  *	If the fragment substate is 2, a 13-bit displacement was not enough.  *	Replace the cobr with a two instructions (a compare and a branch).  *  **************************************************************************** */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|headers
parameter_list|,
name|fragP
parameter_list|)
name|object_headers
modifier|*
name|headers
decl_stmt|;
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/* Structure describing needed address fix */
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
literal|1
case|:
comment|/* LEAVE SINGLE COBR INSTRUCTION */
name|fixP
operator|=
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_opcode
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_bit_fixP
operator|=
operator|(
name|bit_fixS
operator|*
operator|)
literal|13
expr_stmt|;
comment|/* size of bit field */
break|break;
case|case
literal|2
case|:
comment|/* REPLACE COBR WITH COMPARE/BRANCH INSTRUCTIONS */
name|relax_cobr
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*****************************************************************************  * md_estimate_size_before_relax:  How much does it look like *fragP will grow?  *  *	Called by base assembler just before address relaxation.  *	Return the amount by which the fragment will grow.  *  *	Any symbol that is now undefined will not become defined; cobr's  *	based on undefined symbols will have to be replaced with a compare  *	instruction and a branch instruction, and the code fragment will grow  *	by 4 bytes.  *  **************************************************************************** */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment_type
parameter_list|)
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
specifier|register
name|segT
name|segment_type
decl_stmt|;
block|{
comment|/* If symbol is undefined in this segment, go to "relaxed" state 	 * (compare and branch instructions instead of cobr) right now. 	 */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|segment_type
condition|)
block|{
name|relax_cobr
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
return|return
literal|4
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* md_estimate_size_before_relax() */
end_comment

begin_comment
comment|/*****************************************************************************  * md_ri_to_chars:  *	This routine exists in order to overcome machine byte-order problems  *	when dealing with bit-field entries in the relocation_info struct.  *  *	But relocation info will be used on the host machine only (only  *	executable code is actually downloaded to the i80960).  Therefore,  *	we leave it in host byte order.  *  **************************************************************************** */
end_comment

begin_function
name|void
name|md_ri_to_chars
parameter_list|(
name|where
parameter_list|,
name|ri
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|ri
decl_stmt|;
block|{
operator|*
operator|(
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
name|where
operator|)
operator|=
operator|*
name|ri
expr_stmt|;
comment|/* structure assignment */
block|}
end_function

begin_comment
comment|/* md_ri_to_chars() */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
end_ifndef

begin_decl_stmt
name|int
name|md_short_jump_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|md_long_jump_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|long
name|from_addr
decl_stmt|;
name|long
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|as_fatal
argument_list|(
literal|"failed sanity check."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|long
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|as_fatal
argument_list|(
literal|"failed sanity check."
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*************************************************************  *                                                           *  *  FOLLOWING ARE THE LOCAL ROUTINES, IN ALPHABETICAL ORDER  *  *                                                           *  ************************************************************ */
end_comment

begin_comment
comment|/*****************************************************************************  * brcnt_emit:	Emit code to increment inline branch counter.  *  *	See the comments above the declaration of 'br_cnt' for details on  *	branch-prediction instrumentation.  **************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|brcnt_emit
parameter_list|()
block|{
name|ctrl_fmt
argument_list|(
name|BR_CNT_FUNC
argument_list|,
name|CALL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Emit call to "increment" routine */
name|emit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Emit inline counter to be incremented */
block|}
end_function

begin_comment
comment|/*****************************************************************************  * brlab_next:	generate the next branch local label  *  *	See the comments above the declaration of 'br_cnt' for details on  *	branch-prediction instrumentation.  **************************************************************************** */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|brlab_next
parameter_list|()
block|{
specifier|static
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%d"
argument_list|,
name|BR_LABEL_BASE
argument_list|,
name|br_cnt
operator|++
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * brtab_emit:	generate the fetch-prediction branch table.  *  *	See the comments above the declaration of 'br_cnt' for details on  *	branch-prediction instrumentation.  *  *	The code emitted here would be functionally equivalent to the following  *	example assembler source.  *  *			.data  *			.align	2  *	   BR_TAB_NAME:  *			.word	0		# link to next table  *			.word	3		# length of table  *			.word	LBRANCH0	# 1st entry in table proper  *			.word	LBRANCH1  *			.word	LBRANCH2  ***************************************************************************** */
end_comment

begin_function
name|void
name|brtab_emit
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Where the binary was output to */
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/*->description of deferred address fixup */
if|if
condition|(
operator|!
name|instrument_branches
condition|)
block|{
return|return;
block|}
name|subseg_new
argument_list|(
name|SEG_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	.data */
name|frag_align
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	.align 2 */
name|record_alignment
argument_list|(
name|now_seg
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|colon
argument_list|(
name|BR_TAB_NAME
argument_list|)
expr_stmt|;
comment|/* BR_TAB_NAME: */
name|emit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 	.word 0	#link to next table */
name|emit
argument_list|(
name|br_cnt
argument_list|)
expr_stmt|;
comment|/*	.word n #length of table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|br_cnt
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%d"
argument_list|,
name|BR_LABEL_BASE
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|=
name|emit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fixP
operator|=
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|symbol_find
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_im_disp
operator|=
literal|2
expr_stmt|;
comment|/* 32-bit displacement fix */
block|}
block|}
end_function

begin_comment
comment|/*****************************************************************************  * cobr_fmt:	generate a COBR-format instruction  *  **************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|cobr_fmt
parameter_list|(
name|arg
parameter_list|,
name|opcode
parameter_list|,
name|oP
parameter_list|)
name|char
modifier|*
name|arg
index|[]
decl_stmt|;
comment|/* arg[0]->opcode mnemonic, arg[1-3]->operands (ascii) */
name|long
name|opcode
decl_stmt|;
comment|/* Opcode, with branch-prediction bits already set 		 *	if necessary. 		 */
name|struct
name|i960_opcode
modifier|*
name|oP
decl_stmt|;
comment|/*->description of instruction */
block|{
name|long
name|instr
decl_stmt|;
comment|/* 32-bit instruction */
name|struct
name|regop
name|regop
decl_stmt|;
comment|/* Description of register operand */
name|int
name|n
decl_stmt|;
comment|/* Number of operands */
name|int
name|var_frag
decl_stmt|;
comment|/* 1 if varying length code fragment should 				 *	be emitted;  0 if an address fix 				 *	should be emitted. 				 */
name|instr
operator|=
name|opcode
expr_stmt|;
name|n
operator|=
name|oP
operator|->
name|num_ops
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|1
condition|)
block|{
comment|/* First operand (if any) of a COBR is always a register 		 * operand.  Parse it. 		 */
name|parse_regop
argument_list|(
operator|&
name|regop
argument_list|,
name|arg
index|[
literal|1
index|]
argument_list|,
name|oP
operator|->
name|operand
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|instr
operator||=
operator|(
name|regop
operator|.
name|n
operator|<<
literal|19
operator|)
operator||
operator|(
name|regop
operator|.
name|mode
operator|<<
literal|13
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>=
literal|2
condition|)
block|{
comment|/* Second operand (if any) of a COBR is always a register 		 * operand.  Parse it. 		 */
name|parse_regop
argument_list|(
operator|&
name|regop
argument_list|,
name|arg
index|[
literal|2
index|]
argument_list|,
name|oP
operator|->
name|operand
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|instr
operator||=
operator|(
name|regop
operator|.
name|n
operator|<<
literal|14
operator|)
operator||
name|regop
operator|.
name|special
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<
literal|3
condition|)
block|{
name|emit
argument_list|(
name|instr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|instrument_branches
condition|)
block|{
name|brcnt_emit
argument_list|()
expr_stmt|;
name|colon
argument_list|(
name|brlab_next
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* A third operand to a COBR is always a displacement. 		 * Parse it; if it's relaxable (a cobr "j" directive, or any 		 * cobr other than bbs/bbc when the "-norelax" option is not in 		 * use) set up a variable code fragment;  otherwise set up an 		 * address fix. 		 */
name|var_frag
operator|=
operator|!
name|norelax
operator|||
operator|(
name|oP
operator|->
name|format
operator|==
name|COJ
operator|)
expr_stmt|;
comment|/* TRUE or FALSE */
name|get_cdisp
argument_list|(
name|arg
index|[
literal|3
index|]
argument_list|,
literal|"COBR"
argument_list|,
name|instr
argument_list|,
literal|13
argument_list|,
name|var_frag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|instrument_branches
condition|)
block|{
name|brcnt_emit
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* cobr_fmt() */
end_comment

begin_comment
comment|/*****************************************************************************  * ctrl_fmt:	generate a CTRL-format instruction  *  **************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|ctrl_fmt
parameter_list|(
name|targP
parameter_list|,
name|opcode
parameter_list|,
name|num_ops
parameter_list|)
name|char
modifier|*
name|targP
decl_stmt|;
comment|/* Pointer to text of lone operand (if any) */
name|long
name|opcode
decl_stmt|;
comment|/* Template of instruction */
name|int
name|num_ops
decl_stmt|;
comment|/* Number of operands */
block|{
name|int
name|instrument
decl_stmt|;
comment|/* TRUE iff we should add instrumentation to track 			 * how often the branch is taken 			 */
if|if
condition|(
name|num_ops
operator|==
literal|0
condition|)
block|{
name|emit
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
comment|/* Output opcode */
block|}
else|else
block|{
name|instrument
operator|=
name|instrument_branches
operator|&&
operator|(
name|opcode
operator|!=
name|CALL
operator|)
operator|&&
operator|(
name|opcode
operator|!=
name|B
operator|)
operator|&&
operator|(
name|opcode
operator|!=
name|RET
operator|)
operator|&&
operator|(
name|opcode
operator|!=
name|BAL
operator|)
expr_stmt|;
if|if
condition|(
name|instrument
condition|)
block|{
name|brcnt_emit
argument_list|()
expr_stmt|;
name|colon
argument_list|(
name|brlab_next
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* The operand MUST be an ip-relative displacment. Parse it 		 * and set up address fix for the instruction we just output. 		 */
name|get_cdisp
argument_list|(
name|targP
argument_list|,
literal|"CTRL"
argument_list|,
name|opcode
argument_list|,
literal|24
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|instrument
condition|)
block|{
name|brcnt_emit
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*****************************************************************************  * emit:	output instruction binary  *  *	Output instruction binary, in target byte order, 4 bytes at a time.  *	Return pointer to where it was placed.  *  **************************************************************************** */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|emit
parameter_list|(
name|instr
parameter_list|)
name|long
name|instr
decl_stmt|;
comment|/* Word to be output, host byte order */
block|{
name|char
modifier|*
name|toP
decl_stmt|;
comment|/* Where to output it */
name|toP
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* Allocate storage */
name|md_number_to_chars
argument_list|(
name|toP
argument_list|,
name|instr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Convert to target byte order */
return|return
name|toP
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * get_args:	break individual arguments out of comma-separated list  *  * Input assumptions:  *	- all comments and labels have been removed  *	- all strings of whitespace have been collapsed to a single blank.  *	- all character constants ('x') have been replaced with decimal  *  * Output:  *	args[0] is untouched. args[1] points to first operand, etc. All args:  *	- are NULL-terminated  *	- contain no whitespace  *  * Return value:  *	Number of operands (0,1,2, or 3) or -1 on error.  *  **************************************************************************** */
end_comment

begin_function
specifier|static
name|int
name|get_args
parameter_list|(
name|p
parameter_list|,
name|args
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Pointer to comma-separated operands; MUCKED BY US */
name|char
modifier|*
name|args
index|[]
decl_stmt|;
comment|/* Output arg: pointers to operands placed in args[1-3]. 		 * MUST ACCOMMODATE 4 ENTRIES (args[0-3]). 		 */
block|{
specifier|register
name|int
name|n
decl_stmt|;
comment|/* Number of operands */
specifier|register
name|char
modifier|*
name|to
decl_stmt|;
comment|/*	char buf[4]; */
comment|/*	int len; */
comment|/* Skip lead white space */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
return|return
literal|0
return|;
block|}
name|n
operator|=
literal|1
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|p
expr_stmt|;
comment|/* Squeze blanks out by moving non-blanks toward start of string. 	 * Isolate operands, whenever comma is found. 	 */
name|to
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|','
condition|)
block|{
comment|/* Start of operand */
if|if
condition|(
name|n
operator|==
literal|3
condition|)
block|{
name|as_bad
argument_list|(
literal|"too many operands"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|to
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate argument */
name|args
index|[
operator|++
name|n
index|]
operator|=
name|to
expr_stmt|;
comment|/* Start next argument */
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|to
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|to
operator|=
literal|'\0'
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * get_cdisp:	handle displacement for a COBR or CTRL instruction.  *  *	Parse displacement for a COBR or CTRL instruction.  *  *	If successful, output the instruction opcode and set up for it,  *	depending on the arg 'var_frag', either:  *	    o an address fixup to be done when all symbol values are known, or  *	    o a varying length code fragment, with address fixup info.  This  *		will be done for cobr instructions that may have to be relaxed  *		in to compare/branch instructions (8 bytes) if the final address  *		displacement is greater than 13 bits.  *  **************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|get_cdisp
parameter_list|(
name|dispP
parameter_list|,
name|ifmtP
parameter_list|,
name|instr
parameter_list|,
name|numbits
parameter_list|,
name|var_frag
parameter_list|,
name|callj
parameter_list|)
name|char
modifier|*
name|dispP
decl_stmt|;
comment|/*->displacement as specified in source instruction */
name|char
modifier|*
name|ifmtP
decl_stmt|;
comment|/*->"COBR" or "CTRL" (for use in error message) */
name|long
name|instr
decl_stmt|;
comment|/* Instruction needing the displacement */
name|int
name|numbits
decl_stmt|;
comment|/* # bits of displacement (13 for COBR, 24 for CTRL) */
name|int
name|var_frag
decl_stmt|;
comment|/* 1 if varying length code fragment should be emitted; 		 *	0 if an address fix should be emitted. 		 */
name|int
name|callj
decl_stmt|;
comment|/* 1 if callj relocation should be done; else 0 */
block|{
name|expressionS
name|e
decl_stmt|;
comment|/* Parsed expression */
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/* Structure describing needed address fix */
name|char
modifier|*
name|outP
decl_stmt|;
comment|/* Where instruction binary is output to */
name|fixP
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|parse_expr
argument_list|(
name|dispP
argument_list|,
operator|&
name|e
argument_list|)
condition|)
block|{
case|case
name|SEG_GOOF
case|:
name|as_bad
argument_list|(
literal|"expression syntax error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEG_TEXT
case|:
case|case
name|SEG_UNKNOWN
case|:
if|if
condition|(
name|var_frag
condition|)
block|{
name|outP
operator|=
name|frag_more
argument_list|(
literal|8
argument_list|)
expr_stmt|;
comment|/* Allocate worst-case storage */
name|md_number_to_chars
argument_list|(
name|outP
argument_list|,
name|instr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|frag_variant
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
name|adds
argument_list|(
name|e
argument_list|)
argument_list|,
name|offs
argument_list|(
name|e
argument_list|)
argument_list|,
name|outP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Set up a new fix structure, so address can be updated 			 * when all symbol values are known. 			 */
name|outP
operator|=
name|emit
argument_list|(
name|instr
argument_list|)
expr_stmt|;
name|fixP
operator|=
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|outP
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|adds
argument_list|(
name|e
argument_list|)
argument_list|,
literal|0
argument_list|,
name|offs
argument_list|(
name|e
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_callj
operator|=
name|callj
expr_stmt|;
comment|/* We want to modify a bit field when the address is 			 * known.  But we don't need all the garbage in the 			 * bit_fix structure.  So we're going to lie and store 			 * the number of bits affected instead of a pointer. 			 */
name|fixP
operator|->
name|fx_bit_fixP
operator|=
operator|(
name|bit_fixS
operator|*
operator|)
name|numbits
expr_stmt|;
block|}
break|break;
case|case
name|SEG_DATA
case|:
case|case
name|SEG_BSS
case|:
name|as_bad
argument_list|(
literal|"attempt to branch into different segment"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"target of %s instruction must be a label"
argument_list|,
name|ifmtP
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*****************************************************************************  * get_ispec:	parse a memory operand for an index specification  *  *	Here, an "index specification" is taken to be anything surrounded  *	by square brackets and NOT followed by anything else.  *  *	If it's found, detach it from the input string, remove the surrounding  *	square brackets, and return a pointer to it.  Otherwise, return NULL.  *  **************************************************************************** */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_ispec
parameter_list|(
name|textP
parameter_list|)
name|char
modifier|*
name|textP
decl_stmt|;
comment|/*->memory operand from source instruction, no white space */
block|{
name|char
modifier|*
name|start
decl_stmt|;
comment|/*->start of index specification */
name|char
modifier|*
name|end
decl_stmt|;
comment|/*->end of index specification */
comment|/* Find opening square bracket, if any 	 */
name|start
operator|=
name|strchr
argument_list|(
name|textP
argument_list|,
literal|'['
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|!=
name|NULL
condition|)
block|{
comment|/* Eliminate '[', detach from rest of operand */
operator|*
name|start
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|end
operator|=
name|strchr
argument_list|(
name|start
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
literal|"unmatched '['"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Eliminate ']' and make sure it was the last thing 			 * in the string. 			 */
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|end
operator|+
literal|1
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|as_bad
argument_list|(
literal|"garbage after index spec ignored"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|start
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * get_regnum:  *  *	Look up a (suspected) register name in the register table and return the  *	associated register number (or -1 if not found).  *  **************************************************************************** */
end_comment

begin_function
specifier|static
name|int
name|get_regnum
parameter_list|(
name|regname
parameter_list|)
name|char
modifier|*
name|regname
decl_stmt|;
comment|/* Suspected register name */
block|{
name|int
modifier|*
name|rP
decl_stmt|;
name|rP
operator|=
operator|(
name|int
operator|*
operator|)
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
name|regname
argument_list|)
expr_stmt|;
return|return
operator|(
name|rP
operator|==
name|NULL
operator|)
condition|?
operator|-
literal|1
else|:
operator|*
name|rP
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * i_scan:	perform lexical scan of ascii assembler instruction.  *  * Input assumptions:  *	- input string is an i80960 instruction (not a pseudo-op)  *	- all comments and labels have been removed  *	- all strings of whitespace have been collapsed to a single blank.  *  * Output:  *	args[0] points to opcode, other entries point to operands. All strings:  *	- are NULL-terminated  *	- contain no whitespace  *	- have character constants ('x') replaced with a decimal number  *  * Return value:  *	Number of operands (0,1,2, or 3) or -1 on error.  *  **************************************************************************** */
end_comment

begin_function
specifier|static
name|int
name|i_scan
parameter_list|(
name|iP
parameter_list|,
name|args
parameter_list|)
specifier|register
name|char
modifier|*
name|iP
decl_stmt|;
comment|/* Pointer to ascii instruction;  MUCKED BY US. */
name|char
modifier|*
name|args
index|[]
decl_stmt|;
comment|/* Output arg: pointers to opcode and operands placed 		 *	here.  MUST ACCOMMODATE 4 ENTRIES. 		 */
block|{
comment|/* Isolate opcode */
if|if
condition|(
operator|*
operator|(
name|iP
operator|)
operator|==
literal|' '
condition|)
block|{
name|iP
operator|++
expr_stmt|;
block|}
comment|/* Skip lead space, if any */
name|args
index|[
literal|0
index|]
operator|=
name|iP
expr_stmt|;
for|for
control|(
init|;
operator|*
name|iP
operator|!=
literal|' '
condition|;
name|iP
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|iP
operator|==
literal|'\0'
condition|)
block|{
comment|/* There are no operands */
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|==
name|iP
condition|)
block|{
comment|/* We never moved: there was no opcode either! */
name|as_bad
argument_list|(
literal|"missing opcode"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
block|}
operator|*
name|iP
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate opcode */
return|return
operator|(
name|get_args
argument_list|(
name|iP
argument_list|,
name|args
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* i_scan() */
end_comment

begin_comment
comment|/*****************************************************************************  * mem_fmt:	generate a MEMA- or MEMB-format instruction  *  **************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|mem_fmt
parameter_list|(
name|args
parameter_list|,
name|oP
parameter_list|)
name|char
modifier|*
name|args
index|[]
decl_stmt|;
comment|/* args[0]->opcode mnemonic, args[1-3]->operands */
name|struct
name|i960_opcode
modifier|*
name|oP
decl_stmt|;
comment|/* Pointer to description of instruction */
block|{
name|int
name|i
decl_stmt|;
comment|/* Loop counter */
name|struct
name|regop
name|regop
decl_stmt|;
comment|/* Description of register operand */
name|char
name|opdesc
decl_stmt|;
comment|/* Operand descriptor byte */
name|memS
name|instr
decl_stmt|;
comment|/* Description of binary to be output */
name|char
modifier|*
name|outP
decl_stmt|;
comment|/* Where the binary was output to */
name|expressionS
name|expr
decl_stmt|;
comment|/* Parsed expression */
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/*->description of deferred address fixup */
name|memset
argument_list|(
operator|&
name|instr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|memS
argument_list|)
argument_list|)
expr_stmt|;
name|instr
operator|.
name|opcode
operator|=
name|oP
operator|->
name|opcode
expr_stmt|;
comment|/* Process operands. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|oP
operator|->
name|num_ops
condition|;
name|i
operator|++
control|)
block|{
name|opdesc
operator|=
name|oP
operator|->
name|operand
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|MEMOP
argument_list|(
name|opdesc
argument_list|)
condition|)
block|{
name|parse_memop
argument_list|(
operator|&
name|instr
argument_list|,
name|args
index|[
name|i
index|]
argument_list|,
name|oP
operator|->
name|format
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parse_regop
argument_list|(
operator|&
name|regop
argument_list|,
name|args
index|[
name|i
index|]
argument_list|,
name|opdesc
argument_list|)
expr_stmt|;
name|instr
operator|.
name|opcode
operator||=
name|regop
operator|.
name|n
operator|<<
literal|19
expr_stmt|;
block|}
block|}
comment|/* Output opcode */
name|outP
operator|=
name|emit
argument_list|(
name|instr
operator|.
name|opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|instr
operator|.
name|disp
operator|==
literal|0
condition|)
block|{
return|return;
block|}
comment|/* Parse and process the displacement */
switch|switch
condition|(
name|parse_expr
argument_list|(
name|instr
operator|.
name|e
argument_list|,
operator|&
name|expr
argument_list|)
condition|)
block|{
case|case
name|SEG_GOOF
case|:
name|as_bad
argument_list|(
literal|"expression syntax error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEG_ABSOLUTE
case|:
if|if
condition|(
name|instr
operator|.
name|disp
operator|==
literal|32
condition|)
block|{
operator|(
name|void
operator|)
name|emit
argument_list|(
name|offs
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output displacement */
block|}
else|else
block|{
comment|/* 12-bit displacement */
if|if
condition|(
name|offs
argument_list|(
name|expr
argument_list|)
operator|&
operator|~
literal|0xfff
condition|)
block|{
comment|/* Won't fit in 12 bits: convert already-output 				 * instruction to MEMB format, output 				 * displacement. 				 */
name|mema_to_memb
argument_list|(
name|outP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|emit
argument_list|(
name|offs
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* WILL fit in 12 bits:  OR into opcode and 				 * overwrite the binary we already put out 				 */
name|instr
operator|.
name|opcode
operator||=
name|offs
argument_list|(
name|expr
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|outP
argument_list|,
name|instr
operator|.
name|opcode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SEG_DIFFERENCE
case|:
case|case
name|SEG_TEXT
case|:
case|case
name|SEG_DATA
case|:
case|case
name|SEG_BSS
case|:
case|case
name|SEG_UNKNOWN
case|:
if|if
condition|(
name|instr
operator|.
name|disp
operator|==
literal|12
condition|)
block|{
comment|/* Displacement is dependent on a symbol, whose value 			 * may change at link time.  We HAVE to reserve 32 bits. 			 * Convert already-output opcode to MEMB format. 			 */
name|mema_to_memb
argument_list|(
name|outP
argument_list|)
expr_stmt|;
block|}
comment|/* Output 0 displacement and set up address fixup for when 		 * this symbol's value becomes known. 		 */
name|outP
operator|=
name|emit
argument_list|(
operator|(
name|long
operator|)
literal|0
argument_list|)
expr_stmt|;
name|fixP
operator|=
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|outP
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|adds
argument_list|(
name|expr
argument_list|)
argument_list|,
name|subs
argument_list|(
name|expr
argument_list|)
argument_list|,
name|offs
argument_list|(
name|expr
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_im_disp
operator|=
literal|2
expr_stmt|;
comment|/* 32-bit displacement fix */
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|segs
argument_list|(
name|expr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* memfmt() */
end_comment

begin_comment
comment|/*****************************************************************************  * mema_to_memb:	convert a MEMA-format opcode to a MEMB-format opcode.  *  * There are 2 possible MEMA formats:  *	- displacement only  *	- displacement + abase  *  * They are distinguished by the setting of the MEMA_ABASE bit.  *  **************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|mema_to_memb
parameter_list|(
name|opcodeP
parameter_list|)
name|char
modifier|*
name|opcodeP
decl_stmt|;
comment|/* Where to find the opcode, in target byte order */
block|{
name|long
name|opcode
decl_stmt|;
comment|/* Opcode in host byte order */
name|long
name|mode
decl_stmt|;
comment|/* Mode bits for MEMB instruction */
name|opcode
operator|=
name|md_chars_to_number
argument_list|(
name|opcodeP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|!
operator|(
name|opcode
operator|&
name|MEMB_BIT
operator|)
argument_list|)
expr_stmt|;
name|mode
operator|=
name|MEMB_BIT
operator||
name|D_BIT
expr_stmt|;
if|if
condition|(
name|opcode
operator|&
name|MEMA_ABASE
condition|)
block|{
name|mode
operator||=
name|A_BIT
expr_stmt|;
block|}
name|opcode
operator|&=
literal|0xffffc000
expr_stmt|;
comment|/* Clear MEMA offset and mode bits */
name|opcode
operator||=
name|mode
expr_stmt|;
comment|/* Set MEMB mode bits */
name|md_number_to_chars
argument_list|(
name|opcodeP
argument_list|,
name|opcode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* mema_to_memb() */
end_comment

begin_comment
comment|/*****************************************************************************  * parse_expr:		parse an expression  *  *	Use base assembler's expression parser to parse an expression.  *	It, unfortunately, runs off a global which we have to save/restore  *	in order to make it work for us.  *  *	An empty expression string is treated as an absolute 0.  *  *	Return "segment" to which the expression evaluates.  *	Return SEG_GOOF regardless of expression evaluation if entire input  *	string is not consumed in the evaluation -- tolerate no dangling junk!  *  **************************************************************************** */
end_comment

begin_function
specifier|static
name|segT
name|parse_expr
parameter_list|(
name|textP
parameter_list|,
name|expP
parameter_list|)
name|char
modifier|*
name|textP
decl_stmt|;
comment|/* Text of expression to be parsed */
name|expressionS
modifier|*
name|expP
decl_stmt|;
comment|/* Where to put the results of parsing */
block|{
name|char
modifier|*
name|save_in
decl_stmt|;
comment|/* Save global here */
name|segT
name|seg
decl_stmt|;
comment|/* Segment to which expression evaluates */
name|symbolS
modifier|*
name|symP
decl_stmt|;
name|know
argument_list|(
name|textP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|textP
operator|==
literal|'\0'
condition|)
block|{
comment|/* Treat empty string as absolute 0 */
name|expP
operator|->
name|X_add_symbol
operator|=
name|expP
operator|->
name|X_subtract_symbol
operator|=
name|NULL
expr_stmt|;
name|expP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|seg
operator|=
name|expP
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
block|}
else|else
block|{
name|save_in
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* Save global */
name|input_line_pointer
operator|=
name|textP
expr_stmt|;
comment|/* Make parser work for us */
name|seg
operator|=
name|expression
argument_list|(
name|expP
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_line_pointer
operator|-
name|textP
operator|!=
name|strlen
argument_list|(
name|textP
argument_list|)
condition|)
block|{
comment|/* Did not consume all of the input */
name|seg
operator|=
name|SEG_GOOF
expr_stmt|;
block|}
name|symP
operator|=
name|expP
operator|->
name|X_add_symbol
expr_stmt|;
if|if
condition|(
name|symP
operator|&&
operator|(
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
name|S_GET_NAME
argument_list|(
name|symP
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Register name in an expression */
name|seg
operator|=
name|SEG_GOOF
expr_stmt|;
block|}
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
comment|/* Restore global */
block|}
return|return
name|seg
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * parse_ldcont:  *	Parse and replace a 'ldconst' pseudo-instruction with an appropriate  *	i80960 instruction.  *  *	Assumes the input consists of:  *		arg[0]	opcode mnemonic ('ldconst')  *		arg[1]  first operand (constant)  *		arg[2]	name of register to be loaded  *  *	Replaces opcode and/or operands as appropriate.  *  *	Returns the new number of arguments, or -1 on failure.  *  **************************************************************************** */
end_comment

begin_function
specifier|static
name|int
name|parse_ldconst
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
index|[]
decl_stmt|;
comment|/* See above */
block|{
name|int
name|n
decl_stmt|;
comment|/* Constant to be loaded */
name|int
name|shift
decl_stmt|;
comment|/* Shift count for "shlo" instruction */
specifier|static
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|;
comment|/* Literal for first operand */
specifier|static
name|char
name|buf2
index|[
literal|5
index|]
decl_stmt|;
comment|/* Literal for second operand */
name|expressionS
name|e
decl_stmt|;
comment|/* Parsed expression */
name|arg
index|[
literal|3
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* So we can tell at the end if it got used or not */
switch|switch
condition|(
name|parse_expr
argument_list|(
name|arg
index|[
literal|1
index|]
argument_list|,
operator|&
name|e
argument_list|)
condition|)
block|{
case|case
name|SEG_TEXT
case|:
case|case
name|SEG_DATA
case|:
case|case
name|SEG_BSS
case|:
case|case
name|SEG_UNKNOWN
case|:
case|case
name|SEG_DIFFERENCE
case|:
comment|/* We're dependent on one or more symbols -- use "lda" */
name|arg
index|[
literal|0
index|]
operator|=
literal|"lda"
expr_stmt|;
break|break;
case|case
name|SEG_ABSOLUTE
case|:
comment|/* Try the following mappings: 		 *	ldconst 0,<reg>  ->mov  0,<reg> 		 * 	ldconst 31,<reg> ->mov  31,<reg> 		 * 	ldconst 32,<reg> ->addo 1,31,<reg> 		 * 	ldconst 62,<reg> ->addo 31,31,<reg>   		 *	ldconst 64,<reg> ->shlo 8,3,<reg> 		 * 	ldconst -1,<reg> ->subo 1,0,<reg> 		 * 	ldconst -31,<reg>->subo 31,0,<reg> 		 * 		 * anthing else becomes: 		 * 	lda xxx,<reg> 		 */
name|n
operator|=
name|offs
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
literal|0
operator|<=
name|n
operator|)
operator|&&
operator|(
name|n
operator|<=
literal|31
operator|)
condition|)
block|{
name|arg
index|[
literal|0
index|]
operator|=
literal|"mov"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|-
literal|31
operator|<=
name|n
operator|)
operator|&&
operator|(
name|n
operator|<=
operator|-
literal|1
operator|)
condition|)
block|{
name|arg
index|[
literal|0
index|]
operator|=
literal|"subo"
expr_stmt|;
name|arg
index|[
literal|3
index|]
operator|=
name|arg
index|[
literal|2
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
operator|-
name|n
argument_list|)
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|=
name|buf
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|=
literal|"0"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
literal|32
operator|<=
name|n
operator|)
operator|&&
operator|(
name|n
operator|<=
literal|62
operator|)
condition|)
block|{
name|arg
index|[
literal|0
index|]
operator|=
literal|"addo"
expr_stmt|;
name|arg
index|[
literal|3
index|]
operator|=
name|arg
index|[
literal|2
index|]
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|=
literal|"31"
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|n
operator|-
literal|31
argument_list|)
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|=
name|buf
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|shift
operator|=
name|shift_ok
argument_list|(
name|n
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|arg
index|[
literal|0
index|]
operator|=
literal|"shlo"
expr_stmt|;
name|arg
index|[
literal|3
index|]
operator|=
name|arg
index|[
literal|2
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|shift
argument_list|)
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|=
name|buf
expr_stmt|;
name|sprintf
argument_list|(
name|buf2
argument_list|,
literal|"%d"
argument_list|,
name|n
operator|>>
name|shift
argument_list|)
expr_stmt|;
name|arg
index|[
literal|2
index|]
operator|=
name|buf2
expr_stmt|;
block|}
else|else
block|{
name|arg
index|[
literal|0
index|]
operator|=
literal|"lda"
expr_stmt|;
block|}
break|break;
default|default:
name|as_bad
argument_list|(
literal|"invalid constant"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
break|break;
block|}
return|return
operator|(
name|arg
index|[
literal|3
index|]
operator|==
literal|0
operator|)
condition|?
literal|2
else|:
literal|3
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * parse_memop:	parse a memory operand  *  *	This routine is based on the observation that the 4 mode bits of the  *	MEMB format, taken individually, have fairly consistent meaning:  *  *		 M3 (bit 13): 1 if displacement is present (D_BIT)  *		 M2 (bit 12): 1 for MEMB instructions (MEMB_BIT)  *		 M1 (bit 11): 1 if index is present (I_BIT)  *		 M0 (bit 10): 1 if abase is present (A_BIT)  *  *	So we parse the memory operand and set bits in the mode as we find  *	things.  Then at the end, if we go to MEMB format, we need only set  *	the MEMB bit (M2) and our mode is built for us.  *  *	Unfortunately, I said "fairly consistent".  The exceptions:  *  *		 DBIA  *		 0100	Would seem illegal, but means "abase-only".  *  *		 0101	Would seem to mean "abase-only" -- it means IP-relative.  *			Must be converted to 0100.  *  *		 0110	Would seem to mean "index-only", but is reserved.  *			We turn on the D bit and provide a 0 displacement.  *  *	The other thing to observe is that we parse from the right, peeling  *	things * off as we go:  first any index spec, then any abase, then  *	the displacement.  *  **************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|parse_memop
parameter_list|(
name|memP
parameter_list|,
name|argP
parameter_list|,
name|optype
parameter_list|)
name|memS
modifier|*
name|memP
decl_stmt|;
comment|/* Where to put the results */
name|char
modifier|*
name|argP
decl_stmt|;
comment|/* Text of the operand to be parsed */
name|int
name|optype
decl_stmt|;
comment|/* MEM1, MEM2, MEM4, MEM8, MEM12, or MEM16 */
block|{
name|char
modifier|*
name|indexP
decl_stmt|;
comment|/* Pointer to index specification with "[]" removed */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Temp char pointer */
name|char
name|iprel_flag
decl_stmt|;
comment|/* True if this is an IP-relative operand */
name|int
name|regnum
decl_stmt|;
comment|/* Register number */
name|int
name|scale
decl_stmt|;
comment|/* Scale factor: 1,2,4,8, or 16.  Later converted 			 *	to internal format (0,1,2,3,4 respectively). 			 */
name|int
name|mode
decl_stmt|;
comment|/* MEMB mode bits */
name|int
modifier|*
name|intP
decl_stmt|;
comment|/* Pointer to register number */
comment|/* The following table contains the default scale factors for each 	 * type of memory instruction.  It is accessed using (optype-MEM1) 	 * as an index -- thus it assumes the 'optype' constants are assigned 	 * consecutive values, in the order they appear in this table 	 */
specifier|static
name|int
name|def_scale
index|[]
init|=
block|{
literal|1
block|,
comment|/* MEM1 */
literal|2
block|,
comment|/* MEM2 */
literal|4
block|,
comment|/* MEM4 */
literal|8
block|,
comment|/* MEM8 */
operator|-
literal|1
block|,
comment|/* MEM12 -- no valid default */
literal|16
comment|/* MEM16 */
block|}
decl_stmt|;
name|iprel_flag
operator|=
name|mode
operator|=
literal|0
expr_stmt|;
comment|/* Any index present? */
name|indexP
operator|=
name|get_ispec
argument_list|(
name|argP
argument_list|)
expr_stmt|;
if|if
condition|(
name|indexP
condition|)
block|{
name|p
operator|=
name|strchr
argument_list|(
name|indexP
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* No explicit scale -- use default for this 			 *instruction type. 			 */
name|scale
operator|=
name|def_scale
index|[
name|optype
operator|-
name|MEM1
index|]
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Eliminate '*' */
comment|/* Now indexP->a '\0'-terminated register name, 			 * and p->a scale factor. 			 */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"16"
argument_list|)
condition|)
block|{
name|scale
operator|=
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"1248"
argument_list|,
operator|*
name|p
argument_list|)
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|scale
operator|=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
name|scale
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|regnum
operator|=
name|get_regnum
argument_list|(
name|indexP
argument_list|)
expr_stmt|;
comment|/* Get index reg. # */
if|if
condition|(
operator|!
name|IS_RG_REG
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"invalid index register"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Convert scale to its binary encoding */
switch|switch
condition|(
name|scale
condition|)
block|{
case|case
literal|1
case|:
name|scale
operator|=
literal|0
operator|<<
literal|7
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|scale
operator|=
literal|1
operator|<<
literal|7
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|scale
operator|=
literal|2
operator|<<
literal|7
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|scale
operator|=
literal|3
operator|<<
literal|7
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|scale
operator|=
literal|4
operator|<<
literal|7
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"invalid scale factor"
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
name|memP
operator|->
name|opcode
operator||=
name|scale
operator||
name|regnum
expr_stmt|;
comment|/* Set index bits in opcode */
name|mode
operator||=
name|I_BIT
expr_stmt|;
comment|/* Found a valid index spec */
block|}
comment|/* Any abase (Register Indirect) specification present? */
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|argP
argument_list|,
literal|'('
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* "(" is there -- does it start a legal abase spec? 		 * (If not it could be part of a displacement expression.) 		 */
name|intP
operator|=
operator|(
name|int
operator|*
operator|)
name|hash_find
argument_list|(
name|areg_hash
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|intP
operator|!=
name|NULL
condition|)
block|{
comment|/* Got an abase here */
name|regnum
operator|=
operator|*
name|intP
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* discard register spec */
if|if
condition|(
name|regnum
operator|==
name|IPREL
condition|)
block|{
comment|/* We have to specialcase ip-rel mode */
name|iprel_flag
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|memP
operator|->
name|opcode
operator||=
name|regnum
operator|<<
literal|14
expr_stmt|;
name|mode
operator||=
name|A_BIT
expr_stmt|;
block|}
block|}
block|}
comment|/* Any expression present? */
name|memP
operator|->
name|e
operator|=
name|argP
expr_stmt|;
if|if
condition|(
operator|*
name|argP
operator|!=
literal|'\0'
condition|)
block|{
name|mode
operator||=
name|D_BIT
expr_stmt|;
block|}
comment|/* Special-case ip-relative addressing */
if|if
condition|(
name|iprel_flag
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|I_BIT
condition|)
block|{
name|syntax
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|memP
operator|->
name|opcode
operator||=
literal|5
operator|<<
literal|10
expr_stmt|;
comment|/* IP-relative mode */
name|memP
operator|->
name|disp
operator|=
literal|32
expr_stmt|;
block|}
return|return;
block|}
comment|/* Handle all other modes */
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|D_BIT
operator||
name|A_BIT
case|:
comment|/* Go with MEMA instruction format for now (grow to MEMB later 		 *	if 12 bits is not enough for the displacement). 		 * MEMA format has a single mode bit: set it to indicate 		 *	that abase is present. 		 */
name|memP
operator|->
name|opcode
operator||=
name|MEMA_ABASE
expr_stmt|;
name|memP
operator|->
name|disp
operator|=
literal|12
expr_stmt|;
break|break;
case|case
name|D_BIT
case|:
comment|/* Go with MEMA instruction format for now (grow to MEMB later 		 *	if 12 bits is not enough for the displacement). 		 */
name|memP
operator|->
name|disp
operator|=
literal|12
expr_stmt|;
break|break;
case|case
name|A_BIT
case|:
comment|/* For some reason, the bit string for this mode is not 		 * consistent:  it should be 0 (exclusive of the MEMB bit), 		 * so we set it "by hand" here. 		 */
name|memP
operator|->
name|opcode
operator||=
name|MEMB_BIT
expr_stmt|;
break|break;
case|case
name|A_BIT
operator||
name|I_BIT
case|:
comment|/* set MEMB bit in mode, and OR in mode bits */
name|memP
operator|->
name|opcode
operator||=
name|mode
operator||
name|MEMB_BIT
expr_stmt|;
break|break;
case|case
name|I_BIT
case|:
comment|/* Treat missing displacement as displacement of 0 */
name|mode
operator||=
name|D_BIT
expr_stmt|;
comment|/*********************** 		 * Fall into next case * 		 ********************** */
case|case
name|D_BIT
operator||
name|A_BIT
operator||
name|I_BIT
case|:
case|case
name|D_BIT
operator||
name|I_BIT
case|:
comment|/* set MEMB bit in mode, and OR in mode bits */
name|memP
operator|->
name|opcode
operator||=
name|mode
operator||
name|MEMB_BIT
expr_stmt|;
name|memP
operator|->
name|disp
operator|=
literal|32
expr_stmt|;
break|break;
default|default:
name|syntax
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*****************************************************************************  * parse_po:	parse machine-dependent pseudo-op  *  *	This is a top-level routine for machine-dependent pseudo-ops.  It slurps  *	up the rest of the input line, breaks out the individual arguments,  *	and dispatches them to the correct handler.  **************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|parse_po
parameter_list|(
name|po_num
parameter_list|)
name|int
name|po_num
decl_stmt|;
comment|/* Pseudo-op number:  currently S_LEAFPROC or S_SYSPROC */
block|{
name|char
modifier|*
name|args
index|[
literal|4
index|]
decl_stmt|;
comment|/* Pointers operands, with no embedded whitespace. 			 *	arg[0] unused. 			 *	arg[1-3]->operands 			 */
name|int
name|n_ops
decl_stmt|;
comment|/* Number of operands */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Pointer to beginning of unparsed argument string */
name|char
name|eol
decl_stmt|;
comment|/* Character that indicated end of line */
specifier|extern
name|char
name|is_end_of_line
index|[]
decl_stmt|;
comment|/* Advance input pointer to end of line. */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|*
name|input_line_pointer
index|]
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
block|}
name|eol
operator|=
operator|*
name|input_line_pointer
expr_stmt|;
comment|/* Save end-of-line char */
operator|*
name|input_line_pointer
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate argument list */
comment|/* Parse out operands */
name|n_ops
operator|=
name|get_args
argument_list|(
name|p
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|n_ops
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
block|}
comment|/* Dispatch to correct handler */
switch|switch
condition|(
name|po_num
condition|)
block|{
case|case
name|S_SYSPROC
case|:
name|s_sysproc
argument_list|(
name|n_ops
argument_list|,
name|args
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_LEAFPROC
case|:
name|s_leafproc
argument_list|(
name|n_ops
argument_list|,
name|args
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|po_num
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Restore eol, so line numbers get updated correctly.  Base assembler 	 * assumes we leave input pointer pointing at char following the eol. 	 */
operator|*
name|input_line_pointer
operator|++
operator|=
name|eol
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * parse_regop: parse a register operand.  *  *	In case of illegal operand, issue a message and return some valid  *	information so instruction processing can continue.  **************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|parse_regop
parameter_list|(
name|regopP
parameter_list|,
name|optext
parameter_list|,
name|opdesc
parameter_list|)
name|struct
name|regop
modifier|*
name|regopP
decl_stmt|;
comment|/* Where to put description of register operand */
name|char
modifier|*
name|optext
decl_stmt|;
comment|/* Text of operand */
name|char
name|opdesc
decl_stmt|;
comment|/* Descriptor byte:  what's legal for this operand */
block|{
name|int
name|n
decl_stmt|;
comment|/* Register number */
name|expressionS
name|e
decl_stmt|;
comment|/* Parsed expression */
comment|/* See if operand is a register */
name|n
operator|=
name|get_regnum
argument_list|(
name|optext
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|IS_RG_REG
argument_list|(
name|n
argument_list|)
condition|)
block|{
comment|/* global or local register */
if|if
condition|(
operator|!
name|REG_ALIGN
argument_list|(
name|opdesc
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"unaligned register"
argument_list|)
expr_stmt|;
block|}
name|regopP
operator|->
name|n
operator|=
name|n
expr_stmt|;
name|regopP
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
name|regopP
operator|->
name|special
operator|=
literal|0
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|IS_FP_REG
argument_list|(
name|n
argument_list|)
operator|&&
name|FP_OK
argument_list|(
name|opdesc
argument_list|)
condition|)
block|{
comment|/* Floating point register, and it's allowed */
name|regopP
operator|->
name|n
operator|=
name|n
operator|-
name|FP0
expr_stmt|;
name|regopP
operator|->
name|mode
operator|=
literal|1
expr_stmt|;
name|regopP
operator|->
name|special
operator|=
literal|0
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|IS_SF_REG
argument_list|(
name|n
argument_list|)
operator|&&
name|SFR_OK
argument_list|(
name|opdesc
argument_list|)
condition|)
block|{
comment|/* Special-function register, and it's allowed */
name|regopP
operator|->
name|n
operator|=
name|n
operator|-
name|SF0
expr_stmt|;
name|regopP
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
name|regopP
operator|->
name|special
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|targ_has_sfr
argument_list|(
name|regopP
operator|->
name|n
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"no such sfr in this architecture"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|LIT_OK
argument_list|(
name|opdesc
argument_list|)
condition|)
block|{
comment|/* 		 * How about a literal? 		 */
name|regopP
operator|->
name|mode
operator|=
literal|1
expr_stmt|;
name|regopP
operator|->
name|special
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|FP_OK
argument_list|(
name|opdesc
argument_list|)
condition|)
block|{
comment|/* floating point literal acceptable */
comment|/* Skip over 0f, 0d, or 0e prefix */
if|if
condition|(
operator|(
name|optext
index|[
literal|0
index|]
operator|==
literal|'0'
operator|)
operator|&&
operator|(
name|optext
index|[
literal|1
index|]
operator|>=
literal|'d'
operator|)
operator|&&
operator|(
name|optext
index|[
literal|1
index|]
operator|<=
literal|'f'
operator|)
condition|)
block|{
name|optext
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|optext
argument_list|,
literal|"0.0"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|optext
argument_list|,
literal|"0"
argument_list|)
condition|)
block|{
name|regopP
operator|->
name|n
operator|=
literal|0x10
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|optext
argument_list|,
literal|"1.0"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|optext
argument_list|,
literal|"1"
argument_list|)
condition|)
block|{
name|regopP
operator|->
name|n
operator|=
literal|0x16
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* fixed point literal acceptable */
if|if
condition|(
operator|(
name|parse_expr
argument_list|(
name|optext
argument_list|,
operator|&
name|e
argument_list|)
operator|!=
name|SEG_ABSOLUTE
operator|)
operator|||
operator|(
name|offs
argument_list|(
name|e
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|offs
argument_list|(
name|e
argument_list|)
operator|>
literal|31
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"illegal literal"
argument_list|)
expr_stmt|;
name|offs
argument_list|(
name|e
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|regopP
operator|->
name|n
operator|=
name|offs
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Nothing worked */
name|syntax
argument_list|()
expr_stmt|;
name|regopP
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
comment|/* Register r0 is always a good one */
name|regopP
operator|->
name|n
operator|=
literal|0
expr_stmt|;
name|regopP
operator|->
name|special
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* parse_regop() */
end_comment

begin_comment
comment|/*****************************************************************************  * reg_fmt:	generate a REG-format instruction  *  **************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|reg_fmt
parameter_list|(
name|args
parameter_list|,
name|oP
parameter_list|)
name|char
modifier|*
name|args
index|[]
decl_stmt|;
comment|/* args[0]->opcode mnemonic, args[1-3]->operands */
name|struct
name|i960_opcode
modifier|*
name|oP
decl_stmt|;
comment|/* Pointer to description of instruction */
block|{
name|long
name|instr
decl_stmt|;
comment|/* Binary to be output */
name|struct
name|regop
name|regop
decl_stmt|;
comment|/* Description of register operand */
name|int
name|n_ops
decl_stmt|;
comment|/* Number of operands */
name|instr
operator|=
name|oP
operator|->
name|opcode
expr_stmt|;
name|n_ops
operator|=
name|oP
operator|->
name|num_ops
expr_stmt|;
if|if
condition|(
name|n_ops
operator|>=
literal|1
condition|)
block|{
name|parse_regop
argument_list|(
operator|&
name|regop
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|oP
operator|->
name|operand
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n_ops
operator|==
literal|1
operator|)
operator|&&
operator|!
operator|(
name|instr
operator|&
name|M3
operator|)
condition|)
block|{
comment|/* 1-operand instruction in which the dst field should 			 * be used (instead of src1). 			 */
name|regop
operator|.
name|n
operator|<<=
literal|19
expr_stmt|;
if|if
condition|(
name|regop
operator|.
name|special
condition|)
block|{
name|regop
operator|.
name|mode
operator|=
name|regop
operator|.
name|special
expr_stmt|;
block|}
name|regop
operator|.
name|mode
operator|<<=
literal|13
expr_stmt|;
name|regop
operator|.
name|special
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* regop.n goes in bit 0, needs no shifting */
name|regop
operator|.
name|mode
operator|<<=
literal|11
expr_stmt|;
name|regop
operator|.
name|special
operator|<<=
literal|5
expr_stmt|;
block|}
name|instr
operator||=
name|regop
operator|.
name|n
operator||
name|regop
operator|.
name|mode
operator||
name|regop
operator|.
name|special
expr_stmt|;
block|}
if|if
condition|(
name|n_ops
operator|>=
literal|2
condition|)
block|{
name|parse_regop
argument_list|(
operator|&
name|regop
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|,
name|oP
operator|->
name|operand
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n_ops
operator|==
literal|2
operator|)
operator|&&
operator|!
operator|(
name|instr
operator|&
name|M3
operator|)
condition|)
block|{
comment|/* 2-operand instruction in which the dst field should 			 * be used instead of src2). 			 */
name|regop
operator|.
name|n
operator|<<=
literal|19
expr_stmt|;
if|if
condition|(
name|regop
operator|.
name|special
condition|)
block|{
name|regop
operator|.
name|mode
operator|=
name|regop
operator|.
name|special
expr_stmt|;
block|}
name|regop
operator|.
name|mode
operator|<<=
literal|13
expr_stmt|;
name|regop
operator|.
name|special
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|regop
operator|.
name|n
operator|<<=
literal|14
expr_stmt|;
name|regop
operator|.
name|mode
operator|<<=
literal|12
expr_stmt|;
name|regop
operator|.
name|special
operator|<<=
literal|6
expr_stmt|;
block|}
name|instr
operator||=
name|regop
operator|.
name|n
operator||
name|regop
operator|.
name|mode
operator||
name|regop
operator|.
name|special
expr_stmt|;
block|}
if|if
condition|(
name|n_ops
operator|==
literal|3
condition|)
block|{
name|parse_regop
argument_list|(
operator|&
name|regop
argument_list|,
name|args
index|[
literal|3
index|]
argument_list|,
name|oP
operator|->
name|operand
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|regop
operator|.
name|special
condition|)
block|{
name|regop
operator|.
name|mode
operator|=
name|regop
operator|.
name|special
expr_stmt|;
block|}
name|instr
operator||=
operator|(
name|regop
operator|.
name|n
operator|<<=
literal|19
operator|)
operator||
operator|(
name|regop
operator|.
name|mode
operator|<<=
literal|13
operator|)
expr_stmt|;
block|}
name|emit
argument_list|(
name|instr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * relax_cobr:  *	Replace cobr instruction in a code fragment with equivalent branch and  *	compare instructions, so it can reach beyond a 13-bit displacement.  *	Set up an address fix/relocation for the new branch instruction.  *  **************************************************************************** */
end_comment

begin_comment
comment|/* This "conditional jump" table maps cobr instructions into equivalent  * compare and branch opcodes.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|long
name|compare
decl_stmt|;
name|long
name|branch
decl_stmt|;
block|}
name|coj
index|[]
init|=
block|{
comment|/* COBR OPCODE: */
name|CHKBIT
block|,
name|BNO
block|,
comment|/*	0x30 - bbc */
name|CMPO
block|,
name|BG
block|,
comment|/*	0x31 - cmpobg */
name|CMPO
block|,
name|BE
block|,
comment|/*	0x32 - cmpobe */
name|CMPO
block|,
name|BGE
block|,
comment|/*	0x33 - cmpobge */
name|CMPO
block|,
name|BL
block|,
comment|/*	0x34 - cmpobl */
name|CMPO
block|,
name|BNE
block|,
comment|/*	0x35 - cmpobne */
name|CMPO
block|,
name|BLE
block|,
comment|/*	0x36 - cmpoble */
name|CHKBIT
block|,
name|BO
block|,
comment|/*	0x37 - bbs */
name|CMPI
block|,
name|BNO
block|,
comment|/*	0x38 - cmpibno */
name|CMPI
block|,
name|BG
block|,
comment|/*	0x39 - cmpibg */
name|CMPI
block|,
name|BE
block|,
comment|/*	0x3a - cmpibe */
name|CMPI
block|,
name|BGE
block|,
comment|/*	0x3b - cmpibge */
name|CMPI
block|,
name|BL
block|,
comment|/*	0x3c - cmpibl */
name|CMPI
block|,
name|BNE
block|,
comment|/*	0x3d - cmpibne */
name|CMPI
block|,
name|BLE
block|,
comment|/*	0x3e - cmpible */
name|CMPI
block|,
name|BO
block|,
comment|/*	0x3f - cmpibo */
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|relax_cobr
parameter_list|(
name|fragP
parameter_list|)
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
comment|/* fragP->fr_opcode is assumed to point to 			 * the cobr instruction, which comes at the 			 * end of the code fragment. 			 */
block|{
name|int
name|opcode
decl_stmt|,
name|src1
decl_stmt|,
name|src2
decl_stmt|,
name|m1
decl_stmt|,
name|s2
decl_stmt|;
comment|/* Bit fields from cobr instruction */
name|long
name|bp_bits
decl_stmt|;
comment|/* Branch prediction bits from cobr instruction */
name|long
name|instr
decl_stmt|;
comment|/* A single i960 instruction */
name|char
modifier|*
name|iP
decl_stmt|;
comment|/*->instruction to be replaced */
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/* Relocation that can be done at assembly time */
comment|/* PICK UP& PARSE COBR INSTRUCTION */
name|iP
operator|=
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
name|instr
operator|=
name|md_chars_to_number
argument_list|(
name|iP
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|opcode
operator|=
operator|(
operator|(
name|instr
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
operator|-
literal|0x30
expr_stmt|;
comment|/* "-0x30" for table index */
name|src1
operator|=
operator|(
name|instr
operator|>>
literal|19
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|m1
operator|=
operator|(
name|instr
operator|>>
literal|13
operator|)
operator|&
literal|1
expr_stmt|;
name|s2
operator|=
name|instr
operator|&
literal|1
expr_stmt|;
name|src2
operator|=
operator|(
name|instr
operator|>>
literal|14
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|bp_bits
operator|=
name|instr
operator|&
name|BP_MASK
expr_stmt|;
comment|/* GENERATE AND OUTPUT COMPARE INSTRUCTION */
name|instr
operator|=
name|coj
index|[
name|opcode
index|]
operator|.
name|compare
operator||
name|src1
operator||
operator|(
name|m1
operator|<<
literal|11
operator|)
operator||
operator|(
name|s2
operator|<<
literal|6
operator|)
operator||
operator|(
name|src2
operator|<<
literal|14
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|iP
argument_list|,
name|instr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* OUTPUT BRANCH INSTRUCTION */
name|md_number_to_chars
argument_list|(
name|iP
operator|+
literal|4
argument_list|,
name|coj
index|[
name|opcode
index|]
operator|.
name|branch
operator||
name|bp_bits
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* SET UP ADDRESS FIXUP/RELOCATION */
name|fixP
operator|=
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|iP
operator|+
literal|4
operator|-
name|fragP
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_bit_fixP
operator|=
operator|(
name|bit_fixS
operator|*
operator|)
literal|24
expr_stmt|;
comment|/* Store size of bit field */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * reloc_callj:	Relocate a 'callj' instruction  *  *	This is a "non-(GNU)-standard" machine-dependent hook.  The base  *	assembler calls it when it decides it can relocate an address at  *	assembly time instead of emitting a relocation directive.  *  *	Check to see if the relocation involves a 'callj' instruction to a:  *	    sysproc:	Replace the default 'call' instruction with a 'calls'  *	    leafproc:	Replace the default 'call' instruction with a 'bal'.  *	    other proc:	Do nothing.  *  *	See b.out.h for details on the 'n_other' field in a symbol structure.  *  * IMPORTANT!:  *	Assumes the caller has already figured out, in the case of a leafproc,  *	to use the 'bal' entry point, and has substituted that symbol into the  *	passed fixup structure.  *  **************************************************************************** */
end_comment

begin_function
name|void
name|reloc_callj
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/* Relocation that can be done at assembly time */
block|{
name|char
modifier|*
name|where
decl_stmt|;
comment|/*->the binary for the instruction being relocated */
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_callj
condition|)
block|{
return|return;
block|}
comment|/* This wasn't a callj instruction in the first place */
name|where
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
operator|+
name|fixP
operator|->
name|fx_where
expr_stmt|;
if|if
condition|(
name|TC_S_IS_SYSPROC
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
comment|/* Symbol is a .sysproc: replace 'call' with 'calls'. 		 * System procedure number is (other-1). 		 */
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|CALLS
operator||
name|TC_S_GET_SYSPROC
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Nothing else needs to be done for this instruction. 		 * Make sure 'md_number_to_field()' will perform a no-op. 		 */
name|fixP
operator|->
name|fx_bit_fixP
operator|=
operator|(
name|bit_fixS
operator|*
operator|)
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TC_S_IS_CALLNAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
comment|/* Should not happen: see block comment above */
name|as_fatal
argument_list|(
literal|"Trying to 'bal' to %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TC_S_IS_BALNAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
comment|/* Replace 'call' with 'bal';  both instructions have 		 * the same format, so calling code should complete 		 * relocation as if nothing happened here. 		 */
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|BAL
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TC_S_IS_BADPROC
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Looks like a proc, but can't tell what kind.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* switch on proc type */
comment|/* else Symbol is neither a sysproc nor a leafproc */
return|return;
block|}
end_function

begin_comment
comment|/* reloc_callj() */
end_comment

begin_comment
comment|/*****************************************************************************  * s_leafproc:	process .leafproc pseudo-op  *  *	.leafproc takes two arguments, the second one is optional:  *		arg[1]: name of 'call' entry point to leaf procedure  *		arg[2]: name of 'bal' entry point to leaf procedure  *  *	If the two arguments are identical, or if the second one is missing,  *	the first argument is taken to be the 'bal' entry point.  *  *	If there are 2 distinct arguments, we must make sure that the 'bal'  *	entry point immediately follows the 'call' entry point in the linked  *	list of symbols.  *  **************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|s_leafproc
parameter_list|(
name|n_ops
parameter_list|,
name|args
parameter_list|)
name|int
name|n_ops
decl_stmt|;
comment|/* Number of operands */
name|char
modifier|*
name|args
index|[]
decl_stmt|;
comment|/* args[1]->1st operand, args[2]->2nd operand */
block|{
name|symbolS
modifier|*
name|callP
decl_stmt|;
comment|/* Pointer to leafproc 'call' entry point symbol */
name|symbolS
modifier|*
name|balP
decl_stmt|;
comment|/* Pointer to leafproc 'bal' entry point symbol */
if|if
condition|(
operator|(
name|n_ops
operator|!=
literal|1
operator|)
operator|&&
operator|(
name|n_ops
operator|!=
literal|2
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"should have 1 or 2 operands"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check number of arguments */
comment|/* Find or create symbol for 'call' entry point. */
name|callP
operator|=
name|symbol_find_or_make
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|TC_S_IS_CALLNAME
argument_list|(
name|callP
argument_list|)
condition|)
block|{
name|as_warn
argument_list|(
literal|"Redefining leafproc %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|callP
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* is leafproc */
comment|/* If that was the only argument, use it as the 'bal' entry point. 	 * Otherwise, mark it as the 'call' entry point and find or create 	 * another symbol for the 'bal' entry point. 	 */
if|if
condition|(
operator|(
name|n_ops
operator|==
literal|1
operator|)
operator|||
operator|!
name|strcmp
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|TC_S_FORCE_TO_BALNAME
argument_list|(
name|callP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TC_S_FORCE_TO_CALLNAME
argument_list|(
name|callP
argument_list|)
expr_stmt|;
name|balP
operator|=
name|symbol_find_or_make
argument_list|(
name|args
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|TC_S_IS_CALLNAME
argument_list|(
name|balP
argument_list|)
condition|)
block|{
name|as_warn
argument_list|(
literal|"Redefining leafproc %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|balP
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|TC_S_FORCE_TO_BALNAME
argument_list|(
name|balP
argument_list|)
expr_stmt|;
name|tc_set_bal_of_call
argument_list|(
name|callP
argument_list|,
name|balP
argument_list|)
expr_stmt|;
block|}
comment|/* if only one arg, or the args are the same */
return|return;
block|}
end_function

begin_comment
comment|/* s_leafproc() */
end_comment

begin_comment
comment|/*  * s_sysproc:	process .sysproc pseudo-op  *  *	.sysproc takes two arguments:  *		arg[1]: name of entry point to system procedure  *		arg[2]: 'entry_num' (index) of system procedure in the range  *			[0,31] inclusive.  *  *	For [ab].out, we store the 'entrynum' in the 'n_other' field of  *	the symbol.  Since that entry is normally 0, we bias 'entrynum'  *	by adding 1 to it.  It must be unbiased before it is used.  */
end_comment

begin_function
specifier|static
name|void
name|s_sysproc
parameter_list|(
name|n_ops
parameter_list|,
name|args
parameter_list|)
name|int
name|n_ops
decl_stmt|;
comment|/* Number of operands */
name|char
modifier|*
name|args
index|[]
decl_stmt|;
comment|/* args[1]->1st operand, args[2]->2nd operand */
block|{
name|expressionS
name|exp
decl_stmt|;
name|symbolS
modifier|*
name|symP
decl_stmt|;
if|if
condition|(
name|n_ops
operator|!=
literal|2
condition|)
block|{
name|as_bad
argument_list|(
literal|"should have two operands"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* bad arg count */
comment|/* Parse "entry_num" argument and check it for validity. */
if|if
condition|(
operator|(
name|parse_expr
argument_list|(
name|args
index|[
literal|2
index|]
argument_list|,
operator|&
name|exp
argument_list|)
operator|!=
name|SEG_ABSOLUTE
operator|)
operator|||
operator|(
name|offs
argument_list|(
name|exp
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|offs
argument_list|(
name|exp
argument_list|)
operator|>
literal|31
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"'entry_num' must be absolute number in [0,31]"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find/make symbol and stick entry number (biased by +1) into it */
name|symP
operator|=
name|symbol_find_or_make
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|TC_S_IS_SYSPROC
argument_list|(
name|symP
argument_list|)
condition|)
block|{
name|as_warn
argument_list|(
literal|"Redefining entrynum for sysproc %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|symP
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* redefining */
name|TC_S_SET_SYSPROC
argument_list|(
name|symP
argument_list|,
name|offs
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* encode entry number */
name|TC_S_FORCE_TO_SYSPROC
argument_list|(
name|symP
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* s_sysproc() */
end_comment

begin_comment
comment|/*****************************************************************************  * shift_ok:  *	Determine if a "shlo" instruction can be used to implement a "ldconst".  *	This means that some number X< 32 can be shifted left to produce the  *	constant of interest.  *  *	Return the shift count, or 0 if we can't do it.  *	Caller calculates X by shifting original constant right 'shift' places.  *  **************************************************************************** */
end_comment

begin_function
specifier|static
name|int
name|shift_ok
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
comment|/* The constant of interest */
block|{
name|int
name|shift
decl_stmt|;
comment|/* The shift count */
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
comment|/* Can't do it for negative numbers */
return|return
literal|0
return|;
block|}
comment|/* Shift 'n' right until a 1 is about to be lost */
for|for
control|(
name|shift
operator|=
literal|0
init|;
operator|(
name|n
operator|&
literal|1
operator|)
operator|==
literal|0
condition|;
name|shift
operator|++
control|)
block|{
name|n
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|>=
literal|32
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
name|shift
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************  * syntax:	issue syntax error  *  **************************************************************************** */
end_comment

begin_function
specifier|static
name|void
name|syntax
parameter_list|()
block|{
name|as_bad
argument_list|(
literal|"syntax error"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* syntax() */
end_comment

begin_comment
comment|/*****************************************************************************  * targ_has_sfr:  *	Return TRUE iff the target architecture supports the specified  *	special-function register (sfr).  *  **************************************************************************** */
end_comment

begin_function
specifier|static
name|int
name|targ_has_sfr
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
comment|/* Number (0-31) of sfr */
block|{
switch|switch
condition|(
name|architecture
condition|)
block|{
case|case
name|ARCH_KA
case|:
case|case
name|ARCH_KB
case|:
case|case
name|ARCH_MC
case|:
return|return
literal|0
return|;
case|case
name|ARCH_CA
case|:
default|default:
return|return
operator|(
operator|(
literal|0
operator|<=
name|n
operator|)
operator|&&
operator|(
name|n
operator|<=
literal|2
operator|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*****************************************************************************  * targ_has_iclass:  *	Return TRUE iff the target architecture supports the indicated  *	class of instructions.  *  **************************************************************************** */
end_comment

begin_function
specifier|static
name|int
name|targ_has_iclass
parameter_list|(
name|ic
parameter_list|)
name|int
name|ic
decl_stmt|;
comment|/* Instruction class;  one of: 	 *	I_BASE, I_CX, I_DEC, I_KX, I_FP, I_MIL, I_CASIM 	 */
block|{
name|iclasses_seen
operator||=
name|ic
expr_stmt|;
switch|switch
condition|(
name|architecture
condition|)
block|{
case|case
name|ARCH_KA
case|:
return|return
name|ic
operator|&
operator|(
name|I_BASE
operator||
name|I_KX
operator|)
return|;
case|case
name|ARCH_KB
case|:
return|return
name|ic
operator|&
operator|(
name|I_BASE
operator||
name|I_KX
operator||
name|I_FP
operator||
name|I_DEC
operator|)
return|;
case|case
name|ARCH_MC
case|:
return|return
name|ic
operator|&
operator|(
name|I_BASE
operator||
name|I_KX
operator||
name|I_FP
operator||
name|I_DEC
operator||
name|I_MIL
operator|)
return|;
case|case
name|ARCH_CA
case|:
return|return
name|ic
operator|&
operator|(
name|I_BASE
operator||
name|I_CX
operator||
name|I_CASIM
operator|)
return|;
default|default:
if|if
condition|(
operator|(
name|iclasses_seen
operator|&
operator|(
name|I_KX
operator||
name|I_FP
operator||
name|I_DEC
operator||
name|I_MIL
operator|)
operator|)
operator|&&
operator|(
name|iclasses_seen
operator|&
name|I_CX
operator|)
condition|)
block|{
name|as_warn
argument_list|(
literal|"architecture of opcode conflicts with that of earlier instruction(s)"
argument_list|)
expr_stmt|;
name|iclasses_seen
operator|&=
operator|~
name|ic
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Parse an operand that is machine-specific.    We just return without modifying the expression if we have nothing    to do. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* We have no need to default values of symbols. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* md_undefined_symbol() */
end_comment

begin_comment
comment|/* Exactly what point is a PC-relative offset relative TO?    On the i960, they're relative to the address of the instruction,    which we have set up as the address of the fixup too. */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
return|return
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
block|}
end_function

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixP
parameter_list|,
name|val
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|long
name|val
decl_stmt|;
block|{
name|char
modifier|*
name|place
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_bit_fixP
condition|)
block|{
switch|switch
condition|(
name|fixP
operator|->
name|fx_im_disp
condition|)
block|{
case|case
literal|0
case|:
name|fixP
operator|->
name|fx_addnumber
operator|=
name|val
expr_stmt|;
name|md_number_to_imm
argument_list|(
name|place
argument_list|,
name|val
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|,
name|fixP
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|md_number_to_disp
argument_list|(
name|place
argument_list|,
name|fixP
operator|->
name|fx_pcrel
condition|?
name|val
operator|+
name|fixP
operator|->
name|fx_pcrel_adjust
else|:
name|val
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* fix requested for .long .word etc */
name|md_number_to_chars
argument_list|(
name|place
argument_list|,
name|val
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"Internal error in md_apply_fix() in file \"%s\""
argument_list|,
name|__FILE__
argument_list|)
expr_stmt|;
block|}
comment|/* OVE: maybe one ought to put _imm _disp _chars in one md-func */
block|}
else|else
block|{
name|md_number_to_field
argument_list|(
name|place
argument_list|,
name|val
argument_list|,
name|fixP
operator|->
name|fx_bit_fixP
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* md_apply_fix() */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
end_if

begin_function
name|void
name|tc_bout_fix_to_chars
parameter_list|(
name|where
parameter_list|,
name|fixP
parameter_list|,
name|segment_address_in_file
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|relax_addressT
name|segment_address_in_file
decl_stmt|;
block|{
specifier|static
name|unsigned
name|char
name|nbytes_r_length
index|[]
init|=
block|{
literal|42
block|,
literal|0
block|,
literal|1
block|,
literal|42
block|,
literal|2
block|}
decl_stmt|;
name|struct
name|relocation_info
name|ri
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* JF this is for paranoia */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ri
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ri
argument_list|)
argument_list|)
expr_stmt|;
name|know
argument_list|(
operator|(
name|symbolP
operator|=
name|fixP
operator|->
name|fx_addsy
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* These two 'cuz of NS32K */
name|ri
operator|.
name|r_callj
operator|=
name|fixP
operator|->
name|fx_callj
expr_stmt|;
name|ri
operator|.
name|r_length
operator|=
name|nbytes_r_length
index|[
name|fixP
operator|->
name|fx_size
index|]
expr_stmt|;
name|ri
operator|.
name|r_pcrel
operator|=
name|fixP
operator|->
name|fx_pcrel
expr_stmt|;
name|ri
operator|.
name|r_address
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|segment_address_in_file
expr_stmt|;
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|ri
operator|.
name|r_extern
operator|=
literal|1
expr_stmt|;
name|ri
operator|.
name|r_index
operator|=
name|symbolP
operator|->
name|sy_number
expr_stmt|;
block|}
else|else
block|{
name|ri
operator|.
name|r_extern
operator|=
literal|0
expr_stmt|;
name|ri
operator|.
name|r_index
operator|=
name|S_GET_TYPE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
comment|/* Output the relocation information in machine-dependent form. */
name|md_ri_to_chars
argument_list|(
name|where
argument_list|,
operator|&
name|ri
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tc_bout_fix_to_chars() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_AOUT or OBJ_BOUT */
end_comment

begin_comment
comment|/* Align an address by rounding it up to the specified boundary.  */
end_comment

begin_function
name|long
name|md_section_align
parameter_list|(
name|seg
parameter_list|,
name|addr
parameter_list|)
name|segT
name|seg
decl_stmt|;
name|long
name|addr
decl_stmt|;
comment|/* Address to be rounded up */
block|{
return|return
operator|(
operator|(
name|addr
operator|+
operator|(
literal|1
operator|<<
name|section_alignment
index|[
operator|(
name|int
operator|)
name|seg
index|]
operator|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
literal|1
operator|<<
name|section_alignment
index|[
operator|(
name|int
operator|)
name|seg
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* md_section_align() */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_COFF
end_ifdef

begin_function
name|void
name|tc_headers_hook
parameter_list|(
name|headers
parameter_list|)
name|object_headers
modifier|*
name|headers
decl_stmt|;
block|{
comment|/* FIXME: remove this line */
comment|/*	unsigned short arch_flag = 0; */
if|if
condition|(
operator|(
name|iclasses_seen
operator|==
name|I_BASE
operator|)
operator|||
operator|(
name|iclasses_seen
operator|==
literal|0
operator|)
condition|)
block|{
name|headers
operator|->
name|filehdr
operator|.
name|f_flags
operator||=
name|F_I960CORE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iclasses_seen
operator|&
name|I_CX
condition|)
block|{
name|headers
operator|->
name|filehdr
operator|.
name|f_flags
operator||=
name|F_I960CA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iclasses_seen
operator|&
name|I_MIL
condition|)
block|{
name|headers
operator|->
name|filehdr
operator|.
name|f_flags
operator||=
name|F_I960MC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iclasses_seen
operator|&
operator|(
name|I_DEC
operator||
name|I_FP
operator|)
condition|)
block|{
name|headers
operator|->
name|filehdr
operator|.
name|f_flags
operator||=
name|F_I960KB
expr_stmt|;
block|}
else|else
block|{
name|headers
operator|->
name|filehdr
operator|.
name|f_flags
operator||=
name|F_I960KA
expr_stmt|;
block|}
comment|/* set arch flag */
if|if
condition|(
name|flagseen
index|[
literal|'R'
index|]
condition|)
block|{
name|headers
operator|->
name|filehdr
operator|.
name|f_magic
operator|=
name|I960RWMAGIC
expr_stmt|;
name|headers
operator|->
name|aouthdr
operator|.
name|magic
operator|=
name|OMAGIC
expr_stmt|;
block|}
else|else
block|{
name|headers
operator|->
name|filehdr
operator|.
name|f_magic
operator|=
name|I960ROMAGIC
expr_stmt|;
name|headers
operator|->
name|aouthdr
operator|.
name|magic
operator|=
name|NMAGIC
expr_stmt|;
block|}
comment|/* set magic numbers */
return|return;
block|}
end_function

begin_comment
comment|/* tc_headers_hook() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_COFF */
end_comment

begin_comment
comment|/*  * Things going on here:  *  * For bout, We need to assure a couple of simplifying  * assumptions about leafprocs for the linker: the leafproc  * entry symbols will be defined in the same assembly in  * which they're declared with the '.leafproc' directive;  * and if a leafproc has both 'call' and 'bal' entry points  * they are both global or both local.  *  * For coff, the call symbol has a second aux entry that  * contains the bal entry point.  The bal symbol becomes a  * label.  *  * For coff representation, the call symbol has a second aux entry that  * contains the bal entry point.  The bal symbol becomes a label.  *  */
end_comment

begin_function
name|void
name|tc_crawl_symbol_chain
parameter_list|(
name|headers
parameter_list|)
name|object_headers
modifier|*
name|headers
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
ifdef|#
directive|ifdef
name|OBJ_COFF
if|if
condition|(
name|TC_S_IS_SYSPROC
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* second aux entry already contains the sysproc number */
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_SCALL
argument_list|)
expr_stmt|;
name|S_SET_DATA_TYPE
argument_list|(
name|symbolP
argument_list|,
name|S_GET_DATA_TYPE
argument_list|(
name|symbolP
argument_list|)
operator||
operator|(
name|DT_FCN
operator|<<
name|N_BTSHFT
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* rewrite sysproc */
endif|#
directive|endif
comment|/* OBJ_COFF */
if|if
condition|(
operator|!
name|TC_S_IS_BALNAME
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|TC_S_IS_CALLNAME
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|/* Not a leafproc symbol */
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"leafproc symbol '%s' undefined"
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* undefined leaf */
if|if
condition|(
name|TC_S_IS_CALLNAME
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|symbolS
modifier|*
name|balP
init|=
name|tc_get_bal_of_call
argument_list|(
name|symbolP
argument_list|)
decl_stmt|;
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|S_IS_EXTERNAL
argument_list|(
name|balP
argument_list|)
condition|)
block|{
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|balP
argument_list|)
expr_stmt|;
name|as_warn
argument_list|(
literal|"Warning: making leafproc entries %s and %s both global\n"
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|balP
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* externality mismatch */
block|}
comment|/* if callname */
block|}
comment|/* walk the symbol chain */
return|return;
block|}
end_function

begin_comment
comment|/* tc_crawl_symbol_chain() */
end_comment

begin_comment
comment|/*  * For aout or bout, the bal immediately follows the call.  *  * For coff, we cheat and store a pointer to the bal symbol  * in the second aux entry of the call.  */
end_comment

begin_function
name|void
name|tc_set_bal_of_call
parameter_list|(
name|callP
parameter_list|,
name|balP
parameter_list|)
name|symbolS
modifier|*
name|callP
decl_stmt|;
name|symbolS
modifier|*
name|balP
decl_stmt|;
block|{
name|know
argument_list|(
name|TC_S_IS_CALLNAME
argument_list|(
name|callP
argument_list|)
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|TC_S_IS_BALNAME
argument_list|(
name|balP
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_COFF
name|callP
operator|->
name|sy_symbol
operator|.
name|ost_auxent
index|[
literal|1
index|]
operator|.
name|x_bal
operator|.
name|x_balntry
operator|=
operator|(
name|int
operator|)
name|balP
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|callP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
comment|/* If the 'bal' entry doesn't immediately follow the 'call' 	 * symbol, unlink it from the symbol list and re-insert it. 	 */
if|if
condition|(
name|symbol_next
argument_list|(
name|callP
argument_list|)
operator|!=
name|balP
condition|)
block|{
name|symbol_remove
argument_list|(
name|balP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_append
argument_list|(
name|balP
argument_list|,
name|callP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
comment|/* if not in order */
else|#
directive|else
operator|(
name|as
name|yet
name|unwritten
operator|.
expr|);
endif|#
directive|endif
comment|/* switch on OBJ_FORMAT */
return|return;
block|}
end_function

begin_comment
comment|/* tc_set_bal_of_call() */
end_comment

begin_function
name|char
modifier|*
name|_tc_get_bal_of_call
parameter_list|(
name|callP
parameter_list|)
name|symbolS
modifier|*
name|callP
decl_stmt|;
block|{
name|symbolS
modifier|*
name|retval
decl_stmt|;
name|know
argument_list|(
name|TC_S_IS_CALLNAME
argument_list|(
name|callP
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OBJ_COFF
name|retval
operator|=
operator|(
name|symbolS
operator|*
operator|)
operator|(
name|callP
operator|->
name|sy_symbol
operator|.
name|ost_auxent
index|[
literal|1
index|]
operator|.
name|x_bal
operator|.
name|x_balntry
operator|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
name|retval
operator|=
name|symbol_next
argument_list|(
name|callP
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|as
name|yet
name|unwritten
operator|.
expr|);
endif|#
directive|endif
comment|/* switch on OBJ_FORMAT */
name|know
argument_list|(
name|TC_S_IS_BALNAME
argument_list|(
name|retval
argument_list|)
argument_list|)
expr|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* _tc_get_bal_of_call() */
end_comment

begin_function
name|void
name|tc_coff_symbol_emit_hook
parameter_list|(
name|symbolP
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
if|if
condition|(
name|TC_S_IS_CALLNAME
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|OBJ_COFF
name|symbolS
modifier|*
name|balP
init|=
name|tc_get_bal_of_call
argument_list|(
name|symbolP
argument_list|)
decl_stmt|;
comment|/* second aux entry contains the bal entry point */
comment|/*		S_SET_NUMBER_AUXILIARY(symbolP, 2); */
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_auxent
index|[
literal|1
index|]
operator|.
name|x_bal
operator|.
name|x_balntry
operator|=
name|S_GET_VALUE
argument_list|(
name|balP
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
operator|(
operator|!
name|SF_GET_LOCAL
argument_list|(
name|symbolP
argument_list|)
condition|?
name|C_LEAFEXT
else|:
name|C_LEAFSTAT
operator|)
argument_list|)
expr_stmt|;
name|S_SET_DATA_TYPE
argument_list|(
name|symbolP
argument_list|,
name|S_GET_DATA_TYPE
argument_list|(
name|symbolP
argument_list|)
operator||
operator|(
name|DT_FCN
operator|<<
name|N_BTSHFT
operator|)
argument_list|)
expr_stmt|;
comment|/* fix up the bal symbol */
name|S_SET_STORAGE_CLASS
argument_list|(
name|balP
argument_list|,
name|C_LABEL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJ_COFF */
block|}
comment|/* only on calls */
return|return;
block|}
end_function

begin_comment
comment|/* tc_coff_symbol_emit_hook() */
end_comment

begin_comment
comment|/*  * Local Variables:  * comment-column: 0  * fill-column: 131  * End:  */
end_comment

begin_comment
comment|/* end of tc-i960.c */
end_comment

end_unit

