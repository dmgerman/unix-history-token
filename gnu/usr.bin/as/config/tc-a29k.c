begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-a29k.c -- Assemble for the AMD 29000.    Copyright (C) 1989, 1990, 1991, 1992 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* John Gilmore has reorganized this module somewhat, to make it easier    to convert it to new machines' assemblers as desired.  There was too    much bloody rewriting required before.  There still probably is.  */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"opcode/a29k.h"
end_include

begin_comment
comment|/* Make it easier to clone this machine desc into another one.  */
end_comment

begin_define
define|#
directive|define
name|machine_opcode
value|a29k_opcode
end_define

begin_define
define|#
directive|define
name|machine_opcodes
value|a29k_opcodes
end_define

begin_define
define|#
directive|define
name|machine_ip
value|a29k_ip
end_define

begin_define
define|#
directive|define
name|machine_it
value|a29k_it
end_define

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IMMEDIATE_BIT
value|0x01000000
end_define

begin_comment
comment|/* Turns RB into Immediate */
end_comment

begin_define
define|#
directive|define
name|ABSOLUTE_BIT
value|0x01000000
end_define

begin_comment
comment|/* Turns PC-relative to Absolute */
end_comment

begin_define
define|#
directive|define
name|CE_BIT
value|0x00800000
end_define

begin_comment
comment|/* Coprocessor enable in LOAD */
end_comment

begin_define
define|#
directive|define
name|UI_BIT
value|0x00000080
end_define

begin_comment
comment|/* Unsigned integer in CONVERT */
end_comment

begin_comment
comment|/* handle of the OPCODE hash table */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|machine_it
block|{
name|char
modifier|*
name|error
decl_stmt|;
name|unsigned
name|long
name|opcode
decl_stmt|;
name|struct
name|nlist
modifier|*
name|nlistp
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|int
name|pcrel
decl_stmt|;
name|int
name|reloc_offset
decl_stmt|;
comment|/* Offset of reloc within insn */
name|enum
name|reloc_type
name|reloc
decl_stmt|;
block|}
name|the_insn
struct|;
end_struct

begin_if
if|#
directive|if
name|__STDC__
operator|==
literal|1
end_if

begin_comment
comment|/* static int getExpression(char *str); */
end_comment

begin_function_decl
specifier|static
name|void
name|machine_ip
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* static void print_insn(struct machine_it *insn); */
end_comment

begin_function_decl
specifier|static
name|void
name|s_data1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_use
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not __STDC__ */
end_comment

begin_comment
comment|/* static int getExpression(); */
end_comment

begin_function_decl
specifier|static
name|void
name|machine_ip
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* static void print_insn(); */
end_comment

begin_function_decl
specifier|static
name|void
name|s_data1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_use
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __STDC__ */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|4
block|}
block|,
block|{
literal|"block"
block|,
name|s_space
block|,
literal|0
block|}
block|,
block|{
literal|"cputype"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* CPU as 29000 or 29050 */
block|{
literal|"reg"
block|,
name|s_lsym
block|,
literal|0
block|}
block|,
comment|/* Register equate, same as equ */
block|{
literal|"space"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* Listing control */
block|{
literal|"sect"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
comment|/* Creation of coff sections */
block|{
literal|"use"
block|,
name|s_use
block|,
literal|0
block|}
block|,
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|,     }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|md_short_jump_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|md_long_jump_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BFD_HEADERS
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|RELSZ
end_ifdef

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
name|RELSZ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Coff headers */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
literal|12
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* something else headers */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
literal|12
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Not bfdized*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This array holds the chars that always start a comment.  If the    pre-processor is disabled, these aren't very useful */
end_comment

begin_decl_stmt
name|char
name|comment_chars
index|[]
init|=
literal|";"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds the chars that only start a comment at the beginning of    a line.  If the line seems to have the form '# 123 filename'    .line and .file directives will appear in the pre-processed output */
end_comment

begin_comment
comment|/* Note that input_file.c hand checks for '#' at the beginning of the    first line of the input file.  This is because the compiler outputs    #NO_APP at the beginning of its output. */
end_comment

begin_comment
comment|/* Also note that comments like this one will always work */
end_comment

begin_decl_stmt
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We needed an unused char for line separation to work around the    lack of macros, using sed and such.  */
end_comment

begin_decl_stmt
name|char
name|line_separator_chars
index|[]
init|=
literal|"@"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums */
end_comment

begin_decl_stmt
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant */
end_comment

begin_comment
comment|/* As in 0f12.456 */
end_comment

begin_comment
comment|/* or    0d1.2345e12 */
end_comment

begin_decl_stmt
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXpP"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be    changed in read.c. Ideally it shouldn't have to know about it at all,    but nothing is ideal around here.    */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|octal
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|isoctal
parameter_list|(
name|c
parameter_list|)
value|octal[c]
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|toHex
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  anull bit - causes the branch delay slot instructions to not be executed  */
end_comment

begin_define
define|#
directive|define
name|ANNUL
value|(1<< 29)
end_define

begin_function
specifier|static
name|void
name|s_use
parameter_list|()
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|".text"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|5
expr_stmt|;
name|s_text
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|".data"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|5
expr_stmt|;
name|s_data
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|".data1"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|6
expr_stmt|;
name|s_data1
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Literals can't go in the text segment because you can't read 	   from instruction memory on some 29k's.  So, into initialized data. */
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|".lit"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|4
expr_stmt|;
name|subseg_new
argument_list|(
name|SEG_DATA
argument_list|,
literal|200
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|as_bad
argument_list|(
literal|"Unknown segment type"
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|s_data1
parameter_list|()
block|{
name|subseg_new
argument_list|(
name|SEG_DATA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Install symbol definition that maps REGNAME to REGNO.    FIXME-SOON:  These are not recognized in mixed case.  */
end_comment

begin_function
specifier|static
name|void
name|insert_sreg
parameter_list|(
name|regname
parameter_list|,
name|regnum
parameter_list|)
name|char
modifier|*
name|regname
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
comment|/* FIXME-SOON, put something in these syms so they won't be output to the symbol 	   table of the resulting object file.  */
comment|/* Must be large enough to hold the names of the special registers.  */
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
name|regname
argument_list|,
name|SEG_REGISTER
argument_list|,
name|regnum
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|regname
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|islower
argument_list|(
name|regname
index|[
name|i
index|]
argument_list|)
condition|?
name|toupper
argument_list|(
name|regname
index|[
name|i
index|]
argument_list|)
else|:
name|regname
index|[
name|i
index|]
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbol_new
argument_list|(
name|buf
argument_list|,
name|SEG_REGISTER
argument_list|,
name|regnum
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* insert_sreg() */
end_comment

begin_comment
comment|/* Install symbol definitions for assorted special registers.    See ASM29K Ref page 2-9.  */
end_comment

begin_function
name|void
name|define_some_regs
parameter_list|()
block|{
define|#
directive|define
name|SREG
value|256
comment|/* Protected special-purpose register names */
name|insert_sreg
argument_list|(
literal|"vab"
argument_list|,
name|SREG
operator|+
literal|0
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"ops"
argument_list|,
name|SREG
operator|+
literal|1
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"cps"
argument_list|,
name|SREG
operator|+
literal|2
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"cfg"
argument_list|,
name|SREG
operator|+
literal|3
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"cha"
argument_list|,
name|SREG
operator|+
literal|4
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"chd"
argument_list|,
name|SREG
operator|+
literal|5
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"chc"
argument_list|,
name|SREG
operator|+
literal|6
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"rbp"
argument_list|,
name|SREG
operator|+
literal|7
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"tmc"
argument_list|,
name|SREG
operator|+
literal|8
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"tmr"
argument_list|,
name|SREG
operator|+
literal|9
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"pc0"
argument_list|,
name|SREG
operator|+
literal|10
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"pc1"
argument_list|,
name|SREG
operator|+
literal|11
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"pc2"
argument_list|,
name|SREG
operator|+
literal|12
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"mmu"
argument_list|,
name|SREG
operator|+
literal|13
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"lru"
argument_list|,
name|SREG
operator|+
literal|14
argument_list|)
expr_stmt|;
comment|/* Unprotected special-purpose register names */
name|insert_sreg
argument_list|(
literal|"ipc"
argument_list|,
name|SREG
operator|+
literal|128
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"ipa"
argument_list|,
name|SREG
operator|+
literal|129
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"ipb"
argument_list|,
name|SREG
operator|+
literal|130
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"q"
argument_list|,
name|SREG
operator|+
literal|131
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"alu"
argument_list|,
name|SREG
operator|+
literal|132
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"bp"
argument_list|,
name|SREG
operator|+
literal|133
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"fc"
argument_list|,
name|SREG
operator|+
literal|134
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"cr"
argument_list|,
name|SREG
operator|+
literal|135
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"fpe"
argument_list|,
name|SREG
operator|+
literal|160
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"inte"
argument_list|,
name|SREG
operator|+
literal|161
argument_list|)
expr_stmt|;
name|insert_sreg
argument_list|(
literal|"fps"
argument_list|,
name|SREG
operator|+
literal|162
argument_list|)
expr_stmt|;
comment|/*  "",    SREG+163);	  Reserved */
name|insert_sreg
argument_list|(
literal|"exop"
argument_list|,
name|SREG
operator|+
literal|164
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* define_some_regs() */
end_comment

begin_comment
comment|/* This function is called once, at assembler startup time.  It should    set up all the tables, etc. that the MD part of the assembler will need.  */
end_comment

begin_function
name|void
name|md_begin
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|retval
init|=
name|NULL
decl_stmt|;
name|int
name|lose
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|skipnext
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|strend
decl_stmt|,
modifier|*
name|strend2
decl_stmt|;
comment|/* Hash up all the opcodes for fast use later.  */
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|op_hash
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
literal|"Virtual memory exhausted"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_opcodes
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|machine_opcodes
index|[
name|i
index|]
operator|.
name|name
decl_stmt|;
if|if
condition|(
name|skipnext
condition|)
block|{
name|skipnext
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Hack to avoid multiple opcode entries.  We pre-locate all the 		       variations (b/i field and P/A field) and handle them. */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|machine_opcodes
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|machine_opcodes
index|[
name|i
index|]
operator|.
name|opcode
operator|^
name|machine_opcodes
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|opcode
operator|)
operator|!=
literal|0x01000000
condition|)
goto|goto
name|bad_table
goto|;
name|strend
operator|=
name|machine_opcodes
index|[
name|i
index|]
operator|.
name|args
operator|+
name|strlen
argument_list|(
name|machine_opcodes
index|[
name|i
index|]
operator|.
name|args
argument_list|)
operator|-
literal|1
expr_stmt|;
name|strend2
operator|=
name|machine_opcodes
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|args
operator|+
name|strlen
argument_list|(
name|machine_opcodes
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|args
argument_list|)
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
operator|*
name|strend
condition|)
block|{
case|case
literal|'b'
case|:
if|if
condition|(
operator|*
name|strend2
operator|!=
literal|'i'
condition|)
goto|goto
name|bad_table
goto|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
operator|*
name|strend2
operator|!=
literal|'b'
condition|)
goto|goto
name|bad_table
goto|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
operator|*
name|strend2
operator|!=
literal|'A'
condition|)
goto|goto
name|bad_table
goto|;
break|break;
case|case
literal|'A'
case|:
if|if
condition|(
operator|*
name|strend2
operator|!=
literal|'P'
condition|)
goto|goto
name|bad_table
goto|;
break|break;
default|default:
name|bad_table
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"internal error: can't handle opcode %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|lose
operator|=
literal|1
expr_stmt|;
block|}
comment|/* OK, this is an i/b or A/P pair.  We skip the higher-valued one, 			       and let the code for operand checking handle OR-ing in the bit.  */
if|if
condition|(
name|machine_opcodes
index|[
name|i
index|]
operator|.
name|opcode
operator|&
literal|1
condition|)
continue|continue;
else|else
name|skipnext
operator|=
literal|1
expr_stmt|;
block|}
name|retval
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|name
argument_list|,
operator|&
name|machine_opcodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
operator|&&
operator|*
name|retval
operator|!=
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"internal error: can't hash `%s': %s\n"
argument_list|,
name|machine_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|lose
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lose
condition|)
name|as_fatal
argument_list|(
literal|"Broken assembler.  No assembly attempted."
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'0'
init|;
name|i
operator|<
literal|'8'
condition|;
operator|++
name|i
control|)
name|octal
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'0'
init|;
name|i
operator|<=
literal|'9'
condition|;
operator|++
name|i
control|)
name|toHex
index|[
name|i
index|]
operator|=
name|i
operator|-
literal|'0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'a'
init|;
name|i
operator|<=
literal|'f'
condition|;
operator|++
name|i
control|)
name|toHex
index|[
name|i
index|]
operator|=
name|i
operator|+
literal|10
operator|-
literal|'a'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'A'
init|;
name|i
operator|<=
literal|'F'
condition|;
operator|++
name|i
control|)
name|toHex
index|[
name|i
index|]
operator|=
name|i
operator|+
literal|10
operator|-
literal|'A'
expr_stmt|;
name|define_some_regs
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_end
parameter_list|()
block|{
return|return;
block|}
end_function

begin_comment
comment|/* Assemble a single instruction.  Its label has already been handled    by the generic front end.  We just parse opcode and operands, and    produce the bytes of data and relocation.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|toP
decl_stmt|;
comment|/* !!!!    int rsd; */
name|know
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|machine_ip
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|toP
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* put out the opcode */
name|md_number_to_chars
argument_list|(
name|toP
argument_list|,
name|the_insn
operator|.
name|opcode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* put out the symbol-dependent stuff */
if|if
condition|(
name|the_insn
operator|.
name|reloc
operator|!=
name|NO_RELOC
condition|)
block|{
name|fix_new
argument_list|(
name|frag_now
argument_list|,
comment|/* which frag */
operator|(
name|toP
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
name|the_insn
operator|.
name|reloc_offset
operator|)
argument_list|,
comment|/* where */
literal|4
argument_list|,
comment|/* size */
name|the_insn
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|the_insn
operator|.
name|exp
operator|.
name|X_subtract_symbol
argument_list|,
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
argument_list|,
name|the_insn
operator|.
name|pcrel
argument_list|,
name|the_insn
operator|.
name|reloc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|parse_operand
parameter_list|(
name|s
parameter_list|,
name|operandp
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|expressionS
modifier|*
name|operandp
decl_stmt|;
block|{
name|char
modifier|*
name|save
init|=
name|input_line_pointer
decl_stmt|;
name|char
modifier|*
name|new
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|input_line_pointer
operator|=
name|s
expr_stmt|;
name|seg
operator|=
name|expr
argument_list|(
literal|0
argument_list|,
name|operandp
argument_list|)
expr_stmt|;
name|new
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save
expr_stmt|;
switch|switch
condition|(
name|seg
condition|)
block|{
case|case
name|SEG_ABSOLUTE
case|:
case|case
name|SEG_TEXT
case|:
case|case
name|SEG_DATA
case|:
case|case
name|SEG_BSS
case|:
case|case
name|SEG_UNKNOWN
case|:
case|case
name|SEG_DIFFERENCE
case|:
case|case
name|SEG_BIG
case|:
case|case
name|SEG_REGISTER
case|:
return|return
name|new
return|;
case|case
name|SEG_ABSENT
case|:
name|as_bad
argument_list|(
literal|"Missing operand"
argument_list|)
expr_stmt|;
return|return
name|new
return|;
default|default:
name|as_bad
argument_list|(
literal|"Don't understand operand of type %s"
argument_list|,
name|segment_name
argument_list|(
name|seg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
block|}
end_function

begin_comment
comment|/* Instruction parsing.  Takes a string containing the opcode.    Operands are at input_line_pointer.  Output is in the_insn.    Warnings or errors are generated.  */
end_comment

begin_function
specifier|static
name|void
name|machine_ip
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
comment|/* !!!!    char c; */
comment|/* !!!!    unsigned long i; */
name|struct
name|machine_opcode
modifier|*
name|insn
decl_stmt|;
name|char
modifier|*
name|argsStart
decl_stmt|;
name|unsigned
name|long
name|opcode
decl_stmt|;
comment|/* !!!!    unsigned int mask; */
name|expressionS
name|the_operand
decl_stmt|;
name|expressionS
modifier|*
name|operand
init|=
operator|&
name|the_operand
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
comment|/* Must handle `div0' opcode.  */
name|s
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|s
argument_list|)
condition|)
for|for
control|(
init|;
name|isalnum
argument_list|(
operator|*
name|s
argument_list|)
condition|;
operator|++
name|s
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|s
argument_list|)
condition|)
operator|*
name|s
operator|=
name|tolower
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\0'
case|:
break|break;
case|case
literal|' '
case|:
comment|/* FIXME-SOMEDAY more whitespace */
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"Unknown opcode: `%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|insn
operator|=
operator|(
expr|struct
name|machine_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
literal|"Unknown opcode `%s'."
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|argsStart
operator|=
name|s
expr_stmt|;
name|opcode
operator|=
name|insn
operator|->
name|opcode
expr_stmt|;
name|memset
argument_list|(
operator|&
name|the_insn
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|the_insn
argument_list|)
argument_list|)
expr_stmt|;
name|the_insn
operator|.
name|reloc
operator|=
name|NO_RELOC
expr_stmt|;
comment|/* 	 * Build the opcode, checking as we go to make 	 * sure that the operands match. 	 * 	 * If an operand matches, we modify the_insn or opcode appropriately, 	 * and do a "continue".  If an operand fails to match, we "break". 	 */
if|if
condition|(
name|insn
operator|->
name|args
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|s
operator|=
name|parse_operand
argument_list|(
name|s
argument_list|,
name|operand
argument_list|)
expr_stmt|;
comment|/* Prime the pump */
for|for
control|(
name|args
operator|=
name|insn
operator|->
name|args
init|;
condition|;
operator|++
name|args
control|)
block|{
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
case|case
literal|'\0'
case|:
comment|/* end of args */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
comment|/* We are truly done. */
name|the_insn
operator|.
name|opcode
operator|=
name|opcode
expr_stmt|;
return|return;
block|}
name|as_bad
argument_list|(
literal|"Too many operands: %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|','
case|:
comment|/* Must match a comma */
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|','
condition|)
block|{
name|s
operator|=
name|parse_operand
argument_list|(
name|s
argument_list|,
name|operand
argument_list|)
expr_stmt|;
comment|/* Parse next opnd */
continue|continue;
block|}
break|break;
case|case
literal|'v'
case|:
comment|/* Trap numbers (immediate field) */
if|if
condition|(
name|operand
operator|->
name|X_seg
operator|==
name|SEG_ABSOLUTE
condition|)
block|{
if|if
condition|(
name|operand
operator|->
name|X_add_number
operator|<
literal|256
condition|)
block|{
name|opcode
operator||=
operator|(
name|operand
operator|->
name|X_add_number
operator|<<
literal|16
operator|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|"Immediate value of %d is too large"
argument_list|,
name|operand
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|the_insn
operator|.
name|reloc
operator|=
name|RELOC_8
expr_stmt|;
name|the_insn
operator|.
name|reloc_offset
operator|=
literal|1
expr_stmt|;
comment|/* BIG-ENDIAN Byte 1 of insn */
name|the_insn
operator|.
name|exp
operator|=
operator|*
name|operand
expr_stmt|;
continue|continue;
case|case
literal|'b'
case|:
comment|/* A general register or 8-bit immediate */
case|case
literal|'i'
case|:
comment|/* We treat the two cases identically since we mashed 			   them together in the opcode table.  */
if|if
condition|(
name|operand
operator|->
name|X_seg
operator|==
name|SEG_REGISTER
condition|)
goto|goto
name|general_reg
goto|;
name|opcode
operator||=
name|IMMEDIATE_BIT
expr_stmt|;
if|if
condition|(
name|operand
operator|->
name|X_seg
operator|==
name|SEG_ABSOLUTE
condition|)
block|{
if|if
condition|(
name|operand
operator|->
name|X_add_number
operator|<
literal|256
condition|)
block|{
name|opcode
operator||=
name|operand
operator|->
name|X_add_number
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|"Immediate value of %d is too large"
argument_list|,
name|operand
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|the_insn
operator|.
name|reloc
operator|=
name|RELOC_8
expr_stmt|;
name|the_insn
operator|.
name|reloc_offset
operator|=
literal|3
expr_stmt|;
comment|/* BIG-ENDIAN Byte 3 of insn */
name|the_insn
operator|.
name|exp
operator|=
operator|*
name|operand
expr_stmt|;
continue|continue;
case|case
literal|'a'
case|:
comment|/* next operand must be a register */
case|case
literal|'c'
case|:
name|general_reg
label|:
comment|/* lrNNN or grNNN or %%expr or a user-def register name */
if|if
condition|(
name|operand
operator|->
name|X_seg
operator|!=
name|SEG_REGISTER
condition|)
break|break;
comment|/* Only registers */
name|know
argument_list|(
name|operand
operator|->
name|X_add_symbol
operator|==
literal|0
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|operand
operator|->
name|X_subtract_symbol
operator|==
literal|0
argument_list|)
expr_stmt|;
name|reg
operator|=
name|operand
operator|->
name|X_add_number
expr_stmt|;
if|if
condition|(
name|reg
operator|>=
name|SREG
condition|)
break|break;
comment|/* No special registers */
comment|/* 			 * Got the register, now figure out where 			 * it goes in the opcode. 			 */
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
case|case
literal|'a'
case|:
name|opcode
operator||=
name|reg
operator|<<
literal|8
expr_stmt|;
continue|continue;
case|case
literal|'b'
case|:
case|case
literal|'i'
case|:
name|opcode
operator||=
name|reg
expr_stmt|;
continue|continue;
case|case
literal|'c'
case|:
name|opcode
operator||=
name|reg
operator|<<
literal|16
expr_stmt|;
continue|continue;
block|}
name|as_fatal
argument_list|(
literal|"failed sanity check."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* 16 bit constant, zero-extended */
case|case
literal|'X'
case|:
comment|/* 16 bit constant, one-extended */
if|if
condition|(
name|operand
operator|->
name|X_seg
operator|==
name|SEG_ABSOLUTE
condition|)
block|{
name|opcode
operator||=
operator|(
name|operand
operator|->
name|X_add_number
operator|&
literal|0xFF
operator|)
operator|<<
literal|0
operator||
operator|(
operator|(
name|operand
operator|->
name|X_add_number
operator|&
literal|0xFF00
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
continue|continue;
block|}
name|the_insn
operator|.
name|reloc
operator|=
name|RELOC_CONST
expr_stmt|;
name|the_insn
operator|.
name|exp
operator|=
operator|*
name|operand
expr_stmt|;
continue|continue;
case|case
literal|'h'
case|:
if|if
condition|(
name|operand
operator|->
name|X_seg
operator|==
name|SEG_ABSOLUTE
condition|)
block|{
name|opcode
operator||=
operator|(
name|operand
operator|->
name|X_add_number
operator|&
literal|0x00FF0000
operator|)
operator|>>
literal|16
operator||
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|operand
operator|->
name|X_add_number
comment|/* avoid sign ext */
operator|&
literal|0xFF000000
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
continue|continue;
block|}
name|the_insn
operator|.
name|reloc
operator|=
name|RELOC_CONSTH
expr_stmt|;
name|the_insn
operator|.
name|exp
operator|=
operator|*
name|operand
expr_stmt|;
continue|continue;
case|case
literal|'P'
case|:
comment|/* PC-relative jump address */
case|case
literal|'A'
case|:
comment|/* Absolute jump address */
comment|/* These two are treated together since we folded the 			   opcode table entries together.  */
if|if
condition|(
name|operand
operator|->
name|X_seg
operator|==
name|SEG_ABSOLUTE
condition|)
block|{
name|opcode
operator||=
name|ABSOLUTE_BIT
operator||
operator|(
name|operand
operator|->
name|X_add_number
operator|&
literal|0x0003FC00
operator|)
operator|<<
literal|6
operator||
operator|(
operator|(
name|operand
operator|->
name|X_add_number
operator|&
literal|0x000003FC
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
continue|continue;
block|}
name|the_insn
operator|.
name|reloc
operator|=
name|RELOC_JUMPTARG
expr_stmt|;
name|the_insn
operator|.
name|exp
operator|=
operator|*
name|operand
expr_stmt|;
name|the_insn
operator|.
name|pcrel
operator|=
literal|1
expr_stmt|;
comment|/* Assume PC-relative jump */
comment|/* FIXME-SOON, Do we figure out whether abs later, after know sym val? */
continue|continue;
case|case
literal|'e'
case|:
comment|/* Coprocessor enable bit for LOAD/STORE insn */
if|if
condition|(
name|operand
operator|->
name|X_seg
operator|==
name|SEG_ABSOLUTE
condition|)
block|{
if|if
condition|(
name|operand
operator|->
name|X_add_number
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|operand
operator|->
name|X_add_number
operator|==
literal|1
condition|)
block|{
name|opcode
operator||=
name|CE_BIT
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
case|case
literal|'n'
case|:
comment|/* Control bits for LOAD/STORE instructions */
if|if
condition|(
name|operand
operator|->
name|X_seg
operator|==
name|SEG_ABSOLUTE
operator|&&
name|operand
operator|->
name|X_add_number
operator|<
literal|128
condition|)
block|{
name|opcode
operator||=
operator|(
name|operand
operator|->
name|X_add_number
operator|<<
literal|16
operator|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'s'
case|:
comment|/* Special register number */
if|if
condition|(
name|operand
operator|->
name|X_seg
operator|!=
name|SEG_REGISTER
condition|)
break|break;
comment|/* Only registers */
if|if
condition|(
name|operand
operator|->
name|X_add_number
operator|<
name|SREG
condition|)
break|break;
comment|/* Not a special register */
name|opcode
operator||=
operator|(
name|operand
operator|->
name|X_add_number
operator|&
literal|0xFF
operator|)
operator|<<
literal|8
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
comment|/* UI bit of CONVERT */
if|if
condition|(
name|operand
operator|->
name|X_seg
operator|==
name|SEG_ABSOLUTE
condition|)
block|{
if|if
condition|(
name|operand
operator|->
name|X_add_number
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|operand
operator|->
name|X_add_number
operator|==
literal|1
condition|)
block|{
name|opcode
operator||=
name|UI_BIT
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
case|case
literal|'r'
case|:
comment|/* RND bits of CONVERT */
if|if
condition|(
name|operand
operator|->
name|X_seg
operator|==
name|SEG_ABSOLUTE
operator|&&
name|operand
operator|->
name|X_add_number
operator|<
literal|8
condition|)
block|{
name|opcode
operator||=
name|operand
operator|->
name|X_add_number
operator|<<
literal|4
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'d'
case|:
comment|/* FD bits of CONVERT */
if|if
condition|(
name|operand
operator|->
name|X_seg
operator|==
name|SEG_ABSOLUTE
operator|&&
name|operand
operator|->
name|X_add_number
operator|<
literal|4
condition|)
block|{
name|opcode
operator||=
name|operand
operator|->
name|X_add_number
operator|<<
literal|2
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'f'
case|:
comment|/* FS bits of CONVERT */
if|if
condition|(
name|operand
operator|->
name|X_seg
operator|==
name|SEG_ABSOLUTE
operator|&&
name|operand
operator|->
name|X_add_number
operator|<
literal|4
condition|)
block|{
name|opcode
operator||=
name|operand
operator|->
name|X_add_number
operator|<<
literal|0
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|operand
operator|->
name|X_seg
operator|==
name|SEG_ABSOLUTE
operator|&&
name|operand
operator|->
name|X_add_number
operator|<
literal|4
condition|)
block|{
name|opcode
operator||=
name|operand
operator|->
name|X_add_number
operator|<<
literal|16
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
name|operand
operator|->
name|X_seg
operator|==
name|SEG_ABSOLUTE
operator|&&
name|operand
operator|->
name|X_add_number
operator|<
literal|16
condition|)
block|{
name|opcode
operator||=
name|operand
operator|->
name|X_add_number
operator|<<
literal|18
expr_stmt|;
continue|continue;
block|}
break|break;
default|default:
name|BAD_CASE
argument_list|(
operator|*
name|args
argument_list|)
expr_stmt|;
block|}
comment|/* Types or values of args don't match.  */
name|as_bad
argument_list|(
literal|"Invalid operands"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*   This is identical to the md_atof in m68k.c.  I think this is right,   but I'm not sure.    Turn a string in input_line_pointer into a floating point constant of type   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS   emitted is stored in *sizeP. An error message is returned, or NULL on OK.   */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
literal|"Bad call to MD_ATOF()"
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|wordP
operator|=
name|words
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|wordP
operator|++
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
comment|/* Someone should teach Dean about null pointers */
block|}
end_function

begin_comment
comment|/*  * Write out big-endian.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|4
case|:
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
case|case
literal|2
case|:
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
case|case
literal|1
case|:
operator|*
name|buf
operator|=
name|val
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"failed sanity check."
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixP
parameter_list|,
name|val
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|long
name|val
decl_stmt|;
block|{
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|fixP
operator|->
name|fx_addnumber
operator|=
name|val
expr_stmt|;
comment|/* Remember value for emit_reloc */
name|know
argument_list|(
name|fixP
operator|->
name|fx_size
operator|==
literal|4
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|fixP
operator|->
name|fx_r_type
operator|<
name|NO_RELOC
argument_list|)
expr_stmt|;
comment|/* 	 * This is a hack.  There should be a better way to 	 * handle this. 	 */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|RELOC_WDISP30
operator|&&
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|val
operator|+=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
expr_stmt|;
block|}
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|RELOC_32
case|:
name|buf
index|[
literal|0
index|]
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_8
case|:
name|buf
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_WDISP30
case|:
name|val
operator|=
operator|(
name|val
operator|>>=
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator||=
operator|(
name|val
operator|>>
literal|24
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_HI22
case|:
name|buf
index|[
literal|1
index|]
operator||=
operator|(
name|val
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|18
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
operator|>>
literal|10
expr_stmt|;
break|break;
case|case
name|RELOC_LO10
case|:
name|buf
index|[
literal|2
index|]
operator||=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0x03
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_BASE13
case|:
name|buf
index|[
literal|2
index|]
operator||=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_WDISP22
case|:
name|val
operator|=
operator|(
name|val
operator|>>=
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|RELOC_BASE22
case|:
name|buf
index|[
literal|1
index|]
operator||=
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case RELOC_PC10: 	case RELOC_PC22: 	case RELOC_JMP_TBL: 	case RELOC_SEGOFF16: 	case RELOC_GLOB_DAT: 	case RELOC_JMP_SLOT: 	case RELOC_RELATIVE:
endif|#
directive|endif
case|case
name|RELOC_JUMPTARG
case|:
comment|/* 00XX00XX pattern in a word */
name|buf
index|[
literal|1
index|]
operator|=
name|val
operator|>>
literal|10
expr_stmt|;
comment|/* Holds bits 0003FFFC of address */
name|buf
index|[
literal|3
index|]
operator|=
name|val
operator|>>
literal|2
expr_stmt|;
break|break;
case|case
name|RELOC_CONST
case|:
comment|/* 00XX00XX pattern in a word */
name|buf
index|[
literal|1
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
comment|/* Holds bits 0000XXXX */
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_CONSTH
case|:
comment|/* 00XX00XX pattern in a word */
name|buf
index|[
literal|1
index|]
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
comment|/* Holds bits XXXX0000 */
name|buf
index|[
literal|3
index|]
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
break|break;
case|case
name|NO_RELOC
case|:
default|default:
name|as_bad
argument_list|(
literal|"bad relocation type: 0x%02x"
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_COFF
end_ifdef

begin_function
name|short
name|tc_coff_fix2rtype
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
comment|/* FIXME-NOW: relocation type handling is not yet written for 	   a29k. */
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|RELOC_32
case|:
return|return
operator|(
name|R_WORD
operator|)
return|;
case|case
name|RELOC_8
case|:
return|return
operator|(
name|R_BYTE
operator|)
return|;
case|case
name|RELOC_CONST
case|:
return|return
operator|(
name|R_ILOHALF
operator|)
return|;
case|case
name|RELOC_CONSTH
case|:
return|return
operator|(
name|R_IHIHALF
operator|)
return|;
case|case
name|RELOC_JUMPTARG
case|:
return|return
operator|(
name|R_IREL
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"need %o3\n"
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
name|abort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* switch on type */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* tc_coff_fix2rtype() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_COFF */
end_comment

begin_comment
comment|/* should never be called for sparc */
end_comment

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|long
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|as_fatal
argument_list|(
literal|"a29k_create_short_jmp\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* should never be called for 29k */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|headers
parameter_list|,
name|fragP
parameter_list|)
name|object_headers
modifier|*
name|headers
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|as_fatal
argument_list|(
literal|"sparc_convert_frag\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* should never be called for 29k */
end_comment

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|long
name|from_addr
decl_stmt|;
name|long
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|as_fatal
argument_list|(
literal|"sparc_create_long_jump\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* should never be called for a29k */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segtype
parameter_list|)
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|segT
name|segtype
decl_stmt|;
block|{
name|as_fatal
argument_list|(
literal|"sparc_estimate_size_before_relax\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* for debugging only */
end_comment

begin_endif
unit|static void     print_insn(insn) struct machine_it *insn; { 	char *Reloc[] = { 		"RELOC_8", 		"RELOC_16", 		"RELOC_32", 		"RELOC_DISP8", 		"RELOC_DISP16", 		"RELOC_DISP32", 		"RELOC_WDISP30", 		"RELOC_WDISP22", 		"RELOC_HI22", 		"RELOC_22", 		"RELOC_13", 		"RELOC_LO10", 		"RELOC_SFA_BASE", 		"RELOC_SFA_OFF13", 		"RELOC_BASE10", 		"RELOC_BASE13", 		"RELOC_BASE22", 		"RELOC_PC10", 		"RELOC_PC22", 		"RELOC_JMP_TBL", 		"RELOC_SEGOFF16", 		"RELOC_GLOB_DAT", 		"RELOC_JMP_SLOT", 		"RELOC_RELATIVE", 		"NO_RELOC" 	    };  	if (insn->error) { 		fprintf(stderr, "ERROR: %s\n"); 	} 	fprintf(stderr, "opcode=0x%08x\n", insn->opcode); 	fprintf(stderr, "reloc = %s\n", Reloc[insn->reloc]); 	fprintf(stderr, "exp =  {\n"); 	fprintf(stderr, "\t\tX_add_symbol = %s\n", 		insn->exp.X_add_symbol ? 		(S_GET_NAME(insn->exp.X_add_symbol) ? 		 S_GET_NAME(insn->exp.X_add_symbol) : "???") : "0"); 	fprintf(stderr, "\t\tX_sub_symbol = %s\n", 		insn->exp.X_subtract_symbol ? 		(S_GET_NAME(insn->exp.X_subtract_symbol) ? 		 S_GET_NAME(insn->exp.X_subtract_symbol) : "???") : "0"); 	fprintf(stderr, "\t\tX_add_number = %d\n", 		insn->exp.X_add_number); 	fprintf(stderr, "}\n"); 	return; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Translate internal representation of relocation info to target format.     On sparc/29k: first 4 bytes are normal unsigned long address, next three    bytes are index, most sig. byte first.  Byte 7 is broken up with    bit 7 as external, bits 6& 5 unused, and the lower    five bits as relocation type.  Next 4 bytes are long addend. */
end_comment

begin_comment
comment|/* Thanx and a tip of the hat to Michael Bloom, mb@ttidca.tti.com */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_AOUT
end_ifdef

begin_function
name|void
name|tc_aout_fix_to_chars
parameter_list|(
name|where
parameter_list|,
name|fixP
parameter_list|,
name|segment_address_in_file
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|relax_addressT
name|segment_address_in_file
decl_stmt|;
block|{
name|long
name|r_symbolnum
decl_stmt|;
name|know
argument_list|(
name|fixP
operator|->
name|fx_r_type
operator|<
name|NO_RELOC
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|segment_address_in_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|r_symbolnum
operator|=
operator|(
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|?
name|S_GET_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
else|:
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_number
operator|)
expr_stmt|;
name|where
index|[
literal|4
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|16
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|5
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|8
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|6
index|]
operator|=
name|r_symbolnum
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|7
index|]
operator|=
operator|(
operator|(
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|)
operator|<<
literal|7
operator|)
operator|&
literal|0x80
operator|)
operator||
operator|(
literal|0
operator|&
literal|0x60
operator|)
operator||
operator|(
name|fixP
operator|->
name|fx_r_type
operator|&
literal|0x1F
operator|)
expr_stmt|;
comment|/* Also easy */
name|md_number_to_chars
argument_list|(
operator|&
name|where
index|[
literal|8
index|]
argument_list|,
name|fixP
operator|->
name|fx_addnumber
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tc_aout_fix_to_chars() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_AOUT */
end_comment

begin_function
name|int
name|md_parse_option
parameter_list|(
name|argP
parameter_list|,
name|cntP
parameter_list|,
name|vecP
parameter_list|)
name|char
modifier|*
modifier|*
name|argP
decl_stmt|;
name|int
modifier|*
name|cntP
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|vecP
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Default the values of symbols known that should be "predefined".  We    don't bother to predefine them unless you actually use one, since there    are a lot of them.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|long
name|regnum
decl_stmt|;
name|char
name|testbuf
index|[
literal|5
operator|+
comment|/*SLOP*/
literal|5
index|]
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'g'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'G'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'l'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'L'
condition|)
block|{
comment|/* Perhaps a global or local register name */
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'r'
operator|||
name|name
index|[
literal|1
index|]
operator|==
literal|'R'
condition|)
block|{
comment|/* Parse the number, make sure it has no extra zeroes or trailing 				   chars */
name|regnum
operator|=
name|atol
argument_list|(
operator|&
name|name
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|>
literal|127
condition|)
return|return
literal|0
return|;
name|sprintf
argument_list|(
name|testbuf
argument_list|,
literal|"%ld"
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|testbuf
argument_list|,
operator|&
name|name
index|[
literal|2
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* gr007 or lr7foo or whatever */
comment|/* We have a wiener!  Define and return a new symbol for it.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'l'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'L'
condition|)
name|regnum
operator|+=
literal|128
expr_stmt|;
return|return
operator|(
name|symbol_new
argument_list|(
name|name
argument_list|,
name|SEG_REGISTER
argument_list|,
name|regnum
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
operator|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Parse an operand that is machine-specific.  */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|input_line_pointer
index|[
literal|1
index|]
operator|==
literal|'%'
condition|)
block|{
comment|/* We have a numeric register expression.  No biggy.  */
name|input_line_pointer
operator|+=
literal|2
expr_stmt|;
comment|/* Skip %% */
operator|(
name|void
operator|)
name|expression
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
if|if
condition|(
name|expressionP
operator|->
name|X_seg
operator|!=
name|SEG_ABSOLUTE
operator|||
name|expressionP
operator|->
name|X_add_number
operator|>
literal|255
condition|)
name|as_bad
argument_list|(
literal|"Invalid expression after %%%%\n"
argument_list|)
expr_stmt|;
name|expressionP
operator|->
name|X_seg
operator|=
name|SEG_REGISTER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|input_line_pointer
index|[
literal|0
index|]
operator|==
literal|'&'
condition|)
block|{
comment|/* We are taking the 'address' of a register...this one is not 		       in the manual, but it *is* in traps/fpsymbol.h!  What they 		       seem to want is the register number, as an absolute number.  */
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* Skip& */
operator|(
name|void
operator|)
name|expression
argument_list|(
name|expressionP
argument_list|)
expr_stmt|;
if|if
condition|(
name|expressionP
operator|->
name|X_seg
operator|!=
name|SEG_REGISTER
condition|)
name|as_bad
argument_list|(
literal|"Invalid register in& expression"
argument_list|)
expr_stmt|;
else|else
name|expressionP
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|long
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
return|return
name|size
return|;
comment|/* Byte alignment is fine */
block|}
end_function

begin_comment
comment|/* Exactly what point is a PC-relative offset relative TO?    On the 29000, they're relative to the address of the instruction,    which we have set up as the address of the fixup too.  */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
return|return
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * comment-column: 0  * End:  */
end_comment

begin_comment
comment|/* end of tc-a29k.c */
end_comment

end_unit

