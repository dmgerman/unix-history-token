begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)i386.c	6.4 (Berkeley) 5/8/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* i386.c -- Assemble code for the Intel 80386    Copyright (C) 1989, Free Software Foundation.  This file is part of GAS, the GNU Assembler.  GAS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GAS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GAS; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*   Intel 80386 machine specific gas.   Written by Eliot Dresselhaus (eliot@mgm.mit.edu).   Bugs& suggestions are completely welcome.  This is free software.   Please help us make it better. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|alloca
value|__builtin_alloca
end_define

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|extern
name|char
modifier|*
name|alloca
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_define
define|#
directive|define
name|index
value|strchr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"read.h"
end_include

begin_include
include|#
directive|include
file|"flonum.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"frags.h"
end_include

begin_include
include|#
directive|include
file|"struc-symbol.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"symbols.h"
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"md.h"
end_include

begin_include
include|#
directive|include
file|"i386.h"
end_include

begin_include
include|#
directive|include
file|"i386-opcode.h"
end_include

begin_decl_stmt
name|long
name|omagic
init|=
name|OMAGIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|FLT_CHARS
index|[]
init|=
literal|"fFdDxX"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tables for lexical analysis */
end_comment

begin_decl_stmt
specifier|static
name|char
name|opcode_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|register_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|operand_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|space_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|identifier_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|digit_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lexical macros */
end_comment

begin_define
define|#
directive|define
name|is_opcode_char
parameter_list|(
name|x
parameter_list|)
value|(opcode_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_operand_char
parameter_list|(
name|x
parameter_list|)
value|(operand_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_register_char
parameter_list|(
name|x
parameter_list|)
value|(register_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_space_char
parameter_list|(
name|x
parameter_list|)
value|(space_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_identifier_char
parameter_list|(
name|x
parameter_list|)
value|(identifier_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_digit_char
parameter_list|(
name|x
parameter_list|)
value|(digit_chars[(unsigned char) x])
end_define

begin_comment
comment|/* put here all non-digit non-letter charcters that may occur in an operand */
end_comment

begin_decl_stmt
specifier|static
name|char
name|operand_special_chars
index|[]
init|=
literal|"%$-+(,)*._~/<>|&^!:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ordinal_names
index|[]
init|=
block|{
literal|"first"
block|,
literal|"second"
block|,
literal|"third"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for printfs */
end_comment

begin_comment
comment|/* md_assemble() always leaves the strings it's passed unaltered.  To    effect this we maintain a stack of saved characters that we've smashed    with '\0's (indicating end of strings for various sub-fields of the    assembler instruction). */
end_comment

begin_decl_stmt
specifier|static
name|char
name|save_stack
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|save_stack_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stack pointer */
end_comment

begin_define
define|#
directive|define
name|END_STRING_AND_SAVE
parameter_list|(
name|s
parameter_list|)
value|*save_stack_p++ = *s; *s = '\0'
end_define

begin_define
define|#
directive|define
name|RESTORE_END_STRING
parameter_list|(
name|s
parameter_list|)
value|*s = *--save_stack_p
end_define

begin_comment
comment|/* The instruction we're assembling. */
end_comment

begin_decl_stmt
specifier|static
name|i386_insn
name|i
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Per instruction expressionS buffers: 2 displacements& 2 immediate max. */
end_comment

begin_decl_stmt
specifier|static
name|expressionS
name|disp_expressions
index|[
literal|2
index|]
decl_stmt|,
name|im_expressions
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers to ebp& esp entries in reg_hash hash table */
end_comment

begin_decl_stmt
specifier|static
name|reg_entry
modifier|*
name|ebp
decl_stmt|,
modifier|*
name|esp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|this_operand
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current operand we are working on */
end_comment

begin_comment
comment|/* Interface to relax_segment. There are 2 relax states for 386 jump insns: one for conditional& one for unconditional jumps.  This is because the these two types of jumps add different sizes to frags when we're figuring out what sort of jump to choose to reach a given label.  */
end_comment

begin_comment
comment|/* types */
end_comment

begin_define
define|#
directive|define
name|COND_JUMP
value|1
end_define

begin_comment
comment|/* conditional jump */
end_comment

begin_define
define|#
directive|define
name|UNCOND_JUMP
value|2
end_define

begin_comment
comment|/* unconditional jump */
end_comment

begin_comment
comment|/* sizes */
end_comment

begin_define
define|#
directive|define
name|BYTE
value|0
end_define

begin_define
define|#
directive|define
name|WORD
value|1
end_define

begin_define
define|#
directive|define
name|DWORD
value|2
end_define

begin_define
define|#
directive|define
name|UNKNOWN_SIZE
value|3
end_define

begin_define
define|#
directive|define
name|ENCODE_RELAX_STATE
parameter_list|(
name|type
parameter_list|,
name|size
parameter_list|)
value|((type<<2) | (size))
end_define

begin_define
define|#
directive|define
name|SIZE_FROM_RELAX_STATE
parameter_list|(
name|s
parameter_list|)
define|\
value|( (((s)& 0x3) == BYTE ? 1 : (((s)& 0x3) == WORD ? 2 : 4)) )
end_define

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
comment|/*   The fields are:    1) most positive reach of this state,    2) most negative reach of this state,    3) how many bytes this mode will add to the size of the current frag    4) which index into the table to try if we can't fit into this one. */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* For now we don't use word displacement jumps:  they may be      untrustworthy. */
block|{
literal|127
operator|+
literal|1
block|,
operator|-
literal|128
operator|+
literal|1
block|,
literal|0
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|COND_JUMP
argument_list|,
argument|DWORD
argument_list|)
block|}
block|,
comment|/* word conditionals add 3 bytes to frag:          2 opcode prefix; 1 displacement bytes */
block|{
literal|32767
operator|+
literal|2
block|,
operator|-
literal|32768
operator|+
literal|2
block|,
literal|3
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|COND_JUMP
argument_list|,
argument|DWORD
argument_list|)
block|}
block|,
comment|/* dword conditionals adds 4 bytes to frag:          1 opcode prefix; 3 displacement bytes */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|127
operator|+
literal|1
block|,
operator|-
literal|128
operator|+
literal|1
block|,
literal|0
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|UNCOND_JUMP
argument_list|,
argument|DWORD
argument_list|)
block|}
block|,
comment|/* word jmp adds 2 bytes to frag:          1 opcode prefix; 1 displacement bytes */
block|{
literal|32767
operator|+
literal|2
block|,
operator|-
literal|32768
operator|+
literal|2
block|,
literal|2
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|UNCOND_JUMP
argument_list|,
argument|DWORD
argument_list|)
block|}
block|,
comment|/* dword jmp adds 3 bytes to frag:          0 opcode prefix; 3 displacement bytes */
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,  }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|float_cons
argument_list|()
decl_stmt|,
name|cons
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ignore certain directives generated by gcc. This probably should    not be here. */
end_comment

begin_function
name|void
name|dummy
parameter_list|()
block|{
while|while
condition|(
operator|*
name|input_line_pointer
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|'\n'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"ffloat"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"dfloat"
block|,
name|float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"tfloat"
block|,
name|float_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"value"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"ident"
block|,
name|dummy
block|,
literal|0
block|}
block|,
comment|/* ignore these directives */
block|{
literal|"def"
block|,
name|dummy
block|,
literal|0
block|}
block|,
block|{
literal|"optim"
block|,
name|dummy
block|,
literal|0
block|}
block|,
comment|/* For sun386i cc */
block|{
literal|"version"
block|,
name|dummy
block|,
literal|0
block|}
block|,
block|{
literal|"ln"
block|,
name|dummy
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for interface with expression () */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|input_line_pointer
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|output_invalid
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|reg_entry
modifier|*
name|parse_register
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* obstack for constructing various things in md_begin */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|o
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash table for opcode lookup */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
init|=
operator|(
expr|struct
name|hash_control
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash table for register lookup */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|reg_hash
init|=
operator|(
expr|struct
name|hash_control
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash table for prefix lookup */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|prefix_hash
init|=
operator|(
expr|struct
name|hash_control
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|md_begin
parameter_list|()
block|{
name|char
modifier|*
name|hash_err
decl_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|o
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
comment|/* initialize op_hash hash table */
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* xmalloc handles error */
block|{
specifier|register
name|template
modifier|*
name|optab
decl_stmt|;
specifier|register
name|templates
modifier|*
name|core_optab
decl_stmt|;
name|char
modifier|*
name|prev_name
decl_stmt|;
name|optab
operator|=
name|i386_optab
expr_stmt|;
comment|/* setup for loop */
name|prev_name
operator|=
name|optab
operator|->
name|name
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|o
argument_list|,
name|optab
argument_list|,
sizeof|sizeof
argument_list|(
name|template
argument_list|)
argument_list|)
expr_stmt|;
name|core_optab
operator|=
operator|(
name|templates
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|templates
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|optab
operator|++
init|;
name|optab
operator|<
name|i386_optab_end
condition|;
name|optab
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|optab
operator|->
name|name
argument_list|,
name|prev_name
argument_list|)
condition|)
block|{
comment|/* same name as before --> append to current template list */
name|obstack_grow
argument_list|(
operator|&
name|o
argument_list|,
name|optab
argument_list|,
sizeof|sizeof
argument_list|(
name|template
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* different name --> ship out current template list; 	   add to hash table;& begin anew */
comment|/* Note: end must be set before start! since obstack_next_free changes 	   upon opstack_finish */
name|core_optab
operator|->
name|end
operator|=
operator|(
name|template
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|o
argument_list|)
expr_stmt|;
name|core_optab
operator|->
name|start
operator|=
operator|(
name|template
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|o
argument_list|)
expr_stmt|;
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|prev_name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|core_optab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
operator|&&
operator|*
name|hash_err
condition|)
block|{
name|hash_error
label|:
name|as_fatal
argument_list|(
literal|"Internal Error:  Can't hash %s: %s"
argument_list|,
name|prev_name
argument_list|,
name|hash_err
argument_list|)
expr_stmt|;
block|}
name|prev_name
operator|=
name|optab
operator|->
name|name
expr_stmt|;
name|core_optab
operator|=
operator|(
name|templates
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|templates
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|o
argument_list|,
name|optab
argument_list|,
sizeof|sizeof
argument_list|(
name|template
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* initialize reg_hash hash table */
name|reg_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
block|{
specifier|register
name|reg_entry
modifier|*
name|regtab
decl_stmt|;
for|for
control|(
name|regtab
operator|=
name|i386_regtab
init|;
name|regtab
operator|<
name|i386_regtab_end
condition|;
name|regtab
operator|++
control|)
block|{
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|reg_hash
argument_list|,
name|regtab
operator|->
name|reg_name
argument_list|,
name|regtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
operator|&&
operator|*
name|hash_err
condition|)
goto|goto
name|hash_error
goto|;
block|}
block|}
name|esp
operator|=
operator|(
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
literal|"esp"
argument_list|)
expr_stmt|;
name|ebp
operator|=
operator|(
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
literal|"ebp"
argument_list|)
expr_stmt|;
comment|/* initialize reg_hash hash table */
name|prefix_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
block|{
specifier|register
name|prefix_entry
modifier|*
name|prefixtab
decl_stmt|;
for|for
control|(
name|prefixtab
operator|=
name|i386_prefixtab
init|;
name|prefixtab
operator|<
name|i386_prefixtab_end
condition|;
name|prefixtab
operator|++
control|)
block|{
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|prefix_hash
argument_list|,
name|prefixtab
operator|->
name|prefix_name
argument_list|,
name|prefixtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
operator|&&
operator|*
name|hash_err
condition|)
goto|goto
name|hash_error
goto|;
block|}
block|}
comment|/* fill in lexical tables:  opcode_chars, operand_chars, space_chars */
block|{
specifier|register
name|unsigned
name|int
name|c
decl_stmt|;
name|bzero
argument_list|(
name|opcode_chars
argument_list|,
sizeof|sizeof
argument_list|(
name|opcode_chars
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|operand_chars
argument_list|,
sizeof|sizeof
argument_list|(
name|operand_chars
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|space_chars
argument_list|,
sizeof|sizeof
argument_list|(
name|space_chars
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|identifier_chars
argument_list|,
sizeof|sizeof
argument_list|(
name|identifier_chars
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|digit_chars
argument_list|,
sizeof|sizeof
argument_list|(
name|digit_chars
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|256
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
operator|||
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|opcode_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|register_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|opcode_chars
index|[
name|c
index|]
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|register_chars
index|[
name|c
index|]
operator|=
name|opcode_chars
index|[
name|c
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|PREFIX_SEPERATOR
condition|)
block|{
name|opcode_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
operator|||
name|c
operator|==
literal|'('
condition|)
block|{
name|register_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
operator|||
name|islower
argument_list|(
name|c
argument_list|)
operator|||
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|operand_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|&&
name|index
argument_list|(
name|operand_special_chars
argument_list|,
name|c
argument_list|)
condition|)
name|operand_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'-'
condition|)
name|digit_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|identifier_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|space_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|md_end
parameter_list|()
block|{}
end_function

begin_comment
comment|/* not much to do here. */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG386
end_ifdef

begin_comment
comment|/* debugging routines for md_assemble */
end_comment

begin_decl_stmt
specifier|static
name|void
name|pi
argument_list|()
decl_stmt|,
name|pte
argument_list|()
decl_stmt|,
name|pt
argument_list|()
decl_stmt|,
name|pe
argument_list|()
decl_stmt|,
name|ps
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|pi
parameter_list|(
name|line
parameter_list|,
name|x
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|i386_insn
modifier|*
name|x
decl_stmt|;
block|{
specifier|register
name|template
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s: template "
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|pte
argument_list|(
operator|&
name|x
operator|->
name|tm
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  modrm:  mode %x  reg %x  reg/mem %x"
argument_list|,
name|x
operator|->
name|rm
operator|.
name|mode
argument_list|,
name|x
operator|->
name|rm
operator|.
name|reg
argument_list|,
name|x
operator|->
name|rm
operator|.
name|regmem
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" base %x  index %x  scale %x\n"
argument_list|,
name|x
operator|->
name|bi
operator|.
name|base
argument_list|,
name|x
operator|->
name|bi
operator|.
name|index
argument_list|,
name|x
operator|->
name|bi
operator|.
name|scale
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|x
operator|->
name|operands
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    #%d:  "
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pt
argument_list|(
name|x
operator|->
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|types
index|[
name|i
index|]
operator|&
name|Reg
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s\n"
argument_list|,
name|x
operator|->
name|regs
index|[
name|i
index|]
operator|->
name|reg_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|types
index|[
name|i
index|]
operator|&
name|Imm
condition|)
name|pe
argument_list|(
name|x
operator|->
name|imms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|types
index|[
name|i
index|]
operator|&
operator|(
name|Disp
operator||
name|Abs
operator|)
condition|)
name|pe
argument_list|(
name|x
operator|->
name|disps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pte
parameter_list|(
name|t
parameter_list|)
name|template
modifier|*
name|t
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" %d operands "
argument_list|,
name|t
operator|->
name|operands
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"opcode %x "
argument_list|,
name|t
operator|->
name|base_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|extension_opcode
operator|!=
name|None
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"ext %x "
argument_list|,
name|t
operator|->
name|extension_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|D
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"D"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|W
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"W"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|operands
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    #%d type "
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pt
argument_list|(
name|t
operator|->
name|operand_types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|char
modifier|*
name|seg_names
index|[]
init|=
block|{
literal|"SEG_ABSOLUTE"
block|,
literal|"SEG_TEXT"
block|,
literal|"SEG_DATA"
block|,
literal|"SEG_BSS"
block|,
literal|"SEG_UNKNOWN"
block|,
literal|"SEG_NONE"
block|,
literal|"SEG_PASS1"
block|,
literal|"SEG_GOOF"
block|,
literal|"SEG_BIG"
block|,
literal|"SEG_DIFFERENCE"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|pe
parameter_list|(
name|e
parameter_list|)
name|expressionS
modifier|*
name|e
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    segment       %s\n"
argument_list|,
name|seg_names
index|[
operator|(
name|int
operator|)
name|e
operator|->
name|X_seg
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    add_number    %d (%x)\n"
argument_list|,
name|e
operator|->
name|X_add_number
argument_list|,
name|e
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_add_symbol
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    add_symbol    "
argument_list|)
expr_stmt|;
name|ps
argument_list|(
name|e
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|X_subtract_symbol
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    sub_symbol    "
argument_list|)
expr_stmt|;
name|ps
argument_list|(
name|e
operator|->
name|X_subtract_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|SYMBOL_TYPE
parameter_list|(
name|t
parameter_list|)
define|\
value|(((t&N_TYPE) == N_UNDF) ? "UNDEFINED" : \    (((t&N_TYPE) == N_ABS) ? "ABSOLUTE" : \     (((t&N_TYPE) == N_TEXT) ? "TEXT" : \      (((t&N_TYPE) == N_DATA) ? "DATA" : \       (((t&N_TYPE) == N_BSS) ? "BSS" : "Bad n_type!")))))
end_define

begin_function
specifier|static
name|void
name|ps
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s type %s%s"
argument_list|,
name|s
operator|->
name|sy_nlist
operator|.
name|n_un
operator|.
name|n_name
argument_list|,
operator|(
name|s
operator|->
name|sy_nlist
operator|.
name|n_type
operator|&
name|N_EXT
operator|)
condition|?
literal|"EXTERNAL "
else|:
literal|""
argument_list|,
name|SYMBOL_TYPE
argument_list|(
name|s
operator|->
name|sy_nlist
operator|.
name|n_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|type_name
block|{
name|uint
name|mask
decl_stmt|;
name|char
modifier|*
name|tname
decl_stmt|;
block|}
name|type_names
index|[]
init|=
block|{
block|{
name|Reg8
block|,
literal|"r8"
block|}
block|,
block|{
name|Reg16
block|,
literal|"r16"
block|}
block|,
block|{
name|Reg32
block|,
literal|"r32"
block|}
block|,
block|{
name|Imm8
block|,
literal|"i8"
block|}
block|,
block|{
name|Imm8S
block|,
literal|"i8s"
block|}
block|,
block|{
name|Imm16
block|,
literal|"i16"
block|}
block|,
block|{
name|Imm32
block|,
literal|"i32"
block|}
block|,
block|{
name|Mem8
block|,
literal|"Mem8"
block|}
block|,
block|{
name|Mem16
block|,
literal|"Mem16"
block|}
block|,
block|{
name|Mem32
block|,
literal|"Mem32"
block|}
block|,
block|{
name|BaseIndex
block|,
literal|"BaseIndex"
block|}
block|,
block|{
name|Abs8
block|,
literal|"Abs8"
block|}
block|,
block|{
name|Abs16
block|,
literal|"Abs16"
block|}
block|,
block|{
name|Abs32
block|,
literal|"Abs32"
block|}
block|,
block|{
name|Disp8
block|,
literal|"d8"
block|}
block|,
block|{
name|Disp16
block|,
literal|"d16"
block|}
block|,
block|{
name|Disp32
block|,
literal|"d32"
block|}
block|,
block|{
name|SReg2
block|,
literal|"SReg2"
block|}
block|,
block|{
name|SReg3
block|,
literal|"SReg3"
block|}
block|,
block|{
name|Acc
block|,
literal|"Acc"
block|}
block|,
block|{
name|InOutPortReg
block|,
literal|"InOutPortReg"
block|}
block|,
block|{
name|ShiftCount
block|,
literal|"ShiftCount"
block|}
block|,
block|{
name|Imm1
block|,
literal|"i1"
block|}
block|,
block|{
name|Control
block|,
literal|"control reg"
block|}
block|,
block|{
name|Test
block|,
literal|"test reg"
block|}
block|,
block|{
name|FloatReg
block|,
literal|"FReg"
block|}
block|,
block|{
name|FloatAcc
block|,
literal|"FAcc"
block|}
block|,
block|{
name|JumpAbsolute
block|,
literal|"Jump Absolute"
block|}
block|,
block|{
literal|0
block|,
literal|""
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|pt
parameter_list|(
name|t
parameter_list|)
name|uint
name|t
decl_stmt|;
block|{
specifier|register
name|struct
name|type_name
modifier|*
name|ty
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|Unknown
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Unknown"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|ty
operator|=
name|type_names
init|;
name|ty
operator|->
name|mask
condition|;
name|ty
operator|++
control|)
if|if
condition|(
name|t
operator|&
name|ty
operator|->
name|mask
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s, "
argument_list|,
name|ty
operator|->
name|tname
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG386 */
end_comment

begin_escape
end_escape

begin_comment
comment|/*   This is the guts of the machine-dependent assembler.  LINE points to a   machine dependent instruction.  This funciton is supposed to emit   the frags/bytes it assembles to.  */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
block|{
comment|/* Holds temlate once we've found it. */
specifier|register
name|template
modifier|*
name|t
decl_stmt|;
comment|/* Possible templates for current insn */
name|templates
modifier|*
name|current_templates
init|=
operator|(
name|templates
operator|*
operator|)
literal|0
decl_stmt|;
comment|/* Initialize globals. */
name|bzero
argument_list|(
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|disp_expressions
argument_list|,
sizeof|sizeof
argument_list|(
name|disp_expressions
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|im_expressions
argument_list|,
sizeof|sizeof
argument_list|(
name|im_expressions
argument_list|)
argument_list|)
expr_stmt|;
name|save_stack_p
operator|=
name|save_stack
expr_stmt|;
comment|/* reset stack pointer */
comment|/* Fist parse an opcode& call i386_operand for the operands.      We assume that the scrubber has arranged it so that line[0] is the valid       start of a (possibly prefixed) opcode. */
block|{
specifier|register
name|char
modifier|*
name|l
init|=
name|line
decl_stmt|;
comment|/* Fast place to put LINE. */
comment|/* TRUE if operand is pending after ','. */
name|uint
name|expecting_operand
init|=
literal|0
decl_stmt|;
comment|/* TRUE if we found a prefix only acceptable with string insns. */
name|uint
name|expecting_string_instruction
init|=
literal|0
decl_stmt|;
comment|/* Non-zero if operand parens not balenced. */
name|uint
name|paren_not_balenced
decl_stmt|;
name|char
modifier|*
name|token_start
init|=
name|l
decl_stmt|;
while|while
condition|(
operator|!
name|is_space_char
argument_list|(
operator|*
name|l
argument_list|)
operator|&&
operator|*
name|l
operator|!=
name|END_OF_INSN
condition|)
block|{
if|if
condition|(
operator|!
name|is_opcode_char
argument_list|(
operator|*
name|l
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"invalid character %s in opcode"
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|l
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|*
name|l
operator|!=
name|PREFIX_SEPERATOR
condition|)
block|{
operator|*
name|l
operator|=
name|opcode_chars
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|l
index|]
expr_stmt|;
comment|/* fold case of opcodes */
name|l
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* this opcode's got a prefix */
specifier|register
name|int
name|q
decl_stmt|;
specifier|register
name|prefix_entry
modifier|*
name|prefix
decl_stmt|;
if|if
condition|(
name|l
operator|==
name|token_start
condition|)
block|{
name|as_bad
argument_list|(
literal|"expecting prefix; got nothing"
argument_list|)
expr_stmt|;
return|return;
block|}
name|END_STRING_AND_SAVE
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|prefix
operator|=
operator|(
name|prefix_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|prefix_hash
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prefix
condition|)
block|{
name|as_bad
argument_list|(
literal|"no such opcode prefix ('%s')"
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
return|return;
block|}
name|RESTORE_END_STRING
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* check for repeated prefix */
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|i
operator|.
name|prefixes
condition|;
name|q
operator|++
control|)
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|q
index|]
operator|==
name|prefix
operator|->
name|prefix_code
condition|)
block|{
name|as_bad
argument_list|(
literal|"same prefix used twice; you don't really want this!"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|.
name|prefixes
operator|==
name|MAX_PREFIXES
condition|)
block|{
name|as_bad
argument_list|(
literal|"too many opcode prefixes"
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|.
name|prefix
index|[
name|i
operator|.
name|prefixes
operator|++
index|]
operator|=
name|prefix
operator|->
name|prefix_code
expr_stmt|;
if|if
condition|(
name|prefix
operator|->
name|prefix_code
operator|==
name|REPE
operator|||
name|prefix
operator|->
name|prefix_code
operator|==
name|REPNE
condition|)
name|expecting_string_instruction
operator|=
name|TRUE
expr_stmt|;
comment|/* skip past PREFIX_SEPERATOR and reset token_start */
name|token_start
operator|=
operator|++
name|l
expr_stmt|;
block|}
block|}
name|END_STRING_AND_SAVE
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|token_start
operator|==
name|l
condition|)
block|{
name|as_bad
argument_list|(
literal|"expecting opcode; got nothing"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Lookup insn in hash; try intel& att naming conventions if appropriate;        that is:  we only use the opcode suffix 'b' 'w' or 'l' if we need to. */
name|current_templates
operator|=
operator|(
name|templates
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current_templates
condition|)
block|{
name|int
name|last_index
init|=
name|strlen
argument_list|(
name|token_start
argument_list|)
operator|-
literal|1
decl_stmt|;
name|char
name|last_char
init|=
name|token_start
index|[
name|last_index
index|]
decl_stmt|;
switch|switch
condition|(
name|last_char
condition|)
block|{
case|case
name|DWORD_OPCODE_SUFFIX
case|:
case|case
name|WORD_OPCODE_SUFFIX
case|:
case|case
name|BYTE_OPCODE_SUFFIX
case|:
name|token_start
index|[
name|last_index
index|]
operator|=
literal|'\0'
expr_stmt|;
name|current_templates
operator|=
operator|(
name|templates
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
name|token_start
index|[
name|last_index
index|]
operator|=
name|last_char
expr_stmt|;
name|i
operator|.
name|suffix
operator|=
name|last_char
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|current_templates
condition|)
block|{
name|as_bad
argument_list|(
literal|"no such 386 instruction: `%s'"
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|RESTORE_END_STRING
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* check for rep/repne without a string instruction */
if|if
condition|(
name|expecting_string_instruction
operator|&&
operator|!
name|IS_STRING_INSTRUCTION
argument_list|(
name|current_templates
operator|->
name|start
operator|->
name|base_opcode
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"expecting string instruction after rep/repne"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* There may be operands to parse. */
if|if
condition|(
operator|*
name|l
operator|!=
name|END_OF_INSN
operator|&&
comment|/* For string instructions, we ignore any operands if given.  This 	   kludges, for example, 'rep/movsb %ds:(%esi), %es:(%edi)' where 	   the operands are always going to be the same, and are not really 	   encoded in machine code. */
operator|!
name|IS_STRING_INSTRUCTION
argument_list|(
name|current_templates
operator|->
name|start
operator|->
name|base_opcode
argument_list|)
condition|)
block|{
comment|/* parse operands */
do|do
block|{
comment|/* skip optional white space before operand */
while|while
condition|(
operator|!
name|is_operand_char
argument_list|(
operator|*
name|l
argument_list|)
operator|&&
operator|*
name|l
operator|!=
name|END_OF_INSN
condition|)
block|{
if|if
condition|(
operator|!
name|is_space_char
argument_list|(
operator|*
name|l
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"invalid character %s before %s operand"
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|l
argument_list|)
argument_list|,
name|ordinal_names
index|[
name|i
operator|.
name|operands
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|l
operator|++
expr_stmt|;
block|}
name|token_start
operator|=
name|l
expr_stmt|;
comment|/* after white space */
name|paren_not_balenced
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|paren_not_balenced
operator|||
operator|*
name|l
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
operator|*
name|l
operator|==
name|END_OF_INSN
condition|)
block|{
if|if
condition|(
name|paren_not_balenced
condition|)
block|{
name|as_bad
argument_list|(
literal|"unbalenced parenthesis in %s operand."
argument_list|,
name|ordinal_names
index|[
name|i
operator|.
name|operands
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
break|break;
comment|/* we are done */
block|}
elseif|else
if|if
condition|(
operator|!
name|is_operand_char
argument_list|(
operator|*
name|l
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"invalid character %s in %s operand"
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|l
argument_list|)
argument_list|,
name|ordinal_names
index|[
name|i
operator|.
name|operands
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|l
operator|==
literal|'('
condition|)
operator|++
name|paren_not_balenced
expr_stmt|;
if|if
condition|(
operator|*
name|l
operator|==
literal|')'
condition|)
operator|--
name|paren_not_balenced
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|!=
name|token_start
condition|)
block|{
comment|/* yes, we've read in another operand */
name|uint
name|operand_ok
decl_stmt|;
name|this_operand
operator|=
name|i
operator|.
name|operands
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|operands
operator|>
name|MAX_OPERANDS
condition|)
block|{
name|as_bad
argument_list|(
literal|"spurious operands; (%d operands/instruction max)"
argument_list|,
name|MAX_OPERANDS
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* now parse operand adding info to 'i' as we go along */
name|END_STRING_AND_SAVE
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|operand_ok
operator|=
name|i386_operand
argument_list|(
name|token_start
argument_list|)
expr_stmt|;
name|RESTORE_END_STRING
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* restore old contents */
if|if
condition|(
operator|!
name|operand_ok
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
name|expecting_operand
condition|)
block|{
name|expecting_operand_after_comma
label|:
name|as_bad
argument_list|(
literal|"expecting operand after ','; got nothing"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|l
operator|==
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"expecting operand before ','; got nothing"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* now *l must be either ',' or END_OF_INSN */
if|if
condition|(
operator|*
name|l
operator|==
literal|','
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|l
operator|==
name|END_OF_INSN
condition|)
block|{
comment|/* just skip it, if it's \n complain */
goto|goto
name|expecting_operand_after_comma
goto|;
block|}
name|expecting_operand
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|l
operator|!=
name|END_OF_INSN
condition|)
do|;
comment|/* until we get end of insn */
block|}
block|}
comment|/* Now we've parsed the opcode into a set of templates, and have the      operands at hand.      Next, we find a template that matches the given insn,      making sure the overlap of the given operands types is consistent      with the template operand types. */
define|#
directive|define
name|MATCH
parameter_list|(
name|overlap
parameter_list|,
name|given_type
parameter_list|)
define|\
value|(overlap&& \    (overlap& (JumpAbsolute|BaseIndex|Mem8)) \    == (given_type& (JumpAbsolute|BaseIndex|Mem8)))
comment|/* If m0 and m1 are register matches they must be consistent        with the expected operand types t0 and t1.      That is, if both m0& m1 are register matches          i.e. ( ((m0& (Reg))&& (m1& (Reg)) ) ?      then, either 1. or 2. must be true:          1. the expected operand type register overlap is null: 	             (t0& t1& Reg) == 0 	 AND 	    the given register overlap is null:                      (m0& m1& Reg) == 0 	 2. the expected operand type register overlap == the given 	    operand type overlap:  (t0& t1& m0& m1& Reg).      */
define|#
directive|define
name|CONSISTENT_REGISTER_MATCH
parameter_list|(
name|m0
parameter_list|,
name|m1
parameter_list|,
name|t0
parameter_list|,
name|t1
parameter_list|)
define|\
value|( ((m0& (Reg))&& (m1& (Reg))) ? \       ( ((t0& t1& (Reg)) == 0&& (m0& m1& (Reg)) == 0) || \         ((t0& t1)& (m0& m1)& (Reg)) \        ) : 1)
block|{
specifier|register
name|uint
name|overlap0
decl_stmt|,
name|overlap1
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|uint
name|overlap2
decl_stmt|;
name|uint
name|found_reverse_match
decl_stmt|;
name|overlap0
operator|=
name|overlap1
operator|=
name|overlap2
operator|=
name|found_reverse_match
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|current_templates
operator|->
name|start
init|;
name|t
operator|<
name|current_templates
operator|->
name|end
condition|;
name|t
operator|++
control|)
block|{
comment|/* must have right number of operands */
if|if
condition|(
name|i
operator|.
name|operands
operator|!=
name|t
operator|->
name|operands
condition|)
continue|continue;
elseif|else
if|if
condition|(
operator|!
name|t
operator|->
name|operands
condition|)
break|break;
comment|/* 0 operands always matches */
name|overlap0
operator|=
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|operands
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|)
condition|)
continue|continue;
break|break;
case|case
literal|2
case|:
case|case
literal|3
case|:
name|overlap1
operator|=
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|MATCH
argument_list|(
name|overlap1
argument_list|,
name|i
operator|.
name|types
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|CONSISTENT_REGISTER_MATCH
argument_list|(
name|overlap0
argument_list|,
name|overlap1
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* check if other direction is valid ... */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
name|COMES_IN_BOTH_DIRECTIONS
operator|)
condition|)
continue|continue;
comment|/* try reversing direction of operands */
name|overlap0
operator|=
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
expr_stmt|;
name|overlap1
operator|=
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|MATCH
argument_list|(
name|overlap1
argument_list|,
name|i
operator|.
name|types
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|CONSISTENT_REGISTER_MATCH
argument_list|(
name|overlap0
argument_list|,
name|overlap1
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* does not match either direction */
continue|continue;
block|}
comment|/* found a reverse match here -- slip through */
comment|/* found_reverse_match holds which of D or FloatD we've found */
name|found_reverse_match
operator|=
name|t
operator|->
name|opcode_modifier
operator|&
name|COMES_IN_BOTH_DIRECTIONS
expr_stmt|;
block|}
comment|/* endif: not forward match */
comment|/* found either forward/reverse 2 operand match here */
if|if
condition|(
name|t
operator|->
name|operands
operator|==
literal|3
condition|)
block|{
name|overlap2
operator|=
name|i
operator|.
name|types
index|[
literal|2
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap2
argument_list|,
name|i
operator|.
name|types
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|CONSISTENT_REGISTER_MATCH
argument_list|(
name|overlap0
argument_list|,
name|overlap2
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|CONSISTENT_REGISTER_MATCH
argument_list|(
name|overlap1
argument_list|,
name|overlap2
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|2
index|]
argument_list|)
condition|)
continue|continue;
block|}
comment|/* found either forward/reverse 2 or 3 operand match here: 	   slip through to break */
block|}
break|break;
comment|/* we've found a match; break out of loop */
block|}
comment|/* for (t = ... */
if|if
condition|(
name|t
operator|==
name|current_templates
operator|->
name|end
condition|)
block|{
comment|/* we found no match */
name|as_bad
argument_list|(
literal|"operands given don't match any known 386 instruction"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Copy the template we found (we may change it!). */
name|bcopy
argument_list|(
name|t
argument_list|,
operator|&
name|i
operator|.
name|tm
argument_list|,
sizeof|sizeof
argument_list|(
name|template
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
operator|&
name|i
operator|.
name|tm
expr_stmt|;
comment|/* alter new copy of template */
comment|/* If there's no opcode suffix we try to invent one based on register        operands. */
if|if
condition|(
operator|!
name|i
operator|.
name|suffix
operator|&&
name|i
operator|.
name|reg_operands
condition|)
block|{
comment|/* We take i.suffix from the LAST register operand specified.  This 	 assumes that the last register operands is the destination register 	 operand. */
name|int
name|o
decl_stmt|;
for|for
control|(
name|o
operator|=
literal|0
init|;
name|o
operator|<
name|MAX_OPERANDS
condition|;
name|o
operator|++
control|)
if|if
condition|(
name|i
operator|.
name|types
index|[
name|o
index|]
operator|&
name|Reg
condition|)
block|{
name|i
operator|.
name|suffix
operator|=
operator|(
name|i
operator|.
name|types
index|[
name|o
index|]
operator|==
name|Reg8
operator|)
condition|?
name|BYTE_OPCODE_SUFFIX
else|:
operator|(
name|i
operator|.
name|types
index|[
name|o
index|]
operator|==
name|Reg16
operator|)
condition|?
name|WORD_OPCODE_SUFFIX
else|:
name|DWORD_OPCODE_SUFFIX
expr_stmt|;
block|}
block|}
comment|/* Make still unresolved immediate matches conform to size of immediate        given in i.suffix. Note:  overlap2 cannot be an immediate!        We assume this. */
if|if
condition|(
operator|(
name|overlap0
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator||
name|Imm16
operator||
name|Imm32
operator|)
operator|)
operator|&&
name|overlap0
operator|!=
name|Imm8
operator|&&
name|overlap0
operator|!=
name|Imm8S
operator|&&
name|overlap0
operator|!=
name|Imm16
operator|&&
name|overlap0
operator|!=
name|Imm32
condition|)
block|{
if|if
condition|(
operator|!
name|i
operator|.
name|suffix
condition|)
block|{
name|as_bad
argument_list|(
literal|"no opcode suffix given; can't determine immediate size"
argument_list|)
expr_stmt|;
return|return;
block|}
name|overlap0
operator|&=
operator|(
name|i
operator|.
name|suffix
operator|==
name|BYTE_OPCODE_SUFFIX
condition|?
operator|(
name|Imm8
operator||
name|Imm8S
operator|)
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|WORD_OPCODE_SUFFIX
condition|?
name|Imm16
else|:
name|Imm32
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|overlap1
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator||
name|Imm16
operator||
name|Imm32
operator|)
operator|)
operator|&&
name|overlap1
operator|!=
name|Imm8
operator|&&
name|overlap1
operator|!=
name|Imm8S
operator|&&
name|overlap1
operator|!=
name|Imm16
operator|&&
name|overlap1
operator|!=
name|Imm32
condition|)
block|{
if|if
condition|(
operator|!
name|i
operator|.
name|suffix
condition|)
block|{
name|as_bad
argument_list|(
literal|"no opcode suffix given; can't determine immediate size"
argument_list|)
expr_stmt|;
return|return;
block|}
name|overlap1
operator|&=
operator|(
name|i
operator|.
name|suffix
operator|==
name|BYTE_OPCODE_SUFFIX
condition|?
operator|(
name|Imm8
operator||
name|Imm8S
operator|)
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|WORD_OPCODE_SUFFIX
condition|?
name|Imm16
else|:
name|Imm32
operator|)
operator|)
expr_stmt|;
block|}
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|=
name|overlap0
expr_stmt|;
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|=
name|overlap1
expr_stmt|;
name|i
operator|.
name|types
index|[
literal|2
index|]
operator|=
name|overlap2
expr_stmt|;
if|if
condition|(
name|overlap0
operator|&
name|ImplicitRegister
condition|)
name|i
operator|.
name|reg_operands
operator|--
expr_stmt|;
if|if
condition|(
name|overlap1
operator|&
name|ImplicitRegister
condition|)
name|i
operator|.
name|reg_operands
operator|--
expr_stmt|;
if|if
condition|(
name|overlap2
operator|&
name|ImplicitRegister
condition|)
name|i
operator|.
name|reg_operands
operator|--
expr_stmt|;
if|if
condition|(
name|overlap0
operator|&
name|Imm1
condition|)
name|i
operator|.
name|imm_operands
operator|=
literal|0
expr_stmt|;
comment|/* kludge for shift insns */
if|if
condition|(
name|found_reverse_match
condition|)
block|{
name|uint
name|save
decl_stmt|;
name|save
operator|=
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
expr_stmt|;
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
operator|=
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
expr_stmt|;
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
operator|=
name|save
expr_stmt|;
block|}
comment|/* Finalize opcode.  First, we change the opcode based on the operand        size given by i.suffix: we never have to change things for byte insns,        or when no opcode suffix is need to size the operands. */
if|if
condition|(
operator|!
name|i
operator|.
name|suffix
operator|&&
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
name|W
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"no opcode suffix given and no register operands; can't size instruction"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|.
name|suffix
operator|&&
name|i
operator|.
name|suffix
operator|!=
name|BYTE_OPCODE_SUFFIX
condition|)
block|{
comment|/* Select between byte and word/dword operations. */
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|W
condition|)
name|t
operator|->
name|base_opcode
operator||=
name|W
expr_stmt|;
comment|/* Now select between word& dword operations via the 	 operand size prefix. */
if|if
condition|(
name|i
operator|.
name|suffix
operator|==
name|WORD_OPCODE_SUFFIX
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|prefixes
operator|==
name|MAX_PREFIXES
condition|)
block|{
name|as_bad
argument_list|(
literal|"%d prefixes given and 'w' opcode suffix gives too many prefixes"
argument_list|,
name|MAX_PREFIXES
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|.
name|prefix
index|[
name|i
operator|.
name|prefixes
operator|++
index|]
operator|=
name|WORD_PREFIX_OPCODE
expr_stmt|;
block|}
block|}
comment|/* For insns with operands there are more diddles to do to the opcode. */
if|if
condition|(
name|i
operator|.
name|operands
condition|)
block|{
comment|/* If we found a reverse match we must alter the opcode direction bit 	 found_reverse_match holds bit to set (different for int& 	 float insns). */
if|if
condition|(
name|found_reverse_match
condition|)
block|{
name|t
operator|->
name|base_opcode
operator||=
name|found_reverse_match
expr_stmt|;
block|}
comment|/* 	The imul $imm, %reg instruction is converted into 	imul $imm, %reg, %reg. */
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|imulKludge
condition|)
block|{
name|i
operator|.
name|regs
index|[
literal|2
index|]
operator|=
name|i
operator|.
name|regs
index|[
literal|1
index|]
expr_stmt|;
comment|/* Pretend we saw the 3 operand case. */
name|i
operator|.
name|reg_operands
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Certain instructions expect the destination to be in the i.rm.reg 	 field.  This is by far the exceptional case.  For these instructions, 	 if the source operand is a register, we must reverse the i.rm.reg 	 and i.rm.regmem fields.  We accomplish this by faking that the 	 two register operands were given in the reverse order. */
if|if
condition|(
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
name|ReverseRegRegmem
operator|)
operator|&&
name|i
operator|.
name|reg_operands
operator|==
literal|2
condition|)
block|{
name|uint
name|first_reg_operand
init|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|Reg
operator|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
name|uint
name|second_reg_operand
init|=
name|first_reg_operand
operator|+
literal|1
decl_stmt|;
name|reg_entry
modifier|*
name|tmp
init|=
name|i
operator|.
name|regs
index|[
name|first_reg_operand
index|]
decl_stmt|;
name|i
operator|.
name|regs
index|[
name|first_reg_operand
index|]
operator|=
name|i
operator|.
name|regs
index|[
name|second_reg_operand
index|]
expr_stmt|;
name|i
operator|.
name|regs
index|[
name|second_reg_operand
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|ShortForm
condition|)
block|{
comment|/* The register or float register operand is in operand 0 or 1. */
name|uint
name|o
init|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
operator|(
name|Reg
operator||
name|FloatReg
operator|)
operator|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
comment|/* Register goes in low 3 bits of opcode. */
name|t
operator|->
name|base_opcode
operator||=
name|i
operator|.
name|regs
index|[
name|o
index|]
operator|->
name|reg_num
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|ShortFormW
condition|)
block|{
comment|/* Short form with 0x8 width bit.  Register is always dest. operand */
name|t
operator|->
name|base_opcode
operator||=
name|i
operator|.
name|regs
index|[
literal|1
index|]
operator|->
name|reg_num
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|suffix
operator|==
name|WORD_OPCODE_SUFFIX
operator|||
name|i
operator|.
name|suffix
operator|==
name|DWORD_OPCODE_SUFFIX
condition|)
name|t
operator|->
name|base_opcode
operator||=
literal|0x8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|Seg2ShortForm
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|base_opcode
operator|==
name|POP_SEG_SHORT
operator|&&
name|i
operator|.
name|regs
index|[
literal|0
index|]
operator|->
name|reg_num
operator|==
literal|1
condition|)
block|{
name|as_bad
argument_list|(
literal|"you can't 'pop cs' on the 386."
argument_list|)
expr_stmt|;
return|return;
block|}
name|t
operator|->
name|base_opcode
operator||=
operator|(
name|i
operator|.
name|regs
index|[
literal|0
index|]
operator|->
name|reg_num
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|Seg3ShortForm
condition|)
block|{
comment|/* 'push %fs' is 0x0fa0; 'pop %fs' is 0x0fa1. 	   'push %gs' is 0x0fa8; 'pop %fs' is 0x0fa9. 	   So, only if i.regs[0]->reg_num == 5 (%gs) do we need 	   to change the opcode. */
if|if
condition|(
name|i
operator|.
name|regs
index|[
literal|0
index|]
operator|->
name|reg_num
operator|==
literal|5
condition|)
name|t
operator|->
name|base_opcode
operator||=
literal|0x08
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|Modrm
condition|)
block|{
comment|/* The opcode is completed (modulo t->extension_opcode which must 	   be put into the modrm byte. 	   Now, we make the modrm& index base bytes based on all the info 	   we've collected. */
comment|/* i.reg_operands MUST be the number of real register operands; 	   implicit registers do not count. */
if|if
condition|(
name|i
operator|.
name|reg_operands
operator|==
literal|2
condition|)
block|{
name|uint
name|source
decl_stmt|,
name|dest
decl_stmt|;
name|source
operator|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
operator|(
name|Reg
operator||
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator|)
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|dest
operator|=
name|source
operator|+
literal|1
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
literal|3
expr_stmt|;
comment|/* We must be careful to make sure that all segment/control/test/ 	     debug registers go into the i.rm.reg field (despite the whether 	     they are source or destination operands). */
if|if
condition|(
name|i
operator|.
name|regs
index|[
name|dest
index|]
operator|->
name|reg_type
operator|&
operator|(
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator|)
condition|)
block|{
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|i
operator|.
name|regs
index|[
name|dest
index|]
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|regs
index|[
name|source
index|]
operator|->
name|reg_num
expr_stmt|;
block|}
else|else
block|{
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|i
operator|.
name|regs
index|[
name|source
index|]
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|regs
index|[
name|dest
index|]
operator|->
name|reg_num
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* if it's not 2 reg operands... */
if|if
condition|(
name|i
operator|.
name|mem_operands
condition|)
block|{
name|uint
name|fake_zero_displacement
init|=
name|FALSE
decl_stmt|;
name|uint
name|o
init|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|Mem
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|Mem
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
decl_stmt|;
comment|/* Encode memory operand into modrm byte and base index byte. */
if|if
condition|(
name|i
operator|.
name|base_reg
operator|==
name|esp
operator|&&
operator|!
name|i
operator|.
name|index_reg
condition|)
block|{
comment|/*<disp>(%esp) becomes two byte modrm with no index register. */
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
name|MODE_FROM_DISP_SIZE
argument_list|(
name|i
operator|.
name|types
index|[
name|o
index|]
argument_list|)
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|base
operator|=
name|ESP_REG_NUM
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|index
operator|=
name|NO_INDEX_REGISTER
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|scale
operator|=
literal|0
expr_stmt|;
comment|/* Must be zero! */
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|base_reg
operator|==
name|ebp
operator|&&
operator|!
name|i
operator|.
name|index_reg
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|.
name|types
index|[
name|o
index|]
operator|&
name|Disp
operator|)
condition|)
block|{
comment|/* Must fake a zero byte displacement. 		   There is no direct way to code '(%ebp)' directly. */
name|fake_zero_displacement
operator|=
name|TRUE
expr_stmt|;
comment|/* fake_zero_displacement code does not set this. */
name|i
operator|.
name|types
index|[
name|o
index|]
operator||=
name|Disp8
expr_stmt|;
block|}
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
name|MODE_FROM_DISP_SIZE
argument_list|(
name|i
operator|.
name|types
index|[
name|o
index|]
argument_list|)
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|EBP_REG_NUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|i
operator|.
name|base_reg
operator|&&
operator|(
name|i
operator|.
name|types
index|[
name|o
index|]
operator|&
name|BaseIndex
operator|)
condition|)
block|{
comment|/* There are three cases here. 		 Case 1:  '<32bit disp>(,1)' -- indirect absolute. 		 (Same as cases 2& 3 with NO index register) 		 Case 2:<32bit disp> (,<index>) -- no base register with disp 		 Case 3:  (,<index>)       --- no base register; 		 no disp (must add 32bit 0 disp). */
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
comment|/* 32bit mode */
name|i
operator|.
name|bi
operator|.
name|base
operator|=
name|NO_BASE_REGISTER
expr_stmt|;
name|i
operator|.
name|types
index|[
name|o
index|]
operator|&=
operator|~
name|Disp
expr_stmt|;
name|i
operator|.
name|types
index|[
name|o
index|]
operator||=
name|Disp32
expr_stmt|;
comment|/* Must be 32bit! */
if|if
condition|(
name|i
operator|.
name|index_reg
condition|)
block|{
comment|/* case 2 or case 3 */
name|i
operator|.
name|bi
operator|.
name|index
operator|=
name|i
operator|.
name|index_reg
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|scale
operator|=
name|i
operator|.
name|log2_scale_factor
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|disp_operands
operator|==
literal|0
condition|)
name|fake_zero_displacement
operator|=
name|TRUE
expr_stmt|;
comment|/* case 3 */
block|}
else|else
block|{
name|i
operator|.
name|bi
operator|.
name|index
operator|=
name|NO_INDEX_REGISTER
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|scale
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|disp_operands
operator|&&
operator|!
name|i
operator|.
name|base_reg
operator|&&
operator|!
name|i
operator|.
name|index_reg
condition|)
block|{
comment|/* Operand is just<32bit disp> */
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|EBP_REG_NUM
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|i
operator|.
name|types
index|[
name|o
index|]
operator|&=
operator|~
name|Disp
expr_stmt|;
name|i
operator|.
name|types
index|[
name|o
index|]
operator||=
name|Disp32
expr_stmt|;
block|}
else|else
block|{
comment|/* It's not a special case; rev'em up. */
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|base_reg
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
name|MODE_FROM_DISP_SIZE
argument_list|(
name|i
operator|.
name|types
index|[
name|o
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|index_reg
condition|)
block|{
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|base
operator|=
name|i
operator|.
name|base_reg
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|index
operator|=
name|i
operator|.
name|index_reg
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|scale
operator|=
name|i
operator|.
name|log2_scale_factor
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|base_reg
operator|==
name|ebp
operator|&&
name|i
operator|.
name|disp_operands
operator|==
literal|0
condition|)
block|{
comment|/* pace */
name|fake_zero_displacement
operator|=
name|TRUE
expr_stmt|;
name|i
operator|.
name|types
index|[
name|o
index|]
operator||=
name|Disp8
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
name|MODE_FROM_DISP_SIZE
argument_list|(
name|i
operator|.
name|types
index|[
name|o
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|fake_zero_displacement
condition|)
block|{
comment|/* Fakes a zero displacement assuming that i.types[o] holds 		 the correct displacement size. */
name|exp
operator|=
operator|&
name|disp_expressions
index|[
name|i
operator|.
name|disp_operands
operator|++
index|]
expr_stmt|;
name|i
operator|.
name|disps
index|[
name|o
index|]
operator|=
name|exp
expr_stmt|;
name|exp
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
name|exp
operator|->
name|X_subtract_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* Select the correct segment for the memory operand. */
if|if
condition|(
name|i
operator|.
name|seg
condition|)
block|{
name|uint
name|seg_index
decl_stmt|;
name|seg_entry
modifier|*
name|default_seg
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|rm
operator|.
name|regmem
operator|==
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
condition|)
block|{
name|seg_index
operator|=
operator|(
name|i
operator|.
name|rm
operator|.
name|mode
operator|<<
literal|3
operator|)
operator||
name|i
operator|.
name|bi
operator|.
name|base
expr_stmt|;
name|default_seg
operator|=
name|two_byte_segment_defaults
index|[
name|seg_index
index|]
expr_stmt|;
block|}
else|else
block|{
name|seg_index
operator|=
operator|(
name|i
operator|.
name|rm
operator|.
name|mode
operator|<<
literal|3
operator|)
operator||
name|i
operator|.
name|rm
operator|.
name|regmem
expr_stmt|;
name|default_seg
operator|=
name|one_byte_segment_defaults
index|[
name|seg_index
index|]
expr_stmt|;
block|}
comment|/* If the specified segment is not the default, use an 		 opcode prefix to select it */
if|if
condition|(
name|i
operator|.
name|seg
operator|!=
name|default_seg
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|prefixes
operator|==
name|MAX_PREFIXES
condition|)
block|{
name|as_bad
argument_list|(
literal|"%d prefixes given and %s segment override gives too many prefixes"
argument_list|,
name|MAX_PREFIXES
argument_list|,
name|i
operator|.
name|seg
operator|->
name|seg_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|.
name|prefix
index|[
name|i
operator|.
name|prefixes
operator|++
index|]
operator|=
name|i
operator|.
name|seg
operator|->
name|seg_prefix
expr_stmt|;
block|}
block|}
block|}
comment|/* Fill in i.rm.reg or i.rm.regmem field with register operand 	     (if any) based on t->extension_opcode. Again, we must be careful 	     to make sure that segment/control/debug/test registers are coded 	     into the i.rm.reg field. */
if|if
condition|(
name|i
operator|.
name|reg_operands
condition|)
block|{
name|uint
name|o
init|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
operator|(
name|Reg
operator||
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator|)
operator|)
condition|?
literal|0
else|:
operator|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
operator|(
name|Reg
operator||
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator|)
operator|)
condition|?
literal|1
else|:
literal|2
decl_stmt|;
comment|/* If there is an extension opcode to put here, the register number 	       must be put into the regmem field. */
if|if
condition|(
name|t
operator|->
name|extension_opcode
operator|!=
name|None
condition|)
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|regs
index|[
name|o
index|]
operator|->
name|reg_num
expr_stmt|;
else|else
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|i
operator|.
name|regs
index|[
name|o
index|]
operator|->
name|reg_num
expr_stmt|;
comment|/* Now, if no memory operand has set i.rm.mode = 0, 1, 2 	       we must set it to 3 to indicate this is a register operand 	       int the regmem field */
if|if
condition|(
operator|!
name|i
operator|.
name|mem_operands
condition|)
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
literal|3
expr_stmt|;
block|}
comment|/* Fill in i.rm.reg field with extension opcode (if any). */
if|if
condition|(
name|t
operator|->
name|extension_opcode
operator|!=
name|None
condition|)
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|t
operator|->
name|extension_opcode
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Handle conversion of 'int $3' --> special int3 insn. */
if|if
condition|(
name|t
operator|->
name|base_opcode
operator|==
name|INT_OPCODE
operator|&&
name|i
operator|.
name|imms
index|[
literal|0
index|]
operator|->
name|X_add_number
operator|==
literal|3
condition|)
block|{
name|t
operator|->
name|base_opcode
operator|=
name|INT3_OPCODE
expr_stmt|;
name|i
operator|.
name|imm_operands
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We are ready to output the insn. */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Output jumps. */
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|Jump
condition|)
block|{
name|int
name|n
init|=
name|i
operator|.
name|disps
index|[
literal|0
index|]
operator|->
name|X_add_number
decl_stmt|;
switch|switch
condition|(
name|i
operator|.
name|disps
index|[
literal|0
index|]
operator|->
name|X_seg
condition|)
block|{
case|case
name|SEG_ABSOLUTE
case|:
if|if
condition|(
name|FITS_IN_SIGNED_BYTE
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|t
operator|->
name|base_opcode
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|n
expr_stmt|;
if|#
directive|if
literal|0
comment|/* leave out 16 bit jumps - pace */
block|} else if (FITS_IN_SIGNED_WORD (n)) { 	  p = frag_more (4); 	  p[0] = WORD_PREFIX_OPCODE; 	  p[1] = t->base_opcode; 	  md_number_to_chars (&p[2], n, 2);
endif|#
directive|endif
block|}
else|else
block|{
comment|/* It's an absolute dword displacement. */
if|if
condition|(
name|t
operator|->
name|base_opcode
operator|==
name|JUMP_PC_RELATIVE
condition|)
block|{
comment|/* pace */
comment|/* unconditional jump */
name|p
operator|=
name|frag_more
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|0xe9
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|&
name|p
index|[
literal|1
index|]
argument_list|,
name|n
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* conditional jump */
name|p
operator|=
name|frag_more
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|TWO_BYTE_OPCODE_ESCAPE
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|t
operator|->
name|base_opcode
operator|+
literal|0x10
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
name|n
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
comment|/* It's a symbol; end frag& setup for relax. 	   Make sure there are 6 chars left in the current frag; if not 	   we'll have to start a new one. */
comment|/* I caught it failing with obstack_room == 6, 	   so I changed to<=   pace */
if|if
condition|(
name|obstack_room
argument_list|(
operator|&
name|frags
argument_list|)
operator|<=
literal|6
condition|)
block|{
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|t
operator|->
name|base_opcode
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|6
argument_list|,
comment|/* 2 opcode/prefix + 4 displacement */
literal|1
argument_list|,
operator|(
operator|(
name|uchar
operator|)
operator|*
name|p
operator|==
name|JUMP_PC_RELATIVE
condition|?
name|ENCODE_RELAX_STATE
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|BYTE
argument_list|)
else|:
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP
argument_list|,
name|BYTE
argument_list|)
operator|)
argument_list|,
name|i
operator|.
name|disps
index|[
literal|0
index|]
operator|->
name|X_add_symbol
argument_list|,
name|n
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
operator|(
name|JumpByte
operator||
name|JumpDword
operator|)
condition|)
block|{
name|int
name|size
init|=
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
name|JumpByte
operator|)
condition|?
literal|1
else|:
literal|4
decl_stmt|;
name|int
name|n
init|=
name|i
operator|.
name|disps
index|[
literal|0
index|]
operator|->
name|X_add_number
decl_stmt|;
if|if
condition|(
name|FITS_IN_UNSIGNED_BYTE
argument_list|(
name|t
operator|->
name|base_opcode
argument_list|)
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|t
operator|->
name|base_opcode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* opcode can be at most two bytes */
comment|/* put out high byte first: can't use md_number_to_chars! */
operator|*
name|p
operator|++
operator|=
operator|(
name|t
operator|->
name|base_opcode
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|p
operator|=
name|t
operator|->
name|base_opcode
operator|&
literal|0xff
expr_stmt|;
block|}
name|p
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
operator|.
name|disps
index|[
literal|0
index|]
operator|->
name|X_seg
condition|)
block|{
case|case
name|SEG_ABSOLUTE
case|:
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|1
operator|&&
operator|!
name|FITS_IN_SIGNED_BYTE
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"loop/jecx only takes byte displacement; %d shortened to %d"
argument_list|,
name|n
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
name|i
operator|.
name|disps
index|[
literal|0
index|]
operator|->
name|X_add_symbol
argument_list|,
name|i
operator|.
name|disps
index|[
literal|0
index|]
operator|->
name|X_subtract_symbol
argument_list|,
name|i
operator|.
name|disps
index|[
literal|0
index|]
operator|->
name|X_add_number
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|JumpInterSegment
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
operator|+
literal|2
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* 1 opcode; 2 segment; 4 offset */
name|p
index|[
literal|0
index|]
operator|=
name|t
operator|->
name|base_opcode
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|imms
index|[
literal|1
index|]
operator|->
name|X_seg
operator|==
name|SEG_ABSOLUTE
condition|)
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|i
operator|.
name|imms
index|[
literal|1
index|]
operator|->
name|X_add_number
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|1
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|i
operator|.
name|imms
index|[
literal|1
index|]
operator|->
name|X_add_symbol
argument_list|,
name|i
operator|.
name|imms
index|[
literal|1
index|]
operator|->
name|X_subtract_symbol
argument_list|,
name|i
operator|.
name|imms
index|[
literal|1
index|]
operator|->
name|X_add_number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|imms
index|[
literal|0
index|]
operator|->
name|X_seg
operator|!=
name|SEG_ABSOLUTE
condition|)
name|as_bad
argument_list|(
literal|"can't handle non absolute segment in long call/jmp"
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|5
argument_list|,
name|i
operator|.
name|imms
index|[
literal|0
index|]
operator|->
name|X_add_number
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Output normal instructions here. */
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
comment|/* First the prefix bytes. */
for|for
control|(
name|q
operator|=
name|i
operator|.
name|prefix
init|;
name|q
operator|<
name|i
operator|.
name|prefix
operator|+
name|i
operator|.
name|prefixes
condition|;
name|q
operator|++
control|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|uint
operator|)
operator|*
name|q
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now the opcode; be careful about word order here! */
if|if
condition|(
name|FITS_IN_UNSIGNED_BYTE
argument_list|(
name|t
operator|->
name|base_opcode
argument_list|)
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|t
operator|->
name|base_opcode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FITS_IN_UNSIGNED_WORD
argument_list|(
name|t
operator|->
name|base_opcode
argument_list|)
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* put out high byte first: can't use md_number_to_chars! */
operator|*
name|p
operator|++
operator|=
operator|(
name|t
operator|->
name|base_opcode
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|p
operator|=
name|t
operator|->
name|base_opcode
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
comment|/* opcode is either 3 or 4 bytes */
if|if
condition|(
name|t
operator|->
name|base_opcode
operator|&
literal|0xff000000
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|t
operator|->
name|base_opcode
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
name|p
operator|=
name|frag_more
argument_list|(
literal|3
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|t
operator|->
name|base_opcode
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|t
operator|->
name|base_opcode
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|p
operator|=
operator|(
name|t
operator|->
name|base_opcode
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
comment|/* Now the modrm byte and base index byte (if present). */
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|Modrm
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* md_number_to_chars (p, i.rm, 1); */
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|i
operator|.
name|rm
operator|.
name|regmem
operator|<<
literal|0
operator||
name|i
operator|.
name|rm
operator|.
name|reg
operator|<<
literal|3
operator||
name|i
operator|.
name|rm
operator|.
name|mode
operator|<<
literal|6
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If i.rm.regmem == ESP (4)&& i.rm.mode != Mode 3 (Register mode) 	   ==> need second modrm byte. */
if|if
condition|(
name|i
operator|.
name|rm
operator|.
name|regmem
operator|==
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
operator|&&
name|i
operator|.
name|rm
operator|.
name|mode
operator|!=
literal|3
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* md_number_to_chars (p, i.bi, 1); */
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|i
operator|.
name|bi
operator|.
name|base
operator|<<
literal|0
operator||
name|i
operator|.
name|bi
operator|.
name|index
operator|<<
literal|3
operator||
name|i
operator|.
name|bi
operator|.
name|scale
operator|<<
literal|6
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|.
name|disp_operands
condition|)
block|{
specifier|register
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|i
operator|.
name|operands
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|.
name|disps
index|[
name|n
index|]
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|disps
index|[
name|n
index|]
operator|->
name|X_seg
operator|==
name|SEG_ABSOLUTE
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Disp8
operator||
name|Abs8
operator|)
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|i
operator|.
name|disps
index|[
name|n
index|]
operator|->
name|X_add_number
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Disp16
operator||
name|Abs16
operator|)
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|i
operator|.
name|disps
index|[
name|n
index|]
operator|->
name|X_add_number
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Disp32|Abs32 */
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|i
operator|.
name|disps
index|[
name|n
index|]
operator|->
name|X_add_number
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* not SEG_ABSOLUTE */
comment|/* need a 32-bit fixup (don't support 8bit non-absolute disps) */
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|i
operator|.
name|disps
index|[
name|n
index|]
operator|->
name|X_add_symbol
argument_list|,
name|i
operator|.
name|disps
index|[
name|n
index|]
operator|->
name|X_subtract_symbol
argument_list|,
name|i
operator|.
name|disps
index|[
name|n
index|]
operator|->
name|X_add_number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* end displacement output */
comment|/* output immediate */
if|if
condition|(
name|i
operator|.
name|imm_operands
condition|)
block|{
specifier|register
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|i
operator|.
name|operands
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|.
name|imms
index|[
name|n
index|]
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_seg
operator|==
name|SEG_ABSOLUTE
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator|)
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_add_number
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Imm16
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_add_number
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_add_number
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* not SEG_ABSOLUTE */
comment|/* need a 32-bit fixup (don't support 8bit non-absolute ims) */
comment|/* try to support other sizes ... */
name|int
name|size
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator|)
condition|)
name|size
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Imm16
condition|)
name|size
operator|=
literal|2
expr_stmt|;
else|else
name|size
operator|=
literal|4
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_add_symbol
argument_list|,
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_subtract_symbol
argument_list|,
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_add_number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* end immediate output */
block|}
ifdef|#
directive|ifdef
name|DEBUG386
if|if
condition|(
name|flagseen
index|[
literal|'D'
index|]
condition|)
block|{
name|pi
argument_list|(
name|line
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG386 */
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse OPERAND_STRING into the i386_insn structure I.  Returns non-zero    on error. */
end_comment

begin_function
name|int
name|i386_operand
parameter_list|(
name|operand_string
parameter_list|)
name|char
modifier|*
name|operand_string
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|op_string
init|=
name|operand_string
decl_stmt|;
comment|/* Address of '\0' at end of operand_string. */
name|char
modifier|*
name|end_of_operand_string
init|=
name|operand_string
operator|+
name|strlen
argument_list|(
name|operand_string
argument_list|)
decl_stmt|;
comment|/* Start and end of displacement string expression (if found). */
name|char
modifier|*
name|displacement_string_start
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|displacement_string_end
decl_stmt|;
comment|/* We check for an absolute prefix (differentiating,      for example, 'jmp pc_relative_label' from 'jmp *absolute_label'. */
if|if
condition|(
operator|*
name|op_string
operator|==
name|ABSOLUTE_PREFIX
condition|)
block|{
name|op_string
operator|++
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|JumpAbsolute
expr_stmt|;
block|}
comment|/* Check if operand is a register. */
if|if
condition|(
operator|*
name|op_string
operator|==
name|REGISTER_PREFIX
condition|)
block|{
specifier|register
name|reg_entry
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|r
operator|=
name|parse_register
argument_list|(
name|op_string
argument_list|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"bad register name ('%s')"
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check for segment override, rather than segment register by        searching for ':' after %<x>s where<x> = s, c, d, e, f, g. */
if|if
condition|(
operator|(
name|r
operator|->
name|reg_type
operator|&
operator|(
name|SReg2
operator||
name|SReg3
operator|)
operator|)
operator|&&
name|op_string
index|[
literal|3
index|]
operator|==
literal|':'
condition|)
block|{
switch|switch
condition|(
name|r
operator|->
name|reg_num
condition|)
block|{
case|case
literal|0
case|:
name|i
operator|.
name|seg
operator|=
operator|&
name|es
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|i
operator|.
name|seg
operator|=
operator|&
name|cs
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|i
operator|.
name|seg
operator|=
operator|&
name|ss
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|i
operator|.
name|seg
operator|=
operator|&
name|ds
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|i
operator|.
name|seg
operator|=
operator|&
name|fs
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|i
operator|.
name|seg
operator|=
operator|&
name|gs
expr_stmt|;
break|break;
block|}
name|op_string
operator|+=
literal|4
expr_stmt|;
comment|/* skip %<x> s : */
name|operand_string
operator|=
name|op_string
expr_stmt|;
comment|/* Pretend given string starts here. */
if|if
condition|(
operator|!
name|is_digit_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|&&
operator|!
name|is_identifier_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|&&
operator|*
name|op_string
operator|!=
literal|'('
operator|&&
operator|*
name|op_string
operator|!=
name|ABSOLUTE_PREFIX
condition|)
block|{
name|as_bad
argument_list|(
literal|"bad memory operand after segment override"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Handle case of %es:*foo. */
if|if
condition|(
operator|*
name|op_string
operator|==
name|ABSOLUTE_PREFIX
condition|)
block|{
name|op_string
operator|++
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|JumpAbsolute
expr_stmt|;
block|}
goto|goto
name|do_memory_reference
goto|;
block|}
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|r
operator|->
name|reg_type
expr_stmt|;
name|i
operator|.
name|regs
index|[
name|this_operand
index|]
operator|=
name|r
expr_stmt|;
name|i
operator|.
name|reg_operands
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|op_string
operator|==
name|IMMEDIATE_PREFIX
condition|)
block|{
comment|/* ... or an immediate */
name|char
modifier|*
name|save_input_line_pointer
decl_stmt|;
specifier|register
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|segT
name|exp_seg
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|imm_operands
operator|==
name|MAX_IMMEDIATE_OPERANDS
condition|)
block|{
name|as_bad
argument_list|(
literal|"only 1 or 2 immediate operands are allowed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|exp
operator|=
operator|&
name|im_expressions
index|[
name|i
operator|.
name|imm_operands
operator|++
index|]
expr_stmt|;
name|i
operator|.
name|imms
index|[
name|this_operand
index|]
operator|=
name|exp
expr_stmt|;
name|save_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
operator|++
name|op_string
expr_stmt|;
comment|/* must advance op_string! */
name|exp_seg
operator|=
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save_input_line_pointer
expr_stmt|;
switch|switch
condition|(
name|exp_seg
condition|)
block|{
case|case
name|SEG_NONE
case|:
comment|/* missing or bad expr becomes absolute 0 */
name|as_bad
argument_list|(
literal|"missing or invalid immediate expression '%s' taken as 0"
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
name|exp
operator|->
name|X_subtract_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Imm
expr_stmt|;
break|break;
case|case
name|SEG_ABSOLUTE
case|:
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|SMALLEST_IMM_TYPE
argument_list|(
name|exp
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEG_TEXT
case|:
case|case
name|SEG_DATA
case|:
case|case
name|SEG_BSS
case|:
case|case
name|SEG_UNKNOWN
case|:
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Imm32
expr_stmt|;
comment|/* this is an address ==> 32bit */
break|break;
default|default:
name|seg_unimplemented
label|:
name|as_bad
argument_list|(
literal|"Unimplemented segment type %d in parse_operand"
argument_list|,
name|exp_seg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* shorten this type of this operand if the instruction wants      * fewer bits than are present in the immediate.  The bit field      * code can put out 'andb $0xffffff, %al', for example.   pace      * also 'movw $foo,(%eax)'      */
switch|switch
condition|(
name|i
operator|.
name|suffix
condition|)
block|{
case|case
name|WORD_OPCODE_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Imm16
expr_stmt|;
break|break;
case|case
name|BYTE_OPCODE_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Imm16
operator||
name|Imm8
operator||
name|Imm8S
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|is_digit_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|||
name|is_identifier_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|||
operator|*
name|op_string
operator|==
literal|'('
condition|)
block|{
comment|/* This is a memory reference of some sort. */
specifier|register
name|char
modifier|*
name|base_string
decl_stmt|;
name|uint
name|found_base_index_form
decl_stmt|;
name|do_memory_reference
label|:
if|if
condition|(
name|i
operator|.
name|mem_operands
operator|==
name|MAX_MEMORY_OPERANDS
condition|)
block|{
name|as_bad
argument_list|(
literal|"more than 1 memory reference in instruction"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|.
name|mem_operands
operator|++
expr_stmt|;
comment|/* Determine type of memory operand from opcode_suffix;        no opcode suffix implies general memory references. */
switch|switch
condition|(
name|i
operator|.
name|suffix
condition|)
block|{
case|case
name|BYTE_OPCODE_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Mem8
expr_stmt|;
break|break;
case|case
name|WORD_OPCODE_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Mem16
expr_stmt|;
break|break;
case|case
name|DWORD_OPCODE_SUFFIX
case|:
default|default:
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Mem32
expr_stmt|;
block|}
comment|/*  Check for base index form.  We detect the base index form by 	looking for an ')' at the end of the operand, searching 	for the '(' matching it, and finding a REGISTER_PREFIX or ',' 	after it. */
name|base_string
operator|=
name|end_of_operand_string
operator|-
literal|1
expr_stmt|;
name|found_base_index_form
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|')'
condition|)
block|{
name|uint
name|parens_balenced
init|=
literal|1
decl_stmt|;
comment|/* We've already checked that the number of left& right ()'s are equal, 	 so this loop will not be infinite. */
do|do
block|{
name|base_string
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|')'
condition|)
name|parens_balenced
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|'('
condition|)
name|parens_balenced
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|parens_balenced
condition|)
do|;
name|base_string
operator|++
expr_stmt|;
comment|/* Skip past '('. */
if|if
condition|(
operator|*
name|base_string
operator|==
name|REGISTER_PREFIX
operator|||
operator|*
name|base_string
operator|==
literal|','
condition|)
name|found_base_index_form
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If we can't parse a base index register expression, we've found        a pure displacement expression.  We set up displacement_string_start        and displacement_string_end for the code below. */
if|if
condition|(
operator|!
name|found_base_index_form
condition|)
block|{
name|displacement_string_start
operator|=
name|op_string
expr_stmt|;
name|displacement_string_end
operator|=
name|end_of_operand_string
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|base_reg_name
decl_stmt|,
modifier|*
name|index_reg_name
decl_stmt|,
modifier|*
name|num_string
decl_stmt|;
name|int
name|num
decl_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|BaseIndex
expr_stmt|;
comment|/* If there is a displacement set-up for it to be parsed later. */
if|if
condition|(
name|base_string
operator|!=
name|op_string
operator|+
literal|1
condition|)
block|{
name|displacement_string_start
operator|=
name|op_string
expr_stmt|;
name|displacement_string_end
operator|=
name|base_string
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Find base register (if any). */
if|if
condition|(
operator|*
name|base_string
operator|!=
literal|','
condition|)
block|{
name|base_reg_name
operator|=
name|base_string
operator|++
expr_stmt|;
comment|/* skip past register name& parse it */
while|while
condition|(
name|isalpha
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
name|base_string
operator|++
expr_stmt|;
if|if
condition|(
name|base_string
operator|==
name|base_reg_name
operator|+
literal|1
condition|)
block|{
name|as_bad
argument_list|(
literal|"can't find base register name after '(%c'"
argument_list|,
name|REGISTER_PREFIX
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|END_STRING_AND_SAVE
argument_list|(
name|base_string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|.
name|base_reg
operator|=
name|parse_register
argument_list|(
name|base_reg_name
argument_list|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"bad base register name ('%s')"
argument_list|,
name|base_reg_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|RESTORE_END_STRING
argument_list|(
name|base_string
argument_list|)
expr_stmt|;
block|}
comment|/* Now check seperator; must be ',' ==> index reg 	 OR num ==> no index reg. just scale factor 	 OR ')' ==> end. (scale factor = 1) */
if|if
condition|(
operator|*
name|base_string
operator|!=
literal|','
operator|&&
operator|*
name|base_string
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
literal|"expecting ',' or ')' after base register in `%s'"
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* There may index reg here; and there may be a scale factor. */
if|if
condition|(
operator|*
name|base_string
operator|==
literal|','
operator|&&
operator|*
operator|(
name|base_string
operator|+
literal|1
operator|)
operator|==
name|REGISTER_PREFIX
condition|)
block|{
name|index_reg_name
operator|=
operator|++
name|base_string
expr_stmt|;
while|while
condition|(
name|isalpha
argument_list|(
operator|*
operator|++
name|base_string
argument_list|)
condition|)
empty_stmt|;
name|END_STRING_AND_SAVE
argument_list|(
name|base_string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|.
name|index_reg
operator|=
name|parse_register
argument_list|(
name|index_reg_name
argument_list|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"bad index register name ('%s')"
argument_list|,
name|index_reg_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|RESTORE_END_STRING
argument_list|(
name|base_string
argument_list|)
expr_stmt|;
block|}
comment|/* Check for scale factor. */
if|if
condition|(
operator|*
name|base_string
operator|==
literal|','
operator|&&
name|isdigit
argument_list|(
operator|*
operator|(
name|base_string
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|num_string
operator|=
operator|++
name|base_string
expr_stmt|;
while|while
condition|(
name|is_digit_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
name|base_string
operator|++
expr_stmt|;
if|if
condition|(
name|base_string
operator|==
name|num_string
condition|)
block|{
name|as_bad
argument_list|(
literal|"can't find a scale factor after ','"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|END_STRING_AND_SAVE
argument_list|(
name|base_string
argument_list|)
expr_stmt|;
comment|/* We've got a scale factor. */
if|if
condition|(
operator|!
name|sscanf
argument_list|(
name|num_string
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|num
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"can't parse scale factor from '%s'"
argument_list|,
name|num_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|RESTORE_END_STRING
argument_list|(
name|base_string
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|num
condition|)
block|{
comment|/* must be 1 digit scale */
case|case
literal|1
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"expecting scale factor of 1, 2, 4, 8; got %d"
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|i
operator|.
name|index_reg
operator|&&
operator|*
name|base_string
operator|==
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"expecting index register or scale factor after ','; got '%c'"
argument_list|,
operator|*
operator|(
name|base_string
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
comment|/* If there's an expression begining the operand, parse it,        assuming displacement_string_start and displacement_string_end        are meaningful. */
if|if
condition|(
name|displacement_string_start
condition|)
block|{
specifier|register
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|segT
name|exp_seg
decl_stmt|;
name|char
modifier|*
name|save_input_line_pointer
decl_stmt|;
name|exp
operator|=
operator|&
name|disp_expressions
index|[
name|i
operator|.
name|disp_operands
index|]
expr_stmt|;
name|i
operator|.
name|disps
index|[
name|this_operand
index|]
operator|=
name|exp
expr_stmt|;
name|i
operator|.
name|disp_operands
operator|++
expr_stmt|;
name|save_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|displacement_string_start
expr_stmt|;
name|END_STRING_AND_SAVE
argument_list|(
name|displacement_string_end
argument_list|)
expr_stmt|;
name|exp_seg
operator|=
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
condition|)
name|as_bad
argument_list|(
literal|"Ignoring junk '%s' after expression"
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
name|RESTORE_END_STRING
argument_list|(
name|displacement_string_end
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save_input_line_pointer
expr_stmt|;
switch|switch
condition|(
name|exp_seg
condition|)
block|{
case|case
name|SEG_NONE
case|:
comment|/* missing expr becomes absolute 0 */
name|as_bad
argument_list|(
literal|"missing or invalid displacement '%s' taken as 0"
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
operator|(
name|Disp
operator||
name|Abs
operator|)
expr_stmt|;
name|exp
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
name|exp
operator|->
name|X_subtract_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
break|break;
case|case
name|SEG_ABSOLUTE
case|:
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|SMALLEST_DISP_TYPE
argument_list|(
name|exp
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEG_TEXT
case|:
case|case
name|SEG_DATA
case|:
case|case
name|SEG_BSS
case|:
case|case
name|SEG_UNKNOWN
case|:
comment|/* must be 32 bit displacement (i.e. address) */
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Disp32
expr_stmt|;
break|break;
default|default:
goto|goto
name|seg_unimplemented
goto|;
block|}
block|}
comment|/* Make sure the memory operand we've been dealt is valid. */
if|if
condition|(
name|i
operator|.
name|base_reg
operator|&&
name|i
operator|.
name|index_reg
operator|&&
operator|!
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
name|i
operator|.
name|index_reg
operator|->
name|reg_type
operator|&
name|Reg
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"register size mismatch in (base,index,scale) expression"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|i
operator|.
name|base_reg
operator|&&
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
name|Reg32
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|i
operator|.
name|index_reg
operator|&&
operator|(
name|i
operator|.
name|index_reg
operator|->
name|reg_type
operator|&
name|Reg32
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"base/index register must be 32 bit register"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|i
operator|.
name|index_reg
operator|&&
name|i
operator|.
name|index_reg
operator|==
name|esp
condition|)
block|{
name|as_bad
argument_list|(
literal|"%s may not be used as an index register"
argument_list|,
name|esp
operator|->
name|reg_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* it's not a memory operand; argh! */
name|as_bad
argument_list|(
literal|"invalid char %s begining %s operand '%s'"
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|op_string
argument_list|)
argument_list|,
name|ordinal_names
index|[
name|this_operand
index|]
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
comment|/* normal return */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			md_estimate_size_before_relax()  *  * Called just before relax().  * Any symbol that is now undefined will not become defined.  * Return the correct fr_subtype in the frag.  * Return the initial "guess for fr_var" to caller.  * The guess for fr_var is ACTUALLY the growth beyond fr_fix.  * Whatever we do to grow fr_fix or fr_var contributes to our returned value.  * Although it may not be explicit in the frag, pretend fr_var starts with a  * 0 value.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment_type
parameter_list|)
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
specifier|register
name|int
name|segment_type
decl_stmt|;
comment|/* N_DATA or N_TEXT. */
block|{
specifier|register
name|uchar
modifier|*
name|opcode
decl_stmt|;
specifier|register
name|int
name|old_fr_fix
decl_stmt|;
name|old_fr_fix
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|opcode
operator|=
operator|(
name|uchar
operator|*
operator|)
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
comment|/* We've already got fragP->fr_subtype right;  all we have to do is check      for un-relaxable symbols. */
if|if
condition|(
operator|(
name|fragP
operator|->
name|fr_symbol
operator|->
name|sy_type
operator|&
name|N_TYPE
operator|)
operator|!=
name|segment_type
condition|)
block|{
comment|/* symbol is undefined in this segment */
switch|switch
condition|(
name|opcode
index|[
literal|0
index|]
condition|)
block|{
case|case
name|JUMP_PC_RELATIVE
case|:
comment|/* make jmp (0xeb) a dword displacement jump */
name|opcode
index|[
literal|0
index|]
operator|=
literal|0xe9
expr_stmt|;
comment|/* dword disp jmp */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* This changes the byte-displacement jump 0x7N --> 	 the dword-displacement jump 0x0f8N */
name|opcode
index|[
literal|1
index|]
operator|=
name|opcode
index|[
literal|0
index|]
operator|+
literal|0x10
expr_stmt|;
name|opcode
index|[
literal|0
index|]
operator|=
name|TWO_BYTE_OPCODE_ESCAPE
expr_stmt|;
comment|/* two-byte escape */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|1
operator|+
literal|4
expr_stmt|;
comment|/* we've added an opcode byte */
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|+
literal|1
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fragP
operator|->
name|fr_var
operator|+
name|fragP
operator|->
name|fr_fix
operator|-
name|old_fr_fix
operator|)
return|;
block|}
end_function

begin_comment
comment|/* md_estimate_size_before_relax() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			md_convert_frag();  *  * Called after relax() is finished.  * In:	Address of frag.  *	fr_type == rs_machine_dependent.  *	fr_subtype is what the address relaxed to.  *  * Out:	Any fixSs and constants are set up.  *	Caller will turn frag into a ".space 0".  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|fragP
parameter_list|)
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
specifier|register
name|uchar
modifier|*
name|opcode
decl_stmt|;
name|uchar
modifier|*
name|where_to_put_displacement
decl_stmt|;
name|uint
name|target_address
decl_stmt|,
name|opcode_address
decl_stmt|;
name|uint
name|extension
decl_stmt|;
name|int
name|displacement_from_opcode_start
decl_stmt|;
name|opcode
operator|=
operator|(
name|uchar
operator|*
operator|)
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
comment|/* Address we want to reach in file space. */
name|target_address
operator|=
name|fragP
operator|->
name|fr_symbol
operator|->
name|sy_value
operator|+
name|fragP
operator|->
name|fr_offset
expr_stmt|;
comment|/* Address opcode resides at in file space. */
name|opcode_address
operator|=
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
expr_stmt|;
comment|/* Displacement from opcode start to fill into instruction. */
name|displacement_from_opcode_start
operator|=
name|target_address
operator|-
name|opcode_address
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP
argument_list|,
name|BYTE
argument_list|)
case|:
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|BYTE
argument_list|)
case|:
comment|/* don't have to change opcode */
name|extension
operator|=
literal|1
expr_stmt|;
comment|/* 1 opcode + 1 displacement */
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP
argument_list|,
name|WORD
argument_list|)
case|:
name|opcode
index|[
literal|1
index|]
operator|=
name|TWO_BYTE_OPCODE_ESCAPE
expr_stmt|;
name|opcode
index|[
literal|2
index|]
operator|=
name|opcode
index|[
literal|0
index|]
operator|+
literal|0x10
expr_stmt|;
name|opcode
index|[
literal|0
index|]
operator|=
name|WORD_PREFIX_OPCODE
expr_stmt|;
name|extension
operator|=
literal|4
expr_stmt|;
comment|/* 3 opcode + 2 displacement */
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|3
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|WORD
argument_list|)
case|:
name|opcode
index|[
literal|1
index|]
operator|=
literal|0xe9
expr_stmt|;
name|opcode
index|[
literal|0
index|]
operator|=
name|WORD_PREFIX_OPCODE
expr_stmt|;
name|extension
operator|=
literal|3
expr_stmt|;
comment|/* 2 opcode + 2 displacement */
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP
argument_list|,
name|DWORD
argument_list|)
case|:
name|opcode
index|[
literal|1
index|]
operator|=
name|opcode
index|[
literal|0
index|]
operator|+
literal|0x10
expr_stmt|;
name|opcode
index|[
literal|0
index|]
operator|=
name|TWO_BYTE_OPCODE_ESCAPE
expr_stmt|;
name|extension
operator|=
literal|5
expr_stmt|;
comment|/* 2 opcode + 4 displacement */
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|DWORD
argument_list|)
case|:
name|opcode
index|[
literal|0
index|]
operator|=
literal|0xe9
expr_stmt|;
name|extension
operator|=
literal|4
expr_stmt|;
comment|/* 1 opcode + 4 displacement */
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|1
index|]
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* now put displacement after opcode */
name|md_number_to_chars
argument_list|(
name|where_to_put_displacement
argument_list|,
name|displacement_from_opcode_start
operator|-
name|extension
argument_list|,
name|SIZE_FROM_RELAX_STATE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|extension
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|int
name|md_short_jump_size
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of byte displacement jmp */
end_comment

begin_decl_stmt
name|int
name|md_long_jump_size
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of dword displacement jmp */
end_comment

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|long
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
block|{
name|long
name|offset
decl_stmt|;
name|offset
operator|=
name|to_addr
operator|-
operator|(
name|from_addr
operator|+
literal|2
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|long
operator|)
literal|0xeb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* opcode for byte-disp jump */
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|long
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|long
name|offset
decl_stmt|;
if|if
condition|(
name|flagseen
index|[
literal|'m'
index|]
condition|)
block|{
name|offset
operator|=
name|to_addr
operator|-
name|to_symbol
operator|->
name|sy_value
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
literal|0xe9
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* opcode for long jmp */
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag
argument_list|,
operator|(
name|ptr
operator|+
literal|1
operator|)
operator|-
name|frag
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|to_symbol
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|long
name|int
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|to_addr
operator|-
operator|(
name|from_addr
operator|+
literal|5
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|long
operator|)
literal|0xe9
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|md_parse_option
parameter_list|(
name|argP
parameter_list|,
name|cntP
parameter_list|,
name|vecP
parameter_list|)
name|char
modifier|*
modifier|*
name|argP
decl_stmt|;
name|int
modifier|*
name|cntP
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|vecP
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
comment|/* Knows about order of bytes in address. */
name|md_number_to_chars
parameter_list|(
name|con
parameter_list|,
name|value
parameter_list|,
name|nbytes
parameter_list|)
name|char
name|con
index|[]
decl_stmt|;
comment|/* Return 'nbytes' of chars here. */
name|long
name|int
name|value
decl_stmt|;
comment|/* The value of the bits. */
name|int
name|nbytes
decl_stmt|;
comment|/* Number of bytes in the output. */
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|con
decl_stmt|;
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|1
case|:
name|p
index|[
literal|0
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|p
index|[
literal|0
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|p
index|[
literal|0
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
comment|/* Knows about order of bytes in address. */
name|md_number_to_disp
parameter_list|(
name|con
parameter_list|,
name|value
parameter_list|,
name|nbytes
parameter_list|)
name|char
name|con
index|[]
decl_stmt|;
comment|/* Return 'nbytes' of chars here. */
name|long
name|int
name|value
decl_stmt|;
comment|/* The value of the bits. */
name|int
name|nbytes
decl_stmt|;
comment|/* Number of bytes in the output. */
block|{
name|char
modifier|*
name|answer
init|=
name|alloca
argument_list|(
name|nbytes
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|answer
decl_stmt|;
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|1
case|:
operator|*
name|p
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|p
operator|++
operator|=
name|value
expr_stmt|;
operator|*
name|p
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
operator|*
name|p
operator|++
operator|=
name|value
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|value
operator|>>
literal|16
operator|)
expr_stmt|;
operator|*
name|p
operator|=
operator|(
name|value
operator|>>
literal|24
operator|)
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|answer
argument_list|,
name|con
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
comment|/* Knows about order of bytes in address. */
name|md_number_to_imm
parameter_list|(
name|con
parameter_list|,
name|value
parameter_list|,
name|nbytes
parameter_list|)
name|char
name|con
index|[]
decl_stmt|;
comment|/* Return 'nbytes' of chars here. */
name|long
name|int
name|value
decl_stmt|;
comment|/* The value of the bits. */
name|int
name|nbytes
decl_stmt|;
comment|/* Number of bytes in the output. */
block|{
name|char
modifier|*
name|answer
init|=
name|alloca
argument_list|(
name|nbytes
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|answer
decl_stmt|;
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|1
case|:
operator|*
name|p
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|p
operator|++
operator|=
name|value
expr_stmt|;
operator|*
name|p
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
operator|*
name|p
operator|++
operator|=
name|value
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|value
operator|>>
literal|16
operator|)
expr_stmt|;
operator|*
name|p
operator|=
operator|(
name|value
operator|>>
literal|24
operator|)
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|answer
argument_list|,
name|con
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
comment|/* Knows about order of bytes in address. */
name|md_number_to_field
parameter_list|(
name|con
parameter_list|,
name|value
parameter_list|,
name|nbytes
parameter_list|)
name|char
name|con
index|[]
decl_stmt|;
comment|/* Return 'nbytes' of chars here. */
name|long
name|int
name|value
decl_stmt|;
comment|/* The value of the bits. */
name|int
name|nbytes
decl_stmt|;
comment|/* Number of bytes in the output. */
block|{
name|char
modifier|*
name|answer
init|=
name|alloca
argument_list|(
name|nbytes
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
init|=
name|answer
decl_stmt|;
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|1
case|:
operator|*
name|p
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|p
operator|++
operator|=
name|value
expr_stmt|;
operator|*
name|p
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
operator|*
name|p
operator|++
operator|=
name|value
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|value
operator|>>
literal|16
operator|)
expr_stmt|;
operator|*
name|p
operator|=
operator|(
name|value
operator|>>
literal|24
operator|)
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|answer
argument_list|,
name|con
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|long
name|int
comment|/* Knows about the byte order in a word. */
name|md_chars_to_number
parameter_list|(
name|con
parameter_list|,
name|nbytes
parameter_list|)
name|unsigned
name|char
name|con
index|[]
decl_stmt|;
comment|/* Low order byte 1st. */
name|int
name|nbytes
decl_stmt|;
comment|/* Number of bytes in the input. */
block|{
name|long
name|int
name|retval
decl_stmt|;
for|for
control|(
name|retval
operator|=
literal|0
operator|,
name|con
operator|+=
name|nbytes
operator|-
literal|1
init|;
name|nbytes
operator|--
condition|;
name|con
operator|--
control|)
block|{
name|retval
operator|<<=
name|BITS_PER_CHAR
expr_stmt|;
name|retval
operator||=
operator|*
name|con
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
name|void
name|md_ri_to_chars
parameter_list|(
name|ri_p
parameter_list|,
name|ri
parameter_list|)
name|struct
name|relocation_info
modifier|*
name|ri_p
decl_stmt|,
name|ri
decl_stmt|;
block|{
name|unsigned
name|char
name|the_bytes
index|[
literal|8
index|]
decl_stmt|;
comment|/* this is easy */
name|md_number_to_chars
argument_list|(
name|the_bytes
argument_list|,
name|ri
operator|.
name|r_address
argument_list|,
sizeof|sizeof
argument_list|(
name|ri
operator|.
name|r_address
argument_list|)
argument_list|)
expr_stmt|;
comment|/* now the fun stuff */
name|the_bytes
index|[
literal|6
index|]
operator|=
operator|(
name|ri
operator|.
name|r_symbolnum
operator|>>
literal|16
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|the_bytes
index|[
literal|5
index|]
operator|=
operator|(
name|ri
operator|.
name|r_symbolnum
operator|>>
literal|8
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|the_bytes
index|[
literal|4
index|]
operator|=
name|ri
operator|.
name|r_symbolnum
operator|&
literal|0x0ff
expr_stmt|;
name|the_bytes
index|[
literal|7
index|]
operator|=
operator|(
operator|(
operator|(
name|ri
operator|.
name|r_extern
operator|<<
literal|3
operator|)
operator|&
literal|0x08
operator|)
operator||
operator|(
operator|(
name|ri
operator|.
name|r_length
operator|<<
literal|1
operator|)
operator|&
literal|0x06
operator|)
operator||
operator|(
operator|(
name|ri
operator|.
name|r_pcrel
operator|<<
literal|0
operator|)
operator|&
literal|0x01
operator|)
operator|)
operator|&
literal|0x0F
expr_stmt|;
comment|/* now put it back where you found it */
name|bcopy
argument_list|(
name|the_bytes
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ri_p
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_comment
comment|/* Turn the string pointed to by litP into a floating point constant of type    type, and emit the appropriate bytes.  The number of LITTLENUMS emitted    is stored in *sizeP .  An error message is returned, or NULL on OK.  */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|atof_ieee
parameter_list|()
function_decl|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
literal|"Bad call to md_atof ()"
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
comment|/* this loops outputs the LITTLENUMs in REVERSE order; in accord with      the bigendian 386 */
for|for
control|(
name|wordP
operator|=
name|words
operator|+
name|prec
operator|-
literal|1
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|wordP
operator|--
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
comment|/* Someone should teach Dean about null pointers */
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|char
name|output_invalid_buf
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|output_invalid
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|sprintf
argument_list|(
name|output_invalid_buf
argument_list|,
literal|"'%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|output_invalid_buf
argument_list|,
literal|"(0x%x)"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|output_invalid_buf
return|;
block|}
end_function

begin_function
name|reg_entry
modifier|*
name|parse_register
parameter_list|(
name|reg_string
parameter_list|)
name|char
modifier|*
name|reg_string
decl_stmt|;
comment|/* reg_string starts *before* REGISTER_PREFIX */
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|reg_string
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|reg_name_given
index|[
name|MAX_REG_NAME_SIZE
index|]
decl_stmt|;
name|s
operator|++
expr_stmt|;
comment|/* skip REGISTER_PREFIX */
for|for
control|(
name|p
operator|=
name|reg_name_given
init|;
name|is_register_char
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|p
operator|++
operator|,
name|s
operator|++
control|)
block|{
operator|*
name|p
operator|=
name|register_chars
index|[
operator|*
name|s
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|reg_name_given
operator|+
name|MAX_REG_NAME_SIZE
condition|)
return|return
operator|(
name|reg_entry
operator|*
operator|)
literal|0
return|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
name|reg_name_given
argument_list|)
return|;
block|}
end_function

end_unit

