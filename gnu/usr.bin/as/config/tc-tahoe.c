begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-tahoe.c    Not part of GAS yet. */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* this bit glommed from tahoe-inst.h */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|char
name|byte
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|byte
name|tahoe_opcodeT
typedef|;
end_typedef

begin_comment
comment|/*  * This is part of tahoe-ins-parse.c& friends.  * We want to parse a tahoe instruction text into a tree defined here.  */
end_comment

begin_define
define|#
directive|define
name|TIT_MAX_OPERANDS
value|(4)
end_define

begin_comment
comment|/* maximum number of operands in one 				   single tahoe instruction */
end_comment

begin_struct
struct|struct
name|top
comment|/* tahoe instruction operand */
block|{
name|int
name|top_ndx
decl_stmt|;
comment|/* -1, or index register. eg 7=[R7] */
name|int
name|top_reg
decl_stmt|;
comment|/* -1, or register number. eg 7 = R7 or (R7) */
name|byte
name|top_mode
decl_stmt|;
comment|/* Addressing mode byte. This byte, defines 				   which of the 11 modes opcode is. */
name|char
name|top_access
decl_stmt|;
comment|/* Access type wanted for this opperand 				   'b'branch ' 'no-instruction 'amrvw' */
name|char
name|top_width
decl_stmt|;
comment|/* Operand width expected, one of "bwlq?-:!" */
name|char
modifier|*
name|top_error
decl_stmt|;
comment|/* Say if operand is inappropriate         */
name|expressionS
name|exp_of_operand
decl_stmt|;
comment|/* The expression as parsed by expression()*/
name|byte
name|top_dispsize
decl_stmt|;
comment|/* Number of bytes in the displacement if we 				   can figure it out */
block|}
struct|;
end_struct

begin_comment
comment|/* The addressing modes for an operand. These numbers are the acutal values    for certain modes, so be carefull if you screw with them. */
end_comment

begin_define
define|#
directive|define
name|TAHOE_DIRECT_REG
value|(0x50)
end_define

begin_define
define|#
directive|define
name|TAHOE_REG_DEFERRED
value|(0x60)
end_define

begin_define
define|#
directive|define
name|TAHOE_REG_DISP
value|(0xE0)
end_define

begin_define
define|#
directive|define
name|TAHOE_REG_DISP_DEFERRED
value|(0xF0)
end_define

begin_define
define|#
directive|define
name|TAHOE_IMMEDIATE
value|(0x8F)
end_define

begin_define
define|#
directive|define
name|TAHOE_IMMEDIATE_BYTE
value|(0x88)
end_define

begin_define
define|#
directive|define
name|TAHOE_IMMEDIATE_WORD
value|(0x89)
end_define

begin_define
define|#
directive|define
name|TAHOE_IMMEDIATE_LONGWORD
value|(0x8F)
end_define

begin_define
define|#
directive|define
name|TAHOE_ABSOLUTE_ADDR
value|(0x9F)
end_define

begin_define
define|#
directive|define
name|TAHOE_DISPLACED_RELATIVE
value|(0xEF)
end_define

begin_define
define|#
directive|define
name|TAHOE_DISP_REL_DEFERRED
value|(0xFF)
end_define

begin_define
define|#
directive|define
name|TAHOE_AUTO_DEC
value|(0x7E)
end_define

begin_define
define|#
directive|define
name|TAHOE_AUTO_INC
value|(0x8E)
end_define

begin_define
define|#
directive|define
name|TAHOE_AUTO_INC_DEFERRED
value|(0x9E)
end_define

begin_comment
comment|/* INDEXED_REG is decided by the existance or lack of a [reg] */
end_comment

begin_comment
comment|/* These are encoded into top_width when top_access=='b'    and it's a psuedo op.*/
end_comment

begin_define
define|#
directive|define
name|TAHOE_WIDTH_ALWAYS_JUMP
value|'-'
end_define

begin_define
define|#
directive|define
name|TAHOE_WIDTH_CONDITIONAL_JUMP
value|'?'
end_define

begin_define
define|#
directive|define
name|TAHOE_WIDTH_BIG_REV_JUMP
value|'!'
end_define

begin_define
define|#
directive|define
name|TAHOE_WIDTH_BIG_NON_REV_JUMP
value|':'
end_define

begin_comment
comment|/* The hex code for certain tahoe commands and modes.    This is just for readability. */
end_comment

begin_define
define|#
directive|define
name|TAHOE_JMP
value|(0x71)
end_define

begin_define
define|#
directive|define
name|TAHOE_PC_REL_LONG
value|(0xEF)
end_define

begin_define
define|#
directive|define
name|TAHOE_BRB
value|(0x11)
end_define

begin_define
define|#
directive|define
name|TAHOE_BRW
value|(0x13)
end_define

begin_comment
comment|/* These, when 'ored' with, or added to, a register number,    set up the number for the displacement mode. */
end_comment

begin_define
define|#
directive|define
name|TAHOE_PC_OR_BYTE
value|(0xA0)
end_define

begin_define
define|#
directive|define
name|TAHOE_PC_OR_WORD
value|(0xC0)
end_define

begin_define
define|#
directive|define
name|TAHOE_PC_OR_LONG
value|(0xE0)
end_define

begin_struct
struct|struct
name|tit
comment|/* get it out of the sewer, it stands for 				   tahoe instruction tree (Geeze!) */
block|{
name|tahoe_opcodeT
name|tit_opcode
decl_stmt|;
comment|/* The opcode. */
name|byte
name|tit_operands
decl_stmt|;
comment|/* How many operands are here. */
name|struct
name|top
name|tit_operand
index|[
name|TIT_MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Operands */
name|char
modifier|*
name|tit_error
decl_stmt|;
comment|/* "" or fatal error text */
block|}
struct|;
end_struct

begin_comment
comment|/* end: tahoe-inst.h */
end_comment

begin_comment
comment|/* tahoe.c - tahoe-specific -    Not part of gas yet.    */
end_comment

begin_include
include|#
directive|include
file|"opcode/tahoe.h"
end_include

begin_comment
comment|/* This is the number to put at the beginning of the a.out file */
end_comment

begin_decl_stmt
name|long
name|omagic
init|=
name|OMAGIC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These chars start a comment anywhere in a source file (except inside    another comment or a quoted string. */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#;"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These chars only start a comment at the beginning of a line. */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant    as in 0f123.456    or    0d1.234E-12 (see exp chars above)    Note: The Tahoe port doesn't support floating point constants. This is          consistant with 'as' If it's needed, I can always add it later. */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"df"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be    changed in read.c .  Ideally it shouldn't have to know about it at all,    but nothing is ideal around here.    (The tahoe has plenty of room, so the change currently isn't needed.)    */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|tit
name|t
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A tahoe instruction after decoding. */
end_comment

begin_function_decl
name|void
name|float_cons
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* A table of pseudo ops (sans .), the function called, and an integer op    that the function is called with. */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"dfloat"
block|,
name|float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"ffloat"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  * For Tahoe, relative addresses of "just the right length" are pretty easy.  * The branch displacement is always the last operand, even in  * synthetic instructions.  * For Tahoe, we encode the relax_substateTs (in e.g. fr_substate) as:  *  *		    4       3       2       1       0	     bit number  *	---/ /--+-------+-------+-------+-------+-------+  *		|     what state ?	|  how long ?	|  *	---/ /--+-------+-------+-------+-------+-------+  *  * The "how long" bits are 00=byte, 01=word, 10=long.  * This is a Un*x convention.  * Not all lengths are legit for a given value of (what state).  * The four states are listed below.  * The "how long" refers merely to the displacement length.  * The address usually has some constant bytes in it as well.  *  States for Tahoe address relaxing. 1.	TAHOE_WIDTH_ALWAYS_JUMP (-) 	Format: "b-" 	Tahoe opcodes are:	(Hex) 		jr		11 		jbr		11 	Simple branch. 	Always, 1 byte opcode, then displacement/absolute. 	If word or longword, change opcode to brw or jmp.   2.	TAHOE_WIDTH_CONDITIONAL_JUMP (?) 	J<cond> where<cond> is a simple flag test. 	Format: "b?" 	Tahoe opcodes are:	(Hex) 		jneq/jnequ	21 		jeql/jeqlu	31 		jgtr		41 		jleq		51 		jgeq		81 		jlss		91 		jgtru		a1 		jlequ		b1 		jvc		c1 		jvs		d1 		jlssu/jcs	e1 		jgequ/jcc	f1 	Always, you complement 4th bit to reverse the condition. 	Always, 1-byte opcode, then 1-byte displacement.  3.	TAHOE_WIDTH_BIG_REV_JUMP (!) 	Jbc/Jbs where cond tests a memory bit. 	Format: "rlvlb!" 	Tahoe opcodes are:	(Hex) 		jbs		0e 		jbc		1e 	Always, you complement 4th bit to reverse the condition. 	Always, 1-byte opcde, longword, longword-address, 1-word-displacement  4.	TAHOE_WIDTH_BIG_NON_REV_JUMP (:) 	JaoblXX/Jbssi 	Format: "rlmlb:" 	Tahoe opcodes are:	(Hex) 		aojlss		2f 		jaoblss		2f 		aojleq		3f 		jaobleq		3f 		jbssi		5f 	Always, we cannot reverse the sense of the branch; we have a word 	displacement.  We need to modify the opcode is for class 1, 2 and 3 instructions. After relax() we may complement the 4th bit of 2 or 3 to reverse sense of branch.  We sometimes store context in the operand literal. This way we can figure out after relax() what the original addressing mode was. (Was is pc_rel, or pc_rel_disp? That sort of thing.) */
end_comment

begin_escape
end_escape

begin_comment
comment|/* These displacements are relative to the START address of the    displacement which is at the start of the displacement, not the end of    the instruction. The hardware pc_rel is at the end of the instructions.    That's why all the displacements have the length of the displacement added    to them. (WF + length(word))     The first letter is Byte, Word.    2nd letter is Forward, Backward. */
end_comment

begin_define
define|#
directive|define
name|BF
value|(1+ 127)
end_define

begin_define
define|#
directive|define
name|BB
value|(1+-128)
end_define

begin_define
define|#
directive|define
name|WF
value|(2+ 32767)
end_define

begin_define
define|#
directive|define
name|WB
value|(2+-32768)
end_define

begin_comment
comment|/* Dont need LF, LB because they always reach. [They are coded as 0.] */
end_comment

begin_define
define|#
directive|define
name|C
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|ENCODE_RELAX(a,b)
end_define

begin_comment
comment|/* This macro has no side-effects. */
end_comment

begin_define
define|#
directive|define
name|ENCODE_RELAX
parameter_list|(
name|what
parameter_list|,
name|length
parameter_list|)
value|(((what)<< 2) + (length))
end_define

begin_define
define|#
directive|define
name|RELAX_STATE
parameter_list|(
name|what
parameter_list|)
value|((what)>> 2)
end_define

begin_define
define|#
directive|define
name|RELAX_LENGTH
parameter_list|(
name|length
parameter_list|)
value|((length)&& 3)
end_define

begin_define
define|#
directive|define
name|STATE_ALWAYS_BRANCH
value|(1)
end_define

begin_define
define|#
directive|define
name|STATE_CONDITIONAL_BRANCH
value|(2)
end_define

begin_define
define|#
directive|define
name|STATE_BIG_REV_BRANCH
value|(3)
end_define

begin_define
define|#
directive|define
name|STATE_BIG_NON_REV_BRANCH
value|(4)
end_define

begin_define
define|#
directive|define
name|STATE_PC_RELATIVE
value|(5)
end_define

begin_define
define|#
directive|define
name|STATE_BYTE
value|(0)
end_define

begin_define
define|#
directive|define
name|STATE_WORD
value|(1)
end_define

begin_define
define|#
directive|define
name|STATE_LONG
value|(2)
end_define

begin_define
define|#
directive|define
name|STATE_UNDF
value|(3)
end_define

begin_comment
comment|/* Symbol undefined in pass1 */
end_comment

begin_comment
comment|/* This is the table used by gas to figure out relaxing modes. The fields are    forward_branch reach, backward_branch reach, number of bytes it would take,    where the next biggest branch is. */
end_comment

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* error sentinel   0,0	*/
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    0,1	*/
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    0,2	*/
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    0,3	*/
comment|/* Unconditional branch cases "jrb"      The relax part is the actual displacement */
block|{
name|BF
block|,
name|BB
block|,
literal|1
block|,
name|C
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|}
block|,
comment|/* brb B`foo	    1,0 */
block|{
name|WF
block|,
name|WB
block|,
literal|2
block|,
name|C
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|}
block|,
comment|/* brw W`foo	    1,1 */
block|{
literal|0
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|}
block|,
comment|/* Jmp L`foo	    1,2 */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    1,3 */
comment|/* Reversible Conditional Branch. If the branch won't reach, reverse      it, and jump over a brw or a jmp that will reach. The relax part is the      actual address. */
block|{
name|BF
block|,
name|BB
block|,
literal|1
block|,
name|C
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|}
block|,
comment|/* b<cond> B`foo    2,0 */
block|{
name|WF
operator|+
literal|2
block|,
name|WB
operator|+
literal|2
block|,
literal|4
block|,
name|C
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|}
block|,
comment|/* brev over, brw W`foo, over: 2,1 */
block|{
literal|0
block|,
literal|0
block|,
literal|7
block|,
literal|0
block|}
block|,
comment|/* brev over, jmp L`foo, over: 2,2 */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    2,3 */
comment|/* Another type of reversable branch. But this only has a word      displacement. */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    3,0 */
block|{
name|WF
block|,
name|WB
block|,
literal|2
block|,
name|C
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
block|}
block|,
comment|/* jbX W`foo	    3,1 */
block|{
literal|0
block|,
literal|0
block|,
literal|8
block|,
literal|0
block|}
block|,
comment|/* jrevX over, jmp L`foo, over:  3,2 */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    3,3 */
comment|/* These are the non reversable branches, all of which have a word      displacement. If I can't reach, branch over a byte branch, to a      jump that will reach. The jumped branch jumps over the reaching      branch, to continue with the flow of the program. It's like playing      leap frog. */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    4,0 */
block|{
name|WF
block|,
name|WB
block|,
literal|2
block|,
name|C
argument_list|(
literal|4
argument_list|,
literal|2
argument_list|)
block|}
block|,
comment|/* aobl_ W`foo	    4,1 */
block|{
literal|0
block|,
literal|0
block|,
literal|10
block|,
literal|0
block|}
block|,
comment|/*aobl_ W`hop,br over,hop: jmp L^foo,over 4,2*/
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    4,3 */
comment|/* Normal displacement mode, no jumping or anything like that.      The relax points to one byte before the address, thats why all      the numbers are up by one. */
block|{
name|BF
operator|+
literal|1
block|,
name|BB
operator|+
literal|1
block|,
literal|2
block|,
name|C
argument_list|(
literal|5
argument_list|,
literal|1
argument_list|)
block|}
block|,
comment|/* B^"foo"	    5,0 */
block|{
name|WF
operator|+
literal|1
block|,
name|WB
operator|+
literal|1
block|,
literal|3
block|,
name|C
argument_list|(
literal|5
argument_list|,
literal|2
argument_list|)
block|}
block|,
comment|/* W^"foo"	    5,1 */
block|{
literal|0
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|}
block|,
comment|/* L^"foo"	    5,2 */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    5,3 */
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|C
end_undef

begin_undef
undef|#
directive|undef
name|BF
end_undef

begin_undef
undef|#
directive|undef
name|BB
end_undef

begin_undef
undef|#
directive|undef
name|WF
end_undef

begin_undef
undef|#
directive|undef
name|WB
end_undef

begin_comment
comment|/* End relax stuff */
end_comment

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* handle of the OPCODE hash table 						   NULL means any use before md_begin() will 						   crash */
end_comment

begin_comment
comment|/* Init function. Build the hash table. */
end_comment

begin_function
name|void
name|md_begin
parameter_list|()
block|{
name|struct
name|tot
modifier|*
name|tP
decl_stmt|;
name|char
modifier|*
name|errorval
init|=
literal|""
decl_stmt|;
name|int
name|synthetic_too
init|=
literal|1
decl_stmt|;
comment|/* If 0, just use real opcodes. */
if|if
condition|(
operator|(
name|op_hash
operator|=
name|hash_new
argument_list|()
operator|)
condition|)
block|{
for|for
control|(
name|tP
operator|=
name|totstrs
init|;
operator|*
name|tP
operator|->
name|name
operator|&&
operator|!
operator|*
name|errorval
condition|;
name|tP
operator|++
control|)
block|{
name|errorval
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|tP
operator|->
name|name
argument_list|,
operator|&
name|tP
operator|->
name|detail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|synthetic_too
condition|)
block|{
for|for
control|(
name|tP
operator|=
name|synthetic_totstrs
init|;
operator|*
name|tP
operator|->
name|name
operator|&&
operator|!
operator|*
name|errorval
condition|;
name|tP
operator|++
control|)
block|{
name|errorval
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|tP
operator|->
name|name
argument_list|,
operator|&
name|tP
operator|->
name|detail
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|errorval
operator|=
literal|"Virtual memory exceeded"
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|errorval
condition|)
name|as_fatal
argument_list|(
name|errorval
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* md_begin */
end_comment

begin_function
name|void
name|md_end
parameter_list|()
block|{ }
end_function

begin_comment
comment|/* md_end */
end_comment

begin_escape
end_escape

begin_function
name|int
name|md_parse_option
parameter_list|(
name|argP
parameter_list|,
name|cntP
parameter_list|,
name|vecP
parameter_list|)
name|char
modifier|*
modifier|*
name|argP
decl_stmt|;
name|int
modifier|*
name|cntP
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|vecP
decl_stmt|;
block|{
name|char
modifier|*
name|temp_name
decl_stmt|;
comment|/* name for -t or -d options */
name|char
name|opt
decl_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|argP
condition|)
block|{
case|case
literal|'a'
case|:
name|as_warn
argument_list|(
literal|"The -a option doesn't exits. (Dispite what the man page says!"
argument_list|)
expr_stmt|;
case|case
literal|'J'
case|:
name|as_warn
argument_list|(
literal|"JUMPIFY (-J) not implemented, use psuedo ops instead."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|as_warn
argument_list|(
literal|"SYMBOL TABLE not implemented"
argument_list|)
expr_stmt|;
break|break;
comment|/* SYMBOL TABLE not implemented */
case|case
literal|'T'
case|:
name|as_warn
argument_list|(
literal|"TOKEN TRACE not implemented"
argument_list|)
expr_stmt|;
break|break;
comment|/* TOKEN TRACE not implemented */
case|case
literal|'d'
case|:
case|case
literal|'t'
case|:
name|opt
operator|=
operator|*
operator|*
name|argP
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|argP
condition|)
block|{
comment|/* Rest of argument is filename. */
name|temp_name
operator|=
operator|*
name|argP
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|argP
condition|)
operator|(
operator|*
name|argP
operator|)
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cntP
condition|)
block|{
while|while
condition|(
operator|*
operator|*
name|argP
condition|)
operator|(
operator|*
name|argP
operator|)
operator|++
expr_stmt|;
operator|--
operator|(
operator|*
name|cntP
operator|)
expr_stmt|;
name|temp_name
operator|=
operator|*
operator|++
operator|(
operator|*
name|vecP
operator|)
expr_stmt|;
operator|*
operator|*
name|vecP
operator|=
name|NULL
expr_stmt|;
comment|/* Remember this is not a file-name. */
block|}
else|else
block|{
name|as_warn
argument_list|(
literal|"I expected a filename after -%c."
argument_list|,
name|opt
argument_list|)
expr_stmt|;
name|temp_name
operator|=
literal|"{absent}"
expr_stmt|;
block|}
if|if
condition|(
name|opt
operator|==
literal|'d'
condition|)
name|as_warn
argument_list|(
literal|"Displacement length %s ignored!"
argument_list|,
name|temp_name
argument_list|)
expr_stmt|;
else|else
name|as_warn
argument_list|(
literal|"I don't need or use temp. file \"%s\"."
argument_list|,
name|temp_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|as_warn
argument_list|(
literal|"I don't use an interpass file! -V ignored"
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The functions in this section take numbers in the machine format, and    munges them into Tahoe byte order.    They exist primarily for cross assembly purpose. */
end_comment

begin_function
name|void
comment|/* Knows about order of bytes in address. */
name|md_number_to_chars
parameter_list|(
name|con
parameter_list|,
name|value
parameter_list|,
name|nbytes
parameter_list|)
name|char
name|con
index|[]
decl_stmt|;
comment|/* Return 'nbytes' of chars here. */
name|long
name|int
name|value
decl_stmt|;
comment|/* The value of the bits. */
name|int
name|nbytes
decl_stmt|;
comment|/* Number of bytes in the output. */
block|{
name|int
name|n
init|=
name|nbytes
decl_stmt|;
name|long
name|int
name|v
init|=
name|value
decl_stmt|;
name|con
operator|+=
name|nbytes
operator|-
literal|1
expr_stmt|;
comment|/* Tahoes is (Bleah!) big endian */
while|while
condition|(
name|nbytes
operator|--
condition|)
block|{
operator|*
name|con
operator|--
operator|=
name|value
expr_stmt|;
comment|/* Lint wants& MASK_CHAR. */
name|value
operator|>>=
name|BITS_PER_CHAR
expr_stmt|;
block|}
comment|/* XXX line number probably botched for this warning message. */
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|value
operator|!=
operator|-
literal|1
condition|)
name|as_warn
argument_list|(
literal|"Displacement (%ld) long for instruction field length (%d)."
argument_list|,
name|v
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|comment
end_ifdef

begin_function
name|void
comment|/* Knows about order of bytes in address. */
name|md_number_to_imm
parameter_list|(
name|con
parameter_list|,
name|value
parameter_list|,
name|nbytes
parameter_list|)
name|char
name|con
index|[]
decl_stmt|;
comment|/* Return 'nbytes' of chars here. */
name|long
name|int
name|value
decl_stmt|;
comment|/* The value of the bits. */
name|int
name|nbytes
decl_stmt|;
comment|/* Number of bytes in the output. */
block|{
name|md_number_to_chars
argument_list|(
name|con
argument_list|,
name|value
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* comment */
end_comment

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixP
parameter_list|,
name|val
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|long
name|val
decl_stmt|;
block|{
name|char
modifier|*
name|place
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|md_number_to_chars
argument_list|(
name|place
argument_list|,
name|val
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* md_apply_fix() */
end_comment

begin_function
name|void
comment|/* Knows about order of bytes in address. */
name|md_number_to_disp
parameter_list|(
name|con
parameter_list|,
name|value
parameter_list|,
name|nbytes
parameter_list|)
name|char
name|con
index|[]
decl_stmt|;
comment|/* Return 'nbytes' of chars here. */
name|long
name|int
name|value
decl_stmt|;
comment|/* The value of the bits. */
name|int
name|nbytes
decl_stmt|;
comment|/* Number of bytes in the output. */
block|{
name|md_number_to_chars
argument_list|(
name|con
argument_list|,
name|value
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
comment|/* Knows about order of bytes in address. */
name|md_number_to_field
parameter_list|(
name|con
parameter_list|,
name|value
parameter_list|,
name|nbytes
parameter_list|)
name|char
name|con
index|[]
decl_stmt|;
comment|/* Return 'nbytes' of chars here. */
name|long
name|int
name|value
decl_stmt|;
comment|/* The value of the bits. */
name|int
name|nbytes
decl_stmt|;
comment|/* Number of bytes in the output. */
block|{
name|md_number_to_chars
argument_list|(
name|con
argument_list|,
name|value
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put the bits in an order that a tahoe will understand, despite the ordering    of the native machine.    On Tahoe: first 4 bytes are normal unsigned big endian long,    next three bytes are symbolnum, in kind of 3 byte big endian (least sig. byte last).    The last byte is broken up with bit 7 as pcrel,    	bits 6& 5 as length, 	bit 4 as extern and the last nibble as 'undefined'. */
end_comment

begin_if
if|#
directive|if
name|comment
end_if

begin_function
name|void
name|md_ri_to_chars
parameter_list|(
name|ri_p
parameter_list|,
name|ri
parameter_list|)
name|struct
name|relocation_info
modifier|*
name|ri_p
decl_stmt|,
name|ri
decl_stmt|;
block|{
name|byte
name|the_bytes
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
index|]
decl_stmt|;
comment|/* The reason I can't just encode these directly into ri_p is that      ri_p may point to ri. */
comment|/* This is easy */
name|md_number_to_chars
argument_list|(
name|the_bytes
argument_list|,
name|ri
operator|.
name|r_address
argument_list|,
sizeof|sizeof
argument_list|(
name|ri
operator|.
name|r_address
argument_list|)
argument_list|)
expr_stmt|;
comment|/* now the fun stuff */
name|the_bytes
index|[
literal|4
index|]
operator|=
operator|(
name|ri
operator|.
name|r_symbolnum
operator|>>
literal|16
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|the_bytes
index|[
literal|5
index|]
operator|=
operator|(
name|ri
operator|.
name|r_symbolnum
operator|>>
literal|8
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|the_bytes
index|[
literal|6
index|]
operator|=
name|ri
operator|.
name|r_symbolnum
operator|&
literal|0x0ff
expr_stmt|;
name|the_bytes
index|[
literal|7
index|]
operator|=
operator|(
operator|(
operator|(
name|ri
operator|.
name|r_extern
operator|<<
literal|4
operator|)
operator|&
literal|0x10
operator|)
operator||
operator|(
operator|(
name|ri
operator|.
name|r_length
operator|<<
literal|5
operator|)
operator|&
literal|0x60
operator|)
operator||
operator|(
operator|(
name|ri
operator|.
name|r_pcrel
operator|<<
literal|7
operator|)
operator|&
literal|0x80
operator|)
operator|)
operator|&
literal|0xf0
expr_stmt|;
name|bcopy
argument_list|(
name|the_bytes
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ri_p
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* comment */
end_comment

begin_comment
comment|/* Put the bits in an order that a tahoe will understand, despite the ordering    of the native machine.    On Tahoe: first 4 bytes are normal unsigned big endian long,    next three bytes are symbolnum, in kind of 3 byte big endian (least sig. byte last).    The last byte is broken up with bit 7 as pcrel,    	bits 6& 5 as length, 	bit 4 as extern and the last nibble as 'undefined'. */
end_comment

begin_function
name|void
name|tc_aout_fix_to_chars
parameter_list|(
name|where
parameter_list|,
name|fixP
parameter_list|,
name|segment_address_in_file
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|relax_addressT
name|segment_address_in_file
decl_stmt|;
block|{
comment|/* 	 * In: length of relocation (or of address) in chars: 1, 2 or 4. 	 * Out: GNU LD relocation length code: 0, 1, or 2. 	 */
specifier|static
name|unsigned
name|char
name|nbytes_r_length
index|[]
init|=
block|{
literal|42
block|,
literal|0
block|,
literal|1
block|,
literal|42
block|,
literal|2
block|}
decl_stmt|;
name|long
name|r_symbolnum
decl_stmt|;
name|know
argument_list|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|segment_address_in_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|r_symbolnum
operator|=
operator|(
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|?
name|S_GET_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
else|:
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_number
operator|)
expr_stmt|;
name|where
index|[
literal|4
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|16
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|5
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|8
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|6
index|]
operator|=
name|r_symbolnum
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|7
index|]
operator|=
operator|(
operator|(
operator|(
name|fixP
operator|->
name|fx_pcrel
operator|<<
literal|7
operator|)
operator|&
literal|0x80
operator|)
operator||
operator|(
operator|(
name|nbytes_r_length
index|[
name|fixP
operator|->
name|fx_size
index|]
operator|<<
literal|5
operator|)
operator|&
literal|0x60
operator|)
operator||
operator|(
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|<<
literal|4
operator|)
operator|&
literal|0x10
operator|)
operator|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tc_aout_fix_to_chars() */
end_comment

begin_comment
comment|/* Relocate byte stuff */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This is for broken word. */
end_comment

begin_decl_stmt
specifier|const
name|int
name|md_short_jump_size
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|long
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|long
name|offset
decl_stmt|;
name|offset
operator|=
name|to_addr
operator|-
operator|(
name|from_addr
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|TAHOE_BRW
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
name|offset
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|int
name|md_long_jump_size
init|=
literal|6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of relocation record */
end_comment

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|long
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|long
name|offset
decl_stmt|;
name|offset
operator|=
name|to_addr
operator|-
operator|(
name|from_addr
operator|+
literal|4
operator|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|TAHOE_JMP
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|TAHOE_PC_REL_LONG
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			md_estimate_size_before_relax()  *  * Called just before relax().  * Any symbol that is now undefined will not become defined, so we assumed  * that it will be resolved by the linker.  * Return the correct fr_subtype in the frag, for relax()  * Return the initial "guess for fr_var" to caller. (How big I think this  * will be.)  * The guess for fr_var is ACTUALLY the growth beyond fr_fix.  * Whatever we do to grow fr_fix or fr_var contributes to our returned value.  * Although it may not be explicit in the frag, pretend fr_var starts with a  * 0 value.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment_type
parameter_list|)
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|segT
name|segment_type
decl_stmt|;
comment|/* N_DATA or N_TEXT. */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|old_fr_fix
decl_stmt|;
comment|/*  int pc_rel; FIXME: remove this */
name|old_fr_fix
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_PC_RELATIVE
argument_list|,
name|STATE_UNDF
argument_list|)
case|:
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment_type
condition|)
block|{
comment|/* The symbol was in the same segment as the opcode, and it's 	 a real pc_rel case so it's a relaxable case. */
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_PC_RELATIVE
argument_list|,
name|STATE_BYTE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This case is still undefined, so asume it's a long word for the 	 linker to fix. */
name|p
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|old_fr_fix
expr_stmt|;
operator|*
name|p
operator||=
name|TAHOE_PC_OR_LONG
expr_stmt|;
comment|/* We now know how big it will be, one long word. */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|1
operator|+
literal|4
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|+
literal|1
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH
argument_list|,
name|STATE_UNDF
argument_list|)
case|:
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment_type
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH
argument_list|,
name|STATE_BYTE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|old_fr_fix
expr_stmt|;
operator|*
name|fragP
operator|->
name|fr_opcode
operator|^=
literal|0x10
expr_stmt|;
comment|/* Reverse sense of branch. */
operator|*
name|p
operator|++
operator|=
literal|6
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|TAHOE_JMP
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|TAHOE_PC_REL_LONG
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|1
operator|+
literal|1
operator|+
literal|1
operator|+
literal|4
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|+
literal|3
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_BIG_REV_BRANCH
argument_list|,
name|STATE_UNDF
argument_list|)
case|:
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment_type
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_BIG_REV_BRANCH
argument_list|,
name|STATE_WORD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|old_fr_fix
expr_stmt|;
operator|*
name|fragP
operator|->
name|fr_opcode
operator|^=
literal|0x10
expr_stmt|;
comment|/* Reverse sense of branch. */
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|6
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|TAHOE_JMP
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|TAHOE_PC_REL_LONG
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
operator|+
literal|2
operator|+
literal|4
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|+
literal|4
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_BIG_NON_REV_BRANCH
argument_list|,
name|STATE_UNDF
argument_list|)
case|:
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment_type
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_BIG_NON_REV_BRANCH
argument_list|,
name|STATE_WORD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|old_fr_fix
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|TAHOE_BRB
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|6
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|TAHOE_JMP
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|TAHOE_PC_REL_LONG
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
operator|+
literal|2
operator|+
literal|2
operator|+
literal|4
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|+
literal|6
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_ALWAYS_BRANCH
argument_list|,
name|STATE_UNDF
argument_list|)
case|:
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment_type
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_ALWAYS_BRANCH
argument_list|,
name|STATE_BYTE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|old_fr_fix
expr_stmt|;
operator|*
name|fragP
operator|->
name|fr_opcode
operator|=
name|TAHOE_JMP
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|TAHOE_PC_REL_LONG
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|1
operator|+
literal|4
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|+
literal|1
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|fragP
operator|->
name|fr_var
operator|+
name|fragP
operator|->
name|fr_fix
operator|-
name|old_fr_fix
operator|)
return|;
block|}
end_function

begin_comment
comment|/* md_estimate_size_before_relax() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			md_convert_frag();  *  * Called after relax() is finished.  * In:	Address of frag.  *	fr_type == rs_machine_dependent.  *	fr_subtype is what the address relaxed to.  *  * Out:	Any fixSs and constants are set up.  *	Caller will turn frag into a ".space 0".  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|headers
parameter_list|,
name|fragP
parameter_list|)
name|object_headers
modifier|*
name|headers
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|addressP
decl_stmt|;
comment|/* -> _var to change. */
specifier|register
name|char
modifier|*
name|opcodeP
decl_stmt|;
comment|/* -> opcode char(s) to change. */
specifier|register
name|short
name|int
name|length_code
decl_stmt|;
comment|/* 2=long 1=word 0=byte */
specifier|register
name|short
name|int
name|extension
init|=
literal|0
decl_stmt|;
comment|/* Size of relaxed address. 				   Added to fr_fix: incl. ALL var chars. */
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
specifier|register
name|long
name|int
name|where
decl_stmt|;
specifier|register
name|long
name|int
name|address_of_var
decl_stmt|;
comment|/* Where, in file space, is _var of *fragP? */
specifier|register
name|long
name|int
name|target_address
decl_stmt|;
comment|/* Where, in file space, does addr point? */
name|know
argument_list|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
argument_list|)
expr_stmt|;
name|length_code
operator|=
name|RELAX_LENGTH
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|length_code
operator|>=
literal|0
operator|&&
name|length_code
operator|<
literal|3
argument_list|)
expr_stmt|;
name|where
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|addressP
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|where
expr_stmt|;
name|opcodeP
operator|=
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
name|symbolP
operator|=
name|fragP
operator|->
name|fr_symbol
expr_stmt|;
name|know
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|target_address
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|+
name|fragP
operator|->
name|fr_offset
expr_stmt|;
name|address_of_var
operator|=
name|fragP
operator|->
name|fr_address
operator|+
name|where
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_PC_RELATIVE
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
comment|/* *addressP holds the registers number, plus 0x10, if it's deferred        mode. To set up the right mode, just OR the size of this displacement */
comment|/* Byte displacement. */
operator|*
name|addressP
operator|++
operator||=
name|TAHOE_PC_OR_BYTE
expr_stmt|;
operator|*
name|addressP
operator|=
name|target_address
operator|-
operator|(
name|address_of_var
operator|+
literal|2
operator|)
expr_stmt|;
name|extension
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_PC_RELATIVE
argument_list|,
name|STATE_WORD
argument_list|)
case|:
comment|/* Word displacement. */
operator|*
name|addressP
operator|++
operator||=
name|TAHOE_PC_OR_WORD
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|addressP
argument_list|,
name|target_address
operator|-
operator|(
name|address_of_var
operator|+
literal|3
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_PC_RELATIVE
argument_list|,
name|STATE_LONG
argument_list|)
case|:
comment|/* Long word displacement. */
operator|*
name|addressP
operator|++
operator||=
name|TAHOE_PC_OR_LONG
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|addressP
argument_list|,
name|target_address
operator|-
operator|(
name|address_of_var
operator|+
literal|5
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
operator|*
name|addressP
operator|=
name|target_address
operator|-
operator|(
name|address_of_var
operator|+
literal|1
operator|)
expr_stmt|;
name|extension
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH
argument_list|,
name|STATE_WORD
argument_list|)
case|:
operator|*
name|opcodeP
operator|^=
literal|0x10
expr_stmt|;
comment|/* Reverse sense of test. */
operator|*
name|addressP
operator|++
operator|=
literal|3
expr_stmt|;
comment|/* Jump over word branch */
operator|*
name|addressP
operator|++
operator|=
name|TAHOE_BRW
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|addressP
argument_list|,
name|target_address
operator|-
operator|(
name|address_of_var
operator|+
literal|4
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH
argument_list|,
name|STATE_LONG
argument_list|)
case|:
operator|*
name|opcodeP
operator|^=
literal|0x10
expr_stmt|;
comment|/* Reverse sense of test. */
operator|*
name|addressP
operator|++
operator|=
literal|6
expr_stmt|;
operator|*
name|addressP
operator|++
operator|=
name|TAHOE_JMP
expr_stmt|;
operator|*
name|addressP
operator|++
operator|=
name|TAHOE_PC_REL_LONG
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|addressP
argument_list|,
name|target_address
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|7
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_ALWAYS_BRANCH
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
operator|*
name|addressP
operator|=
name|target_address
operator|-
operator|(
name|address_of_var
operator|+
literal|1
operator|)
expr_stmt|;
name|extension
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_ALWAYS_BRANCH
argument_list|,
name|STATE_WORD
argument_list|)
case|:
operator|*
name|opcodeP
operator|=
name|TAHOE_BRW
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|addressP
argument_list|,
name|target_address
operator|-
operator|(
name|address_of_var
operator|+
literal|2
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_ALWAYS_BRANCH
argument_list|,
name|STATE_LONG
argument_list|)
case|:
operator|*
name|opcodeP
operator|=
name|TAHOE_JMP
expr_stmt|;
operator|*
name|addressP
operator|++
operator|=
name|TAHOE_PC_REL_LONG
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|addressP
argument_list|,
name|target_address
operator|-
operator|(
name|address_of_var
operator|+
literal|5
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_BIG_REV_BRANCH
argument_list|,
name|STATE_WORD
argument_list|)
case|:
name|md_number_to_chars
argument_list|(
name|addressP
argument_list|,
name|target_address
operator|-
operator|(
name|address_of_var
operator|+
literal|2
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_BIG_REV_BRANCH
argument_list|,
name|STATE_LONG
argument_list|)
case|:
operator|*
name|opcodeP
operator|^=
literal|0x10
expr_stmt|;
operator|*
name|addressP
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|addressP
operator|++
operator|=
literal|6
expr_stmt|;
operator|*
name|addressP
operator|++
operator|=
name|TAHOE_JMP
expr_stmt|;
operator|*
name|addressP
operator|++
operator|=
name|TAHOE_PC_REL_LONG
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|addressP
argument_list|,
name|target_address
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_BIG_NON_REV_BRANCH
argument_list|,
name|STATE_WORD
argument_list|)
case|:
name|md_number_to_chars
argument_list|(
name|addressP
argument_list|,
name|target_address
operator|-
operator|(
name|address_of_var
operator|+
literal|2
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_BIG_NON_REV_BRANCH
argument_list|,
name|STATE_LONG
argument_list|)
case|:
operator|*
name|addressP
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|addressP
operator|++
operator|=
literal|2
expr_stmt|;
operator|*
name|addressP
operator|++
operator|=
name|TAHOE_BRB
expr_stmt|;
operator|*
name|addressP
operator|++
operator|=
literal|6
expr_stmt|;
operator|*
name|addressP
operator|++
operator|=
name|TAHOE_JMP
expr_stmt|;
operator|*
name|addressP
operator|++
operator|=
name|TAHOE_PC_REL_LONG
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|addressP
argument_list|,
name|target_address
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|10
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
break|break;
block|}
name|fragP
operator|->
name|fr_fix
operator|+=
name|extension
expr_stmt|;
block|}
end_function

begin_comment
comment|/* md_convert_frag */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This is the stuff for md_assemble. */
end_comment

begin_define
define|#
directive|define
name|FP_REG
value|13
end_define

begin_define
define|#
directive|define
name|SP_REG
value|14
end_define

begin_define
define|#
directive|define
name|PC_REG
value|15
end_define

begin_define
define|#
directive|define
name|BIGGESTREG
value|PC_REG
end_define

begin_comment
comment|/*  * Parse the string pointed to by START  * If it represents a valid register, point START to the character after  * the last valid register char, and return the register number (0-15).  * If invalid, leave START alone, return -1.  * The format has to be exact. I don't do things like eat leading zeros  * or the like.  * Note: This doesn't check for the next character in the string making  * this invalid. Ex: R123 would return 12, it's the callers job to check  * what start is point to apon return.  *  * Valid registers are R1-R15, %1-%15, FP (13), SP (14), PC (15)  * Case doesn't matter.  */
end_comment

begin_function
name|int
name|tahoe_reg_parse
parameter_list|(
name|start
parameter_list|)
name|char
modifier|*
modifier|*
name|start
decl_stmt|;
comment|/* A pointer to the string to parse. */
block|{
specifier|register
name|char
modifier|*
name|regpoint
init|=
operator|*
name|start
decl_stmt|;
specifier|register
name|int
name|regnum
init|=
operator|-
literal|1
decl_stmt|;
switch|switch
condition|(
operator|*
name|regpoint
operator|++
condition|)
block|{
case|case
literal|'%'
case|:
comment|/* Registers can start with a %, 				   R or r, and then a number. */
case|case
literal|'R'
case|:
case|case
literal|'r'
case|:
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|regpoint
argument_list|)
condition|)
block|{
comment|/* Got the first digit. */
name|regnum
operator|=
operator|*
name|regpoint
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|(
name|regnum
operator|==
literal|1
operator|)
operator|&&
name|isdigit
argument_list|(
operator|*
name|regpoint
argument_list|)
condition|)
block|{
comment|/* Its a two digit number. */
name|regnum
operator|=
literal|10
operator|+
operator|(
operator|*
name|regpoint
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|>
name|BIGGESTREG
condition|)
block|{
comment|/* Number too big? */
name|regnum
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|'F'
case|:
comment|/* Is it the FP */
case|case
literal|'f'
case|:
switch|switch
condition|(
operator|*
name|regpoint
operator|++
condition|)
block|{
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|regnum
operator|=
name|FP_REG
expr_stmt|;
block|}
break|break;
case|case
literal|'s'
case|:
comment|/* How about the SP */
case|case
literal|'S'
case|:
switch|switch
condition|(
operator|*
name|regpoint
operator|++
condition|)
block|{
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|regnum
operator|=
name|SP_REG
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
comment|/* OR the PC even */
case|case
literal|'P'
case|:
switch|switch
condition|(
operator|*
name|regpoint
operator|++
condition|)
block|{
case|case
literal|'c'
case|:
case|case
literal|'C'
case|:
name|regnum
operator|=
name|PC_REG
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|regnum
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* No error, so move string pointer */
operator|*
name|start
operator|=
name|regpoint
expr_stmt|;
block|}
return|return
name|regnum
return|;
comment|/* Return results */
block|}
end_function

begin_comment
comment|/* tahoe_reg_parse */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * This chops up an operand and figures out its modes and stuff.  * It's a little touchy about extra characters.  * Optex to start with one extra character so it can be overwritten for  * the backward part of the parsing.  * You can't put a bunch of extra characters in side to  * make the command look cute. ie: * foo ( r1 ) [  r0 ]  * If you like doing a lot of typing, try COBOL!  * Actually, this parser is a little weak all around. It's designed to be  * used with compliers, so I emphisise correct decoding of valid code quickly  * rather that catching every possable error.  * Note: This uses the expression function, so save input_line_pointer before  * calling.  *  * Sperry defines the semantics of address modes (and values)  * by a two-letter code, explained here.  *  *   letter 1:   access type  *  *     a         address calculation - no data access, registers forbidden  *     b         branch displacement  *     m         read - let go of bus - write back "modify"  *     r         read  *     w         write  *     v         bit field address: like 'a' but registers are OK  *  *   letter 2:   data type (i.e. width, alignment)  *  *     b         byte  *     w         word  *     l         longword  *     q         quadword (Even regs< 14 allowed) (if 12, you get a warning)  *     -	 unconditional synthetic jbr operand  *     ?	 simple synthetic reversable branch operand  *     !	 complex synthetic reversable branch operand  *     :	 complex synthetic non-reversable branch operand  *  * The '-?!:' letter 2's are not for external consumption. They are used  * by GAS for psuedo ops relaxing code.  *  * After parsing topP has:  *  *   top_ndx:        -1, or the index register. eg 7=[R7]  *   top_reg:        -1, or register number. eg 7 = R7 or (R7)  *   top_mode:       The addressing mode byte. This byte, defines which of  *                   the 11 modes opcode is.  *   top_access:     Access type wanted for this opperand 'b'branch ' '  *                   no-instruction 'amrvw'  *   top_width:      Operand width expected, one of "bwlq?-:!"  *   exp_of_operand: The expression as parsed by expression()  *   top_dispsize:   Number of bytes in the displacement if we can figure it  *                   out and it's relavent.  *  * Need syntax checks built.  */
end_comment

begin_function
name|void
name|tip_op
parameter_list|(
name|optex
parameter_list|,
name|topP
parameter_list|)
name|char
modifier|*
name|optex
decl_stmt|;
comment|/* The users text input, with one leading character */
name|struct
name|top
modifier|*
name|topP
decl_stmt|;
comment|/* The tahoe instruction with some fields already set: 			 in: access, width 			 out: ndx, reg, mode, error, dispsize */
block|{
name|int
name|mode
init|=
literal|0
decl_stmt|;
comment|/* This operand's mode. */
name|char
name|segfault
init|=
operator|*
name|optex
decl_stmt|;
comment|/* To keep the back parsing from freaking. */
name|char
modifier|*
name|point
init|=
name|optex
operator|+
literal|1
decl_stmt|;
comment|/* Parsing from front to back. */
name|char
modifier|*
name|end
decl_stmt|;
comment|/* Parsing from back to front. */
name|int
name|reg
init|=
operator|-
literal|1
decl_stmt|;
comment|/* major register, -1 means absent */
name|int
name|imreg
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Major register in immediate mode */
name|int
name|ndx
init|=
operator|-
literal|1
decl_stmt|;
comment|/* index register number, -1 means absent */
name|char
name|dec_inc
init|=
literal|' '
decl_stmt|;
comment|/* Is the SP auto-incremented '+' or 				   auto-decremented '-' or neither ' '. */
name|int
name|immediate
init|=
literal|0
decl_stmt|;
comment|/* 1 if '$' immediate mode */
name|int
name|call_width
init|=
literal|0
decl_stmt|;
comment|/* If the caller casts the displacement */
name|int
name|abs_width
init|=
literal|0
decl_stmt|;
comment|/* The width of the absolute displacment */
name|int
name|com_width
init|=
literal|0
decl_stmt|;
comment|/* Displacement width required by branch */
name|int
name|deferred
init|=
literal|0
decl_stmt|;
comment|/* 1 if '*' deferral is used */
name|byte
name|disp_size
init|=
literal|0
decl_stmt|;
comment|/* How big is this operand. 0 == don't know */
name|char
modifier|*
name|op_bad
init|=
literal|""
decl_stmt|;
comment|/* Bad operand error */
name|char
modifier|*
name|tp
decl_stmt|,
modifier|*
name|temp
decl_stmt|,
name|c
decl_stmt|;
comment|/* Temporary holders */
name|char
name|access
init|=
name|topP
operator|->
name|top_access
decl_stmt|;
comment|/* Save on a deref. */
name|char
name|width
init|=
name|topP
operator|->
name|top_width
decl_stmt|;
name|int
name|really_none
init|=
literal|0
decl_stmt|;
comment|/* Empty expressions evaluate to 0 				   but I need to know if it's there or not */
name|expressionS
modifier|*
name|expP
decl_stmt|;
comment|/* -> expression values for this operand */
comment|/* Does this command restrict the displacement size. */
if|if
condition|(
name|access
operator|==
literal|'b'
condition|)
name|com_width
operator|=
operator|(
name|width
operator|==
literal|'b'
condition|?
literal|1
else|:
operator|(
name|width
operator|==
literal|'w'
condition|?
literal|2
else|:
operator|(
name|width
operator|==
literal|'l'
condition|?
literal|4
else|:
literal|0
operator|)
operator|)
operator|)
expr_stmt|;
operator|*
name|optex
operator|=
literal|'\0'
expr_stmt|;
comment|/* This is kind of a back stop for all 				   the searches to fail on if needed.*/
if|if
condition|(
operator|*
name|point
operator|==
literal|'*'
condition|)
block|{
comment|/* A dereference? */
name|deferred
operator|=
literal|1
expr_stmt|;
name|point
operator|++
expr_stmt|;
block|}
comment|/* Force words into a certain mode */
comment|/* Bitch, Bitch, Bitch! */
comment|/*    * Using the ^ operator is ambigous. If I have an absolute label    * called 'w' set to, say 2, and I have the expression 'w^1', do I get    * 1, forced to be in word displacement mode, or do I get the value of    * 'w' or'ed with 1 (3 in this case).    * The default is 'w' as an offset, so that's what I use.    * Stick with `, it does the same, and isn't ambig.    */
if|if
condition|(
operator|*
name|point
operator|!=
literal|'\0'
operator|&&
operator|(
operator|(
name|point
index|[
literal|1
index|]
operator|==
literal|'^'
operator|)
operator|||
operator|(
name|point
index|[
literal|1
index|]
operator|==
literal|'`'
operator|)
operator|)
condition|)
switch|switch
condition|(
operator|*
name|point
condition|)
block|{
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
if|if
condition|(
name|com_width
condition|)
name|as_warn
argument_list|(
literal|"Casting a branch displacement is bad form, and is ignored."
argument_list|)
expr_stmt|;
else|else
block|{
name|c
operator|=
operator|(
name|isupper
argument_list|(
operator|*
name|point
argument_list|)
condition|?
name|tolower
argument_list|(
operator|*
name|point
argument_list|)
else|:
operator|*
name|point
operator|)
expr_stmt|;
name|call_width
operator|=
operator|(
operator|(
name|c
operator|==
literal|'b'
operator|)
condition|?
literal|1
else|:
operator|(
operator|(
name|c
operator|==
literal|'w'
operator|)
condition|?
literal|2
else|:
literal|4
operator|)
operator|)
expr_stmt|;
block|}
name|point
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
comment|/* Setting immediate mode */
if|if
condition|(
operator|*
name|point
operator|==
literal|'$'
condition|)
block|{
name|immediate
operator|=
literal|1
expr_stmt|;
name|point
operator|++
expr_stmt|;
block|}
comment|/*    * I've pulled off all the easy stuff off the front, move to the end and    * yank.    */
for|for
control|(
name|end
operator|=
name|point
init|;
operator|*
name|end
operator|!=
literal|'\0'
condition|;
name|end
operator|++
control|)
comment|/* Move to the end. */
empty_stmt|;
if|if
condition|(
name|end
operator|!=
name|point
condition|)
comment|/* Null string? */
name|end
operator|--
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|point
operator|&&
operator|*
name|end
operator|==
literal|' '
operator|&&
name|end
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\''
condition|)
name|end
operator|--
expr_stmt|;
comment|/* Hop white space */
comment|/* Is this an index reg. */
if|if
condition|(
operator|(
operator|*
name|end
operator|==
literal|']'
operator|)
operator|&&
operator|(
name|end
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\''
operator|)
condition|)
block|{
name|temp
operator|=
name|end
expr_stmt|;
comment|/* Find opening brace. */
for|for
control|(
operator|--
name|end
init|;
operator|(
operator|*
name|end
operator|!=
literal|'['
operator|&&
name|end
operator|!=
name|point
operator|)
condition|;
name|end
operator|--
control|)
empty_stmt|;
comment|/* If I found the opening brace, get the index register number. */
if|if
condition|(
operator|*
name|end
operator|==
literal|'['
condition|)
block|{
name|tp
operator|=
name|end
operator|+
literal|1
expr_stmt|;
comment|/* tp should point to the start of a reg. */
name|ndx
operator|=
name|tahoe_reg_parse
argument_list|(
operator|&
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|!=
name|temp
condition|)
block|{
comment|/* Reg. parse error. */
name|ndx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|end
operator|--
expr_stmt|;
comment|/* Found it, move past brace. */
block|}
if|if
condition|(
name|ndx
operator|==
operator|-
literal|1
condition|)
block|{
name|op_bad
operator|=
literal|"Couldn't parse the [index] in this operand."
expr_stmt|;
name|end
operator|=
name|point
expr_stmt|;
comment|/* Force all the rest of the tests to fail. */
block|}
block|}
else|else
block|{
name|op_bad
operator|=
literal|"Couldn't find the opening '[' for the index of this operand."
expr_stmt|;
name|end
operator|=
name|point
expr_stmt|;
comment|/* Force all the rest of the tests to fail. */
block|}
block|}
comment|/* Post increment? */
if|if
condition|(
operator|*
name|end
operator|==
literal|'+'
condition|)
block|{
name|dec_inc
operator|=
literal|'+'
expr_stmt|;
comment|/* was:    *end--; */
name|end
operator|--
expr_stmt|;
block|}
comment|/* register in parens? */
if|if
condition|(
operator|(
operator|*
name|end
operator|==
literal|')'
operator|)
operator|&&
operator|(
name|end
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\''
operator|)
condition|)
block|{
name|temp
operator|=
name|end
expr_stmt|;
comment|/* Find opening paren. */
for|for
control|(
operator|--
name|end
init|;
operator|(
operator|*
name|end
operator|!=
literal|'('
operator|&&
name|end
operator|!=
name|point
operator|)
condition|;
name|end
operator|--
control|)
empty_stmt|;
comment|/* If I found the opening paren, get the register number. */
if|if
condition|(
operator|*
name|end
operator|==
literal|'('
condition|)
block|{
name|tp
operator|=
name|end
operator|+
literal|1
expr_stmt|;
name|reg
operator|=
name|tahoe_reg_parse
argument_list|(
operator|&
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|!=
name|temp
condition|)
block|{
comment|/* Not a register, but could be part of the expression. */
name|reg
operator|=
operator|-
literal|1
expr_stmt|;
name|end
operator|=
name|temp
expr_stmt|;
comment|/* Rest the pointer back */
block|}
else|else
block|{
name|end
operator|--
expr_stmt|;
comment|/* Found the reg. move before opening paren. */
block|}
block|}
else|else
block|{
name|op_bad
operator|=
literal|"Couldn't find the opening '(' for the deref of this operand."
expr_stmt|;
name|end
operator|=
name|point
expr_stmt|;
comment|/* Force all the rest of the tests to fail. */
block|}
block|}
comment|/* Pre decrement? */
if|if
condition|(
operator|*
name|end
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|dec_inc
operator|!=
literal|' '
condition|)
block|{
name|op_bad
operator|=
literal|"Operand can't be both pre-inc and post-dec."
expr_stmt|;
name|end
operator|=
name|point
expr_stmt|;
block|}
else|else
block|{
name|dec_inc
operator|=
literal|'-'
expr_stmt|;
comment|/* was:      *end--; */
name|end
operator|--
expr_stmt|;
block|}
block|}
comment|/*    * Everything between point and end is the 'expression', unless it's    * a register name.    */
name|c
operator|=
name|end
index|[
literal|1
index|]
expr_stmt|;
name|end
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tp
operator|=
name|point
expr_stmt|;
name|imreg
operator|=
name|tahoe_reg_parse
argument_list|(
operator|&
name|point
argument_list|)
expr_stmt|;
comment|/* Get the immediate register 				      if it is there.*/
if|if
condition|(
operator|*
name|point
operator|!=
literal|'\0'
condition|)
block|{
comment|/* If there is junk after point, then the it's not immediate reg. */
name|point
operator|=
name|tp
expr_stmt|;
name|imreg
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|imreg
operator|!=
operator|-
literal|1
operator|&&
name|reg
operator|!=
operator|-
literal|1
condition|)
name|op_bad
operator|=
literal|"I parsed 2 registers in this operand."
expr_stmt|;
comment|/*    * Evaluate whats left of the expression to see if it's valid.    * Note again: This assumes that the calling expression has saved    * input_line_pointer. (Nag, nag, nag!)    */
if|if
condition|(
operator|*
name|op_bad
operator|==
literal|'\0'
condition|)
block|{
comment|/* statement has no syntax goofs yet: lets sniff the expression */
name|input_line_pointer
operator|=
name|point
expr_stmt|;
name|expP
operator|=
operator|&
operator|(
name|topP
operator|->
name|exp_of_operand
operator|)
expr_stmt|;
switch|switch
condition|(
name|expression
argument_list|(
name|expP
argument_list|)
condition|)
block|{
comment|/* If expression == SEG_PASS1, expression() will have set 	 need_pass_2 = 1. */
case|case
name|SEG_ABSENT
case|:
comment|/* No expression. For BSD4.2 compatibility, missing expression is 	 absolute 0 */
name|expP
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|expP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|really_none
operator|=
literal|1
expr_stmt|;
case|case
name|SEG_ABSOLUTE
case|:
comment|/* for SEG_ABSOLUTE, we shouldnt need to set X_subtract_symbol, 	 X_add_symbol to any particular value. */
comment|/* But, we will program defensively. Since this situation occurs 	 rarely so it costs us little to do so. */
name|expP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expP
operator|->
name|X_subtract_symbol
operator|=
name|NULL
expr_stmt|;
comment|/* How many bytes are needed to express this abs value? */
name|abs_width
operator|=
operator|(
operator|(
operator|(
operator|(
name|expP
operator|->
name|X_add_number
operator|&
literal|0xFFFFFF80
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|expP
operator|->
name|X_add_number
operator|&
literal|0xFFFFFF80
operator|)
operator|==
literal|0xFFFFFF80
operator|)
operator|)
condition|?
literal|1
else|:
operator|(
operator|(
operator|(
name|expP
operator|->
name|X_add_number
operator|&
literal|0xFFFF8000
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|expP
operator|->
name|X_add_number
operator|&
literal|0xFFFF8000
operator|)
operator|==
literal|0xFFFF8000
operator|)
operator|)
condition|?
literal|2
else|:
literal|4
operator|)
expr_stmt|;
case|case
name|SEG_TEXT
case|:
case|case
name|SEG_DATA
case|:
case|case
name|SEG_BSS
case|:
case|case
name|SEG_UNKNOWN
case|:
break|break;
case|case
name|SEG_DIFFERENCE
case|:
comment|/*        * Major bug. We can't handle the case of a        * SEG_DIFFERENCE expression in a synthetic opcode        * variable-length instruction.        * We don't have a frag type that is smart enough to        * relax a SEG_DIFFERENCE, and so we just force all        * SEG_DIFFERENCEs to behave like SEG_PASS1s.        * Clearly, if there is a demand we can invent a new or        * modified frag type and then coding up a frag for this        * case will be easy. SEG_DIFFERENCE was invented for the        * .words after a CASE opcode, and was never intended for        * instruction operands.        */
name|need_pass_2
operator|=
literal|1
expr_stmt|;
case|case
name|SEG_PASS1
case|:
name|op_bad
operator|=
literal|"Can't relocate expression error."
expr_stmt|;
break|break;
case|case
name|SEG_BIG
case|:
comment|/* This is an error. Tahoe doesn't allow any expressions 	 bigger that a 32 bit long word. Any bigger has to be referenced 	 by address. */
name|op_bad
operator|=
literal|"Expression is too large for a 32 bits."
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"Complier Bug: I got segment %d in tip_op."
argument_list|,
name|expP
operator|->
name|X_seg
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|'\0'
condition|)
block|{
name|op_bad
operator|=
literal|"Junk at end of expression."
expr_stmt|;
block|}
block|}
name|end
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
comment|/* I'm done, so restore optex */
operator|*
name|optex
operator|=
name|segfault
expr_stmt|;
comment|/*    * At this point in the game, we (in theory) have all the components of    * the operand at least parsed. Now it's time to check for syntax/semantic    * errors, and build the mode.    * This is what I have:    *   deferred = 1 if '*'    *   call_width = 0,1,2,4    *   abs_width = 0,1,2,4    *   com_width = 0,1,2,4    *   immediate = 1 if '$'    *   ndx = -1 or reg num    *   dec_inc = '-' or '+' or ' '    *   reg = -1 or reg num    *   imreg = -1 or reg num    *   topP->exp_of_operand    *   really_none    */
comment|/* Is there a displacement size? */
name|disp_size
operator|=
operator|(
name|call_width
condition|?
name|call_width
else|:
operator|(
name|com_width
condition|?
name|com_width
else|:
name|abs_width
condition|?
name|abs_width
else|:
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|op_bad
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|imreg
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Rn */
name|mode
operator|=
name|TAHOE_DIRECT_REG
expr_stmt|;
if|if
condition|(
name|deferred
operator|||
name|immediate
operator|||
operator|(
name|dec_inc
operator|!=
literal|' '
operator|)
operator|||
operator|(
name|reg
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|!
name|really_none
condition|)
name|op_bad
operator|=
literal|"Syntax error in direct register mode."
expr_stmt|;
elseif|else
if|if
condition|(
name|ndx
operator|!=
operator|-
literal|1
condition|)
name|op_bad
operator|=
literal|"You can't index a register in direct register mode."
expr_stmt|;
elseif|else
if|if
condition|(
name|imreg
operator|==
name|SP_REG
operator|&&
name|access
operator|==
literal|'r'
condition|)
name|op_bad
operator|=
literal|"SP can't be the source operand with direct register addressing."
expr_stmt|;
elseif|else
if|if
condition|(
name|access
operator|==
literal|'a'
condition|)
name|op_bad
operator|=
literal|"Can't take the address of a register."
expr_stmt|;
elseif|else
if|if
condition|(
name|access
operator|==
literal|'b'
condition|)
name|op_bad
operator|=
literal|"Direct Register can't be used in a branch."
expr_stmt|;
elseif|else
if|if
condition|(
name|width
operator|==
literal|'q'
operator|&&
operator|(
operator|(
name|imreg
operator|%
literal|2
operator|)
operator|||
operator|(
name|imreg
operator|>
literal|13
operator|)
operator|)
condition|)
name|op_bad
operator|=
literal|"For quad access, the register must be even and< 14."
expr_stmt|;
elseif|else
if|if
condition|(
name|call_width
condition|)
name|op_bad
operator|=
literal|"You can't cast a direct register."
expr_stmt|;
if|if
condition|(
operator|*
name|op_bad
operator|==
literal|'\0'
condition|)
block|{
comment|/* No errors, check for warnings */
if|if
condition|(
name|width
operator|==
literal|'q'
operator|&&
name|imreg
operator|==
literal|12
condition|)
name|as_warn
argument_list|(
literal|"Using reg 14 for quadwords can tromp the FP register."
argument_list|)
expr_stmt|;
name|reg
operator|=
name|imreg
expr_stmt|;
block|}
comment|/* We know: imm = -1 */
block|}
elseif|else
if|if
condition|(
name|dec_inc
operator|==
literal|'-'
condition|)
block|{
comment|/* -(SP) */
name|mode
operator|=
name|TAHOE_AUTO_DEC
expr_stmt|;
if|if
condition|(
name|deferred
operator|||
name|immediate
operator|||
operator|!
name|really_none
condition|)
name|op_bad
operator|=
literal|"Syntax error in auto-dec mode."
expr_stmt|;
elseif|else
if|if
condition|(
name|ndx
operator|!=
operator|-
literal|1
condition|)
name|op_bad
operator|=
literal|"You can't have an index auto dec mode."
expr_stmt|;
elseif|else
if|if
condition|(
name|access
operator|==
literal|'r'
condition|)
name|op_bad
operator|=
literal|"Auto dec mode cant be used for reading."
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|!=
name|SP_REG
condition|)
name|op_bad
operator|=
literal|"Auto dec only works of the SP register."
expr_stmt|;
elseif|else
if|if
condition|(
name|access
operator|==
literal|'b'
condition|)
name|op_bad
operator|=
literal|"Auto dec can't be used in a branch."
expr_stmt|;
elseif|else
if|if
condition|(
name|width
operator|==
literal|'q'
condition|)
name|op_bad
operator|=
literal|"Auto dec won't work with quadwords."
expr_stmt|;
comment|/* We know: imm = -1, dec_inc != '-' */
block|}
elseif|else
if|if
condition|(
name|dec_inc
operator|==
literal|'+'
condition|)
block|{
if|if
condition|(
name|immediate
operator|||
operator|!
name|really_none
condition|)
name|op_bad
operator|=
literal|"Syntax error in one of the auto-inc modes."
expr_stmt|;
elseif|else
if|if
condition|(
name|deferred
condition|)
block|{
comment|/* *(SP)+ */
name|mode
operator|=
name|TAHOE_AUTO_INC_DEFERRED
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
name|SP_REG
condition|)
name|op_bad
operator|=
literal|"Auto inc deferred only works of the SP register."
expr_stmt|;
elseif|else
if|if
condition|(
name|ndx
operator|!=
operator|-
literal|1
condition|)
name|op_bad
operator|=
literal|"You can't have an index auto inc deferred mode."
expr_stmt|;
elseif|else
if|if
condition|(
name|access
operator|==
literal|'b'
condition|)
name|op_bad
operator|=
literal|"Auto inc can't be used in a branch."
expr_stmt|;
block|}
else|else
block|{
comment|/* (SP)+ */
name|mode
operator|=
name|TAHOE_AUTO_INC
expr_stmt|;
if|if
condition|(
name|access
operator|==
literal|'m'
operator|||
name|access
operator|==
literal|'w'
condition|)
name|op_bad
operator|=
literal|"You can't write to an auto inc register."
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|!=
name|SP_REG
condition|)
name|op_bad
operator|=
literal|"Auto inc only works of the SP register."
expr_stmt|;
elseif|else
if|if
condition|(
name|access
operator|==
literal|'b'
condition|)
name|op_bad
operator|=
literal|"Auto inc can't be used in a branch."
expr_stmt|;
elseif|else
if|if
condition|(
name|width
operator|==
literal|'q'
condition|)
name|op_bad
operator|=
literal|"Auto inc won't work with quadwords."
expr_stmt|;
elseif|else
if|if
condition|(
name|ndx
operator|!=
operator|-
literal|1
condition|)
name|op_bad
operator|=
literal|"You can't have an index in auto inc mode."
expr_stmt|;
block|}
comment|/* We know: imm = -1, dec_inc == ' ' */
block|}
elseif|else
if|if
condition|(
name|reg
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|ndx
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|reg
operator|==
name|SP_REG
operator|)
condition|)
name|op_bad
operator|=
literal|"You can't index the sp register."
expr_stmt|;
if|if
condition|(
name|deferred
condition|)
block|{
comment|/* *<disp>(Rn) */
name|mode
operator|=
name|TAHOE_REG_DISP_DEFERRED
expr_stmt|;
if|if
condition|(
name|immediate
condition|)
name|op_bad
operator|=
literal|"Syntax error in register displaced mode."
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|really_none
condition|)
block|{
comment|/* (Rn) */
name|mode
operator|=
name|TAHOE_REG_DEFERRED
expr_stmt|;
comment|/* if reg = SP then cant be indexed */
block|}
else|else
block|{
comment|/*<disp>(Rn) */
name|mode
operator|=
name|TAHOE_REG_DISP
expr_stmt|;
block|}
comment|/* We know: imm = -1, dec_inc == ' ', Reg = -1 */
block|}
else|else
block|{
if|if
condition|(
name|really_none
condition|)
name|op_bad
operator|=
literal|"An offest is needed for this operand."
expr_stmt|;
if|if
condition|(
name|deferred
operator|&&
name|immediate
condition|)
block|{
comment|/* *$<ADDR> */
name|mode
operator|=
name|TAHOE_ABSOLUTE_ADDR
expr_stmt|;
name|disp_size
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|immediate
condition|)
block|{
comment|/* $<disp> */
name|mode
operator|=
name|TAHOE_IMMEDIATE
expr_stmt|;
if|if
condition|(
name|ndx
operator|!=
operator|-
literal|1
condition|)
name|op_bad
operator|=
literal|"You can't index a register in immediate mode."
expr_stmt|;
if|if
condition|(
name|access
operator|==
literal|'a'
condition|)
name|op_bad
operator|=
literal|"Immediate access can't be used as an address."
expr_stmt|;
comment|/* ponder the wisdom of a cast because it doesn't do any good. */
block|}
elseif|else
if|if
condition|(
name|deferred
condition|)
block|{
comment|/* *<disp> */
name|mode
operator|=
name|TAHOE_DISP_REL_DEFERRED
expr_stmt|;
block|}
else|else
block|{
comment|/*<disp> */
name|mode
operator|=
name|TAHOE_DISPLACED_RELATIVE
expr_stmt|;
block|}
block|}
block|}
comment|/*    * At this point, all the errors we can do have be checked for.    * We can build the 'top'. */
name|topP
operator|->
name|top_ndx
operator|=
name|ndx
expr_stmt|;
name|topP
operator|->
name|top_reg
operator|=
name|reg
expr_stmt|;
name|topP
operator|->
name|top_mode
operator|=
name|mode
expr_stmt|;
name|topP
operator|->
name|top_error
operator|=
name|op_bad
expr_stmt|;
name|topP
operator|->
name|top_dispsize
operator|=
name|disp_size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tip_op */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *                  t i p ( )  *  * This converts a string into a tahoe instruction.  * The string must be a bare single instruction in tahoe (with BSD4 frobs)  * format.  * It provides at most one fatal error message (which stops the scan)  * some warning messages as it finds them.  * The tahoe instruction is returned in exploded form.  *  * The exploded instruction is returned to a struct tit of your choice.  * #include "tahoe-inst.h" to know what a struct tit is.  *  */
end_comment

begin_function
specifier|static
name|void
name|tip
parameter_list|(
name|titP
parameter_list|,
name|instring
parameter_list|)
name|struct
name|tit
modifier|*
name|titP
decl_stmt|;
comment|/* We build an exploded instruction here. */
name|char
modifier|*
name|instring
decl_stmt|;
comment|/* Text of a vax instruction: we modify. */
block|{
specifier|register
name|struct
name|tot_wot
modifier|*
name|twP
init|=
name|NULL
decl_stmt|;
comment|/* How to bit-encode this opcode. */
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 1/skip whitespace.2/scan vot_how */
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
comment|/*  */
specifier|register
name|unsigned
name|char
name|count
decl_stmt|;
comment|/* counts number of operands seen */
specifier|register
name|struct
name|top
modifier|*
name|operandp
decl_stmt|;
comment|/* scan operands in struct tit */
specifier|register
name|char
modifier|*
name|alloperr
init|=
literal|""
decl_stmt|;
comment|/* error over all operands */
specifier|register
name|char
name|c
decl_stmt|;
comment|/* Remember char, (we clobber it 				   with '\0' temporarily). */
name|char
modifier|*
name|save_input_line_pointer
decl_stmt|;
if|if
condition|(
operator|*
name|instring
operator|==
literal|' '
condition|)
operator|++
name|instring
expr_stmt|;
comment|/* Skip leading whitespace. */
for|for
control|(
name|p
operator|=
name|instring
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
condition|;
name|p
operator|++
control|)
empty_stmt|;
comment|/* MUST end in end-of-string or 				   exactly 1 space. */
comment|/* Scanned up to end of operation-code. */
comment|/* Operation-code is ended with whitespace. */
if|if
condition|(
name|p
operator|==
name|instring
condition|)
block|{
name|titP
operator|->
name|tit_error
operator|=
literal|"No operator"
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|titP
operator|->
name|tit_opcode
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/*      * Here with instring pointing to what better be an op-name, and p      * pointing to character just past that.      * We trust instring points to an op-name, with no whitespace.      */
name|twP
operator|=
operator|(
expr|struct
name|tot_wot
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|instring
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
comment|/* Restore char after op-code. */
if|if
condition|(
name|twP
operator|==
literal|0
condition|)
block|{
name|titP
operator|->
name|tit_error
operator|=
literal|"Unknown operator"
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|titP
operator|->
name|tit_opcode
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/*        * We found a match! So lets pick up as many operands as the        * instruction wants, and even gripe if there are too many.        * We expect comma to seperate each operand.        * We let instring track the text, while p tracks a part of the        * struct tot.        */
name|count
operator|=
literal|0
expr_stmt|;
comment|/* no operands seen yet */
name|instring
operator|=
name|p
operator|+
operator|(
operator|*
name|p
operator|!=
literal|'\0'
operator|)
expr_stmt|;
comment|/* point past the operation code */
comment|/* tip_op() screws with the input_line_pointer, so save it before 	 I jump in */
name|save_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
for|for
control|(
name|p
operator|=
name|twP
operator|->
name|args
operator|,
name|operandp
operator|=
name|titP
operator|->
name|tit_operand
init|;
operator|!
operator|*
name|alloperr
operator|&&
operator|*
name|p
condition|;
name|operandp
operator|++
operator|,
name|p
operator|+=
literal|2
control|)
block|{
comment|/* 	 * Here to parse one operand. Leave instring pointing just 	 * past any one ',' that marks the end of this operand. 	 */
if|if
condition|(
operator|!
name|p
index|[
literal|1
index|]
condition|)
name|as_fatal
argument_list|(
literal|"Compiler bug: ODD number of bytes in arg structure %s."
argument_list|,
name|twP
operator|->
name|args
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|instring
condition|)
block|{
for|for
control|(
name|q
operator|=
name|instring
init|;
operator|(
operator|*
name|q
operator|!=
literal|','
operator|&&
operator|*
name|q
operator|!=
literal|'\0'
operator|)
condition|;
name|q
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'\''
operator|&&
name|q
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
comment|/* Jump quoted characters */
name|q
operator|++
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|q
expr_stmt|;
comment|/* 	   * Q points to ',' or '\0' that ends argument. C is that 	   * character. 	   */
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|operandp
operator|->
name|top_access
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
name|operandp
operator|->
name|top_width
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|tip_op
argument_list|(
name|instring
operator|-
literal|1
argument_list|,
name|operandp
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
name|c
expr_stmt|;
comment|/* Restore input text. */
if|if
condition|(
operator|*
operator|(
name|operandp
operator|->
name|top_error
operator|)
condition|)
block|{
name|alloperr
operator|=
name|operandp
operator|->
name|top_error
expr_stmt|;
block|}
name|instring
operator|=
name|q
operator|+
operator|(
name|c
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|/* next operand (if any) */
name|count
operator|++
expr_stmt|;
comment|/*  won another argument, may have an operr */
block|}
else|else
name|alloperr
operator|=
literal|"Not enough operands"
expr_stmt|;
block|}
comment|/* Restore the pointer. */
name|input_line_pointer
operator|=
name|save_input_line_pointer
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|alloperr
condition|)
block|{
if|if
condition|(
operator|*
name|instring
operator|==
literal|' '
condition|)
name|instring
operator|++
expr_stmt|;
comment|/* Skip whitespace. */
if|if
condition|(
operator|*
name|instring
condition|)
name|alloperr
operator|=
literal|"Too many operands"
expr_stmt|;
block|}
name|titP
operator|->
name|tit_error
operator|=
name|alloperr
expr_stmt|;
block|}
block|}
name|titP
operator|->
name|tit_opcode
operator|=
name|twP
operator|->
name|code
expr_stmt|;
comment|/* The op-code. */
name|titP
operator|->
name|tit_operands
operator|=
name|count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tip */
end_comment

begin_escape
end_escape

begin_comment
comment|/* md_assemble() emit frags for 1 instruction */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|instruction_string
parameter_list|)
name|char
modifier|*
name|instruction_string
decl_stmt|;
comment|/* A string: assemble 1 instruction. */
block|{
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|top
modifier|*
name|operandP
decl_stmt|;
comment|/* An operand. Scans all operands. */
comment|/*  char c_save;	fixme: remove this line */
comment|/* What used to live after an expression. */
comment|/*  struct frag *fragP;	fixme: remove this line */
comment|/* Fragment of code we just made. */
comment|/*  register struct top *end_operandP; fixme: remove this line */
comment|/* -> slot just after last operand 					Limit of the for (each operand). */
specifier|register
name|expressionS
modifier|*
name|expP
decl_stmt|;
comment|/* -> expression values for this operand */
comment|/* These refer to an instruction operand expression. */
name|segT
name|to_seg
decl_stmt|;
comment|/* Target segment of the address.	 */
specifier|register
name|valueT
name|this_add_number
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|this_add_symbol
decl_stmt|;
comment|/* +ve (minuend) symbol. */
comment|/*  tahoe_opcodeT opcode_as_number; fixme: remove this line */
comment|/* The opcode as a number. */
name|char
modifier|*
name|opcodeP
decl_stmt|;
comment|/* Where it is in a frag. */
comment|/*  char *opmodeP;	fixme: remove this line */
comment|/* Where opcode type is, in a frag. */
name|int
name|dispsize
decl_stmt|;
comment|/* From top_dispsize: tahoe_operand_width 				   (in bytes) */
name|int
name|is_undefined
decl_stmt|;
comment|/* 1 if operand expression's 				   segment not known yet. */
name|int
name|pc_rel
decl_stmt|;
comment|/* Is this operand pc relative? */
comment|/* Decode the operand. */
name|tip
argument_list|(
operator|&
name|t
argument_list|,
name|instruction_string
argument_list|)
expr_stmt|;
comment|/*    * Check to see if this operand decode properly.    * Notice that we haven't made any frags yet.    * If it goofed, then this instruction will wedge in any pass,    * and we can safely flush it, without causing interpass symbol phase    * errors. That is, without changing label values in different passes.    */
if|if
condition|(
operator|*
name|t
operator|.
name|tit_error
condition|)
block|{
name|as_warn
argument_list|(
literal|"Ignoring statement due to \"%s\""
argument_list|,
name|t
operator|.
name|tit_error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We saw no errors in any operands - try to make frag(s) */
comment|/* Emit op-code. */
comment|/* Remember where it is, in case we want to modify the op-code later. */
name|opcodeP
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|opcodeP
operator|=
name|t
operator|.
name|tit_opcode
expr_stmt|;
comment|/* Now do each operand. */
for|for
control|(
name|operandP
operator|=
name|t
operator|.
name|tit_operand
init|;
name|operandP
operator|<
name|t
operator|.
name|tit_operand
operator|+
name|t
operator|.
name|tit_operands
condition|;
name|operandP
operator|++
control|)
block|{
comment|/* for each operand */
name|expP
operator|=
operator|&
operator|(
name|operandP
operator|->
name|exp_of_operand
operator|)
expr_stmt|;
if|if
condition|(
name|operandP
operator|->
name|top_ndx
operator|>=
literal|0
condition|)
block|{
comment|/* Indexed addressing byte 	   Legality of indexed mode already checked: it is OK */
name|FRAG_APPEND_1_CHAR
argument_list|(
literal|0x40
operator|+
name|operandP
operator|->
name|top_ndx
argument_list|)
expr_stmt|;
block|}
comment|/* if(top_ndx>=0) */
comment|/* Here to make main operand frag(s). */
name|this_add_number
operator|=
name|expP
operator|->
name|X_add_number
expr_stmt|;
name|this_add_symbol
operator|=
name|expP
operator|->
name|X_add_symbol
expr_stmt|;
name|to_seg
operator|=
name|expP
operator|->
name|X_seg
expr_stmt|;
name|know
argument_list|(
name|to_seg
operator|==
name|SEG_UNKNOWN
operator|||
expr|\
name|to_seg
operator|==
name|SEG_ABSOLUTE
operator|||
expr|\
name|to_seg
operator|==
name|SEG_DATA
operator|||
expr|\
name|to_seg
operator|==
name|SEG_TEXT
operator|||
expr|\
name|to_seg
operator|==
name|SEG_BSS
argument_list|)
expr_stmt|;
name|is_undefined
operator|=
operator|(
name|to_seg
operator|==
name|SEG_UNKNOWN
operator|)
expr_stmt|;
comment|/* Do we know how big this opperand is? */
name|dispsize
operator|=
name|operandP
operator|->
name|top_dispsize
expr_stmt|;
name|pc_rel
operator|=
literal|0
expr_stmt|;
comment|/* Deal with the branch possabilities. (Note, this doesn't include 	 jumps.)*/
if|if
condition|(
name|operandP
operator|->
name|top_access
operator|==
literal|'b'
condition|)
block|{
comment|/* Branches must be expressions. A psuedo branch can also jump to 	   an absolute address. */
if|if
condition|(
name|to_seg
operator|==
name|now_seg
operator|||
name|is_undefined
condition|)
block|{
comment|/* If is_undefined, then it might BECOME now_seg by relax time. */
if|if
condition|(
name|dispsize
condition|)
block|{
comment|/* I know how big the branch is supposed to be (it's a normal 	       branch), so I set up the frag, and let GAS do the rest. */
name|p
operator|=
name|frag_more
argument_list|(
name|dispsize
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|dispsize
argument_list|,
name|this_add_symbol
argument_list|,
literal|0
argument_list|,
name|this_add_number
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* (to_seg==now_seg || to_seg == SEG_UNKNOWN)&& dispsize==0 */
comment|/* If we don't know how big it is, then its a synthetic branch, 	       so we set up a simple relax state. */
switch|switch
condition|(
name|operandP
operator|->
name|top_width
condition|)
block|{
case|case
name|TAHOE_WIDTH_CONDITIONAL_JUMP
case|:
comment|/* Simple (conditional) jump. I may have to reverse the 		 condition of opcodeP, and then jump to my destination. 		 I set 1 byte aside for the branch off set, and could need 6 		 more bytes for the pc_rel jump */
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH
argument_list|,
name|is_undefined
condition|?
name|STATE_UNDF
else|:
name|STATE_BYTE
argument_list|)
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
name|opcodeP
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAHOE_WIDTH_ALWAYS_JUMP
case|:
comment|/* Simple (unconditional) jump. I may have to convert this to 		 a word branch, or an absolute jump. */
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_ALWAYS_BRANCH
argument_list|,
name|is_undefined
condition|?
name|STATE_UNDF
else|:
name|STATE_BYTE
argument_list|)
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
name|opcodeP
argument_list|)
expr_stmt|;
break|break;
comment|/* The smallest size for the next 2 cases is word. */
case|case
name|TAHOE_WIDTH_BIG_REV_JUMP
case|:
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|8
argument_list|,
literal|2
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_BIG_REV_BRANCH
argument_list|,
name|is_undefined
condition|?
name|STATE_UNDF
else|:
name|STATE_WORD
argument_list|)
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
name|opcodeP
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAHOE_WIDTH_BIG_NON_REV_JUMP
case|:
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_BIG_NON_REV_BRANCH
argument_list|,
name|is_undefined
condition|?
name|STATE_UNDF
else|:
name|STATE_WORD
argument_list|)
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
name|opcodeP
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"Compliler bug: Got a case (%d) I wasn't expecting."
argument_list|,
name|operandP
operator|->
name|top_width
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* to_seg != now_seg&& to_seg != seg_unknown (still in branch) 	     In other words, I'm jumping out of my segment so extend the 	     branches to jumps, and let GAS fix them. */
comment|/* These are "branches" what will always be branches around a jump 	     to the correct addresss in real life. 	     If to_seg is SEG_ABSOLUTE, just encode the branch in, 	     else let GAS fix the address. */
switch|switch
condition|(
name|operandP
operator|->
name|top_width
condition|)
block|{
comment|/* The theory: 	       For SEG_ABSOLUTE, then mode is ABSOLUTE_ADDR, jump 	       to that addresss (not pc_rel). 	       For other segs, address is a long word PC rel jump. */
case|case
name|TAHOE_WIDTH_CONDITIONAL_JUMP
case|:
comment|/* b<cond> */
comment|/* To reverse the condition in a TAHOE branch, 	       complement bit 4 */
operator|*
name|opcodeP
operator|^=
literal|0x10
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|7
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|6
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|TAHOE_JMP
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|operandP
operator|->
name|top_mode
operator|==
name|TAHOE_ABSOLUTE_ADDR
condition|?
name|TAHOE_ABSOLUTE_ADDR
else|:
name|TAHOE_PC_REL_LONG
operator|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|this_add_symbol
argument_list|,
literal|0
argument_list|,
name|this_add_number
argument_list|,
operator|(
name|to_seg
operator|!=
name|SEG_ABSOLUTE
operator|)
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
comment|/* 	     * Now (eg)	BLEQ	1f 	     *		JMP	foo 	     *	1: 	     */
break|break;
case|case
name|TAHOE_WIDTH_ALWAYS_JUMP
case|:
comment|/* br, just turn it into a jump */
operator|*
name|opcodeP
operator|=
name|TAHOE_JMP
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|operandP
operator|->
name|top_mode
operator|==
name|TAHOE_ABSOLUTE_ADDR
condition|?
name|TAHOE_ABSOLUTE_ADDR
else|:
name|TAHOE_PC_REL_LONG
operator|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|this_add_symbol
argument_list|,
literal|0
argument_list|,
name|this_add_number
argument_list|,
operator|(
name|to_seg
operator|!=
name|SEG_ABSOLUTE
operator|)
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
comment|/* Now (eg) JMP foo */
break|break;
case|case
name|TAHOE_WIDTH_BIG_REV_JUMP
case|:
name|p
operator|=
name|frag_more
argument_list|(
literal|8
argument_list|)
expr_stmt|;
operator|*
name|opcodeP
operator|^=
literal|0x10
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|6
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|TAHOE_JMP
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|operandP
operator|->
name|top_mode
operator|==
name|TAHOE_ABSOLUTE_ADDR
condition|?
name|TAHOE_ABSOLUTE_ADDR
else|:
name|TAHOE_PC_REL_LONG
operator|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|this_add_symbol
argument_list|,
literal|0
argument_list|,
name|this_add_number
argument_list|,
operator|(
name|to_seg
operator|!=
name|SEG_ABSOLUTE
operator|)
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
comment|/* 	     * Now (eg)	ACBx	1f 	     *		JMP     foo 	     *	1: 	     */
break|break;
case|case
name|TAHOE_WIDTH_BIG_NON_REV_JUMP
case|:
name|p
operator|=
name|frag_more
argument_list|(
literal|10
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|TAHOE_BRB
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|6
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|TAHOE_JMP
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|operandP
operator|->
name|top_mode
operator|==
name|TAHOE_ABSOLUTE_ADDR
condition|?
name|TAHOE_ABSOLUTE_ADDR
else|:
name|TAHOE_PC_REL_LONG
operator|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|this_add_symbol
argument_list|,
literal|0
argument_list|,
name|this_add_number
argument_list|,
operator|(
name|to_seg
operator|!=
name|SEG_ABSOLUTE
operator|)
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
comment|/* 	     * Now (eg)	xOBxxx	1f 	     *		BRB	2f 	     *	1:	JMP	@#foo 	     *	2: 	     */
break|break;
case|case
literal|'b'
case|:
case|case
literal|'w'
case|:
name|as_warn
argument_list|(
literal|"Real branch displacements must be expressions."
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"Complier error: I got an unknown synthetic branch :%c"
argument_list|,
name|operandP
operator|->
name|top_width
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* It ain't a branch operand. */
switch|switch
condition|(
name|operandP
operator|->
name|top_mode
condition|)
block|{
comment|/* Auto-foo access, only works for one reg (SP) 	     so the only thing needed is the mode. */
case|case
name|TAHOE_AUTO_DEC
case|:
case|case
name|TAHOE_AUTO_INC
case|:
case|case
name|TAHOE_AUTO_INC_DEFERRED
case|:
name|FRAG_APPEND_1_CHAR
argument_list|(
name|operandP
operator|->
name|top_mode
argument_list|)
expr_stmt|;
break|break;
comment|/* Numbered Register only access. Only thing needed is the 	     mode + Register number */
case|case
name|TAHOE_DIRECT_REG
case|:
case|case
name|TAHOE_REG_DEFERRED
case|:
name|FRAG_APPEND_1_CHAR
argument_list|(
name|operandP
operator|->
name|top_mode
operator|+
name|operandP
operator|->
name|top_reg
argument_list|)
expr_stmt|;
break|break;
comment|/* An absolute address. It's size is always 5 bytes. 	     (mode_type + 4 byte address). */
case|case
name|TAHOE_ABSOLUTE_ADDR
case|:
name|know
argument_list|(
operator|(
name|this_add_symbol
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|TAHOE_ABSOLUTE_ADDR
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|this_add_number
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
comment|/* Immediate data. If the size isn't known, then it's an address 	     + and offset, which is 4 bytes big. */
case|case
name|TAHOE_IMMEDIATE
case|:
if|if
condition|(
name|this_add_symbol
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|5
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|TAHOE_IMMEDIATE_LONGWORD
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|this_add_symbol
argument_list|,
literal|0
argument_list|,
name|this_add_number
argument_list|,
literal|0
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It's a integer, and I know it's size. */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|this_add_number
operator|<
literal|0x40
condition|)
block|{
comment|/* Will it fit in a literal? */
name|FRAG_APPEND_1_CHAR
argument_list|(
operator|(
name|byte
operator|)
name|this_add_number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|frag_more
argument_list|(
name|dispsize
operator|+
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dispsize
condition|)
block|{
case|case
literal|1
case|:
operator|*
name|p
operator|++
operator|=
name|TAHOE_IMMEDIATE_BYTE
expr_stmt|;
operator|*
name|p
operator|=
operator|(
name|byte
operator|)
name|this_add_number
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|p
operator|++
operator|=
name|TAHOE_IMMEDIATE_WORD
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|this_add_number
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
operator|*
name|p
operator|++
operator|=
name|TAHOE_IMMEDIATE_LONGWORD
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|this_add_number
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
comment|/* Distance from the PC. If the size isn't known, we have to relax 	     into it. The difference between this and disp(sp) is that 	     this offset is pc_rel, and disp(sp) isn't. 	     Note the drop through code. */
case|case
name|TAHOE_DISPLACED_RELATIVE
case|:
case|case
name|TAHOE_DISP_REL_DEFERRED
case|:
name|operandP
operator|->
name|top_reg
operator|=
name|PC_REG
expr_stmt|;
name|pc_rel
operator|=
literal|1
expr_stmt|;
comment|/* Register, plus a displacement mode. Save the register number, 	     and weather its deffered or not, and relax the size if it isn't 	     known. */
case|case
name|TAHOE_REG_DISP
case|:
case|case
name|TAHOE_REG_DISP_DEFERRED
case|:
if|if
condition|(
name|operandP
operator|->
name|top_mode
operator|==
name|TAHOE_DISP_REL_DEFERRED
operator|||
name|operandP
operator|->
name|top_mode
operator|==
name|TAHOE_REG_DISP_DEFERRED
condition|)
name|operandP
operator|->
name|top_reg
operator|+=
literal|0x10
expr_stmt|;
comment|/* deffered mode is always 0x10 higher 					  than it's non-deffered sibling. */
comment|/* Is this a value out of this segment? 	     The first part of this conditional is a cludge to make gas 	     produce the same output as 'as' when there is a lable, in 	     the current segment, displaceing a register. It's strange, 	     and no one in their right mind would do it, but it's easy 	     to cludge. */
if|if
condition|(
operator|(
name|dispsize
operator|==
literal|0
operator|&&
operator|!
name|pc_rel
operator|)
operator|||
operator|(
name|to_seg
operator|!=
name|now_seg
operator|&&
operator|!
name|is_undefined
operator|&&
name|to_seg
operator|!=
name|SEG_ABSOLUTE
operator|)
condition|)
name|dispsize
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|dispsize
operator|==
literal|0
condition|)
block|{
comment|/* 	     * We have a SEG_UNKNOWN symbol, or the size isn't cast. 	     * It might turn out to be in the same segment as 	     * the instruction, permitting relaxation. 	     */
name|p
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|5
argument_list|,
literal|2
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_PC_RELATIVE
argument_list|,
name|is_undefined
condition|?
name|STATE_UNDF
else|:
name|STATE_BYTE
argument_list|)
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|operandP
operator|->
name|top_reg
expr_stmt|;
block|}
else|else
block|{
comment|/* Either this is an abs, or a cast. */
name|p
operator|=
name|frag_more
argument_list|(
name|dispsize
operator|+
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dispsize
condition|)
block|{
case|case
literal|1
case|:
operator|*
name|p
operator|=
name|TAHOE_PC_OR_BYTE
operator|+
name|operandP
operator|->
name|top_reg
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|p
operator|=
name|TAHOE_PC_OR_WORD
operator|+
name|operandP
operator|->
name|top_reg
expr_stmt|;
break|break;
case|case
literal|4
case|:
operator|*
name|p
operator|=
name|TAHOE_PC_OR_LONG
operator|+
name|operandP
operator|->
name|top_reg
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|1
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|dispsize
argument_list|,
name|this_add_symbol
argument_list|,
literal|0
argument_list|,
name|this_add_number
argument_list|,
name|pc_rel
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"Barf, bad mode %x\n"
argument_list|,
name|operandP
operator|->
name|top_mode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* for(operandP) */
block|}
comment|/* if(!need_pass_2&& !goofed) */
block|}
end_function

begin_comment
comment|/* tahoe_assemble() */
end_comment

begin_comment
comment|/* We have no need to default values of symbols. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* md_undefined_symbol() */
end_comment

begin_comment
comment|/* Parse an operand that is machine-specific.    We just return without modifying the expression if we have nothing    to do. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* md_operand() */
end_comment

begin_comment
comment|/* Round up a section size to the appropriate boundary. */
end_comment

begin_function
name|long
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|size
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
return|;
comment|/* Round all sects to multiple of 8 */
block|}
end_function

begin_comment
comment|/* md_section_align() */
end_comment

begin_comment
comment|/* Exactly what point is a PC-relative offset relative TO?    On the sparc, they're relative to the address of the offset, plus    its size.  This gets us to the following instruction.    (??? Is this right?  FIXME-SOON) */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
return|return
operator|(
name|fixP
operator|->
name|fx_size
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|)
return|;
block|}
end_function

begin_comment
comment|/* md_pcrel_from() */
end_comment

begin_comment
comment|/* end of tc-tahoe.c */
end_comment

end_unit

