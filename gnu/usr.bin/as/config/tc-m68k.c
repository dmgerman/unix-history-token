begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-m68k.c  All the m68020 specific stuff in one convenient, huge,    slow to compile, easy to find file.     Copyright (C) 1987, 1991, 1992 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* note that this file includes real declarations and thus can only be included by one source file per executable. */
end_comment

begin_include
include|#
directive|include
file|"opcode/m68k.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TE_SUN
end_ifdef

begin_comment
comment|/* This variable contains the value to write out at the beginning of    the a.out file.  The 2<<16 means that this is a 68020 file instead    of an old-style 68000 file */
end_comment

begin_decl_stmt
name|long
name|omagic
init|=
literal|2
operator|<<
literal|16
operator||
name|OMAGIC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Magic byte for header file */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|long
name|omagic
init|=
name|OMAGIC
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This array holds the chars that always start a comment.  If the    pre-processor is disabled, these aren't very useful */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"|"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds the chars that only start a comment at the beginning of    a line.  If the line seems to have the form '# 123 filename'    .line and .file directives will appear in the pre-processed output */
end_comment

begin_comment
comment|/* Note that input_file.c hand checks for '#' at the beginning of the    first line of the input file.  This is because the compiler outputs    #NO_APP at the beginning of its output. */
end_comment

begin_comment
comment|/* Also note that comments like this one will always work. */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant */
end_comment

begin_comment
comment|/* As in 0f12.456 */
end_comment

begin_comment
comment|/* or    0d1.2345e12 */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXeEpP"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be    changed in read.c. Ideally it shouldn't have to know about it at all,    but nothing is ideal around here.    */
end_comment

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of relocation record */
end_comment

begin_comment
comment|/* Its an arbitrary name:  This means I don't approve of it */
end_comment

begin_comment
comment|/* See flames below */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|robyn
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TAB
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x)<<2)+(y))
end_define

begin_define
define|#
directive|define
name|TABTYPE
parameter_list|(
name|xy
parameter_list|)
value|((xy)>> 2)
end_define

begin_define
define|#
directive|define
name|BYTE
value|0
end_define

begin_define
define|#
directive|define
name|SHORT
value|1
end_define

begin_define
define|#
directive|define
name|LONG
value|2
end_define

begin_define
define|#
directive|define
name|SZ_UNDEF
value|3
end_define

begin_define
define|#
directive|define
name|BRANCH
value|1
end_define

begin_define
define|#
directive|define
name|FBRANCH
value|2
end_define

begin_define
define|#
directive|define
name|PCREL
value|3
end_define

begin_define
define|#
directive|define
name|BCC68000
value|4
end_define

begin_define
define|#
directive|define
name|DBCC
value|5
end_define

begin_define
define|#
directive|define
name|PCLEA
value|6
end_define

begin_comment
comment|/* Operands we can parse:  (And associated modes)     numb:	8 bit num    numw:	16 bit num    numl:	32 bit num    dreg:	data reg 0-7    reg:	address or data register    areg:	address register    apc:	address register, PC, ZPC or empty string    num:	16 or 32 bit num    num2:	like num    sz:	w or l		if omitted, l assumed    scale:	1 2 4 or 8	if omitted, 1 assumed     7.4 IMMED #num				--> NUM    0.? DREG  dreg				--> dreg    1.? AREG  areg				--> areg    2.? AINDR areg@				--> *(areg)    3.? AINC  areg@+			--> *(areg++)    4.? ADEC  areg@-			--> *(--areg)    5.? AOFF  apc@(numw)			--> *(apc+numw)	-- empty string and ZPC not allowed here    6.? AINDX apc@(num,reg:sz:scale)	--> *(apc+num+reg*scale)    6.? AINDX apc@(reg:sz:scale)		--> same, with num=0    6.? APODX apc@(num)@(num2,reg:sz:scale)	--> *(*(apc+num)+num2+reg*scale)    6.? APODX apc@(num)@(reg:sz:scale)	--> same, with num2=0    6.? AMIND apc@(num)@(num2)		--> *(*(apc+num)+num2) (previous mode without an index reg)    6.? APRDX apc@(num,reg:sz:scale)@(num2)	--> *(*(apc+num+reg*scale)+num2)    6.? APRDX apc@(reg:sz:scale)@(num2)	--> same, with num=0    7.0 ABSL  num:sz			--> *(num)    num				--> *(num) (sz L assumed)    *** MSCR  otherreg			--> Magic    With -l option    5.? AOFF  apc@(num)			--> *(apc+num) -- empty string and ZPC not allowed here still     examples:    #foo	#0x35	#12    d2    a4    a3@    a5@+    a6@-    a2@(12)	pc@(14)    a1@(5,d2:w:1)	@(45,d6:l:4)    pc@(a2)		@(d4)    etc...      #name@(numw)	-->turn into PC rel mode    apc@(num8,reg:sz:scale)		--> *(apc+num8+reg*scale)     */
end_comment

begin_enum
enum|enum
name|operand_type
block|{
name|IMMED
init|=
literal|1
block|,
name|DREG
block|,
name|AREG
block|,
name|AINDR
block|,
name|ADEC
block|,
name|AINC
block|,
name|AOFF
block|,
name|AINDX
block|,
name|APODX
block|,
name|AMIND
block|,
name|APRDX
block|,
name|ABSL
block|,
name|MSCR
block|,
name|REGLST
block|, }
enum|;
end_enum

begin_struct
struct|struct
name|m68k_exp
block|{
name|char
modifier|*
name|e_beg
decl_stmt|;
name|char
modifier|*
name|e_end
decl_stmt|;
name|expressionS
name|e_exp
decl_stmt|;
name|short
name|e_siz
decl_stmt|;
comment|/* 0 == default 1 == short/byte 2 == word 3 == long */
block|}
struct|;
end_struct

begin_comment
comment|/* DATA and ADDR have to be contiguous, so that reg-DATA gives 0-7 == data reg,    8-15 == addr reg for operands that take both types */
end_comment

begin_enum
enum|enum
name|_register
block|{
name|DATA
init|=
literal|1
block|,
comment|/*   1- 8 == data registers 0-7 */
name|DATA0
init|=
name|DATA
block|,
name|DATA1
block|,
name|DATA2
block|,
name|DATA3
block|,
name|DATA4
block|,
name|DATA5
block|,
name|DATA6
block|,
name|DATA7
block|,
name|ADDR
block|,
name|ADDR0
init|=
name|ADDR
block|,
name|ADDR1
block|,
name|ADDR2
block|,
name|ADDR3
block|,
name|ADDR4
block|,
name|ADDR5
block|,
name|ADDR6
block|,
name|ADDR7
block|,
comment|/* Note that COPNUM == processor #1 -- COPNUM+7 == #8, which stores as 000 */
comment|/* I think...  */
name|SP
init|=
name|ADDR7
block|,
name|FPREG
block|,
comment|/* Eight FP registers */
name|FP0
init|=
name|FPREG
block|,
name|FP1
block|,
name|FP2
block|,
name|FP3
block|,
name|FP4
block|,
name|FP5
block|,
name|FP6
block|,
name|FP7
block|,
name|COPNUM
init|=
operator|(
name|FPREG
operator|+
literal|8
operator|)
block|,
comment|/* Co-processor #1-#8 */
name|COP0
init|=
name|COPNUM
block|,
name|COP1
block|,
name|COP2
block|,
name|COP3
block|,
name|COP4
block|,
name|COP5
block|,
name|COP6
block|,
name|COP7
block|,
name|PC
block|,
comment|/* Program counter */
name|ZPC
block|,
comment|/* Hack for Program space, but 0 addressing */
name|SR
block|,
comment|/* Status Reg */
name|CCR
block|,
comment|/* Condition code Reg */
comment|/* These have to be in order for the movec instruction to work. */
name|USP
block|,
comment|/*  User Stack Pointer */
name|ISP
block|,
comment|/*  Interrupt stack pointer */
name|SFC
block|,
name|DFC
block|,
name|CACR
block|,
name|VBR
block|,
name|CAAR
block|,
name|MSP
block|,
name|ITT0
block|,
name|ITT1
block|,
name|DTT0
block|,
name|DTT1
block|,
name|MMUSR
block|,
name|TC
block|,
name|SRP
block|,
name|URP
block|,
comment|/* end of movec ordering constraints */
name|FPI
block|,
name|FPS
block|,
name|FPC
block|,
name|DRP
block|,
name|CRP
block|,
name|CAL
block|,
name|VAL
block|,
name|SCC
block|,
name|AC
block|,
name|BAD
block|,
name|BAD0
init|=
name|BAD
block|,
name|BAD1
block|,
name|BAD2
block|,
name|BAD3
block|,
name|BAD4
block|,
name|BAD5
block|,
name|BAD6
block|,
name|BAD7
block|,
name|BAC
block|,
name|BAC0
init|=
name|BAC
block|,
name|BAC1
block|,
name|BAC2
block|,
name|BAC3
block|,
name|BAC4
block|,
name|BAC5
block|,
name|BAC6
block|,
name|BAC7
block|,
name|PSR
block|,
name|PCSR
block|,
name|IC
block|,
comment|/* instruction cache token */
name|DC
block|,
comment|/* data cache token */
name|NC
block|,
comment|/* no cache token */
name|BC
block|,
comment|/* both caches token */
block|}
enum|;
end_enum

begin_comment
comment|/* Internal form of an operand.  */
end_comment

begin_struct
struct|struct
name|m68k_op
block|{
name|char
modifier|*
name|error
decl_stmt|;
comment|/* Couldn't parse it */
name|enum
name|operand_type
name|mode
decl_stmt|;
comment|/* What mode this instruction is in.  */
name|enum
name|_register
name|reg
decl_stmt|;
comment|/* Base register */
name|struct
name|m68k_exp
modifier|*
name|con1
decl_stmt|;
name|int
name|ireg
decl_stmt|;
comment|/* Index register */
name|int
name|isiz
decl_stmt|;
comment|/* 0 == unspec  1 == byte(?)  2 == short  3 == long  */
name|int
name|imul
decl_stmt|;
comment|/* Multipy ireg by this (1,2,4,or 8) */
name|struct
name|m68k_exp
modifier|*
name|con2
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* internal form of a 68020 instruction */
end_comment

begin_struct
struct|struct
name|m68k_it
block|{
name|char
modifier|*
name|error
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
comment|/* list of opcode info */
name|int
name|numargs
decl_stmt|;
name|int
name|numo
decl_stmt|;
comment|/* Number of shorts in opcode */
name|short
name|opcode
index|[
literal|11
index|]
decl_stmt|;
name|struct
name|m68k_op
name|operands
index|[
literal|6
index|]
decl_stmt|;
name|int
name|nexp
decl_stmt|;
comment|/* number of exprs in use */
name|struct
name|m68k_exp
name|exprs
index|[
literal|4
index|]
decl_stmt|;
name|int
name|nfrag
decl_stmt|;
comment|/* Number of frags we have to produce */
struct|struct
block|{
name|int
name|fragoff
decl_stmt|;
comment|/* Where in the current opcode[] the frag ends */
name|symbolS
modifier|*
name|fadd
decl_stmt|;
name|long
name|foff
decl_stmt|;
name|int
name|fragty
decl_stmt|;
block|}
name|fragb
index|[
literal|4
index|]
struct|;
name|int
name|nrel
decl_stmt|;
comment|/* Num of reloc strucs in use */
struct|struct
block|{
name|int
name|n
decl_stmt|;
name|symbolS
modifier|*
name|add
decl_stmt|,
modifier|*
name|sub
decl_stmt|,
modifier|*
name|got
decl_stmt|;
name|long
name|off
decl_stmt|;
name|char
name|wid
decl_stmt|;
name|char
name|pcrel
decl_stmt|;
name|enum
name|reloc_type
name|rtype
decl_stmt|;
block|}
name|reloc
index|[
literal|5
index|]
struct|;
comment|/* Five is enough??? */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|cpu_of_arch
parameter_list|(
name|x
parameter_list|)
value|((x)& m68000up)
end_define

begin_define
define|#
directive|define
name|float_of_arch
parameter_list|(
name|x
parameter_list|)
value|((x)& mfloat)
end_define

begin_define
define|#
directive|define
name|mmu_of_arch
parameter_list|(
name|x
parameter_list|)
value|((x)& mmmu)
end_define

begin_decl_stmt
specifier|static
name|struct
name|m68k_it
name|the_ins
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the instruction being assembled */
end_comment

begin_comment
comment|/* Macros for adding things to the m68k_it struct */
end_comment

begin_define
define|#
directive|define
name|addword
parameter_list|(
name|w
parameter_list|)
value|the_ins.opcode[the_ins.numo++]=(w)
end_define

begin_comment
comment|/* Like addword, but goes BEFORE general operands */
end_comment

begin_define
define|#
directive|define
name|insop
parameter_list|(
name|w
parameter_list|)
value|{ \ 	int z; \ 	for (z=the_ins.numo;z>opcode->m_codenum;--z) \ 	    the_ins.opcode[z]=the_ins.opcode[z-1]; \ 	for (z=0;z<the_ins.nrel;z++) \ 	    the_ins.reloc[z].n+=2; \ 	the_ins.opcode[opcode->m_codenum]=w; \ 	the_ins.numo++; \     }
end_define

begin_define
define|#
directive|define
name|add_exp
parameter_list|(
name|beg
parameter_list|,
name|end
parameter_list|)
value|(the_ins.exprs[the_ins.nexp].e_beg=beg, \ 			  the_ins.exprs[the_ins.nexp].e_end=end, \&the_ins.exprs[the_ins.nexp++] \ 			  )
end_define

begin_comment
comment|/* The numo+1 kludge is so we can hit the low order byte of the prev word. Blecch*/
end_comment

begin_define
define|#
directive|define
name|add_fix
parameter_list|(
name|width
parameter_list|,
name|exp
parameter_list|,
name|pc_rel
parameter_list|,
name|r_type
parameter_list|)
value|{ \ 	the_ins.reloc[the_ins.nrel].n= ((width) == 'B') ? (the_ins.numo*2-1) : \ 	    (((width) == 'b') ? ((the_ins.numo-1)*2) : (the_ins.numo*2)); \ 	the_ins.reloc[the_ins.nrel].add=adds((exp)); \ 	the_ins.reloc[the_ins.nrel].sub=subs((exp)); \ 	the_ins.reloc[the_ins.nrel].off=offs((exp)); \ 	the_ins.reloc[the_ins.nrel].got=gots((exp)); \ 	the_ins.reloc[the_ins.nrel].wid=width; \ 	the_ins.reloc[the_ins.nrel].pcrel=pc_rel; \ 	the_ins.reloc[the_ins.nrel++].rtype=r_type; \     }
end_define

begin_define
define|#
directive|define
name|add_frag
parameter_list|(
name|add
parameter_list|,
name|off
parameter_list|,
name|type
parameter_list|)
value|{\ 	the_ins.fragb[the_ins.nfrag].fragoff=the_ins.numo;\ 	the_ins.fragb[the_ins.nfrag].fadd=add;\ 	the_ins.fragb[the_ins.nfrag].foff=off;\ 	the_ins.fragb[the_ins.nfrag++].fragty=type;\     }
end_define

begin_define
define|#
directive|define
name|isvar
parameter_list|(
name|exp
parameter_list|)
value|((exp)&& (adds(exp) || subs(exp) || gots(exp)))
end_define

begin_define
define|#
directive|define
name|seg
parameter_list|(
name|exp
parameter_list|)
value|((exp)->e_exp.X_seg)
end_define

begin_define
define|#
directive|define
name|adds
parameter_list|(
name|exp
parameter_list|)
value|((exp)->e_exp.X_add_symbol)
end_define

begin_define
define|#
directive|define
name|subs
parameter_list|(
name|exp
parameter_list|)
value|((exp)->e_exp.X_subtract_symbol)
end_define

begin_define
define|#
directive|define
name|offs
parameter_list|(
name|exp
parameter_list|)
value|((exp)->e_exp.X_add_number)
end_define

begin_define
define|#
directive|define
name|gots
parameter_list|(
name|exp
parameter_list|)
value|((exp)->e_exp.X_got_symbol)
end_define

begin_struct
struct|struct
name|m68k_incant
block|{
name|char
modifier|*
name|m_operands
decl_stmt|;
name|unsigned
name|long
name|m_opcode
decl_stmt|;
name|short
name|m_opnum
decl_stmt|;
name|short
name|m_codenum
decl_stmt|;
name|enum
name|m68k_architecture
name|m_arch
decl_stmt|;
name|struct
name|m68k_incant
modifier|*
name|m_next
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|getone
parameter_list|(
name|x
parameter_list|)
value|((((x)->m_opcode)>>16)&0xffff)
end_define

begin_define
define|#
directive|define
name|gettwo
parameter_list|(
name|x
parameter_list|)
value|(((x)->m_opcode)&0xffff)
end_define

begin_if
if|#
directive|if
name|__STDC__
operator|==
literal|1
end_if

begin_function_decl
specifier|static
name|char
modifier|*
name|crack_operand
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|m68k_op
modifier|*
name|opP
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_num
parameter_list|(
name|struct
name|m68k_exp
modifier|*
name|exp
parameter_list|,
name|int
name|ok
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_regs
parameter_list|(
name|int
name|i
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|struct
name|m68k_op
modifier|*
name|opP
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reverse_16_bits
parameter_list|(
name|int
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reverse_8_bits
parameter_list|(
name|int
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|try_index
parameter_list|(
name|char
modifier|*
modifier|*
name|s
parameter_list|,
name|struct
name|m68k_op
modifier|*
name|opP
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|install_gen_operand
parameter_list|(
name|int
name|mode
parameter_list|,
name|int
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|install_operand
parameter_list|(
name|int
name|mode
parameter_list|,
name|int
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_bss
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_data1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_data2
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_even
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_proc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not __STDC__ */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|crack_operand
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_num
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_regs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reverse_16_bits
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reverse_8_bits
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|try_index
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|install_gen_operand
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|install_operand
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_bss
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_data1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_data2
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_even
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_proc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __STDC__ */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|m68k_architecture
name|current_architecture
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* BCC68000 is for patching in an extra jmp instruction for long offsets    on the 68000.  The 68000 doesn't support long branches with branchs */
end_comment

begin_comment
comment|/* This table desribes how you change sizes for the various types of variable    size expressions.  This version only supports two kinds. */
end_comment

begin_comment
comment|/* Note that calls to frag_var need to specify the maximum expansion needed */
end_comment

begin_comment
comment|/* This is currently 10 bytes for DBCC */
end_comment

begin_comment
comment|/* The fields are:    How far Forward this mode will reach:    How far Backward this mode will reach:    How many bytes this mode will add to the size of the frag    Which mode to go to if the offset won't fit in this one    */
end_comment

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* First entries aren't used */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* For no good reason except */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* that the VAX doesn't either */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
operator|(
literal|127
operator|)
block|,
operator|(
operator|-
literal|128
operator|)
block|,
literal|0
block|,
name|TAB
argument_list|(
argument|BRANCH
argument_list|,
argument|SHORT
argument_list|)
block|}
block|,
block|{
operator|(
literal|32767
operator|)
block|,
operator|(
operator|-
literal|32768
operator|)
block|,
literal|2
block|,
name|TAB
argument_list|(
argument|BRANCH
argument_list|,
argument|LONG
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* FBRANCH doesn't come BYTE */
block|{
operator|(
literal|32767
operator|)
block|,
operator|(
operator|-
literal|32768
operator|)
block|,
literal|2
block|,
name|TAB
argument_list|(
argument|FBRANCH
argument_list|,
argument|LONG
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* PCREL doesn't come BYTE */
block|{
operator|(
literal|32767
operator|)
block|,
operator|(
operator|-
literal|32768
operator|)
block|,
literal|2
block|,
name|TAB
argument_list|(
argument|PCREL
argument_list|,
argument|LONG
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
operator|(
literal|127
operator|)
block|,
operator|(
operator|-
literal|128
operator|)
block|,
literal|0
block|,
name|TAB
argument_list|(
argument|BCC68000
argument_list|,
argument|SHORT
argument_list|)
block|}
block|,
block|{
operator|(
literal|32767
operator|)
block|,
operator|(
operator|-
literal|32768
operator|)
block|,
literal|2
block|,
name|TAB
argument_list|(
argument|BCC68000
argument_list|,
argument|LONG
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|6
block|,
literal|0
block|}
block|,
comment|/* jmp long space */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DBCC doesn't come BYTE */
block|{
operator|(
literal|32767
operator|)
block|,
operator|(
operator|-
literal|32768
operator|)
block|,
literal|2
block|,
name|TAB
argument_list|(
argument|DBCC
argument_list|,
argument|LONG
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|10
block|,
literal|0
block|}
block|,
comment|/* bra/jmp long space */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* PCLEA doesn't come BYTE */
block|{
literal|32767
block|,
operator|-
literal|32768
block|,
literal|2
block|,
name|TAB
argument_list|(
argument|PCLEA
argument_list|,
argument|LONG
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|6
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,      }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are the machine dependent pseudo-ops.  These are included so    the assembler can work on the output from the SUN C compiler, which    generates these.    */
end_comment

begin_comment
comment|/* This table describes all the machine specific pseudo-ops the assembler    has to support.  The fields are:    pseudo-op name without dot    function to call to execute this pseudo-op    Integer arg to pass to the function    */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"data1"
block|,
name|s_data1
block|,
literal|0
block|}
block|,
block|{
literal|"data2"
block|,
name|s_data2
block|,
literal|0
block|}
block|,
block|{
literal|"bss"
block|,
name|s_bss
block|,
literal|0
block|}
block|,
block|{
literal|"even"
block|,
name|s_even
block|,
literal|0
block|}
block|,
block|{
literal|"skip"
block|,
name|s_space
block|,
literal|0
block|}
block|,
block|{
literal|"proc"
block|,
name|s_proc
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #define isbyte(x)	((x)>= -128&& (x)<= 127) */
end_comment

begin_comment
comment|/* #define isword(x)	((x)>= -32768&& (x)<= 32767) */
end_comment

begin_define
define|#
directive|define
name|issbyte
parameter_list|(
name|x
parameter_list|)
value|((x)>= -128&& (x)<= 127)
end_define

begin_define
define|#
directive|define
name|isubyte
parameter_list|(
name|x
parameter_list|)
value|((x)>= 0&& (x)<= 255)
end_define

begin_define
define|#
directive|define
name|issword
parameter_list|(
name|x
parameter_list|)
value|((x)>= -32768&& (x)<= 32767)
end_define

begin_define
define|#
directive|define
name|isuword
parameter_list|(
name|x
parameter_list|)
value|((x)>= 0&& (x)<= 65535)
end_define

begin_define
define|#
directive|define
name|isbyte
parameter_list|(
name|x
parameter_list|)
value|((x)>= -128&& (x)<= 255)
end_define

begin_define
define|#
directive|define
name|isword
parameter_list|(
name|x
parameter_list|)
value|((x)>= -32768&& (x)<= 65535)
end_define

begin_define
define|#
directive|define
name|islong
parameter_list|(
name|x
parameter_list|)
value|(1)
end_define

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|input_line_pointer
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
block|{
name|FAIL
init|=
literal|0
block|,
name|OK
init|=
literal|1
block|, }
enum|;
end_enum

begin_comment
comment|/* JF these tables here are for speed at the expense of size */
end_comment

begin_comment
comment|/* You can replace them with the #if 0 versions if you really    need space and don't mind it running a bit slower */
end_comment

begin_decl_stmt
specifier|static
name|char
name|mklower_table
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|mklower
parameter_list|(
name|c
parameter_list|)
value|(mklower_table[(unsigned char)(c)])
end_define

begin_decl_stmt
specifier|static
name|char
name|notend_table
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|alt_notend_table
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|notend
parameter_list|(
name|s
parameter_list|)
value|(!(notend_table[(unsigned char)(*s)] || (*s == ':'&&\ 							    alt_notend_table[(unsigned char)(s[1])])))
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|mklower
parameter_list|(
name|c
parameter_list|)
value|(isupper(c) ? tolower(c) : c)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Handle the extra arg for fix_new when doing PIC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PIC
end_ifdef

begin_define
define|#
directive|define
name|FIX_NO_RELOC
value|NO_RELOC, NULL
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FIX_NO_RELOC
value|NO_RELOC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PIC */
end_comment

begin_comment
comment|/* JF modified this to handle cases where the first part of a symbol name    looks like a register */
end_comment

begin_comment
comment|/*  * m68k_reg_parse() := if it looks like a register, return it's token&  * advance the pointer.  */
end_comment

begin_function
name|enum
name|_register
name|m68k_reg_parse
parameter_list|(
name|ccp
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
name|ccp
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|MAX_REG_NAME_LEN
define|#
directive|define
name|MAX_REG_NAME_LEN
value|(6)
endif|#
directive|endif
comment|/* MAX_REG_NAME_LEN */
specifier|register
name|char
name|c
index|[
name|MAX_REG_NAME_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|n
init|=
literal|0
decl_stmt|,
name|ret
init|=
name|FAIL
decl_stmt|;
name|c
index|[
literal|0
index|]
operator|=
name|mklower
argument_list|(
name|ccp
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REGISTER_PREFIX
if|if
condition|(
name|c
index|[
literal|0
index|]
operator|!=
name|REGISTER_PREFIX
condition|)
block|{
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
comment|/* need prefix */
endif|#
directive|endif
for|for
control|(
name|p
operator|=
name|c
operator|,
name|q
operator|=
name|ccp
index|[
literal|0
index|]
init|;
name|p
operator|<
name|c
operator|+
name|MAX_REG_NAME_LEN
condition|;
operator|++
name|p
operator|,
operator|++
name|q
control|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|0
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
operator|*
name|p
operator|=
name|mklower
argument_list|(
operator|*
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* downcase */
switch|switch
condition|(
name|c
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'a'
case|:
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|c
index|[
literal|1
index|]
operator|<=
literal|'7'
condition|)
block|{
name|n
operator|=
literal|2
expr_stmt|;
name|ret
operator|=
name|ADDR
operator|+
name|c
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_68851
elseif|else
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'c'
condition|)
block|{
name|n
operator|=
literal|2
expr_stmt|;
name|ret
operator|=
name|AC
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
ifndef|#
directive|ifndef
name|NO_68851
case|case
literal|'b'
case|:
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'a'
condition|)
block|{
if|if
condition|(
name|c
index|[
literal|2
index|]
operator|==
literal|'d'
condition|)
block|{
if|if
condition|(
name|c
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|c
index|[
literal|3
index|]
operator|<=
literal|'7'
condition|)
block|{
name|n
operator|=
literal|4
expr_stmt|;
name|ret
operator|=
name|BAD
operator|+
name|c
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
block|}
block|}
comment|/* BAD */
if|if
condition|(
name|c
index|[
literal|2
index|]
operator|==
literal|'c'
condition|)
block|{
if|if
condition|(
name|c
index|[
literal|3
index|]
operator|>=
literal|'0'
operator|&&
name|c
index|[
literal|3
index|]
operator|<=
literal|'7'
condition|)
block|{
name|n
operator|=
literal|4
expr_stmt|;
name|ret
operator|=
name|BAC
operator|+
name|c
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
block|}
block|}
comment|/* BAC */
block|}
elseif|else
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'c'
condition|)
block|{
name|n
operator|=
literal|2
expr_stmt|;
name|ret
operator|=
name|BC
expr_stmt|;
block|}
comment|/* BC */
break|break;
endif|#
directive|endif
case|case
literal|'c'
case|:
ifndef|#
directive|ifndef
name|NO_68851
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'a'
operator|&&
name|c
index|[
literal|2
index|]
operator|==
literal|'l'
condition|)
block|{
name|n
operator|=
literal|3
expr_stmt|;
name|ret
operator|=
name|CAL
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* This supports both CCR and CC as the ccr reg. */
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'c'
operator|&&
name|c
index|[
literal|2
index|]
operator|==
literal|'r'
condition|)
block|{
name|n
operator|=
literal|3
expr_stmt|;
name|ret
operator|=
name|CCR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'c'
condition|)
block|{
name|n
operator|=
literal|2
expr_stmt|;
name|ret
operator|=
name|CCR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'a'
operator|&&
operator|(
name|c
index|[
literal|2
index|]
operator|==
literal|'a'
operator|||
name|c
index|[
literal|2
index|]
operator|==
literal|'c'
operator|)
operator|&&
name|c
index|[
literal|3
index|]
operator|==
literal|'r'
condition|)
block|{
name|n
operator|=
literal|4
expr_stmt|;
name|ret
operator|=
name|c
index|[
literal|2
index|]
operator|==
literal|'a'
condition|?
name|CAAR
else|:
name|CACR
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_68851
elseif|else
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'r'
operator|&&
name|c
index|[
literal|2
index|]
operator|==
literal|'p'
condition|)
block|{
name|n
operator|=
literal|3
expr_stmt|;
name|ret
operator|=
operator|(
name|CRP
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|c
index|[
literal|1
index|]
operator|<=
literal|'7'
condition|)
block|{
name|n
operator|=
literal|2
expr_stmt|;
name|ret
operator|=
name|DATA
operator|+
name|c
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
name|c
index|[
literal|2
index|]
operator|==
literal|'c'
condition|)
block|{
name|n
operator|=
literal|3
expr_stmt|;
name|ret
operator|=
name|DFC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'c'
condition|)
block|{
name|n
operator|=
literal|2
expr_stmt|;
name|ret
operator|=
name|DC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'t'
operator|&&
name|c
index|[
literal|2
index|]
operator|==
literal|'t'
condition|)
block|{
if|if
condition|(
literal|'0'
operator|<=
name|c
index|[
literal|3
index|]
operator|&&
name|c
index|[
literal|3
index|]
operator|<=
literal|'1'
condition|)
block|{
name|n
operator|=
literal|4
expr_stmt|;
name|ret
operator|=
name|DTT0
operator|+
operator|(
name|c
index|[
literal|3
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
comment|/* DTT[01] */
block|}
ifndef|#
directive|ifndef
name|NO_68851
elseif|else
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'r'
operator|&&
name|c
index|[
literal|2
index|]
operator|==
literal|'p'
condition|)
block|{
name|n
operator|=
literal|3
expr_stmt|;
name|ret
operator|=
operator|(
name|DRP
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'p'
condition|)
block|{
if|if
condition|(
name|c
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|c
index|[
literal|2
index|]
operator|<=
literal|'7'
condition|)
block|{
name|n
operator|=
literal|3
expr_stmt|;
name|ret
operator|=
name|FPREG
operator|+
name|c
index|[
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|c
index|[
literal|3
index|]
operator|==
literal|':'
condition|)
name|ccp
index|[
literal|0
index|]
index|[
literal|3
index|]
operator|=
literal|','
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
index|[
literal|2
index|]
operator|==
literal|'i'
condition|)
block|{
name|n
operator|=
literal|3
expr_stmt|;
name|ret
operator|=
name|FPI
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
index|[
literal|2
index|]
operator|==
literal|'s'
condition|)
block|{
name|n
operator|=
operator|(
name|c
index|[
literal|3
index|]
operator|==
literal|'r'
condition|?
literal|4
else|:
literal|3
operator|)
expr_stmt|;
name|ret
operator|=
name|FPS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
index|[
literal|2
index|]
operator|==
literal|'c'
condition|)
block|{
name|n
operator|=
operator|(
name|c
index|[
literal|3
index|]
operator|==
literal|'r'
condition|?
literal|4
else|:
literal|3
operator|)
expr_stmt|;
name|ret
operator|=
name|FPC
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'s'
operator|&&
name|c
index|[
literal|2
index|]
operator|==
literal|'p'
condition|)
block|{
name|n
operator|=
literal|3
expr_stmt|;
name|ret
operator|=
name|ISP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'c'
condition|)
block|{
name|n
operator|=
literal|2
expr_stmt|;
name|ret
operator|=
name|IC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'t'
operator|&&
name|c
index|[
literal|2
index|]
operator|==
literal|'t'
condition|)
block|{
if|if
condition|(
literal|'0'
operator|<=
name|c
index|[
literal|3
index|]
operator|&&
name|c
index|[
literal|3
index|]
operator|<=
literal|'1'
condition|)
block|{
name|n
operator|=
literal|4
expr_stmt|;
name|ret
operator|=
name|ITT0
operator|+
operator|(
name|c
index|[
literal|3
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
comment|/* ITT[01] */
block|}
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'s'
operator|&&
name|c
index|[
literal|2
index|]
operator|==
literal|'p'
condition|)
block|{
name|n
operator|=
literal|3
expr_stmt|;
name|ret
operator|=
name|MSP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'m'
operator|&&
name|c
index|[
literal|2
index|]
operator|==
literal|'u'
operator|&&
name|c
index|[
literal|3
index|]
operator|==
literal|'s'
operator|&&
name|c
index|[
literal|4
index|]
operator|==
literal|'r'
condition|)
block|{
name|n
operator|=
literal|5
expr_stmt|;
name|ret
operator|=
name|MMUSR
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'c'
condition|)
block|{
name|n
operator|=
literal|2
expr_stmt|;
name|ret
operator|=
name|NC
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'c'
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_68851
if|if
condition|(
name|c
index|[
literal|2
index|]
operator|==
literal|'s'
operator|&&
name|c
index|[
literal|3
index|]
operator|==
literal|'r'
condition|)
block|{
name|n
operator|=
literal|4
expr_stmt|;
name|ret
operator|=
operator|(
name|PCSR
operator|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|n
operator|=
literal|2
expr_stmt|;
name|ret
operator|=
name|PC
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|NO_68851
elseif|else
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'s'
operator|&&
name|c
index|[
literal|2
index|]
operator|==
literal|'r'
condition|)
block|{
name|n
operator|=
literal|3
expr_stmt|;
name|ret
operator|=
operator|(
name|PSR
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
literal|'s'
case|:
ifndef|#
directive|ifndef
name|NO_68851
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'c'
operator|&&
name|c
index|[
literal|2
index|]
operator|==
literal|'c'
condition|)
block|{
name|n
operator|=
literal|3
expr_stmt|;
name|ret
operator|=
operator|(
name|SCC
operator|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'r'
condition|)
block|{
if|if
condition|(
name|c
index|[
literal|2
index|]
operator|==
literal|'p'
condition|)
block|{
name|n
operator|=
literal|3
expr_stmt|;
name|ret
operator|=
name|SRP
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
literal|2
expr_stmt|;
name|ret
operator|=
name|SR
expr_stmt|;
block|}
comment|/* srp else sr */
block|}
elseif|else
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'p'
condition|)
block|{
name|n
operator|=
literal|2
expr_stmt|;
name|ret
operator|=
name|SP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
name|c
index|[
literal|2
index|]
operator|==
literal|'c'
condition|)
block|{
name|n
operator|=
literal|3
expr_stmt|;
name|ret
operator|=
name|SFC
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'c'
condition|)
block|{
name|n
operator|=
literal|2
expr_stmt|;
name|ret
operator|=
name|TC
expr_stmt|;
block|}
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'s'
operator|&&
name|c
index|[
literal|2
index|]
operator|==
literal|'p'
condition|)
block|{
name|n
operator|=
literal|3
expr_stmt|;
name|ret
operator|=
name|USP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'r'
operator|&&
name|c
index|[
literal|2
index|]
operator|==
literal|'p'
condition|)
block|{
name|n
operator|=
literal|3
expr_stmt|;
name|ret
operator|=
name|URP
expr_stmt|;
block|}
break|break;
case|case
literal|'v'
case|:
ifndef|#
directive|ifndef
name|NO_68851
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'a'
operator|&&
name|c
index|[
literal|2
index|]
operator|==
literal|'l'
condition|)
block|{
name|n
operator|=
literal|3
expr_stmt|;
name|ret
operator|=
operator|(
name|VAL
operator|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'b'
operator|&&
name|c
index|[
literal|2
index|]
operator|==
literal|'r'
condition|)
block|{
name|n
operator|=
literal|3
expr_stmt|;
name|ret
operator|=
name|VBR
expr_stmt|;
block|}
break|break;
case|case
literal|'z'
case|:
if|if
condition|(
name|c
index|[
literal|1
index|]
operator|==
literal|'p'
operator|&&
name|c
index|[
literal|2
index|]
operator|==
literal|'c'
condition|)
block|{
name|n
operator|=
literal|3
expr_stmt|;
name|ret
operator|=
name|ZPC
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|n
condition|)
block|{
ifdef|#
directive|ifdef
name|REGISTER_PREFIX
name|n
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|isalnum
argument_list|(
name|ccp
index|[
literal|0
index|]
index|[
name|n
index|]
argument_list|)
operator|||
name|ccp
index|[
literal|0
index|]
index|[
name|n
index|]
operator|==
literal|'_'
condition|)
name|ret
operator|=
name|FAIL
expr_stmt|;
else|else
name|ccp
index|[
literal|0
index|]
operator|+=
name|n
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|FAIL
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SKIP_WHITE
parameter_list|()
value|{ str++; if (*str == ' ') str++;}
end_define

begin_comment
comment|/*  * m68k_ip_op := '#' +<anything>  *	|<register> + range_sep + get_regs  *	;  *  * range_sep := '/' | '-' ;  *  * SKIP_WHITE :=<empty> | ' ' ;  *  */
end_comment

begin_function
name|int
name|m68k_ip_op
parameter_list|(
name|str
parameter_list|,
name|opP
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
specifier|register
name|struct
name|m68k_op
modifier|*
name|opP
decl_stmt|;
block|{
name|char
modifier|*
name|strend
decl_stmt|;
name|long
name|i
decl_stmt|;
name|char
modifier|*
name|parse_index
parameter_list|()
function_decl|;
if|if
condition|(
operator|*
name|str
operator|==
literal|' '
condition|)
block|{
name|str
operator|++
expr_stmt|;
block|}
comment|/* Find the beginning of the string */
if|if
condition|(
operator|!
operator|*
name|str
condition|)
block|{
name|opP
operator|->
name|error
operator|=
literal|"Missing operand"
expr_stmt|;
return|return
name|FAIL
return|;
block|}
comment|/* Out of gas */
for|for
control|(
name|strend
operator|=
name|str
init|;
operator|*
name|strend
condition|;
name|strend
operator|++
control|)
empty_stmt|;
empty_stmt|;
operator|--
name|strend
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'#'
condition|)
block|{
name|str
operator|++
expr_stmt|;
name|opP
operator|->
name|con1
operator|=
name|add_exp
argument_list|(
name|str
argument_list|,
name|strend
argument_list|)
expr_stmt|;
name|opP
operator|->
name|mode
operator|=
name|IMMED
expr_stmt|;
return|return
name|OK
return|;
block|}
comment|/* Guess what:  A constant.  Shar and enjoy */
name|i
operator|=
name|m68k_reg_parse
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
comment|/* is a register, is exactly a register, and is followed by '@' */
if|if
condition|(
operator|(
name|i
operator|==
name|FAIL
operator|||
operator|*
name|str
operator|!=
literal|'\0'
operator|)
operator|&&
operator|*
name|str
operator|!=
literal|'@'
condition|)
block|{
name|char
modifier|*
name|stmp
decl_stmt|;
if|if
condition|(
name|i
operator|!=
name|FAIL
operator|&&
operator|(
operator|*
name|str
operator|==
literal|'/'
operator|||
operator|*
name|str
operator|==
literal|'-'
operator|)
condition|)
block|{
name|opP
operator|->
name|mode
operator|=
name|REGLST
expr_stmt|;
return|return
operator|(
name|get_regs
argument_list|(
name|i
argument_list|,
name|str
argument_list|,
name|opP
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|stmp
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|opP
operator|->
name|con1
operator|=
name|add_exp
argument_list|(
name|str
argument_list|,
name|stmp
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stmp
operator|==
name|strend
condition|)
block|{
name|opP
operator|->
name|mode
operator|=
name|AINDX
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|current_architecture
operator|&
name|m68020up
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
comment|/* if target is not a '20 or better */
name|stmp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|stmp
operator|++
operator|!=
literal|'('
operator|||
operator|*
name|strend
operator|--
operator|!=
literal|')'
condition|)
block|{
name|opP
operator|->
name|error
operator|=
literal|"Malformed operand"
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|i
operator|=
name|try_index
argument_list|(
operator|&
name|stmp
argument_list|,
name|opP
argument_list|)
expr_stmt|;
name|opP
operator|->
name|con2
operator|=
name|add_exp
argument_list|(
name|stmp
argument_list|,
name|strend
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|FAIL
condition|)
block|{
name|opP
operator|->
name|mode
operator|=
name|AMIND
expr_stmt|;
block|}
else|else
block|{
name|opP
operator|->
name|mode
operator|=
name|APODX
expr_stmt|;
block|}
return|return
operator|(
name|OK
operator|)
return|;
block|}
comment|/* if there's an '@' */
name|opP
operator|->
name|mode
operator|=
name|ABSL
expr_stmt|;
name|opP
operator|->
name|con1
operator|=
name|add_exp
argument_list|(
name|str
argument_list|,
name|strend
argument_list|)
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
comment|/* not a register, not exactly a register, or no '@' */
name|opP
operator|->
name|reg
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|DATA
operator|+
literal|0
operator|&&
name|i
operator|<=
name|DATA
operator|+
literal|7
condition|)
name|opP
operator|->
name|mode
operator|=
name|DREG
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>=
name|ADDR
operator|+
literal|0
operator|&&
name|i
operator|<=
name|ADDR
operator|+
literal|7
condition|)
name|opP
operator|->
name|mode
operator|=
name|AREG
expr_stmt|;
else|else
name|opP
operator|->
name|mode
operator|=
name|MSCR
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
operator|(
name|i
operator|<
name|ADDR
operator|+
literal|0
operator|||
name|i
operator|>
name|ADDR
operator|+
literal|7
operator|)
operator|&&
name|i
operator|!=
name|PC
operator|&&
name|i
operator|!=
name|ZPC
operator|&&
name|i
operator|!=
name|FAIL
condition|)
block|{
comment|/* Can't indirect off non address regs */
name|opP
operator|->
name|error
operator|=
literal|"Invalid indirect register"
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|know
argument_list|(
operator|*
name|str
operator|==
literal|'@'
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'\0'
case|:
name|opP
operator|->
name|mode
operator|=
name|AINDR
expr_stmt|;
return|return
name|OK
return|;
case|case
literal|'-'
case|:
name|opP
operator|->
name|mode
operator|=
name|ADEC
expr_stmt|;
return|return
name|OK
return|;
case|case
literal|'+'
case|:
name|opP
operator|->
name|mode
operator|=
name|AINC
expr_stmt|;
return|return
name|OK
return|;
case|case
literal|'('
case|:
name|str
operator|++
expr_stmt|;
break|break;
default|default:
name|opP
operator|->
name|error
operator|=
literal|"Junk after indirect"
expr_stmt|;
return|return
name|FAIL
return|;
block|}
comment|/* Some kind of indexing involved.  Lets find out how bad it is */
name|i
operator|=
name|try_index
argument_list|(
operator|&
name|str
argument_list|,
name|opP
argument_list|)
expr_stmt|;
comment|/* Didn't start with an index reg, maybe its offset or offset,reg */
if|if
condition|(
name|i
operator|==
name|FAIL
condition|)
block|{
name|char
modifier|*
name|beg_str
decl_stmt|;
name|beg_str
operator|=
name|str
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|str
operator|++
condition|)
block|{
case|case
literal|'\0'
case|:
name|opP
operator|->
name|error
operator|=
literal|"Missing )"
expr_stmt|;
return|return
name|FAIL
return|;
case|case
literal|','
case|:
name|i
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|i
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
operator|--
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/* if (str[-3] == ':') { 		   int siz;  		   switch (str[-2]) { 		   case 'b': 		   case 'B': 		   siz=1; 		   break; 		   case 'w': 		   case 'W': 		   siz=2; 		   break; 		   case 'l': 		   case 'L': 		   siz=3; 		   break; 		   default: 		   opP->error="Specified size isn't :w or :l"; 		   return FAIL; 		   } 		   opP->con1=add_exp(beg_str,str-4); 		   opP->con1->e_siz=siz; 		   } else */
name|opP
operator|->
name|con1
operator|=
name|add_exp
argument_list|(
name|beg_str
argument_list|,
name|str
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* Should be offset,reg */
if|if
condition|(
name|str
index|[
operator|-
literal|1
index|]
operator|==
literal|','
condition|)
block|{
name|i
operator|=
name|try_index
argument_list|(
operator|&
name|str
argument_list|,
name|opP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|FAIL
condition|)
block|{
name|opP
operator|->
name|error
operator|=
literal|"Malformed index reg"
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
block|}
comment|/* We've now got offset)   offset,reg)   or    reg) */
if|if
condition|(
operator|*
name|str
operator|==
literal|'\0'
condition|)
block|{
comment|/* Th-the-thats all folks */
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|FAIL
condition|)
name|opP
operator|->
name|mode
operator|=
name|AINDX
expr_stmt|;
comment|/* Other form of indirect */
elseif|else
if|if
condition|(
name|opP
operator|->
name|ireg
operator|==
name|FAIL
condition|)
name|opP
operator|->
name|mode
operator|=
name|AOFF
expr_stmt|;
else|else
name|opP
operator|->
name|mode
operator|=
name|AINDX
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
comment|/* Next thing had better be another @ */
if|if
condition|(
operator|*
name|str
operator|!=
literal|'@'
operator|||
name|str
index|[
literal|1
index|]
operator|!=
literal|'('
condition|)
block|{
name|opP
operator|->
name|error
operator|=
literal|"junk after indirect"
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|current_architecture
operator|&
name|m68020up
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
comment|/* if target is not a '20 or better */
name|str
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|opP
operator|->
name|ireg
operator|!=
name|FAIL
condition|)
block|{
name|opP
operator|->
name|mode
operator|=
name|APRDX
expr_stmt|;
name|i
operator|=
name|try_index
argument_list|(
operator|&
name|str
argument_list|,
name|opP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|FAIL
condition|)
block|{
name|opP
operator|->
name|error
operator|=
literal|"Two index registers!  not allowed!"
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
block|}
else|else
block|{
name|i
operator|=
name|try_index
argument_list|(
operator|&
name|str
argument_list|,
name|opP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|FAIL
condition|)
block|{
name|char
modifier|*
name|beg_str
decl_stmt|;
name|beg_str
operator|=
name|str
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|str
operator|++
condition|)
block|{
case|case
literal|'\0'
case|:
name|opP
operator|->
name|error
operator|=
literal|"Missing )"
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
case|case
literal|','
case|:
name|i
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|i
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
operator|--
name|i
expr_stmt|;
break|break;
block|}
block|}
name|opP
operator|->
name|con2
operator|=
name|add_exp
argument_list|(
name|beg_str
argument_list|,
name|str
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
index|[
operator|-
literal|1
index|]
operator|==
literal|','
condition|)
block|{
if|if
condition|(
name|opP
operator|->
name|ireg
operator|!=
name|FAIL
condition|)
block|{
name|opP
operator|->
name|error
operator|=
literal|"Can't have two index regs"
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|i
operator|=
name|try_index
argument_list|(
operator|&
name|str
argument_list|,
name|opP
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|FAIL
condition|)
block|{
name|opP
operator|->
name|error
operator|=
literal|"malformed index reg"
expr_stmt|;
return|return
operator|(
name|FAIL
operator|)
return|;
block|}
name|opP
operator|->
name|mode
operator|=
name|APODX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opP
operator|->
name|ireg
operator|!=
name|FAIL
condition|)
block|{
name|opP
operator|->
name|mode
operator|=
name|APRDX
expr_stmt|;
block|}
else|else
block|{
name|opP
operator|->
name|mode
operator|=
name|AMIND
expr_stmt|;
block|}
block|}
else|else
block|{
name|opP
operator|->
name|mode
operator|=
name|APODX
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|str
operator|!=
literal|'\0'
condition|)
block|{
name|opP
operator|->
name|error
operator|=
literal|"Junk after indirect"
expr_stmt|;
return|return
name|FAIL
return|;
block|}
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* m68k_ip_op() */
end_comment

begin_comment
comment|/*  *  * try_index := data_or_address_register + ')' + SKIP_W  *	| data_or_address_register + ':' + SKIP_W + size_spec + SKIP_W + multiplier + ')' + SKIP_W  *  * multiplier :=<empty>  *	| ':' + multiplier_number  *	;  *  * multiplier_number := '1' | '2' | '4' | '8' ;  *  * size_spec := 'l' | 'L' | 'w' | 'W' ;  *  * SKIP_W :=<empty> | ' ' ;  *  */
end_comment

begin_function
specifier|static
name|int
name|try_index
parameter_list|(
name|s
parameter_list|,
name|opP
parameter_list|)
name|char
modifier|*
modifier|*
name|s
decl_stmt|;
name|struct
name|m68k_op
modifier|*
name|opP
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|ss
decl_stmt|;
define|#
directive|define
name|SKIP_W
parameter_list|()
value|{ ss++; if (*ss == ' ') ss++;}
name|ss
operator|=
operator|*
name|s
expr_stmt|;
comment|/* SKIP_W(); */
name|i
operator|=
name|m68k_reg_parse
argument_list|(
operator|&
name|ss
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|>=
name|DATA
operator|+
literal|0
operator|&&
name|i
operator|<=
name|ADDR
operator|+
literal|7
operator|)
condition|)
block|{
comment|/* if i is not DATA or ADDR reg */
operator|*
name|s
operator|=
name|ss
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|opP
operator|->
name|ireg
operator|=
name|i
expr_stmt|;
comment|/* SKIP_W(); */
if|if
condition|(
operator|*
name|ss
operator|==
literal|')'
condition|)
block|{
name|opP
operator|->
name|isiz
operator|=
literal|0
expr_stmt|;
name|opP
operator|->
name|imul
operator|=
literal|1
expr_stmt|;
name|SKIP_W
argument_list|()
expr_stmt|;
operator|*
name|s
operator|=
name|ss
expr_stmt|;
return|return
name|OK
return|;
block|}
if|if
condition|(
operator|*
name|ss
operator|!=
literal|':'
condition|)
block|{
name|opP
operator|->
name|error
operator|=
literal|"Missing : in index register"
expr_stmt|;
operator|*
name|s
operator|=
name|ss
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|SKIP_W
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
name|ss
condition|)
block|{
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
name|opP
operator|->
name|isiz
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
name|opP
operator|->
name|isiz
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|opP
operator|->
name|error
operator|=
literal|"Index register size spec not :w or :l"
expr_stmt|;
operator|*
name|s
operator|=
name|ss
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|SKIP_W
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|ss
operator|==
literal|':'
condition|)
block|{
name|SKIP_W
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
name|ss
condition|)
block|{
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'4'
case|:
case|case
literal|'8'
case|:
name|opP
operator|->
name|imul
operator|=
operator|*
name|ss
operator|-
literal|'0'
expr_stmt|;
break|break;
default|default:
name|opP
operator|->
name|error
operator|=
literal|"index multiplier not 1, 2, 4 or 8"
expr_stmt|;
operator|*
name|s
operator|=
name|ss
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|SKIP_W
argument_list|()
expr_stmt|;
block|}
else|else
name|opP
operator|->
name|imul
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|ss
operator|!=
literal|')'
condition|)
block|{
name|opP
operator|->
name|error
operator|=
literal|"Missing )"
expr_stmt|;
operator|*
name|s
operator|=
name|ss
expr_stmt|;
return|return
name|FAIL
return|;
block|}
name|SKIP_W
argument_list|()
expr_stmt|;
operator|*
name|s
operator|=
name|ss
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/* try_index() */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TEST1
end_ifdef

begin_comment
comment|/* TEST1 tests m68k_ip_op(), which parses operands */
end_comment

begin_function
name|main
parameter_list|()
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|m68k_op
name|thark
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|gets
argument_list|(
name|buf
argument_list|)
condition|)
break|break;
name|memset
argument_list|(
operator|&
name|thark
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|thark
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m68k_ip_op
argument_list|(
name|buf
argument_list|,
operator|&
name|thark
argument_list|)
condition|)
name|printf
argument_list|(
literal|"FAIL:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|thark
operator|.
name|error
condition|)
name|printf
argument_list|(
literal|"op1 error %s in %s\n"
argument_list|,
name|thark
operator|.
name|error
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mode %d, reg %d, "
argument_list|,
name|thark
operator|.
name|mode
argument_list|,
name|thark
operator|.
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|thark
operator|.
name|b_const
condition|)
name|printf
argument_list|(
literal|"Constant: '%.*s',"
argument_list|,
literal|1
operator|+
name|thark
operator|.
name|e_const
operator|-
name|thark
operator|.
name|b_const
argument_list|,
name|thark
operator|.
name|b_const
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ireg %d, isiz %d, imul %d "
argument_list|,
name|thark
operator|.
name|ireg
argument_list|,
name|thark
operator|.
name|isiz
argument_list|,
name|thark
operator|.
name|imul
argument_list|)
expr_stmt|;
if|if
condition|(
name|thark
operator|.
name|b_iadd
condition|)
name|printf
argument_list|(
literal|"Iadd: '%.*s'"
argument_list|,
literal|1
operator|+
name|thark
operator|.
name|e_iadd
operator|-
name|thark
operator|.
name|b_iadd
argument_list|,
name|thark
operator|.
name|b_iadd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* handle of the OPCODE hash table 						   NULL means any use before m68k_ip_begin() 						   will crash */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *		m 6 8 k _ i p ( )  *  * This converts a string into a 68k instruction.  * The string must be a bare single instruction in sun format  * with RMS-style 68020 indirects  *  (example:  )  *  * It provides some error messages: at most one fatal error message (which  * stops the scan) and at most one warning message for each operand.  * The 68k instruction is returned in exploded form, since we have no  * knowledge of how you parse (or evaluate) your expressions.  * We do however strip off and decode addressing modes and operation  * mnemonic.  *  * This function's value is a string. If it is not "" then an internal  * logic error was found: read this code to assign meaning to the string.  * No argument string should generate such an error string:  * it means a bug in our code, not in the user's text.  *  * You MUST have called m68k_ip_begin() once and m86_ip_end() never before using  * this function.  */
end_comment

begin_comment
comment|/* JF this function no longer returns a useful value.  Sorry */
end_comment

begin_function
name|void
name|m68k_ip
parameter_list|(
name|instring
parameter_list|)
name|char
modifier|*
name|instring
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|m68k_op
modifier|*
name|opP
decl_stmt|;
specifier|register
name|struct
name|m68k_incant
modifier|*
name|opcode
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|tmpreg
init|=
literal|0
decl_stmt|,
name|baseo
init|=
literal|0
decl_stmt|,
name|outro
init|=
literal|0
decl_stmt|,
name|nextword
decl_stmt|;
name|int
name|siz1
decl_stmt|,
name|siz2
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|losing
decl_stmt|;
name|int
name|opsfound
decl_stmt|;
name|int
name|reloc_type
decl_stmt|;
name|char
modifier|*
name|crack_operand
parameter_list|()
function_decl|;
name|LITTLENUM_TYPE
name|words
index|[
literal|6
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordp
decl_stmt|;
if|if
condition|(
operator|*
name|instring
operator|==
literal|' '
condition|)
name|instring
operator|++
expr_stmt|;
comment|/* skip leading whitespace */
comment|/* Scan up to end of operation-code, which MUST end in end-of-string 	   or exactly 1 space. */
for|for
control|(
name|p
operator|=
name|instring
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
break|break;
if|if
condition|(
name|p
operator|==
name|instring
condition|)
block|{
name|the_ins
operator|.
name|error
operator|=
literal|"No operator"
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* the_ins.numo=1; */
return|return;
block|}
comment|/* p now points to the end of the opcode name, probably whitespace. 	   make sure the name is null terminated by clobbering the whitespace, 	   look it up in the hash table, then fix it back. */
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|opcode
operator|=
operator|(
expr|struct
name|m68k_incant
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|instring
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|NULL
condition|)
block|{
name|the_ins
operator|.
name|error
operator|=
literal|"Unknown operator"
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* the_ins.numo=1; */
return|return;
block|}
comment|/* found a legitimate opcode, start matching operands */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
operator|++
name|p
expr_stmt|;
for|for
control|(
name|opP
operator|=
operator|&
name|the_ins
operator|.
name|operands
index|[
literal|0
index|]
init|;
operator|*
name|p
condition|;
name|opP
operator|++
control|)
block|{
name|p
operator|=
name|crack_operand
argument_list|(
name|p
argument_list|,
name|opP
argument_list|)
expr_stmt|;
if|if
condition|(
name|opP
operator|->
name|error
condition|)
block|{
name|the_ins
operator|.
name|error
operator|=
name|opP
operator|->
name|error
expr_stmt|;
return|return;
block|}
block|}
name|opsfound
operator|=
name|opP
operator|-
operator|&
name|the_ins
operator|.
name|operands
index|[
literal|0
index|]
expr_stmt|;
comment|/* This ugly hack is to support the floating pt opcodes in their standard form */
comment|/* Essentially, we fake a first enty of type COP#1 */
if|if
condition|(
name|opcode
operator|->
name|m_operands
index|[
literal|0
index|]
operator|==
literal|'I'
condition|)
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|opsfound
init|;
name|n
operator|>
literal|0
condition|;
operator|--
name|n
control|)
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|=
name|the_ins
operator|.
name|operands
index|[
name|n
operator|-
literal|1
index|]
expr_stmt|;
comment|/* memcpy((char *)(&the_ins.operands[1]), (char *)(&the_ins.operands[0]), opsfound*sizeof(the_ins.operands[0])); */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|the_ins
operator|.
name|operands
index|[
literal|0
index|]
operator|)
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|the_ins
operator|.
name|operands
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|the_ins
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|mode
operator|=
name|MSCR
expr_stmt|;
name|the_ins
operator|.
name|operands
index|[
literal|0
index|]
operator|.
name|reg
operator|=
name|COPNUM
expr_stmt|;
comment|/* COP #1 */
name|opsfound
operator|++
expr_stmt|;
block|}
comment|/* We've got the operands.  Find an opcode that'll accept them */
for|for
control|(
name|losing
operator|=
literal|0
init|;
condition|;
control|)
block|{
comment|/* if we didn't get the right number of ops, 		   or we have no common model with this pattern 		   then reject this pattern. */
if|if
condition|(
name|opsfound
operator|!=
name|opcode
operator|->
name|m_opnum
operator|||
operator|(
operator|(
name|opcode
operator|->
name|m_arch
operator|&
name|current_architecture
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|++
name|losing
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|s
operator|=
name|opcode
operator|->
name|m_operands
operator|,
name|opP
operator|=
operator|&
name|the_ins
operator|.
name|operands
index|[
literal|0
index|]
init|;
operator|*
name|s
operator|&&
operator|!
name|losing
condition|;
name|s
operator|+=
literal|2
operator|,
name|opP
operator|++
control|)
block|{
comment|/* Warning: this switch is huge! */
comment|/* I've tried to organize the cases into  this order: 				   non-alpha first, then alpha by letter.  lower-case goes directly 				   before uppercase counterpart. */
comment|/* Code with multiple case ...: gets sorted by the lowest case ... 				   it belongs to.  I hope this makes sense. */
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
ifdef|#
directive|ifdef
name|PIC
case|case
literal|' '
case|:
comment|/* this operand is just here to indicate a jump-table branch */
if|if
condition|(
operator|!
name|picmode
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* PIC */
case|case
literal|'!'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|MSCR
operator|||
name|opP
operator|->
name|mode
operator|==
name|IMMED
operator|||
name|opP
operator|->
name|mode
operator|==
name|DREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|AREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|AINC
operator|||
name|opP
operator|->
name|mode
operator|==
name|ADEC
operator|||
name|opP
operator|->
name|mode
operator|==
name|REGLST
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|IMMED
condition|)
name|losing
operator|++
expr_stmt|;
else|else
block|{
name|long
name|t
decl_stmt|;
name|t
operator|=
name|get_num
argument_list|(
name|opP
operator|->
name|con1
argument_list|,
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'b'
operator|&&
operator|!
name|isbyte
argument_list|(
name|t
argument_list|)
condition|)
name|losing
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'w'
operator|&&
operator|!
name|isword
argument_list|(
name|t
argument_list|)
condition|)
name|losing
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'^'
case|:
case|case
literal|'T'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|IMMED
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|MSCR
operator|||
name|opP
operator|->
name|mode
operator|==
name|AREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|IMMED
operator|||
name|opP
operator|->
name|reg
operator|==
name|PC
operator|||
name|opP
operator|->
name|reg
operator|==
name|ZPC
operator|||
name|opP
operator|->
name|mode
operator|==
name|REGLST
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|MSCR
operator|||
name|opP
operator|->
name|reg
operator|==
name|PC
operator|||
name|opP
operator|->
name|reg
operator|==
name|ZPC
operator|||
name|opP
operator|->
name|mode
operator|==
name|REGLST
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|MSCR
operator|||
name|opP
operator|->
name|mode
operator|==
name|DREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|AREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|IMMED
operator|||
name|opP
operator|->
name|reg
operator|==
name|PC
operator|||
name|opP
operator|->
name|reg
operator|==
name|ZPC
operator|||
name|opP
operator|->
name|mode
operator|==
name|AINC
operator|||
name|opP
operator|->
name|mode
operator|==
name|ADEC
operator|||
name|opP
operator|->
name|mode
operator|==
name|REGLST
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|MSCR
operator|||
name|opP
operator|->
name|mode
operator|==
name|REGLST
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|AINC
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|ADEC
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|MSCR
operator|||
name|opP
operator|->
name|mode
operator|==
name|AREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|AINC
operator|||
name|opP
operator|->
name|mode
operator|==
name|ADEC
operator|||
name|opP
operator|->
name|mode
operator|==
name|IMMED
operator|||
name|opP
operator|->
name|mode
operator|==
name|REGLST
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|';'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|MSCR
operator|||
name|opP
operator|->
name|mode
operator|==
name|AREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|REGLST
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|MSCR
operator|||
name|opP
operator|->
name|mode
operator|==
name|AREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|AINC
operator|||
name|opP
operator|->
name|mode
operator|==
name|ADEC
operator|||
name|opP
operator|->
name|mode
operator|==
name|IMMED
operator|||
name|opP
operator|->
name|reg
operator|==
name|PC
operator|||
name|opP
operator|->
name|reg
operator|==
name|ZPC
operator|||
name|opP
operator|->
name|mode
operator|==
name|REGLST
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|MSCR
operator|||
name|opP
operator|->
name|mode
operator|==
name|AREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|IMMED
operator|||
name|opP
operator|->
name|mode
operator|==
name|REGLST
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
comment|/* For now! (JF FOO is this right?) */
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|MSCR
operator|||
name|opP
operator|->
name|mode
operator|==
name|DREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|AREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|IMMED
operator|||
name|opP
operator|->
name|reg
operator|==
name|PC
operator|||
name|opP
operator|->
name|reg
operator|==
name|ZPC
operator|||
name|opP
operator|->
name|mode
operator|==
name|REGLST
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|AREG
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|AINDR
condition|)
block|{
operator|++
name|losing
expr_stmt|;
block|}
comment|/* if not address register indirect */
break|break;
case|case
literal|'B'
case|:
comment|/* FOO */
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|ABSL
operator|||
operator|(
name|flagseen
index|[
literal|'S'
index|]
operator|&&
name|instring
index|[
literal|0
index|]
operator|==
literal|'j'
operator|&&
name|instring
index|[
literal|1
index|]
operator|==
literal|'b'
operator|&&
name|instring
index|[
literal|2
index|]
operator|==
literal|'s'
operator|&&
name|instring
index|[
literal|3
index|]
operator|==
literal|'r'
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|MSCR
operator|||
name|opP
operator|->
name|reg
operator|!=
name|CCR
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* FOO This mode is a KLUDGE!! */
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|AOFF
operator|&&
operator|(
name|opP
operator|->
name|mode
operator|!=
name|ABSL
operator|||
name|opP
operator|->
name|con1
operator|->
name|e_beg
index|[
literal|0
index|]
operator|!=
literal|'('
operator|||
name|opP
operator|->
name|con1
operator|->
name|e_end
index|[
literal|0
index|]
operator|!=
literal|')'
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|DREG
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|MSCR
operator|||
name|opP
operator|->
name|reg
operator|<
operator|(
name|FPREG
operator|+
literal|0
operator|)
operator|||
name|opP
operator|->
name|reg
operator|>
operator|(
name|FPREG
operator|+
literal|7
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|MSCR
operator|||
name|opP
operator|->
name|reg
operator|<
name|COPNUM
operator|||
name|opP
operator|->
name|reg
operator|>=
name|COPNUM
operator|+
literal|7
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|MSCR
operator|||
name|opP
operator|->
name|reg
operator|<
name|USP
operator|||
name|opP
operator|->
name|reg
operator|>
name|URP
operator|||
name|cpu_of_arch
argument_list|(
name|current_architecture
argument_list|)
operator|<
name|m68010
comment|/* before 68010 had none */
operator|||
operator|(
name|cpu_of_arch
argument_list|(
name|current_architecture
argument_list|)
operator|<
name|m68020
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|SFC
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|DFC
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|USP
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|VBR
operator|)
comment|/* 68010's had only these */
operator|||
operator|(
name|cpu_of_arch
argument_list|(
name|current_architecture
argument_list|)
operator|<
name|m68040
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|SFC
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|DFC
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|USP
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|VBR
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|CACR
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|CAAR
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|MSP
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|ISP
operator|)
comment|/* 680[23]0's have only these */
operator|||
operator|(
name|cpu_of_arch
argument_list|(
name|current_architecture
argument_list|)
operator|==
name|m68040
comment|/* 68040 has all but this */
operator|&&
name|opP
operator|->
name|reg
operator|==
name|CAAR
operator|)
condition|)
block|{
name|losing
operator|++
expr_stmt|;
block|}
comment|/* doesn't cut it */
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|IMMED
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|DREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|AREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|FPREG
condition|)
block|{
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'8'
condition|)
name|losing
operator|++
expr_stmt|;
else|else
block|{
name|opP
operator|->
name|mode
operator|=
name|REGLST
expr_stmt|;
name|opP
operator|->
name|reg
operator|=
literal|1
operator|<<
operator|(
name|opP
operator|->
name|reg
operator|-
name|DATA
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|REGLST
condition|)
block|{
name|losing
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'8'
operator|&&
name|opP
operator|->
name|reg
operator|&
literal|0x0FFffFF
condition|)
name|losing
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'3'
operator|&&
name|opP
operator|->
name|reg
operator|&
literal|0x7000000
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|IMMED
condition|)
name|losing
operator|++
expr_stmt|;
else|else
block|{
name|long
name|t
decl_stmt|;
name|t
operator|=
name|get_num
argument_list|(
name|opP
operator|->
name|con1
argument_list|,
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|issbyte
argument_list|(
name|t
argument_list|)
operator|||
name|isvar
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
condition|)
name|losing
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'O'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|DREG
operator|&&
name|opP
operator|->
name|mode
operator|!=
name|IMMED
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|IMMED
condition|)
name|losing
operator|++
expr_stmt|;
else|else
block|{
name|long
name|t
decl_stmt|;
name|t
operator|=
name|get_num
argument_list|(
name|opP
operator|->
name|con1
argument_list|,
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|1
operator|||
name|t
operator|>
literal|8
operator|||
name|isvar
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
condition|)
name|losing
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'R'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|DREG
operator|&&
name|opP
operator|->
name|mode
operator|!=
name|AREG
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|MSCR
operator|||
operator|!
operator|(
name|opP
operator|->
name|reg
operator|==
name|FPI
operator|||
name|opP
operator|->
name|reg
operator|==
name|FPS
operator|||
name|opP
operator|->
name|reg
operator|==
name|FPC
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|MSCR
operator|||
name|opP
operator|->
name|reg
operator|!=
name|SR
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|MSCR
operator|||
name|opP
operator|->
name|reg
operator|!=
name|USP
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
comment|/* JF these are out of order.  We could put them 					   in order if we were willing to put up with 					   bunches of #ifdef m68851s in the code */
ifndef|#
directive|ifndef
name|NO_68851
comment|/* Memory addressing mode used by pflushr */
case|case
literal|'|'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|MSCR
operator|||
name|opP
operator|->
name|mode
operator|==
name|DREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|AREG
operator|||
name|opP
operator|->
name|mode
operator|==
name|REGLST
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|MSCR
operator|||
operator|(
name|opP
operator|->
name|reg
operator|!=
name|SFC
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|DFC
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|MSCR
operator|||
operator|(
name|opP
operator|->
name|reg
operator|!=
name|TC
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|CAL
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|VAL
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|SCC
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|AC
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
if|if
condition|(
name|opP
operator|->
name|reg
operator|!=
name|VAL
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|MSCR
operator|||
operator|(
name|opP
operator|->
name|reg
operator|!=
name|DRP
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|SRP
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|CRP
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|MSCR
operator|||
operator|(
operator|!
operator|(
name|opP
operator|->
name|reg
operator|>=
name|BAD
operator|&&
name|opP
operator|->
name|reg
operator|<=
name|BAD
operator|+
literal|7
operator|)
operator|&&
operator|!
operator|(
name|opP
operator|->
name|reg
operator|>=
name|BAC
operator|&&
name|opP
operator|->
name|reg
operator|<=
name|BAC
operator|+
literal|7
operator|)
operator|)
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
if|if
condition|(
name|opP
operator|->
name|reg
operator|!=
name|PSR
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
if|if
condition|(
name|opP
operator|->
name|reg
operator|!=
name|PCSR
condition|)
name|losing
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'c'
case|:
if|if
condition|(
name|opP
operator|->
name|reg
operator|!=
name|NC
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|IC
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|DC
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|BC
condition|)
block|{
name|losing
operator|++
expr_stmt|;
block|}
comment|/* not a cache specifier. */
break|break;
case|case
literal|'_'
case|:
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|ABSL
condition|)
block|{
operator|++
name|losing
expr_stmt|;
block|}
comment|/* not absolute */
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"Internal error:  Operand mode %c unknown in line %s of file \"%s\""
argument_list|,
operator|*
name|s
argument_list|,
name|__LINE__
argument_list|,
name|__FILE__
argument_list|)
expr_stmt|;
block|}
comment|/* switch on type of operand */
if|if
condition|(
name|losing
condition|)
break|break;
block|}
comment|/* for each operand */
block|}
comment|/* if immediately wrong */
if|if
condition|(
operator|!
name|losing
condition|)
block|{
break|break;
block|}
comment|/* got it. */
name|opcode
operator|=
name|opcode
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
operator|!
name|opcode
condition|)
block|{
name|the_ins
operator|.
name|error
operator|=
literal|"instruction/operands mismatch"
expr_stmt|;
return|return;
block|}
comment|/* Fell off the end */
name|losing
operator|=
literal|0
expr_stmt|;
block|}
comment|/* now assemble it */
name|the_ins
operator|.
name|args
operator|=
name|opcode
operator|->
name|m_operands
expr_stmt|;
name|the_ins
operator|.
name|numargs
operator|=
name|opcode
operator|->
name|m_opnum
expr_stmt|;
name|the_ins
operator|.
name|numo
operator|=
name|opcode
operator|->
name|m_codenum
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator|=
name|getone
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator|=
name|gettwo
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|the_ins
operator|.
name|args
operator|,
name|opP
operator|=
operator|&
name|the_ins
operator|.
name|operands
index|[
literal|0
index|]
init|;
operator|*
name|s
condition|;
name|s
operator|+=
literal|2
operator|,
name|opP
operator|++
control|)
block|{
comment|/* This switch is a doozy. 		   Watch the first step; its a big one! */
switch|switch
condition|(
name|s
index|[
literal|0
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|PIC
case|case
literal|' '
case|:
comment|/* this operand is just here to indicate a jump-table branch */
break|break;
endif|#
directive|endif
comment|/* PIC */
case|case
literal|'*'
case|:
case|case
literal|'~'
case|:
case|case
literal|'%'
case|:
case|case
literal|';'
case|:
case|case
literal|'@'
case|:
case|case
literal|'!'
case|:
case|case
literal|'&'
case|:
case|case
literal|'$'
case|:
case|case
literal|'?'
case|:
case|case
literal|'/'
case|:
ifndef|#
directive|ifndef
name|NO_68851
case|case
literal|'|'
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PIC
comment|/* Use GLOB_DAT for operand references in PIC mode */
if|if
condition|(
name|picmode
condition|)
name|reloc_type
operator|=
name|RELOC_GLOB_DAT
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* PIC */
name|reloc_type
operator|=
name|NO_RELOC
expr_stmt|;
switch|switch
condition|(
name|opP
operator|->
name|mode
condition|)
block|{
name|int
name|literal
decl_stmt|;
case|case
name|IMMED
case|:
name|tmpreg
operator|=
literal|0x3c
expr_stmt|;
comment|/* 7.4 */
if|if
condition|(
operator|*
name|opP
operator|->
name|con1
operator|->
name|e_beg
operator|==
literal|':'
condition|)
block|{
operator|++
name|opP
operator|->
name|con1
operator|->
name|e_beg
expr_stmt|;
name|literal
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|literal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"bwl"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|nextword
operator|=
name|get_num
argument_list|(
name|opP
operator|->
name|con1
argument_list|,
literal|80
argument_list|)
expr_stmt|;
else|else
name|nextword
operator|=
name|nextword
operator|=
name|get_num
argument_list|(
name|opP
operator|->
name|con1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|isvar
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PIC
comment|/* KLUDGE!!!  In PIC assembly, an immediate reference to 				       __GLOBAL_OFFSET_TABLE_ is turned into a pc-relative 				       reference to __GLOBAL_OFFSET_TABLE_ - 6, 				       for the sake of Sun compatibility. */
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'l'
operator|&&
name|picmode
operator|&&
name|gots
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
condition|)
block|{
name|offs
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
operator|-=
literal|6
expr_stmt|;
name|add_fix
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|opP
operator|->
name|con1
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* PIC */
name|add_fix
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|opP
operator|->
name|con1
argument_list|,
literal|0
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|s
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'b'
case|:
if|if
condition|(
operator|!
name|isbyte
argument_list|(
name|nextword
argument_list|)
condition|)
name|opP
operator|->
name|error
operator|=
literal|"operand out of range"
expr_stmt|;
name|addword
argument_list|(
name|nextword
argument_list|)
expr_stmt|;
name|baseo
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
operator|!
name|isword
argument_list|(
name|nextword
argument_list|)
condition|)
name|opP
operator|->
name|error
operator|=
literal|"operand out of range"
expr_stmt|;
name|addword
argument_list|(
name|nextword
argument_list|)
expr_stmt|;
name|baseo
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|addword
argument_list|(
name|nextword
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addword
argument_list|(
name|nextword
argument_list|)
expr_stmt|;
name|baseo
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|baseo
operator|=
literal|2
expr_stmt|;
name|outro
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|baseo
operator|=
literal|4
expr_stmt|;
name|outro
operator|=
literal|11
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|baseo
operator|=
literal|6
expr_stmt|;
name|outro
operator|=
literal|15
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|baseo
operator|=
literal|6
expr_stmt|;
name|outro
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"Internal error:  Can't decode %c%c in line %s of file \"%s\""
argument_list|,
operator|*
name|s
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|__LINE__
argument_list|,
name|__FILE__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|baseo
condition|)
break|break;
if|if
condition|(
name|literal
condition|)
block|{
if|if
condition|(
name|seg
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
operator|==
name|SEG_BIG
condition|)
goto|goto
name|bignum
goto|;
while|while
condition|(
name|baseo
operator|-=
literal|2
condition|)
block|{
name|addword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|addword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|addword
argument_list|(
name|nextword
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addword
argument_list|(
name|nextword
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* We gotta put out some float */
if|if
condition|(
name|seg
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
operator|!=
name|SEG_BIG
condition|)
block|{
name|int_to_gen
argument_list|(
name|nextword
argument_list|)
expr_stmt|;
name|gen_to_words
argument_list|(
name|words
argument_list|,
name|baseo
argument_list|,
operator|(
name|long
name|int
operator|)
name|outro
argument_list|)
expr_stmt|;
for|for
control|(
name|wordp
operator|=
name|words
init|;
name|baseo
operator|--
condition|;
name|wordp
operator|++
control|)
name|addword
argument_list|(
operator|*
name|wordp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Its BIG */
if|if
condition|(
name|offs
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
operator|>
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"Bignum assumed to be binary bit-pattern"
argument_list|)
expr_stmt|;
name|bignum
label|:
if|if
condition|(
name|offs
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
operator|>
name|baseo
condition|)
block|{
name|as_warn
argument_list|(
literal|"Bignum too big for %c format; truncated"
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|offs
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
operator|=
name|baseo
expr_stmt|;
block|}
name|baseo
operator|-=
name|offs
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
expr_stmt|;
for|for
control|(
name|wordp
operator|=
name|generic_bignum
operator|+
name|offs
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
operator|-
literal|1
init|;
name|offs
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
operator|--
condition|;
operator|--
name|wordp
control|)
name|addword
argument_list|(
operator|*
name|wordp
argument_list|)
expr_stmt|;
while|while
condition|(
name|baseo
operator|--
condition|)
name|addword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|gen_to_words
argument_list|(
name|words
argument_list|,
name|baseo
argument_list|,
operator|(
name|long
operator|)
name|outro
argument_list|)
expr_stmt|;
for|for
control|(
name|wordp
operator|=
name|words
init|;
name|baseo
operator|--
condition|;
name|wordp
operator|++
control|)
name|addword
argument_list|(
operator|*
name|wordp
argument_list|)
expr_stmt|;
break|break;
case|case
name|DREG
case|:
name|tmpreg
operator|=
name|opP
operator|->
name|reg
operator|-
name|DATA
expr_stmt|;
comment|/* 0.dreg */
break|break;
case|case
name|AREG
case|:
name|tmpreg
operator|=
literal|0x08
operator|+
name|opP
operator|->
name|reg
operator|-
name|ADDR
expr_stmt|;
comment|/* 1.areg */
break|break;
case|case
name|AINDR
case|:
name|tmpreg
operator|=
literal|0x10
operator|+
name|opP
operator|->
name|reg
operator|-
name|ADDR
expr_stmt|;
comment|/* 2.areg */
break|break;
case|case
name|ADEC
case|:
name|tmpreg
operator|=
literal|0x20
operator|+
name|opP
operator|->
name|reg
operator|-
name|ADDR
expr_stmt|;
comment|/* 4.areg */
break|break;
case|case
name|AINC
case|:
name|tmpreg
operator|=
literal|0x18
operator|+
name|opP
operator|->
name|reg
operator|-
name|ADDR
expr_stmt|;
comment|/* 3.areg */
break|break;
case|case
name|AOFF
case|:
name|nextword
operator|=
name|get_num
argument_list|(
name|opP
operator|->
name|con1
argument_list|,
literal|80
argument_list|)
expr_stmt|;
comment|/* Force into index mode.  Hope this works */
comment|/* We do the first bit for 32-bit displacements, 				   and the second bit for 16 bit ones.  It is 				   possible that we should make the default be 				   WORD instead of LONG, but I think that'd 				   break GCC, so we put up with a little 				   inefficiency for the sake of working output. 				   */
if|if
condition|(
operator|!
name|issword
argument_list|(
name|nextword
argument_list|)
operator|||
operator|(
name|isvar
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
operator|&&
operator|(
operator|(
name|opP
operator|->
name|con1
operator|->
name|e_siz
operator|==
literal|0
operator|&&
name|flagseen
index|[
literal|'l'
index|]
operator|==
literal|0
operator|)
operator|||
name|opP
operator|->
name|con1
operator|->
name|e_siz
operator|==
literal|3
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|PC
condition|)
name|tmpreg
operator|=
literal|0x3B
expr_stmt|;
comment|/* 7.3 */
else|else
name|tmpreg
operator|=
literal|0x30
operator|+
name|opP
operator|->
name|reg
operator|-
name|ADDR
expr_stmt|;
comment|/* 6.areg */
if|if
condition|(
name|isvar
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
condition|)
block|{
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|PC
operator|&&
operator|!
name|subs
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
condition|)
block|{
name|add_frag
argument_list|(
name|adds
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
argument_list|,
name|offs
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
argument_list|,
name|TAB
argument_list|(
name|PCLEA
argument_list|,
name|SZ_UNDEF
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|addword
argument_list|(
literal|0x0170
argument_list|)
expr_stmt|;
name|add_fix
argument_list|(
literal|'l'
argument_list|,
name|opP
operator|->
name|con1
argument_list|,
literal|0
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|addword
argument_list|(
literal|0x0170
argument_list|)
expr_stmt|;
name|addword
argument_list|(
name|nextword
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|PC
condition|)
name|tmpreg
operator|=
literal|0x3A
expr_stmt|;
comment|/* 7.2 */
else|else
name|tmpreg
operator|=
literal|0x28
operator|+
name|opP
operator|->
name|reg
operator|-
name|ADDR
expr_stmt|;
comment|/* 5.areg */
if|if
condition|(
name|isvar
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
condition|)
block|{
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|PC
condition|)
block|{
name|add_fix
argument_list|(
literal|'w'
argument_list|,
name|opP
operator|->
name|con1
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
else|else
name|add_fix
argument_list|(
literal|'w'
argument_list|,
name|opP
operator|->
name|con1
argument_list|,
literal|0
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
block|}
block|}
name|addword
argument_list|(
name|nextword
argument_list|)
expr_stmt|;
break|break;
case|case
name|APODX
case|:
case|case
name|AMIND
case|:
case|case
name|APRDX
case|:
name|know
argument_list|(
name|current_architecture
operator|&
name|m68020up
argument_list|)
expr_stmt|;
comment|/* intentional fall-through */
case|case
name|AINDX
case|:
name|nextword
operator|=
literal|0
expr_stmt|;
name|baseo
operator|=
name|get_num
argument_list|(
name|opP
operator|->
name|con1
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|outro
operator|=
name|get_num
argument_list|(
name|opP
operator|->
name|con2
argument_list|,
literal|80
argument_list|)
expr_stmt|;
comment|/* Figure out the 'addressing mode' */
comment|/* Also turn on the BASE_DISABLE bit, if needed */
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|PC
operator|||
name|opP
operator|->
name|reg
operator|==
name|ZPC
condition|)
block|{
name|tmpreg
operator|=
literal|0x3b
expr_stmt|;
comment|/* 7.3 */
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|ZPC
condition|)
name|nextword
operator||=
literal|0x80
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|FAIL
condition|)
block|{
name|nextword
operator||=
literal|0x80
expr_stmt|;
name|tmpreg
operator|=
literal|0x30
expr_stmt|;
comment|/* 6.garbage */
block|}
else|else
name|tmpreg
operator|=
literal|0x30
operator|+
name|opP
operator|->
name|reg
operator|-
name|ADDR
expr_stmt|;
comment|/* 6.areg */
name|siz1
operator|=
operator|(
name|opP
operator|->
name|con1
operator|)
condition|?
name|opP
operator|->
name|con1
operator|->
name|e_siz
else|:
literal|0
expr_stmt|;
name|siz2
operator|=
operator|(
name|opP
operator|->
name|con2
operator|)
condition|?
name|opP
operator|->
name|con2
operator|->
name|e_siz
else|:
literal|0
expr_stmt|;
comment|/* Index register stuff */
if|if
condition|(
name|opP
operator|->
name|ireg
operator|>=
name|DATA
operator|+
literal|0
operator|&&
name|opP
operator|->
name|ireg
operator|<=
name|ADDR
operator|+
literal|7
condition|)
block|{
name|nextword
operator||=
operator|(
name|opP
operator|->
name|ireg
operator|-
name|DATA
operator|)
operator|<<
literal|12
expr_stmt|;
if|if
condition|(
name|opP
operator|->
name|isiz
operator|==
literal|0
operator|||
name|opP
operator|->
name|isiz
operator|==
literal|3
condition|)
name|nextword
operator||=
literal|0x800
expr_stmt|;
switch|switch
condition|(
name|opP
operator|->
name|imul
condition|)
block|{
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
name|nextword
operator||=
literal|0x200
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|nextword
operator||=
literal|0x400
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|nextword
operator||=
literal|0x600
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"failed sanity check."
argument_list|)
expr_stmt|;
block|}
comment|/* IF its simple, 					   GET US OUT OF HERE! */
comment|/* Must be INDEX, with an index 					   register.  Address register 					   cannot be ZERO-PC, and either 					   :b was forced, or we know 					   it will fit */
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|AINDX
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|FAIL
operator|&&
name|opP
operator|->
name|reg
operator|!=
name|ZPC
operator|&&
operator|(
name|siz1
operator|==
literal|1
operator|||
operator|(
name|issbyte
argument_list|(
name|baseo
argument_list|)
operator|&&
operator|!
name|isvar
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
operator|)
operator|)
condition|)
block|{
name|nextword
operator|+=
name|baseo
operator|&
literal|0xff
expr_stmt|;
name|addword
argument_list|(
name|nextword
argument_list|)
expr_stmt|;
if|if
condition|(
name|isvar
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
condition|)
name|add_fix
argument_list|(
literal|'B'
argument_list|,
name|opP
operator|->
name|con1
argument_list|,
literal|0
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|nextword
operator||=
literal|0x40
expr_stmt|;
comment|/* No index reg */
comment|/* It aint simple */
name|nextword
operator||=
literal|0x100
expr_stmt|;
comment|/* If the guy specified a width, we assume that 				   it is wide enough.  Maybe it isn't.  If so, we lose 				   */
switch|switch
condition|(
name|siz1
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|isvar
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
operator|||
operator|!
name|issword
argument_list|(
name|baseo
argument_list|)
condition|)
block|{
name|siz1
operator|=
literal|3
expr_stmt|;
name|nextword
operator||=
literal|0x30
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|baseo
operator|==
literal|0
condition|)
name|nextword
operator||=
literal|0x10
expr_stmt|;
else|else
block|{
name|nextword
operator||=
literal|0x20
expr_stmt|;
name|siz1
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
name|as_warn
argument_list|(
literal|"Byte dispacement won't work.  Defaulting to :w"
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|nextword
operator||=
literal|0x20
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|nextword
operator||=
literal|0x30
expr_stmt|;
break|break;
block|}
comment|/* Figure out innner displacement stuff */
if|if
condition|(
name|opP
operator|->
name|mode
operator|!=
name|AINDX
condition|)
block|{
switch|switch
condition|(
name|siz2
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|isvar
argument_list|(
name|opP
operator|->
name|con2
argument_list|)
operator|||
operator|!
name|issword
argument_list|(
name|outro
argument_list|)
condition|)
block|{
name|siz2
operator|=
literal|3
expr_stmt|;
name|nextword
operator||=
literal|0x3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|outro
operator|==
literal|0
condition|)
name|nextword
operator||=
literal|0x1
expr_stmt|;
else|else
block|{
name|nextword
operator||=
literal|0x2
expr_stmt|;
name|siz2
operator|=
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
name|as_warn
argument_list|(
literal|"Byte dispacement won't work.  Defaulting to :w"
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|nextword
operator||=
literal|0x2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|nextword
operator||=
literal|0x3
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|APODX
condition|)
name|nextword
operator||=
literal|0x04
expr_stmt|;
elseif|else
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|AMIND
condition|)
name|nextword
operator||=
literal|0x40
expr_stmt|;
block|}
name|addword
argument_list|(
name|nextword
argument_list|)
expr_stmt|;
if|if
condition|(
name|isvar
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
condition|)
block|{
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|PC
operator|||
name|opP
operator|->
name|reg
operator|==
name|ZPC
condition|)
block|{
name|add_fix
argument_list|(
name|siz1
operator|==
literal|3
condition|?
literal|'l'
else|:
literal|'w'
argument_list|,
name|opP
operator|->
name|con1
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|opP
operator|->
name|con1
operator|->
name|e_exp
operator|.
name|X_add_number
operator|+=
literal|6
expr_stmt|;
block|}
else|else
name|add_fix
argument_list|(
name|siz1
operator|==
literal|3
condition|?
literal|'l'
else|:
literal|'w'
argument_list|,
name|opP
operator|->
name|con1
argument_list|,
literal|0
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|siz1
operator|==
literal|3
condition|)
name|addword
argument_list|(
name|baseo
operator|>>
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|siz1
condition|)
name|addword
argument_list|(
name|baseo
argument_list|)
expr_stmt|;
if|if
condition|(
name|isvar
argument_list|(
name|opP
operator|->
name|con2
argument_list|)
condition|)
block|{
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|PC
operator|||
name|opP
operator|->
name|reg
operator|==
name|ZPC
condition|)
block|{
name|add_fix
argument_list|(
name|siz2
operator|==
literal|3
condition|?
literal|'l'
else|:
literal|'w'
argument_list|,
name|opP
operator|->
name|con2
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|opP
operator|->
name|con1
operator|->
name|e_exp
operator|.
name|X_add_number
operator|+=
literal|6
expr_stmt|;
block|}
else|else
name|add_fix
argument_list|(
name|siz2
operator|==
literal|3
condition|?
literal|'l'
else|:
literal|'w'
argument_list|,
name|opP
operator|->
name|con2
argument_list|,
literal|0
argument_list|,
name|reloc_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|siz2
operator|==
literal|3
condition|)
name|addword
argument_list|(
name|outro
operator|>>
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|siz2
condition|)
name|addword
argument_list|(
name|outro
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABSL
case|:
name|nextword
operator|=
name|get_num
argument_list|(
name|opP
operator|->
name|con1
argument_list|,
literal|80
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opP
operator|->
name|con1
operator|->
name|e_siz
condition|)
block|{
default|default:
name|as_warn
argument_list|(
literal|"Unknown size for absolute reference"
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
if|if
condition|(
operator|!
name|isvar
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
operator|&&
name|issword
argument_list|(
name|offs
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
argument_list|)
condition|)
block|{
name|tmpreg
operator|=
literal|0x38
expr_stmt|;
comment|/* 7.0 */
name|addword
argument_list|(
name|nextword
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Don't generate pc relative code 					   on 68010 and 68000 */
if|if
condition|(
name|isvar
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
operator|&&
operator|!
name|subs
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
operator|&&
name|seg
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
operator|==
name|SEG_TEXT
operator|&&
name|now_seg
operator|==
name|SEG_TEXT
operator|&&
name|cpu_of_arch
argument_list|(
name|current_architecture
argument_list|)
operator|>=
name|m68020
operator|&&
operator|!
name|flagseen
index|[
literal|'S'
index|]
operator|&&
operator|!
name|strchr
argument_list|(
literal|"~%&$?"
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|tmpreg
operator|=
literal|0x3A
expr_stmt|;
comment|/* 7.2 */
name|add_frag
argument_list|(
name|adds
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
argument_list|,
name|offs
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
argument_list|,
name|TAB
argument_list|(
name|PCREL
argument_list|,
name|SZ_UNDEF
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|3
case|:
comment|/* Fall through into long */
if|if
condition|(
name|isvar
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
condition|)
name|add_fix
argument_list|(
literal|'l'
argument_list|,
name|opP
operator|->
name|con1
argument_list|,
literal|0
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|tmpreg
operator|=
literal|0x39
expr_stmt|;
comment|/* 7.1 mode */
name|addword
argument_list|(
name|nextword
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|addword
argument_list|(
name|nextword
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Word */
if|if
condition|(
name|isvar
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
condition|)
name|add_fix
argument_list|(
literal|'w'
argument_list|,
name|opP
operator|->
name|con1
argument_list|,
literal|0
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|tmpreg
operator|=
literal|0x38
expr_stmt|;
comment|/* 7.0 mode */
name|addword
argument_list|(
name|nextword
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|MSCR
case|:
default|default:
name|as_bad
argument_list|(
literal|"unknown/incorrect operand"
argument_list|)
expr_stmt|;
comment|/* abort(); */
block|}
name|install_gen_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
case|case
literal|'^'
case|:
switch|switch
condition|(
name|s
index|[
literal|1
index|]
condition|)
block|{
comment|/* JF: I hate floating point! */
case|case
literal|'j'
case|:
name|tmpreg
operator|=
literal|70
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
name|tmpreg
operator|=
literal|20
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|tmpreg
operator|=
literal|50
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
default|default:
name|tmpreg
operator|=
literal|80
expr_stmt|;
break|break;
block|}
name|tmpreg
operator|=
name|get_num
argument_list|(
name|opP
operator|->
name|con1
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|isvar
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
condition|)
name|add_fix
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|opP
operator|->
name|con1
argument_list|,
literal|0
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'b'
case|:
comment|/* Danger:  These do no check for 					   certain types of overflow. 					   user beware! */
if|if
condition|(
operator|!
name|isbyte
argument_list|(
name|tmpreg
argument_list|)
condition|)
name|opP
operator|->
name|error
operator|=
literal|"out of range"
expr_stmt|;
name|insop
argument_list|(
name|tmpreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|isvar
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
condition|)
name|the_ins
operator|.
name|reloc
index|[
name|the_ins
operator|.
name|nrel
operator|-
literal|1
index|]
operator|.
name|n
operator|=
operator|(
name|opcode
operator|->
name|m_codenum
operator|)
operator|*
literal|2
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
operator|!
name|isword
argument_list|(
name|tmpreg
argument_list|)
condition|)
name|opP
operator|->
name|error
operator|=
literal|"out of range"
expr_stmt|;
name|insop
argument_list|(
name|tmpreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|isvar
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
condition|)
name|the_ins
operator|.
name|reloc
index|[
name|the_ins
operator|.
name|nrel
operator|-
literal|1
index|]
operator|.
name|n
operator|=
operator|(
name|opcode
operator|->
name|m_codenum
operator|)
operator|*
literal|2
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|insop
argument_list|(
name|tmpreg
argument_list|)
expr_stmt|;
comment|/* Because of the way insop works, we put these two out backwards */
name|insop
argument_list|(
name|tmpreg
operator|>>
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|isvar
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
condition|)
name|the_ins
operator|.
name|reloc
index|[
name|the_ins
operator|.
name|nrel
operator|-
literal|1
index|]
operator|.
name|n
operator|=
operator|(
name|opcode
operator|->
name|m_codenum
operator|)
operator|*
literal|2
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
name|tmpreg
operator|&=
literal|0xFF
expr_stmt|;
case|case
literal|'8'
case|:
case|case
literal|'C'
case|:
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"Internal error:  Unknown mode #%c in line %s of file \"%s\""
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|__LINE__
argument_list|,
name|__FILE__
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|opP
operator|->
name|reg
operator|-
name|ADDR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|tmpreg
operator|=
name|get_num
argument_list|(
name|opP
operator|->
name|con1
argument_list|,
literal|80
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'B'
case|:
comment|/* Offset is relative to next word */
name|opP
operator|->
name|con1
operator|->
name|e_exp
operator|.
name|X_add_number
operator|-=
literal|1
expr_stmt|;
name|add_fix
argument_list|(
literal|'B'
argument_list|,
name|opP
operator|->
name|con1
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|add_fix
argument_list|(
literal|'w'
argument_list|,
name|opP
operator|->
name|con1
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|addword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|long_branch
label|:
if|if
condition|(
name|cpu_of_arch
argument_list|(
name|current_architecture
argument_list|)
operator|<
name|m68020
condition|)
comment|/* 68000 or 010 */
name|as_warn
argument_list|(
literal|"Can't use long branches on 68000/68010"
argument_list|)
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
name|the_ins
operator|.
name|numo
operator|-
literal|1
index|]
operator||=
literal|0xff
expr_stmt|;
name|add_fix
argument_list|(
literal|'l'
argument_list|,
name|opP
operator|->
name|con1
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|addword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|addword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
ifdef|#
directive|ifdef
name|PIC
comment|/* If we have the optional kludgey 2nd operand, 				   make this go via the jump table. */
if|if
condition|(
name|picmode
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|' '
condition|)
block|{
name|the_ins
operator|.
name|opcode
index|[
name|the_ins
operator|.
name|numo
operator|-
literal|1
index|]
operator||=
literal|0xFF
expr_stmt|;
name|add_fix
argument_list|(
literal|'l'
argument_list|,
name|opP
operator|->
name|con1
argument_list|,
literal|1
argument_list|,
name|RELOC_JMP_TBL
argument_list|)
expr_stmt|;
name|addword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|addword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* PIC */
if|if
condition|(
name|subs
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
condition|)
comment|/* We can't relax it */
goto|goto
name|long_branch
goto|;
comment|/* This could either be a symbol, or an 				   absolute address.  No matter, the 				   frag hacking will finger it out. 				   Not quite: it can't switch from 				   BRANCH to BCC68000 for the case 				   where opnd is absolute (it needs 				   to use the 68000 hack since no 				   conditional abs jumps).  */
if|if
condition|(
operator|(
operator|(
name|cpu_of_arch
argument_list|(
name|current_architecture
argument_list|)
operator|<
name|m68020
operator|)
operator|||
operator|(
literal|0
operator|==
name|adds
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator|>=
literal|0x6200
operator|)
operator|&&
operator|(
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator|<=
literal|0x6f00
operator|)
condition|)
block|{
name|add_frag
argument_list|(
name|adds
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
argument_list|,
name|offs
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
argument_list|,
name|TAB
argument_list|(
name|BCC68000
argument_list|,
name|SZ_UNDEF
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_frag
argument_list|(
name|adds
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
argument_list|,
name|offs
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
argument_list|,
name|TAB
argument_list|(
name|BRANCH
argument_list|,
name|SZ_UNDEF
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
name|isvar
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
condition|)
block|{
comment|/* check for DBcc instruction */
if|if
condition|(
operator|(
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator|&
literal|0xf0f8
operator|)
operator|==
literal|0x50c8
condition|)
block|{
comment|/* size varies if patch */
comment|/* needed for long form */
name|add_frag
argument_list|(
name|adds
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
argument_list|,
name|offs
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
argument_list|,
name|TAB
argument_list|(
name|DBCC
argument_list|,
name|SZ_UNDEF
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Don't ask! */
name|opP
operator|->
name|con1
operator|->
name|e_exp
operator|.
name|X_add_number
operator|+=
literal|2
expr_stmt|;
name|add_fix
argument_list|(
literal|'w'
argument_list|,
name|opP
operator|->
name|con1
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
name|addword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* Fixed size LONG coproc branches */
name|the_ins
operator|.
name|opcode
index|[
name|the_ins
operator|.
name|numo
operator|-
literal|1
index|]
operator||=
literal|0x40
expr_stmt|;
comment|/* Offset the displacement to be relative to byte disp location */
comment|/* Coproc branches don't have a byte disp option, but they are 				   compatible with the ordinary branches, which do... */
name|opP
operator|->
name|con1
operator|->
name|e_exp
operator|.
name|X_add_number
operator|+=
literal|4
expr_stmt|;
name|add_fix
argument_list|(
literal|'l'
argument_list|,
name|opP
operator|->
name|con1
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|addword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|addword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* Var size Coprocesssor branches */
if|if
condition|(
name|subs
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
condition|)
block|{
name|add_fix
argument_list|(
literal|'l'
argument_list|,
name|opP
operator|->
name|con1
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|add_frag
argument_list|(
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
name|TAB
argument_list|(
name|FBRANCH
argument_list|,
name|LONG
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adds
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
condition|)
block|{
name|add_frag
argument_list|(
name|adds
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
argument_list|,
name|offs
argument_list|(
name|opP
operator|->
name|con1
argument_list|)
argument_list|,
name|TAB
argument_list|(
name|FBRANCH
argument_list|,
name|SZ_UNDEF
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* add_frag((symbolS *)0,offs(opP->con1),TAB(FBRANCH,SHORT)); */
name|the_ins
operator|.
name|opcode
index|[
name|the_ins
operator|.
name|numo
operator|-
literal|1
index|]
operator||=
literal|0x40
expr_stmt|;
name|add_fix
argument_list|(
literal|'l'
argument_list|,
name|opP
operator|->
name|con1
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|addword
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|addword
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"Internal error:  operand type B%c unknown in line %s of file \"%s\""
argument_list|,
name|s
index|[
literal|1
index|]
argument_list|,
name|__LINE__
argument_list|,
name|__FILE__
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
comment|/* Ignore it */
break|break;
case|case
literal|'d'
case|:
comment|/* JF this is a kludge */
if|if
condition|(
name|opP
operator|->
name|mode
operator|==
name|AOFF
condition|)
block|{
name|install_operand
argument_list|(
literal|'s'
argument_list|,
name|opP
operator|->
name|reg
operator|-
name|ADDR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|tmpP
decl_stmt|;
name|tmpP
operator|=
name|opP
operator|->
name|con1
operator|->
name|e_end
operator|-
literal|2
expr_stmt|;
name|opP
operator|->
name|con1
operator|->
name|e_beg
operator|++
expr_stmt|;
name|opP
operator|->
name|con1
operator|->
name|e_end
operator|-=
literal|4
expr_stmt|;
comment|/* point to the , */
name|baseo
operator|=
name|m68k_reg_parse
argument_list|(
operator|&
name|tmpP
argument_list|)
expr_stmt|;
if|if
condition|(
name|baseo
operator|<
name|ADDR
operator|+
literal|0
operator|||
name|baseo
operator|>
name|ADDR
operator|+
literal|7
condition|)
block|{
name|as_bad
argument_list|(
literal|"Unknown address reg, using A0"
argument_list|)
expr_stmt|;
name|baseo
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|baseo
operator|-=
name|ADDR
expr_stmt|;
name|install_operand
argument_list|(
literal|'s'
argument_list|,
name|baseo
argument_list|)
expr_stmt|;
block|}
name|tmpreg
operator|=
name|get_num
argument_list|(
name|opP
operator|->
name|con1
argument_list|,
literal|80
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|issword
argument_list|(
name|tmpreg
argument_list|)
condition|)
block|{
name|as_warn
argument_list|(
literal|"Expression out of range, using 0"
argument_list|)
expr_stmt|;
name|tmpreg
operator|=
literal|0
expr_stmt|;
block|}
name|addword
argument_list|(
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|opP
operator|->
name|reg
operator|-
name|DATA
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|opP
operator|->
name|reg
operator|-
name|FPREG
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|tmpreg
operator|=
literal|1
operator|+
name|opP
operator|->
name|reg
operator|-
name|COPNUM
expr_stmt|;
if|if
condition|(
name|tmpreg
operator|==
literal|8
condition|)
name|tmpreg
operator|=
literal|0
expr_stmt|;
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
comment|/* JF foo */
switch|switch
condition|(
name|opP
operator|->
name|reg
condition|)
block|{
case|case
name|SFC
case|:
name|tmpreg
operator|=
literal|0x000
expr_stmt|;
break|break;
case|case
name|DFC
case|:
name|tmpreg
operator|=
literal|0x001
expr_stmt|;
break|break;
case|case
name|CACR
case|:
name|tmpreg
operator|=
literal|0x002
expr_stmt|;
break|break;
case|case
name|TC
case|:
name|tmpreg
operator|=
literal|0x003
expr_stmt|;
break|break;
case|case
name|ITT0
case|:
name|tmpreg
operator|=
literal|0x004
expr_stmt|;
break|break;
case|case
name|ITT1
case|:
name|tmpreg
operator|=
literal|0x005
expr_stmt|;
break|break;
case|case
name|DTT0
case|:
name|tmpreg
operator|=
literal|0x006
expr_stmt|;
break|break;
case|case
name|DTT1
case|:
name|tmpreg
operator|=
literal|0x007
expr_stmt|;
break|break;
case|case
name|USP
case|:
name|tmpreg
operator|=
literal|0x800
expr_stmt|;
break|break;
case|case
name|VBR
case|:
name|tmpreg
operator|=
literal|0x801
expr_stmt|;
break|break;
case|case
name|CAAR
case|:
name|tmpreg
operator|=
literal|0x802
expr_stmt|;
break|break;
case|case
name|MSP
case|:
name|tmpreg
operator|=
literal|0x803
expr_stmt|;
break|break;
case|case
name|ISP
case|:
name|tmpreg
operator|=
literal|0x804
expr_stmt|;
break|break;
case|case
name|MMUSR
case|:
name|tmpreg
operator|=
literal|0x805
expr_stmt|;
break|break;
case|case
name|URP
case|:
name|tmpreg
operator|=
literal|0x806
expr_stmt|;
break|break;
case|case
name|SRP
case|:
name|tmpreg
operator|=
literal|0x807
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"failed sanity check."
argument_list|)
expr_stmt|;
block|}
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|tmpreg
operator|=
name|get_num
argument_list|(
name|opP
operator|->
name|con1
argument_list|,
literal|55
argument_list|)
expr_stmt|;
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|tmpreg
operator|=
name|opP
operator|->
name|reg
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'w'
condition|)
block|{
if|if
condition|(
name|tmpreg
operator|&
literal|0x7FF0000
condition|)
name|as_bad
argument_list|(
literal|"Floating point register in register list"
argument_list|)
expr_stmt|;
name|insop
argument_list|(
name|reverse_16_bits
argument_list|(
name|tmpreg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tmpreg
operator|&
literal|0x700FFFF
condition|)
name|as_bad
argument_list|(
literal|"Wrong register in floating-point reglist"
argument_list|)
expr_stmt|;
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|reverse_8_bits
argument_list|(
name|tmpreg
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'L'
case|:
name|tmpreg
operator|=
name|opP
operator|->
name|reg
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'w'
condition|)
block|{
if|if
condition|(
name|tmpreg
operator|&
literal|0x7FF0000
condition|)
name|as_bad
argument_list|(
literal|"Floating point register in register list"
argument_list|)
expr_stmt|;
name|insop
argument_list|(
name|tmpreg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'8'
condition|)
block|{
if|if
condition|(
name|tmpreg
operator|&
literal|0x0FFFFFF
condition|)
name|as_bad
argument_list|(
literal|"incorrect register in reglist"
argument_list|)
expr_stmt|;
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
operator|>>
literal|24
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tmpreg
operator|&
literal|0x700FFFF
condition|)
name|as_bad
argument_list|(
literal|"wrong register in floating-point reglist"
argument_list|)
expr_stmt|;
else|else
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
operator|>>
literal|16
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'M'
case|:
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|get_num
argument_list|(
name|opP
operator|->
name|con1
argument_list|,
literal|60
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|tmpreg
operator|=
operator|(
name|opP
operator|->
name|mode
operator|==
name|DREG
operator|)
condition|?
literal|0x20
operator|+
name|opP
operator|->
name|reg
operator|-
name|DATA
else|:
operator|(
name|get_num
argument_list|(
name|opP
operator|->
name|con1
argument_list|,
literal|40
argument_list|)
operator|&
literal|0x1F
operator|)
expr_stmt|;
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|tmpreg
operator|=
name|get_num
argument_list|(
name|opP
operator|->
name|con1
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpreg
operator|==
literal|8
condition|)
name|tmpreg
operator|=
literal|0
expr_stmt|;
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
comment|/* This depends on the fact that ADDR registers are 			   eight more than their corresponding DATA regs, so 			   the result will have the ADDR_REG bit set */
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|opP
operator|->
name|reg
operator|-
name|DATA
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|FPI
condition|)
name|tmpreg
operator|=
literal|0x1
expr_stmt|;
elseif|else
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|FPS
condition|)
name|tmpreg
operator|=
literal|0x2
expr_stmt|;
elseif|else
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|FPC
condition|)
name|tmpreg
operator|=
literal|0x4
expr_stmt|;
else|else
name|as_fatal
argument_list|(
literal|"failed sanity check."
argument_list|)
expr_stmt|;
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* Ignore it */
break|break;
case|case
literal|'T'
case|:
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|get_num
argument_list|(
name|opP
operator|->
name|con1
argument_list|,
literal|30
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* Ignore it */
break|break;
case|case
literal|'c'
case|:
switch|switch
condition|(
name|opP
operator|->
name|reg
condition|)
block|{
case|case
name|NC
case|:
name|tmpreg
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DC
case|:
name|tmpreg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IC
case|:
name|tmpreg
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|BC
case|:
name|tmpreg
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"failed sanity check"
argument_list|)
expr_stmt|;
block|}
comment|/* switch on cache token */
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NO_68851
comment|/* JF: These are out of order, I fear. */
case|case
literal|'f'
case|:
switch|switch
condition|(
name|opP
operator|->
name|reg
condition|)
block|{
case|case
name|SFC
case|:
name|tmpreg
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DFC
case|:
name|tmpreg
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"failed sanity check."
argument_list|)
expr_stmt|;
block|}
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
switch|switch
condition|(
name|opP
operator|->
name|reg
condition|)
block|{
case|case
name|TC
case|:
name|tmpreg
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CAL
case|:
name|tmpreg
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|VAL
case|:
name|tmpreg
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|SCC
case|:
name|tmpreg
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|AC
case|:
name|tmpreg
operator|=
literal|7
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"failed sanity check."
argument_list|)
expr_stmt|;
block|}
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
if|if
condition|(
name|opP
operator|->
name|reg
operator|==
name|VAL
condition|)
break|break;
name|as_fatal
argument_list|(
literal|"failed sanity check."
argument_list|)
expr_stmt|;
case|case
literal|'W'
case|:
switch|switch
condition|(
name|opP
operator|->
name|reg
condition|)
block|{
case|case
name|DRP
case|:
name|tmpreg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SRP
case|:
name|tmpreg
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|CRP
case|:
name|tmpreg
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"failed sanity check."
argument_list|)
expr_stmt|;
block|}
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
switch|switch
condition|(
name|opP
operator|->
name|reg
condition|)
block|{
case|case
name|BAD
case|:
case|case
name|BAD
operator|+
literal|1
case|:
case|case
name|BAD
operator|+
literal|2
case|:
case|case
name|BAD
operator|+
literal|3
case|:
case|case
name|BAD
operator|+
literal|4
case|:
case|case
name|BAD
operator|+
literal|5
case|:
case|case
name|BAD
operator|+
literal|6
case|:
case|case
name|BAD
operator|+
literal|7
case|:
name|tmpreg
operator|=
operator|(
literal|4
operator|<<
literal|10
operator|)
operator||
operator|(
operator|(
name|opP
operator|->
name|reg
operator|-
name|BAD
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
break|break;
case|case
name|BAC
case|:
case|case
name|BAC
operator|+
literal|1
case|:
case|case
name|BAC
operator|+
literal|2
case|:
case|case
name|BAC
operator|+
literal|3
case|:
case|case
name|BAC
operator|+
literal|4
case|:
case|case
name|BAC
operator|+
literal|5
case|:
case|case
name|BAC
operator|+
literal|6
case|:
case|case
name|BAC
operator|+
literal|7
case|:
name|tmpreg
operator|=
operator|(
literal|5
operator|<<
literal|10
operator|)
operator||
operator|(
operator|(
name|opP
operator|->
name|reg
operator|-
name|BAC
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"failed sanity check."
argument_list|)
expr_stmt|;
block|}
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
name|know
argument_list|(
name|opP
operator|->
name|reg
operator|==
name|PSR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|know
argument_list|(
name|opP
operator|->
name|reg
operator|==
name|PCSR
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* m68851 */
case|case
literal|'_'
case|:
name|tmpreg
operator|=
name|get_num
argument_list|(
name|opP
operator|->
name|con1
argument_list|,
literal|80
argument_list|)
expr_stmt|;
name|install_operand
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|,
name|tmpreg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"Internal error:  Operand type %c unknown in line %s of file \"%s\""
argument_list|,
name|s
index|[
literal|0
index|]
argument_list|,
name|__LINE__
argument_list|,
name|__FILE__
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* By the time whe get here (FINALLY) the_ins contains the complete 	   instruction, ready to be emitted... */
block|}
end_function

begin_comment
comment|/* m68k_ip() */
end_comment

begin_comment
comment|/*  * get_regs := '/' + ?  *	| '-' +<register>  *	| '-' +<register> + ?  *	|<empty>  *	;  *   * The idea here must be to scan in a set of registers but I don't  * understand it.  Looks awfully sloppy to me but I don't have any doc on  * this format so...   *  *  */
end_comment

begin_function
specifier|static
name|int
name|get_regs
parameter_list|(
name|i
parameter_list|,
name|str
parameter_list|,
name|opP
parameter_list|)
name|int
name|i
decl_stmt|;
name|struct
name|m68k_op
modifier|*
name|opP
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
comment|/*			     26, 25, 24, 23-16,  15-8, 0-7 */
comment|/* Low order 24 bits encoded fpc,fps,fpi,fp7-fp0,a7-a0,d7-d0 */
name|unsigned
name|long
name|cur_regs
init|=
literal|0
decl_stmt|;
name|int
name|reg1
decl_stmt|,
name|reg2
decl_stmt|;
define|#
directive|define
name|ADD_REG
parameter_list|(
name|x
parameter_list|)
value|{     if (x == FPI) cur_regs|=(1<<24);\ else if (x == FPS) cur_regs|=(1<<25);\ else if (x == FPC) cur_regs|=(1<<26);\ else cur_regs|=(1<<(x-1));  }
name|reg1
operator|=
name|i
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|'/'
condition|)
block|{
name|ADD_REG
argument_list|(
name|reg1
argument_list|)
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|'-'
condition|)
block|{
name|str
operator|++
expr_stmt|;
name|reg2
operator|=
name|m68k_reg_parse
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg2
operator|<
name|DATA
operator|||
name|reg2
operator|>=
name|FPREG
operator|+
literal|8
operator|||
name|reg1
operator|==
name|FPI
operator|||
name|reg1
operator|==
name|FPS
operator|||
name|reg1
operator|==
name|FPC
condition|)
block|{
name|opP
operator|->
name|error
operator|=
literal|"unknown register in register list"
expr_stmt|;
return|return
name|FAIL
return|;
block|}
while|while
condition|(
name|reg1
operator|<=
name|reg2
condition|)
block|{
name|ADD_REG
argument_list|(
name|reg1
argument_list|)
expr_stmt|;
name|reg1
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|str
operator|==
literal|'\0'
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|'\0'
condition|)
block|{
name|ADD_REG
argument_list|(
name|reg1
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|opP
operator|->
name|error
operator|=
literal|"unknow character in register list"
expr_stmt|;
return|return
name|FAIL
return|;
block|}
comment|/* DJA -- Bug Fix.  Did't handle d1-d2/a1 until the following instruction was added */
if|if
condition|(
operator|*
name|str
operator|==
literal|'/'
condition|)
name|str
operator|++
expr_stmt|;
name|reg1
operator|=
name|m68k_reg_parse
argument_list|(
operator|&
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|reg1
operator|<
name|DATA
operator|||
name|reg1
operator|>=
name|FPREG
operator|+
literal|8
operator|)
operator|&&
operator|!
operator|(
name|reg1
operator|==
name|FPI
operator|||
name|reg1
operator|==
name|FPS
operator|||
name|reg1
operator|==
name|FPC
operator|)
condition|)
block|{
name|opP
operator|->
name|error
operator|=
literal|"unknown register in register list"
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
name|opP
operator|->
name|reg
operator|=
name|cur_regs
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/* get_regs() */
end_comment

begin_function
specifier|static
name|int
name|reverse_16_bits
parameter_list|(
name|in
parameter_list|)
name|int
name|in
decl_stmt|;
block|{
name|int
name|out
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|static
name|int
name|mask
index|[
literal|16
index|]
init|=
block|{
literal|0x0001
block|,
literal|0x0002
block|,
literal|0x0004
block|,
literal|0x0008
block|,
literal|0x0010
block|,
literal|0x0020
block|,
literal|0x0040
block|,
literal|0x0080
block|,
literal|0x0100
block|,
literal|0x0200
block|,
literal|0x0400
block|,
literal|0x0800
block|,
literal|0x1000
block|,
literal|0x2000
block|,
literal|0x4000
block|,
literal|0x8000
block|}
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|16
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|in
operator|&
name|mask
index|[
name|n
index|]
condition|)
name|out
operator||=
name|mask
index|[
literal|15
operator|-
name|n
index|]
expr_stmt|;
block|}
return|return
name|out
return|;
block|}
end_function

begin_comment
comment|/* reverse_16_bits() */
end_comment

begin_function
specifier|static
name|int
name|reverse_8_bits
parameter_list|(
name|in
parameter_list|)
name|int
name|in
decl_stmt|;
block|{
name|int
name|out
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|static
name|int
name|mask
index|[
literal|8
index|]
init|=
block|{
literal|0x0001
block|,
literal|0x0002
block|,
literal|0x0004
block|,
literal|0x0008
block|,
literal|0x0010
block|,
literal|0x0020
block|,
literal|0x0040
block|,
literal|0x0080
block|, 	}
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|8
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|in
operator|&
name|mask
index|[
name|n
index|]
condition|)
name|out
operator||=
name|mask
index|[
literal|7
operator|-
name|n
index|]
expr_stmt|;
block|}
return|return
name|out
return|;
block|}
end_function

begin_comment
comment|/* reverse_8_bits() */
end_comment

begin_function
specifier|static
name|void
name|install_operand
parameter_list|(
name|mode
parameter_list|,
name|val
parameter_list|)
name|int
name|mode
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|'s'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
name|val
operator|&
literal|0xFF
expr_stmt|;
comment|/* JF FF is for M kludge */
break|break;
case|case
literal|'d'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
name|val
operator|<<
literal|9
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
name|val
operator|<<
literal|12
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
name|val
operator|<<
literal|6
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
name|val
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|2
index|]
operator||=
name|val
operator|<<
literal|12
expr_stmt|;
break|break;
case|case
literal|'5'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|2
index|]
operator||=
name|val
operator|<<
literal|6
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
comment|/* DANGER!  This is a hack to force cas2l and cas2w cmds 		   to be three words long! */
name|the_ins
operator|.
name|numo
operator|++
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|2
index|]
operator||=
name|val
expr_stmt|;
break|break;
case|case
literal|'7'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
name|val
operator|<<
literal|7
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
name|val
operator|<<
literal|10
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NO_68851
case|case
literal|'9'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
name|val
operator|<<
literal|5
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'t'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
operator|(
name|val
operator|<<
literal|10
operator|)
operator||
operator|(
name|val
operator|<<
literal|7
operator|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
operator|(
name|val
operator|<<
literal|12
operator|)
operator||
name|val
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
name|val
operator|=
literal|0xff
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
name|val
operator|<<
literal|9
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
name|val
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
name|val
expr_stmt|;
name|the_ins
operator|.
name|numo
operator|++
expr_stmt|;
comment|/* What a hack */
break|break;
case|case
literal|'k'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator||=
name|val
operator|<<
literal|4
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'w'
case|:
case|case
literal|'l'
case|:
break|break;
case|case
literal|'e'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
operator|(
name|val
operator|<<
literal|6
operator|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|1
index|]
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
expr_stmt|;
name|the_ins
operator|.
name|opcode
index|[
literal|2
index|]
operator|=
name|val
operator|&
literal|0xffff
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
default|default:
name|as_fatal
argument_list|(
literal|"failed sanity check."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* install_operand() */
end_comment

begin_function
specifier|static
name|void
name|install_gen_operand
parameter_list|(
name|mode
parameter_list|,
name|val
parameter_list|)
name|int
name|mode
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|'s'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
name|val
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* This is a kludge!!! */
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
operator|(
name|val
operator|&
literal|0x07
operator|)
operator|<<
literal|9
operator||
operator|(
name|val
operator|&
literal|0x38
operator|)
operator|<<
literal|3
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'w'
case|:
case|case
literal|'l'
case|:
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'x'
case|:
case|case
literal|'p'
case|:
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
operator||=
name|val
expr_stmt|;
break|break;
comment|/* more stuff goes here */
default|default:
name|as_fatal
argument_list|(
literal|"failed sanity check."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* install_gen_operand() */
end_comment

begin_comment
comment|/*  * verify that we have some number of paren pairs, do m68k_ip_op(), and  * then deal with the bitfield hack.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|crack_operand
parameter_list|(
name|str
parameter_list|,
name|opP
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
specifier|register
name|struct
name|m68k_op
modifier|*
name|opP
decl_stmt|;
block|{
specifier|register
name|int
name|parens
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|beg_str
decl_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
block|{
return|return
name|str
return|;
block|}
name|beg_str
operator|=
name|str
expr_stmt|;
for|for
control|(
name|parens
operator|=
literal|0
init|;
operator|*
name|str
operator|&&
operator|(
name|parens
operator|>
literal|0
operator|||
name|notend
argument_list|(
name|str
argument_list|)
operator|)
condition|;
name|str
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|'('
condition|)
name|parens
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
operator|!
name|parens
condition|)
block|{
comment|/* ERROR */
name|opP
operator|->
name|error
operator|=
literal|"Extra )"
expr_stmt|;
return|return
name|str
return|;
block|}
operator|--
name|parens
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|str
operator|&&
name|parens
condition|)
block|{
comment|/* ERROR */
name|opP
operator|->
name|error
operator|=
literal|"Missing )"
expr_stmt|;
return|return
name|str
return|;
block|}
name|c
operator|=
operator|*
name|str
expr_stmt|;
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|m68k_ip_op
argument_list|(
name|beg_str
argument_list|,
name|opP
argument_list|)
operator|==
name|FAIL
condition|)
block|{
operator|*
name|str
operator|=
name|c
expr_stmt|;
return|return
name|str
return|;
block|}
operator|*
name|str
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'}'
condition|)
name|c
operator|=
operator|*
operator|++
name|str
expr_stmt|;
comment|/* JF bitfield hack */
if|if
condition|(
name|c
condition|)
block|{
name|c
operator|=
operator|*
operator|++
name|str
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
name|as_bad
argument_list|(
literal|"Missing operand"
argument_list|)
expr_stmt|;
block|}
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* See the comment up above where the #define notend(... is */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|notend(s) char *s; { 	if (*s == ',') return 0; 	if (*s == '{' || *s == '}') 	    return 0; 	if (*s != ':') return 1;
comment|/* This kludge here is for the division cmd, which is a kludge */
end_comment

begin_endif
unit|if (index("aAdD#",s[1])) return 0; 	return 1; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Generate a new fixup for one of the relocs in the_ins.  */
end_comment

begin_function
specifier|static
name|void
name|make_fix
parameter_list|(
name|m
parameter_list|,
name|where
parameter_list|)
name|int
name|m
decl_stmt|;
name|char
modifier|*
name|where
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
switch|switch
condition|(
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|wid
condition|)
block|{
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
name|n
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
case|case
literal|'w'
case|:
name|n
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|n
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"Don't know how to figure width of %c in md_assemble()"
argument_list|,
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|wid
argument_list|)
expr_stmt|;
block|}
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|where
operator|-
name|frag_now
operator|->
name|fr_literal
operator|+
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|n
argument_list|,
name|n
argument_list|,
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|add
argument_list|,
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|sub
argument_list|,
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|off
argument_list|,
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|pcrel
argument_list|,
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|rtype
ifdef|#
directive|ifdef
name|PIC
argument_list|,
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|got
endif|#
directive|endif
comment|/* PIC */
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PIC
if|if
condition|(
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|rtype
operator|==
name|RELOC_GLOB_DAT
operator|&&
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|add
operator|!=
name|NULL
condition|)
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|add
operator|->
name|sy_forceout
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* PIC */
block|}
end_function

begin_comment
comment|/* This is the guts of the machine-dependent assembler.  STR points to a    machine dependent instruction.  This function is supposed to emit    the frags/bytes it assembles to.    */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|er
decl_stmt|;
name|short
modifier|*
name|fromP
decl_stmt|;
name|char
modifier|*
name|toP
init|=
name|NULL
decl_stmt|;
name|int
name|m
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|to_beg_P
decl_stmt|;
name|int
name|shorts_this_frag
decl_stmt|;
if|if
condition|(
name|current_architecture
operator|==
literal|0
condition|)
block|{
name|current_architecture
operator|=
operator|(
name|m68020
ifndef|#
directive|ifndef
name|NO_68881
operator||
name|m68881
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_68851
operator||
name|m68851
endif|#
directive|endif
operator|)
expr_stmt|;
block|}
comment|/* default current_architecture */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|the_ins
operator|)
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|the_ins
argument_list|)
argument_list|)
expr_stmt|;
comment|/* JF for paranoia sake */
name|m68k_ip
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|er
operator|=
name|the_ins
operator|.
name|error
expr_stmt|;
if|if
condition|(
operator|!
name|er
condition|)
block|{
for|for
control|(
name|n
operator|=
name|the_ins
operator|.
name|numargs
init|;
name|n
condition|;
operator|--
name|n
control|)
if|if
condition|(
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|error
condition|)
block|{
name|er
operator|=
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|error
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|er
condition|)
block|{
name|as_bad
argument_list|(
literal|"\"%s\" -- Statement '%s' ignored"
argument_list|,
name|er
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|the_ins
operator|.
name|nfrag
operator|==
literal|0
condition|)
block|{
comment|/* No frag hacking involved; just put it out */
name|toP
operator|=
name|frag_more
argument_list|(
literal|2
operator|*
name|the_ins
operator|.
name|numo
argument_list|)
expr_stmt|;
name|fromP
operator|=
operator|&
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|m
operator|=
name|the_ins
operator|.
name|numo
init|;
name|m
condition|;
operator|--
name|m
control|)
block|{
name|md_number_to_chars
argument_list|(
name|toP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|fromP
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|toP
operator|+=
literal|2
expr_stmt|;
name|fromP
operator|++
expr_stmt|;
block|}
comment|/* put out symbol-dependent info */
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|the_ins
operator|.
name|nrel
condition|;
name|m
operator|++
control|)
block|{
name|make_fix
argument_list|(
name|m
argument_list|,
name|toP
operator|-
name|the_ins
operator|.
name|numo
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* There's some frag hacking */
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|fromP
operator|=
operator|&
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
init|;
name|n
operator|<
name|the_ins
operator|.
name|nfrag
condition|;
name|n
operator|++
control|)
block|{
name|int
name|wid
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|wid
operator|=
literal|2
operator|*
name|the_ins
operator|.
name|fragb
index|[
name|n
index|]
operator|.
name|fragoff
expr_stmt|;
else|else
name|wid
operator|=
literal|2
operator|*
operator|(
name|the_ins
operator|.
name|numo
operator|-
name|the_ins
operator|.
name|fragb
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|fragoff
operator|)
expr_stmt|;
name|toP
operator|=
name|frag_more
argument_list|(
name|wid
argument_list|)
expr_stmt|;
name|to_beg_P
operator|=
name|toP
expr_stmt|;
name|shorts_this_frag
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|wid
operator|/
literal|2
init|;
name|m
condition|;
operator|--
name|m
control|)
block|{
name|md_number_to_chars
argument_list|(
name|toP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|fromP
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|toP
operator|+=
literal|2
expr_stmt|;
name|fromP
operator|++
expr_stmt|;
name|shorts_this_frag
operator|++
expr_stmt|;
block|}
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|the_ins
operator|.
name|nrel
condition|;
name|m
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|n
operator|)
operator|>=
literal|2
operator|*
name|shorts_this_frag
comment|/* 2*the_ins.fragb[n].fragoff */
condition|)
block|{
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|n
operator|-=
literal|2
operator|*
name|shorts_this_frag
comment|/* 2*the_ins.fragb[n].fragoff */
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|wid
operator|==
literal|0
condition|)
continue|continue;
name|make_fix
argument_list|(
name|m
argument_list|,
name|toP
operator|-
name|the_ins
operator|.
name|numo
operator|*
literal|2
argument_list|)
expr_stmt|;
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|wid
operator|=
literal|0
expr_stmt|;
block|}
comment|/* know(the_ins.fragb[n].fadd); */
operator|(
name|void
operator|)
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|,
call|(
name|relax_substateT
call|)
argument_list|(
name|the_ins
operator|.
name|fragb
index|[
name|n
index|]
operator|.
name|fragty
argument_list|)
argument_list|,
name|the_ins
operator|.
name|fragb
index|[
name|n
index|]
operator|.
name|fadd
argument_list|,
name|the_ins
operator|.
name|fragb
index|[
name|n
index|]
operator|.
name|foff
argument_list|,
name|to_beg_P
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
operator|(
name|the_ins
operator|.
name|numo
operator|-
name|the_ins
operator|.
name|fragb
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|fragoff
operator|)
expr_stmt|;
name|shorts_this_frag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|toP
operator|=
name|frag_more
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|toP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|fromP
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|toP
operator|+=
literal|2
expr_stmt|;
name|fromP
operator|++
expr_stmt|;
name|shorts_this_frag
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|m
operator|=
literal|0
init|;
name|m
operator|<
name|the_ins
operator|.
name|nrel
condition|;
name|m
operator|++
control|)
block|{
if|if
condition|(
name|the_ins
operator|.
name|reloc
index|[
name|m
index|]
operator|.
name|wid
operator|==
literal|0
condition|)
continue|continue;
name|make_fix
argument_list|(
name|m
argument_list|,
name|toP
operator|-
comment|/* the_ins.numo */
name|shorts_this_frag
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function is called once, at assembler startup time.  This should    set up all the tables, etc that the MD part of the assembler needs    */
end_comment

begin_function
name|void
name|md_begin
parameter_list|()
block|{
comment|/* 	 * md_begin -- set up hash tables with 68000 instructions. 	 * similar to what the vax assembler does.  ---phr 	 */
comment|/* RMS claims the thing to do is take the m68k-opcode.h table, and make 	   a copy of it at runtime, adding in the information we want but isn't 	   there.  I think it'd be better to have an awk script hack the table 	   at compile time.  Or even just xstr the table and use it as-is.  But 	   my lord ghod hath spoken, so we do it this way.  Excuse the ugly var 	   names.  */
specifier|register
specifier|const
name|struct
name|m68k_opcode
modifier|*
name|ins
decl_stmt|;
specifier|register
name|struct
name|m68k_incant
modifier|*
name|hack
decl_stmt|,
modifier|*
name|slak
decl_stmt|;
specifier|register
name|char
modifier|*
name|retval
init|=
literal|0
decl_stmt|;
comment|/* empty string, or error msg text */
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|op_hash
operator|=
name|hash_new
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
literal|"Virtual memory exhausted"
argument_list|)
expr_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|robyn
argument_list|,
literal|4000
argument_list|)
expr_stmt|;
for|for
control|(
name|ins
operator|=
name|m68k_opcodes
init|;
name|ins
operator|<
name|endop
condition|;
name|ins
operator|++
control|)
block|{
name|hack
operator|=
name|slak
operator|=
operator|(
expr|struct
name|m68k_incant
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|robyn
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|m68k_incant
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* we *could* ignore insns that don't match our 			   arch here but just leaving them out of the 			   hash. */
name|slak
operator|->
name|m_operands
operator|=
name|ins
operator|->
name|args
expr_stmt|;
name|slak
operator|->
name|m_opnum
operator|=
name|strlen
argument_list|(
name|slak
operator|->
name|m_operands
argument_list|)
operator|/
literal|2
expr_stmt|;
name|slak
operator|->
name|m_arch
operator|=
name|ins
operator|->
name|arch
expr_stmt|;
name|slak
operator|->
name|m_opcode
operator|=
name|ins
operator|->
name|opcode
expr_stmt|;
comment|/* This is kludgey */
name|slak
operator|->
name|m_codenum
operator|=
operator|(
operator|(
name|ins
operator|->
name|match
operator|)
operator|&
literal|0xffffL
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|ins
operator|+
literal|1
operator|)
operator|!=
name|endop
operator|&&
operator|!
name|strcmp
argument_list|(
name|ins
operator|->
name|name
argument_list|,
operator|(
name|ins
operator|+
literal|1
operator|)
operator|->
name|name
argument_list|)
condition|)
block|{
name|slak
operator|->
name|m_next
operator|=
operator|(
expr|struct
name|m68k_incant
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|robyn
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|m68k_incant
argument_list|)
argument_list|)
expr_stmt|;
name|ins
operator|++
expr_stmt|;
block|}
else|else
name|slak
operator|->
name|m_next
operator|=
literal|0
expr_stmt|;
name|slak
operator|=
name|slak
operator|->
name|m_next
expr_stmt|;
block|}
do|while
condition|(
name|slak
condition|)
do|;
name|retval
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|ins
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hack
argument_list|)
expr_stmt|;
comment|/* Didn't his mommy tell him about null pointers? */
if|if
condition|(
name|retval
operator|&&
operator|*
name|retval
condition|)
name|as_fatal
argument_list|(
literal|"Internal Error:  Can't hash %s: %s"
argument_list|,
name|ins
operator|->
name|name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|mklower_table
argument_list|)
condition|;
name|i
operator|++
control|)
name|mklower_table
index|[
name|i
index|]
operator|=
operator|(
name|isupper
argument_list|(
name|c
operator|=
operator|(
name|char
operator|)
name|i
argument_list|)
operator|)
condition|?
name|tolower
argument_list|(
name|c
argument_list|)
else|:
name|c
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|notend_table
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|notend_table
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|alt_notend_table
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|notend_table
index|[
literal|','
index|]
operator|=
literal|1
expr_stmt|;
name|notend_table
index|[
literal|'{'
index|]
operator|=
literal|1
expr_stmt|;
name|notend_table
index|[
literal|'}'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'a'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'A'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'d'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'D'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'#'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'f'
index|]
operator|=
literal|1
expr_stmt|;
name|alt_notend_table
index|[
literal|'F'
index|]
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|REGISTER_PREFIX
name|alt_notend_table
index|[
name|REGISTER_PREFIX
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|notend
parameter_list|(
name|s
parameter_list|)
value|((*s == ',' || *s == '}' || *s == '{' \ 		    || (*s == ':'&& strchr("aAdD#", s[1]))) \ 		   ? 0 : 1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This funciton is called once, before the assembler exits.  It is    supposed to do any final cleanup for this part of the assembler.    */
end_comment

begin_function
name|void
name|md_end
parameter_list|()
block|{ }
end_function

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_comment
comment|/* Turn a string in input_line_pointer into a floating point constant of type    type, and store the appropriate bytes in *litP.  The number of LITTLENUMS    emitted is stored in *sizeP. An error message is returned, or NULL on OK.    */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|atof_ieee
parameter_list|()
function_decl|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
literal|"Bad call to MD_ATOF()"
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|wordP
operator|=
name|words
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|wordP
operator|++
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
comment|/* Someone should teach Dean about null pointers */
block|}
end_function

begin_comment
comment|/* Turn an integer of n bytes (in val) into a stream of bytes appropriate    for use in the a.out file, and stores them in the array pointed to by buf.    This knows about the endian-ness of the target machine and does    THE RIGHT THING, whatever it is.  Possible values for n are 1 (byte)    2 (short) and 4 (long)  Floating numbers are put out as a series of    LITTLENUMS (shorts, here at least)    */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|1
case|:
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
case|case
literal|4
case|:
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|24
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"failed sanity check."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixP
parameter_list|,
name|val
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|long
name|val
decl_stmt|;
block|{
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_size
condition|)
block|{
case|case
literal|1
case|:
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
case|case
literal|4
case|:
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|24
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* *fragP has been relaxed to its final size, and now needs to have    the bytes inside it modified to conform to the new size  There is UGLY    MAGIC here. ..    */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|headers
parameter_list|,
name|fragP
parameter_list|)
name|object_headers
modifier|*
name|headers
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|long
name|disp
decl_stmt|;
name|long
name|ext
init|=
literal|0
decl_stmt|;
comment|/* Address in object code of the displacement.  */
specifier|register
name|int
name|object_address
init|=
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_address
decl_stmt|;
ifdef|#
directive|ifdef
name|IBM_COMPILER_SUX
comment|/* This is wrong but it convinces the native rs6000 compiler to 	   generate the code we want. */
specifier|register
name|char
modifier|*
name|buffer_address
init|=
name|fragP
operator|->
name|fr_literal
decl_stmt|;
name|buffer_address
operator|+=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
else|#
directive|else
comment|/* IBM_COMPILER_SUX */
comment|/* Address in gas core of the place to store the displacement.  */
specifier|register
name|char
modifier|*
name|buffer_address
init|=
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_literal
decl_stmt|;
endif|#
directive|endif
comment|/* IBM_COMPILER_SUX */
comment|/* No longer true:   know(fragP->fr_symbol); */
comment|/* The displacement of the address, from current location.  */
name|disp
operator|=
name|fragP
operator|->
name|fr_symbol
condition|?
name|S_GET_VALUE
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
else|:
literal|0
expr_stmt|;
name|disp
operator|=
operator|(
name|disp
operator|+
name|fragP
operator|->
name|fr_offset
operator|)
operator|-
name|object_address
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|TAB
argument_list|(
name|BCC68000
argument_list|,
name|BYTE
argument_list|)
case|:
case|case
name|TAB
argument_list|(
name|BRANCH
argument_list|,
name|BYTE
argument_list|)
case|:
name|know
argument_list|(
name|issbyte
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
operator|==
literal|0
condition|)
name|as_bad
argument_list|(
literal|"short branch with zero offset: use :w"
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
name|disp
expr_stmt|;
name|ext
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|DBCC
argument_list|,
name|SHORT
argument_list|)
case|:
name|know
argument_list|(
name|issword
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
name|ext
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|BCC68000
argument_list|,
name|SHORT
argument_list|)
case|:
case|case
name|TAB
argument_list|(
name|BRANCH
argument_list|,
name|SHORT
argument_list|)
case|:
name|know
argument_list|(
name|issword
argument_list|(
name|disp
argument_list|)
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
name|ext
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|BRANCH
argument_list|,
name|LONG
argument_list|)
case|:
if|if
condition|(
name|cpu_of_arch
argument_list|(
name|current_architecture
argument_list|)
operator|<
name|m68020
condition|)
block|{
if|if
condition|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|==
literal|0x61
condition|)
block|{
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|=
literal|0x4E
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
literal|0xB9
expr_stmt|;
comment|/* JBSR with ABSL LONG offset */
name|subseg_change
argument_list|(
name|SEG_TEXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|FIX_NO_RELOC
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
name|ext
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|==
literal|0x60
condition|)
block|{
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|=
literal|0x4E
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
literal|0xF9
expr_stmt|;
comment|/* JMP  with ABSL LONG offset */
name|subseg_change
argument_list|(
name|SEG_TEXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|FIX_NO_RELOC
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
name|ext
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|"Long branch offset not supported."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
literal|0xff
expr_stmt|;
name|ext
operator|=
literal|4
expr_stmt|;
block|}
break|break;
case|case
name|TAB
argument_list|(
name|BCC68000
argument_list|,
name|LONG
argument_list|)
case|:
comment|/* only Bcc 68000 instructions can come here */
comment|/* change bcc into b!cc/jmp absl long */
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|^=
literal|0x01
expr_stmt|;
comment|/* invert bcc */
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
literal|0x6
expr_stmt|;
comment|/* branch offset = 6 */
comment|/* JF: these used to be fr_opcode[2,3], but they may be in a 	   different frag, in which case refering to them is a no-no. 	   Only fr_opcode[0,1] are guaranteed to work. */
operator|*
name|buffer_address
operator|++
operator|=
literal|0x4e
expr_stmt|;
comment|/* put in jmp long (0x4ef9) */
operator|*
name|buffer_address
operator|++
operator|=
literal|0xf9
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
comment|/* account for jmp instruction */
name|subseg_change
argument_list|(
name|SEG_TEXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|FIX_NO_RELOC
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
name|ext
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|DBCC
argument_list|,
name|LONG
argument_list|)
case|:
comment|/* only DBcc 68000 instructions can come here */
comment|/* change dbcc into dbcc/jmp absl long */
comment|/* JF: these used to be fr_opcode[2-7], but that's wrong */
operator|*
name|buffer_address
operator|++
operator|=
literal|0x00
expr_stmt|;
comment|/* branch offset = 4 */
operator|*
name|buffer_address
operator|++
operator|=
literal|0x04
expr_stmt|;
operator|*
name|buffer_address
operator|++
operator|=
literal|0x60
expr_stmt|;
comment|/* put in bra pc+6 */
operator|*
name|buffer_address
operator|++
operator|=
literal|0x06
expr_stmt|;
operator|*
name|buffer_address
operator|++
operator|=
literal|0x4e
expr_stmt|;
comment|/* put in jmp long (0x4ef9) */
operator|*
name|buffer_address
operator|++
operator|=
literal|0xf9
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|6
expr_stmt|;
comment|/* account for bra/jmp instructions */
name|subseg_change
argument_list|(
name|SEG_TEXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|FIX_NO_RELOC
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
name|ext
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|FBRANCH
argument_list|,
name|SHORT
argument_list|)
case|:
name|know
argument_list|(
operator|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|&
literal|0x40
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ext
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|FBRANCH
argument_list|,
name|LONG
argument_list|)
case|:
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator||=
literal|0x40
expr_stmt|;
comment|/* Turn on LONG bit */
name|ext
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|PCREL
argument_list|,
name|SHORT
argument_list|)
case|:
name|ext
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|PCREL
argument_list|,
name|LONG
argument_list|)
case|:
comment|/* The thing to do here is force it to ABSOLUTE LONG, since 	PCREL is really trying to shorten an ABSOLUTE address anyway */
comment|/* JF FOO This code has not been tested */
name|subseg_change
argument_list|(
name|SEG_TEXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|FIX_NO_RELOC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|&
literal|0x3F
operator|)
operator|!=
literal|0x3A
condition|)
name|as_bad
argument_list|(
literal|"Internal error (long PC-relative operand) for insn 0x%04lx at 0x%lx"
argument_list|,
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
argument_list|,
name|fragP
operator|->
name|fr_address
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|&=
operator|~
literal|0x3F
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator||=
literal|0x39
expr_stmt|;
comment|/* Mode 7.1 */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
comment|/* md_number_to_chars(buffer_address, 	   (long)(fragP->fr_symbol->sy_value + fragP->fr_offset), 	   4); */
name|ext
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|PCLEA
argument_list|,
name|SHORT
argument_list|)
case|:
name|subseg_change
argument_list|(
name|SEG_TEXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
call|(
name|int
call|)
argument_list|(
name|fragP
operator|->
name|fr_fix
argument_list|)
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|FIX_NO_RELOC
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|&=
operator|~
literal|0x3F
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator||=
literal|0x3A
expr_stmt|;
name|ext
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|TAB
argument_list|(
name|PCLEA
argument_list|,
name|LONG
argument_list|)
case|:
name|subseg_change
argument_list|(
name|SEG_TEXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
call|(
name|int
call|)
argument_list|(
name|fragP
operator|->
name|fr_fix
argument_list|)
operator|+
literal|2
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
operator|+
literal|2
argument_list|,
literal|1
argument_list|,
name|FIX_NO_RELOC
argument_list|)
expr_stmt|;
operator|*
name|buffer_address
operator|++
operator|=
literal|0x01
expr_stmt|;
operator|*
name|buffer_address
operator|++
operator|=
literal|0x70
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
comment|/* buffer_address+=2; */
name|ext
operator|=
literal|4
expr_stmt|;
break|break;
block|}
comment|/* switch on subtype */
if|if
condition|(
name|ext
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|buffer_address
argument_list|,
operator|(
name|long
operator|)
name|disp
argument_list|,
operator|(
name|int
operator|)
name|ext
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|ext
expr_stmt|;
comment|/*	  H_SET_TEXT_SIZE(headers, H_GET_TEXT_SIZE(headers) + ext); */
block|}
comment|/* if extending */
return|return;
block|}
end_function

begin_comment
comment|/* md_convert_frag() */
end_comment

begin_comment
comment|/* Force truly undefined symbols to their maximum size, and generally set up    the frag list to be relaxed    */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment
parameter_list|)
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|segT
name|segment
decl_stmt|;
block|{
name|int
name|old_fix
decl_stmt|;
specifier|register
name|char
modifier|*
name|buffer_address
init|=
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_literal
decl_stmt|;
name|old_fix
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
comment|/* handle SZ_UNDEF first, it can be changed to BYTE or SHORT */
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|TAB
argument_list|(
name|BRANCH
argument_list|,
name|SZ_UNDEF
argument_list|)
case|:
block|{
if|if
condition|(
operator|(
name|fragP
operator|->
name|fr_symbol
operator|!=
name|NULL
operator|)
comment|/* Not absolute */
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|TAB
argument_list|(
name|TABTYPE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
argument_list|,
name|BYTE
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|fragP
operator|->
name|fr_symbol
operator|==
literal|0
operator|)
operator|||
operator|(
name|cpu_of_arch
argument_list|(
name|current_architecture
argument_list|)
operator|<
name|m68020
operator|)
condition|)
block|{
comment|/* On 68000, or for absolute value, switch to abs long */
comment|/* FIXME, we should check abs val, pick short or long */
if|if
condition|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|==
literal|0x61
condition|)
block|{
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|=
literal|0x4E
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
literal|0xB9
expr_stmt|;
comment|/* JSR with ABSL LONG offset */
name|subseg_change
argument_list|(
name|SEG_TEXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|FIX_NO_RELOC
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|==
literal|0x60
condition|)
block|{
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|=
literal|0x4E
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
literal|0xF9
expr_stmt|;
comment|/* JMP  with ABSL LONG offset */
name|subseg_change
argument_list|(
name|SEG_TEXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|FIX_NO_RELOC
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_warn
argument_list|(
literal|"Long branch offset to extern symbol not supported."
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flagseen
index|[
literal|'l'
index|]
condition|)
block|{
comment|/* Symbol is still undefined.  Make it simple */
name|fix_new
argument_list|(
name|fragP
argument_list|,
call|(
name|int
call|)
argument_list|(
name|fragP
operator|->
name|fr_fix
argument_list|)
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|FIX_NO_RELOC
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fix_new
argument_list|(
argument|fragP
argument_list|,
argument|(int) (fragP->fr_fix)
argument_list|,
literal|4
argument_list|,
argument|fragP->fr_symbol
argument_list|,
argument|(symbolS *)
literal|0
argument_list|,
argument|fragP->fr_offset
argument_list|,
literal|1
argument_list|,
ifdef|#
directive|ifdef
name|PIC
comment|/* With -k, make all external branches go via the jump table. */
argument|(picmode? RELOC_JMP_TBL: NO_RELOC)
argument_list|,
argument|NULL
else|#
directive|else
argument|NO_RELOC
endif|#
directive|endif
argument_list|)
empty_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
literal|0xff
expr_stmt|;
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
comment|/* case TAB(BRANCH,SZ_UNDEF) */
case|case
name|TAB
argument_list|(
name|FBRANCH
argument_list|,
name|SZ_UNDEF
argument_list|)
case|:
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment
operator|||
name|flagseen
index|[
literal|'l'
index|]
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|TAB
argument_list|(
name|FBRANCH
argument_list|,
name|SHORT
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|TAB
argument_list|(
name|FBRANCH
argument_list|,
name|LONG
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
block|}
comment|/* TAB(FBRANCH,SZ_UNDEF) */
case|case
name|TAB
argument_list|(
name|PCREL
argument_list|,
name|SZ_UNDEF
argument_list|)
case|:
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment
operator|||
name|flagseen
index|[
literal|'l'
index|]
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|TAB
argument_list|(
name|PCREL
argument_list|,
name|SHORT
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|TAB
argument_list|(
name|PCREL
argument_list|,
name|LONG
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
block|}
comment|/* TAB(PCREL,SZ_UNDEF) */
case|case
name|TAB
argument_list|(
name|BCC68000
argument_list|,
name|SZ_UNDEF
argument_list|)
case|:
block|{
if|if
condition|(
operator|(
name|fragP
operator|->
name|fr_symbol
operator|!=
name|NULL
operator|)
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|TAB
argument_list|(
name|BCC68000
argument_list|,
name|BYTE
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* only Bcc 68000 instructions can come here */
comment|/* change bcc into b!cc/jmp absl long */
name|fragP
operator|->
name|fr_opcode
index|[
literal|0
index|]
operator|^=
literal|0x01
expr_stmt|;
comment|/* invert bcc */
if|if
condition|(
name|flagseen
index|[
literal|'l'
index|]
condition|)
block|{
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
literal|0x04
expr_stmt|;
comment|/* branch offset = 6 */
comment|/* JF: these were fr_opcode[2,3] */
name|buffer_address
index|[
literal|0
index|]
operator|=
literal|0x4e
expr_stmt|;
comment|/* put in jmp long (0x4ef9) */
name|buffer_address
index|[
literal|1
index|]
operator|=
literal|0xf8
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
comment|/* account for jmp instruction */
name|subseg_change
argument_list|(
name|SEG_TEXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|FIX_NO_RELOC
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|fragP
operator|->
name|fr_opcode
index|[
literal|1
index|]
operator|=
literal|0x06
expr_stmt|;
comment|/* branch offset = 6 */
comment|/* JF: these were fr_opcode[2,3] */
name|buffer_address
index|[
literal|2
index|]
operator|=
literal|0x4e
expr_stmt|;
comment|/* put in jmp long (0x4ef9) */
name|buffer_address
index|[
literal|3
index|]
operator|=
literal|0xf9
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
comment|/* account for jmp instruction */
name|subseg_change
argument_list|(
name|SEG_TEXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|FIX_NO_RELOC
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
block|}
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* case TAB(BCC68000,SZ_UNDEF) */
case|case
name|TAB
argument_list|(
name|DBCC
argument_list|,
name|SZ_UNDEF
argument_list|)
case|:
block|{
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
operator|!=
name|NULL
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|TAB
argument_list|(
name|DBCC
argument_list|,
name|SHORT
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
comment|/* only DBcc 68000 instructions can come here */
comment|/* change dbcc into dbcc/jmp absl long */
comment|/* JF: these used to be fr_opcode[2-4], which is wrong. */
name|buffer_address
index|[
literal|0
index|]
operator|=
literal|0x00
expr_stmt|;
comment|/* branch offset = 4 */
name|buffer_address
index|[
literal|1
index|]
operator|=
literal|0x04
expr_stmt|;
name|buffer_address
index|[
literal|2
index|]
operator|=
literal|0x60
expr_stmt|;
comment|/* put in bra pc + ... */
if|if
condition|(
name|flagseen
index|[
literal|'l'
index|]
condition|)
block|{
comment|/* JF: these were fr_opcode[5-7] */
name|buffer_address
index|[
literal|3
index|]
operator|=
literal|0x04
expr_stmt|;
comment|/* plus 4 */
name|buffer_address
index|[
literal|4
index|]
operator|=
literal|0x4e
expr_stmt|;
comment|/* Put in Jump Word */
name|buffer_address
index|[
literal|5
index|]
operator|=
literal|0xf8
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|6
expr_stmt|;
comment|/* account for bra/jmp instruction */
name|subseg_change
argument_list|(
name|SEG_TEXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|2
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|FIX_NO_RELOC
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* JF: these were fr_opcode[5-7] */
name|buffer_address
index|[
literal|3
index|]
operator|=
literal|0x06
expr_stmt|;
comment|/* Plus 6 */
name|buffer_address
index|[
literal|4
index|]
operator|=
literal|0x4e
expr_stmt|;
comment|/* put in jmp long (0x4ef9) */
name|buffer_address
index|[
literal|5
index|]
operator|=
literal|0xf9
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|6
expr_stmt|;
comment|/* account for bra/jmp instruction */
name|subseg_change
argument_list|(
name|SEG_TEXT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|0
argument_list|,
name|FIX_NO_RELOC
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
block|}
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* case TAB(DBCC,SZ_UNDEF) */
case|case
name|TAB
argument_list|(
name|PCLEA
argument_list|,
name|SZ_UNDEF
argument_list|)
case|:
block|{
if|if
condition|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|)
operator|==
name|segment
operator|||
name|flagseen
index|[
literal|'l'
index|]
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|TAB
argument_list|(
name|PCLEA
argument_list|,
name|SHORT
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|TAB
argument_list|(
name|PCLEA
argument_list|,
name|LONG
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|+=
literal|6
expr_stmt|;
block|}
break|break;
block|}
comment|/* TAB(PCLEA,SZ_UNDEF) */
default|default:
break|break;
block|}
comment|/* switch on subtype looking for SZ_UNDEF's. */
comment|/* now that SZ_UNDEF are taken care of, check others */
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|TAB
argument_list|(
name|BCC68000
argument_list|,
name|BYTE
argument_list|)
case|:
case|case
name|TAB
argument_list|(
name|BRANCH
argument_list|,
name|BYTE
argument_list|)
case|:
comment|/* We can't do a short jump to the next instruction, 	   so we force word mode.  */
if|if
condition|(
name|fragP
operator|->
name|fr_symbol
operator|&&
name|S_GET_VALUE
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
literal|0
operator|&&
name|fragP
operator|->
name|fr_symbol
operator|->
name|sy_frag
operator|==
name|fragP
operator|->
name|fr_next
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|TAB
argument_list|(
name|TABTYPE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
argument_list|,
name|SHORT
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_var
operator|+=
literal|2
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
name|fragP
operator|->
name|fr_var
operator|+
name|fragP
operator|->
name|fr_fix
operator|-
name|old_fix
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
end_if

begin_comment
comment|/* the bit-field entries in the relocation_info struct plays hell    with the byte-order problems of cross-assembly.  So as a hack,    I added this mach. dependent ri twiddler.  Ugly, but it gets    you there. -KWK */
end_comment

begin_comment
comment|/* on m68k: first 4 bytes are normal unsigned long, next three bytes    are symbolnum, most sig. byte first.  Last byte is broken up with    bit 7 as pcrel, bits 6& 5 as length, bit 4 as pcrel, and the lower    nibble as nuthin. (on Sun 3 at least) */
end_comment

begin_comment
comment|/* Translate the internal relocation information into target-specific    format. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|comment
end_ifdef

begin_function
name|void
name|md_ri_to_chars
parameter_list|(
name|the_bytes
parameter_list|,
name|ri
parameter_list|)
name|char
modifier|*
name|the_bytes
decl_stmt|;
name|struct
name|reloc_info_generic
modifier|*
name|ri
decl_stmt|;
block|{
comment|/* this is easy */
name|md_number_to_chars
argument_list|(
name|the_bytes
argument_list|,
name|ri
operator|->
name|r_address
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* now the fun stuff */
name|the_bytes
index|[
literal|4
index|]
operator|=
operator|(
name|ri
operator|->
name|r_symbolnum
operator|>>
literal|16
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|the_bytes
index|[
literal|5
index|]
operator|=
operator|(
name|ri
operator|->
name|r_symbolnum
operator|>>
literal|8
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|the_bytes
index|[
literal|6
index|]
operator|=
name|ri
operator|->
name|r_symbolnum
operator|&
literal|0x0ff
expr_stmt|;
name|the_bytes
index|[
literal|7
index|]
operator|=
operator|(
operator|(
operator|(
name|ri
operator|->
name|r_pcrel
operator|<<
literal|7
operator|)
operator|&
literal|0x80
operator|)
operator||
operator|(
operator|(
name|ri
operator|->
name|r_length
operator|<<
literal|5
operator|)
operator|&
literal|0x60
operator|)
operator||
operator|(
operator|(
name|ri
operator|->
name|r_extern
operator|<<
literal|4
operator|)
operator|&
literal|0x10
operator|)
operator|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* comment */
end_comment

begin_function
name|void
name|tc_aout_fix_to_chars
parameter_list|(
name|where
parameter_list|,
name|fixP
parameter_list|,
name|segment_address_in_file
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|relax_addressT
name|segment_address_in_file
decl_stmt|;
block|{
comment|/* 	 * In: length of relocation (or of address) in chars: 1, 2 or 4. 	 * Out: GNU LD relocation length code: 0, 1, or 2. 	 */
specifier|static
name|unsigned
name|char
name|nbytes_r_length
index|[]
init|=
block|{
literal|42
block|,
literal|0
block|,
literal|1
block|,
literal|42
block|,
literal|2
block|}
decl_stmt|;
name|long
name|r_symbolnum
decl_stmt|;
name|int
name|r_flags
decl_stmt|;
name|know
argument_list|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|segment_address_in_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|r_symbolnum
operator|=
operator|(
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|?
name|S_GET_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
else|:
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_number
operator|)
expr_stmt|;
name|r_flags
operator|=
operator|(
name|fixP
operator|->
name|fx_pcrel
condition|?
literal|0x80
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|nbytes_r_length
index|[
name|fixP
operator|->
name|fx_size
index|]
operator|&
literal|3
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|?
literal|0x10
else|:
literal|0
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PIC
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|NO_RELOC
case|:
break|break;
case|case
name|RELOC_32
case|:
if|if
condition|(
name|picmode
operator|&&
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
name|r_symbolnum
operator|=
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_number
expr_stmt|;
name|r_flags
operator||=
literal|0x10
expr_stmt|;
comment|/* set extern bit */
block|}
break|break;
case|case
name|RELOC_GLOB_DAT
case|:
name|r_flags
operator||=
literal|8
expr_stmt|;
comment|/* set baserel bit */
name|r_symbolnum
operator|=
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_number
expr_stmt|;
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
name|r_flags
operator||=
literal|0x10
expr_stmt|;
break|break;
case|case
name|RELOC_JMP_TBL
case|:
name|r_flags
operator||=
literal|4
expr_stmt|;
comment|/* set jmptable bit */
break|break;
case|case
name|RELOC_RELATIVE
case|:
comment|/* should never happen */
name|r_flags
operator||=
literal|2
expr_stmt|;
comment|/* set relative bit */
break|break;
block|}
endif|#
directive|endif
comment|/* PIC */
name|where
index|[
literal|4
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|16
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|5
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|8
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|6
index|]
operator|=
name|r_symbolnum
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|7
index|]
operator|=
name|r_flags
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tc_aout_fix_to_chars() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_AOUT or OBJ_BOUT */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WORKING_DOT_WORD
end_ifndef

begin_decl_stmt
specifier|const
name|int
name|md_short_jump_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|md_long_jump_size
init|=
literal|6
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|long
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|long
name|offset
decl_stmt|;
name|offset
operator|=
name|to_addr
operator|-
operator|(
name|from_addr
operator|+
literal|2
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|long
operator|)
literal|0x6000
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
literal|2
argument_list|,
operator|(
name|long
operator|)
name|offset
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|long
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|long
name|offset
decl_stmt|;
if|if
condition|(
name|cpu_of_arch
argument_list|(
name|current_architecture
argument_list|)
operator|<
name|m68020
condition|)
block|{
name|offset
operator|=
name|to_addr
operator|-
name|S_GET_VALUE
argument_list|(
name|to_symbol
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|long
operator|)
literal|0x4EF9
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
literal|2
argument_list|,
operator|(
name|long
operator|)
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag
argument_list|,
operator|(
name|ptr
operator|+
literal|2
operator|)
operator|-
name|frag
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|to_symbol
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|FIX_NO_RELOC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|to_addr
operator|-
operator|(
name|from_addr
operator|+
literal|2
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|long
operator|)
literal|0x60ff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
literal|2
argument_list|,
operator|(
name|long
operator|)
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Different values of OK tell what its OK to return.  Things that aren't OK are an error (what a shock, no?)     0:  Everything is OK    10:  Absolute 1:8	only    20:  Absolute 0:7	only    30:  absolute 0:15	only    40:  Absolute 0:31	only    50:  absolute 0:127	only    55:  absolute -64:63    only    60:  absolute -128:127	only    70:  absolute 0:4095	only    80:  No bignums     */
end_comment

begin_function
specifier|static
name|int
name|get_num
parameter_list|(
name|exp
parameter_list|,
name|ok
parameter_list|)
name|struct
name|m68k_exp
modifier|*
name|exp
decl_stmt|;
name|int
name|ok
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|TEST2
name|long
name|l
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|exp
operator|->
name|e_beg
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|exp
operator|->
name|e_beg
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|e_beg
index|[
literal|1
index|]
operator|==
literal|'x'
condition|)
name|sscanf
argument_list|(
name|exp
operator|->
name|e_beg
operator|+
literal|2
argument_list|,
literal|"%x"
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
else|else
name|sscanf
argument_list|(
name|exp
operator|->
name|e_beg
operator|+
literal|1
argument_list|,
literal|"%O"
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
return|return
name|l
return|;
block|}
return|return
name|atol
argument_list|(
name|exp
operator|->
name|e_beg
argument_list|)
return|;
else|#
directive|else
name|char
modifier|*
name|save_in
decl_stmt|;
name|char
name|c_save
decl_stmt|;
if|if
condition|(
operator|!
name|exp
condition|)
block|{
comment|/* Can't do anything */
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|exp
operator|->
name|e_beg
operator|||
operator|!
name|exp
operator|->
name|e_end
condition|)
block|{
name|seg
argument_list|(
name|exp
argument_list|)
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|adds
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|subs
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|offs
argument_list|(
name|exp
argument_list|)
operator|=
operator|(
name|ok
operator|==
literal|10
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|as_warn
argument_list|(
literal|"Null expression defaults to %ld"
argument_list|,
name|offs
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|exp
operator|->
name|e_siz
operator|=
literal|0
expr_stmt|;
if|if
condition|(
comment|/* ok != 80&& */
name|exp
operator|->
name|e_end
index|[
operator|-
literal|1
index|]
operator|==
literal|':'
operator|&&
operator|(
name|exp
operator|->
name|e_end
operator|-
name|exp
operator|->
name|e_beg
operator|)
operator|>=
literal|2
condition|)
block|{
switch|switch
condition|(
name|exp
operator|->
name|e_end
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|exp
operator|->
name|e_siz
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
case|case
literal|'W'
case|:
name|exp
operator|->
name|e_siz
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
name|exp
operator|->
name|e_siz
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"Unknown size for expression \"%c\""
argument_list|,
name|exp
operator|->
name|e_end
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|exp
operator|->
name|e_end
operator|-=
literal|2
expr_stmt|;
block|}
name|c_save
operator|=
name|exp
operator|->
name|e_end
index|[
literal|1
index|]
expr_stmt|;
name|exp
operator|->
name|e_end
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|save_in
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|exp
operator|->
name|e_beg
expr_stmt|;
switch|switch
condition|(
name|expression
argument_list|(
operator|&
operator|(
name|exp
operator|->
name|e_exp
operator|)
argument_list|)
condition|)
block|{
case|case
name|SEG_PASS1
case|:
name|seg
argument_list|(
name|exp
argument_list|)
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|adds
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|subs
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|offs
argument_list|(
name|exp
argument_list|)
operator|=
operator|(
name|ok
operator|==
literal|10
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|as_warn
argument_list|(
literal|"Unknown expression: '%s' defaulting to %d"
argument_list|,
name|exp
operator|->
name|e_beg
argument_list|,
name|offs
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEG_ABSENT
case|:
comment|/* Do the same thing the VAX asm does */
name|seg
argument_list|(
name|exp
argument_list|)
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|adds
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|subs
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|offs
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ok
operator|==
literal|10
condition|)
block|{
name|as_warn
argument_list|(
literal|"expression out of range: defaulting to 1"
argument_list|)
expr_stmt|;
name|offs
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|SEG_ABSOLUTE
case|:
switch|switch
condition|(
name|ok
condition|)
block|{
case|case
literal|10
case|:
if|if
condition|(
name|offs
argument_list|(
name|exp
argument_list|)
operator|<
literal|1
operator|||
name|offs
argument_list|(
name|exp
argument_list|)
operator|>
literal|8
condition|)
block|{
name|as_warn
argument_list|(
literal|"expression out of range: defaulting to 1"
argument_list|)
expr_stmt|;
name|offs
argument_list|(
name|exp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|20
case|:
if|if
condition|(
name|offs
argument_list|(
name|exp
argument_list|)
operator|<
literal|0
operator|||
name|offs
argument_list|(
name|exp
argument_list|)
operator|>
literal|7
condition|)
goto|goto
name|outrange
goto|;
break|break;
case|case
literal|30
case|:
if|if
condition|(
name|offs
argument_list|(
name|exp
argument_list|)
operator|<
literal|0
operator|||
name|offs
argument_list|(
name|exp
argument_list|)
operator|>
literal|15
condition|)
goto|goto
name|outrange
goto|;
break|break;
case|case
literal|40
case|:
if|if
condition|(
name|offs
argument_list|(
name|exp
argument_list|)
operator|<
literal|0
operator|||
name|offs
argument_list|(
name|exp
argument_list|)
operator|>
literal|32
condition|)
goto|goto
name|outrange
goto|;
break|break;
case|case
literal|50
case|:
if|if
condition|(
name|offs
argument_list|(
name|exp
argument_list|)
operator|<
literal|0
operator|||
name|offs
argument_list|(
name|exp
argument_list|)
operator|>
literal|127
condition|)
goto|goto
name|outrange
goto|;
break|break;
case|case
literal|55
case|:
if|if
condition|(
name|offs
argument_list|(
name|exp
argument_list|)
operator|<
operator|-
literal|64
operator|||
name|offs
argument_list|(
name|exp
argument_list|)
operator|>
literal|63
condition|)
goto|goto
name|outrange
goto|;
break|break;
case|case
literal|60
case|:
if|if
condition|(
name|offs
argument_list|(
name|exp
argument_list|)
operator|<
operator|-
literal|128
operator|||
name|offs
argument_list|(
name|exp
argument_list|)
operator|>
literal|127
condition|)
goto|goto
name|outrange
goto|;
break|break;
case|case
literal|70
case|:
if|if
condition|(
name|offs
argument_list|(
name|exp
argument_list|)
operator|<
literal|0
operator|||
name|offs
argument_list|(
name|exp
argument_list|)
operator|>
literal|4095
condition|)
block|{
name|outrange
label|:
name|as_warn
argument_list|(
literal|"expression out of range: defaulting to 0"
argument_list|)
expr_stmt|;
name|offs
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|SEG_TEXT
case|:
case|case
name|SEG_DATA
case|:
case|case
name|SEG_BSS
case|:
case|case
name|SEG_UNKNOWN
case|:
case|case
name|SEG_DIFFERENCE
case|:
if|if
condition|(
name|ok
operator|>=
literal|10
operator|&&
name|ok
operator|<=
literal|70
condition|)
block|{
name|seg
argument_list|(
name|exp
argument_list|)
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|adds
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|subs
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|offs
argument_list|(
name|exp
argument_list|)
operator|=
operator|(
name|ok
operator|==
literal|10
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|as_warn
argument_list|(
literal|"Can't deal with expression \"%s\": defaulting to %ld"
argument_list|,
name|exp
operator|->
name|e_beg
argument_list|,
name|offs
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SEG_BIG
case|:
if|if
condition|(
name|ok
operator|==
literal|80
operator|&&
name|offs
argument_list|(
name|exp
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* HACK! Turn it into a long */
name|LITTLENUM_TYPE
name|words
index|[
literal|6
index|]
decl_stmt|;
name|gen_to_words
argument_list|(
name|words
argument_list|,
literal|2
argument_list|,
literal|8L
argument_list|)
expr_stmt|;
comment|/* These numbers are magic! */
name|seg
argument_list|(
name|exp
argument_list|)
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|adds
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|subs
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|offs
argument_list|(
name|exp
argument_list|)
operator|=
name|words
index|[
literal|1
index|]
operator||
operator|(
name|words
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ok
operator|!=
literal|0
condition|)
block|{
name|seg
argument_list|(
name|exp
argument_list|)
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|adds
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|subs
argument_list|(
name|exp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|offs
argument_list|(
name|exp
argument_list|)
operator|=
operator|(
name|ok
operator|==
literal|10
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|as_warn
argument_list|(
literal|"Can't deal with expression \"%s\": defaulting to %ld"
argument_list|,
name|exp
operator|->
name|e_beg
argument_list|,
name|offs
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"failed sanity check."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|input_line_pointer
operator|!=
name|exp
operator|->
name|e_end
operator|+
literal|1
condition|)
name|as_bad
argument_list|(
literal|"Ignoring junk after expression"
argument_list|)
expr_stmt|;
name|exp
operator|->
name|e_end
index|[
literal|1
index|]
operator|=
name|c_save
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|e_siz
condition|)
block|{
switch|switch
condition|(
name|exp
operator|->
name|e_siz
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|isbyte
argument_list|(
name|offs
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|as_warn
argument_list|(
literal|"expression doesn't fit in BYTE"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
operator|!
name|isword
argument_list|(
name|offs
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
name|as_warn
argument_list|(
literal|"expression doesn't fit in WORD"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|offs
argument_list|(
name|exp
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* get_num() */
end_comment

begin_comment
comment|/* These are the back-ends for the various machine dependent pseudo-ops.  */
end_comment

begin_function_decl
name|void
name|demand_empty_rest_of_line
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Hate those extra verbose names */
end_comment

begin_function
specifier|static
name|void
name|s_data1
parameter_list|()
block|{
name|subseg_new
argument_list|(
name|SEG_DATA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_data1() */
end_comment

begin_function
specifier|static
name|void
name|s_data2
parameter_list|()
block|{
name|subseg_new
argument_list|(
name|SEG_DATA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_data2() */
end_comment

begin_function
specifier|static
name|void
name|s_bss
parameter_list|()
block|{
comment|/* We don't support putting frags in the BSS segment, but we 	   can put them into initialized data for now... */
name|subseg_new
argument_list|(
name|SEG_DATA
argument_list|,
literal|255
argument_list|)
expr_stmt|;
comment|/* FIXME-SOON */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_bss() */
end_comment

begin_function
specifier|static
name|void
name|s_even
parameter_list|()
block|{
specifier|register
name|int
name|temp
decl_stmt|;
specifier|register
name|long
name|temp_fill
decl_stmt|;
name|temp
operator|=
literal|1
expr_stmt|;
comment|/* JF should be 2? */
name|temp_fill
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|need_pass_2
condition|)
comment|/* Never make frag if expect extra pass. */
name|frag_align
argument_list|(
name|temp
argument_list|,
operator|(
name|int
operator|)
name|temp_fill
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_even() */
end_comment

begin_function
specifier|static
name|void
name|s_proc
parameter_list|()
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* s_proc() */
end_comment

begin_comment
comment|/* s_space is defined in read.c .skip is simply an alias to it. */
end_comment

begin_comment
comment|/*  * md_parse_option  *	Invocation line includes a switch not recognized by the base assembler.  *	See if it's a processor-specific option.  These are:  *  *	-[A]m[c]68000, -[A]m[c]68008, -[A]m[c]68010, -[A]m[c]68020, -[A]m[c]68030, -[A]m[c]68040  *	-[A]m[c]68881, -[A]m[c]68882, -[A]m[c]68851  *		Select the architecture.  Instructions or features not  *		supported by the selected architecture cause fatal  *		errors.  More than one may be specified.  The default is  *		-m68020 -m68851 -m68881.  Note that -m68008 is a synonym  *		for -m68000, and -m68882 is a synonym for -m68881.  *  * MAYBE_FLOAT_TOO is defined below so that specifying a processor type  * (e.g. m68020) also requests that float instructions be included.  This  * is the default setup, mostly to avoid hassling users.  A better  * rearrangement of this structure would be to add an option to DENY  * floating point opcodes, for people who want to really know there's none  * of that funny floaty stuff going on.  FIXME-later.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAYBE_FLOAT_TOO
end_ifndef

begin_define
define|#
directive|define
name|MAYBE_FLOAT_TOO
value|m68881
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|md_parse_option
parameter_list|(
name|argP
parameter_list|,
name|cntP
parameter_list|,
name|vecP
parameter_list|)
name|char
modifier|*
modifier|*
name|argP
decl_stmt|;
name|int
modifier|*
name|cntP
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|vecP
decl_stmt|;
block|{
switch|switch
condition|(
operator|*
operator|*
name|argP
condition|)
block|{
case|case
literal|'l'
case|:
comment|/* -l means keep external to 2 bit offset 			   rather than 16 bit one */
break|break;
case|case
literal|'S'
case|:
comment|/* -S means that jbsr's always turn into jsr's.  */
break|break;
case|case
literal|'A'
case|:
operator|(
operator|*
name|argP
operator|)
operator|++
expr_stmt|;
comment|/* intentional fall-through */
case|case
literal|'m'
case|:
operator|(
operator|*
name|argP
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|argP
operator|==
literal|'c'
condition|)
block|{
operator|(
operator|*
name|argP
operator|)
operator|++
expr_stmt|;
block|}
comment|/* allow an optional "c" */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argP
argument_list|,
literal|"68000"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
operator|*
name|argP
argument_list|,
literal|"68008"
argument_list|)
condition|)
block|{
name|current_architecture
operator||=
name|m68000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argP
argument_list|,
literal|"68010"
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TE_SUN
name|omagic
operator|=
literal|1
operator|<<
literal|16
operator||
name|OMAGIC
expr_stmt|;
endif|#
directive|endif
name|current_architecture
operator||=
name|m68010
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argP
argument_list|,
literal|"68020"
argument_list|)
condition|)
block|{
name|current_architecture
operator||=
name|m68020
operator||
name|MAYBE_FLOAT_TOO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argP
argument_list|,
literal|"68030"
argument_list|)
condition|)
block|{
name|current_architecture
operator||=
name|m68030
operator||
name|MAYBE_FLOAT_TOO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argP
argument_list|,
literal|"68040"
argument_list|)
condition|)
block|{
name|current_architecture
operator||=
name|m68040
operator||
name|MAYBE_FLOAT_TOO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argP
argument_list|,
literal|"68060"
argument_list|)
condition|)
block|{
name|current_architecture
operator||=
name|m68040
operator||
name|MAYBE_FLOAT_TOO
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_68881
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argP
argument_list|,
literal|"68881"
argument_list|)
condition|)
block|{
name|current_architecture
operator||=
name|m68881
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argP
argument_list|,
literal|"68882"
argument_list|)
condition|)
block|{
name|current_architecture
operator||=
name|m68882
expr_stmt|;
endif|#
directive|endif
comment|/* NO_68881 */
ifndef|#
directive|ifndef
name|NO_68851
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argP
argument_list|,
literal|"68851"
argument_list|)
condition|)
block|{
name|current_architecture
operator||=
name|m68851
expr_stmt|;
endif|#
directive|endif
comment|/* NO_68851 */
block|}
else|else
block|{
name|as_warn
argument_list|(
literal|"Unknown architecture, \"%s\". option ignored"
argument_list|,
operator|*
name|argP
argument_list|)
expr_stmt|;
block|}
comment|/* switch on architecture */
while|while
condition|(
operator|*
operator|*
name|argP
condition|)
operator|(
operator|*
name|argP
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argP
argument_list|,
literal|"pic"
argument_list|)
condition|)
block|{
operator|(
operator|*
name|argP
operator|)
operator|+=
literal|3
expr_stmt|;
break|break;
comment|/* -pic, Position Independent Code */
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* pic or not */
ifdef|#
directive|ifdef
name|PIC
case|case
literal|'k'
case|:
case|case
literal|'K'
case|:
comment|/* Predefine GOT symbol */
name|GOT_symbol
operator|=
name|symbol_find_or_make
argument_list|(
literal|"__GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* PIC */
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST2
end_ifdef

begin_comment
comment|/* TEST2:  Test md_assemble() */
end_comment

begin_comment
comment|/* Warning, this routine probably doesn't work anymore */
end_comment

begin_function
name|main
parameter_list|()
block|{
name|struct
name|m68k_it
name|the_ins
decl_stmt|;
name|char
name|buf
index|[
literal|120
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|m68k_ip_begin
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|gets
argument_list|(
name|buf
argument_list|)
operator|||
operator|!
operator|*
name|buf
condition|)
break|break;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'|'
operator|||
name|buf
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
continue|continue;
for|for
control|(
name|cp
operator|=
name|buf
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\t'
condition|)
operator|*
name|cp
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|is_label
argument_list|(
name|buf
argument_list|)
condition|)
continue|continue;
name|memset
argument_list|(
operator|&
name|the_ins
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|the_ins
argument_list|)
argument_list|)
expr_stmt|;
name|m68k_ip
argument_list|(
operator|&
name|the_ins
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_ins
operator|.
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"Error %s in %s\n"
argument_list|,
name|the_ins
operator|.
name|error
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Opcode(%d.%s): "
argument_list|,
name|the_ins
operator|.
name|numo
argument_list|,
name|the_ins
operator|.
name|args
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|the_ins
operator|.
name|numo
condition|;
name|n
operator|++
control|)
name|printf
argument_list|(
literal|" 0x%x"
argument_list|,
name|the_ins
operator|.
name|opcode
index|[
name|n
index|]
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|print_the_insn
argument_list|(
operator|&
name|the_ins
operator|.
name|opcode
index|[
literal|0
index|]
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|strlen
argument_list|(
name|the_ins
operator|.
name|args
argument_list|)
operator|/
literal|2
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"op%d Error %s in %s\n"
argument_list|,
name|n
argument_list|,
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|error
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|printf
argument_list|(
literal|"mode %d, reg %d, "
argument_list|,
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|mode
argument_list|,
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|b_const
condition|)
name|printf
argument_list|(
literal|"Constant: '%.*s', "
argument_list|,
literal|1
operator|+
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|e_const
operator|-
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|b_const
argument_list|,
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|b_const
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ireg %d, isiz %d, imul %d, "
argument_list|,
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|ireg
argument_list|,
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|isiz
argument_list|,
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|imul
argument_list|)
expr_stmt|;
if|if
condition|(
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|b_iadd
condition|)
name|printf
argument_list|(
literal|"Iadd: '%.*s',"
argument_list|,
literal|1
operator|+
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|e_iadd
operator|-
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|b_iadd
argument_list|,
name|the_ins
operator|.
name|operands
index|[
name|n
index|]
operator|.
name|b_iadd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
name|m68k_ip_end
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_macro
name|is_label
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|str
operator|==
literal|' '
condition|)
name|str
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|str
operator|&&
operator|*
name|str
operator|!=
literal|' '
condition|)
name|str
operator|++
expr_stmt|;
if|if
condition|(
name|str
index|[
operator|-
literal|1
index|]
operator|==
literal|':'
operator|||
name|str
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Possible states for relaxation:     0 0	branch offset	byte	(bra, etc)    0 1			word    0 2			long     1 0	indexed offsets	byte	a0@(32,d4:w:1) etc    1 1			word    1 2			long     2 0	two-offset index word-word a0@(32,d4)@(45) etc    2 1			word-long    2 2			long-word    2 3			long-long     */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DONTDEF
end_ifdef

begin_macro
name|abort
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"ABORT!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|print_frags
argument_list|()
end_macro

begin_block
block|{
name|fragS
modifier|*
name|fragP
decl_stmt|;
specifier|extern
name|fragS
modifier|*
name|text_frag_root
decl_stmt|;
for|for
control|(
name|fragP
operator|=
name|text_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
name|printf
argument_list|(
literal|"addr %lu  next 0x%x  fix %ld  var %ld  symbol 0x%x  offset %ld\n"
argument_list|,
name|fragP
operator|->
name|fr_address
argument_list|,
name|fragP
operator|->
name|fr_next
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
name|fragP
operator|->
name|fr_var
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"opcode 0x%x  type %d  subtype %d\n\n"
argument_list|,
name|fragP
operator|->
name|fr_opcode
argument_list|,
name|fragP
operator|->
name|fr_type
argument_list|,
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We have no need to default values of symbols.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Parse an operand that is machine-specific.    We just return without modifying the expression if we have nothing    to do.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|long
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
return|return
name|size
return|;
comment|/* Byte alignment is fine */
block|}
end_function

begin_comment
comment|/* Exactly what point is a PC-relative offset relative TO?    On the 68k, they're relative to the address of the offset. */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
return|return
operator|(
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * comment-column: 0  * fill-column: 131  * End:  */
end_comment

begin_comment
comment|/* end of tc-m68k.c */
end_comment

end_unit

