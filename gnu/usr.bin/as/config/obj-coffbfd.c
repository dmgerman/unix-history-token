begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* coff object file format with bfd    Copyright (C) 1989, 1990, 1991, 1992 Free Software Foundation, Inc.        This file is part of GAS.        GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.        GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.        You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*      How does this releate to the rest of GAS ?      Well, all the other files in gas are more or less a black box. It   takes care of opening files, parsing command lines, stripping blanks   etc etc. This module gets a chance to register what it wants to do by   saying that it is interested in various pseduo ops. The other big   change is write_object_file. This runs through all the data   structures that gas builds, and outputs the file in the format of our   choice.      Hacked for BFDness by steve chamberlain      This object module now supports the Hitachi H8/300 and the AMD 29k      sac@cygnus.com   */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"frags.h"
end_include

begin_include
include|#
directive|include
file|"../bfd/libbfd.h"
end_include

begin_comment
comment|/* This vector is used to turn an internal segment into a section #    suitable for insertion into a coff symbol table     */
end_comment

begin_decl_stmt
specifier|const
name|short
name|seg_N_TYPE
index|[]
init|=
block|{
comment|/* in: segT   out: N_TYPE bits */
name|C_ABS_SECTION
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
name|C_UNDEF_SECTION
block|,
comment|/* SEG_UNKNOWN */
name|C_UNDEF_SECTION
block|,
comment|/* SEG_ABSENT */
name|C_UNDEF_SECTION
block|,
comment|/* SEG_PASS1 */
name|C_UNDEF_SECTION
block|,
comment|/* SEG_GOOF */
name|C_UNDEF_SECTION
block|,
comment|/* SEG_BIG */
name|C_UNDEF_SECTION
block|,
comment|/* SEG_DIFFERENCE */
name|C_DEBUG_SECTION
block|,
comment|/* SEG_DEBUG */
name|C_NTV_SECTION
block|,
comment|/* SEG_NTV */
name|C_PTV_SECTION
block|,
comment|/* SEG_PTV */
name|C_REGISTER_SECTION
block|,
comment|/* SEG_REGISTER */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|function_lineoff
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offset in line#s where the last function 				   started (the odd entry for line #0) */
end_comment

begin_decl_stmt
name|int
name|our_lineno_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* we use this to build pointers from .bf's 				   into the linetable.  It should match 				   exactly the values that are later 				   assigned in text_lineno_number by 				   write.c. */
end_comment

begin_decl_stmt
name|int
name|text_lineno_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add 4 to the real value to get the index and compensate the    negatives. This vector is used by S_GET_SEGMENT to turn a coff    section number into a segment number     */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|previous_file_symbol
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|c_symbol_merge
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|line_base
decl_stmt|;
end_decl_stmt

begin_function_decl
name|symbolS
modifier|*
name|c_section_symbol
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|bfd
modifier|*
name|abfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|EXFUN
argument_list|(
name|bfd_as_write_hook
argument_list|,
operator|(
expr|struct
name|internal_filehdr
operator|*
operator|,
name|bfd
operator|*
name|abfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EXFUN
argument_list|(
name|fixup_segment
argument_list|,
operator|(
name|fixS
operator|*
name|fixP
operator|,
name|segT
name|this_segment_type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EXFUN
argument_list|(
name|fill_section
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|,
expr|struct
name|internal_filehdr
operator|*
name|f
operator|,
name|unsigned
name|long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|EXFUN
argument_list|(
name|s_get_name
argument_list|,
operator|(
name|symbolS
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|EXFUN
argument_list|(
name|tag_find_or_make
argument_list|,
operator|(
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|EXFUN
argument_list|(
name|tag_find
argument_list|,
operator|(
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|EXFUN
argument_list|(
name|c_line_new
argument_list|,
operator|(
name|symbolS
operator|*
name|symbol
operator|,
name|long
name|paddr
operator|,
name|unsigned
name|short
name|line_number
operator|,
name|fragS
operator|*
name|frag
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EXFUN
argument_list|(
name|w_symbols
argument_list|,
operator|(
name|bfd
operator|*
name|abfd
operator|,
name|char
operator|*
name|where
operator|,
name|symbolS
operator|*
name|symbol_rootP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EXFUN
argument_list|(
name|obj_coff_def
argument_list|,
operator|(
name|int
name|what
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EXFUN
argument_list|(
name|obj_coff_lcomm
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EXFUN
argument_list|(
name|obj_coff_dim
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EXFUN
argument_list|(
name|obj_coff_text
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EXFUN
argument_list|(
name|obj_coff_data
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EXFUN
argument_list|(
name|obj_coff_endef
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EXFUN
argument_list|(
name|obj_coff_line
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EXFUN
argument_list|(
name|obj_coff_ln
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EXFUN
argument_list|(
name|obj_coff_scl
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EXFUN
argument_list|(
name|obj_coff_size
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EXFUN
argument_list|(
name|obj_coff_tag
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EXFUN
argument_list|(
name|obj_coff_type
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EXFUN
argument_list|(
name|obj_coff_val
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EXFUN
argument_list|(
name|obj_coff_section
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EXFUN
argument_list|(
name|tag_init
argument_list|,
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|EXFUN
argument_list|(
name|tag_insert
argument_list|,
operator|(
name|char
operator|*
name|name
operator|,
name|symbolS
operator|*
name|symbolP
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|tag_hash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|def_symbol_in_progress
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|obj_pseudo_table
index|[]
init|=
block|{
block|{
literal|"def"
block|,
name|obj_coff_def
block|,
literal|0
block|}
block|,
block|{
literal|"dim"
block|,
name|obj_coff_dim
block|,
literal|0
block|}
block|,
block|{
literal|"endef"
block|,
name|obj_coff_endef
block|,
literal|0
block|}
block|,
block|{
literal|"line"
block|,
name|obj_coff_line
block|,
literal|0
block|}
block|,
block|{
literal|"ln"
block|,
name|obj_coff_ln
block|,
literal|0
block|}
block|,
block|{
literal|"scl"
block|,
name|obj_coff_scl
block|,
literal|0
block|}
block|,
block|{
literal|"size"
block|,
name|obj_coff_size
block|,
literal|0
block|}
block|,
block|{
literal|"tag"
block|,
name|obj_coff_tag
block|,
literal|0
block|}
block|,
block|{
literal|"type"
block|,
name|obj_coff_type
block|,
literal|0
block|}
block|,
block|{
literal|"val"
block|,
name|obj_coff_val
block|,
literal|0
block|}
block|,
block|{
literal|"section"
block|,
name|obj_coff_section
block|,
literal|0
block|}
block|,
block|{
literal|"text"
block|,
name|obj_coff_text
block|,
literal|0
block|}
block|,
block|{
literal|"data"
block|,
name|obj_coff_data
block|,
literal|0
block|}
block|,
comment|/* we don't yet handle this. */
block|{
literal|"ident"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"ABORT"
block|,
name|s_abort
block|,
literal|0
block|}
block|,
block|{
literal|"lcomm"
block|,
name|obj_coff_lcomm
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|}
comment|/* end sentinel */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* obj_pseudo_table */
end_comment

begin_comment
comment|/* Section stuff         We allow more than just the standard 3 sections, infact, we allow    10 sections, (though the usual three have to be there).        This structure performs the mappings for us:        */
end_comment

begin_comment
comment|/* OBS stuff     static struct internal_scnhdr bss_section_header;    struct internal_scnhdr data_section_header;    struct internal_scnhdr text_section_header;        const segT N_TYPE_seg[32] =    {        };        */
end_comment

begin_define
define|#
directive|define
name|N_SEG
value|32
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|segT
name|seg_t
decl_stmt|;
name|int
name|i
decl_stmt|;
block|}
name|seg_info_type
typedef|;
end_typedef

begin_decl_stmt
name|seg_info_type
name|seg_info_off_by_4
index|[
name|N_SEG
index|]
init|=
block|{
block|{
name|SEG_PTV
block|,  }
block|,
block|{
name|SEG_NTV
block|,  }
block|,
block|{
name|SEG_DEBUG
block|, }
block|,
block|{
name|SEG_ABSOLUTE
block|,  }
block|,
block|{
name|SEG_UNKNOWN
block|,	 }
block|,
block|{
name|SEG_E0
block|}
block|,
block|{
name|SEG_E1
block|}
block|,
block|{
name|SEG_E2
block|}
block|,
block|{
name|SEG_E3
block|}
block|,
block|{
name|SEG_E4
block|}
block|,
block|{
name|SEG_E5
block|}
block|,
block|{
name|SEG_E6
block|}
block|,
block|{
name|SEG_E7
block|}
block|,
block|{
name|SEG_E8
block|}
block|,
block|{
name|SEG_E9
block|}
block|,
block|{
literal|15
block|}
block|,
block|{
literal|16
block|}
block|,
block|{
literal|17
block|}
block|,
block|{
literal|18
block|}
block|,
block|{
literal|19
block|}
block|,
block|{
literal|20
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
block|{
name|SEG_REGISTER
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SEG_INFO_FROM_SECTION_NUMBER
parameter_list|(
name|x
parameter_list|)
value|(seg_info_off_by_4[(x)+4])
end_define

begin_define
define|#
directive|define
name|SEG_INFO_FROM_SEG_NUMBER
parameter_list|(
name|x
parameter_list|)
value|(seg_info_off_by_4[(x)])
end_define

begin_decl_stmt
name|relax_addressT
name|DEFUN
argument_list|(
name|relax_align
argument_list|,
operator|(
name|address
operator|,
name|alignment
operator|)
argument_list|,
specifier|register
name|relax_addressT
name|address
name|AND
specifier|register
name|long
name|alignment
argument_list|)
block|{
name|relax_addressT
name|mask
decl_stmt|;
name|relax_addressT
name|new_address
decl_stmt|;
name|mask
operator|=
operator|~
operator|(
operator|(
operator|~
literal|0
operator|)
operator|<<
name|alignment
operator|)
expr_stmt|;
name|new_address
operator|=
operator|(
name|address
operator|+
name|mask
operator|)
operator|&
operator|(
operator|~
name|mask
operator|)
expr_stmt|;
return|return
operator|(
name|new_address
operator|-
name|address
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* relax_align() */
end_comment

begin_decl_stmt
name|segT
name|DEFUN
argument_list|(
name|s_get_segment
argument_list|,
operator|(
name|x
operator|)
argument_list|,
name|symbolS
operator|*
name|x
argument_list|)
block|{
return|return
name|SEG_INFO_FROM_SECTION_NUMBER
argument_list|(
name|x
operator|->
name|sy_symbol
operator|.
name|ost_entry
operator|.
name|n_scnum
argument_list|)
operator|.
name|seg_t
return|;
block|}
end_decl_stmt

begin_comment
comment|/* calculate the size of the frag chain and fill in the section header    to contain all of it, also fill in the addr of the sections */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|DEFUN
argument_list|(
name|size_section
argument_list|,
operator|(
name|abfd
operator|,
name|idx
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|unsigned
name|int
name|idx
argument_list|)
block|{
name|unsigned
name|int
name|size
init|=
literal|0
decl_stmt|;
name|fragS
modifier|*
name|frag
init|=
name|segment_info
index|[
name|idx
index|]
operator|.
name|frchainP
operator|->
name|frch_root
decl_stmt|;
while|while
condition|(
name|frag
condition|)
block|{
if|if
condition|(
name|frag
operator|->
name|fr_address
operator|!=
name|size
condition|)
block|{
name|printf
argument_list|(
literal|"Out of step\n"
argument_list|)
expr_stmt|;
name|size
operator|=
name|frag
operator|->
name|fr_address
expr_stmt|;
block|}
name|size
operator|+=
name|frag
operator|->
name|fr_fix
expr_stmt|;
switch|switch
condition|(
name|frag
operator|->
name|fr_type
condition|)
block|{
case|case
name|rs_fill
case|:
case|case
name|rs_org
case|:
name|size
operator|+=
name|frag
operator|->
name|fr_offset
operator|*
name|frag
operator|->
name|fr_var
expr_stmt|;
break|break;
case|case
name|rs_align
case|:
name|size
operator|+=
name|relax_align
argument_list|(
name|size
argument_list|,
name|frag
operator|->
name|fr_offset
argument_list|)
expr_stmt|;
block|}
name|frag
operator|=
name|frag
operator|->
name|fr_next
expr_stmt|;
block|}
name|segment_info
index|[
name|idx
index|]
operator|.
name|scnhdr
operator|.
name|s_size
operator|=
name|size
expr_stmt|;
return|return
name|size
return|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|DEFUN
argument_list|(
name|count_entries_in_chain
argument_list|,
operator|(
name|idx
operator|)
argument_list|,
name|unsigned
name|int
name|idx
argument_list|)
block|{
name|unsigned
name|int
name|nrelocs
decl_stmt|;
name|fixS
modifier|*
name|fixup_ptr
decl_stmt|;
comment|/* Count the relocations */
name|fixup_ptr
operator|=
name|segment_info
index|[
name|idx
index|]
operator|.
name|fix_root
expr_stmt|;
name|nrelocs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fixup_ptr
operator|!=
operator|(
name|fixS
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|TC_COUNT_RELOC
argument_list|(
name|fixup_ptr
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TC_A29K
if|if
condition|(
name|fixup_ptr
operator|->
name|fx_r_type
operator|==
name|RELOC_CONSTH
condition|)
name|nrelocs
operator|+=
literal|2
expr_stmt|;
else|else
name|nrelocs
operator|++
expr_stmt|;
else|#
directive|else
name|nrelocs
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
name|fixup_ptr
operator|=
name|fixup_ptr
operator|->
name|fx_next
expr_stmt|;
block|}
return|return
name|nrelocs
return|;
block|}
end_decl_stmt

begin_comment
comment|/* output all the relocations for a section */
end_comment

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|do_relocs_for
argument_list|,
operator|(
name|abfd
operator|,
name|file_cursor
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|unsigned
name|long
operator|*
name|file_cursor
argument_list|)
block|{
name|unsigned
name|int
name|nrelocs
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
name|SEG_E0
init|;
name|idx
operator|<
name|SEG_E9
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|segment_info
index|[
name|idx
index|]
operator|.
name|scnhdr
operator|.
name|s_name
index|[
literal|0
index|]
condition|)
block|{
name|struct
name|external_reloc
modifier|*
name|ext_ptr
decl_stmt|;
name|struct
name|external_reloc
modifier|*
name|external_reloc_vec
decl_stmt|;
name|unsigned
name|int
name|external_reloc_size
decl_stmt|;
name|unsigned
name|int
name|count
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|base
init|=
name|segment_info
index|[
name|idx
index|]
operator|.
name|scnhdr
operator|.
name|s_paddr
decl_stmt|;
name|fixS
modifier|*
name|fix_ptr
init|=
name|segment_info
index|[
name|idx
index|]
operator|.
name|fix_root
decl_stmt|;
name|nrelocs
operator|=
name|count_entries_in_chain
argument_list|(
name|idx
argument_list|)
expr_stmt|;
name|external_reloc_size
operator|=
name|nrelocs
operator|*
name|RELSZ
expr_stmt|;
name|external_reloc_vec
operator|=
operator|(
expr|struct
name|external_reloc
operator|*
operator|)
name|malloc
argument_list|(
name|external_reloc_size
argument_list|)
expr_stmt|;
name|ext_ptr
operator|=
name|external_reloc_vec
expr_stmt|;
comment|/* Fill in the internal coff style reloc struct from the 				   internal fix list */
while|while
condition|(
name|fix_ptr
condition|)
block|{
name|symbolS
modifier|*
name|symbol_ptr
decl_stmt|;
name|struct
name|internal_reloc
name|intr
decl_stmt|;
comment|/* Only output some of the relocations */
if|if
condition|(
name|TC_COUNT_RELOC
argument_list|(
name|fix_ptr
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TC_RELOC_MANGLE
name|TC_RELOC_MANGLE
argument_list|(
name|fix_ptr
argument_list|,
operator|&
name|intr
argument_list|,
name|base
argument_list|)
expr_stmt|;
else|#
directive|else
name|symbolS
modifier|*
name|dot
decl_stmt|;
name|symbol_ptr
operator|=
name|fix_ptr
operator|->
name|fx_addsy
expr_stmt|;
name|intr
operator|.
name|r_type
operator|=
name|TC_COFF_FIX2RTYPE
argument_list|(
name|fix_ptr
argument_list|)
expr_stmt|;
name|intr
operator|.
name|r_vaddr
operator|=
name|base
operator|+
name|fix_ptr
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fix_ptr
operator|->
name|fx_where
expr_stmt|;
name|intr
operator|.
name|r_offset
operator|=
name|fix_ptr
operator|->
name|fx_offset
expr_stmt|;
name|intr
operator|.
name|r_offset
operator|=
literal|0
expr_stmt|;
comment|/* Turn the segment of the symbol into an offset 							 */
if|if
condition|(
name|symbol_ptr
condition|)
block|{
name|dot
operator|=
name|segment_info
index|[
name|S_GET_SEGMENT
argument_list|(
name|symbol_ptr
argument_list|)
index|]
operator|.
name|dot
expr_stmt|;
if|if
condition|(
name|dot
condition|)
block|{
name|intr
operator|.
name|r_symndx
operator|=
name|dot
operator|->
name|sy_number
expr_stmt|;
block|}
else|else
block|{
name|intr
operator|.
name|r_symndx
operator|=
name|symbol_ptr
operator|->
name|sy_number
expr_stmt|;
block|}
block|}
else|else
block|{
name|intr
operator|.
name|r_symndx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|bfd_coff_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|intr
argument_list|,
name|ext_ptr
argument_list|)
expr_stmt|;
name|ext_ptr
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TC_A29K
argument_list|)
comment|/* The 29k has a special kludge for the high 16 bit reloc. 							   Two relocations are emmited, R_IHIHALF, and 							   R_IHCONST. The second one doesn't contain a symbol, 							   but uses the value for offset */
if|if
condition|(
name|intr
operator|.
name|r_type
operator|==
name|R_IHIHALF
condition|)
block|{
comment|/* now emit the second bit */
name|intr
operator|.
name|r_type
operator|=
name|R_IHCONST
expr_stmt|;
name|intr
operator|.
name|r_symndx
operator|=
name|fix_ptr
operator|->
name|fx_addnumber
expr_stmt|;
operator|(
name|void
operator|)
name|bfd_coff_swap_reloc_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|intr
argument_list|,
name|ext_ptr
argument_list|)
expr_stmt|;
name|ext_ptr
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|fix_ptr
operator|=
name|fix_ptr
operator|->
name|fx_next
expr_stmt|;
block|}
comment|/* Write out the reloc table */
name|segment_info
index|[
name|idx
index|]
operator|.
name|scnhdr
operator|.
name|s_relptr
operator|=
operator|*
name|file_cursor
expr_stmt|;
name|segment_info
index|[
name|idx
index|]
operator|.
name|scnhdr
operator|.
name|s_nreloc
operator|=
name|nrelocs
expr_stmt|;
name|bfd_write
argument_list|(
operator|(
name|PTR
operator|)
name|external_reloc_vec
argument_list|,
literal|1
argument_list|,
name|external_reloc_size
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
operator|*
name|file_cursor
operator|+=
name|external_reloc_size
expr_stmt|;
name|free
argument_list|(
name|external_reloc_vec
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/* run through a frag chain and write out the data to go with it, fill    in the scnhdrs with the info on the file postions     */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|fill_section
argument_list|,
operator|(
name|abfd
operator|,
name|filehdr
operator|,
name|file_cursor
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
expr|struct
name|internal_filehdr
operator|*
name|filehdr
name|AND
name|unsigned
name|long
operator|*
name|file_cursor
argument_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|paddr
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|SEG_E0
init|;
name|i
operator|<
name|SEG_UNKNOWN
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|struct
name|internal_scnhdr
modifier|*
name|s
init|=
operator|&
operator|(
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|)
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|s_name
index|[
literal|0
index|]
condition|)
block|{
name|fragS
modifier|*
name|frag
init|=
name|segment_info
index|[
name|i
index|]
operator|.
name|frchainP
operator|->
name|frch_root
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|malloc
argument_list|(
name|s
operator|->
name|s_size
argument_list|)
decl_stmt|;
name|s
operator|->
name|s_scnptr
operator|=
operator|*
name|file_cursor
expr_stmt|;
name|s
operator|->
name|s_paddr
operator|=
name|paddr
expr_stmt|;
name|s
operator|->
name|s_vaddr
operator|=
name|paddr
expr_stmt|;
name|s
operator|->
name|s_flags
operator|=
name|STYP_REG
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|s_name
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|->
name|s_flags
operator||=
name|STYP_TEXT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|s_name
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|->
name|s_flags
operator||=
name|STYP_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|s
operator|->
name|s_name
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
name|s
operator|->
name|s_flags
operator||=
name|STYP_BSS
operator||
name|STYP_NOLOAD
expr_stmt|;
while|while
condition|(
name|frag
condition|)
block|{
name|unsigned
name|int
name|fill_size
decl_stmt|;
switch|switch
condition|(
name|frag
operator|->
name|fr_type
condition|)
block|{
case|case
name|rs_fill
case|:
case|case
name|rs_align
case|:
case|case
name|rs_org
case|:
if|if
condition|(
name|frag
operator|->
name|fr_fix
condition|)
block|{
name|memcpy
argument_list|(
name|buffer
operator|+
name|frag
operator|->
name|fr_address
argument_list|,
name|frag
operator|->
name|fr_literal
argument_list|,
name|frag
operator|->
name|fr_fix
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|frag
operator|->
name|fr_fix
expr_stmt|;
block|}
name|fill_size
operator|=
name|frag
operator|->
name|fr_var
expr_stmt|;
if|if
condition|(
name|fill_size
condition|)
block|{
name|unsigned
name|int
name|count
decl_stmt|;
name|unsigned
name|int
name|off
init|=
name|frag
operator|->
name|fr_fix
decl_stmt|;
for|for
control|(
name|count
operator|=
name|frag
operator|->
name|fr_offset
init|;
name|count
condition|;
name|count
operator|--
control|)
block|{
name|memcpy
argument_list|(
name|buffer
operator|+
name|frag
operator|->
name|fr_address
operator|+
name|off
argument_list|,
name|frag
operator|->
name|fr_literal
operator|+
name|frag
operator|->
name|fr_fix
argument_list|,
name|fill_size
argument_list|)
expr_stmt|;
name|off
operator|+=
name|fill_size
expr_stmt|;
name|offset
operator|+=
name|fill_size
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|frag
operator|=
name|frag
operator|->
name|fr_next
expr_stmt|;
block|}
name|bfd_write
argument_list|(
name|buffer
argument_list|,
name|s
operator|->
name|s_size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
operator|*
name|file_cursor
operator|+=
name|s
operator|->
name|s_size
expr_stmt|;
name|paddr
operator|+=
name|s
operator|->
name|s_size
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Coff file generation& utilities */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|coff_header_append
argument_list|,
operator|(
name|abfd
operator|,
name|filehdr
operator|,
name|aouthdr
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
expr|struct
name|internal_filehdr
operator|*
name|filehdr
name|AND
expr|struct
name|internal_aouthdr
operator|*
name|aouthdr
argument_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|char
name|buffer
index|[
literal|1000
index|]
decl_stmt|;
name|char
name|buffero
index|[
literal|1000
index|]
decl_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|filehdr.f_opthdr = bfd_coff_swap_aouthdr_out(abfd, aouthdr, 						     buffero);
else|#
directive|else
name|filehdr
operator|->
name|f_opthdr
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|bfd_coff_swap_filehdr_out
argument_list|(
name|abfd
argument_list|,
name|filehdr
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
name|buffer
argument_list|,
name|i
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
name|buffero
argument_list|,
name|filehdr
operator|->
name|f_opthdr
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|SEG_E0
init|;
name|i
operator|<
name|SEG_E9
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_name
index|[
literal|0
index|]
condition|)
block|{
name|unsigned
name|int
name|size
init|=
name|bfd_coff_swap_scnhdr_out
argument_list|(
name|abfd
argument_list|,
operator|&
operator|(
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|)
argument_list|,
name|buffer
argument_list|)
decl_stmt|;
name|bfd_write
argument_list|(
name|buffer
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|DEFUN
argument_list|(
name|symbol_to_chars
argument_list|,
operator|(
name|abfd
operator|,
name|where
operator|,
name|symbolP
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|char
operator|*
name|where
name|AND
name|symbolS
operator|*
name|symbolP
argument_list|)
block|{
name|unsigned
name|int
name|numaux
init|=
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_entry
operator|.
name|n_numaux
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Turn any symbols with register attributes into abs symbols */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_REGISTER
condition|)
block|{
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|SEG_ABSOLUTE
argument_list|)
expr_stmt|;
block|}
comment|/* At the same time, relocate all symbols to their output value */
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|segment_info
index|[
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
index|]
operator|.
name|scnhdr
operator|.
name|s_paddr
operator|+
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
name|where
operator|+=
name|bfd_coff_swap_sym_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_entry
argument_list|,
name|where
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numaux
condition|;
name|i
operator|++
control|)
block|{
name|where
operator|+=
name|bfd_coff_swap_aux_out
argument_list|(
name|abfd
argument_list|,
operator|&
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_auxent
index|[
name|i
index|]
argument_list|,
name|S_GET_DATA_TYPE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
block|}
return|return
name|where
return|;
block|}
end_decl_stmt

begin_function
name|void
name|obj_symbol_new_hook
parameter_list|(
name|symbolP
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
name|char
name|underscore
init|=
literal|0
decl_stmt|;
comment|/* Symbol has leading _ */
comment|/* Effective symbol */
comment|/* Store the pointer in the offset. */
name|S_SET_ZEROES
argument_list|(
name|symbolP
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|S_SET_DATA_TYPE
argument_list|(
name|symbolP
argument_list|,
name|T_NULL
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Additional information */
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_flags
operator|=
literal|0
expr_stmt|;
comment|/* Auxiliary entries */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_auxent
index|[
literal|0
index|]
argument_list|,
literal|'\0'
argument_list|,
name|AUXESZ
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STRIP_UNDERSCORE
comment|/* Remove leading underscore at the beginning of the symbol. 	 * This is to be compatible with the standard librairies. 	 */
if|if
condition|(
operator|*
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|'_'
condition|)
block|{
name|underscore
operator|=
literal|1
expr_stmt|;
name|S_SET_NAME
argument_list|(
name|symbolP
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* strip underscore */
endif|#
directive|endif
comment|/* STRIP_UNDERSCORE */
if|if
condition|(
name|S_IS_STRING
argument_list|(
name|symbolP
argument_list|)
condition|)
name|SF_SET_STRING
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|underscore
operator|&&
name|S_IS_LOCAL
argument_list|(
name|symbolP
argument_list|)
condition|)
name|SF_SET_LOCAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_symbol_new_hook() */
end_comment

begin_comment
comment|/* stack stuff */
end_comment

begin_function
name|stack
modifier|*
name|stack_init
parameter_list|(
name|chunk_size
parameter_list|,
name|element_size
parameter_list|)
name|unsigned
name|long
name|chunk_size
decl_stmt|;
name|unsigned
name|long
name|element_size
decl_stmt|;
block|{
name|stack
modifier|*
name|st
decl_stmt|;
if|if
condition|(
operator|(
name|st
operator|=
operator|(
name|stack
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|stack
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
name|stack
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
name|stack
operator|*
operator|)
literal|0
return|;
if|if
condition|(
operator|(
name|st
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|chunk_size
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
return|return
operator|(
name|stack
operator|*
operator|)
literal|0
return|;
block|}
name|st
operator|->
name|pointer
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|size
operator|=
name|chunk_size
expr_stmt|;
name|st
operator|->
name|chunk_size
operator|=
name|chunk_size
expr_stmt|;
name|st
operator|->
name|element_size
operator|=
name|element_size
expr_stmt|;
return|return
name|st
return|;
block|}
end_function

begin_comment
comment|/* stack_init() */
end_comment

begin_function
name|void
name|stack_delete
parameter_list|(
name|st
parameter_list|)
name|stack
modifier|*
name|st
decl_stmt|;
block|{
name|free
argument_list|(
name|st
operator|->
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|stack_push
parameter_list|(
name|st
parameter_list|,
name|element
parameter_list|)
name|stack
modifier|*
name|st
decl_stmt|;
name|char
modifier|*
name|element
decl_stmt|;
block|{
if|if
condition|(
name|st
operator|->
name|pointer
operator|+
name|st
operator|->
name|element_size
operator|>=
name|st
operator|->
name|size
condition|)
block|{
name|st
operator|->
name|size
operator|+=
name|st
operator|->
name|chunk_size
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|->
name|data
operator|=
name|xrealloc
argument_list|(
name|st
operator|->
name|data
argument_list|,
name|st
operator|->
name|size
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|st
operator|->
name|data
operator|+
name|st
operator|->
name|pointer
argument_list|,
name|element
argument_list|,
name|st
operator|->
name|element_size
argument_list|)
expr_stmt|;
name|st
operator|->
name|pointer
operator|+=
name|st
operator|->
name|element_size
expr_stmt|;
return|return
name|st
operator|->
name|data
operator|+
name|st
operator|->
name|pointer
return|;
block|}
end_function

begin_comment
comment|/* stack_push() */
end_comment

begin_function
name|char
modifier|*
name|stack_pop
parameter_list|(
name|st
parameter_list|)
name|stack
modifier|*
name|st
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|st
operator|->
name|pointer
operator|-=
name|st
operator|->
name|element_size
operator|)
operator|<
literal|0
condition|)
block|{
name|st
operator|->
name|pointer
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
return|return
name|st
operator|->
name|data
operator|+
name|st
operator|->
name|pointer
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|stack_top
parameter_list|(
name|st
parameter_list|)
name|stack
modifier|*
name|st
decl_stmt|;
block|{
return|return
name|st
operator|->
name|data
operator|+
name|st
operator|->
name|pointer
operator|-
name|st
operator|->
name|element_size
return|;
block|}
end_function

begin_comment
comment|/*  * Handle .ln directives.  */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_ln
parameter_list|()
block|{
name|int
name|l
decl_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|!=
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
literal|".ln pseudo-op inside .def/.endef: ignored."
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* wrong context */
name|c_line_new
argument_list|(
literal|0
argument_list|,
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|l
operator|=
name|get_absolute_expression
argument_list|()
argument_list|,
name|frag_now
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
block|{
specifier|extern
name|int
name|listing
decl_stmt|;
if|if
condition|(
name|listing
condition|)
block|{
name|listing_source_line
argument_list|(
name|l
operator|+
name|line_base
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_coff_line() */
end_comment

begin_comment
comment|/*  *			def()  *  * Handle .def directives.  *  * One might ask : why can't we symbol_new if the symbol does not  * already exist and fill it with debug information.  Because of  * the C_EFCN special symbol. It would clobber the value of the  * function symbol before we have a chance to notice that it is  * a C_EFCN. And a second reason is that the code is more clear this  * way. (at least I think it is :-).  *  */
end_comment

begin_define
define|#
directive|define
name|SKIP_SEMI_COLON
parameter_list|()
value|while (*input_line_pointer++ != ';')
end_define

begin_define
define|#
directive|define
name|SKIP_WHITESPACES
parameter_list|()
value|while (*input_line_pointer == ' ' || \ 				       *input_line_pointer == '\t') \     input_line_pointer++;
end_define

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|obj_coff_def
argument_list|,
operator|(
name|what
operator|)
argument_list|,
name|int
name|what
argument_list|)
block|{
name|char
name|name_end
decl_stmt|;
comment|/* Char after the end of name */
name|char
modifier|*
name|symbol_name
decl_stmt|;
comment|/* Name of the debug symbol */
name|char
modifier|*
name|symbol_name_copy
decl_stmt|;
comment|/* Temporary copy of the name */
name|unsigned
name|int
name|symbol_name_length
decl_stmt|;
comment|/*$char*	directiveP;$ */
comment|/* Name of the pseudo opcode */
comment|/*$char directive[MAX_DIRECTIVE];$ */
comment|/* Backup of the directive */
comment|/*$char end = 0;$ */
comment|/* If 1, stop parsing */
if|if
condition|(
name|def_symbol_in_progress
operator|!=
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
literal|".def pseudo-op used inside of .def/.endef: ignored."
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
name|SKIP_WHITESPACES
argument_list|()
expr_stmt|;
name|def_symbol_in_progress
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|def_symbol_in_progress
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|def_symbol_in_progress
argument_list|)
argument_list|)
expr_stmt|;
name|symbol_name
operator|=
name|input_line_pointer
expr_stmt|;
name|name_end
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|symbol_name_length
operator|=
name|strlen
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
name|symbol_name_copy
operator|=
name|xmalloc
argument_list|(
name|symbol_name_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|symbol_name_copy
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
comment|/* Initialize the new symbol */
ifdef|#
directive|ifdef
name|STRIP_UNDERSCORE
name|S_SET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|(
operator|*
name|symbol_name_copy
operator|==
literal|'_'
condition|?
name|symbol_name_copy
operator|+
literal|1
else|:
name|symbol_name_copy
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* STRIP_UNDERSCORE */
name|S_SET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|symbol_name_copy
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* STRIP_UNDERSCORE */
comment|/* free(symbol_name_copy); */
name|def_symbol_in_progress
operator|->
name|sy_name_offset
operator|=
operator|~
literal|0
expr_stmt|;
name|def_symbol_in_progress
operator|->
name|sy_number
operator|=
operator|~
literal|0
expr_stmt|;
name|def_symbol_in_progress
operator|->
name|sy_frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
if|if
condition|(
name|S_IS_STRING
argument_list|(
name|def_symbol_in_progress
argument_list|)
condition|)
block|{
name|SF_SET_STRING
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
block|}
comment|/* "long" name */
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_decl_stmt

begin_comment
comment|/* obj_coff_def() */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|dim_index
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|DEFUN_VOID
parameter_list|(
name|obj_coff_endef
parameter_list|)
block|{
name|symbolS
modifier|*
name|symbolP
init|=
literal|0
decl_stmt|;
comment|/* DIM BUG FIX sac@cygnus.com */
name|dim_index
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
literal|".endef pseudo-op used outside of .def/.endef: ignored."
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
comment|/* Set the section number according to storage class. */
switch|switch
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
condition|)
block|{
case|case
name|C_STRTAG
case|:
case|case
name|C_ENTAG
case|:
case|case
name|C_UNTAG
case|:
name|SF_SET_TAG
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
comment|/* intentional fallthrough */
case|case
name|C_FILE
case|:
case|case
name|C_TPDEF
case|:
name|SF_SET_DEBUG
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|SEG_DEBUG
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_EFCN
case|:
name|SF_SET_LOCAL
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
comment|/* Do not emit this symbol. */
comment|/* intentional fallthrough */
case|case
name|C_BLOCK
case|:
name|SF_SET_PROCESS
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
comment|/* Will need processing before writing */
comment|/* intentional fallthrough */
case|case
name|C_FCN
case|:
name|S_SET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|SEG_E0
argument_list|)
expr_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|->
name|sy_symbol
operator|.
name|ost_entry
operator|.
name|n_name
index|[
literal|1
index|]
operator|==
literal|'b'
condition|)
block|{
comment|/* .bf */
if|if
condition|(
name|function_lineoff
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"`.bf' symbol without preceding function\n"
argument_list|)
expr_stmt|;
block|}
comment|/* missing function symbol */
name|SA_GET_SYM_LNNOPTR
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|=
name|function_lineoff
expr_stmt|;
name|SF_SET_PROCESS
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
comment|/* Will need relocating */
name|function_lineoff
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|C_AUTOARG
case|case
name|C_AUTOARG
case|:
endif|#
directive|endif
comment|/* C_AUTOARG */
case|case
name|C_AUTO
case|:
case|case
name|C_REG
case|:
case|case
name|C_MOS
case|:
case|case
name|C_MOE
case|:
case|case
name|C_MOU
case|:
case|case
name|C_ARG
case|:
case|case
name|C_REGPARM
case|:
case|case
name|C_FIELD
case|:
case|case
name|C_EOS
case|:
name|SF_SET_DEBUG
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|SEG_ABSOLUTE
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_EXT
case|:
case|case
name|C_STAT
case|:
case|case
name|C_LABEL
case|:
comment|/* Valid but set somewhere else (s_comm, s_lcomm, colon) */
break|break;
case|case
name|C_USTATIC
case|:
case|case
name|C_EXTDEF
case|:
case|case
name|C_ULABEL
case|:
name|as_warn
argument_list|(
literal|"unexpected storage class %d"
argument_list|,
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch on storage class */
comment|/* Now that we have built a debug symbol, try to 	   find if we should merge with an existing symbol 	   or not.  If a symbol is C_EFCN or SEG_ABSOLUTE or 	   untagged SEG_DEBUG it never merges. */
comment|/* Two cases for functions.  Either debug followed 	   by definition or definition followed by debug. 	   For definition first, we will merge the debug 	   symbol into the definition.  For debug first, the 	   lineno entry MUST point to the definition 	   function or else it will point off into space 	   when crawl_symbols() merges the debug 	   symbol into the real symbol.  Therefor, let's 	   presume the debug symbol is a real function 	   reference. */
comment|/* FIXME-SOON If for some reason the definition 	   label/symbol is never seen, this will probably 	   leave an undefined symbol at link time. */
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
name|C_EFCN
operator|||
operator|(
name|S_GET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
name|SEG_DEBUG
operator|&&
operator|!
name|SF_GET_TAG
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|)
operator|||
name|S_GET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
name|SEG_ABSOLUTE
operator|||
operator|(
name|symbolP
operator|=
name|symbol_find_base
argument_list|(
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|,
name|DO_NOT_STRIP
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|symbol_append
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|symbol_lastP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This symbol already exists, merge the 		   newly created symbol into the old one. 		   This is not mandatory. The linker can 		   handle duplicate symbols correctly. But I 		   guess that it save a *lot* of space if 		   the assembly file defines a lot of 		   symbols. [loic] */
comment|/* The debug entry (def_symbol_in_progress) 		   is merged into the previous definition. */
name|c_symbol_merge
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|symbolP
argument_list|)
expr_stmt|;
comment|/* FIXME-SOON Should *def_symbol_in_progress be free'd? xoxorich. */
name|def_symbol_in_progress
operator|=
name|symbolP
expr_stmt|;
if|if
condition|(
name|SF_GET_FUNCTION
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|||
name|SF_GET_TAG
argument_list|(
name|def_symbol_in_progress
argument_list|)
condition|)
block|{
comment|/* For functions, and tags, the symbol *must* be where the debug symbol 			   appears.  Move the existing symbol to the current place. */
comment|/* If it already is at the end of the symbol list, do nothing */
if|if
condition|(
name|def_symbol_in_progress
operator|!=
name|symbol_lastP
condition|)
block|{
name|symbol_remove
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_append
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|symbol_lastP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
comment|/* if not already in place */
block|}
comment|/* if function */
block|}
comment|/* normal or mergable */
if|if
condition|(
name|SF_GET_TAG
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|&&
name|symbol_find_base
argument_list|(
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|,
name|DO_NOT_STRIP
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|tag_insert
argument_list|(
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|,
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
block|}
comment|/* If symbol is a {structure,union} tag, associate symbol to its name. */
if|if
condition|(
name|SF_GET_FUNCTION
argument_list|(
name|def_symbol_in_progress
argument_list|)
condition|)
block|{
name|know
argument_list|(
sizeof|sizeof
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|function_lineoff
operator|=
name|c_line_new
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|SF_SET_PROCESS
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolP
operator|==
name|NULL
condition|)
block|{
comment|/* That is, if this is the first 			   time we've seen the function... */
name|symbol_table_insert
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
block|}
comment|/* definition follows debug */
block|}
comment|/* Create the line number entry pointing to the function being defined */
name|def_symbol_in_progress
operator|=
name|NULL
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_coff_endef() */
end_comment

begin_function
specifier|static
name|void
name|DEFUN_VOID
parameter_list|(
name|obj_coff_dim
parameter_list|)
block|{
specifier|register
name|int
name|dim_index
decl_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
literal|".dim pseudo-op used outside of .def/.endef: ignored."
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|dim_index
operator|=
literal|0
init|;
name|dim_index
operator|<
name|DIMNUM
condition|;
name|dim_index
operator|++
control|)
block|{
name|SKIP_WHITESPACES
argument_list|()
expr_stmt|;
name|SA_SET_SYM_DIMEN
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|dim_index
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|input_line_pointer
condition|)
block|{
case|case
literal|','
case|:
name|input_line_pointer
operator|++
expr_stmt|;
break|break;
default|default:
name|as_warn
argument_list|(
literal|"badly formed .dim directive ignored"
argument_list|)
expr_stmt|;
comment|/* intentional fallthrough */
case|case
literal|'\n'
case|:
case|case
literal|';'
case|:
name|dim_index
operator|=
name|DIMNUM
expr_stmt|;
break|break;
block|}
comment|/* switch on following character */
block|}
comment|/* for each dimension */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_coff_dim() */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_line
parameter_list|()
block|{
name|int
name|this_base
decl_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|obj_coff_ln
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if it looks like a stabs style line */
name|this_base
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|this_base
operator|>
name|line_base
condition|)
block|{
name|line_base
operator|=
name|this_base
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_LISTING
block|{
specifier|extern
name|int
name|listing
decl_stmt|;
if|if
condition|(
name|listing
operator|&&
literal|0
condition|)
block|{
name|listing_source_line
argument_list|(
name|line_base
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SA_SET_SYM_LNNO
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|line_base
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_coff_line() */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_size
parameter_list|()
block|{
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
literal|".size pseudo-op used outside of .def/.endef ignored."
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SA_SET_SYM_SIZE
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_coff_size() */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_scl
parameter_list|()
block|{
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
literal|".scl pseudo-op used outside of .def/.endef ignored."
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
name|S_SET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_coff_scl() */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_tag
parameter_list|()
block|{
name|char
modifier|*
name|symbol_name
decl_stmt|;
name|char
name|name_end
decl_stmt|;
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
literal|".tag pseudo-op used outside of .def/.endef ignored."
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|def_symbol_in_progress
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|symbol_name
operator|=
name|input_line_pointer
expr_stmt|;
name|name_end
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* Assume that the symbol referred to by .tag is always defined. */
comment|/* This was a bad assumption.  I've added find_or_make. xoxorich. */
name|SA_SET_SYM_TAGNDX
argument_list|(
name|def_symbol_in_progress
argument_list|,
operator|(
name|long
operator|)
name|tag_find_or_make
argument_list|(
name|symbol_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SA_GET_SYM_TAGNDX
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|==
literal|0L
condition|)
block|{
name|as_warn
argument_list|(
literal|"tag not found for .tag %s"
argument_list|,
name|symbol_name
argument_list|)
expr_stmt|;
block|}
comment|/* not defined */
name|SF_SET_TAGGED
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_coff_tag() */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_type
parameter_list|()
block|{
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
literal|".type pseudo-op used outside of .def/.endef ignored."
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
name|S_SET_DATA_TYPE
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISFCN
argument_list|(
name|S_GET_DATA_TYPE
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|)
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|def_symbol_in_progress
argument_list|)
operator|!=
name|C_TPDEF
condition|)
block|{
name|SF_SET_FUNCTION
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
block|}
comment|/* is a function */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_coff_type() */
end_comment

begin_function
specifier|static
name|void
name|obj_coff_val
parameter_list|()
block|{
if|if
condition|(
name|def_symbol_in_progress
operator|==
name|NULL
condition|)
block|{
name|as_warn
argument_list|(
literal|".val pseudo-op used outside of .def/.endef ignored."
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if not inside .def/.endef */
if|if
condition|(
name|is_name_beginner
argument_list|(
operator|*
name|input_line_pointer
argument_list|)
condition|)
block|{
name|char
modifier|*
name|symbol_name
init|=
name|input_line_pointer
decl_stmt|;
name|char
name|name_end
init|=
name|get_symbol_end
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|symbol_name
argument_list|,
literal|"."
argument_list|)
condition|)
block|{
name|def_symbol_in_progress
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|)
expr_stmt|;
comment|/* If the .val is != from the .def (e.g. statics) */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|def_symbol_in_progress
argument_list|)
argument_list|,
name|symbol_name
argument_list|)
condition|)
block|{
name|def_symbol_in_progress
operator|->
name|sy_forward
operator|=
name|symbol_find_or_make
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
comment|/* If the segment is undefined when the forward 			   reference is solved, then copy the segment id 			   from the forward symbol. */
name|SF_SET_GET_SEGMENT
argument_list|(
name|def_symbol_in_progress
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, it is the name of a non debug symbol and its value will be calculated later. */
operator|*
name|input_line_pointer
operator|=
name|name_end
expr_stmt|;
block|}
else|else
block|{
name|S_SET_VALUE
argument_list|(
name|def_symbol_in_progress
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* if symbol based */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_coff_val() */
end_comment

begin_comment
comment|/*  * Maintain a list of the tagnames of the structres.  */
end_comment

begin_function
specifier|static
name|void
name|tag_init
parameter_list|()
block|{
name|tag_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
return|return ;
block|}
end_function

begin_comment
comment|/* tag_init() */
end_comment

begin_function
specifier|static
name|void
name|tag_insert
parameter_list|(
name|name
parameter_list|,
name|symbolP
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|error_string
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|error_string
operator|=
name|hash_jam
argument_list|(
name|tag_hash
argument_list|,
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|symbolP
argument_list|)
operator|)
condition|)
block|{
name|as_fatal
argument_list|(
literal|"Inserting \"%s\" into structure table failed: %s"
argument_list|,
name|name
argument_list|,
name|error_string
argument_list|)
expr_stmt|;
block|}
return|return ;
block|}
end_function

begin_comment
comment|/* tag_insert() */
end_comment

begin_function
specifier|static
name|symbolS
modifier|*
name|tag_find_or_make
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
if|if
condition|(
operator|(
name|symbolP
operator|=
name|tag_find
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|SEG_UNKNOWN
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|tag_insert
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|symbolP
argument_list|)
expr_stmt|;
name|symbol_table_insert
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
comment|/* not found */
return|return
operator|(
name|symbolP
operator|)
return|;
block|}
end_function

begin_comment
comment|/* tag_find_or_make() */
end_comment

begin_function
specifier|static
name|symbolS
modifier|*
name|tag_find
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|STRIP_UNDERSCORE
if|if
condition|(
operator|*
name|name
operator|==
literal|'_'
condition|)
name|name
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* STRIP_UNDERSCORE */
return|return
operator|(
operator|(
name|symbolS
operator|*
operator|)
name|hash_find
argument_list|(
name|tag_hash
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* tag_find() */
end_comment

begin_function
name|void
name|obj_read_begin_hook
parameter_list|()
block|{
comment|/* These had better be the same.  Usually 18 bytes. */
ifndef|#
directive|ifndef
name|BFD_HEADERS
name|know
argument_list|(
sizeof|sizeof
argument_list|(
name|SYMENT
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|AUXENT
argument_list|)
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|SYMESZ
operator|==
name|AUXESZ
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tag_init
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* obj_read_begin_hook() */
end_comment

begin_comment
comment|/* This function runs through the symbol table and puts all the    externals onto another chain */
end_comment

begin_comment
comment|/* The chain of externals */
end_comment

begin_decl_stmt
name|symbolS
modifier|*
name|symbol_externP
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|symbol_extern_lastP
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|stack
modifier|*
name|block_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|last_functionP
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|last_tagP
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|int
name|DEFUN_VOID
parameter_list|(
name|yank_symbols
parameter_list|)
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|unsigned
name|int
name|symbol_number
init|=
literal|0
decl_stmt|;
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbolP
condition|?
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
else|:
name|symbol_rootP
control|)
block|{
if|if
condition|(
operator|!
name|SF_GET_DEBUG
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* Debug symbols do not need all this rubbish */
name|symbolS
modifier|*
name|real_symbolP
decl_stmt|;
comment|/* L* and C_EFCN symbols never merge. */
if|if
condition|(
operator|!
name|SF_GET_LOCAL
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|(
name|real_symbolP
operator|=
name|symbol_find_base
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|DO_NOT_STRIP
argument_list|)
operator|)
operator|&&
name|real_symbolP
operator|!=
name|symbolP
condition|)
block|{
comment|/* FIXME-SOON: where do dups come from? 				   Maybe tag references before definitions? xoxorich. */
comment|/* Move the debug data from the debug symbol to the 				   real symbol. Do NOT do the oposite (i.e. move from 				   real symbol to debug symbol and remove real symbol from the 				   list.) Because some pointers refer to the real symbol 				   whereas no pointers refer to the debug symbol. */
name|c_symbol_merge
argument_list|(
name|symbolP
argument_list|,
name|real_symbolP
argument_list|)
expr_stmt|;
comment|/* Replace the current symbol by the real one */
comment|/* The symbols will never be the last or the first 				   because : 1st symbol is .file and 3 last symbols are 				   .text, .data, .bss */
name|symbol_remove
argument_list|(
name|real_symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_insert
argument_list|(
name|real_symbolP
argument_list|,
name|symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_remove
argument_list|(
name|symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|real_symbolP
expr_stmt|;
block|}
comment|/* if not local but dup'd */
if|if
condition|(
name|flagseen
index|[
literal|'R'
index|]
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_E1
operator|)
condition|)
block|{
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|SEG_E0
argument_list|)
expr_stmt|;
block|}
comment|/* push data into text */
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|+
name|symbolP
operator|->
name|sy_frag
operator|->
name|fr_address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|SF_GET_LOCAL
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_NULL
condition|)
block|{
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_E0
condition|)
block|{
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_LABEL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_STAT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Mainly to speed up if not -g */
if|if
condition|(
name|SF_GET_PROCESS
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* Handle the nested blocks auxiliary info. */
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_BLOCK
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
literal|".bb"
argument_list|)
condition|)
name|stack_push
argument_list|(
name|block_stack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|symbolP
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* .eb */
specifier|register
name|symbolS
modifier|*
name|begin_symbolP
decl_stmt|;
name|begin_symbolP
operator|=
operator|*
operator|(
name|symbolS
operator|*
operator|*
operator|)
name|stack_pop
argument_list|(
name|block_stack
argument_list|)
expr_stmt|;
if|if
condition|(
name|begin_symbolP
operator|==
operator|(
name|symbolS
operator|*
operator|)
literal|0
condition|)
name|as_warn
argument_list|(
literal|"mismatched .eb"
argument_list|)
expr_stmt|;
else|else
name|SA_SET_SYM_ENDNDX
argument_list|(
name|begin_symbolP
argument_list|,
name|symbol_number
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we are able to identify the type of a function, and we 				       are out of a function (last_functionP == 0) then, the 				       function symbol will be associated with an auxiliary 				       entry. */
if|if
condition|(
name|last_functionP
operator|==
operator|(
name|symbolS
operator|*
operator|)
literal|0
operator|&&
name|SF_GET_FUNCTION
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|last_functionP
operator|=
name|symbolP
expr_stmt|;
if|if
condition|(
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|)
operator|<
literal|1
condition|)
block|{
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* make it at least 1 */
comment|/* Clobber possible stale .dim information. */
name|memset
argument_list|(
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_auxent
index|[
literal|0
index|]
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_auxent
index|[
literal|0
index|]
operator|.
name|x_sym
operator|.
name|x_fcnary
operator|.
name|x_ary
operator|.
name|x_dimen
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The C_FCN doesn't need any additional information. 				       I don't even know if this is needed for sdb. But the 				       standard assembler generates it, so... 				       */
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_EFCN
condition|)
block|{
if|if
condition|(
name|last_functionP
operator|==
operator|(
name|symbolS
operator|*
operator|)
literal|0
condition|)
name|as_fatal
argument_list|(
literal|"C_EFCN symbol out of scope"
argument_list|)
expr_stmt|;
name|SA_SET_SYM_FSIZE
argument_list|(
name|last_functionP
argument_list|,
call|(
name|long
call|)
argument_list|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|last_functionP
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SA_SET_SYM_ENDNDX
argument_list|(
name|last_functionP
argument_list|,
name|symbol_number
argument_list|)
expr_stmt|;
name|last_functionP
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|SF_GET_TAG
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* First descriptor of a structure must point to 			   the first slot after the structure description. */
name|last_tagP
operator|=
name|symbolP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_EOS
condition|)
block|{
comment|/* +2 take in account the current symbol */
name|SA_SET_SYM_ENDNDX
argument_list|(
name|last_tagP
argument_list|,
name|symbol_number
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_FILE
condition|)
block|{
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|S_SET_VALUE
argument_list|(
operator|(
name|symbolS
operator|*
operator|)
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|symbol_number
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* no one points at the first .file symbol */
block|}
comment|/* if debug or tag or eos or file */
comment|/* We must put the external symbols apart. The loader 		   does not bomb if we do not. But the references in 		   the endndx field for a .bb symbol are not corrected 		   if an external symbol is removed between .bb and .be. 		   I.e in the following case : 		   [20] .bb endndx = 22 		   [21] foo external 		   [22] .be 		   ld will move the symbol 21 to the end of the list but 		   endndx will still be 22 instead of 21. */
if|if
condition|(
name|SF_GET_LOCAL
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* remove C_EFCN and LOCAL (L...) symbols */
comment|/* next pointer remains valid */
name|symbol_remove
argument_list|(
name|symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|S_IS_DEBUG
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|!
name|SF_GET_STATICS
argument_list|(
name|symbolP
argument_list|)
operator|&&
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|)
operator|==
name|C_EXT
condition|)
block|{
comment|/* C_EXT&& !SF_GET_FUNCTION(symbolP))  */
comment|/* if external, Remove from the list */
name|symbolS
modifier|*
name|hold
init|=
name|symbol_previous
argument_list|(
name|symbolP
argument_list|)
decl_stmt|;
name|symbol_remove
argument_list|(
name|symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_clear_list_pointers
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbol_append
argument_list|(
name|symbolP
argument_list|,
name|symbol_extern_lastP
argument_list|,
operator|&
name|symbol_externP
argument_list|,
operator|&
name|symbol_extern_lastP
argument_list|)
expr_stmt|;
name|symbolP
operator|=
name|hold
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SF_GET_STRING
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|symbolP
operator|->
name|sy_name_offset
operator|=
name|string_byte_count
expr_stmt|;
name|string_byte_count
operator|+=
name|strlen
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|symbolP
operator|->
name|sy_name_offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* fix "long" names */
name|symbolP
operator|->
name|sy_number
operator|=
name|symbol_number
expr_stmt|;
name|symbol_number
operator|+=
literal|1
operator|+
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
comment|/* if local symbol */
block|}
comment|/* traverse the symbol list */
return|return
name|symbol_number
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|DEFUN_VOID
parameter_list|(
name|glue_symbols
parameter_list|)
block|{
name|unsigned
name|int
name|symbol_number
init|=
literal|0
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
for|for
control|(
name|symbolP
operator|=
name|symbol_externP
init|;
name|symbol_externP
condition|;
control|)
block|{
name|symbolS
modifier|*
name|tmp
init|=
name|symbol_externP
decl_stmt|;
comment|/* append */
name|symbol_remove
argument_list|(
name|tmp
argument_list|,
operator|&
name|symbol_externP
argument_list|,
operator|&
name|symbol_extern_lastP
argument_list|)
expr_stmt|;
name|symbol_append
argument_list|(
name|tmp
argument_list|,
name|symbol_lastP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
comment|/* and process */
if|if
condition|(
name|SF_GET_STRING
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|tmp
operator|->
name|sy_name_offset
operator|=
name|string_byte_count
expr_stmt|;
name|string_byte_count
operator|+=
name|strlen
argument_list|(
name|S_GET_NAME
argument_list|(
name|tmp
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|->
name|sy_name_offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* fix "long" names */
name|tmp
operator|->
name|sy_number
operator|=
name|symbol_number
expr_stmt|;
name|symbol_number
operator|+=
literal|1
operator|+
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* append the entire extern chain */
return|return
name|symbol_number
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|DEFUN_VOID
parameter_list|(
name|tie_tags
parameter_list|)
block|{
name|unsigned
name|int
name|symbol_number
init|=
literal|0
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
name|symbolP
operator|->
name|sy_number
operator|=
name|symbol_number
expr_stmt|;
if|if
condition|(
name|SF_GET_TAGGED
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|SA_SET_SYM_TAGNDX
argument_list|(
name|symbolP
argument_list|,
operator|(
operator|(
name|symbolS
operator|*
operator|)
name|SA_GET_SYM_TAGNDX
argument_list|(
name|symbolP
argument_list|)
operator|)
operator|->
name|sy_number
argument_list|)
expr_stmt|;
block|}
name|symbol_number
operator|+=
literal|1
operator|+
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
return|return
name|symbol_number
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|crawl_symbols
argument_list|,
operator|(
name|headers
operator|,
name|abfd
operator|)
argument_list|,
expr|struct
name|internal_filehdr
operator|*
name|headers
name|AND
name|bfd
operator|*
name|abfd
argument_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|ptr
init|=
literal|0
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* Initialize the stack used to keep track of the matching .bb .be */
name|block_stack
operator|=
name|stack_init
argument_list|(
literal|512
argument_list|,
sizeof|sizeof
argument_list|(
name|symbolS
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* JF deal with forward references first... */
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
if|if
condition|(
name|symbolP
operator|->
name|sy_forward
condition|)
block|{
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|+
name|S_GET_VALUE
argument_list|(
name|symbolP
operator|->
name|sy_forward
argument_list|)
operator|+
name|symbolP
operator|->
name|sy_forward
operator|->
name|sy_frag
operator|->
name|fr_address
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SF_GET_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|S_GET_SEGMENT
argument_list|(
name|symbolP
operator|->
name|sy_forward
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* forward segment also */
name|symbolP
operator|->
name|sy_forward
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if it has a forward reference */
block|}
comment|/* walk the symbol chain */
comment|/* The symbol list should be ordered according to the following sequence 	 * order : 	 * . .file symbol 	 * . debug entries for functions 	 * . fake symbols for the sections, including.text .data and .bss 	 * . defined symbols 	 * . undefined symbols 	 * But this is not mandatory. The only important point is to put the 	 * undefined symbols at the end of the list. 	 */
if|if
condition|(
name|symbol_rootP
operator|==
name|NULL
operator|||
name|S_GET_STORAGE_CLASS
argument_list|(
name|symbol_rootP
argument_list|)
operator|!=
name|C_FILE
condition|)
block|{
name|c_dot_file_symbol
argument_list|(
literal|"fake"
argument_list|)
expr_stmt|;
block|}
comment|/* Is there a .file symbol ? If not insert one at the beginning. */
comment|/* 	 * Build up static symbols for the sections, they are filled in later 	 */
for|for
control|(
name|i
operator|=
name|SEG_E0
init|;
name|i
operator|<
name|SEG_E9
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_name
index|[
literal|0
index|]
condition|)
block|{
name|segment_info
index|[
name|i
index|]
operator|.
name|dot
operator|=
name|c_section_symbol
argument_list|(
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_name
argument_list|,
name|i
operator|-
name|SEG_E0
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Take all the externals out and put them into another chain */
name|headers
operator|->
name|f_nsyms
operator|=
name|yank_symbols
argument_list|()
expr_stmt|;
comment|/* Take the externals and glue them onto the end.*/
name|headers
operator|->
name|f_nsyms
operator|+=
name|glue_symbols
argument_list|()
expr_stmt|;
name|headers
operator|->
name|f_nsyms
operator|=
name|tie_tags
argument_list|()
expr_stmt|;
name|know
argument_list|(
name|symbol_externP
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|symbol_extern_lastP
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
end_decl_stmt

begin_comment
comment|/*  * Find strings by crawling along symbol table chain.  */
end_comment

begin_decl_stmt
name|void
name|DEFUN
argument_list|(
name|w_strings
argument_list|,
operator|(
name|where
operator|)
argument_list|,
name|char
operator|*
name|where
argument_list|)
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
comment|/* Gotta do md_ byte-ordering stuff for string_byte_count first - KWK */
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|string_byte_count
argument_list|,
sizeof|sizeof
argument_list|(
name|string_byte_count
argument_list|)
argument_list|)
expr_stmt|;
name|where
operator|+=
sizeof|sizeof
argument_list|(
name|string_byte_count
argument_list|)
expr_stmt|;
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
name|unsigned
name|int
name|size
decl_stmt|;
if|if
condition|(
name|SF_GET_STRING
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|size
operator|=
name|strlen
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|where
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|where
operator|+=
name|size
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|do_linenos_for
argument_list|,
operator|(
name|abfd
operator|,
name|file_cursor
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|unsigned
name|long
operator|*
name|file_cursor
argument_list|)
block|{
name|unsigned
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
name|SEG_E0
init|;
name|idx
operator|<
name|SEG_E9
condition|;
name|idx
operator|++
control|)
block|{
name|segment_info_type
modifier|*
name|s
init|=
name|segment_info
operator|+
name|idx
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|scnhdr
operator|.
name|s_nlnno
operator|!=
literal|0
condition|)
block|{
name|struct
name|lineno_list
modifier|*
name|line_ptr
decl_stmt|;
name|struct
name|external_lineno
modifier|*
name|buffer
init|=
operator|(
expr|struct
name|external_lineno
operator|*
operator|)
name|xmalloc
argument_list|(
name|s
operator|->
name|scnhdr
operator|.
name|s_nlnno
operator|*
name|LINESZ
argument_list|)
decl_stmt|;
name|struct
name|external_lineno
modifier|*
name|dst
init|=
name|buffer
decl_stmt|;
comment|/* Run through the table we've built and turn it into its external 				   form, take this chance to remove duplicates */
for|for
control|(
name|line_ptr
operator|=
name|s
operator|->
name|lineno_list_head
init|;
name|line_ptr
operator|!=
operator|(
expr|struct
name|lineno_list
operator|*
operator|)
name|NULL
condition|;
name|line_ptr
operator|=
name|line_ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|line_ptr
operator|->
name|line
operator|.
name|l_lnno
operator|==
literal|0
condition|)
block|{
comment|/* Turn a pointer to a symbol into the symbols' index */
name|line_ptr
operator|->
name|line
operator|.
name|l_addr
operator|.
name|l_symndx
operator|=
operator|(
operator|(
name|symbolS
operator|*
operator|)
name|line_ptr
operator|->
name|line
operator|.
name|l_addr
operator|.
name|l_symndx
operator|)
operator|->
name|sy_number
expr_stmt|;
block|}
else|else
block|{
name|line_ptr
operator|->
name|line
operator|.
name|l_addr
operator|.
name|l_paddr
operator|+=
operator|(
operator|(
expr|struct
name|frag
operator|*
operator|)
operator|(
name|line_ptr
operator|->
name|frag
operator|)
operator|)
operator|->
name|fr_address
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|bfd_coff_swap_lineno_out
argument_list|(
name|abfd
argument_list|,
operator|&
operator|(
name|line_ptr
operator|->
name|line
operator|)
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|dst
operator|++
expr_stmt|;
block|}
name|s
operator|->
name|scnhdr
operator|.
name|s_lnnoptr
operator|=
operator|*
name|file_cursor
expr_stmt|;
name|bfd_write
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|s
operator|->
name|scnhdr
operator|.
name|s_nlnno
operator|*
name|LINESZ
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
operator|*
name|file_cursor
operator|+=
name|s
operator|->
name|scnhdr
operator|.
name|s_nlnno
operator|*
name|LINESZ
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|/* Now we run through the list of frag chains in a segment and    make all the subsegment frags appear at the end of the    list, as if the seg 0 was extra long */
end_comment

begin_function
specifier|static
name|void
name|DEFUN_VOID
parameter_list|(
name|remove_subsegs
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|SEG_E0
init|;
name|i
operator|<
name|SEG_UNKNOWN
condition|;
name|i
operator|++
control|)
block|{
name|frchainS
modifier|*
name|head
init|=
name|segment_info
index|[
name|i
index|]
operator|.
name|frchainP
decl_stmt|;
name|fragS
name|dummy
decl_stmt|;
name|fragS
modifier|*
name|prev_frag
init|=
operator|&
name|dummy
decl_stmt|;
while|while
condition|(
name|head
operator|&&
name|head
operator|->
name|frch_seg
operator|==
name|i
condition|)
block|{
name|prev_frag
operator|->
name|fr_next
operator|=
name|head
operator|->
name|frch_root
expr_stmt|;
name|prev_frag
operator|=
name|head
operator|->
name|frch_last
expr_stmt|;
name|head
operator|=
name|head
operator|->
name|frch_next
expr_stmt|;
block|}
name|prev_frag
operator|->
name|fr_next
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|extern
name|void
name|DEFUN_VOID
parameter_list|(
name|write_object_file
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|frchain
modifier|*
name|frchain_ptr
decl_stmt|;
name|struct
name|internal_filehdr
name|filehdr
decl_stmt|;
name|struct
name|internal_aouthdr
name|aouthdr
decl_stmt|;
name|unsigned
name|long
name|file_cursor
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|addr
init|=
literal|0
decl_stmt|;
name|abfd
operator|=
name|bfd_openw
argument_list|(
name|out_file_name
argument_list|,
name|TARGET_FORMAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|==
literal|0
condition|)
block|{
name|as_perror
argument_list|(
literal|"FATAL: Can't create %s"
argument_list|,
name|out_file_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|42
argument_list|)
expr_stmt|;
block|}
name|bfd_set_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
expr_stmt|;
name|bfd_set_arch_mach
argument_list|(
name|abfd
argument_list|,
name|BFD_ARCH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|string_byte_count
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|frchain_ptr
operator|=
name|frchain_root
init|;
name|frchain_ptr
operator|!=
operator|(
expr|struct
name|frchain
operator|*
operator|)
name|NULL
condition|;
name|frchain_ptr
operator|=
name|frchain_ptr
operator|->
name|frch_next
control|)
block|{
comment|/* Run through all the sub-segments and align them up. Also close any 		   open frags. We tack a .fill onto the end of the frag chain so 		   that any .align's size can be worked by looking at the next 		   frag */
name|subseg_new
argument_list|(
name|frchain_ptr
operator|->
name|frch_seg
argument_list|,
name|frchain_ptr
operator|->
name|frch_subseg
argument_list|)
expr_stmt|;
define|#
directive|define
name|SUB_SEGMENT_ALIGN
value|1
name|frag_align
argument_list|(
name|SUB_SEGMENT_ALIGN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_now
operator|->
name|fr_fix
operator|=
literal|0
expr_stmt|;
name|know
argument_list|(
name|frag_now
operator|->
name|fr_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
name|remove_subsegs
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|SEG_E0
init|;
name|i
operator|<
name|SEG_UNKNOWN
condition|;
name|i
operator|++
control|)
block|{
name|relax_segment
argument_list|(
name|segment_info
index|[
name|i
index|]
operator|.
name|frchainP
operator|->
name|frch_root
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|filehdr
operator|.
name|f_nscns
operator|=
literal|0
expr_stmt|;
comment|/* Find out how big the sections are */
for|for
control|(
name|i
operator|=
name|SEG_E0
init|;
name|i
operator|<
name|SEG_UNKNOWN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_name
index|[
literal|0
index|]
condition|)
block|{
name|filehdr
operator|.
name|f_nscns
operator|++
expr_stmt|;
block|}
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_paddr
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|SEG_E2
condition|)
block|{
comment|/* THis is a special case, we leave the size alone, which will have */
comment|/* been made up from all and any lcomms seen */
block|}
else|else
block|{
name|addr
operator|+=
name|size_section
argument_list|(
name|abfd
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Turn the gas native symbol table shape into a coff symbol table */
name|crawl_symbols
argument_list|(
operator|&
name|filehdr
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|TC_H8300
for|for
control|(
name|i
operator|=
name|SEG_E0
init|;
name|i
operator|<
name|SEG_UNKNOWN
condition|;
name|i
operator|++
control|)
block|{
name|fixup_segment
argument_list|(
name|segment_info
index|[
name|i
index|]
operator|.
name|fix_root
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|file_cursor
operator|=
name|FILHSZ
operator|+
name|SCNHSZ
operator|*
name|filehdr
operator|.
name|f_nscns
expr_stmt|;
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|file_cursor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_relocs_for
argument_list|(
name|abfd
argument_list|,
operator|&
name|file_cursor
argument_list|)
expr_stmt|;
name|do_linenos_for
argument_list|(
name|abfd
argument_list|,
operator|&
name|file_cursor
argument_list|)
expr_stmt|;
comment|/* Plant the data */
name|fill_section
argument_list|(
name|abfd
argument_list|,
operator|&
name|filehdr
argument_list|,
operator|&
name|file_cursor
argument_list|)
expr_stmt|;
name|filehdr
operator|.
name|f_magic
operator|=
name|COFF_MAGIC
expr_stmt|;
name|filehdr
operator|.
name|f_timdat
operator|=
literal|0
expr_stmt|;
name|filehdr
operator|.
name|f_flags
operator|=
literal|0
expr_stmt|;
block|{
name|unsigned
name|int
name|symtable_size
init|=
name|filehdr
operator|.
name|f_nsyms
operator|*
name|SYMESZ
decl_stmt|;
name|char
modifier|*
name|buffer1
init|=
name|malloc
argument_list|(
name|symtable_size
operator|+
name|string_byte_count
operator|+
literal|4
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
name|buffer1
decl_stmt|;
name|filehdr
operator|.
name|f_symptr
operator|=
name|bfd_tell
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|w_symbols
argument_list|(
name|abfd
argument_list|,
name|buffer1
argument_list|,
name|symbol_rootP
argument_list|)
expr_stmt|;
name|w_strings
argument_list|(
name|buffer1
operator|+
name|symtable_size
argument_list|)
expr_stmt|;
name|bfd_write
argument_list|(
name|buffer1
argument_list|,
literal|1
argument_list|,
name|symtable_size
operator|+
name|string_byte_count
operator|+
literal|4
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer1
argument_list|)
expr_stmt|;
block|}
name|coff_header_append
argument_list|(
name|abfd
argument_list|,
operator|&
name|filehdr
argument_list|,
operator|&
name|aouthdr
argument_list|)
expr_stmt|;
name|bfd_close_all_done
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|change_to_section
argument_list|,
operator|(
name|name
operator|,
name|len
operator|,
name|exp
operator|)
argument_list|,
name|char
operator|*
name|name
name|AND
name|unsigned
name|int
name|len
name|AND
name|unsigned
name|int
name|exp
argument_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Find out if we've already got a section of this name etc */
for|for
control|(
name|i
operator|=
name|SEG_E0
init|;
name|i
operator|<
name|SEG_E9
operator|&&
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_name
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|subseg_new
argument_list|(
name|i
argument_list|,
name|exp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* No section, add one */
name|strncpy
argument_list|(
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_name
argument_list|,
name|name
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|subseg_new
argument_list|(
name|i
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|DEFUN_VOID
parameter_list|(
name|obj_coff_section
parameter_list|)
block|{
comment|/* Strip out the section name */
name|char
modifier|*
name|section_name
decl_stmt|;
name|char
modifier|*
name|section_name_end
decl_stmt|;
name|char
name|c
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
name|unsigned
name|int
name|exp
decl_stmt|;
name|section_name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|section_name_end
operator|=
name|input_line_pointer
expr_stmt|;
name|len
operator|=
name|section_name_end
operator|-
name|section_name
expr_stmt|;
name|input_line_pointer
operator|++
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|','
condition|)
block|{
name|exp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
name|input_line_pointer
operator|++
expr_stmt|;
name|exp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|exp
operator|=
literal|0
expr_stmt|;
block|}
name|change_to_section
argument_list|(
name|section_name
argument_list|,
name|len
argument_list|,
name|exp
argument_list|)
expr_stmt|;
operator|*
name|section_name_end
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_text
parameter_list|()
block|{
name|change_to_section
argument_list|(
literal|".text"
argument_list|,
literal|5
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|obj_coff_data
parameter_list|()
block|{
name|change_to_section
argument_list|(
literal|".data"
argument_list|,
literal|5
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|c_symbol_merge
parameter_list|(
name|debug
parameter_list|,
name|normal
parameter_list|)
name|symbolS
modifier|*
name|debug
decl_stmt|;
name|symbolS
modifier|*
name|normal
decl_stmt|;
block|{
name|S_SET_DATA_TYPE
argument_list|(
name|normal
argument_list|,
name|S_GET_DATA_TYPE
argument_list|(
name|debug
argument_list|)
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|normal
argument_list|,
name|S_GET_STORAGE_CLASS
argument_list|(
name|debug
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|debug
argument_list|)
operator|>
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|normal
argument_list|)
condition|)
block|{
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|normal
argument_list|,
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|debug
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* take the most we have */
if|if
condition|(
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|debug
argument_list|)
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|normal
operator|->
name|sy_symbol
operator|.
name|ost_auxent
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug
operator|->
name|sy_symbol
operator|.
name|ost_auxent
index|[
literal|0
index|]
argument_list|,
name|S_GET_NUMBER_AUXILIARY
argument_list|(
name|debug
argument_list|)
operator|*
name|AUXESZ
argument_list|)
expr_stmt|;
block|}
comment|/* Move all the auxiliary information */
comment|/* Move the debug flags. */
name|SF_SET_DEBUG_FIELD
argument_list|(
name|normal
argument_list|,
name|SF_GET_DEBUG_FIELD
argument_list|(
name|debug
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* c_symbol_merge() */
end_comment

begin_decl_stmt
specifier|static
name|int
name|DEFUN
argument_list|(
name|c_line_new
argument_list|,
operator|(
name|symbol
operator|,
name|paddr
operator|,
name|line_number
operator|,
name|frag
operator|)
argument_list|,
name|symbolS
operator|*
name|symbol
name|AND
name|long
name|paddr
name|AND
name|unsigned
name|short
name|line_number
name|AND
name|fragS
operator|*
name|frag
argument_list|)
block|{
name|struct
name|lineno_list
modifier|*
name|new_line
init|=
operator|(
expr|struct
name|lineno_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lineno_list
argument_list|)
argument_list|)
decl_stmt|;
name|segment_info_type
modifier|*
name|s
init|=
name|segment_info
operator|+
name|now_seg
decl_stmt|;
name|new_line
operator|->
name|line
operator|.
name|l_lnno
operator|=
name|line_number
expr_stmt|;
if|if
condition|(
name|line_number
operator|==
literal|0
condition|)
block|{
name|new_line
operator|->
name|line
operator|.
name|l_addr
operator|.
name|l_symndx
operator|=
operator|(
name|long
operator|)
name|symbol
expr_stmt|;
block|}
else|else
block|{
name|new_line
operator|->
name|line
operator|.
name|l_addr
operator|.
name|l_paddr
operator|=
name|paddr
expr_stmt|;
block|}
name|new_line
operator|->
name|frag
operator|=
operator|(
name|char
operator|*
operator|)
name|frag
expr_stmt|;
name|new_line
operator|->
name|next
operator|=
operator|(
expr|struct
name|lineno_list
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|lineno_list_head
operator|==
operator|(
expr|struct
name|lineno_list
operator|*
operator|)
name|NULL
condition|)
block|{
name|s
operator|->
name|lineno_list_head
operator|=
name|new_line
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|lineno_list_tail
operator|->
name|next
operator|=
name|new_line
expr_stmt|;
block|}
name|s
operator|->
name|lineno_list_tail
operator|=
name|new_line
expr_stmt|;
return|return
name|LINESZ
operator|*
name|s
operator|->
name|scnhdr
operator|.
name|s_nlnno
operator|++
return|;
block|}
end_decl_stmt

begin_function
name|void
name|c_dot_file_symbol
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolP
operator|=
name|symbol_new
argument_list|(
literal|".file"
argument_list|,
name|SEG_DEBUG
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_FILE
argument_list|)
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SA_SET_FILE_FNAME
argument_list|(
name|symbolP
argument_list|,
name|filename
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_LISTING
block|{
specifier|extern
name|int
name|listing
decl_stmt|;
if|if
condition|(
name|listing
condition|)
block|{
name|listing_source_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|SF_SET_DEBUG
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
operator|(
name|long
operator|)
name|previous_file_symbol
argument_list|)
expr_stmt|;
name|previous_file_symbol
operator|=
name|symbolP
expr_stmt|;
comment|/* Make sure that the symbol is first on the symbol chain */
if|if
condition|(
name|symbol_rootP
operator|!=
name|symbolP
condition|)
block|{
if|if
condition|(
name|symbolP
operator|==
name|symbol_lastP
condition|)
block|{
name|symbol_lastP
operator|=
name|symbol_lastP
operator|->
name|sy_previous
expr_stmt|;
block|}
comment|/* if it was the last thing on the list */
name|symbol_remove
argument_list|(
name|symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_insert
argument_list|(
name|symbolP
argument_list|,
name|symbol_rootP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_rootP
operator|=
name|symbolP
expr_stmt|;
block|}
comment|/* if not first on the list */
block|}
end_function

begin_comment
comment|/* c_dot_file_symbol() */
end_comment

begin_comment
comment|/*  * Build a 'section static' symbol.  */
end_comment

begin_function
name|symbolS
modifier|*
name|c_section_symbol
parameter_list|(
name|name
parameter_list|,
name|idx
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|idx
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|name
argument_list|,
name|idx
argument_list|,
literal|0
argument_list|,
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_STAT
argument_list|)
expr_stmt|;
name|S_SET_NUMBER_AUXILIARY
argument_list|(
name|symbolP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SF_SET_STATICS
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
return|return
name|symbolP
return|;
block|}
end_function

begin_comment
comment|/* c_section_symbol() */
end_comment

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|w_symbols
argument_list|,
operator|(
name|abfd
operator|,
name|where
operator|,
name|symbol_rootP
operator|)
argument_list|,
name|bfd
operator|*
name|abfd
name|AND
name|char
operator|*
name|where
name|AND
name|symbolS
operator|*
name|symbol_rootP
argument_list|)
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* First fill in those values we have only just worked out */
for|for
control|(
name|i
operator|=
name|SEG_E0
init|;
name|i
operator|<
name|SEG_E9
condition|;
name|i
operator|++
control|)
block|{
name|symbolP
operator|=
name|segment_info
index|[
name|i
index|]
operator|.
name|dot
expr_stmt|;
if|if
condition|(
name|symbolP
condition|)
block|{
name|SA_SET_SCN_SCNLEN
argument_list|(
name|symbolP
argument_list|,
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_size
argument_list|)
expr_stmt|;
name|SA_SET_SCN_NRELOC
argument_list|(
name|symbolP
argument_list|,
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_nreloc
argument_list|)
expr_stmt|;
name|SA_SET_SCN_NLINNO
argument_list|(
name|symbolP
argument_list|,
name|segment_info
index|[
name|i
index|]
operator|.
name|scnhdr
operator|.
name|s_nlnno
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Emit all symbols left in the symbol chain. 	 */
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
comment|/* Used to save the offset of the name. It is used to point 		   to the string in memory but must be a file offset. */
specifier|register
name|char
modifier|*
name|temp
decl_stmt|;
name|tc_coff_symbol_emit_hook
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|temp
operator|=
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|SF_GET_STRING
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|S_SET_OFFSET
argument_list|(
name|symbolP
argument_list|,
name|symbolP
operator|->
name|sy_name_offset
argument_list|)
expr_stmt|;
name|S_SET_ZEROES
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_entry
operator|.
name|n_name
argument_list|,
literal|'\0'
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|symbolP
operator|->
name|sy_symbol
operator|.
name|ost_entry
operator|.
name|n_name
argument_list|,
name|temp
argument_list|,
name|SYMNMLEN
argument_list|)
expr_stmt|;
block|}
name|where
operator|=
name|symbol_to_chars
argument_list|(
name|abfd
argument_list|,
name|where
argument_list|,
name|symbolP
argument_list|)
expr_stmt|;
name|S_SET_NAME
argument_list|(
name|symbolP
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* w_symbols() */
end_comment

begin_function
specifier|static
name|void
name|DEFUN_VOID
parameter_list|(
name|obj_coff_lcomm
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected comma after name"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Missing size expression"
argument_list|)
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|=
name|get_absolute_expression
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"lcomm length (%d.)<0! Ignored."
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|segment_info
index|[
name|SEG_E2
index|]
operator|.
name|scnhdr
operator|.
name|s_size
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|SEG_E2
argument_list|)
expr_stmt|;
name|segment_info
index|[
name|SEG_E2
index|]
operator|.
name|scnhdr
operator|.
name|s_size
operator|+=
name|temp
expr_stmt|;
name|S_SET_STORAGE_CLASS
argument_list|(
name|symbolP
argument_list|,
name|C_STAT
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|1
end_if

begin_decl_stmt
specifier|static
name|void
name|DEFUN
argument_list|(
name|fixup_segment
argument_list|,
operator|(
name|fixP
operator|,
name|this_segment_type
operator|)
argument_list|,
specifier|register
name|fixS
operator|*
name|fixP
name|AND
name|segT
name|this_segment_type
argument_list|)
block|{
specifier|register
name|symbolS
modifier|*
name|add_symbolP
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|sub_symbolP
decl_stmt|;
specifier|register
name|long
name|add_number
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
specifier|register
name|char
modifier|*
name|place
decl_stmt|;
specifier|register
name|long
name|where
decl_stmt|;
specifier|register
name|char
name|pcrel
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
specifier|register
name|segT
name|add_symbol_segment
init|=
name|SEG_ABSOLUTE
decl_stmt|;
for|for
control|(
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
block|{
name|fragP
operator|=
name|fixP
operator|->
name|fx_frag
expr_stmt|;
name|know
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
name|where
operator|=
name|fixP
operator|->
name|fx_where
expr_stmt|;
name|place
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|where
expr_stmt|;
name|size
operator|=
name|fixP
operator|->
name|fx_size
expr_stmt|;
name|add_symbolP
operator|=
name|fixP
operator|->
name|fx_addsy
expr_stmt|;
ifdef|#
directive|ifdef
name|TC_I960
if|if
condition|(
name|fixP
operator|->
name|fx_callj
operator|&&
name|TC_S_IS_CALLNAME
argument_list|(
name|add_symbolP
argument_list|)
condition|)
block|{
comment|/* Relocation should be done via the 			       associated 'bal' entry point 			       symbol. */
if|if
condition|(
operator|!
name|TC_S_IS_BALNAME
argument_list|(
name|tc_get_bal_of_call
argument_list|(
name|add_symbolP
argument_list|)
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"No 'bal' entry point for leafproc %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|add_symbolP
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fixP
operator|->
name|fx_addsy
operator|=
name|add_symbolP
operator|=
name|tc_get_bal_of_call
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
block|}
comment|/* callj relocation */
endif|#
directive|endif
name|sub_symbolP
operator|=
name|fixP
operator|->
name|fx_subsy
expr_stmt|;
name|add_number
operator|=
name|fixP
operator|->
name|fx_offset
expr_stmt|;
name|pcrel
operator|=
name|fixP
operator|->
name|fx_pcrel
expr_stmt|;
if|if
condition|(
name|add_symbolP
condition|)
block|{
name|add_symbol_segment
operator|=
name|S_GET_SEGMENT
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
block|}
comment|/* if there is an addend */
if|if
condition|(
name|sub_symbolP
condition|)
block|{
if|if
condition|(
operator|!
name|add_symbolP
condition|)
block|{
comment|/* Its just -sym */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|sub_symbolP
argument_list|)
operator|!=
name|SEG_ABSOLUTE
condition|)
block|{
name|as_bad
argument_list|(
literal|"Negative of non-absolute symbol %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|sub_symbolP
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* not absolute */
name|add_number
operator|-=
name|S_GET_VALUE
argument_list|(
name|sub_symbolP
argument_list|)
expr_stmt|;
comment|/* if sub_symbol is in the same segment that add_symbol 				       and add_symbol is either in DATA, TEXT, BSS or ABSOLUTE */
block|}
elseif|else
if|if
condition|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|sub_symbolP
argument_list|)
operator|==
name|add_symbol_segment
operator|)
operator|&&
operator|(
name|SEG_NORMAL
argument_list|(
name|add_symbol_segment
argument_list|)
operator|||
operator|(
name|add_symbol_segment
operator|==
name|SEG_ABSOLUTE
operator|)
operator|)
condition|)
block|{
comment|/* Difference of 2 symbols from same segment. */
comment|/* Can't make difference of 2 undefineds: 'value' means */
comment|/* something different for N_UNDF. */
ifdef|#
directive|ifdef
name|TC_I960
comment|/* Makes no sense to use the difference of 2 arbitrary symbols 				     * as the target of a call instruction. 				     */
if|if
condition|(
name|fixP
operator|->
name|fx_callj
condition|)
block|{
name|as_bad
argument_list|(
literal|"callj to difference of 2 symbols"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TC_I960 */
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|sub_symbolP
argument_list|)
expr_stmt|;
name|add_symbolP
operator|=
name|NULL
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Different segments in subtraction. */
name|know
argument_list|(
operator|!
operator|(
name|S_IS_EXTERNAL
argument_list|(
name|sub_symbolP
argument_list|)
operator|&&
operator|(
name|S_GET_SEGMENT
argument_list|(
name|sub_symbolP
argument_list|)
operator|==
name|SEG_ABSOLUTE
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|sub_symbolP
argument_list|)
operator|==
name|SEG_ABSOLUTE
operator|)
condition|)
block|{
name|add_number
operator|-=
name|S_GET_VALUE
argument_list|(
name|sub_symbolP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|"Can't emit reloc {- %s-seg symbol \"%s\"} @ file address %d."
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|sub_symbolP
argument_list|)
argument_list|)
argument_list|,
name|S_GET_NAME
argument_list|(
name|sub_symbolP
argument_list|)
argument_list|,
name|fragP
operator|->
name|fr_address
operator|+
name|where
argument_list|)
expr_stmt|;
block|}
comment|/* if absolute */
block|}
block|}
comment|/* if sub_symbolP */
if|if
condition|(
name|add_symbolP
condition|)
block|{
if|if
condition|(
name|add_symbol_segment
operator|==
name|this_segment_type
operator|&&
name|pcrel
condition|)
block|{
comment|/* 				     * This fixup was made when the symbol's segment was 				     * SEG_UNKNOWN, but it is now in the local segment. 				     * So we know how to do the address without relocation. 				     */
ifdef|#
directive|ifdef
name|TC_I960
comment|/* reloc_callj() may replace a 'call' with a 'calls' or a 'bal', 				     * in which cases it modifies *fixP as appropriate.  In the case 				     * of a 'calls', no further work is required, and *fixP has been 				     * set up to make the rest of the code below a no-op. 				     */
name|reloc_callj
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TC_I960 */
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
name|add_number
operator|-=
name|md_pcrel_from
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
name|pcrel
operator|=
literal|0
expr_stmt|;
comment|/* Lie. Don't want further pcrel processing. */
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
comment|/* No relocations please. */
block|}
else|else
block|{
switch|switch
condition|(
name|add_symbol_segment
condition|)
block|{
case|case
name|SEG_ABSOLUTE
case|:
ifdef|#
directive|ifdef
name|TC_I960
name|reloc_callj
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
comment|/* See comment about reloc_callj() above*/
endif|#
directive|endif
comment|/* TC_I960 */
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
name|add_symbolP
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|add_number
operator|+=
name|S_GET_VALUE
argument_list|(
name|add_symbolP
argument_list|)
operator|+
name|segment_info
index|[
name|S_GET_SEGMENT
argument_list|(
name|add_symbolP
argument_list|)
index|]
operator|.
name|scnhdr
operator|.
name|s_paddr
expr_stmt|;
break|break;
case|case
name|SEG_UNKNOWN
case|:
ifdef|#
directive|ifdef
name|TC_I960
if|if
condition|(
operator|(
name|int
operator|)
name|fixP
operator|->
name|fx_bit_fixP
operator|==
literal|13
condition|)
block|{
comment|/* This is a COBR instruction.  They have only a 							     * 13-bit displacement and are only to be used 							     * for local branches: flag as error, don't generate 							     * relocation. 							     */
name|as_bad
argument_list|(
literal|"can't use COBR format with external label"
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|NULL
expr_stmt|;
comment|/* No relocations please. */
continue|continue;
block|}
comment|/* COBR */
endif|#
directive|endif
comment|/* TC_I960 */
break|break;
block|}
comment|/* switch on symbol seg */
block|}
comment|/* if not in local seg */
block|}
comment|/* if there was a + symbol */
if|if
condition|(
name|pcrel
condition|)
block|{
name|add_number
operator|-=
name|md_pcrel_from
argument_list|(
name|fixP
argument_list|)
expr_stmt|;
if|if
condition|(
name|add_symbolP
operator|==
literal|0
condition|)
block|{
name|fixP
operator|->
name|fx_addsy
operator|=
operator|&
name|abs_symbol
expr_stmt|;
block|}
comment|/* if there's an add_symbol */
block|}
comment|/* if pcrel */
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_bit_fixP
condition|)
block|{
if|if
condition|(
operator|(
name|size
operator|==
literal|1
operator|&&
operator|(
name|add_number
operator|&
operator|~
literal|0xFF
operator|)
operator|&&
operator|(
name|add_number
operator|&
operator|~
literal|0xFF
operator|!=
operator|(
operator|-
literal|1
operator|&
operator|~
literal|0xFF
operator|)
operator|)
operator|)
operator|||
operator|(
name|size
operator|==
literal|2
operator|&&
operator|(
name|add_number
operator|&
operator|~
literal|0xFFFF
operator|)
operator|&&
operator|(
name|add_number
operator|&
operator|~
literal|0xFFFF
operator|!=
operator|(
operator|-
literal|1
operator|&
operator|~
literal|0xFFFF
operator|)
operator|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Value of %d too large for field of %d bytes at 0x%x"
argument_list|,
name|add_number
argument_list|,
name|size
argument_list|,
name|fragP
operator|->
name|fr_address
operator|+
name|where
argument_list|)
expr_stmt|;
block|}
comment|/* generic error checking */
block|}
comment|/* not a bit fix */
comment|/* once this fix has been applied, we don't have to output anything  		       nothing more need be done -*/
name|md_apply_fix
argument_list|(
name|fixP
argument_list|,
name|add_number
argument_list|)
expr_stmt|;
block|}
comment|/* For each fixS in this segment. */
block|}
end_decl_stmt

begin_comment
comment|/* fixup_segment() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Local Variables:  * fill-column: 131  * End:  */
end_comment

begin_comment
comment|/* end of obj-coffbfd.c */
end_comment

end_unit

