begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-vax.c - vax-specific -    Copyright (C) 1987, 1991, 1992 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* JF I moved almost all the vax specific stuff into this one file 'cuz RMS    seems to think its a good idea.  I hope I managed to get all the VAX-isms */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"read.h"
end_include

begin_include
include|#
directive|include
file|"vax-inst.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* For FRAG_APPEND_1_CHAR macro in "frags.h" */
end_comment

begin_comment
comment|/* These chars start a comment anywhere in a source file (except inside    another comment */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These chars only start a comment at the beginning of a line. */
end_comment

begin_comment
comment|/* Note that for the VAX the are the same as comment_chars above. */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant */
end_comment

begin_comment
comment|/* as in 0f123.456 */
end_comment

begin_comment
comment|/* or    0H1.234E-12 (see exp chars above) */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"dDfFgGhH"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be    changed in read.c. Ideally it shouldn't have to know about it at all,    but nothing is ideal around here.    */
end_comment

begin_decl_stmt
specifier|static
name|expressionS
comment|/* Hold details of an operand expression */
name|exp_of_operand
index|[
name|VIT_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vit
name|v
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A vax instruction after decoding. */
end_comment

begin_decl_stmt
name|LITTLENUM_TYPE
name|big_operand_bits
index|[
name|VIT_MAX_OPERANDS
index|]
index|[
name|SIZE_OF_LARGE_NUMBER
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hold details of big operands. */
end_comment

begin_decl_stmt
name|FLONUM_TYPE
name|float_operand
index|[
name|VIT_MAX_OPERANDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Above is made to point into */
end_comment

begin_comment
comment|/* big_operand_bits by md_begin(). */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * For VAX, relative addresses of "just the right length" are easy.  * The branch displacement is always the last operand, even in  * synthetic instructions.  * For VAX, we encode the relax_substateTs (in e.g. fr_substate) as:  *  *		    4       3       2       1       0	     bit number  *	---/ /--+-------+-------+-------+-------+-------+  *		|     what state ?	|  how long ?	|  *	---/ /--+-------+-------+-------+-------+-------+  *  * The "how long" bits are 00=byte, 01=word, 10=long.  * This is a Un*x convention.  * Not all lengths are legit for a given value of (what state).  * The "how long" refers merely to the displacement length.  * The address usually has some constant bytes in it as well.  *   groups for VAX address relaxing.   1.	"foo" pc-relative.  length of byte, word, long   2a.	J<cond> where<cond> is a simple flag test.  length of byte, word, long.  VAX opcodes are:	(Hex)  bneq/bnequ	12  beql/beqlu	13  bgtr		14  bleq		15  bgeq		18  blss		19  bgtru		1a  blequ		1b  bvc		1c  bvs		1d  bgequ/bcc	1e  blssu/bcs	1f  Always, you complement 0th bit to reverse condition.  Always, 1-byte opcode, then 1-byte displacement.   2b.	J<cond> where cond tests a memory bit.  length of byte, word, long.  Vax opcodes are:	(Hex)  bbs		e0  bbc		e1  bbss		e2  bbcs		e3  bbsc		e4  bbcc		e5  bbssi		e6  bbcci		e7  Always, you complement 0th bit to reverse condition.  Always, 1-byte opcde, longword-address, byte-address, 1-byte-displacement   2c.	J<cond> where cond tests low-order memory bit  length of byte,word,long.  Vax opcodes are:	(Hex)  blbs		e8  blbc		e9  Always, you complement 0th bit to reverse condition.  Always, 1-byte opcode, longword-address, 1-byte displacement.   3.	Jbs/Jbr.  length of byte,word,long.  Vax opcodes are:	(Hex)  bsbb		10  brb		11  These are like (2) but there is no condition to reverse.  Always, 1 byte opcode, then displacement/absolute.   4a.	JacbX  length of word, long.  Vax opcodes are:	(Hex)  acbw		3d  acbf		4f  acbd		6f  abcb		9d  acbl		f1  acbg	      4ffd  acbh	      6ffd  Always, we cannot reverse the sense of the branch; we have a word  displacement.  The double-byte op-codes don't hurt: we never want to modify the  opcode, so we don't care how many bytes are between the opcode and  the operand.   4b.	JXobXXX  length of long, long, byte.  Vax opcodes are:	(Hex)  aoblss		f2  aobleq		f3  sobgeq		f4  sobgtr		f5  Always, we cannot reverse the sense of the branch; we have a byte  displacement.   The only time we need to modify the opcode is for class 2 instructions.  After relax() we may complement the lowest order bit of such instruction  to reverse sense of branch.   For class 2 instructions, we store context of "where is the opcode literal".  We can change an opcode's lowest order bit without breaking anything else.   We sometimes store context in the operand literal. This way we can figure out  after relax() what the original addressing mode was.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/* These displacements are relative to */
end_comment

begin_comment
comment|/* the start address of the displacement. */
end_comment

begin_comment
comment|/* The first letter is Byte, Word. */
end_comment

begin_comment
comment|/* 2nd letter is Forward, Backward. */
end_comment

begin_define
define|#
directive|define
name|BF
value|(1+ 127)
end_define

begin_define
define|#
directive|define
name|BB
value|(1+-128)
end_define

begin_define
define|#
directive|define
name|WF
value|(2+ 32767)
end_define

begin_define
define|#
directive|define
name|WB
value|(2+-32768)
end_define

begin_comment
comment|/* Dont need LF, LB because they always */
end_comment

begin_comment
comment|/* reach. [They are coded as 0.] */
end_comment

begin_define
define|#
directive|define
name|C
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|ENCODE_RELAX(a,b)
end_define

begin_comment
comment|/* This macro has no side-effects. */
end_comment

begin_define
define|#
directive|define
name|ENCODE_RELAX
parameter_list|(
name|what
parameter_list|,
name|length
parameter_list|)
value|(((what)<< 2) + (length))
end_define

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* error sentinel   0,0	*/
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    0,1	*/
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    0,2	*/
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    0,3	*/
block|{
name|BF
operator|+
literal|1
block|,
name|BB
operator|+
literal|1
block|,
literal|2
block|,
name|C
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
block|}
block|,
comment|/* B^"foo"	    1,0 */
block|{
name|WF
operator|+
literal|1
block|,
name|WB
operator|+
literal|1
block|,
literal|3
block|,
name|C
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
block|}
block|,
comment|/* W^"foo"	    1,1 */
block|{
literal|0
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|}
block|,
comment|/* L^"foo"	    1,2 */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    1,3 */
block|{
name|BF
block|,
name|BB
block|,
literal|1
block|,
name|C
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
block|}
block|,
comment|/* b<cond> B^"foo"  2,0 */
block|{
name|WF
operator|+
literal|2
block|,
name|WB
operator|+
literal|2
block|,
literal|4
block|,
name|C
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
block|}
block|,
comment|/* br.+? brw X	    2,1 */
block|{
literal|0
block|,
literal|0
block|,
literal|7
block|,
literal|0
block|}
block|,
comment|/* br.+? jmp X	    2,2 */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    2,3 */
block|{
name|BF
block|,
name|BB
block|,
literal|1
block|,
name|C
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
block|}
block|,
comment|/* brb B^foo	    3,0 */
block|{
name|WF
block|,
name|WB
block|,
literal|2
block|,
name|C
argument_list|(
literal|3
argument_list|,
literal|2
argument_list|)
block|}
block|,
comment|/* brw W^foo	    3,1 */
block|{
literal|0
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|}
block|,
comment|/* Jmp L^foo	    3,2 */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    3,3 */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    4,0 */
block|{
name|WF
block|,
name|WB
block|,
literal|2
block|,
name|C
argument_list|(
literal|4
argument_list|,
literal|2
argument_list|)
block|}
block|,
comment|/* acb_ ^Wfoo	    4,1 */
block|{
literal|0
block|,
literal|0
block|,
literal|10
block|,
literal|0
block|}
block|,
comment|/* acb_,br,jmp L^foo4,2 */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* unused	    4,3 */
block|{
name|BF
block|,
name|BB
block|,
literal|1
block|,
name|C
argument_list|(
literal|5
argument_list|,
literal|1
argument_list|)
block|}
block|,
comment|/* Xob___,,foo      5,0 */
block|{
name|WF
operator|+
literal|4
block|,
name|WB
operator|+
literal|4
block|,
literal|6
block|,
name|C
argument_list|(
literal|5
argument_list|,
literal|2
argument_list|)
block|}
block|,
comment|/* Xob.+2,brb.+3,brw5,1 */
block|{
literal|0
block|,
literal|0
block|,
literal|9
block|,
literal|0
block|}
block|,
comment|/* Xob.+2,brb.+6,jmp5,2 */
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|C
end_undef

begin_undef
undef|#
directive|undef
name|BF
end_undef

begin_undef
undef|#
directive|undef
name|BB
end_undef

begin_undef
undef|#
directive|undef
name|WF
end_undef

begin_undef
undef|#
directive|undef
name|WB
end_undef

begin_function_decl
name|void
name|float_cons
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"dfloat"
block|,
name|float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"ffloat"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"gfloat"
block|,
name|float_cons
block|,
literal|'g'
block|}
block|,
block|{
literal|"hfloat"
block|,
name|float_cons
block|,
literal|'h'
block|}
block|,
block|{
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|STATE_PC_RELATIVE
value|(1)
end_define

begin_define
define|#
directive|define
name|STATE_CONDITIONAL_BRANCH
value|(2)
end_define

begin_define
define|#
directive|define
name|STATE_ALWAYS_BRANCH
value|(3)
end_define

begin_comment
comment|/* includes BSB... */
end_comment

begin_define
define|#
directive|define
name|STATE_COMPLEX_BRANCH
value|(4)
end_define

begin_define
define|#
directive|define
name|STATE_COMPLEX_HOP
value|(5)
end_define

begin_define
define|#
directive|define
name|STATE_BYTE
value|(0)
end_define

begin_define
define|#
directive|define
name|STATE_WORD
value|(1)
end_define

begin_define
define|#
directive|define
name|STATE_LONG
value|(2)
end_define

begin_define
define|#
directive|define
name|STATE_UNDF
value|(3)
end_define

begin_comment
comment|/* Symbol undefined in pass1 */
end_comment

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_if
if|#
directive|if
name|__STDC__
operator|==
literal|1
end_if

begin_function_decl
name|int
name|flonum_gen2vax
parameter_list|(
name|char
name|format_letter
parameter_list|,
name|FLONUM_TYPE
modifier|*
name|f
parameter_list|,
name|LITTLENUM_TYPE
modifier|*
name|words
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vip_end
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vip_op_defaults
parameter_list|(
name|char
modifier|*
name|immediate
parameter_list|,
name|char
modifier|*
name|indirect
parameter_list|,
name|char
modifier|*
name|displen
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not __STDC__ */
end_comment

begin_function_decl
name|int
name|flonum_gen2vax
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vip_end
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vip_op_defaults
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __STDC__ */
end_comment

begin_function
name|void
name|md_begin
parameter_list|()
block|{
name|char
modifier|*
name|vip_begin
parameter_list|()
function_decl|;
name|char
modifier|*
name|errtxt
decl_stmt|;
name|FLONUM_TYPE
modifier|*
name|fP
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
operator|(
name|errtxt
operator|=
name|vip_begin
argument_list|(
literal|1
argument_list|,
literal|"$"
argument_list|,
literal|"*"
argument_list|,
literal|"`"
argument_list|)
operator|)
condition|)
block|{
name|as_fatal
argument_list|(
literal|"VIP_BEGIN error:%s"
argument_list|,
name|errtxt
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|fP
operator|=
name|float_operand
init|;
name|fP
operator|<
name|float_operand
operator|+
name|VIT_MAX_OPERANDS
condition|;
name|i
operator|++
operator|,
name|fP
operator|++
control|)
block|{
name|fP
operator|->
name|low
operator|=
operator|&
name|big_operand_bits
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
name|fP
operator|->
name|high
operator|=
operator|&
name|big_operand_bits
index|[
name|i
index|]
index|[
name|SIZE_OF_LARGE_NUMBER
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|md_end
parameter_list|()
block|{
name|vip_end
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
comment|/* Knows about order of bytes in address. */
name|md_number_to_chars
parameter_list|(
name|con
parameter_list|,
name|value
parameter_list|,
name|nbytes
parameter_list|)
name|char
name|con
index|[]
decl_stmt|;
comment|/* Return 'nbytes' of chars here. */
name|long
name|value
decl_stmt|;
comment|/* The value of the bits. */
name|int
name|nbytes
decl_stmt|;
comment|/* Number of bytes in the output. */
block|{
name|int
name|n
decl_stmt|;
name|long
name|v
decl_stmt|;
name|n
operator|=
name|nbytes
expr_stmt|;
name|v
operator|=
name|value
expr_stmt|;
while|while
condition|(
name|nbytes
operator|--
condition|)
block|{
operator|*
name|con
operator|++
operator|=
name|value
expr_stmt|;
comment|/* Lint wants& MASK_CHAR. */
name|value
operator|>>=
name|BITS_PER_CHAR
expr_stmt|;
block|}
comment|/* XXX line number probably botched for this warning message. */
if|if
condition|(
name|value
operator|!=
literal|0
operator|&&
name|value
operator|!=
operator|-
literal|1
condition|)
name|as_bad
argument_list|(
literal|"Displacement (%ld) long for instruction field length (%d)."
argument_list|,
name|v
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fix up some data or instructions after we find out the value of a symbol    that they reference.  */
end_comment

begin_function
name|void
comment|/* Knows about order of bytes in address. */
name|md_apply_fix
parameter_list|(
name|fixP
parameter_list|,
name|value
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/* Fixup struct pointer */
name|long
name|value
decl_stmt|;
comment|/* The value of the bits. */
block|{
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
comment|/* Number of bytes in the output. */
name|nbytes
operator|=
name|fixP
operator|->
name|fx_size
expr_stmt|;
while|while
condition|(
name|nbytes
operator|--
condition|)
block|{
operator|*
name|buf
operator|++
operator|=
name|value
expr_stmt|;
comment|/* Lint wants& MASK_CHAR. */
name|value
operator|>>=
name|BITS_PER_CHAR
expr_stmt|;
block|}
block|}
end_function

begin_function
name|long
comment|/* Knows about the byte order in a word. */
name|md_chars_to_number
parameter_list|(
name|con
parameter_list|,
name|nbytes
parameter_list|)
name|unsigned
name|char
name|con
index|[]
decl_stmt|;
comment|/* Low order byte 1st. */
name|int
name|nbytes
decl_stmt|;
comment|/* Number of bytes in the input. */
block|{
name|long
name|retval
decl_stmt|;
for|for
control|(
name|retval
operator|=
literal|0
operator|,
name|con
operator|+=
name|nbytes
operator|-
literal|1
init|;
name|nbytes
operator|--
condition|;
name|con
operator|--
control|)
block|{
name|retval
operator|<<=
name|BITS_PER_CHAR
expr_stmt|;
name|retval
operator||=
operator|*
name|con
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* vax:md_assemble() emit frags for 1 instruction */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|instruction_string
parameter_list|)
name|char
modifier|*
name|instruction_string
decl_stmt|;
comment|/* A string: assemble 1 instruction. */
block|{
comment|/* We saw no errors in any operands - try to make frag(s) */
name|int
name|is_undefined
decl_stmt|;
comment|/* 1 if operand expression's */
comment|/* segment not known yet. */
name|int
name|length_code
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|vop
modifier|*
name|operandP
decl_stmt|;
comment|/* An operand. Scans all operands. */
name|char
modifier|*
name|save_input_line_pointer
decl_stmt|;
name|char
name|c_save
decl_stmt|;
comment|/* What used to live after an expression. */
comment|/* fixme: unused? */
comment|/*	struct frag *fragP; */
comment|/* Fragment of code we just made. */
specifier|register
name|int
name|goofed
decl_stmt|;
comment|/* 1: instruction_string bad for all passes. */
specifier|register
name|struct
name|vop
modifier|*
name|end_operandP
decl_stmt|;
comment|/* -> slot just after last operand */
comment|/* Limit of the for (each operand). */
specifier|register
name|expressionS
modifier|*
name|expP
decl_stmt|;
comment|/* -> expression values for this operand */
comment|/* These refer to an instruction operand expression. */
name|segT
name|to_seg
decl_stmt|;
comment|/* Target segment of the address.	 */
specifier|register
name|valueT
name|this_add_number
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|this_add_symbol
decl_stmt|;
comment|/* +ve (minuend) symbol. */
specifier|register
name|struct
name|symbol
modifier|*
name|this_subtract_symbol
decl_stmt|;
comment|/* -ve(subtrahend) symbol. */
name|long
name|opcode_as_number
decl_stmt|;
comment|/* As a number. */
name|char
modifier|*
name|opcode_as_chars
decl_stmt|;
comment|/* Least significant byte 1st. */
comment|/* As an array of characters. */
name|char
modifier|*
name|opcode_low_byteP
decl_stmt|;
comment|/* Least significant byte 1st */
comment|/* richfix: unused? */
comment|/*	struct details *detP; */
comment|/* The details of an ADxxx frag. */
name|int
name|length
decl_stmt|;
comment|/* length (bytes) meant by vop_short. */
name|int
name|at
decl_stmt|;
comment|/* 0, or 1 if '@' is in addressing mode. */
name|int
name|nbytes
decl_stmt|;
comment|/* From vop_nbytes: vax_operand_width (in bytes) */
name|FLONUM_TYPE
modifier|*
name|floatP
decl_stmt|;
name|char
modifier|*
name|vip
parameter_list|()
function_decl|;
name|LITTLENUM_TYPE
name|literal_float
index|[
literal|8
index|]
decl_stmt|;
comment|/* Big enough for any floating point literal. */
if|if
condition|(
operator|*
operator|(
name|p
operator|=
name|vip
argument_list|(
operator|&
name|v
argument_list|,
name|instruction_string
argument_list|)
operator|)
condition|)
block|{
name|as_fatal
argument_list|(
literal|"vax_assemble\"%s\" in=\"%s\""
argument_list|,
name|p
argument_list|,
name|instruction_string
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now we try to find as many as_warn()s as we can. If we do any as_warn()s 	 * then goofed=1. Notice that we don't make any frags yet. 	 * Should goofed be 1, then this instruction will wedge in any pass, 	 * and we can safely flush it, without causing interpass symbol phase 	 * errors. That is, without changing label values in different passes. 	 */
if|if
condition|(
name|goofed
operator|=
operator|(
operator|*
name|v
operator|.
name|vit_error
operator|)
condition|)
block|{
name|as_warn
argument_list|(
literal|"Ignoring statement due to \"%s\""
argument_list|,
name|v
operator|.
name|vit_error
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We need to use expression() and friends, which require us to diddle 	 * input_line_pointer. So we save it and restore it later. 	 */
name|save_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
for|for
control|(
name|operandP
operator|=
name|v
operator|.
name|vit_operand
operator|,
name|expP
operator|=
name|exp_of_operand
operator|,
name|floatP
operator|=
name|float_operand
operator|,
name|end_operandP
operator|=
name|v
operator|.
name|vit_operand
operator|+
name|v
operator|.
name|vit_operands
init|;
name|operandP
operator|<
name|end_operandP
condition|;
name|operandP
operator|++
operator|,
name|expP
operator|++
operator|,
name|floatP
operator|++
control|)
block|{
comment|/* for each operand */
if|if
condition|(
operator|*
operator|(
name|operandP
operator|->
name|vop_error
operator|)
condition|)
block|{
name|as_warn
argument_list|(
literal|"Ignoring statement because \"%s\""
argument_list|,
operator|(
name|operandP
operator|->
name|vop_error
operator|)
argument_list|)
expr_stmt|;
name|goofed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* statement has no syntax goofs: lets sniff the expression */
name|int
name|can_be_short
init|=
literal|0
decl_stmt|;
comment|/* 1 if a bignum can be reduced to a short literal. */
name|input_line_pointer
operator|=
name|operandP
operator|->
name|vop_expr_begin
expr_stmt|;
name|c_save
operator|=
name|operandP
operator|->
name|vop_expr_end
index|[
literal|1
index|]
expr_stmt|;
name|operandP
operator|->
name|vop_expr_end
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If to_seg == SEG_PASS1, expression() will have set need_pass_2 = 1. */
switch|switch
condition|(
name|to_seg
operator|=
name|expression
argument_list|(
name|expP
argument_list|)
condition|)
block|{
case|case
name|SEG_ABSENT
case|:
comment|/* for BSD4.2 compatibility, missing expression is absolute 0 */
name|to_seg
operator|=
name|expP
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|expP
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
comment|/* for SEG_ABSOLUTE, we shouldnt need to set X_subtract_symbol, X_add_symbol to any 				   particular value. But, we will program defensively. Since this situation occurs rarely 				   so it costs us little to do, and stops Dean worrying about the origin of random bits in 				   expressionS's. */
name|expP
operator|->
name|X_add_symbol
operator|=
name|NULL
expr_stmt|;
name|expP
operator|->
name|X_subtract_symbol
operator|=
name|NULL
expr_stmt|;
case|case
name|SEG_TEXT
case|:
case|case
name|SEG_DATA
case|:
case|case
name|SEG_BSS
case|:
case|case
name|SEG_ABSOLUTE
case|:
case|case
name|SEG_UNKNOWN
case|:
break|break;
case|case
name|SEG_DIFFERENCE
case|:
case|case
name|SEG_PASS1
case|:
comment|/* 				 * Major bug. We can't handle the case of a 				 * SEG_DIFFERENCE expression in a VIT_OPCODE_SYNTHETIC 				 * variable-length instruction. 				 * We don't have a frag type that is smart enough to 				 * relax a SEG_DIFFERENCE, and so we just force all 				 * SEG_DIFFERENCEs to behave like SEG_PASS1s. 				 * Clearly, if there is a demand we can invent a new or 				 * modified frag type and then coding up a frag for this 				 * case will be easy. SEG_DIFFERENCE was invented for the 				 * .words after a CASE opcode, and was never intended for 				 * instruction operands. 				 */
name|need_pass_2
operator|=
literal|1
expr_stmt|;
name|as_warn
argument_list|(
literal|"Can't relocate expression"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEG_BIG
case|:
comment|/* Preserve the bits. */
if|if
condition|(
name|expP
operator|->
name|X_add_number
operator|>
literal|0
condition|)
block|{
name|bignum_copy
argument_list|(
name|generic_bignum
argument_list|,
name|expP
operator|->
name|X_add_number
argument_list|,
name|floatP
operator|->
name|low
argument_list|,
name|SIZE_OF_LARGE_NUMBER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|know
argument_list|(
name|expP
operator|->
name|X_add_number
operator|<
literal|0
argument_list|)
expr_stmt|;
name|flonum_copy
argument_list|(
operator|&
name|generic_floating_point_number
argument_list|,
name|floatP
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"s i"
argument_list|,
name|operandP
operator|->
name|vop_short
argument_list|)
condition|)
block|{
comment|/* Could possibly become S^# */
name|flonum_gen2vax
argument_list|(
operator|-
name|expP
operator|->
name|X_add_number
argument_list|,
name|floatP
argument_list|,
name|literal_float
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|-
name|expP
operator|->
name|X_add_number
condition|)
block|{
case|case
literal|'f'
case|:
name|can_be_short
operator|=
operator|(
name|literal_float
index|[
literal|0
index|]
operator|&
literal|0xFC0F
operator|)
operator|==
literal|0x4000
operator|&&
name|literal_float
index|[
literal|1
index|]
operator|==
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|can_be_short
operator|=
operator|(
name|literal_float
index|[
literal|0
index|]
operator|&
literal|0xFC0F
operator|)
operator|==
literal|0x4000
operator|&&
name|literal_float
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|literal_float
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|literal_float
index|[
literal|3
index|]
operator|==
literal|0
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|can_be_short
operator|=
operator|(
name|literal_float
index|[
literal|0
index|]
operator|&
literal|0xFF81
operator|)
operator|==
literal|0x4000
operator|&&
name|literal_float
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|literal_float
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|literal_float
index|[
literal|3
index|]
operator|==
literal|0
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|can_be_short
operator|=
operator|(
operator|(
name|literal_float
index|[
literal|0
index|]
operator|&
literal|0xFFF8
operator|)
operator|==
literal|0x4000
operator|&&
operator|(
name|literal_float
index|[
literal|1
index|]
operator|&
literal|0xE000
operator|)
operator|==
literal|0
operator|&&
name|literal_float
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|literal_float
index|[
literal|3
index|]
operator|==
literal|0
operator|&&
name|literal_float
index|[
literal|4
index|]
operator|==
literal|0
operator|&&
name|literal_float
index|[
literal|5
index|]
operator|==
literal|0
operator|&&
name|literal_float
index|[
literal|6
index|]
operator|==
literal|0
operator|&&
name|literal_float
index|[
literal|7
index|]
operator|==
literal|0
operator|)
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
operator|-
name|expP
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch (float type) */
block|}
comment|/* if (could want to become S^#...) */
block|}
comment|/* bignum or flonum ? */
if|if
condition|(
name|operandP
operator|->
name|vop_short
operator|==
literal|'s'
operator|||
name|operandP
operator|->
name|vop_short
operator|==
literal|'i'
operator|||
operator|(
name|operandP
operator|->
name|vop_short
operator|==
literal|' '
operator|&&
name|operandP
operator|->
name|vop_reg
operator|==
literal|0xF
operator|&&
operator|(
name|operandP
operator|->
name|vop_mode
operator|&
literal|0xE
operator|)
operator|==
literal|0x8
operator|)
condition|)
block|{
comment|/* Saw a '#'. */
if|if
condition|(
name|operandP
operator|->
name|vop_short
operator|==
literal|' '
condition|)
block|{
comment|/* We must chose S^ or I^. */
if|if
condition|(
name|expP
operator|->
name|X_add_number
operator|>
literal|0
condition|)
block|{
comment|/* Bignum: Short literal impossible. */
name|operandP
operator|->
name|vop_short
operator|=
literal|'i'
expr_stmt|;
name|operandP
operator|->
name|vop_mode
operator|=
literal|8
expr_stmt|;
name|operandP
operator|->
name|vop_reg
operator|=
literal|0xF
expr_stmt|;
comment|/* VAX PC. */
block|}
else|else
block|{
comment|/* Flonum: Try to do it. */
if|if
condition|(
name|can_be_short
condition|)
block|{
name|operandP
operator|->
name|vop_short
operator|=
literal|'s'
expr_stmt|;
name|operandP
operator|->
name|vop_mode
operator|=
literal|0
expr_stmt|;
name|operandP
operator|->
name|vop_ndx
operator|=
operator|-
literal|1
expr_stmt|;
name|operandP
operator|->
name|vop_reg
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* JF hope this is the right thing */
name|expP
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
block|}
else|else
block|{
name|operandP
operator|->
name|vop_short
operator|=
literal|'i'
expr_stmt|;
name|operandP
operator|->
name|vop_mode
operator|=
literal|8
expr_stmt|;
name|operandP
operator|->
name|vop_reg
operator|=
literal|0xF
expr_stmt|;
comment|/* VAX PC */
block|}
block|}
comment|/* bignum or flonum ? */
block|}
comment|/*  if #, but no S^ or I^ seen. */
comment|/* No more ' ' case: either 's' or 'i'. */
if|if
condition|(
name|operandP
operator|->
name|vop_short
operator|==
literal|'s'
condition|)
block|{
comment|/* Wants to be a short literal. */
if|if
condition|(
name|expP
operator|->
name|X_add_number
operator|>
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"Bignum not permitted in short literal. Immediate mode assumed."
argument_list|)
expr_stmt|;
name|operandP
operator|->
name|vop_short
operator|=
literal|'i'
expr_stmt|;
name|operandP
operator|->
name|vop_mode
operator|=
literal|8
expr_stmt|;
name|operandP
operator|->
name|vop_reg
operator|=
literal|0xF
expr_stmt|;
comment|/* VAX PC. */
block|}
else|else
block|{
if|if
condition|(
operator|!
name|can_be_short
condition|)
block|{
name|as_warn
argument_list|(
literal|"Can't do flonum short literal: immediate mode used."
argument_list|)
expr_stmt|;
name|operandP
operator|->
name|vop_short
operator|=
literal|'i'
expr_stmt|;
name|operandP
operator|->
name|vop_mode
operator|=
literal|8
expr_stmt|;
name|operandP
operator|->
name|vop_reg
operator|=
literal|0xF
expr_stmt|;
comment|/* VAX PC. */
block|}
else|else
block|{
comment|/* Encode short literal now. */
name|int
name|temp
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
operator|-
name|expP
operator|->
name|X_add_number
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'d'
case|:
name|temp
operator|=
name|literal_float
index|[
literal|0
index|]
operator|>>
literal|4
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|temp
operator|=
name|literal_float
index|[
literal|0
index|]
operator|>>
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|temp
operator|=
operator|(
operator|(
name|literal_float
index|[
literal|0
index|]
operator|<<
literal|3
operator|)
operator|&
literal|070
operator|)
operator||
operator|(
operator|(
name|literal_float
index|[
literal|1
index|]
operator|>>
literal|13
operator|)
operator|&
literal|07
operator|)
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
operator|-
name|expP
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
break|break;
block|}
name|floatP
operator|->
name|low
index|[
literal|0
index|]
operator|=
name|temp
operator|&
literal|077
expr_stmt|;
name|floatP
operator|->
name|low
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if can be short literal float */
block|}
comment|/* flonum or bignum ? */
block|}
else|else
block|{
comment|/* I^# seen: set it up if float. */
if|if
condition|(
name|expP
operator|->
name|X_add_number
operator|<
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|floatP
operator|->
name|low
argument_list|,
name|literal_float
argument_list|,
sizeof|sizeof
argument_list|(
name|literal_float
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if S^# seen. */
block|}
else|else
block|{
name|as_warn
argument_list|(
literal|"A bignum/flonum may not be a displacement: 0x%x used"
argument_list|,
name|expP
operator|->
name|X_add_number
operator|=
literal|0x80000000
argument_list|)
expr_stmt|;
comment|/* Chosen so luser gets the most offset bits to patch later. */
block|}
name|expP
operator|->
name|X_add_number
operator|=
name|floatP
operator|->
name|low
index|[
literal|0
index|]
operator||
operator|(
operator|(
name|LITTLENUM_MASK
operator|&
operator|(
name|floatP
operator|->
name|low
index|[
literal|1
index|]
operator|)
operator|)
operator|<<
name|LITTLENUM_NUMBER_OF_BITS
operator|)
expr_stmt|;
comment|/* 				 * For the SEG_BIG case we have: 				 * If vop_short == 's' then a short floating literal is in the 				 *	lowest 6 bits of floatP->low [0], which is 				 *	big_operand_bits [---] [0]. 				 * If vop_short == 'i' then the appropriate number of elements 				 *	of big_operand_bits [---] [...] are set up with the correct 				 *	bits. 				 * Also, just in case width is byte word or long, we copy the lowest 				 * 32 bits of the number to X_add_number. 				 */
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|to_seg
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|input_line_pointer
operator|!=
name|operandP
operator|->
name|vop_expr_end
operator|+
literal|1
condition|)
block|{
name|as_warn
argument_list|(
literal|"Junk at end of expression \"%s\""
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
name|goofed
operator|=
literal|1
expr_stmt|;
block|}
name|operandP
operator|->
name|vop_expr_end
index|[
literal|1
index|]
operator|=
name|c_save
expr_stmt|;
block|}
block|}
comment|/* for (each operand) */
name|input_line_pointer
operator|=
name|save_input_line_pointer
expr_stmt|;
if|if
condition|(
name|need_pass_2
operator|||
name|goofed
condition|)
block|{
return|return;
block|}
comment|/* Emit op-code. */
comment|/* Remember where it is, in case we want to modify the op-code later. */
name|opcode_low_byteP
operator|=
name|frag_more
argument_list|(
name|v
operator|.
name|vit_opcode_nbytes
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|opcode_low_byteP
argument_list|,
name|v
operator|.
name|vit_opcode
argument_list|,
name|v
operator|.
name|vit_opcode_nbytes
argument_list|)
expr_stmt|;
name|opcode_as_number
operator|=
name|md_chars_to_number
argument_list|(
name|opcode_as_chars
operator|=
name|v
operator|.
name|vit_opcode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|operandP
operator|=
name|v
operator|.
name|vit_operand
operator|,
name|expP
operator|=
name|exp_of_operand
operator|,
name|floatP
operator|=
name|float_operand
operator|,
name|end_operandP
operator|=
name|v
operator|.
name|vit_operand
operator|+
name|v
operator|.
name|vit_operands
init|;
name|operandP
operator|<
name|end_operandP
condition|;
name|operandP
operator|++
operator|,
name|floatP
operator|++
operator|,
name|expP
operator|++
control|)
block|{
comment|/* for each operand */
if|if
condition|(
name|operandP
operator|->
name|vop_ndx
operator|>=
literal|0
condition|)
block|{
comment|/* indexed addressing byte */
comment|/* Legality of indexed mode already checked: it is OK */
name|FRAG_APPEND_1_CHAR
argument_list|(
literal|0x40
operator|+
name|operandP
operator|->
name|vop_ndx
argument_list|)
expr_stmt|;
block|}
comment|/* if (vop_ndx>= 0) */
comment|/* Here to make main operand frag(s). */
name|this_add_number
operator|=
name|expP
operator|->
name|X_add_number
expr_stmt|;
name|this_add_symbol
operator|=
name|expP
operator|->
name|X_add_symbol
expr_stmt|;
name|this_subtract_symbol
operator|=
name|expP
operator|->
name|X_subtract_symbol
expr_stmt|;
name|to_seg
operator|=
name|expP
operator|->
name|X_seg
expr_stmt|;
name|is_undefined
operator|=
operator|(
name|to_seg
operator|==
name|SEG_UNKNOWN
operator|)
expr_stmt|;
name|know
argument_list|(
name|to_seg
operator|==
name|SEG_UNKNOWN
operator|||
name|to_seg
operator|==
name|SEG_ABSOLUTE
operator|||
name|to_seg
operator|==
name|SEG_DATA
operator|||
name|to_seg
operator|==
name|SEG_TEXT
operator|||
name|to_seg
operator|==
name|SEG_BSS
operator|||
name|to_seg
operator|==
name|SEG_BIG
argument_list|)
expr_stmt|;
name|at
operator|=
name|operandP
operator|->
name|vop_mode
operator|&
literal|1
expr_stmt|;
name|length
operator|=
operator|(
name|operandP
operator|->
name|vop_short
operator|==
literal|'b'
condition|?
literal|1
else|:
operator|(
name|operandP
operator|->
name|vop_short
operator|==
literal|'w'
condition|?
literal|2
else|:
operator|(
name|operandP
operator|->
name|vop_short
operator|==
literal|'l'
condition|?
literal|4
else|:
literal|0
operator|)
operator|)
operator|)
expr_stmt|;
name|nbytes
operator|=
name|operandP
operator|->
name|vop_nbytes
expr_stmt|;
if|if
condition|(
name|operandP
operator|->
name|vop_access
operator|==
literal|'b'
condition|)
block|{
if|if
condition|(
name|to_seg
operator|==
name|now_seg
operator|||
name|is_undefined
condition|)
block|{
comment|/* If is_undefined, then it might BECOME now_seg. */
if|if
condition|(
name|nbytes
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|nbytes
argument_list|,
name|this_add_symbol
argument_list|,
literal|0
argument_list|,
name|this_add_number
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* to_seg == now_seg || to_seg == SEG_UNKNOWN */
comment|/* nbytes == 0 */
name|length_code
operator|=
name|is_undefined
condition|?
name|STATE_UNDF
else|:
name|STATE_BYTE
expr_stmt|;
if|if
condition|(
name|opcode_as_number
operator|&
name|VIT_OPCODE_SPECIAL
condition|)
block|{
if|if
condition|(
name|operandP
operator|->
name|vop_width
operator|==
name|VAX_WIDTH_UNCONDITIONAL_JUMP
condition|)
block|{
comment|/* br or jsb */
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_ALWAYS_BRANCH
argument_list|,
name|length_code
argument_list|)
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
name|opcode_low_byteP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|operandP
operator|->
name|vop_width
operator|==
name|VAX_WIDTH_WORD_JUMP
condition|)
block|{
name|length_code
operator|=
name|STATE_WORD
expr_stmt|;
comment|/* JF: There is no state_byte for this one! */
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_COMPLEX_BRANCH
argument_list|,
name|length_code
argument_list|)
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
name|opcode_low_byteP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|know
argument_list|(
name|operandP
operator|->
name|vop_width
operator|==
name|VAX_WIDTH_BYTE_JUMP
argument_list|)
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|9
argument_list|,
literal|1
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_COMPLEX_HOP
argument_list|,
name|length_code
argument_list|)
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
name|opcode_low_byteP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|know
argument_list|(
name|operandP
operator|->
name|vop_width
operator|==
name|VAX_WIDTH_CONDITIONAL_JUMP
argument_list|)
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|7
argument_list|,
literal|1
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH
argument_list|,
name|length_code
argument_list|)
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
name|opcode_low_byteP
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* to_seg != now_seg&& to_seg != SEG_UNKNOWN */
comment|/* 				 * --- SEG FLOAT MAY APPEAR HERE ---- 				 */
if|if
condition|(
name|to_seg
operator|==
name|SEG_ABSOLUTE
condition|)
block|{
if|if
condition|(
name|nbytes
condition|)
block|{
name|know
argument_list|(
operator|!
operator|(
name|opcode_as_number
operator|&
name|VIT_OPCODE_SYNTHETIC
operator|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
comment|/* Conventional relocation. */
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|nbytes
argument_list|,
operator|&
name|abs_symbol
argument_list|,
literal|0
argument_list|,
name|this_add_number
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|know
argument_list|(
name|opcode_as_number
operator|&
name|VIT_OPCODE_SYNTHETIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode_as_number
operator|&
name|VIT_OPCODE_SPECIAL
condition|)
block|{
if|if
condition|(
name|operandP
operator|->
name|vop_width
operator|==
name|VAX_WIDTH_UNCONDITIONAL_JUMP
condition|)
block|{
comment|/* br or jsb */
operator|*
name|opcode_low_byteP
operator|=
name|opcode_as_chars
index|[
literal|0
index|]
operator|+
name|VAX_WIDEN_LONG
expr_stmt|;
name|know
argument_list|(
name|opcode_as_chars
index|[
literal|1
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|VAX_ABSOLUTE_MODE
expr_stmt|;
comment|/* @#... */
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|this_add_number
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Now (eg) JMP @#foo or JSB @#foo. */
block|}
else|else
block|{
if|if
condition|(
name|operandP
operator|->
name|vop_width
operator|==
name|VAX_WIDTH_WORD_JUMP
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|VAX_BRB
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
literal|6
expr_stmt|;
name|p
index|[
literal|4
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|p
index|[
literal|5
index|]
operator|=
name|VAX_ABSOLUTE_MODE
expr_stmt|;
comment|/* @#... */
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|6
argument_list|,
name|this_add_number
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* 									 * Now (eg)	ACBx	1f 									 *		BRB	2f 									 *	1:	JMP	@#foo 									 *	2: 									 */
block|}
else|else
block|{
name|know
argument_list|(
name|operandP
operator|->
name|vop_width
operator|==
name|VAX_WIDTH_BYTE_JUMP
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|9
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|VAX_BRB
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
literal|6
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|p
index|[
literal|4
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
operator|+
literal|1
expr_stmt|;
comment|/* @#... */
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|5
argument_list|,
name|this_add_number
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* 									 * Now (eg)	xOBxxx	1f 									 *		BRB	2f 									 *	1:	JMP	@#foo 									 *	2: 									 */
block|}
block|}
block|}
else|else
block|{
comment|/* b<cond> */
operator|*
name|opcode_low_byteP
operator|^=
literal|1
expr_stmt|;
comment|/* To reverse the condition in a VAX branch, complement the lowest order 							   bit. */
name|p
operator|=
name|frag_more
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|6
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|VAX_ABSOLUTE_MODE
expr_stmt|;
comment|/* @#... */
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|3
argument_list|,
name|this_add_number
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* 							 * Now (eg)	BLEQ	1f 							 *		JMP	@#foo 							 *	1: 							 */
block|}
block|}
block|}
else|else
block|{
comment|/* to_seg != now_seg&& to_seg != SEG_UNKNOWN&& to_Seg != SEG_ABSOLUTE */
if|if
condition|(
name|nbytes
operator|>
literal|0
condition|)
block|{
comment|/* Pc-relative. Conventional relocation. */
name|know
argument_list|(
operator|!
operator|(
name|opcode_as_number
operator|&
name|VIT_OPCODE_SYNTHETIC
operator|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|nbytes
argument_list|,
operator|&
name|abs_symbol
argument_list|,
literal|0
argument_list|,
name|this_add_number
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|know
argument_list|(
name|opcode_as_number
operator|&
name|VIT_OPCODE_SYNTHETIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode_as_number
operator|&
name|VIT_OPCODE_SPECIAL
condition|)
block|{
if|if
condition|(
name|operandP
operator|->
name|vop_width
operator|==
name|VAX_WIDTH_UNCONDITIONAL_JUMP
condition|)
block|{
comment|/* br or jsb */
name|know
argument_list|(
name|opcode_as_chars
index|[
literal|1
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|*
name|opcode_low_byteP
operator|=
name|opcode_as_chars
index|[
literal|0
index|]
operator|+
name|VAX_WIDEN_LONG
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|1
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|this_add_symbol
argument_list|,
literal|0
argument_list|,
name|this_add_number
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
comment|/* Now eg JMP foo or JSB foo. */
block|}
else|else
block|{
if|if
condition|(
name|operandP
operator|->
name|vop_width
operator|==
name|VAX_WIDTH_WORD_JUMP
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|VAX_BRB
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
literal|6
expr_stmt|;
name|p
index|[
literal|4
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|p
index|[
literal|5
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|6
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|this_add_symbol
argument_list|,
literal|0
argument_list|,
name|this_add_number
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
comment|/* 									 * Now (eg)	ACBx	1f 									 *		BRB	2f 									 *	1:	JMP	foo 									 *	2: 									 */
block|}
else|else
block|{
name|know
argument_list|(
name|operandP
operator|->
name|vop_width
operator|==
name|VAX_WIDTH_BYTE_JUMP
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|VAX_BRB
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
literal|6
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|p
index|[
literal|4
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|5
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|this_add_symbol
argument_list|,
literal|0
argument_list|,
name|this_add_number
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
comment|/* 									 * Now (eg)	xOBxxx	1f 									 *		BRB	2f 									 *	1:	JMP	foo 									 *	2: 									 */
block|}
block|}
block|}
else|else
block|{
name|know
argument_list|(
name|operandP
operator|->
name|vop_width
operator|==
name|VAX_WIDTH_CONDITIONAL_JUMP
argument_list|)
expr_stmt|;
operator|*
name|opcode_low_byteP
operator|^=
literal|1
expr_stmt|;
comment|/* Reverse branch condition. */
name|p
operator|=
name|frag_more
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|6
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|3
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|this_add_symbol
argument_list|,
literal|0
argument_list|,
name|this_add_number
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|know
argument_list|(
name|operandP
operator|->
name|vop_access
operator|!=
literal|'b'
argument_list|)
expr_stmt|;
comment|/* So it is ordinary operand. */
name|know
argument_list|(
name|operandP
operator|->
name|vop_access
operator|!=
literal|' '
argument_list|)
expr_stmt|;
comment|/* ' ' target-independent: elsewhere. */
name|know
argument_list|(
name|operandP
operator|->
name|vop_access
operator|==
literal|'a'
operator|||
name|operandP
operator|->
name|vop_access
operator|==
literal|'m'
operator|||
name|operandP
operator|->
name|vop_access
operator|==
literal|'r'
operator|||
name|operandP
operator|->
name|vop_access
operator|==
literal|'v'
operator|||
name|operandP
operator|->
name|vop_access
operator|==
literal|'w'
argument_list|)
expr_stmt|;
if|if
condition|(
name|operandP
operator|->
name|vop_short
operator|==
literal|'s'
condition|)
block|{
if|if
condition|(
name|to_seg
operator|==
name|SEG_ABSOLUTE
condition|)
block|{
if|if
condition|(
name|this_add_number
operator|<
literal|0
operator|||
name|this_add_number
operator|>=
literal|64
condition|)
block|{
name|as_warn
argument_list|(
literal|"Short literal overflow(%d.), immediate mode assumed."
argument_list|,
name|this_add_number
argument_list|)
expr_stmt|;
name|operandP
operator|->
name|vop_short
operator|=
literal|'i'
expr_stmt|;
name|operandP
operator|->
name|vop_mode
operator|=
literal|8
expr_stmt|;
name|operandP
operator|->
name|vop_reg
operator|=
literal|0xF
expr_stmt|;
block|}
block|}
else|else
block|{
name|as_warn
argument_list|(
literal|"Forced short literal to immediate mode. now_seg=%s to_seg=%s"
argument_list|,
name|segment_name
argument_list|(
name|now_seg
argument_list|)
argument_list|,
name|segment_name
argument_list|(
name|to_seg
argument_list|)
argument_list|)
expr_stmt|;
name|operandP
operator|->
name|vop_short
operator|=
literal|'i'
expr_stmt|;
name|operandP
operator|->
name|vop_mode
operator|=
literal|8
expr_stmt|;
name|operandP
operator|->
name|vop_reg
operator|=
literal|0xF
expr_stmt|;
block|}
block|}
if|if
condition|(
name|operandP
operator|->
name|vop_reg
operator|>=
literal|0
operator|&&
operator|(
name|operandP
operator|->
name|vop_mode
operator|<
literal|8
operator|||
operator|(
name|operandP
operator|->
name|vop_reg
operator|!=
literal|0xF
operator|&&
name|operandP
operator|->
name|vop_mode
operator|<
literal|10
operator|)
operator|)
condition|)
block|{
comment|/* One byte operand. */
name|know
argument_list|(
name|operandP
operator|->
name|vop_mode
operator|>
literal|3
argument_list|)
expr_stmt|;
name|FRAG_APPEND_1_CHAR
argument_list|(
name|operandP
operator|->
name|vop_mode
operator|<<
literal|4
operator||
name|operandP
operator|->
name|vop_reg
argument_list|)
expr_stmt|;
comment|/* All 1-bytes except S^# happen here. */
block|}
else|else
block|{
comment|/* {@}{q^}foo{(Rn)} or S^#foo */
if|if
condition|(
name|operandP
operator|->
name|vop_reg
operator|==
operator|-
literal|1
operator|&&
name|operandP
operator|->
name|vop_short
operator|!=
literal|'s'
condition|)
block|{
comment|/* "{@}{q^}foo" */
if|if
condition|(
name|to_seg
operator|==
name|now_seg
condition|)
block|{
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|know
argument_list|(
name|operandP
operator|->
name|vop_short
operator|==
literal|' '
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|10
argument_list|,
literal|2
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_PC_RELATIVE
argument_list|,
name|STATE_BYTE
argument_list|)
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
name|opcode_low_byteP
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|operandP
operator|->
name|vop_mode
operator|==
literal|10
operator|+
name|at
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|at
operator|<<
literal|4
expr_stmt|;
comment|/* At is the only context we need to carry to */
comment|/* other side of relax() process. */
comment|/* Must be in the correct bit position of VAX */
comment|/* operand spec. byte. */
block|}
else|else
block|{
name|know
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|operandP
operator|->
name|vop_short
operator|!=
literal|' '
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* JF is this array stuff really going to work? */
name|p
index|[
literal|0
index|]
operator|=
literal|0xF
operator||
operator|(
operator|(
name|at
operator|+
literal|"?\12\14?\16"
index|[
name|length
index|]
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|1
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|length
argument_list|,
name|this_add_symbol
argument_list|,
literal|0
argument_list|,
name|this_add_number
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* to_seg != now_seg */
if|if
condition|(
name|this_add_symbol
operator|==
name|NULL
condition|)
block|{
name|know
argument_list|(
name|to_seg
operator|==
name|SEG_ABSOLUTE
argument_list|)
expr_stmt|;
comment|/* Do @#foo: simpler relocation than foo-.(pc) anyway. */
name|p
operator|=
name|frag_more
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|VAX_ABSOLUTE_MODE
expr_stmt|;
comment|/* @#... */
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|this_add_number
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|&&
name|length
operator|!=
literal|4
condition|)
block|{
name|as_warn
argument_list|(
literal|"Length specification ignored. Address mode 9F used"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* {@}{q^}other_seg */
name|know
argument_list|(
operator|(
name|length
operator|==
literal|0
operator|&&
name|operandP
operator|->
name|vop_short
operator|==
literal|' '
operator|)
operator|||
operator|(
name|length
operator|>
literal|0
operator|&&
name|operandP
operator|->
name|vop_short
operator|!=
literal|' '
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_undefined
condition|)
block|{
comment|/* 								 * We have a SEG_UNKNOWN symbol. It might 								 * turn out to be in the same segment as 								 * the instruction, permitting relaxation. 								 */
name|p
operator|=
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|5
argument_list|,
literal|2
argument_list|,
name|ENCODE_RELAX
argument_list|(
name|STATE_PC_RELATIVE
argument_list|,
name|STATE_UNDF
argument_list|)
argument_list|,
name|this_add_symbol
argument_list|,
name|this_add_number
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|at
operator|<<
literal|4
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|know
argument_list|(
name|operandP
operator|->
name|vop_short
operator|==
literal|' '
argument_list|)
expr_stmt|;
name|length
operator|=
literal|4
expr_stmt|;
comment|/* Longest possible. */
block|}
name|p
operator|=
name|frag_more
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|0xF
operator||
operator|(
operator|(
name|at
operator|+
literal|"?\12\14?\16"
index|[
name|length
index|]
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|this_add_number
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|1
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|length
argument_list|,
name|this_add_symbol
argument_list|,
literal|0
argument_list|,
name|this_add_number
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* {@}{q^}foo(Rn) or S^# or I^# or # */
if|if
condition|(
name|operandP
operator|->
name|vop_mode
operator|<
literal|0xA
condition|)
block|{
comment|/* # or S^# or I^# */
comment|/* know(   (length == 0&& operandP->vop_short == ' ') 						   || (length>  0&& operandP->vop_short != ' ')); */
if|if
condition|(
name|length
operator|==
literal|0
operator|&&
name|to_seg
operator|==
name|SEG_ABSOLUTE
operator|&&
name|operandP
operator|->
name|vop_mode
operator|==
literal|8
comment|/* No '@'. */
operator|&&
name|this_add_number
operator|<
literal|64
operator|&&
name|this_add_number
operator|>=
literal|0
condition|)
block|{
name|operandP
operator|->
name|vop_short
operator|=
literal|'s'
expr_stmt|;
block|}
if|if
condition|(
name|operandP
operator|->
name|vop_short
operator|==
literal|'s'
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|this_add_number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* I^#... */
name|know
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|nbytes
operator|+
literal|1
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|operandP
operator|->
name|vop_reg
operator|==
literal|0xF
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
operator|(
name|operandP
operator|->
name|vop_mode
operator|<<
literal|4
operator|)
operator||
literal|0xF
expr_stmt|;
if|if
condition|(
name|to_seg
operator|==
name|SEG_ABSOLUTE
condition|)
block|{
comment|/* 								 * If nbytes> 4, then we are scrod. We don't know if the 								 * high order bytes are to be 0xFF or 0x00. 								 * BSD4.2& RMS say use 0x00. OK --- but this 								 * assembler needs ANOTHER rewrite to 								 * cope properly with this bug. 								 */
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|this_add_number
argument_list|,
name|min
argument_list|(
literal|4
argument_list|,
name|nbytes
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|>
literal|4
condition|)
block|{
name|memset
argument_list|(
name|p
operator|+
literal|5
argument_list|,
literal|'\0'
argument_list|,
name|nbytes
operator|-
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|to_seg
operator|==
name|SEG_BIG
condition|)
block|{
comment|/* 									 * Problem here is to get the bytes in the right order. 									 * We stored our constant as LITTLENUMs, not bytes. 									 */
name|LITTLENUM_TYPE
modifier|*
name|lP
decl_stmt|;
name|lP
operator|=
name|floatP
operator|->
name|low
expr_stmt|;
if|if
condition|(
name|nbytes
operator|&
literal|1
condition|)
block|{
name|know
argument_list|(
name|nbytes
operator|==
literal|1
argument_list|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
operator|*
name|lP
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|++
init|;
name|nbytes
condition|;
name|nbytes
operator|-=
literal|2
operator|,
name|p
operator|+=
literal|2
operator|,
name|lP
operator|++
control|)
block|{
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|*
name|lP
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|1
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|nbytes
argument_list|,
name|this_add_symbol
argument_list|,
literal|0
argument_list|,
name|this_add_number
argument_list|,
literal|0
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* {@}{q^}foo(Rn) */
name|know
argument_list|(
operator|(
name|length
operator|==
literal|0
operator|&&
name|operandP
operator|->
name|vop_short
operator|==
literal|' '
operator|)
operator|||
operator|(
name|length
operator|>
literal|0
operator|&&
name|operandP
operator|->
name|vop_short
operator|!=
literal|' '
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|to_seg
operator|==
name|SEG_ABSOLUTE
condition|)
block|{
specifier|register
name|long
name|test
decl_stmt|;
name|test
operator|=
name|this_add_number
expr_stmt|;
if|if
condition|(
name|test
operator|<
literal|0
condition|)
name|test
operator|=
operator|~
name|test
expr_stmt|;
name|length
operator|=
name|test
operator|&
literal|0xffff8000
condition|?
literal|4
else|:
name|test
operator|&
literal|0xffffff80
condition|?
literal|2
else|:
literal|1
expr_stmt|;
block|}
else|else
block|{
name|length
operator|=
literal|4
expr_stmt|;
block|}
block|}
name|p
operator|=
name|frag_more
argument_list|(
literal|1
operator|+
name|length
argument_list|)
expr_stmt|;
name|know
argument_list|(
name|operandP
operator|->
name|vop_reg
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|operandP
operator|->
name|vop_reg
operator||
operator|(
operator|(
name|at
operator||
literal|"?\12\14?\16"
index|[
name|length
index|]
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|to_seg
operator|==
name|SEG_ABSOLUTE
condition|)
block|{
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|this_add_number
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|1
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|length
argument_list|,
name|this_add_symbol
argument_list|,
literal|0
argument_list|,
name|this_add_number
argument_list|,
literal|0
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* if (single-byte-operand) */
block|}
block|}
comment|/* for (operandP) */
block|}
end_function

begin_comment
comment|/* vax_assemble() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			md_estimate_size_before_relax()  *  * Called just before relax().  * Any symbol that is now undefined will not become defined.  * Return the correct fr_subtype in the frag.  * Return the initial "guess for fr_var" to caller.  * The guess for fr_var is ACTUALLY the growth beyond fr_fix.  * Whatever we do to grow fr_fix or fr_var contributes to our returned value.  * Although it may not be explicit in the frag, pretend fr_var starts with a  * 0 value.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment
parameter_list|)
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
specifier|register
name|segT
name|segment
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|old_fr_fix
decl_stmt|;
name|old_fr_fix
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_PC_RELATIVE
argument_list|,
name|STATE_UNDF
argument_list|)
case|:
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment
condition|)
block|{
comment|/* A relaxable case. */
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_PC_RELATIVE
argument_list|,
name|STATE_BYTE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|old_fr_fix
expr_stmt|;
name|p
index|[
literal|0
index|]
operator||=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
comment|/* Preserve @ bit. */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|1
operator|+
literal|4
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|+
literal|1
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH
argument_list|,
name|STATE_UNDF
argument_list|)
case|:
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH
argument_list|,
name|STATE_BYTE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|old_fr_fix
expr_stmt|;
operator|*
name|fragP
operator|->
name|fr_opcode
operator|^=
literal|1
expr_stmt|;
comment|/* Reverse sense of branch. */
name|p
index|[
literal|0
index|]
operator|=
literal|6
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
comment|/* ...(PC) */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|1
operator|+
literal|1
operator|+
literal|1
operator|+
literal|4
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|+
literal|3
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COMPLEX_BRANCH
argument_list|,
name|STATE_UNDF
argument_list|)
case|:
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_COMPLEX_BRANCH
argument_list|,
name|STATE_WORD
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|old_fr_fix
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|VAX_BRB
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
literal|6
expr_stmt|;
name|p
index|[
literal|4
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|p
index|[
literal|5
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
comment|/* ...(pc) */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|2
operator|+
literal|2
operator|+
literal|1
operator|+
literal|1
operator|+
literal|4
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|+
literal|6
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COMPLEX_HOP
argument_list|,
name|STATE_UNDF
argument_list|)
case|:
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_COMPLEX_HOP
argument_list|,
name|STATE_BYTE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|old_fr_fix
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|VAX_BRB
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
literal|6
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|p
index|[
literal|4
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
comment|/* ...(pc) */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|1
operator|+
literal|2
operator|+
literal|1
operator|+
literal|1
operator|+
literal|4
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|+
literal|5
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_ALWAYS_BRANCH
argument_list|,
name|STATE_UNDF
argument_list|)
case|:
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment
condition|)
block|{
name|fragP
operator|->
name|fr_subtype
operator|=
name|ENCODE_RELAX
argument_list|(
name|STATE_ALWAYS_BRANCH
argument_list|,
name|STATE_BYTE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|old_fr_fix
expr_stmt|;
operator|*
name|fragP
operator|->
name|fr_opcode
operator|+=
name|VAX_WIDEN_LONG
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
comment|/* ...(PC) */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|1
operator|+
literal|4
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|+
literal|1
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|fragP
operator|->
name|fr_var
operator|+
name|fragP
operator|->
name|fr_fix
operator|-
name|old_fr_fix
operator|)
return|;
block|}
end_function

begin_comment
comment|/* md_estimate_size_before_relax() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			md_convert_frag();  *  * Called after relax() is finished.  * In:	Address of frag.  *	fr_type == rs_machine_dependent.  *	fr_subtype is what the address relaxed to.  *  * Out:	Any fixSs and constants are set up.  *	Caller will turn frag into a ".space 0".  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|headers
parameter_list|,
name|fragP
parameter_list|)
name|object_headers
modifier|*
name|headers
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|char
modifier|*
name|addressP
decl_stmt|;
comment|/* -> _var to change. */
name|char
modifier|*
name|opcodeP
decl_stmt|;
comment|/* -> opcode char(s) to change. */
name|short
name|int
name|length_code
decl_stmt|;
comment|/* 2=long 1=word 0=byte */
name|short
name|int
name|extension
init|=
literal|0
decl_stmt|;
comment|/* Size of relaxed address. */
comment|/* Added to fr_fix: incl. ALL var chars. */
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|long
name|where
decl_stmt|;
name|long
name|address_of_var
decl_stmt|;
comment|/* Where, in file space, is _var of *fragP? */
name|long
name|target_address
init|=
literal|0
decl_stmt|;
comment|/* Where, in file space, does addr point? */
name|know
argument_list|(
name|fragP
operator|->
name|fr_type
operator|==
name|rs_machine_dependent
argument_list|)
expr_stmt|;
name|length_code
operator|=
name|fragP
operator|->
name|fr_subtype
operator|&
literal|3
expr_stmt|;
comment|/* depends on ENCODE_RELAX() */
name|know
argument_list|(
name|length_code
operator|>=
literal|0
operator|&&
name|length_code
operator|<
literal|3
argument_list|)
expr_stmt|;
name|where
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|addressP
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|where
expr_stmt|;
name|opcodeP
operator|=
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
name|symbolP
operator|=
name|fragP
operator|->
name|fr_symbol
expr_stmt|;
name|know
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|target_address
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|+
name|fragP
operator|->
name|fr_offset
expr_stmt|;
name|address_of_var
operator|=
name|fragP
operator|->
name|fr_address
operator|+
name|where
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_PC_RELATIVE
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
name|know
argument_list|(
operator|*
name|addressP
operator|==
literal|0
operator|||
operator|*
name|addressP
operator|==
literal|0x10
argument_list|)
expr_stmt|;
comment|/* '@' bit. */
name|addressP
index|[
literal|0
index|]
operator||=
literal|0xAF
expr_stmt|;
comment|/* Byte displacement. */
name|addressP
index|[
literal|1
index|]
operator|=
name|target_address
operator|-
operator|(
name|address_of_var
operator|+
literal|2
operator|)
expr_stmt|;
name|extension
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_PC_RELATIVE
argument_list|,
name|STATE_WORD
argument_list|)
case|:
name|know
argument_list|(
operator|*
name|addressP
operator|==
literal|0
operator|||
operator|*
name|addressP
operator|==
literal|0x10
argument_list|)
expr_stmt|;
comment|/* '@' bit. */
name|addressP
index|[
literal|0
index|]
operator||=
literal|0xCF
expr_stmt|;
comment|/* Word displacement. */
name|md_number_to_chars
argument_list|(
name|addressP
operator|+
literal|1
argument_list|,
name|target_address
operator|-
operator|(
name|address_of_var
operator|+
literal|3
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_PC_RELATIVE
argument_list|,
name|STATE_LONG
argument_list|)
case|:
name|know
argument_list|(
operator|*
name|addressP
operator|==
literal|0
operator|||
operator|*
name|addressP
operator|==
literal|0x10
argument_list|)
expr_stmt|;
comment|/* '@' bit. */
name|addressP
index|[
literal|0
index|]
operator||=
literal|0xEF
expr_stmt|;
comment|/* Long word displacement. */
name|md_number_to_chars
argument_list|(
name|addressP
operator|+
literal|1
argument_list|,
name|target_address
operator|-
operator|(
name|address_of_var
operator|+
literal|5
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
name|addressP
index|[
literal|0
index|]
operator|=
name|target_address
operator|-
operator|(
name|address_of_var
operator|+
literal|1
operator|)
expr_stmt|;
name|extension
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH
argument_list|,
name|STATE_WORD
argument_list|)
case|:
name|opcodeP
index|[
literal|0
index|]
operator|^=
literal|1
expr_stmt|;
comment|/* Reverse sense of test. */
name|addressP
index|[
literal|0
index|]
operator|=
literal|3
expr_stmt|;
name|addressP
index|[
literal|1
index|]
operator|=
name|VAX_BRB
operator|+
name|VAX_WIDEN_WORD
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|addressP
operator|+
literal|2
argument_list|,
name|target_address
operator|-
operator|(
name|address_of_var
operator|+
literal|4
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_CONDITIONAL_BRANCH
argument_list|,
name|STATE_LONG
argument_list|)
case|:
name|opcodeP
index|[
literal|0
index|]
operator|^=
literal|1
expr_stmt|;
comment|/* Reverse sense of test. */
name|addressP
index|[
literal|0
index|]
operator|=
literal|6
expr_stmt|;
name|addressP
index|[
literal|1
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|addressP
index|[
literal|2
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|addressP
operator|+
literal|3
argument_list|,
name|target_address
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|7
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_ALWAYS_BRANCH
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
name|addressP
index|[
literal|0
index|]
operator|=
name|target_address
operator|-
operator|(
name|address_of_var
operator|+
literal|1
operator|)
expr_stmt|;
name|extension
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_ALWAYS_BRANCH
argument_list|,
name|STATE_WORD
argument_list|)
case|:
name|opcodeP
index|[
literal|0
index|]
operator|+=
name|VAX_WIDEN_WORD
expr_stmt|;
comment|/* brb -> brw, bsbb -> bsbw */
name|md_number_to_chars
argument_list|(
name|addressP
argument_list|,
name|target_address
operator|-
operator|(
name|address_of_var
operator|+
literal|2
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_ALWAYS_BRANCH
argument_list|,
name|STATE_LONG
argument_list|)
case|:
name|opcodeP
index|[
literal|0
index|]
operator|+=
name|VAX_WIDEN_LONG
expr_stmt|;
comment|/* brb -> jmp, bsbb -> jsb */
name|addressP
index|[
literal|0
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|addressP
operator|+
literal|1
argument_list|,
name|target_address
operator|-
operator|(
name|address_of_var
operator|+
literal|5
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COMPLEX_BRANCH
argument_list|,
name|STATE_WORD
argument_list|)
case|:
name|md_number_to_chars
argument_list|(
name|addressP
argument_list|,
name|target_address
operator|-
operator|(
name|address_of_var
operator|+
literal|2
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COMPLEX_BRANCH
argument_list|,
name|STATE_LONG
argument_list|)
case|:
name|addressP
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|addressP
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|addressP
index|[
literal|2
index|]
operator|=
name|VAX_BRB
expr_stmt|;
name|addressP
index|[
literal|3
index|]
operator|=
literal|6
expr_stmt|;
name|addressP
index|[
literal|4
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|addressP
index|[
literal|5
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|addressP
operator|+
literal|6
argument_list|,
name|target_address
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COMPLEX_HOP
argument_list|,
name|STATE_BYTE
argument_list|)
case|:
name|addressP
index|[
literal|0
index|]
operator|=
name|target_address
operator|-
operator|(
name|address_of_var
operator|+
literal|1
operator|)
expr_stmt|;
name|extension
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COMPLEX_HOP
argument_list|,
name|STATE_WORD
argument_list|)
case|:
name|addressP
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|addressP
index|[
literal|1
index|]
operator|=
name|VAX_BRB
expr_stmt|;
name|addressP
index|[
literal|2
index|]
operator|=
literal|3
expr_stmt|;
name|addressP
index|[
literal|3
index|]
operator|=
name|VAX_BRW
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|addressP
operator|+
literal|4
argument_list|,
name|target_address
operator|-
operator|(
name|address_of_var
operator|+
literal|6
operator|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX
argument_list|(
name|STATE_COMPLEX_HOP
argument_list|,
name|STATE_LONG
argument_list|)
case|:
name|addressP
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|addressP
index|[
literal|1
index|]
operator|=
name|VAX_BRB
expr_stmt|;
name|addressP
index|[
literal|2
index|]
operator|=
literal|6
expr_stmt|;
name|addressP
index|[
literal|3
index|]
operator|=
name|VAX_JMP
expr_stmt|;
name|addressP
index|[
literal|4
index|]
operator|=
name|VAX_PC_RELATIVE_MODE
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|addressP
operator|+
literal|5
argument_list|,
name|target_address
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|extension
operator|=
literal|9
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
break|break;
block|}
name|fragP
operator|->
name|fr_fix
operator|+=
name|extension
expr_stmt|;
block|}
end_function

begin_comment
comment|/* md_convert_frag() */
end_comment

begin_comment
comment|/* Translate internal format of relocation info into target format.     On vax: first 4 bytes are normal unsigned long, next three bytes    are symbolnum, least sig. byte first.  Last byte is broken up with    the upper nibble as nuthin, bit 3 as extern, bits 2& 1 as length, and    bit 0 as pcrel. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|comment
end_ifdef

begin_function
name|void
name|md_ri_to_chars
parameter_list|(
name|the_bytes
parameter_list|,
name|ri
parameter_list|)
name|char
modifier|*
name|the_bytes
decl_stmt|;
name|struct
name|reloc_info_generic
name|ri
decl_stmt|;
block|{
comment|/* this is easy */
name|md_number_to_chars
argument_list|(
name|the_bytes
argument_list|,
name|ri
operator|.
name|r_address
argument_list|,
sizeof|sizeof
argument_list|(
name|ri
operator|.
name|r_address
argument_list|)
argument_list|)
expr_stmt|;
comment|/* now the fun stuff */
name|the_bytes
index|[
literal|6
index|]
operator|=
operator|(
name|ri
operator|.
name|r_symbolnum
operator|>>
literal|16
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|the_bytes
index|[
literal|5
index|]
operator|=
operator|(
name|ri
operator|.
name|r_symbolnum
operator|>>
literal|8
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|the_bytes
index|[
literal|4
index|]
operator|=
name|ri
operator|.
name|r_symbolnum
operator|&
literal|0x0ff
expr_stmt|;
name|the_bytes
index|[
literal|7
index|]
operator|=
operator|(
operator|(
operator|(
name|ri
operator|.
name|r_extern
operator|<<
literal|3
operator|)
operator|&
literal|0x08
operator|)
operator||
operator|(
operator|(
name|ri
operator|.
name|r_length
operator|<<
literal|1
operator|)
operator|&
literal|0x06
operator|)
operator||
operator|(
operator|(
name|ri
operator|.
name|r_pcrel
operator|<<
literal|0
operator|)
operator|&
literal|0x01
operator|)
operator|)
operator|&
literal|0x0F
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* comment */
end_comment

begin_function
name|void
name|tc_aout_fix_to_chars
parameter_list|(
name|where
parameter_list|,
name|fixP
parameter_list|,
name|segment_address_in_file
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|relax_addressT
name|segment_address_in_file
decl_stmt|;
block|{
comment|/* 	 * In: length of relocation (or of address) in chars: 1, 2 or 4. 	 * Out: GNU LD relocation length code: 0, 1, or 2. 	 */
specifier|static
name|unsigned
name|char
name|nbytes_r_length
index|[]
init|=
block|{
literal|42
block|,
literal|0
block|,
literal|1
block|,
literal|42
block|,
literal|2
block|}
decl_stmt|;
name|long
name|r_symbolnum
decl_stmt|;
name|know
argument_list|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|segment_address_in_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|r_symbolnum
operator|=
operator|(
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|?
name|S_GET_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
else|:
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_number
operator|)
expr_stmt|;
name|where
index|[
literal|6
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|16
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|5
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|8
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|4
index|]
operator|=
name|r_symbolnum
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|7
index|]
operator|=
operator|(
operator|(
operator|(
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|)
operator|<<
literal|3
operator|)
operator|&
literal|0x08
operator|)
operator||
operator|(
operator|(
name|nbytes_r_length
index|[
name|fixP
operator|->
name|fx_size
index|]
operator|<<
literal|1
operator|)
operator|&
literal|0x06
operator|)
operator||
operator|(
operator|(
operator|(
name|fixP
operator|->
name|fx_pcrel
operator|<<
literal|0
operator|)
operator|&
literal|0x01
operator|)
operator|&
literal|0x0f
operator|)
operator|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tc_aout_fix_to_chars() */
end_comment

begin_comment
comment|/*  *       BUGS, GRIPES,  APOLOGIA, etc.  *  * The opcode table 'votstrs' needs to be sorted on opcode frequency.  * That is, AFTER we hash it with hash_...(), we want most-used opcodes  * to come out of the hash table faster.  *  * I am sorry to inflict  * yet another VAX assembler on the world, but RMS says we must  * do everything from scratch, to prevent pin-heads restricting  * this software.  */
end_comment

begin_comment
comment|/*  * This is a vaguely modular set of routines in C to parse VAX  * assembly code using DEC mnemonics. It is NOT un*x specific.  *  * The idea here is that the assembler has taken care of all:  *   labels  *   macros  *   listing  *   pseudo-ops  *   line continuation  *   comments  *   condensing any whitespace down to exactly one space  * and all we have to do is parse 1 line into a vax instruction  * partially formed. We will accept a line, and deliver:  *   an error message (hopefully empty)  *   a skeleton VAX instruction (tree structure)  *   textual pointers to all the operand expressions  *   a warning message that notes a silly operand (hopefully empty)  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *		E D I T   H I S T O R Y  *  * 17may86 Dean Elsner. Bug if line ends immediately after opcode.  * 30apr86 Dean Elsner. New vip_op() uses arg block so change call.  *  6jan86 Dean Elsner. Crock vip_begin() to call vip_op_defaults().  *  2jan86 Dean Elsner. Invent synthetic opcodes.  *	Widen vax_opcodeT to 32 bits. Use a bit for VIT_OPCODE_SYNTHETIC,  *	which means this is not a real opcode, it is like a macro; it will  *	be relax()ed into 1 or more instructions.  *	Use another bit for VIT_OPCODE_SPECIAL if the op-code is not optimised  *	like a regular branch instruction. Option added to vip_begin():  *	exclude	synthetic opcodes. Invent synthetic_votstrs[].  * 31dec85 Dean Elsner. Invent vit_opcode_nbytes.  *	Also make vit_opcode into a char[]. We now have n-byte vax opcodes,  *	so caller's don't have to know the difference between a 1-byte& a  *	2-byte op-code. Still need vax_opcodeT concept, so we know how  *	big an object must be to hold an op.code.  * 30dec85 Dean Elsner. Widen typedef vax_opcodeT in "vax-inst.h"  *	because vax opcodes may be 16 bits. Our crufty C compiler was  *	happily initialising 8-bit vot_codes with 16-bit numbers!  *	(Wouldn't the 'phone company like to compress data so easily!)  * 29dec85 Dean Elsner. New static table vax_operand_width_size[].  *	Invented so we know hw many bytes a "I^#42" needs in its immediate  *	operand. Revised struct vop in "vax-inst.h": explicitly include  *	byte length of each operand, and it's letter-code datum type.  * 17nov85 Dean Elsner. Name Change.  *	Due to ar(1) truncating names, we learned the hard way that  *	"vax-inst-parse.c" -> "vax-inst-parse." dropping the "o" off  *	the archived object name. SO... we shortened the name of this  *	source file, and changed the makefile.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* handle of the OPCODE hash table */
end_comment

begin_comment
comment|/* NULL means any use before vip_begin() */
end_comment

begin_comment
comment|/* will crash */
end_comment

begin_comment
comment|/*  * In:	1 character, from "bdfghloqpw" being the data-type of an operand  *	of a vax instruction.  *  * Out:	the length of an operand of that type, in bytes.  *	Special branch operands types "-?!" have length 0.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|short
name|int
name|vax_operand_width_size
index|[
literal|256
index|]
init|=
block|{
define|#
directive|define
name|_
value|0
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
literal|1
block|,
name|_
block|,
literal|8
block|,
name|_
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
name|_
block|,
name|_
block|,
name|_
block|,
literal|4
block|,
name|_
block|,
name|_
block|,
literal|16
block|,
comment|/* ..b.d.fgh...l..o */
name|_
block|,
literal|8
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
literal|2
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* .q.....w........ */
name|_
block|,
name|_
block|,
literal|1
block|,
name|_
block|,
literal|8
block|,
name|_
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
name|_
block|,
name|_
block|,
name|_
block|,
literal|4
block|,
name|_
block|,
name|_
block|,
literal|16
block|,
comment|/* ..b.d.fgh...l..o */
name|_
block|,
literal|8
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
literal|2
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
comment|/* .q.....w........ */
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|,
name|_
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|_
end_undef

begin_escape
end_escape

begin_comment
comment|/*  * This perversion encodes all the vax opcodes as a bunch of strings.  * RMS says we should build our hash-table at run-time. Hmm.  * Please would someone arrange these in decreasing frequency of opcode?  * Because of the way hash_...() works, the most frequently used opcode  * should be textually first and so on.  *  * Input for this table was 'vax.opcodes', awk(1)ed by 'vax.opcodes.c.awk' .  * So change 'vax.opcodes', then re-generate this table.  */
end_comment

begin_include
include|#
directive|include
file|"opcode/vax.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*  * This is a table of optional op-codes. All of them represent  * 'synthetic' instructions that seem popular.  *  * Here we make some pseudo op-codes. Every code has a bit set to say  * it is synthetic. This lets you catch them if you want to  * ban these opcodes. They are mnemonics for "elastic" instructions  * that are supposed to assemble into the fewest bytes needed to do a  * branch, or to do a conditional branch, or whatever.  *  * The opcode is in the usual place [low-order n*8 bits]. This means  * that if you mask off the bucky bits, the usual rules apply about  * how long the opcode is.  *  * All VAX branch displacements come at the end of the instruction.  * For simple branches (1-byte opcode + 1-byte displacement) the last  * operand is coded 'b?' where the "data type" '?' is a clue that we  * may reverse the sense of the branch (complement lowest order bit)  * and branch around a jump. This is by far the most common case.  * That is why the VIT_OPCODE_SYNTHETIC bit is set: it says this is  * a 0-byte op-code followed by 2 or more bytes of operand address.  *  * If the op-code has VIT_OPCODE_SPECIAL set, then we have a more unusual  * case.  *  * For JBSB& JBR the treatment is the similar, except (1) we have a 'bw'  * option before (2) we can directly JSB/JMP because there is no condition.  * These operands have 'b-' as their access/data type.  *  * That leaves a bunch of random opcodes: JACBx, JxOBxxx. In these  * cases, we do the same idea. JACBxxx are all marked with a 'b!'  * JAOBxxx& JSOBxxx are marked with a 'b:'.  *  */
end_comment

begin_if
if|#
directive|if
operator|(
name|VIT_OPCODE_SYNTHETIC
operator|!=
literal|0x80000000
operator|)
end_if

begin_decl_stmt
name|You
name|have
name|just
name|broken
name|the
name|encoding
name|below
decl_stmt|,
name|which
name|assumes
name|the
name|sign
name|bit
name|means
decl|'I am an imaginary instruction'.
endif|#
directive|endif
if|#
directive|if
operator|(
name|VIT_OPCODE_SPECIAL
operator|!=
literal|0x40000000
operator|)
name|You
name|have
name|just
name|broken
name|the
name|encoding
name|below
decl_stmt|,
name|which
name|assumes
name|the
decl|0x40
name|M
name|bit
name|means
decl|'I am not to be "optimised" the way normal branches are'.
endif|#
directive|endif
decl|static const struct
name|vot
name|synthetic_votstrs
index|[]
init|=
block|{
block|{
literal|"jbsb"
block|,
block|{
literal|"b-"
block|,
literal|0xC0000010
block|}
block|}
block|,
comment|/* BSD 4.2 */
comment|/* jsb used already */
block|{
literal|"jbr"
block|,
block|{
literal|"b-"
block|,
literal|0xC0000011
block|}
block|}
block|,
comment|/* BSD 4.2 */
block|{
literal|"jr"
block|,
block|{
literal|"b-"
block|,
literal|0xC0000011
block|}
block|}
block|,
comment|/* consistent */
block|{
literal|"jneq"
block|,
block|{
literal|"b?"
block|,
literal|0x80000012
block|}
block|}
block|,
block|{
literal|"jnequ"
block|,
block|{
literal|"b?"
block|,
literal|0x80000012
block|}
block|}
block|,
block|{
literal|"jeql"
block|,
block|{
literal|"b?"
block|,
literal|0x80000013
block|}
block|}
block|,
block|{
literal|"jeqlu"
block|,
block|{
literal|"b?"
block|,
literal|0x80000013
block|}
block|}
block|,
block|{
literal|"jgtr"
block|,
block|{
literal|"b?"
block|,
literal|0x80000014
block|}
block|}
block|,
block|{
literal|"jleq"
block|,
block|{
literal|"b?"
block|,
literal|0x80000015
block|}
block|}
block|,
comment|/* un-used opcodes here */
block|{
literal|"jgeq"
block|,
block|{
literal|"b?"
block|,
literal|0x80000018
block|}
block|}
block|,
block|{
literal|"jlss"
block|,
block|{
literal|"b?"
block|,
literal|0x80000019
block|}
block|}
block|,
block|{
literal|"jgtru"
block|,
block|{
literal|"b?"
block|,
literal|0x8000001a
block|}
block|}
block|,
block|{
literal|"jlequ"
block|,
block|{
literal|"b?"
block|,
literal|0x8000001b
block|}
block|}
block|,
block|{
literal|"jvc"
block|,
block|{
literal|"b?"
block|,
literal|0x8000001c
block|}
block|}
block|,
block|{
literal|"jvs"
block|,
block|{
literal|"b?"
block|,
literal|0x8000001d
block|}
block|}
block|,
block|{
literal|"jgequ"
block|,
block|{
literal|"b?"
block|,
literal|0x8000001e
block|}
block|}
block|,
block|{
literal|"jcc"
block|,
block|{
literal|"b?"
block|,
literal|0x8000001e
block|}
block|}
block|,
block|{
literal|"jlssu"
block|,
block|{
literal|"b?"
block|,
literal|0x8000001f
block|}
block|}
block|,
block|{
literal|"jcs"
block|,
block|{
literal|"b?"
block|,
literal|0x8000001f
block|}
block|}
block|,
block|{
literal|"jacbw"
block|,
block|{
literal|"rwrwmwb!"
block|,
literal|0xC000003d
block|}
block|}
block|,
block|{
literal|"jacbf"
block|,
block|{
literal|"rfrfmfb!"
block|,
literal|0xC000004f
block|}
block|}
block|,
block|{
literal|"jacbd"
block|,
block|{
literal|"rdrdmdb!"
block|,
literal|0xC000006f
block|}
block|}
block|,
block|{
literal|"jacbb"
block|,
block|{
literal|"rbrbmbb!"
block|,
literal|0xC000009d
block|}
block|}
block|,
block|{
literal|"jacbl"
block|,
block|{
literal|"rlrlmlb!"
block|,
literal|0xC00000f1
block|}
block|}
block|,
block|{
literal|"jacbg"
block|,
block|{
literal|"rgrgmgb!"
block|,
literal|0xC0004ffd
block|}
block|}
block|,
block|{
literal|"jacbh"
block|,
block|{
literal|"rhrhmhb!"
block|,
literal|0xC0006ffd
block|}
block|}
block|,
block|{
literal|"jbs"
block|,
block|{
literal|"rlvbb?"
block|,
literal|0x800000e0
block|}
block|}
block|,
block|{
literal|"jbc"
block|,
block|{
literal|"rlvbb?"
block|,
literal|0x800000e1
block|}
block|}
block|,
block|{
literal|"jbss"
block|,
block|{
literal|"rlvbb?"
block|,
literal|0x800000e2
block|}
block|}
block|,
block|{
literal|"jbcs"
block|,
block|{
literal|"rlvbb?"
block|,
literal|0x800000e3
block|}
block|}
block|,
block|{
literal|"jbsc"
block|,
block|{
literal|"rlvbb?"
block|,
literal|0x800000e4
block|}
block|}
block|,
block|{
literal|"jbcc"
block|,
block|{
literal|"rlvbb?"
block|,
literal|0x800000e5
block|}
block|}
block|,
block|{
literal|"jbssi"
block|,
block|{
literal|"rlvbb?"
block|,
literal|0x800000e6
block|}
block|}
block|,
block|{
literal|"jbcci"
block|,
block|{
literal|"rlvbb?"
block|,
literal|0x800000e7
block|}
block|}
block|,
block|{
literal|"jlbs"
block|,
block|{
literal|"rlb?"
block|,
literal|0x800000e8
block|}
block|}
block|,
comment|/* JF changed from rlvbb? */
block|{
literal|"jlbc"
block|,
block|{
literal|"rlb?"
block|,
literal|0x800000e9
block|}
block|}
block|,
comment|/* JF changed from rlvbb? */
block|{
literal|"jaoblss"
block|,
block|{
literal|"rlmlb:"
block|,
literal|0xC00000f2
block|}
block|}
block|,
block|{
literal|"jaobleq"
block|,
block|{
literal|"rlmlb:"
block|,
literal|0xC00000f3
block|}
block|}
block|,
block|{
literal|"jsobgeq"
block|,
block|{
literal|"mlb:"
block|,
literal|0xC00000f4
block|}
block|}
block|,
comment|/* JF was rlmlb: */
block|{
literal|"jsobgtr"
block|,
block|{
literal|"mlb:"
block|,
literal|0xC00000f5
block|}
block|}
block|,
comment|/* JF was rlmlb: */
comment|/* CASEx has no branch addresses in our conception of it. */
comment|/* You should use ".word ..." statements after the "case ...". */
block|{
literal|""
block|,
literal|""
block|}
comment|/* empty is end sentinel */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* synthetic_votstrs */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *                  v i p _ b e g i n ( )  *  * Call me once before you decode any lines.  * I decode votstrs into a hash table at op_hash (which I create).  * I return an error text: hopefully "".  * If you want, I will include the 'synthetic' jXXX instructions in the  * instruction table.  * You must nominate metacharacters for eg DEC's "#", "@", "^".  */
end_comment

begin_function
name|char
modifier|*
name|vip_begin
parameter_list|(
name|synthetic_too
parameter_list|,
name|immediate
parameter_list|,
name|indirect
parameter_list|,
name|displen
parameter_list|)
name|int
name|synthetic_too
decl_stmt|;
comment|/* 1 means include jXXX op-codes. */
name|char
modifier|*
name|immediate
decl_stmt|,
decl|*
name|indirect
decl_stmt|,
modifier|*
name|displen
decl_stmt|;
end_function

begin_block
block|{
specifier|const
name|struct
name|vot
modifier|*
name|vP
decl_stmt|;
comment|/* scan votstrs */
name|char
modifier|*
name|retval
decl_stmt|;
comment|/* error text */
if|if
condition|(
operator|(
name|op_hash
operator|=
name|hash_new
argument_list|()
operator|)
condition|)
block|{
name|retval
operator|=
literal|""
expr_stmt|;
comment|/* OK so far */
for|for
control|(
name|vP
operator|=
name|votstrs
init|;
operator|*
name|vP
operator|->
name|vot_name
operator|&&
operator|!
operator|*
name|retval
condition|;
name|vP
operator|++
control|)
block|{
name|retval
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|vP
operator|->
name|vot_name
argument_list|,
operator|&
name|vP
operator|->
name|vot_detail
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|synthetic_too
condition|)
block|{
for|for
control|(
name|vP
operator|=
name|synthetic_votstrs
init|;
operator|*
name|vP
operator|->
name|vot_name
operator|&&
operator|!
operator|*
name|retval
condition|;
name|vP
operator|++
control|)
block|{
name|retval
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|vP
operator|->
name|vot_name
argument_list|,
operator|&
name|vP
operator|->
name|vot_detail
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|retval
operator|=
literal|"virtual memory exceeded"
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CONST_TABLE
name|vip_op_defaults
argument_list|(
name|immediate
argument_list|,
name|indirect
argument_list|,
name|displen
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *                  v i p _ e n d ( )  *  * Call me once after you have decoded all lines.  * I do any cleaning-up needed.  *  * We don't have to do any cleanup ourselves: all of our operand  * symbol table is static, and free()ing it is naughty.  */
end_comment

begin_function
specifier|static
name|void
name|vip_end
parameter_list|()
block|{ }
end_function

begin_comment
comment|/*  *                  v i p ( )  *  * This converts a string into a vax instruction.  * The string must be a bare single instruction in dec-vax (with BSD4 frobs)  * format.  * It provides some error messages: at most one fatal error message (which  * stops the scan) and at most one warning message for each operand.  * The vax instruction is returned in exploded form, since we have no  * knowledge of how you parse (or evaluate) your expressions.  * We do however strip off and decode addressing modes and operation  * mnemonic.  *  * The exploded instruction is returned to a struct vit of your choice.  * #include "vax-inst.h" to know what a struct vit is.  *  * This function's value is a string. If it is not "" then an internal  * logic error was found: read this code to assign meaning to the string.  * No argument string should generate such an error string:  * it means a bug in our code, not in the user's text.  *  * You MUST have called vip_begin() once and vip_end() never before using  * this function.  */
end_comment

begin_function
name|char
modifier|*
comment|/* "" or bug string */
name|vip
parameter_list|(
name|vitP
parameter_list|,
name|instring
parameter_list|)
name|struct
name|vit
modifier|*
name|vitP
decl_stmt|;
comment|/* We build an exploded instruction here. */
name|char
modifier|*
name|instring
decl_stmt|;
comment|/* Text of a vax instruction: we modify. */
block|{
specifier|register
name|struct
name|vot_wot
modifier|*
name|vwP
decl_stmt|;
comment|/* How to bit-encode this opcode. */
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 1/skip whitespace.2/scan vot_how */
specifier|register
name|char
modifier|*
name|q
decl_stmt|;
comment|/*  */
specifier|register
name|char
modifier|*
name|bug
decl_stmt|;
comment|/* "" or program logic error */
specifier|register
name|unsigned
name|char
name|count
decl_stmt|;
comment|/* counts number of operands seen */
specifier|register
name|struct
name|vop
modifier|*
name|operandp
decl_stmt|;
comment|/* scan operands in struct vit */
specifier|register
name|char
modifier|*
name|alloperr
decl_stmt|;
comment|/* error over all operands */
specifier|register
name|char
name|c
decl_stmt|;
comment|/* Remember char, (we clobber it */
comment|/* with '\0' temporarily). */
specifier|register
name|vax_opcodeT
name|oc
decl_stmt|;
comment|/* Op-code of this instruction. */
name|char
modifier|*
name|vip_op
parameter_list|()
function_decl|;
name|bug
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|*
name|instring
operator|==
literal|' '
condition|)
operator|++
name|instring
expr_stmt|;
comment|/* Skip leading whitespace. */
for|for
control|(
name|p
operator|=
name|instring
init|;
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
condition|;
name|p
operator|++
control|)
empty_stmt|;
empty_stmt|;
comment|/* MUST end in end-of-string or exactly 1 space. */
comment|/* Scanned up to end of operation-code. */
comment|/* Operation-code is ended with whitespace. */
if|if
condition|(
name|p
operator|-
name|instring
operator|==
literal|0
condition|)
block|{
name|vitP
operator|->
name|vit_error
operator|=
literal|"No operator"
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|vitP
operator|->
name|vit_opcode
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|vitP
operator|->
name|vit_opcode
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * Here with instring pointing to what better be an op-name, and p 		 * pointing to character just past that. 		 * We trust instring points to an op-name, with no whitespace. 		 */
name|vwP
operator|=
operator|(
expr|struct
name|vot_wot
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|instring
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
comment|/* Restore char after op-code. */
if|if
condition|(
name|vwP
operator|==
literal|0
condition|)
block|{
name|vitP
operator|->
name|vit_error
operator|=
literal|"Unknown operator"
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|vitP
operator|->
name|vit_opcode
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|vitP
operator|->
name|vit_opcode
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We found a match! So lets pick up as many operands as the 			 * instruction wants, and even gripe if there are too many. 			 * We expect comma to seperate each operand. 			 * We let instring track the text, while p tracks a part of the 			 * struct vot. 			 */
comment|/* 			 * The lines below know about 2-byte opcodes starting FD,FE or FF. 			 * They also understand synthetic opcodes. Note: 			 * we return 32 bits of opcode, including bucky bits, BUT 			 * an opcode length is either 8 or 16 bits for vit_opcode_nbytes. 			 */
name|oc
operator|=
name|vwP
operator|->
name|vot_code
expr_stmt|;
comment|/* The op-code. */
name|vitP
operator|->
name|vit_opcode_nbytes
operator|=
operator|(
name|oc
operator|&
literal|0xFF
operator|)
operator|>=
literal|0xFD
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|vitP
operator|->
name|vit_opcode
argument_list|,
name|oc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* no operands seen yet */
name|instring
operator|=
name|p
expr_stmt|;
comment|/* point just past operation code */
name|alloperr
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|p
operator|=
name|vwP
operator|->
name|vot_how
operator|,
name|operandp
operator|=
name|vitP
operator|->
name|vit_operand
init|;
operator|!
operator|*
name|alloperr
operator|&&
operator|!
operator|*
name|bug
operator|&&
operator|*
name|p
condition|;
name|operandp
operator|++
operator|,
name|p
operator|+=
literal|2
control|)
block|{
comment|/* 				 * Here to parse one operand. Leave instring pointing just 				 * past any one ',' that marks the end of this operand. 				 */
if|if
condition|(
operator|!
name|p
index|[
literal|1
index|]
condition|)
name|bug
operator|=
literal|"p"
expr_stmt|;
comment|/* ODD(!!) number of bytes in vot_how?? */
elseif|else
if|if
condition|(
operator|*
name|instring
condition|)
block|{
for|for
control|(
name|q
operator|=
name|instring
init|;
operator|(
name|c
operator|=
operator|*
name|q
operator|)
operator|&&
name|c
operator|!=
literal|','
condition|;
name|q
operator|++
control|)
empty_stmt|;
comment|/* 					 * Q points to ',' or '\0' that ends argument. C is that 					 * character. 					 */
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|operandp
operator|->
name|vop_width
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|operandp
operator|->
name|vop_nbytes
operator|=
name|vax_operand_width_size
index|[
name|p
index|[
literal|1
index|]
index|]
expr_stmt|;
name|operandp
operator|->
name|vop_access
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
name|bug
operator|=
name|vip_op
argument_list|(
name|instring
argument_list|,
name|operandp
argument_list|)
expr_stmt|;
operator|*
name|q
operator|=
name|c
expr_stmt|;
comment|/* Restore input text. */
if|if
condition|(
operator|*
operator|(
name|operandp
operator|->
name|vop_error
operator|)
condition|)
name|alloperr
operator|=
literal|"Bad operand"
expr_stmt|;
name|instring
operator|=
name|q
operator|+
operator|(
name|c
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|/* next operand (if any) */
name|count
operator|++
expr_stmt|;
comment|/*  won another argument, may have an operr */
block|}
else|else
name|alloperr
operator|=
literal|"Not enough operands"
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|alloperr
condition|)
block|{
if|if
condition|(
operator|*
name|instring
operator|==
literal|' '
condition|)
name|instring
operator|++
expr_stmt|;
comment|/* Skip whitespace. */
if|if
condition|(
operator|*
name|instring
condition|)
name|alloperr
operator|=
literal|"Too many operands"
expr_stmt|;
block|}
name|vitP
operator|->
name|vit_error
operator|=
name|alloperr
expr_stmt|;
block|}
block|}
name|vitP
operator|->
name|vit_operands
operator|=
name|count
expr_stmt|;
return|return
operator|(
name|bug
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|test
end_ifdef

begin_comment
comment|/*  * Test program for above.  */
end_comment

begin_decl_stmt
name|struct
name|vit
name|myvit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* build an exploded vax instruction here */
end_comment

begin_decl_stmt
name|char
name|answer
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* human types a line of vax assembler here */
end_comment

begin_decl_stmt
name|char
modifier|*
name|mybug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "" or an internal logic diagnostic */
end_comment

begin_decl_stmt
name|int
name|mycount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of operands */
end_comment

begin_decl_stmt
name|struct
name|vop
modifier|*
name|myvop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scan operands from myvit */
end_comment

begin_decl_stmt
name|int
name|mysynth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 means want synthetic opcodes. */
end_comment

begin_decl_stmt
name|char
name|my_immediate
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|my_indirect
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|my_displen
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|vip
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|main
parameter_list|()
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|vip_begin
parameter_list|()
function_decl|;
name|printf
argument_list|(
literal|"0 means no synthetic instructions.   "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Value for vip_begin?  "
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|answer
argument_list|)
expr_stmt|;
name|sscanf
argument_list|(
name|answer
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|mysynth
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Synthetic opcodes %s be included.\n"
argument_list|,
name|mysynth
condition|?
literal|"will"
else|:
literal|"will not"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"enter immediate symbols eg enter #   "
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|my_immediate
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"enter indirect symbols  eg enter @   "
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|my_indirect
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"enter displen symbols   eg enter ^   "
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|my_displen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|p
operator|=
name|vip_begin
argument_list|(
name|mysynth
argument_list|,
name|my_immediate
argument_list|,
name|my_indirect
argument_list|,
name|my_displen
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"vip_begin=%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"An empty input line will quit you from the vax instruction parser\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"vax instruction: "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|answer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|answer
condition|)
block|{
break|break;
comment|/* out of for each input text loop */
block|}
name|mybug
operator|=
name|vip
argument_list|(
operator|&
name|myvit
argument_list|,
name|answer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mybug
condition|)
block|{
name|printf
argument_list|(
literal|"BUG:\"%s\"\n"
argument_list|,
name|mybug
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|myvit
operator|.
name|vit_error
condition|)
block|{
name|printf
argument_list|(
literal|"ERR:\"%s\"\n"
argument_list|,
name|myvit
operator|.
name|vit_error
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"opcode="
argument_list|)
expr_stmt|;
for|for
control|(
name|mycount
operator|=
name|myvit
operator|.
name|vit_opcode_nbytes
operator|,
name|p
operator|=
name|myvit
operator|.
name|vit_opcode
init|;
name|mycount
condition|;
name|mycount
operator|--
operator|,
name|p
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%02x "
argument_list|,
operator|*
name|p
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"   operand count=%d.\n"
argument_list|,
name|mycount
operator|=
name|myvit
operator|.
name|vit_operands
argument_list|)
expr_stmt|;
for|for
control|(
name|myvop
operator|=
name|myvit
operator|.
name|vit_operand
init|;
name|mycount
condition|;
name|mycount
operator|--
operator|,
name|myvop
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"mode=%xx reg=%xx ndx=%xx len='%c'=%c%c%d. expr=\""
argument_list|,
name|myvop
operator|->
name|vop_mode
argument_list|,
name|myvop
operator|->
name|vop_reg
argument_list|,
name|myvop
operator|->
name|vop_ndx
argument_list|,
name|myvop
operator|->
name|vop_short
argument_list|,
name|myvop
operator|->
name|vop_access
argument_list|,
name|myvop
operator|->
name|vop_width
argument_list|,
name|myvop
operator|->
name|vop_nbytes
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|myvop
operator|->
name|vop_expr_begin
init|;
name|p
operator|<=
name|myvop
operator|->
name|vop_expr_end
condition|;
name|p
operator|++
control|)
block|{
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|myvop
operator|->
name|vop_error
condition|)
block|{
name|printf
argument_list|(
literal|"  err:\"%s\"\n"
argument_list|,
name|myvop
operator|->
name|vop_error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|myvop
operator|->
name|vop_warn
condition|)
block|{
name|printf
argument_list|(
literal|"  wrn:\"%s\"\n"
argument_list|,
name|myvop
operator|->
name|vop_warn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|vip_end
argument_list|()
expr_stmt|;
name|exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #ifdef test */
end_comment

begin_comment
comment|/* end of vax_ins_parse.c */
end_comment

begin_comment
comment|/* JF this used to be a separate file also */
end_comment

begin_comment
comment|/* vax_reg_parse.c - convert a VAX register name to a number */
end_comment

begin_comment
comment|/* Copyright (C) 1987 Free Software Foundation, Inc. A part of GNU. */
end_comment

begin_comment
comment|/*  *          v a x _ r e g _ p a r s e ( )  *  * Take 3 char.s, the last of which may be `\0` (non-existent)  * and return the VAX register number that they represent.  *  * Return -1 if they don't form a register name. Good names return  * a number from 0:15 inclusive.  *  * Case is not important in a name.  *  * Register names understood are:  *  *	R0  *	R1  *	R2  *	R3  *	R4  *	R5  *	R6  * 	R7  *	R8  *	R9  *	R10  *	R11  *	R12	AP  *	R13	FP  *	R14	SP  *	R15	PC  *  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|AP
value|(12)
end_define

begin_define
define|#
directive|define
name|FP
value|(13)
end_define

begin_define
define|#
directive|define
name|SP
value|(14)
end_define

begin_define
define|#
directive|define
name|PC
value|(15)
end_define

begin_escape
end_escape

begin_function
name|int
comment|/* return -1 or 0:15 */
name|vax_reg_parse
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|,
name|c3
parameter_list|)
comment|/* 3 chars of register name */
name|char
name|c1
decl_stmt|,
name|c2
decl_stmt|,
name|c3
decl_stmt|;
comment|/* c3 == 0 if 2-character reg name */
block|{
specifier|register
name|int
name|retval
decl_stmt|;
comment|/* return -1:15 */
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|c1
argument_list|)
condition|)
name|c1
operator|=
name|tolower
argument_list|(
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|c2
argument_list|)
condition|)
name|c2
operator|=
name|tolower
argument_list|(
name|c2
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c2
argument_list|)
operator|&&
name|c1
operator|==
literal|'r'
condition|)
block|{
name|retval
operator|=
name|c2
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c3
argument_list|)
condition|)
block|{
name|retval
operator|=
name|retval
operator|*
literal|10
operator|+
name|c3
operator|-
literal|'0'
expr_stmt|;
name|retval
operator|=
operator|(
name|retval
operator|>
literal|15
operator|)
condition|?
operator|-
literal|1
else|:
name|retval
expr_stmt|;
comment|/* clamp the register value to 1 hex digit */
block|}
elseif|else
if|if
condition|(
name|c3
condition|)
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* c3 must be '\0' or a digit */
block|}
elseif|else
if|if
condition|(
name|c3
condition|)
comment|/* There are no three letter regs */
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|c2
operator|==
literal|'p'
condition|)
block|{
switch|switch
condition|(
name|c1
condition|)
block|{
case|case
literal|'s'
case|:
name|retval
operator|=
name|SP
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|retval
operator|=
name|FP
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|retval
operator|=
name|AP
expr_stmt|;
break|break;
default|default:
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c1
operator|==
literal|'p'
operator|&&
name|c2
operator|==
literal|'c'
condition|)
name|retval
operator|=
name|PC
expr_stmt|;
else|else
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *               v i p _ o p ( )  *  * Parse a vax operand in DEC assembler notation.  * For speed, expect a string of whitespace to be reduced to a single ' '.  * This is the case for GNU AS, and is easy for other DEC-compatible  * assemblers.  *  * Knowledge about DEC VAX assembler operand notation lives here.  * This doesn't even know what a register name is, except it believes  * all register names are 2 or 3 characters, and lets vax_reg_parse() say  * what number each name represents.  * It does, however, know that PC, SP etc are special registers so it can  * detect addressing modes that are silly for those registers.  *  * Where possible, it delivers 1 fatal or 1 warning message if the operand  * is suspect. Exactly what we test for is still evolving.  */
end_comment

begin_comment
comment|/*  *		   	B u g s  *  *	Arg block.  *  * There were a number of 'mismatched argument type' bugs to vip_op.  * The most general solution is to typedef each (of many) arguments.  * We used instead a typedef'd argument block. This is less modular  * than using seperate return pointers for each result, but runs faster  * on most engines, and seems to keep programmers happy. It will have  * to be done properly if we ever want to use vip_op as a general-purpose  * module (it was designed to be).  *  *	G^  *  * Doesn't support DEC "G^" format operands. These always take 5 bytes  * to express, and code as modes 8F or 9F. Reason: "G^" deprives you of  * optimising to (say) a "B^" if you are lucky in the way you link.  * When someone builds a linker smart enough to convert "G^" to "B^", "W^"  * whenever possible, then we should implement it.  * If there is some other use for "G^", feel free to code it in!  *  *  *	speed  *  * If I nested if ()s more, I could avoid testing (*err) which would save  * time, space and page faults. I didn't nest all those if ()s for clarity  * and because I think the mode testing can be re-arranged 1st to test the  * commoner constructs 1st. Does anybody have statistics on this?  *  *  *  *	error messages  *  * In future, we should be able to 'compose' error messages in a scratch area  * and give the user MUCH more informative error messages. Although this takes  * a little more code at run-time, it will make this module much more self-  * documenting. As an example of what sucks now: most error messages have  * hardwired into them the DEC VAX metacharacters "#^@" which are nothing like  * the Un*x characters "$`*", that most users will expect from this AS.  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * The input is a string, ending with '\0'.  *  * We also require a 'hint' of what kind of operand is expected: so  * we can remind caller not to write into literals for instance.  *  * The output is a skeletal instruction.  *  * The algorithm has two parts.  * 1. extract the syntactic features (parse off all the @^#-()+[] mode crud);  * 2. express the @^#-()+[] as some parameters suited to further analysis.  *  * 2nd step is where we detect the googles of possible invalid combinations  * a human (or compiler) might write. Note that if we do a half-way  * decent assembler, we don't know how long to make (eg) displacement  * fields when we first meet them (because they may not have defined values).  * So we must wait until we know how many bits are needed for each address,  * then we can know both length and opcodes of instructions.  * For reason(s) above, we will pass to our caller a 'broken' instruction  * of these major components, from which our caller can generate instructions:  *  -  displacement length      I^ S^ L^ B^ W^ unspecified  *  -  mode                     (many)  *  -  register                 R0-R15 or absent  *  -  index register           R0-R15 or absent  *  -  expression text          what we don't parse  *  -  error text(s)            why we couldn't understand the operand  */
end_comment

begin_comment
comment|/*  * To decode output of this, test errtxt. If errtxt[0] == '\0', then  * we had no errors that prevented parsing. Also, if we ever report  * an internal bug, errtxt[0] is set non-zero. So one test tells you  * if the other outputs are to be taken seriously.  */
end_comment

begin_comment
comment|/* vax registers we need to know */
end_comment

begin_comment
comment|/* JF #define SP      (14) */
end_comment

begin_comment
comment|/* JF for one big happy file #define PC      (15) */
end_comment

begin_comment
comment|/*  * Because this module is useful for both VMS and UN*X style assemblers  * and because of the variety of UN*X assemblers we must recognise  * the different conventions for assembler operand notation. For example  * VMS says "#42" for immediate mode, while most UN*X say "$42".  * We permit arbitrary sets of (single) characters to represent the  * 3 concepts that DEC writes '#', '@', '^'.  */
end_comment

begin_comment
comment|/* character tests */
end_comment

begin_define
define|#
directive|define
name|VIP_IMMEDIATE
value|01
end_define

begin_comment
comment|/* Character is like DEC # */
end_comment

begin_define
define|#
directive|define
name|VIP_INDIRECT
value|02
end_define

begin_comment
comment|/* Char is like DEC @ */
end_comment

begin_define
define|#
directive|define
name|VIP_DISPLEN
value|04
end_define

begin_comment
comment|/* Char is like DEC ^ */
end_comment

begin_define
define|#
directive|define
name|IMMEDIATEP
parameter_list|(
name|c
parameter_list|)
value|(vip_metacharacters[(c)&0xff]&VIP_IMMEDIATE)
end_define

begin_define
define|#
directive|define
name|INDIRECTP
parameter_list|(
name|c
parameter_list|)
value|(vip_metacharacters[(c)&0xff]&VIP_INDIRECT)
end_define

begin_define
define|#
directive|define
name|DISPLENP
parameter_list|(
name|c
parameter_list|)
value|(vip_metacharacters[(c)&0xff]&VIP_DISPLEN)
end_define

begin_comment
comment|/* We assume 8 bits per byte. Use vip_op_defaults() to set these up BEFORE we  * are ever called.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONST_TABLE
argument_list|)
end_if

begin_define
define|#
directive|define
name|_
value|0,
end_define

begin_define
define|#
directive|define
name|I
value|VIP_IMMEDIATE,
end_define

begin_define
define|#
directive|define
name|S
value|VIP_INDIRECT,
end_define

begin_define
define|#
directive|define
name|D
value|VIP_DISPLEN,
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|vip_metacharacters
index|[
literal|256
index|]
init|=
block|{
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
comment|/* ^@ ^A ^B ^C ^D ^E ^F ^G ^H ^I ^J ^K ^L ^M ^N ^O*/
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
comment|/* ^P ^Q ^R ^S ^T ^U ^V ^W ^X ^Y ^Z ^[ ^\ ^] ^^ ^_ */
name|_
name|_
name|_
name|_
name|I
name|_
name|_
name|_
name|_
name|_
name|S
name|_
name|_
name|_
name|_
name|_
comment|/* sp !  "  #  $  %& '  (  )  *  +  ,  -  .  / */
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
comment|/*0  1  2  3  4  5  6  7  8  9  :  ;<  =>  ?*/
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
comment|/*@  A  B  C  D  E  F  G  H  I  J  K  L  M  N  O*/
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
comment|/*P  Q  R  S  T  U  V  W  X  Y  Z  [  \  ]  ^  _*/
name|D
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
comment|/*`  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o*/
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
comment|/*p  q  r  s  t  u  v  w  x  y  z  {  |  }  ~  ^?*/
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
name|_
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|_
end_undef

begin_undef
undef|#
directive|undef
name|I
end_undef

begin_undef
undef|#
directive|undef
name|S
end_undef

begin_undef
undef|#
directive|undef
name|D
end_undef

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
name|vip_metacharacters
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro is faster under GCC;  The constant table is faster yet, but only works with ASCII */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifdef
unit|static
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_endif
unit|inline
endif|#
directive|endif
end_endif

begin_else
unit|static void     vip_op_1(bit,syms) int bit; char *syms; { 	unsigned char t;  	while (t= *syms++) 	    vip_metacharacters[t]|=bit; }
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|vip_op_1
parameter_list|(
name|bit
parameter_list|,
name|syms
parameter_list|)
value|{		\ 					    unsigned char t;			\ 						char *table=vip_metacharacters;	\ 						    while (t= *syms++)			\ 							table[t]|=bit;			\ 						    }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|vip_op_defaults
parameter_list|(
name|immediate
parameter_list|,
name|indirect
parameter_list|,
name|displen
parameter_list|)
comment|/* can be called any time */
name|char
modifier|*
name|immediate
decl_stmt|;
comment|/* Strings of characters for each job. */
name|char
modifier|*
name|indirect
decl_stmt|;
name|char
modifier|*
name|displen
decl_stmt|;
comment|/* more arguments may appear in future! */
block|{
name|vip_op_1
argument_list|(
name|VIP_IMMEDIATE
argument_list|,
name|immediate
argument_list|)
expr_stmt|;
name|vip_op_1
argument_list|(
name|VIP_INDIRECT
argument_list|,
name|indirect
argument_list|)
expr_stmt|;
name|vip_op_1
argument_list|(
name|VIP_DISPLEN
argument_list|,
name|displen
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*  * Dec defines the semantics of address modes (and values)  * by a two-letter code, explained here.  *  *   letter 1:   access type  *  *     a         address calculation - no data access, registers forbidden  *     b         branch displacement  *     m         read - let go of bus - write back    "modify"  *     r         read  *     v         bit field address: like 'a' but registers are OK  *     w         write  *     space	 no operator (eg ".long foo") [our convention]  *  *   letter 2:   data type (i.e. width, alignment)  *  *     b         byte  *     d         double precision floating point (D format)  *     f         single precision floating point (F format)  *     g         G format floating  *     h         H format floating  *     l         longword  *     o         octaword  *     q         quadword  *     w         word  *     ?	 simple synthetic branch operand  *     -	 unconditional synthetic JSB/JSR operand  *     !	 complex synthetic branch operand  *  * The '-?!' letter 2's are not for external consumption. They are used  * for various assemblers. Generally, all unknown widths are assumed 0.  * We don't limit your choice of width character.  *  * DEC operands are hard work to parse. For example, '@' as the first  * character means indirect (deferred) mode but elswhere it is a shift  * operator.  * The long-winded explanation of how this is supposed to work is  * cancelled. Read a DEC vax manual.  * We try hard not to parse anything that MIGHT be part of the expression  * buried in that syntax. For example if we see @...(Rn) we don't check  * for '-' before the '(' because mode @-(Rn) does not exist.  *  * After parsing we have:  *  * at                     1 if leading '@' (or Un*x '*')  * len                    takes one value from " bilsw". eg B^ -> 'b'.  * hash                   1 if leading '#' (or Un*x '$')  * expr_begin, expr_end   the expression we did not parse  *                        even though we don't interpret it, we make use  *                        of its presence or absence.  * sign                   -1: -(Rn)    0: absent    +1: (Rn)+  * paren                  1 if () are around register  * reg                    major register number 0:15    -1 means absent  * ndx                    index register number 0:15    -1 means absent  *  * Again, I dare not explain it: just trace ALL the code!  */
end_comment

begin_escape
end_escape

begin_function
name|char
modifier|*
comment|/* (code here) bug message, "" = OK */
comment|/* our code bug, NOT bad assembly language */
name|vip_op
parameter_list|(
name|optext
parameter_list|,
name|vopP
parameter_list|)
name|char
modifier|*
name|optext
decl_stmt|;
comment|/* user's input string e.g.: */
comment|/* "@B^foo@bar(AP)[FP]:" */
name|struct
name|vop
modifier|*
name|vopP
decl_stmt|;
comment|/* In: vop_access, vop_width. */
comment|/* Out: _ndx, _reg, _mode, _short, _warn, */
comment|/* _error _expr_begin, _expr_end, _nbytes. */
comment|/* vop_nbytes : number of bytes in a datum. */
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* track operand text forward */
name|char
modifier|*
name|q
decl_stmt|;
comment|/* track operand text backward */
name|int
name|at
decl_stmt|;
comment|/* 1 if leading '@' ('*') seen */
name|char
name|len
decl_stmt|;
comment|/* one of " bilsw" */
name|int
name|hash
decl_stmt|;
comment|/* 1 if leading '#' ('$') seen */
name|int
name|sign
init|=
literal|0
decl_stmt|;
comment|/* -1, 0 or +1 */
name|int
name|paren
init|=
literal|0
decl_stmt|;
comment|/* 1 if () surround register */
name|int
name|reg
init|=
literal|0
decl_stmt|;
comment|/* register number, -1:absent */
name|int
name|ndx
init|=
literal|0
decl_stmt|;
comment|/* index register number -1:absent */
name|char
modifier|*
name|bug
decl_stmt|;
comment|/* report any logic error in here, "" == OK */
name|char
modifier|*
name|err
decl_stmt|;
comment|/* report illegal operand, "" == OK */
comment|/* " " is a FAKE error: means we won */
comment|/* ANY err that begins with ' ' is a fake. */
comment|/* " " is converted to "" before return */
name|char
modifier|*
name|wrn
decl_stmt|;
comment|/* warn about weird modes pf address */
name|char
modifier|*
name|oldq
init|=
name|NULL
decl_stmt|;
comment|/* preserve q in case we backup */
name|int
name|mode
init|=
literal|0
decl_stmt|;
comment|/* build up 4-bit operand mode here */
comment|/* note: index mode is in ndx, this is */
comment|/* the major mode of operand address */
comment|/* 	 * Notice how we move wrong-arg-type bugs INSIDE this module: if we 	 * get the types wrong below, we lose at compile time rather than at 	 * lint or run time. 	 */
name|char
name|access
decl_stmt|;
comment|/* vop_access. */
name|char
name|width
decl_stmt|;
comment|/* vop_width. */
name|int
name|vax_reg_parse
parameter_list|()
function_decl|;
comment|/* returns 0:15 or -1 if not a register */
name|access
operator|=
name|vopP
operator|->
name|vop_access
expr_stmt|;
name|width
operator|=
name|vopP
operator|->
name|vop_width
expr_stmt|;
name|bug
operator|=
comment|/* none of our code bugs (yet) */
name|err
operator|=
comment|/* no user text errors */
name|wrn
operator|=
literal|""
expr_stmt|;
comment|/* no warnings even */
name|p
operator|=
name|optext
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
comment|/* Expect all whitespace reduced to ' '. */
name|p
operator|++
expr_stmt|;
comment|/* skip over whitespace */
if|if
condition|(
name|at
operator|=
name|INDIRECTP
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
comment|/* 1 if *p == '@'(or '*' for Un*x) */
name|p
operator|++
expr_stmt|;
comment|/* at is determined */
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
comment|/* Expect all whitespace reduced to ' '. */
name|p
operator|++
expr_stmt|;
comment|/* skip over whitespace */
block|}
comment|/* 	 * This code is subtle. It tries to detect all legal (letter)'^' 	 * but it doesn't waste time explicitly testing for premature '\0' because 	 * this case is rejected as a mismatch against either (letter) or '^'. 	 */
block|{
specifier|register
name|char
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|DISPLENP
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
operator|&&
name|strchr
argument_list|(
literal|"bilws"
argument_list|,
name|len
operator|=
name|c
argument_list|)
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* skip (letter) '^' */
else|else
comment|/* no (letter) '^' seen */
name|len
operator|=
literal|' '
expr_stmt|;
comment|/* len is determined */
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
comment|/* Expect all whitespace reduced to ' '. */
name|p
operator|++
expr_stmt|;
comment|/* skip over whitespace */
if|if
condition|(
name|hash
operator|=
name|IMMEDIATEP
argument_list|(
operator|*
name|p
argument_list|)
condition|)
comment|/* 1 if *p == '#' ('$' for Un*x) */
name|p
operator|++
expr_stmt|;
comment|/* hash is determined */
comment|/* 	 * p points to what may be the beginning of an expression. 	 * We have peeled off the front all that is peelable. 	 * We know at, len, hash. 	 * 	 * Lets point q at the end of the text and parse that (backwards). 	 */
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
empty_stmt|;
name|q
operator|--
expr_stmt|;
comment|/* now q points at last char of text */
if|if
condition|(
operator|*
name|q
operator|==
literal|' '
operator|&&
name|q
operator|>=
name|p
condition|)
comment|/* Expect all whitespace reduced to ' '. */
name|q
operator|--
expr_stmt|;
comment|/* reverse over whitespace, but don't */
comment|/* run back over *p */
comment|/* 	 * As a matter of policy here, we look for [Rn], although both Rn and S^# 	 * forbid [Rn]. This is because it is easy, and because only a sick 	 * cyborg would have [...] trailing an expression in a VAX-like assembler. 	 * A meticulous parser would first check for Rn followed by '(' or '[' 	 * and not parse a trailing ']' if it found another. We just ban expressions 	 * ending in ']'. 	 */
if|if
condition|(
operator|*
name|q
operator|==
literal|']'
condition|)
block|{
while|while
condition|(
name|q
operator|>=
name|p
operator|&&
operator|*
name|q
operator|!=
literal|'['
condition|)
name|q
operator|--
expr_stmt|;
comment|/* either q<p or we got matching '[' */
if|if
condition|(
name|q
operator|<
name|p
condition|)
name|err
operator|=
literal|"no '[' to match ']'"
expr_stmt|;
else|else
block|{
comment|/* 			 * Confusers like "[]" will eventually lose with a bad register 			 * name error. So again we don't need to check for early '\0'. 			 */
if|if
condition|(
name|q
index|[
literal|3
index|]
operator|==
literal|']'
condition|)
name|ndx
operator|=
name|vax_reg_parse
argument_list|(
name|q
index|[
literal|1
index|]
argument_list|,
name|q
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|q
index|[
literal|4
index|]
operator|==
literal|']'
condition|)
name|ndx
operator|=
name|vax_reg_parse
argument_list|(
name|q
index|[
literal|1
index|]
argument_list|,
name|q
index|[
literal|2
index|]
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
else|else
name|ndx
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 			 * Since we saw a ']' we will demand a register name in the []. 			 * If luser hasn't given us one: be rude. 			 */
if|if
condition|(
name|ndx
operator|<
literal|0
condition|)
name|err
operator|=
literal|"bad register in []"
expr_stmt|;
elseif|else
if|if
condition|(
name|ndx
operator|==
name|PC
condition|)
name|err
operator|=
literal|"[PC] index banned"
expr_stmt|;
else|else
name|q
operator|--
expr_stmt|;
comment|/* point q just before "[...]" */
block|}
block|}
else|else
name|ndx
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no ']', so no iNDeX register */
comment|/* 	 * If err = "..." then we lost: run away. 	 * Otherwise ndx == -1 if there was no "[...]". 	 * Otherwise, ndx is index register number, and q points before "[...]". 	 */
if|if
condition|(
operator|*
name|q
operator|==
literal|' '
operator|&&
name|q
operator|>=
name|p
condition|)
comment|/* Expect all whitespace reduced to ' '. */
name|q
operator|--
expr_stmt|;
comment|/* reverse over whitespace, but don't */
comment|/* run back over *p */
if|if
condition|(
operator|!
operator|*
name|err
condition|)
block|{
name|sign
operator|=
literal|0
expr_stmt|;
comment|/* no ()+ or -() seen yet */
if|if
condition|(
name|q
operator|>
name|p
operator|+
literal|3
operator|&&
operator|*
name|q
operator|==
literal|'+'
operator|&&
name|q
index|[
operator|-
literal|1
index|]
operator|==
literal|')'
condition|)
block|{
name|sign
operator|=
literal|1
expr_stmt|;
comment|/* we saw a ")+" */
name|q
operator|--
expr_stmt|;
comment|/* q points to ')' */
block|}
if|if
condition|(
operator|*
name|q
operator|==
literal|')'
operator|&&
name|q
operator|>
name|p
operator|+
literal|2
condition|)
block|{
name|paren
operator|=
literal|1
expr_stmt|;
comment|/* assume we have "(...)" */
while|while
condition|(
name|q
operator|>=
name|p
operator|&&
operator|*
name|q
operator|!=
literal|'('
condition|)
name|q
operator|--
expr_stmt|;
comment|/* either q<p or we got matching '(' */
if|if
condition|(
name|q
operator|<
name|p
condition|)
name|err
operator|=
literal|"no '(' to match ')'"
expr_stmt|;
else|else
block|{
comment|/* 				 * Confusers like "()" will eventually lose with a bad register 				 * name error. So again we don't need to check for early '\0'. 				 */
if|if
condition|(
name|q
index|[
literal|3
index|]
operator|==
literal|')'
condition|)
name|reg
operator|=
name|vax_reg_parse
argument_list|(
name|q
index|[
literal|1
index|]
argument_list|,
name|q
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|q
index|[
literal|4
index|]
operator|==
literal|')'
condition|)
name|reg
operator|=
name|vax_reg_parse
argument_list|(
name|q
index|[
literal|1
index|]
argument_list|,
name|q
index|[
literal|2
index|]
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
else|else
name|reg
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 				 * Since we saw a ')' we will demand a register name in the ')'. 				 * This is nasty: why can't our hypothetical assembler permit 				 * parenthesised expressions? BECAUSE I AM LAZY! That is why. 				 * Abuse luser if we didn't spy a register name. 				 */
if|if
condition|(
name|reg
operator|<
literal|0
condition|)
block|{
comment|/* JF allow parenthasized expressions.  I hope this works */
name|paren
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|')'
condition|)
name|q
operator|++
expr_stmt|;
comment|/* err = "unknown register in ()"; */
block|}
else|else
name|q
operator|--
expr_stmt|;
comment|/* point just before '(' of "(...)" */
comment|/* 				 * If err == "..." then we lost. Run away. 				 * Otherwise if reg>= 0 then we saw (Rn). 				 */
block|}
comment|/* 			 * If err == "..." then we lost. 			 * Otherwise paren == 1 and reg = register in "()". 			 */
block|}
else|else
name|paren
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If err == "..." then we lost. 		 * Otherwise, q points just before "(Rn)", if any. 		 * If there was a "(...)" then paren == 1, and reg is the register. 		 */
comment|/* 		 * We should only seek '-' of "-(...)" if: 		 *   we saw "(...)"                    paren == 1 		 *   we have no errors so far          ! *err 		 *   we did not see '+' of "(...)+"    sign< 1 		 * We don't check len. We want a specific error message later if 		 * user tries "x^...-(Rn)". This is a feature not a bug. 		 */
if|if
condition|(
operator|!
operator|*
name|err
condition|)
block|{
if|if
condition|(
name|paren
operator|&&
name|sign
operator|<
literal|1
condition|)
comment|/* !sign is adequate test */
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|--
expr_stmt|;
block|}
block|}
comment|/* 			 * We have back-tracked over most 			 * of the crud at the end of an operand. 			 * Unless err, we know: sign, paren. If paren, we know reg. 			 * The last case is of an expression "Rn". 			 * This is worth hunting for if !err, !paren. 			 * We wouldn't be here if err. 			 * We remember to save q, in case we didn't want "Rn" anyway. 			 */
if|if
condition|(
operator|!
name|paren
condition|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|' '
operator|&&
name|q
operator|>=
name|p
condition|)
comment|/* Expect all whitespace reduced to ' '. */
name|q
operator|--
expr_stmt|;
comment|/* reverse over whitespace, but don't */
comment|/* run back over *p */
if|if
condition|(
name|q
operator|>
name|p
operator|&&
name|q
operator|<
name|p
operator|+
literal|3
condition|)
comment|/* room for Rn or Rnn exactly? */
name|reg
operator|=
name|vax_reg_parse
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|q
operator|<
name|p
operator|+
literal|2
condition|?
literal|0
else|:
name|p
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|reg
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* always comes here if no register at all */
comment|/* 				 * Here with a definitive reg value. 				 */
if|if
condition|(
name|reg
operator|>=
literal|0
condition|)
block|{
name|oldq
operator|=
name|q
expr_stmt|;
name|q
operator|=
name|p
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * have reg. -1:absent; else 0:15 	 */
comment|/* 	 * We have:  err, at, len, hash, ndx, sign, paren, reg. 	 * Also, any remaining expression is from *p through *q inclusive. 	 * Should there be no expression, q == p-1. So expression length = q-p+1. 	 * This completes the first part: parsing the operand text. 	 */
comment|/* 	 * We now want to boil the data down, checking consistency on the way. 	 * We want:  len, mode, reg, ndx, err, p, q, wrn, bug. 	 * We will deliver a 4-bit reg, and a 4-bit mode. 	 */
comment|/* 	 * Case of branch operand. Different. No L^B^W^I^S^ allowed for instance. 	 * 	 * in:  at	? 	 *      len	? 	 *      hash	? 	 *      p:q	? 	 *      sign  ? 	 *      paren	? 	 *      reg   ? 	 *      ndx   ? 	 * 	 * out: mode  0 	 *      reg   -1 	 *      len	' ' 	 *      p:q	whatever was input 	 *      ndx	-1 	 *      err	" "		 or error message, and other outputs trashed 	 */
comment|/* branch operands have restricted forms */
if|if
condition|(
operator|!
operator|*
name|err
operator|&&
name|access
operator|==
literal|'b'
condition|)
block|{
if|if
condition|(
name|at
operator|||
name|hash
operator|||
name|sign
operator|||
name|paren
operator|||
name|ndx
operator|>=
literal|0
operator|||
name|reg
operator|>=
literal|0
operator|||
name|len
operator|!=
literal|' '
condition|)
name|err
operator|=
literal|"invalid branch operand"
expr_stmt|;
else|else
name|err
operator|=
literal|" "
expr_stmt|;
block|}
comment|/* Since nobody seems to use it: comment this 'feature'(?) out for now. */
ifdef|#
directive|ifdef
name|NEVER
comment|/* 	 * Case of stand-alone operand. e.g. ".long foo" 	 * 	 * in:  at	? 	 *      len	? 	 *      hash	? 	 *      p:q	? 	 *      sign  ? 	 *      paren	? 	 *      reg   ? 	 *      ndx   ? 	 * 	 * out: mode  0 	 *      reg   -1 	 *      len	' ' 	 *      p:q	whatever was input 	 *      ndx	-1 	 *      err	" "		 or error message, and other outputs trashed 	 */
if|if
condition|(
operator|!
operator|*
name|err
condition|)
block|{
if|if
condition|(
name|access
operator|==
literal|' '
condition|)
block|{
comment|/* addresses have restricted forms */
if|if
condition|(
name|at
condition|)
name|err
operator|=
literal|"address prohibits @"
expr_stmt|;
else|else
block|{
if|if
condition|(
name|hash
condition|)
name|err
operator|=
literal|"address prohibits #"
expr_stmt|;
else|else
block|{
if|if
condition|(
name|sign
condition|)
block|{
if|if
condition|(
name|sign
operator|<
literal|0
condition|)
name|err
operator|=
literal|"address prohibits -()"
expr_stmt|;
else|else
name|err
operator|=
literal|"address prohibits ()+"
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|paren
condition|)
name|err
operator|=
literal|"address prohibits ()"
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ndx
operator|>=
literal|0
condition|)
name|err
operator|=
literal|"address prohibits []"
expr_stmt|;
else|else
block|{
if|if
condition|(
name|reg
operator|>=
literal|0
condition|)
name|err
operator|=
literal|"address prohibits register"
expr_stmt|;
else|else
block|{
if|if
condition|(
name|len
operator|!=
literal|' '
condition|)
name|err
operator|=
literal|"address prohibits displacement length specifier"
expr_stmt|;
else|else
block|{
name|err
operator|=
literal|" "
expr_stmt|;
comment|/* succeed */
name|mode
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|/*#Ifdef NEVER*/
comment|/* 	 * Case of S^#. 	 * 	 * in:  at       0 	 *      len      's'               definition 	 *      hash     1              demand 	 *      p:q                        demand not empty 	 *      sign     0                 by paren == 0 	 *      paren    0             by "()" scan logic because "S^" seen 	 *      reg      -1                or nn by mistake 	 *      ndx      -1 	 * 	 * out: mode     0 	 *      reg      -1 	 *      len      's' 	 *      exp 	 *      ndx      -1 	 */
if|if
condition|(
operator|!
operator|*
name|err
operator|&&
name|len
operator|==
literal|'s'
condition|)
block|{
if|if
condition|(
operator|!
name|hash
operator|||
name|paren
operator|||
name|at
operator|||
name|ndx
operator|>=
literal|0
condition|)
name|err
operator|=
literal|"invalid operand of S^#"
expr_stmt|;
else|else
block|{
if|if
condition|(
name|reg
operator|>=
literal|0
condition|)
block|{
comment|/* 				 * SHIT! we saw S^#Rnn ! put the Rnn back in 				 * expression. KLUDGE! Use oldq so we don't 				 * need to know exact length of reg name. 				 */
name|q
operator|=
name|oldq
expr_stmt|;
name|reg
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 			 * We have all the expression we will ever get. 			 */
if|if
condition|(
name|p
operator|>
name|q
condition|)
name|err
operator|=
literal|"S^# needs expression"
expr_stmt|;
elseif|else
if|if
condition|(
name|access
operator|==
literal|'r'
condition|)
block|{
name|err
operator|=
literal|" "
expr_stmt|;
comment|/* WIN! */
name|mode
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|err
operator|=
literal|"S^# may only read-access"
expr_stmt|;
block|}
block|}
comment|/* 	 * Case of -(Rn), which is weird case. 	 * 	 * in:  at       0 	 *      len      ' 	 *      hash     0 	 *      p:q      q<p 	 *      sign     -1                by definition 	 *      paren    1              by definition 	 *      reg      present           by definition 	 *      ndx      optional 	 * 	 * out: mode     7 	 *      reg      present 	 *      len      ' ' 	 *      exp      ""                enforce empty expression 	 *      ndx      optional          warn if same as reg 	 */
if|if
condition|(
operator|!
operator|*
name|err
operator|&&
name|sign
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|!=
literal|' '
operator|||
name|hash
operator|||
name|at
operator|||
name|p
operator|<=
name|q
condition|)
name|err
operator|=
literal|"invalid operand of -()"
expr_stmt|;
else|else
block|{
name|err
operator|=
literal|" "
expr_stmt|;
comment|/* win */
name|mode
operator|=
literal|7
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|PC
condition|)
name|wrn
operator|=
literal|"-(PC) unpredictable"
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|==
name|ndx
condition|)
name|wrn
operator|=
literal|"[]index same as -()register: unpredictable"
expr_stmt|;
block|}
block|}
comment|/* 	 * We convert "(Rn)" to "@Rn" for our convenience. 	 * (I hope this is convenient: has someone got a better way to parse this?) 	 * A side-effect of this is that "@Rn" is a valid operand. 	 */
if|if
condition|(
name|paren
operator|&&
operator|!
name|sign
operator|&&
operator|!
name|hash
operator|&&
operator|!
name|at
operator|&&
name|len
operator|==
literal|' '
operator|&&
name|p
operator|>
name|q
condition|)
block|{
name|at
operator|=
literal|1
expr_stmt|;
name|paren
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Case of (Rn)+, which is slightly different. 	 * 	 * in:  at 	 *      len      ' ' 	 *      hash     0 	 *      p:q      q<p 	 *      sign     +1                by definition 	 *      paren    1              by definition 	 *      reg      present           by definition 	 *      ndx      optional 	 * 	 * out: mode     8+@ 	 *      reg      present 	 *      len      ' ' 	 *      exp      ""                enforce empty expression 	 *      ndx      optional          warn if same as reg 	 */
if|if
condition|(
operator|!
operator|*
name|err
operator|&&
name|sign
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|!=
literal|' '
operator|||
name|hash
operator|||
name|p
operator|<=
name|q
condition|)
name|err
operator|=
literal|"invalid operand of ()+"
expr_stmt|;
else|else
block|{
name|err
operator|=
literal|" "
expr_stmt|;
comment|/* win */
name|mode
operator|=
literal|8
operator|+
operator|(
name|at
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|PC
condition|)
name|wrn
operator|=
literal|"(PC)+ unpredictable"
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|==
name|ndx
condition|)
name|wrn
operator|=
literal|"[]index same as ()+register: unpredictable"
expr_stmt|;
block|}
block|}
comment|/* 	 * Case of #, without S^. 	 * 	 * in:  at 	 *      len      ' ' or 'i' 	 *      hash     1              by definition 	 *      p:q 	 *      sign     0 	 *      paren    0 	 *      reg      absent 	 *      ndx      optional 	 * 	 * out: mode     8+@ 	 *      reg      PC 	 *      len      ' ' or 'i' 	 *      exp 	 *      ndx      optional 	 */
if|if
condition|(
operator|!
operator|*
name|err
operator|&&
name|hash
condition|)
block|{
if|if
condition|(
name|len
operator|!=
literal|'i'
operator|&&
name|len
operator|!=
literal|' '
condition|)
name|err
operator|=
literal|"# conflicts length"
expr_stmt|;
elseif|else
if|if
condition|(
name|paren
condition|)
name|err
operator|=
literal|"# bars register"
expr_stmt|;
else|else
block|{
if|if
condition|(
name|reg
operator|>=
literal|0
condition|)
block|{
comment|/* 				 * SHIT! we saw #Rnn! Put the Rnn back into the expression. 				 * By using oldq, we don't need to know how long Rnn was. 				 * KLUDGE! 				 */
name|q
operator|=
name|oldq
expr_stmt|;
name|reg
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no register any more */
block|}
name|err
operator|=
literal|" "
expr_stmt|;
comment|/* win */
comment|/* JF a bugfix, I think! */
if|if
condition|(
name|at
operator|&&
name|access
operator|==
literal|'a'
condition|)
name|vopP
operator|->
name|vop_nbytes
operator|=
literal|4
expr_stmt|;
name|mode
operator|=
operator|(
name|at
condition|?
literal|9
else|:
literal|8
operator|)
expr_stmt|;
name|reg
operator|=
name|PC
expr_stmt|;
if|if
condition|(
operator|(
name|access
operator|==
literal|'m'
operator|||
name|access
operator|==
literal|'w'
operator|)
operator|&&
operator|!
name|at
condition|)
name|wrn
operator|=
literal|"writing or modifying # is unpredictable"
expr_stmt|;
block|}
block|}
comment|/* 	 * If !*err, then        sign == 0 	 *                       hash == 0 	 */
comment|/* 	 * Case of Rn. We seperate this one because it has a few special 	 * errors the remaining modes lack. 	 * 	 * in:  at       optional 	 *      len      ' ' 	 *      hash     0             by program logic 	 *      p:q      empty 	 *      sign     0                 by program logic 	 *      paren    0             by definition 	 *      reg      present           by definition 	 *      ndx      optional 	 * 	 * out: mode     5+@ 	 *      reg      present 	 *      len      ' '               enforce no length 	 *      exp      ""                enforce empty expression 	 *      ndx      optional          warn if same as reg 	 */
if|if
condition|(
operator|!
operator|*
name|err
operator|&&
operator|!
name|paren
operator|&&
name|reg
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|!=
literal|' '
condition|)
name|err
operator|=
literal|"length not needed"
expr_stmt|;
elseif|else
if|if
condition|(
name|at
condition|)
block|{
name|err
operator|=
literal|" "
expr_stmt|;
comment|/* win */
name|mode
operator|=
literal|6
expr_stmt|;
comment|/* @Rn */
block|}
elseif|else
if|if
condition|(
name|ndx
operator|>=
literal|0
condition|)
name|err
operator|=
literal|"can't []index a register, because it has no address"
expr_stmt|;
elseif|else
if|if
condition|(
name|access
operator|==
literal|'a'
condition|)
name|err
operator|=
literal|"a register has no address"
expr_stmt|;
else|else
block|{
comment|/* 			 * Idea here is to detect from length of datum 			 * and from register number if we will touch PC. 			 * Warn if we do. 			 * vop_nbytes is number of bytes in operand. 			 * Compute highest byte affected, compare to PC0. 			 */
if|if
condition|(
operator|(
name|vopP
operator|->
name|vop_nbytes
operator|+
name|reg
operator|*
literal|4
operator|)
operator|>
literal|60
condition|)
name|wrn
operator|=
literal|"PC part of operand unpredictable"
expr_stmt|;
name|err
operator|=
literal|" "
expr_stmt|;
comment|/* win */
name|mode
operator|=
literal|5
expr_stmt|;
comment|/* Rn */
block|}
block|}
comment|/* 	 * If !*err,        sign == 0 	 *                  hash == 0 	 *                  paren == 1  OR reg == -1 	 */
comment|/* 	 * Rest of cases fit into one bunch. 	 * 	 * in:  at       optional 	 *      len      ' ' or 'b' or 'w' or 'l' 	 *      hash     0             by program logic 	 *      p:q      expected          (empty is not an error) 	 *      sign     0                 by program logic 	 *      paren    optional 	 *      reg      optional 	 *      ndx      optional 	 * 	 * out: mode     10 + @ + len 	 *      reg      optional 	 *      len      ' ' or 'b' or 'w' or 'l' 	 *      exp                        maybe empty 	 *      ndx      optional          warn if same as reg 	 */
if|if
condition|(
operator|!
operator|*
name|err
condition|)
block|{
name|err
operator|=
literal|" "
expr_stmt|;
comment|/* win (always) */
name|mode
operator|=
literal|10
operator|+
operator|(
name|at
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|'l'
case|:
name|mode
operator|+=
literal|2
expr_stmt|;
case|case
literal|'w'
case|:
name|mode
operator|+=
literal|2
expr_stmt|;
case|case
literal|' '
case|:
comment|/* assumed B^ until our caller changes it */
case|case
literal|'b'
case|:
break|break;
block|}
block|}
comment|/* 	 * here with completely specified     mode 	 *					len 	 *					reg 	 *					expression   p,q 	 *					ndx 	 */
if|if
condition|(
operator|*
name|err
operator|==
literal|' '
condition|)
name|err
operator|=
literal|""
expr_stmt|;
comment|/* " " is no longer an error */
name|vopP
operator|->
name|vop_mode
operator|=
name|mode
expr_stmt|;
name|vopP
operator|->
name|vop_reg
operator|=
name|reg
expr_stmt|;
name|vopP
operator|->
name|vop_short
operator|=
name|len
expr_stmt|;
name|vopP
operator|->
name|vop_expr_begin
operator|=
name|p
expr_stmt|;
name|vopP
operator|->
name|vop_expr_end
operator|=
name|q
expr_stmt|;
name|vopP
operator|->
name|vop_ndx
operator|=
name|ndx
expr_stmt|;
name|vopP
operator|->
name|vop_error
operator|=
name|err
expr_stmt|;
name|vopP
operator|->
name|vop_warn
operator|=
name|wrn
expr_stmt|;
return|return
operator|(
name|bug
operator|)
return|;
block|}
end_function

begin_comment
comment|/* vip_op() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*    Summary of vip_op outputs.    mode	reg	len	ndx   (Rn) => @Rn   {@}Rn			5+@	n	' '	optional   branch operand		0	-1	' '	-1   S^#foo			0	-1	's'	-1   -(Rn)			7	n	' '	optional   {@}(Rn)+		8+@	n	' '	optional   {@}#foo, no S^		8+@	PC	" i"	optional   {@}{q^}{(Rn)}		10+@+q	option	" bwl"	optional    */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_comment
comment|/* #Define to use this testbed. */
end_comment

begin_comment
comment|/*  * Follows a test program for this function.  * We declare arrays non-local in case some of our tiny-minded machines  * default to small stacks. Also, helps with some debuggers.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_decl_stmt
name|char
name|answer
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* human types into here */
end_comment

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|myerr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mywrn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mybug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|myaccess
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|mywidth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|mymode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|myreg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|mylen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|myleft
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|myright
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|myndx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|my_operand_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|my_immediate
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|my_indirect
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|my_displen
index|[
literal|200
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|()
block|{
name|char
modifier|*
name|vip_op
parameter_list|()
function_decl|;
comment|/* make cc happy */
name|printf
argument_list|(
literal|"enter immediate symbols eg enter #   "
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|my_immediate
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"enter indirect symbols  eg enter @   "
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|my_indirect
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"enter displen symbols   eg enter ^   "
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|my_displen
argument_list|)
expr_stmt|;
name|vip_op_defaults
argument_list|(
name|my_immediate
argument_list|,
name|my_indirect
argument_list|,
name|my_displen
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"access,width (eg 'ab' or 'wh') [empty line to quit] :  "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|answer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|answer
index|[
literal|0
index|]
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|myaccess
operator|=
name|answer
index|[
literal|0
index|]
expr_stmt|;
name|mywidth
operator|=
name|answer
index|[
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|mywidth
condition|)
block|{
case|case
literal|'b'
case|:
name|my_operand_length
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|my_operand_length
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|my_operand_length
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|my_operand_length
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|my_operand_length
operator|=
literal|32
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|my_operand_length
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|my_operand_length
operator|=
literal|16
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|my_operand_length
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|my_operand_length
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
case|case
literal|'?'
case|:
case|case
literal|'-'
case|:
name|my_operand_length
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|my_operand_length
operator|=
literal|2
expr_stmt|;
name|printf
argument_list|(
literal|"I dn't understand access width %c\n"
argument_list|,
name|mywidth
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"VAX assembler instruction operand: "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|answer
argument_list|)
expr_stmt|;
name|mybug
operator|=
name|vip_op
argument_list|(
name|answer
argument_list|,
name|myaccess
argument_list|,
name|mywidth
argument_list|,
name|my_operand_length
argument_list|,
operator|&
name|mymode
argument_list|,
operator|&
name|myreg
argument_list|,
operator|&
name|mylen
argument_list|,
operator|&
name|myleft
argument_list|,
operator|&
name|myright
argument_list|,
operator|&
name|myndx
argument_list|,
operator|&
name|myerr
argument_list|,
operator|&
name|mywrn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|myerr
condition|)
block|{
name|printf
argument_list|(
literal|"error: \"%s\"\n"
argument_list|,
name|myerr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mybug
condition|)
name|printf
argument_list|(
literal|" bug: \"%s\"\n"
argument_list|,
name|mybug
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|mywrn
condition|)
name|printf
argument_list|(
literal|"warning: \"%s\"\n"
argument_list|,
name|mywrn
argument_list|)
expr_stmt|;
name|mumble
argument_list|(
literal|"mode"
argument_list|,
name|mymode
argument_list|)
expr_stmt|;
name|mumble
argument_list|(
literal|"register"
argument_list|,
name|myreg
argument_list|)
expr_stmt|;
name|mumble
argument_list|(
literal|"index"
argument_list|,
name|myndx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"width:'%c'  "
argument_list|,
name|mylen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"expression: \""
argument_list|)
expr_stmt|;
while|while
condition|(
name|myleft
operator|<=
name|myright
condition|)
name|putchar
argument_list|(
operator|*
name|myleft
operator|++
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_macro
name|mumble
argument_list|(
argument|text
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|text
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|"%xx"
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"ABSENT"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ifdef TEST */
end_comment

begin_comment
comment|/* end: vip_op.c */
end_comment

begin_decl_stmt
specifier|const
name|int
name|md_short_jump_size
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|md_long_jump_size
init|=
literal|6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of relocation record */
end_comment

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|long
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|long
name|offset
decl_stmt|;
name|offset
operator|=
name|to_addr
operator|-
operator|(
name|from_addr
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|0x31
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
name|offset
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|long
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|long
name|offset
decl_stmt|;
name|offset
operator|=
name|to_addr
operator|-
name|S_GET_VALUE
argument_list|(
name|to_symbol
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|0x17
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|0x9F
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag
argument_list|,
name|ptr
operator|-
name|frag
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|to_symbol
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|NO_RELOC
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_VMS
end_ifdef

begin_decl_stmt
specifier|extern
name|char
name|vms_name_mapping
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|md_parse_option
parameter_list|(
name|argP
parameter_list|,
name|cntP
parameter_list|,
name|vecP
parameter_list|)
name|char
modifier|*
modifier|*
name|argP
decl_stmt|;
name|int
modifier|*
name|cntP
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|vecP
decl_stmt|;
block|{
name|char
modifier|*
name|temp_name
decl_stmt|;
comment|/* name for -t or -d options */
name|char
name|opt
decl_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|argP
condition|)
block|{
case|case
literal|'J'
case|:
comment|/* as_warn ("I can do better than -J!"); */
break|break;
case|case
literal|'S'
case|:
name|as_warn
argument_list|(
literal|"SYMBOL TABLE not implemented"
argument_list|)
expr_stmt|;
break|break;
comment|/* SYMBOL TABLE not implemented */
case|case
literal|'T'
case|:
name|as_warn
argument_list|(
literal|"TOKEN TRACE not implemented"
argument_list|)
expr_stmt|;
break|break;
comment|/* TOKEN TRACE not implemented */
case|case
literal|'d'
case|:
case|case
literal|'t'
case|:
name|opt
operator|=
operator|*
operator|*
name|argP
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|argP
condition|)
block|{
comment|/* Rest of argument is filename. */
name|temp_name
operator|=
operator|*
name|argP
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|argP
condition|)
operator|(
operator|*
name|argP
operator|)
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cntP
condition|)
block|{
while|while
condition|(
operator|*
operator|*
name|argP
condition|)
operator|(
operator|*
name|argP
operator|)
operator|++
expr_stmt|;
operator|--
operator|(
operator|*
name|cntP
operator|)
expr_stmt|;
name|temp_name
operator|=
operator|*
operator|++
operator|(
operator|*
name|vecP
operator|)
expr_stmt|;
operator|*
operator|*
name|vecP
operator|=
name|NULL
expr_stmt|;
comment|/* Remember this is not a file-name. */
block|}
else|else
block|{
name|as_warn
argument_list|(
literal|"I expected a filename after -%c."
argument_list|,
name|opt
argument_list|)
expr_stmt|;
name|temp_name
operator|=
literal|"{absent}"
expr_stmt|;
block|}
if|if
condition|(
name|opt
operator|==
literal|'d'
condition|)
name|as_warn
argument_list|(
literal|"Displacement length %s ignored!"
argument_list|,
name|temp_name
argument_list|)
expr_stmt|;
else|else
name|as_warn
argument_list|(
literal|"I don't need or use temp. file \"%s\"."
argument_list|,
name|temp_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|as_warn
argument_list|(
literal|"I don't use an interpass file! -V ignored"
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OBJ_VMS
case|case
literal|'+'
case|:
comment|/* For g++ */
break|break;
case|case
literal|'1'
case|:
comment|/* For backward compatibility */
break|break;
case|case
literal|'h'
case|:
comment|/* No hashing of mixed-case names */
name|vms_name_mapping
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|argP
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|argP
condition|)
name|vms_name_mapping
operator|=
operator|*
operator|(
operator|(
operator|*
name|argP
operator|)
operator|++
operator|)
operator|-
literal|'0'
expr_stmt|;
operator|(
operator|*
name|argP
operator|)
operator|--
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* Show new symbol after hash truncation */
break|break;
endif|#
directive|endif
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* We have no need to default values of symbols.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Parse an operand that is machine-specific.    We just return without modifying the expression if we have nothing    to do.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|long
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
return|return
name|size
return|;
comment|/* Byte alignment is fine */
block|}
end_function

begin_comment
comment|/* Exactly what point is a PC-relative offset relative TO?    On the vax, they're relative to the address of the offset, plus    its size. (??? Is this right?  FIXME-SOON) */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
return|return
name|fixP
operator|->
name|fx_size
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
block|}
end_function

begin_comment
comment|/* end of tc-vax.c */
end_comment

end_unit

