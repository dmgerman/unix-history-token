begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tc-sparc.c -- Assemble for the SPARC    Copyright (C) 1989, 1990, 1991, 1992 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|cypress
value|1234
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_comment
comment|/* careful, this file includes data *declarations* */
end_comment

begin_include
include|#
directive|include
file|"opcode/sparc.h"
end_include

begin_define
define|#
directive|define
name|DEBUG_SPARC
value|1
end_define

begin_function_decl
name|void
name|md_begin
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|md_end
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|md_number_to_chars
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|md_assemble
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|md_atof
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|md_convert_frag
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|md_create_short_jump
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|md_create_long_jump
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|md_estimate_size_before_relax
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|md_ri_to_chars
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sparc_ip
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|enum
name|sparc_architecture
name|current_architecture
init|=
name|v6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|architecture_requested
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|warn_on_bump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* handle of the OPCODE hash table */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|s_seg
argument_list|()
decl_stmt|,
name|s_proc
argument_list|()
decl_stmt|,
name|s_data1
argument_list|()
decl_stmt|,
name|s_reserve
argument_list|()
decl_stmt|,
name|s_common
argument_list|()
decl_stmt|,
name|s_empty
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|s_globl
argument_list|()
decl_stmt|,
name|s_long
argument_list|()
decl_stmt|,
name|s_short
argument_list|()
decl_stmt|,
name|s_space
argument_list|()
decl_stmt|,
name|cons
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|s_align_bytes
argument_list|()
decl_stmt|,
name|s_ignore
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|0
block|}
block|,
comment|/* Defaulting is invalid (0) */
block|{
literal|"empty"
block|,
name|s_empty
block|,
literal|0
block|}
block|,
block|{
literal|"common"
block|,
name|s_common
block|,
literal|0
block|}
block|,
block|{
literal|"global"
block|,
name|s_globl
block|,
literal|0
block|}
block|,
block|{
literal|"half"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|"optim"
block|,
name|s_ignore
block|,
literal|0
block|}
block|,
block|{
literal|"proc"
block|,
name|s_proc
block|,
literal|0
block|}
block|,
block|{
literal|"reserve"
block|,
name|s_reserve
block|,
literal|0
block|}
block|,
block|{
literal|"seg"
block|,
name|s_seg
block|,
literal|0
block|}
block|,
block|{
literal|"skip"
block|,
name|s_space
block|,
literal|0
block|}
block|,
block|{
literal|"word"
block|,
name|cons
block|,
literal|4
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|md_short_jump_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|md_long_jump_size
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
literal|12
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of relocation record */
end_comment

begin_comment
comment|/* This array holds the chars that always start a comment.  If the    pre-processor is disabled, these aren't very useful */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"!"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* JF removed '|' from comment_chars */
end_comment

begin_comment
comment|/* This array holds the chars that only start a comment at the beginning of    a line.  If the line seems to have the form '# 123 filename'    .line and .file directives will appear in the pre-processed output */
end_comment

begin_comment
comment|/* Note that input_file.c hand checks for '#' at the beginning of the    first line of the input file.  This is because the compiler outputs    #NO_APP at the beginning of its output. */
end_comment

begin_comment
comment|/* Also note that comments started like this one will always    work if '/' isn't otherwise defined. */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant */
end_comment

begin_comment
comment|/* As in 0f12.456 */
end_comment

begin_comment
comment|/* or    0d1.2345e12 */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"rRsSfFdDxXpP"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Also be aware that MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT may have to be    changed in read.c. Ideally it shouldn't have to know about it at all,    but nothing is ideal around here.    */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|octal
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|isoctal
parameter_list|(
name|c
parameter_list|)
value|octal[c]
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|toHex
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|sparc_it
block|{
name|char
modifier|*
name|error
decl_stmt|;
name|unsigned
name|long
name|opcode
decl_stmt|;
name|struct
name|nlist
modifier|*
name|nlistp
decl_stmt|;
name|expressionS
name|exp
decl_stmt|;
name|int
name|pcrel
decl_stmt|;
name|enum
name|reloc_type
name|reloc
decl_stmt|;
block|}
name|the_insn
struct|,
name|set_insn
struct|;
end_struct

begin_if
if|#
directive|if
name|__STDC__
operator|==
literal|1
end_if

begin_if
if|#
directive|if
name|DEBUG_SPARC
end_if

begin_function_decl
specifier|static
name|void
name|print_insn
parameter_list|(
name|struct
name|sparc_it
modifier|*
name|insn
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|getExpression
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not __STDC__ */
end_comment

begin_if
if|#
directive|if
name|DEBUG_SPARC
end_if

begin_function_decl
specifier|static
name|void
name|print_insn
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|getExpression
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __STDC__ */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|Reloc
index|[]
init|=
block|{
literal|"RELOC_8"
block|,
literal|"RELOC_16"
block|,
literal|"RELOC_32"
block|,
literal|"RELOC_DISP8"
block|,
literal|"RELOC_DISP16"
block|,
literal|"RELOC_DISP32"
block|,
literal|"RELOC_WDISP30"
block|,
literal|"RELOC_WDISP22"
block|,
literal|"RELOC_HI22"
block|,
literal|"RELOC_22"
block|,
literal|"RELOC_13"
block|,
literal|"RELOC_LO10"
block|,
literal|"RELOC_SFA_BASE"
block|,
literal|"RELOC_SFA_OFF13"
block|,
literal|"RELOC_BASE10"
block|,
literal|"RELOC_BASE13"
block|,
literal|"RELOC_BASE22"
block|,
literal|"RELOC_PC10"
block|,
literal|"RELOC_PC22"
block|,
literal|"RELOC_JMP_TBL"
block|,
literal|"RELOC_SEGOFF16"
block|,
literal|"RELOC_GLOB_DAT"
block|,
literal|"RELOC_JMP_SLOT"
block|,
literal|"RELOC_RELATIVE"
block|,
literal|"NO_RELOC"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|expr_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|special_case
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Instructions that require wierd handling because they're longer than  * 4 bytes.  */
end_comment

begin_define
define|#
directive|define
name|SPECIAL_CASE_SET
value|1
end_define

begin_define
define|#
directive|define
name|SPECIAL_CASE_FDIV
value|2
end_define

begin_comment
comment|/*  * sort of like s_lcomm  *  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_alignment
init|=
literal|15
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|s_reserve
parameter_list|()
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected comma after name"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|=
name|get_absolute_expression
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"BSS length (%d.)<0! Ignored."
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* bad length */
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|",\"bss\""
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|"bad .reserve segment: `%s'"
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* if not bss */
name|input_line_pointer
operator|+=
literal|6
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|'\n'
condition|)
block|{
name|as_bad
argument_list|(
literal|"Missing alignment"
argument_list|)
expr_stmt|;
return|return;
block|}
name|align
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
if|if
condition|(
name|align
operator|>
name|max_alignment
condition|)
block|{
name|align
operator|=
name|max_alignment
expr_stmt|;
name|as_warn
argument_list|(
literal|"Alignment too large: %d. assumed."
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|align
operator|<
literal|0
condition|)
block|{
name|align
operator|=
literal|0
expr_stmt|;
name|as_warn
argument_list|(
literal|"Alignment negative. 0 assumed."
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MANY_SEGMENTS
define|#
directive|define
name|SEG_BSS
value|SEG_E2
name|record_alignment
argument_list|(
name|SEG_E2
argument_list|,
name|align
argument_list|)
expr_stmt|;
else|#
directive|else
name|record_alignment
argument_list|(
name|SEG_BSS
argument_list|,
name|align
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* convert to a power of 2 alignment */
for|for
control|(
name|temp
operator|=
literal|0
init|;
operator|(
name|align
operator|&
literal|1
operator|)
operator|==
literal|0
condition|;
name|align
operator|>>=
literal|1
operator|,
operator|++
name|temp
control|)
empty_stmt|;
empty_stmt|;
if|if
condition|(
name|align
operator|!=
literal|1
condition|)
block|{
name|as_bad
argument_list|(
literal|"Alignment not a power of 2"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* not a power of two */
name|align
operator|=
name|temp
expr_stmt|;
comment|/* Align */
name|align
operator|=
operator|~
operator|(
operator|(
operator|~
literal|0
operator|)
operator|<<
name|align
operator|)
expr_stmt|;
comment|/* Convert to a mask */
name|local_bss_counter
operator|=
operator|(
name|local_bss_counter
operator|+
name|align
operator|)
operator|&
operator|(
operator|~
name|align
operator|)
expr_stmt|;
block|}
comment|/* if has optional alignment */
if|if
condition|(
name|S_GET_OTHER
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
operator|&&
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|S_GET_SEGMENT
argument_list|(
name|symbolP
argument_list|)
operator|==
name|SEG_BSS
operator|&&
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|==
name|local_bss_counter
operator|)
operator|||
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
operator|)
condition|)
block|{
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|local_bss_counter
argument_list|)
expr_stmt|;
name|S_SET_SEGMENT
argument_list|(
name|symbolP
argument_list|,
name|SEG_BSS
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
operator|&
name|bss_address_frag
expr_stmt|;
name|local_bss_counter
operator|+=
name|size
expr_stmt|;
block|}
else|else
block|{
name|as_warn
argument_list|(
literal|"Ignoring attempt to re-define symbol from %d. to %d."
argument_list|,
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|local_bss_counter
argument_list|)
expr_stmt|;
block|}
comment|/* if not redefining */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* s_reserve() */
end_comment

begin_function
specifier|static
name|void
name|s_common
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|name
operator|=
name|input_line_pointer
expr_stmt|;
name|c
operator|=
name|get_symbol_end
argument_list|()
expr_stmt|;
comment|/* just after name is now '\0' */
name|p
operator|=
name|input_line_pointer
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"Expected comma after symbol-name"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|++
expr_stmt|;
comment|/* skip ',' */
if|if
condition|(
operator|(
name|temp
operator|=
name|get_absolute_expression
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|as_bad
argument_list|(
literal|".COMMon length (%d.)<0! Ignored."
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|=
name|symbol_find_or_make
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Ignoring attempt to re-define symbol"
argument_list|)
expr_stmt|;
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|!=
name|temp
condition|)
block|{
name|as_warn
argument_list|(
literal|"Length of .comm \"%s\" is already %d. Not changed to %d."
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
name|know
argument_list|(
name|symbolP
operator|->
name|sy_frag
operator|==
operator|&
name|zero_address_frag
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|",\"bss\""
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|",\"data\""
argument_list|,
literal|7
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|p
operator|=
name|input_line_pointer
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|as_bad
argument_list|(
literal|"bad .common segment: `%s'"
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
return|return;
block|}
name|input_line_pointer
operator|+=
literal|6
operator|+
operator|(
name|input_line_pointer
index|[
literal|2
index|]
operator|==
literal|'d'
operator|)
expr_stmt|;
comment|/* Skip either */
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* s_common() */
end_comment

begin_function
specifier|static
name|void
name|s_seg
parameter_list|()
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"\"text\""
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|6
expr_stmt|;
name|s_text
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"\"data\""
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|6
expr_stmt|;
name|s_data
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"\"data1\""
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|7
expr_stmt|;
name|s_data1
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|input_line_pointer
argument_list|,
literal|"\"bss\""
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|input_line_pointer
operator|+=
literal|5
expr_stmt|;
comment|/* We only support 2 segments -- text and data -- for now, so 		   things in the "bss segment" will have to go into data for now. 		   You can still allocate SEG_BSS stuff with .lcomm or .reserve. */
name|subseg_new
argument_list|(
name|SEG_DATA
argument_list|,
literal|255
argument_list|)
expr_stmt|;
comment|/* FIXME-SOMEDAY */
return|return;
block|}
name|as_bad
argument_list|(
literal|"Unknown segment type"
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* s_seg() */
end_comment

begin_function
specifier|static
name|void
name|s_data1
parameter_list|()
block|{
name|subseg_new
argument_list|(
name|SEG_DATA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* s_data1() */
end_comment

begin_function
specifier|static
name|void
name|s_proc
parameter_list|()
block|{
specifier|extern
name|char
name|is_end_of_line
index|[]
decl_stmt|;
while|while
condition|(
operator|!
name|is_end_of_line
index|[
operator|*
name|input_line_pointer
index|]
condition|)
block|{
operator|++
name|input_line_pointer
expr_stmt|;
block|}
operator|++
name|input_line_pointer
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* s_proc() */
end_comment

begin_comment
comment|/*  * GI: This is needed for compatability with Sun's assembler - which  * otherwise generates a warning when certain "suspect" instructions  * appear in the delay slot of a branch.  And more seriously without  * this directive in certain cases Sun's assembler will rearrange  * code thinking it knows how to alter things when it doesn't.  */
end_comment

begin_function
specifier|static
name|void
name|s_empty
parameter_list|()
block|{
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* s_empty() */
end_comment

begin_comment
comment|/* This function is called once, at assembler startup time.  It should    set up all the tables, etc. that the MD part of the assembler will need. */
end_comment

begin_function
name|void
name|md_begin
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|retval
init|=
name|NULL
decl_stmt|;
name|int
name|lose
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|op_hash
operator|==
name|NULL
condition|)
name|as_fatal
argument_list|(
literal|"Virtual memory exhausted"
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|NUMOPCODES
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|sparc_opcodes
index|[
name|i
index|]
operator|.
name|name
decl_stmt|;
name|retval
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|name
argument_list|,
operator|&
name|sparc_opcodes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
operator|&&
operator|*
name|retval
operator|!=
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"internal error: can't hash `%s': %s\n"
argument_list|,
name|sparc_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|lose
operator|=
literal|1
expr_stmt|;
block|}
do|do
block|{
if|if
condition|(
name|sparc_opcodes
index|[
name|i
index|]
operator|.
name|match
operator|&
name|sparc_opcodes
index|[
name|i
index|]
operator|.
name|lose
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"internal error: losing opcode: `%s' \"%s\"\n"
argument_list|,
name|sparc_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|sparc_opcodes
index|[
name|i
index|]
operator|.
name|args
argument_list|)
expr_stmt|;
name|lose
operator|=
literal|1
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|NUMOPCODES
operator|&&
operator|!
name|strcmp
argument_list|(
name|sparc_opcodes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
condition|)
do|;
block|}
if|if
condition|(
name|lose
condition|)
name|as_fatal
argument_list|(
literal|"Broken assembler.  No assembly attempted."
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'0'
init|;
name|i
operator|<
literal|'8'
condition|;
operator|++
name|i
control|)
name|octal
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'0'
init|;
name|i
operator|<=
literal|'9'
condition|;
operator|++
name|i
control|)
name|toHex
index|[
name|i
index|]
operator|=
name|i
operator|-
literal|'0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'a'
init|;
name|i
operator|<=
literal|'f'
condition|;
operator|++
name|i
control|)
name|toHex
index|[
name|i
index|]
operator|=
name|i
operator|+
literal|10
operator|-
literal|'a'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|'A'
init|;
name|i
operator|<=
literal|'F'
condition|;
operator|++
name|i
control|)
name|toHex
index|[
name|i
index|]
operator|=
name|i
operator|+
literal|10
operator|-
literal|'A'
expr_stmt|;
if|#
directive|if
literal|0
block|if (picmode) 		GOT_symbol = symbol_find_or_make("__GLOBAL_OFFSET_TABLE_");
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* md_begin() */
end_comment

begin_function
name|void
name|md_end
parameter_list|()
block|{
return|return;
block|}
end_function

begin_comment
comment|/* md_end() */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|toP
decl_stmt|;
name|int
name|rsd
decl_stmt|;
name|know
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|sparc_ip
argument_list|(
name|str
argument_list|)
expr_stmt|;
comment|/* See if "set" operand is absolute and small; skip sethi if so. */
if|if
condition|(
name|special_case
operator|==
name|SPECIAL_CASE_SET
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_seg
operator|==
name|SEG_ABSOLUTE
condition|)
block|{
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
operator|>=
operator|-
operator|(
literal|1
operator|<<
literal|12
operator|)
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
operator|<
operator|(
literal|1
operator|<<
literal|12
operator|)
condition|)
block|{
name|the_insn
operator|.
name|opcode
operator|=
literal|0x80102000
comment|/* or %g0,imm,... */
operator||
operator|(
name|the_insn
operator|.
name|opcode
operator|&
literal|0x3E000000
operator|)
comment|/* dest reg */
operator||
operator|(
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
operator|&
literal|0x1FFF
operator|)
expr_stmt|;
comment|/* imm */
name|special_case
operator|=
literal|0
expr_stmt|;
comment|/* No longer special */
name|the_insn
operator|.
name|reloc
operator|=
name|NO_RELOC
expr_stmt|;
comment|/* No longer relocated */
block|}
block|}
name|toP
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* put out the opcode */
name|md_number_to_chars
argument_list|(
name|toP
argument_list|,
name|the_insn
operator|.
name|opcode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* put out the symbol-dependent stuff */
if|if
condition|(
name|the_insn
operator|.
name|reloc
operator|!=
name|NO_RELOC
condition|)
block|{
name|fix_new
argument_list|(
name|frag_now
argument_list|,
comment|/* which frag */
operator|(
name|toP
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
argument_list|,
comment|/* where */
literal|4
argument_list|,
comment|/* size */
name|the_insn
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|the_insn
operator|.
name|exp
operator|.
name|X_subtract_symbol
argument_list|,
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
argument_list|,
name|the_insn
operator|.
name|pcrel
argument_list|,
name|the_insn
operator|.
name|reloc
argument_list|,
name|the_insn
operator|.
name|exp
operator|.
name|X_got_symbol
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|special_case
condition|)
block|{
case|case
name|SPECIAL_CASE_SET
case|:
name|special_case
operator|=
literal|0
expr_stmt|;
name|know
argument_list|(
name|the_insn
operator|.
name|reloc
operator|==
name|RELOC_HI22
operator|||
name|the_insn
operator|.
name|reloc
operator|==
name|RELOC_BASE22
argument_list|)
expr_stmt|;
comment|/* See if "set" operand has no low-order bits; skip OR if so. */
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_seg
operator|==
name|SEG_ABSOLUTE
operator|&&
operator|(
operator|(
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
operator|&
literal|0x3FF
operator|)
operator|==
literal|0
operator|)
condition|)
return|return;
name|toP
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|rsd
operator|=
operator|(
name|the_insn
operator|.
name|opcode
operator|>>
literal|25
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|the_insn
operator|.
name|opcode
operator|=
literal|0x80102000
operator||
operator|(
name|rsd
operator|<<
literal|25
operator|)
operator||
operator|(
name|rsd
operator|<<
literal|14
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|toP
argument_list|,
name|the_insn
operator|.
name|opcode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag_now
argument_list|,
comment|/* which frag */
operator|(
name|toP
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
argument_list|,
comment|/* where */
literal|4
argument_list|,
comment|/* size */
name|the_insn
operator|.
name|exp
operator|.
name|X_add_symbol
argument_list|,
name|the_insn
operator|.
name|exp
operator|.
name|X_subtract_symbol
argument_list|,
name|the_insn
operator|.
name|exp
operator|.
name|X_add_number
argument_list|,
name|the_insn
operator|.
name|pcrel
argument_list|,
name|the_insn
operator|.
name|reloc
operator|==
name|RELOC_BASE22
condition|?
name|RELOC_BASE10
else|:
name|RELOC_LO10
argument_list|,
name|the_insn
operator|.
name|exp
operator|.
name|X_got_symbol
argument_list|)
expr_stmt|;
return|return;
case|case
name|SPECIAL_CASE_FDIV
case|:
comment|/* According to information leaked from Sun, the "fdiv" instructions 		   on early SPARC machines would produce incorrect results sometimes. 		   The workaround is to add an fmovs of the destination register to 		   itself just after the instruction.  This was true on machines 		   with Weitek 1165 float chips, such as the Sun-4/260 and /280. */
name|special_case
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|the_insn
operator|.
name|reloc
operator|==
name|NO_RELOC
argument_list|)
expr_stmt|;
name|toP
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|rsd
operator|=
operator|(
name|the_insn
operator|.
name|opcode
operator|>>
literal|25
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|the_insn
operator|.
name|opcode
operator|=
literal|0x81A00020
operator||
operator|(
name|rsd
operator|<<
literal|25
operator|)
operator||
name|rsd
expr_stmt|;
comment|/* fmovs dest,dest */
name|md_number_to_chars
argument_list|(
name|toP
argument_list|,
name|the_insn
operator|.
name|opcode
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return;
case|case
literal|0
case|:
return|return;
default|default:
name|as_fatal
argument_list|(
literal|"md_assemble: failed sanity check."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* md_assemble() */
end_comment

begin_function
specifier|static
name|void
name|sparc_ip
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|error_message
init|=
literal|""
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
specifier|const
name|char
modifier|*
name|args
decl_stmt|;
name|char
name|c
decl_stmt|;
name|struct
name|sparc_opcode
modifier|*
name|insn
decl_stmt|;
name|char
modifier|*
name|argsStart
decl_stmt|;
name|unsigned
name|long
name|opcode
decl_stmt|;
name|unsigned
name|int
name|mask
init|=
literal|0
decl_stmt|;
name|int
name|match
init|=
literal|0
decl_stmt|;
name|int
name|comma
init|=
literal|0
decl_stmt|;
for|for
control|(
name|s
operator|=
name|str
init|;
name|islower
argument_list|(
operator|*
name|s
argument_list|)
operator|||
operator|(
operator|*
name|s
operator|>=
literal|'0'
operator|&&
operator|*
name|s
operator|<=
literal|'3'
operator|)
condition|;
operator|++
name|s
control|)
empty_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\0'
case|:
break|break;
case|case
literal|','
case|:
name|comma
operator|=
literal|1
expr_stmt|;
comment|/*FALLTHROUGH */
case|case
literal|' '
case|:
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"Unknown opcode: `%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|insn
operator|=
operator|(
expr|struct
name|sparc_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
literal|"Unknown opcode: `%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|comma
condition|)
block|{
operator|*
operator|--
name|s
operator|=
literal|','
expr_stmt|;
block|}
name|argsStart
operator|=
name|s
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|opcode
operator|=
name|insn
operator|->
name|match
expr_stmt|;
name|memset
argument_list|(
operator|&
name|the_insn
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|the_insn
argument_list|)
argument_list|)
expr_stmt|;
name|the_insn
operator|.
name|reloc
operator|=
name|NO_RELOC
expr_stmt|;
comment|/* 		 * Build the opcode, checking as we go to make 		 * sure that the operands match 		 */
for|for
control|(
name|args
operator|=
name|insn
operator|->
name|args
init|;
condition|;
operator|++
name|args
control|)
block|{
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
case|case
literal|'M'
case|:
case|case
literal|'m'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%asr"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|long
name|num
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|num
operator|=
name|num
operator|*
literal|10
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|num
operator|<
literal|16
operator|||
literal|31
operator|<
name|num
condition|)
block|{
name|error_message
operator|=
literal|": asr number must be between 15 and 31"
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* out of range */
name|opcode
operator||=
operator|(
operator|*
name|args
operator|==
literal|'M'
condition|?
name|RS1
argument_list|(
name|num
argument_list|)
else|:
name|RD
argument_list|(
name|num
argument_list|)
operator|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|error_message
operator|=
literal|": expecting %asrN"
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* if %asr followed by a number. */
block|}
comment|/* if %asr */
break|break;
case|case
literal|'\0'
case|:
comment|/* end of args */
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|'+'
condition|)
block|{
operator|++
name|s
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
continue|continue;
block|}
break|break;
case|case
literal|'['
case|:
comment|/* these must match exactly */
case|case
literal|']'
case|:
case|case
literal|','
case|:
case|case
literal|' '
case|:
if|if
condition|(
operator|*
name|s
operator|++
operator|==
operator|*
name|args
condition|)
continue|continue;
break|break;
case|case
literal|'#'
case|:
comment|/* must be at least one digit */
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
operator|++
argument_list|)
condition|)
block|{
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
operator|++
name|s
expr_stmt|;
block|}
continue|continue;
block|}
break|break;
case|case
literal|'C'
case|:
comment|/* coprocessor state register */
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%csr"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
literal|4
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'b'
case|:
comment|/* next operand is a coprocessor register */
case|case
literal|'c'
case|:
case|case
literal|'D'
case|:
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'%'
operator|&&
operator|*
name|s
operator|++
operator|==
literal|'c'
operator|&&
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|mask
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
name|mask
operator|=
literal|10
operator|*
operator|(
name|mask
operator|-
literal|'0'
operator|)
operator|+
operator|(
operator|*
name|s
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|mask
operator|>=
literal|32
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
name|mask
operator|-=
literal|'0'
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
case|case
literal|'b'
case|:
name|opcode
operator||=
name|mask
operator|<<
literal|14
expr_stmt|;
continue|continue;
case|case
literal|'c'
case|:
name|opcode
operator||=
name|mask
expr_stmt|;
continue|continue;
case|case
literal|'D'
case|:
name|opcode
operator||=
name|mask
operator|<<
literal|25
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
case|case
literal|'r'
case|:
comment|/* next operand must be a register */
case|case
literal|'s'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'d'
case|:
case|case
literal|'x'
case|:
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'%'
condition|)
block|{
switch|switch
condition|(
name|c
operator|=
operator|*
name|s
operator|++
condition|)
block|{
case|case
literal|'f'
case|:
comment|/* frame pointer */
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'p'
condition|)
block|{
name|mask
operator|=
literal|0x1e
expr_stmt|;
break|break;
block|}
goto|goto
name|error
goto|;
case|case
literal|'g'
case|:
comment|/* global register */
if|if
condition|(
name|isoctal
argument_list|(
name|c
operator|=
operator|*
name|s
operator|++
argument_list|)
condition|)
block|{
name|mask
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
break|break;
block|}
goto|goto
name|error
goto|;
case|case
literal|'i'
case|:
comment|/* in register */
if|if
condition|(
name|isoctal
argument_list|(
name|c
operator|=
operator|*
name|s
operator|++
argument_list|)
condition|)
block|{
name|mask
operator|=
name|c
operator|-
literal|'0'
operator|+
literal|24
expr_stmt|;
break|break;
block|}
goto|goto
name|error
goto|;
case|case
literal|'l'
case|:
comment|/* local register */
if|if
condition|(
name|isoctal
argument_list|(
name|c
operator|=
operator|*
name|s
operator|++
argument_list|)
condition|)
block|{
name|mask
operator|=
operator|(
name|c
operator|-
literal|'0'
operator|+
literal|16
operator|)
expr_stmt|;
break|break;
block|}
goto|goto
name|error
goto|;
case|case
literal|'o'
case|:
comment|/* out register */
if|if
condition|(
name|isoctal
argument_list|(
name|c
operator|=
operator|*
name|s
operator|++
argument_list|)
condition|)
block|{
name|mask
operator|=
operator|(
name|c
operator|-
literal|'0'
operator|+
literal|8
operator|)
expr_stmt|;
break|break;
block|}
goto|goto
name|error
goto|;
case|case
literal|'s'
case|:
comment|/* stack pointer */
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'p'
condition|)
block|{
name|mask
operator|=
literal|0xe
expr_stmt|;
break|break;
block|}
goto|goto
name|error
goto|;
case|case
literal|'r'
case|:
comment|/* any register */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
operator|=
operator|*
name|s
operator|++
argument_list|)
condition|)
block|{
goto|goto
name|error
goto|;
block|}
comment|/* FALLTHROUGH */
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
literal|10
operator|*
operator|(
name|c
operator|-
literal|'0'
operator|)
operator|+
operator|(
operator|*
name|s
operator|++
operator|-
literal|'0'
operator|)
operator|)
operator|>=
literal|32
condition|)
block|{
goto|goto
name|error
goto|;
block|}
block|}
else|else
block|{
name|c
operator|-=
literal|'0'
expr_stmt|;
block|}
name|mask
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|opcode
operator||=
operator|(
name|mask
operator|<<
literal|25
operator|)
operator||
name|mask
expr_stmt|;
continue|continue;
default|default:
goto|goto
name|error
goto|;
block|}
comment|/* 					 * Got the register, now figure out where 					 * it goes in the opcode. 					 */
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
case|case
literal|'1'
case|:
name|opcode
operator||=
name|mask
operator|<<
literal|14
expr_stmt|;
continue|continue;
case|case
literal|'2'
case|:
name|opcode
operator||=
name|mask
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
name|opcode
operator||=
name|mask
operator|<<
literal|25
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
name|opcode
operator||=
operator|(
name|mask
operator|<<
literal|25
operator|)
operator||
operator|(
name|mask
operator|<<
literal|14
operator|)
expr_stmt|;
continue|continue;
case|case
literal|'x'
case|:
name|opcode
operator||=
operator|(
name|mask
operator|<<
literal|25
operator|)
operator||
name|mask
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
case|case
literal|'e'
case|:
comment|/* next operand is a floating point register */
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
case|case
literal|'f'
case|:
case|case
literal|'B'
case|:
case|case
literal|'R'
case|:
case|case
literal|'g'
case|:
case|case
literal|'H'
case|:
case|case
literal|'J'
case|:
block|{
name|char
name|format
decl_stmt|;
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'%'
operator|&&
operator|(
operator|(
name|format
operator|=
operator|*
name|s
operator|)
operator|==
literal|'f'
operator|)
operator|&&
name|isdigit
argument_list|(
operator|*
operator|++
name|s
argument_list|)
condition|)
block|{
for|for
control|(
name|mask
operator|=
literal|0
init|;
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|;
operator|++
name|s
control|)
block|{
name|mask
operator|=
literal|10
operator|*
name|mask
operator|+
operator|(
operator|*
name|s
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
comment|/* read the number */
if|if
condition|(
operator|(
operator|*
name|args
operator|==
literal|'u'
operator|||
operator|*
name|args
operator|==
literal|'v'
operator|||
operator|*
name|args
operator|==
literal|'B'
operator|||
operator|*
name|args
operator|==
literal|'H'
operator|)
operator|&&
operator|(
name|mask
operator|&
literal|1
operator|)
condition|)
block|{
break|break;
block|}
comment|/* register must be even numbered */
if|if
condition|(
operator|(
operator|*
name|args
operator|==
literal|'U'
operator|||
operator|*
name|args
operator|==
literal|'V'
operator|||
operator|*
name|args
operator|==
literal|'R'
operator|||
operator|*
name|args
operator|==
literal|'J'
operator|)
operator|&&
operator|(
name|mask
operator|&
literal|3
operator|)
condition|)
block|{
break|break;
block|}
comment|/* register must be multiple of 4 */
if|if
condition|(
name|format
operator|==
literal|'f'
condition|)
block|{
if|if
condition|(
name|mask
operator|>=
literal|32
condition|)
block|{
name|error_message
operator|=
literal|": There are only 32 f registers; [0-31]"
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* on error */
block|}
comment|/* if not an 'f' register. */
block|}
comment|/* on error */
switch|switch
condition|(
operator|*
name|args
condition|)
block|{
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
case|case
literal|'e'
case|:
name|opcode
operator||=
name|RS1
argument_list|(
name|mask
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'f'
case|:
case|case
literal|'B'
case|:
case|case
literal|'R'
case|:
name|opcode
operator||=
name|RS2
argument_list|(
name|mask
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'g'
case|:
case|case
literal|'H'
case|:
case|case
literal|'J'
case|:
name|opcode
operator||=
name|RD
argument_list|(
name|mask
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* pack it in. */
name|know
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* float arg */
case|case
literal|'F'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%fsr"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
literal|4
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'h'
case|:
comment|/* high 22 bits */
comment|/* 				 * In the case of a `set' pseudo instruction 				 * we have an implied `%hi' operator. 				 */
if|if
condition|(
name|special_case
operator|==
name|SPECIAL_CASE_SET
condition|)
name|the_insn
operator|.
name|reloc
operator|=
name|RELOC_HI22
expr_stmt|;
else|else
name|the_insn
operator|.
name|reloc
operator|=
name|RELOC_22
expr_stmt|;
goto|goto
name|immediate
goto|;
case|case
literal|'l'
case|:
comment|/* 22 bit PC relative immediate */
name|the_insn
operator|.
name|reloc
operator|=
name|RELOC_WDISP22
expr_stmt|;
name|the_insn
operator|.
name|pcrel
operator|=
literal|1
expr_stmt|;
goto|goto
name|immediate
goto|;
case|case
literal|'L'
case|:
comment|/* 30 bit immediate */
name|the_insn
operator|.
name|reloc
operator|=
ifdef|#
directive|ifdef
name|PIC
name|picmode
condition|?
name|RELOC_JMP_TBL
else|:
endif|#
directive|endif
name|RELOC_WDISP30
expr_stmt|;
name|the_insn
operator|.
name|pcrel
operator|=
literal|1
expr_stmt|;
goto|goto
name|immediate
goto|;
case|case
literal|'n'
case|:
comment|/* 22 bit immediate */
name|the_insn
operator|.
name|reloc
operator|=
name|RELOC_22
expr_stmt|;
goto|goto
name|immediate
goto|;
case|case
literal|'i'
case|:
comment|/* 13 bit immediate */
name|the_insn
operator|.
name|reloc
operator|=
name|RELOC_13
expr_stmt|;
comment|/*FALLTHROUGH */
name|immediate
label|:
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|s
index|[
literal|1
index|]
operator|)
operator|==
literal|'h'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'i'
condition|)
block|{
if|if
condition|(
name|the_insn
operator|.
name|reloc
operator|!=
name|RELOC_22
condition|)
name|as_bad
argument_list|(
literal|"`%hi' in improper context"
argument_list|)
expr_stmt|;
name|the_insn
operator|.
name|reloc
operator|=
name|RELOC_HI22
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'l'
operator|&&
name|s
index|[
literal|2
index|]
operator|==
literal|'o'
condition|)
block|{
name|the_insn
operator|.
name|reloc
operator|=
name|RELOC_LO10
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* Note that if the getExpression() fails, we 				   will still have created U entries in the 				   symbol table for the 'symbols' in the input 				   string.  Try not to create U symbols for 				   registers, etc. */
block|{
comment|/* This stuff checks to see if the 					   expression ends in +%reg If it does, 					   it removes the register from the 					   expression, and re-sets 's' to point 					   to the right place */
name|char
modifier|*
name|s1
decl_stmt|;
for|for
control|(
name|s1
operator|=
name|s
init|;
operator|*
name|s1
operator|&&
operator|*
name|s1
operator|!=
literal|','
operator|&&
operator|*
name|s1
operator|!=
literal|']'
condition|;
name|s1
operator|++
control|)
empty_stmt|;
empty_stmt|;
if|if
condition|(
name|s1
operator|!=
name|s
operator|&&
name|isdigit
argument_list|(
name|s1
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|s1
index|[
operator|-
literal|2
index|]
operator|==
literal|'%'
operator|&&
name|s1
index|[
operator|-
literal|3
index|]
operator|==
literal|'+'
condition|)
block|{
name|s1
operator|-=
literal|3
expr_stmt|;
operator|*
name|s1
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|getExpression
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|s1
operator|=
literal|'+'
expr_stmt|;
name|s
operator|=
name|s1
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"goli0123456789"
argument_list|,
name|s1
index|[
operator|-
literal|2
index|]
argument_list|)
operator|&&
name|s1
index|[
operator|-
literal|3
index|]
operator|==
literal|'%'
operator|&&
name|s1
index|[
operator|-
literal|4
index|]
operator|==
literal|'+'
condition|)
block|{
name|s1
operator|-=
literal|4
expr_stmt|;
operator|*
name|s1
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|getExpression
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|s1
operator|=
literal|'+'
expr_stmt|;
name|s
operator|=
name|s1
expr_stmt|;
continue|continue;
block|}
block|}
block|}
operator|(
name|void
operator|)
name|getExpression
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PIC
comment|/* 				 * Handle refs to __GLOBAL_OFFSET_TABLE_ 				 */
if|if
condition|(
name|the_insn
operator|.
name|exp
operator|.
name|X_got_symbol
condition|)
block|{
switch|switch
condition|(
name|the_insn
operator|.
name|reloc
condition|)
block|{
case|case
name|RELOC_22
case|:
case|case
name|RELOC_HI22
case|:
name|the_insn
operator|.
name|reloc
operator|=
name|RELOC_PC22
expr_stmt|;
name|the_insn
operator|.
name|pcrel
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RELOC_LO10
case|:
name|the_insn
operator|.
name|reloc
operator|=
name|RELOC_PC10
expr_stmt|;
name|the_insn
operator|.
name|pcrel
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|picmode
operator|&&
name|the_insn
operator|.
name|exp
operator|.
name|X_add_symbol
condition|)
block|{
switch|switch
condition|(
name|the_insn
operator|.
name|reloc
condition|)
block|{
case|case
name|RELOC_LO10
case|:
name|the_insn
operator|.
name|reloc
operator|=
name|RELOC_BASE10
expr_stmt|;
name|the_insn
operator|.
name|exp
operator|.
name|X_add_symbol
operator|->
name|sy_forceout
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RELOC_HI22
case|:
name|the_insn
operator|.
name|reloc
operator|=
name|RELOC_BASE22
expr_stmt|;
name|the_insn
operator|.
name|exp
operator|.
name|X_add_symbol
operator|->
name|sy_forceout
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RELOC_13
case|:
name|the_insn
operator|.
name|reloc
operator|=
name|RELOC_BASE13
expr_stmt|;
name|the_insn
operator|.
name|exp
operator|.
name|X_add_symbol
operator|->
name|sy_forceout
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
name|s
operator|=
name|expr_end
expr_stmt|;
continue|continue;
case|case
literal|'a'
case|:
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'a'
condition|)
block|{
name|opcode
operator||=
name|ANNUL
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'A'
case|:
block|{
name|char
modifier|*
name|push
init|=
name|input_line_pointer
decl_stmt|;
name|expressionS
name|e
decl_stmt|;
name|input_line_pointer
operator|=
name|s
expr_stmt|;
if|if
condition|(
name|expression
argument_list|(
operator|&
name|e
argument_list|)
operator|==
name|SEG_ABSOLUTE
condition|)
block|{
name|opcode
operator||=
name|e
operator|.
name|X_add_number
operator|<<
literal|5
expr_stmt|;
name|s
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|push
expr_stmt|;
continue|continue;
block|}
comment|/* if absolute */
break|break;
block|}
comment|/* alternate space */
case|case
literal|'p'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%psr"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
literal|4
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'q'
case|:
comment|/* floating point queue */
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%fq"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'Q'
case|:
comment|/* coprocessor queue */
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%cq"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|s
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"set"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|special_case
operator|=
name|SPECIAL_CASE_SET
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"fdiv"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|special_case
operator|=
name|SPECIAL_CASE_FDIV
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%tbr"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|s
operator|+=
literal|4
expr_stmt|;
continue|continue;
case|case
literal|'w'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%wim"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|s
operator|+=
literal|4
expr_stmt|;
continue|continue;
case|case
literal|'y'
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
literal|"%y"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|s
operator|+=
literal|2
expr_stmt|;
continue|continue;
default|default:
name|as_fatal
argument_list|(
literal|"sparc_ip: failed sanity check."
argument_list|)
expr_stmt|;
block|}
comment|/* switch on arg code */
break|break;
block|}
comment|/* for each arg that we expect */
name|error
label|:
if|if
condition|(
name|match
operator|==
literal|0
condition|)
block|{
comment|/* Args don't match. */
if|if
condition|(
operator|(
call|(
name|unsigned
call|)
argument_list|(
operator|&
name|insn
index|[
literal|1
index|]
operator|-
name|sparc_opcodes
argument_list|)
operator|)
operator|<
name|NUMOPCODES
operator|&&
operator|!
name|strcmp
argument_list|(
name|insn
operator|->
name|name
argument_list|,
name|insn
index|[
literal|1
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
operator|++
name|insn
expr_stmt|;
name|s
operator|=
name|argsStart
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|"Illegal operands%s"
argument_list|,
name|error_message
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
name|insn
operator|->
name|architecture
operator|>
name|current_architecture
condition|)
block|{
if|if
condition|(
operator|!
name|architecture_requested
operator|||
name|warn_on_bump
condition|)
block|{
if|if
condition|(
name|warn_on_bump
condition|)
block|{
name|as_warn
argument_list|(
literal|"architecture bumped from \"%s\" to \"%s\" on \"%s\""
argument_list|,
name|architecture_pname
index|[
name|current_architecture
index|]
argument_list|,
name|architecture_pname
index|[
name|insn
operator|->
name|architecture
index|]
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
comment|/* if warning */
name|current_architecture
operator|=
name|insn
operator|->
name|architecture
expr_stmt|;
block|}
else|else
block|{
name|as_bad
argument_list|(
literal|"architecture mismatch on \"%s\" (\"%s\").  current architecture is \"%s\""
argument_list|,
name|str
argument_list|,
name|architecture_pname
index|[
name|insn
operator|->
name|architecture
index|]
argument_list|,
name|architecture_pname
index|[
name|current_architecture
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* if bump ok else error */
block|}
comment|/* if architecture higher */
block|}
comment|/* if no match */
break|break;
block|}
comment|/* forever looking for a match */
name|the_insn
operator|.
name|opcode
operator|=
name|opcode
expr_stmt|;
if|#
directive|if
name|DEBUG_SPARC
if|if
condition|(
name|flagseen
index|[
literal|'D'
index|]
condition|)
name|print_insn
argument_list|(
operator|&
name|the_insn
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/* sparc_ip() */
end_comment

begin_function
specifier|static
name|int
name|getExpression
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|save_in
decl_stmt|;
name|segT
name|seg
decl_stmt|;
name|save_in
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|str
expr_stmt|;
switch|switch
condition|(
name|seg
operator|=
name|expression
argument_list|(
operator|&
name|the_insn
operator|.
name|exp
argument_list|)
condition|)
block|{
case|case
name|SEG_ABSOLUTE
case|:
case|case
name|SEG_TEXT
case|:
case|case
name|SEG_DATA
case|:
case|case
name|SEG_BSS
case|:
case|case
name|SEG_UNKNOWN
case|:
case|case
name|SEG_DIFFERENCE
case|:
case|case
name|SEG_BIG
case|:
case|case
name|SEG_ABSENT
case|:
break|break;
default|default:
name|the_insn
operator|.
name|error
operator|=
literal|"bad segment"
expr_stmt|;
name|expr_end
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
literal|1
return|;
block|}
name|expr_end
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|save_in
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* getExpression() */
end_comment

begin_comment
comment|/*   This is identical to the md_atof in m68k.c.  I think this is right,   but I'm not sure.    Turn a string in input_line_pointer into a floating point constant of type   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS   emitted is stored in *sizeP. An error message is returned, or NULL on OK.   */
end_comment

begin_comment
comment|/* Equal to MAX_PRECISION in atof-ieee.c */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|atof_ieee
parameter_list|()
function_decl|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|prec
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
literal|"Bad call to MD_ATOF()"
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|wordP
operator|=
name|words
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|wordP
operator|++
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
comment|/* Someone should teach Dean about null pointers */
block|}
end_function

begin_comment
comment|/* md_atof() */
end_comment

begin_comment
comment|/*  * Write out big-endian.  */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|4
case|:
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
case|case
literal|2
case|:
operator|*
name|buf
operator|++
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
case|case
literal|1
case|:
operator|*
name|buf
operator|=
name|val
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"md_number_to_chars: failed sanity check."
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* md_number_to_chars() */
end_comment

begin_function
specifier|static
name|int
name|reloc_check
parameter_list|(
name|val
parameter_list|,
name|bits
parameter_list|,
name|fixP
parameter_list|)
name|long
name|val
decl_stmt|;
name|int
name|bits
decl_stmt|;
name|fixS
modifier|*
name|fixP
comment|/* For reporting errors */
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|(
name|val
operator|&
operator|(
operator|-
literal|1
operator|<<
name|bits
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|val
operator|&
operator|(
operator|-
literal|1
operator|<<
name|bits
operator|)
operator|)
operator|!=
operator|(
operator|-
literal|1
operator|<<
operator|(
name|bits
operator|-
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
name|long
name|addr
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
decl_stmt|;
name|int
name|ln
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_frag
operator|->
name|line
condition|)
block|{
name|fname
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|line
operator|->
name|file
operator|->
name|filename
expr_stmt|;
name|ln
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|line
operator|->
name|line
expr_stmt|;
block|}
else|else
block|{
name|fname
operator|=
literal|""
expr_stmt|;
name|ln
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|as_warn_where
argument_list|(
name|fname
argument_list|,
name|ln
argument_list|,
literal|"Relocation (%s) overflow at %#x, value truncated."
argument_list|,
name|Reloc
index|[
name|fixP
operator|->
name|fx_r_type
index|]
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* on overflow */
block|}
end_function

begin_comment
comment|/* reloc_check() */
end_comment

begin_comment
comment|/* Apply a fixS to the frags, now that we know the value it ought to    hold. */
end_comment

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixP
parameter_list|,
name|val
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|long
name|val
decl_stmt|;
block|{
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
name|long
name|addr
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
decl_stmt|;
if|#
directive|if
name|DEBUG_SPARC
if|if
condition|(
name|flagseen
index|[
literal|'D'
index|]
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"md_apply_fix: \"%s\" \"%s\", val %d -- %s\n"
argument_list|,
operator|(
operator|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
operator|)
condition|?
operator|(
operator|(
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|NULL
operator|)
condition|?
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
else|:
literal|"???"
operator|)
else|:
literal|"0"
operator|)
argument_list|,
operator|(
operator|(
name|fixP
operator|->
name|fx_subsy
operator|!=
name|NULL
operator|)
condition|?
operator|(
operator|(
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
operator|!=
name|NULL
operator|)
condition|?
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
else|:
literal|"???"
operator|)
else|:
literal|"0"
operator|)
argument_list|,
name|val
argument_list|,
name|Reloc
index|[
name|fixP
operator|->
name|fx_r_type
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|assert
argument_list|(
name|fixP
operator|->
name|fx_size
operator|==
literal|4
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fixP
operator|->
name|fx_r_type
operator|<
name|NO_RELOC
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_addnumber
operator|=
name|val
expr_stmt|;
comment|/* Remember value for emit_reloc */
comment|/* 	 * This is a hack.  There should be a better way to 	 * handle this. 	 */
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|==
name|RELOC_WDISP30
operator|&&
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|val
operator|+=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
expr_stmt|;
block|}
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
comment|/* Michael Bloom<mb@ttidca.tti.com> says...  [This] change was 		   made to match the behavior of Sun's assembler.  Some broken 		   loaders depend on that. At least one such loader actually 		   adds the section data to what it finds in the addend. (It 		   should only be using the addend like Sun's loader seems to). 		   This caused incorrect relocation: (addend + adjustment) 		   became  ( ( 2 * addend ) + adjustment ).  [and there should 		   be no cases that reach here anyway.  */
case|case
name|RELOC_32
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Ok, the remarks above do not hold if the 			 * expression has been reduced to a number. 			 */
name|buf
index|[
literal|0
index|]
operator|=
name|val
operator|>>
literal|24
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|val
operator|>>
literal|16
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|RELOC_JMP_TBL
case|:
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|val
operator|=
operator|(
name|val
operator|>>=
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
name|reloc_check
argument_list|(
name|val
argument_list|,
literal|30
argument_list|,
name|fixP
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator||=
operator|(
name|val
operator|>>
literal|24
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
block|}
break|break;
case|case
name|RELOC_WDISP30
case|:
name|val
operator|=
operator|(
name|val
operator|>>=
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
name|reloc_check
argument_list|(
name|val
argument_list|,
literal|30
argument_list|,
name|fixP
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator||=
operator|(
name|val
operator|>>
literal|24
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|RELOC_WDISP22
case|:
name|val
operator|=
operator|(
name|val
operator|>>=
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
name|reloc_check
argument_list|(
name|val
argument_list|,
literal|22
argument_list|,
name|fixP
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator||=
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
break|break;
comment|/* 	 * We should only use the RELOC_HI22 type as a result of the %hi 	 * operator (which is implicit in the case of the `set' pseudo op), 	 * This is NOT the same as using the `sethi' instruction, which merely 	 * puts the 22 bit operand into the high 22 bits of the destination 	 * register. 	 */
case|case
name|RELOC_22
case|:
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|reloc_check
argument_list|(
name|val
argument_list|,
literal|22
argument_list|,
name|fixP
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator||=
operator|(
name|val
operator|>>
literal|16
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
block|}
break|break;
case|case
name|RELOC_HI22
case|:
case|case
name|RELOC_BASE22
case|:
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|buf
index|[
literal|1
index|]
operator||=
operator|(
name|val
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|val
operator|>>
literal|18
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
operator|>>
literal|10
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|picmode
operator|&&
name|fixP
operator|->
name|fx_r_type
operator|==
name|RELOC_HI22
condition|)
name|as_warn
argument_list|(
literal|"non-PIC access to %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|RELOC_13
case|:
case|case
name|RELOC_BASE13
case|:
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|reloc_check
argument_list|(
name|val
argument_list|,
literal|13
argument_list|,
name|fixP
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator||=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
expr_stmt|;
block|}
else|else
block|{
name|buf
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|RELOC_LO10
case|:
case|case
name|RELOC_BASE10
case|:
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|buf
index|[
literal|2
index|]
operator||=
operator|(
name|val
operator|>>
literal|8
operator|)
operator|&
literal|0x03
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|picmode
operator|&&
name|fixP
operator|->
name|fx_r_type
operator|==
name|RELOC_LO10
condition|)
name|as_warn
argument_list|(
literal|"non-PIC access to %s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|)
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|RELOC_PC10
case|:
case|case
name|RELOC_PC22
case|:
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|GOT_symbol
condition|)
block|{
name|as_fatal
argument_list|(
literal|"GOT"
argument_list|)
expr_stmt|;
block|}
break|break;
if|#
directive|if
literal|0
block|case RELOC_8:
comment|/* These don't seem to ever be needed. */
block|case RELOC_16: 	case RELOC_DISP8: 	case RELOC_DISP16: 	case RELOC_DISP32: 	case RELOC_SEGOFF16: 	case RELOC_SFA_BASE: 	case RELOC_SFA_OFF13:  	case RELOC_GLOB_DAT:
comment|/* These are output by linker only */
block|case RELOC_JMP_SLOT: 	case RELOC_RELATIVE:
endif|#
directive|endif
case|case
name|NO_RELOC
case|:
default|default:
name|as_bad
argument_list|(
literal|"bad relocation type: 0x%02x"
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* md_apply_fix() */
end_comment

begin_comment
comment|/* should never be called for sparc */
end_comment

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|long
name|from_addr
decl_stmt|;
name|long
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|as_fatal
argument_list|(
literal|"sparc_create_short_jmp\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* md_create_short_jump() */
end_comment

begin_comment
comment|/* Translate internal representation of relocation info to target format.     On sparc: first 4 bytes are normal unsigned long address, next three    bytes are index, most sig. byte first.  Byte 7 is broken up with    bit 7 as external, bits 6& 5 unused, and the lower    five bits as relocation type.  Next 4 bytes are long addend. */
end_comment

begin_comment
comment|/* Thanx and a tip of the hat to Michael Bloom, mb@ttidca.tti.com */
end_comment

begin_function
name|void
name|tc_aout_fix_to_chars
parameter_list|(
name|where
parameter_list|,
name|fixP
parameter_list|,
name|segment_address_in_file
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|relax_addressT
name|segment_address_in_file
decl_stmt|;
block|{
name|long
name|r_index
decl_stmt|;
name|long
name|r_extern
decl_stmt|;
name|long
name|r_addend
init|=
literal|0
decl_stmt|;
name|long
name|r_address
decl_stmt|;
ifdef|#
directive|ifdef
name|PIC
name|int
name|kflag
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|know
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
name|r_extern
operator|=
literal|1
expr_stmt|;
name|r_index
operator|=
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_number
expr_stmt|;
block|}
else|else
block|{
name|r_extern
operator|=
literal|0
expr_stmt|;
name|r_index
operator|=
name|S_GET_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PIC
if|if
condition|(
name|picmode
condition|)
block|{
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|RELOC_BASE10
case|:
case|case
name|RELOC_BASE13
case|:
case|case
name|RELOC_BASE22
case|:
name|r_index
operator|=
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_number
expr_stmt|;
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
name|r_extern
operator|=
literal|1
expr_stmt|;
name|kflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RELOC_32
case|:
if|if
condition|(
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
break|break;
name|r_extern
operator|=
literal|1
expr_stmt|;
name|r_index
operator|=
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_number
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
endif|#
directive|endif
block|}
comment|/* this is easy */
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|r_address
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|segment_address_in_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* now the fun stuff */
name|where
index|[
literal|4
index|]
operator|=
operator|(
name|r_index
operator|>>
literal|16
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|5
index|]
operator|=
operator|(
name|r_index
operator|>>
literal|8
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|6
index|]
operator|=
name|r_index
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|7
index|]
operator|=
operator|(
operator|(
name|r_extern
operator|<<
literal|7
operator|)
operator|&
literal|0x80
operator|)
operator||
operator|(
literal|0
operator|&
literal|0x60
operator|)
operator||
operator|(
name|fixP
operator|->
name|fx_r_type
operator|&
literal|0x1F
operator|)
expr_stmt|;
comment|/* Also easy */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_frag
condition|)
block|{
name|r_addend
operator|=
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_frag
operator|->
name|fr_address
expr_stmt|;
block|}
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
block|{
ifdef|#
directive|ifdef
name|PIC
if|if
condition|(
name|fixP
operator|->
name|fx_gotsy
condition|)
block|{
name|r_addend
operator|=
name|r_address
expr_stmt|;
name|r_addend
operator|+=
name|fixP
operator|->
name|fx_addnumber
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|r_addend
operator|-=
name|r_address
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|PIC
if|if
condition|(
name|kflag
condition|)
name|r_addend
operator|=
literal|0
expr_stmt|;
else|else
endif|#
directive|endif
name|r_addend
operator|=
name|fixP
operator|->
name|fx_addnumber
expr_stmt|;
block|}
name|md_number_to_chars
argument_list|(
operator|&
name|where
index|[
literal|8
index|]
argument_list|,
name|r_addend
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tc_aout_fix_to_chars() */
end_comment

begin_comment
comment|/* should never be called for sparc */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|headers
parameter_list|,
name|fragP
parameter_list|)
name|object_headers
modifier|*
name|headers
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|as_fatal
argument_list|(
literal|"sparc_convert_frag\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* md_convert_frag() */
end_comment

begin_comment
comment|/* should never be called for sparc */
end_comment

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|long
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|as_fatal
argument_list|(
literal|"sparc_create_long_jump\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* md_create_long_jump() */
end_comment

begin_comment
comment|/* should never be called for sparc */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segtype
parameter_list|)
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|segT
name|segtype
decl_stmt|;
block|{
name|as_fatal
argument_list|(
literal|"sparc_estimate_size_before_relax\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* md_estimate_size_before_relax() */
end_comment

begin_if
if|#
directive|if
name|DEBUG_SPARC
end_if

begin_comment
comment|/* for debugging only */
end_comment

begin_function
specifier|static
name|void
name|print_insn
parameter_list|(
name|insn
parameter_list|)
name|struct
name|sparc_it
modifier|*
name|insn
decl_stmt|;
block|{
if|if
condition|(
name|insn
operator|->
name|error
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR: %s\n"
argument_list|,
name|insn
operator|->
name|error
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"opcode=0x%08x\n"
argument_list|,
name|insn
operator|->
name|opcode
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"reloc = %s\n"
argument_list|,
name|Reloc
index|[
name|insn
operator|->
name|reloc
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"exp = {\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\tX_add_symbol = %s\n"
argument_list|,
operator|(
operator|(
name|insn
operator|->
name|exp
operator|.
name|X_add_symbol
operator|!=
name|NULL
operator|)
condition|?
operator|(
operator|(
name|S_GET_NAME
argument_list|(
name|insn
operator|->
name|exp
operator|.
name|X_add_symbol
argument_list|)
operator|!=
name|NULL
operator|)
condition|?
name|S_GET_NAME
argument_list|(
name|insn
operator|->
name|exp
operator|.
name|X_add_symbol
argument_list|)
else|:
literal|"???"
operator|)
else|:
literal|"0"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\tX_sub_symbol = %s\n"
argument_list|,
operator|(
operator|(
name|insn
operator|->
name|exp
operator|.
name|X_subtract_symbol
operator|!=
name|NULL
operator|)
condition|?
operator|(
name|S_GET_NAME
argument_list|(
name|insn
operator|->
name|exp
operator|.
name|X_subtract_symbol
argument_list|)
condition|?
name|S_GET_NAME
argument_list|(
name|insn
operator|->
name|exp
operator|.
name|X_subtract_symbol
argument_list|)
else|:
literal|"???"
operator|)
else|:
literal|"0"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\tX_got_symbol = %s\n"
argument_list|,
operator|(
operator|(
name|insn
operator|->
name|exp
operator|.
name|X_got_symbol
operator|!=
name|NULL
operator|)
condition|?
operator|(
name|S_GET_NAME
argument_list|(
name|insn
operator|->
name|exp
operator|.
name|X_got_symbol
argument_list|)
condition|?
name|S_GET_NAME
argument_list|(
name|insn
operator|->
name|exp
operator|.
name|X_got_symbol
argument_list|)
else|:
literal|"???"
operator|)
else|:
literal|"0"
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\tX_add_number = %d\n"
argument_list|,
name|insn
operator|->
name|exp
operator|.
name|X_add_number
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* print_insn() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Set the hook... */
end_comment

begin_comment
comment|/* void emit_sparc_reloc();    void (*md_emit_relocations)() = emit_sparc_reloc; */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|comment
end_ifdef

begin_comment
comment|/*  * Sparc/AM29K relocations are completely different, so it needs  * this machine dependent routine to emit them.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator|||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
end_if

begin_function
name|void
name|emit_sparc_reloc
parameter_list|(
name|fixP
parameter_list|,
name|segment_address_in_file
parameter_list|)
specifier|register
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|relax_addressT
name|segment_address_in_file
decl_stmt|;
block|{
name|struct
name|reloc_info_generic
name|ri
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
specifier|extern
name|char
modifier|*
name|next_object_file_charP
decl_stmt|;
comment|/*    long add_number; */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ri
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ri
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
block|{
if|if
condition|(
name|fixP
operator|->
name|fx_r_type
operator|>=
name|NO_RELOC
condition|)
block|{
name|as_fatal
argument_list|(
literal|"fixP->fx_r_type = %d\n"
argument_list|,
name|fixP
operator|->
name|fx_r_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|symbolP
operator|=
name|fixP
operator|->
name|fx_addsy
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ri
operator|.
name|r_address
operator|=
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|segment_address_in_file
expr_stmt|;
if|if
condition|(
operator|(
name|S_GET_TYPE
argument_list|(
name|symbolP
argument_list|)
operator|)
operator|==
name|N_UNDF
condition|)
block|{
name|ri
operator|.
name|r_extern
operator|=
literal|1
expr_stmt|;
name|ri
operator|.
name|r_index
operator|=
name|symbolP
operator|->
name|sy_number
expr_stmt|;
block|}
else|else
block|{
name|ri
operator|.
name|r_extern
operator|=
literal|0
expr_stmt|;
name|ri
operator|.
name|r_index
operator|=
name|S_GET_TYPE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|symbolP
operator|&&
name|symbolP
operator|->
name|sy_frag
condition|)
block|{
name|ri
operator|.
name|r_addend
operator|=
name|symbolP
operator|->
name|sy_frag
operator|->
name|fr_address
expr_stmt|;
block|}
name|ri
operator|.
name|r_type
operator|=
name|fixP
operator|->
name|fx_r_type
expr_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
block|{
comment|/*		ri.r_addend -= fixP->fx_where; */
name|ri
operator|.
name|r_addend
operator|-=
name|ri
operator|.
name|r_address
expr_stmt|;
block|}
else|else
block|{
name|ri
operator|.
name|r_addend
operator|=
name|fixP
operator|->
name|fx_addnumber
expr_stmt|;
block|}
name|md_ri_to_chars
argument_list|(
name|next_object_file_charP
argument_list|,
operator|&
name|ri
argument_list|)
expr_stmt|;
name|next_object_file_charP
operator|+=
name|md_reloc_size
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* emit_sparc_reloc() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* aout or bout */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* comment */
end_comment

begin_comment
comment|/*  * md_parse_option  *	Invocation line includes a switch not recognized by the base assembler.  *	See if it's a processor-specific option.  These are:  *  *	-bump  *		Warn on architecture bumps.  See also -A.  *  *	-Av6, -Av7, -Av8  *		Select the architecture.  Instructions or features not  *		supported by the selected architecture cause fatal errors.  *  *		The default is to start at v6, and bump the architecture up  *		whenever an instruction is seen at a higher level.  *  *		If -bump is specified, a warning is printing when bumping to  *		higher levels.  *  *		If an architecture is specified, all instructions must match  *		that architecture.  Any higher level instructions are flagged  *		as errors.  *  *		if both an architecture and -bump are specified, the  *		architecture starts at the specified level, but bumps are  *		warnings.  *  */
end_comment

begin_function
name|int
name|md_parse_option
parameter_list|(
name|argP
parameter_list|,
name|cntP
parameter_list|,
name|vecP
parameter_list|)
name|char
modifier|*
modifier|*
name|argP
decl_stmt|;
name|int
modifier|*
name|cntP
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|vecP
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|arch
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argP
argument_list|,
literal|"bump"
argument_list|)
condition|)
block|{
name|warn_on_bump
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|argP
operator|==
literal|'A'
condition|)
block|{
name|p
operator|=
operator|(
operator|*
name|argP
operator|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|arch
operator|=
name|architecture_pname
init|;
operator|*
name|arch
operator|!=
name|NULL
condition|;
operator|++
name|arch
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
operator|*
name|arch
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
comment|/* found a match */
block|}
comment|/* walk the pname table */
if|if
condition|(
operator|*
name|arch
operator|==
name|NULL
condition|)
block|{
name|as_bad
argument_list|(
literal|"unknown architecture: %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current_architecture
operator|=
operator|(
expr|enum
name|sparc_architecture
operator|)
operator|(
name|arch
operator|-
name|architecture_pname
operator|)
expr_stmt|;
name|architecture_requested
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PIC
block|}
elseif|else
if|if
condition|(
operator|*
operator|*
name|argP
operator|==
literal|'k'
operator|||
operator|*
operator|*
name|argP
operator|==
literal|'K'
condition|)
block|{
comment|/* Predefine GOT symbol */
name|GOT_symbol
operator|=
name|symbol_find_or_make
argument_list|(
literal|"__GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Unknown option */
operator|(
operator|*
name|argP
operator|)
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
operator|*
name|argP
operator|=
literal|'\0'
expr_stmt|;
comment|/* Done parsing this switch */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* md_parse_option() */
end_comment

begin_comment
comment|/* We have no need to default values of symbols. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* md_undefined_symbol() */
end_comment

begin_comment
comment|/* Parse an operand that is machine-specific.    We just return without modifying the expression if we have nothing    to do. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* md_operand() */
end_comment

begin_comment
comment|/* Round up a section size to the appropriate boundary. */
end_comment

begin_function
name|long
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|size
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
return|;
comment|/* Round all sects to multiple of 8 */
block|}
end_function

begin_comment
comment|/* md_section_align() */
end_comment

begin_comment
comment|/* Exactly what point is a PC-relative offset relative TO?    On the sparc, they're relative to the address of the offset, plus    its size.  This gets us to the following instruction.    (??? Is this right?  FIXME-SOON) */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|PIC
comment|/* 	 * _GLOBAL_OFFSET_TABLE_ refs are relative to the offset of the 	 * current instruction. We omit fx_size from the computation (which 	 * is always 4 anyway). 	 */
if|if
condition|(
name|fixP
operator|->
name|fx_gotsy
condition|)
return|return
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
else|else
endif|#
directive|endif
return|return
operator|(
name|fixP
operator|->
name|fx_size
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|)
return|;
block|}
end_function

begin_comment
comment|/* md_pcrel_from() */
end_comment

begin_function
name|void
name|tc_aout_pre_write_hook
parameter_list|(
name|headers
parameter_list|)
name|object_headers
modifier|*
name|headers
decl_stmt|;
block|{
name|H_SET_VERSION
argument_list|(
name|headers
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tc_aout_pre_write_hook() */
end_comment

begin_comment
comment|/*  * Local Variables:  * comment-column: 0  * fill-column: 131  * End:  */
end_comment

begin_comment
comment|/* end of tc-sparc.c */
end_comment

end_unit

