begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* atof_ieee.c - turn a Flonum into an IEEE floating point number    Copyright (C) 1987, 1992 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: atof-ieee.c,v 1.3 1995/05/30 04:46:46 rgrimes Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_decl_stmt
specifier|extern
name|FLONUM_TYPE
name|generic_floating_point_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flonums returned here. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
name|EXP_CHARS
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Precision in LittleNums. */
end_comment

begin_define
define|#
directive|define
name|MAX_PRECISION
value|(6)
end_define

begin_define
define|#
directive|define
name|F_PRECISION
value|(2)
end_define

begin_define
define|#
directive|define
name|D_PRECISION
value|(4)
end_define

begin_define
define|#
directive|define
name|X_PRECISION
value|(6)
end_define

begin_define
define|#
directive|define
name|P_PRECISION
value|(6)
end_define

begin_comment
comment|/* Length in LittleNums of guard bits. */
end_comment

begin_define
define|#
directive|define
name|GUARD
value|(2)
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|mask
index|[]
init|=
block|{
literal|0x00000000
block|,
literal|0x00000001
block|,
literal|0x00000003
block|,
literal|0x00000007
block|,
literal|0x0000000f
block|,
literal|0x0000001f
block|,
literal|0x0000003f
block|,
literal|0x0000007f
block|,
literal|0x000000ff
block|,
literal|0x000001ff
block|,
literal|0x000003ff
block|,
literal|0x000007ff
block|,
literal|0x00000fff
block|,
literal|0x00001fff
block|,
literal|0x00003fff
block|,
literal|0x00007fff
block|,
literal|0x0000ffff
block|,
literal|0x0001ffff
block|,
literal|0x0003ffff
block|,
literal|0x0007ffff
block|,
literal|0x000fffff
block|,
literal|0x001fffff
block|,
literal|0x003fffff
block|,
literal|0x007fffff
block|,
literal|0x00ffffff
block|,
literal|0x01ffffff
block|,
literal|0x03ffffff
block|,
literal|0x07ffffff
block|,
literal|0x0fffffff
block|,
literal|0x1fffffff
block|,
literal|0x3fffffff
block|,
literal|0x7fffffff
block|,
literal|0xffffffff
block|, }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|bits_left_in_littlenum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|littlenums_left
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|LITTLENUM_TYPE
modifier|*
name|littlenum_pointer
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|next_bits
parameter_list|(
name|number_of_bits
parameter_list|)
name|int
name|number_of_bits
decl_stmt|;
block|{
name|int
name|return_value
decl_stmt|;
if|if
condition|(
operator|!
name|littlenums_left
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|number_of_bits
operator|>=
name|bits_left_in_littlenum
condition|)
block|{
name|return_value
operator|=
name|mask
index|[
name|bits_left_in_littlenum
index|]
operator|&
operator|*
name|littlenum_pointer
expr_stmt|;
name|number_of_bits
operator|-=
name|bits_left_in_littlenum
expr_stmt|;
name|return_value
operator|<<=
name|number_of_bits
expr_stmt|;
if|if
condition|(
operator|--
name|littlenums_left
condition|)
block|{
name|bits_left_in_littlenum
operator|=
name|LITTLENUM_NUMBER_OF_BITS
operator|-
name|number_of_bits
expr_stmt|;
operator|--
name|littlenum_pointer
expr_stmt|;
name|return_value
operator||=
operator|(
operator|*
name|littlenum_pointer
operator|>>
name|bits_left_in_littlenum
operator|)
operator|&
name|mask
index|[
name|number_of_bits
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|bits_left_in_littlenum
operator|-=
name|number_of_bits
expr_stmt|;
name|return_value
operator|=
name|mask
index|[
name|number_of_bits
index|]
operator|&
operator|(
operator|*
name|littlenum_pointer
operator|>>
name|bits_left_in_littlenum
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|return_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Num had better be less than LITTLENUM_NUMBER_OF_BITS */
end_comment

begin_function
specifier|static
name|void
name|unget_bits
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|littlenums_left
condition|)
block|{
operator|++
name|littlenum_pointer
expr_stmt|;
operator|++
name|littlenums_left
expr_stmt|;
name|bits_left_in_littlenum
operator|=
name|num
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bits_left_in_littlenum
operator|+
name|num
operator|>
name|LITTLENUM_NUMBER_OF_BITS
condition|)
block|{
name|bits_left_in_littlenum
operator|=
name|num
operator|-
operator|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
name|bits_left_in_littlenum
operator|)
expr_stmt|;
operator|++
name|littlenum_pointer
expr_stmt|;
operator|++
name|littlenums_left
expr_stmt|;
block|}
else|else
name|bits_left_in_littlenum
operator|+=
name|num
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|make_invalid_floating_point_number
parameter_list|(
name|words
parameter_list|)
name|LITTLENUM_TYPE
modifier|*
name|words
decl_stmt|;
block|{
name|as_bad
argument_list|(
literal|"cannot create floating-point number"
argument_list|)
expr_stmt|;
name|words
index|[
literal|0
index|]
operator|=
name|LITTLENUM_MASK
operator|>>
literal|1
expr_stmt|;
comment|/* Zero the leftmost bit */
name|words
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|words
index|[
literal|2
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|words
index|[
literal|3
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|words
index|[
literal|4
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|words
index|[
literal|5
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/***********************************************************************\  *	Warning: this returns 16-bit LITTLENUMs. It is up to the caller	*  *	to figure out any alignment problems and to conspire for the	*  *	bytes/word to be emitted in the right order. Bigendians beware!	*  *									*  \***********************************************************************/
end_comment

begin_comment
comment|/* Note that atof-ieee always has X and P precisions enabled.  it is up    to md_atof to filter them out if the target machine does not support    them.  */
end_comment

begin_function
name|char
modifier|*
comment|/* Return pointer past text consumed. */
name|atof_ieee
parameter_list|(
name|str
parameter_list|,
name|what_kind
parameter_list|,
name|words
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
comment|/* Text to convert to binary. */
name|char
name|what_kind
decl_stmt|;
comment|/* 'd', 'f', 'g', 'h' */
name|LITTLENUM_TYPE
modifier|*
name|words
decl_stmt|;
comment|/* Build the binary here. */
block|{
specifier|static
name|LITTLENUM_TYPE
name|bits
index|[
name|MAX_PRECISION
operator|+
name|MAX_PRECISION
operator|+
name|GUARD
index|]
decl_stmt|;
comment|/* Extra bits for zeroed low-order bits. */
comment|/* The 1st MAX_PRECISION are zeroed, */
comment|/* the last contain flonum bits. */
name|char
modifier|*
name|return_value
decl_stmt|;
name|int
name|precision
decl_stmt|;
comment|/* Number of 16-bit words in the format. */
name|long
name|exponent_bits
decl_stmt|;
name|FLONUM_TYPE
name|save_gen_flonum
decl_stmt|;
comment|/* We have to save the generic_floating_point_number because it 	   contains storage allocation about the array of LITTLENUMs 	   where the value is actually stored.  We will allocate our 	   own array of littlenums below, but have to restore the global 	   one on exit.  */
name|save_gen_flonum
operator|=
name|generic_floating_point_number
expr_stmt|;
name|return_value
operator|=
name|str
expr_stmt|;
name|generic_floating_point_number
operator|.
name|low
operator|=
name|bits
operator|+
name|MAX_PRECISION
expr_stmt|;
name|generic_floating_point_number
operator|.
name|high
operator|=
name|NULL
expr_stmt|;
name|generic_floating_point_number
operator|.
name|leader
operator|=
name|NULL
expr_stmt|;
name|generic_floating_point_number
operator|.
name|exponent
operator|=
name|NULL
expr_stmt|;
name|generic_floating_point_number
operator|.
name|sign
operator|=
literal|'\0'
expr_stmt|;
comment|/* Use more LittleNums than seems */
comment|/* necessary: the highest flonum may have */
comment|/* 15 leading 0 bits, so could be useless. */
name|memset
argument_list|(
name|bits
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
operator|*
name|MAX_PRECISION
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|what_kind
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
name|precision
operator|=
name|F_PRECISION
expr_stmt|;
name|exponent_bits
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|precision
operator|=
name|D_PRECISION
expr_stmt|;
name|exponent_bits
operator|=
literal|11
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
name|precision
operator|=
name|X_PRECISION
expr_stmt|;
name|exponent_bits
operator|=
literal|15
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|precision
operator|=
name|P_PRECISION
expr_stmt|;
name|exponent_bits
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|make_invalid_floating_point_number
argument_list|(
name|words
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|generic_floating_point_number
operator|.
name|high
operator|=
name|generic_floating_point_number
operator|.
name|low
operator|+
name|precision
operator|-
literal|1
operator|+
name|GUARD
expr_stmt|;
if|if
condition|(
name|atof_generic
argument_list|(
operator|&
name|return_value
argument_list|,
literal|"."
argument_list|,
name|EXP_CHARS
argument_list|,
operator|&
name|generic_floating_point_number
argument_list|)
condition|)
block|{
comment|/* as_bad("Error converting floating point number (Exponent overflow?)"); */
name|make_invalid_floating_point_number
argument_list|(
name|words
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|gen_to_words
argument_list|(
name|words
argument_list|,
name|precision
argument_list|,
name|exponent_bits
argument_list|)
expr_stmt|;
comment|/* Restore the generic_floating_point_number's storage alloc 	   (and everything else).  */
name|generic_floating_point_number
operator|=
name|save_gen_flonum
expr_stmt|;
return|return
operator|(
name|return_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Turn generic_floating_point_number into a real float/double/extended */
end_comment

begin_function
name|int
name|gen_to_words
parameter_list|(
name|words
parameter_list|,
name|precision
parameter_list|,
name|exponent_bits
parameter_list|)
name|LITTLENUM_TYPE
modifier|*
name|words
decl_stmt|;
name|int
name|precision
decl_stmt|;
name|long
name|exponent_bits
decl_stmt|;
block|{
name|int
name|return_value
init|=
literal|0
decl_stmt|;
name|long
name|exponent_1
decl_stmt|;
name|long
name|exponent_2
decl_stmt|;
name|long
name|exponent_3
decl_stmt|;
name|long
name|exponent_4
decl_stmt|;
name|int
name|exponent_skippage
decl_stmt|;
name|LITTLENUM_TYPE
name|word1
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|generic_floating_point_number
operator|.
name|low
operator|>
name|generic_floating_point_number
operator|.
name|leader
condition|)
block|{
comment|/* 0.0e0 seen. */
if|if
condition|(
name|generic_floating_point_number
operator|.
name|sign
operator|==
literal|'+'
condition|)
name|words
index|[
literal|0
index|]
operator|=
literal|0x0000
expr_stmt|;
else|else
name|words
index|[
literal|0
index|]
operator|=
literal|0x8000
expr_stmt|;
name|memset
argument_list|(
operator|&
name|words
index|[
literal|1
index|]
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
operator|*
operator|(
name|precision
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|return_value
operator|)
return|;
block|}
comment|/* NaN:  Do the right thing */
if|if
condition|(
name|generic_floating_point_number
operator|.
name|sign
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|precision
operator|==
name|F_PRECISION
condition|)
block|{
name|words
index|[
literal|0
index|]
operator|=
literal|0x7fff
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
name|words
index|[
literal|0
index|]
operator|=
literal|0x7fff
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
literal|0xffff
expr_stmt|;
name|words
index|[
literal|2
index|]
operator|=
literal|0xffff
expr_stmt|;
name|words
index|[
literal|3
index|]
operator|=
literal|0xffff
expr_stmt|;
block|}
return|return
name|return_value
return|;
block|}
elseif|else
if|if
condition|(
name|generic_floating_point_number
operator|.
name|sign
operator|==
literal|'P'
condition|)
block|{
comment|/* +INF:  Do the right thing */
if|if
condition|(
name|precision
operator|==
name|F_PRECISION
condition|)
block|{
name|words
index|[
literal|0
index|]
operator|=
literal|0x7f80
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|words
index|[
literal|0
index|]
operator|=
literal|0x7ff0
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|words
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|words
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|return_value
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|generic_floating_point_number
operator|.
name|sign
operator|==
literal|'N'
condition|)
block|{
comment|/* Negative INF */
if|if
condition|(
name|precision
operator|==
name|F_PRECISION
condition|)
block|{
name|words
index|[
literal|0
index|]
operator|=
literal|0xff80
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
literal|0x0
expr_stmt|;
block|}
else|else
block|{
name|words
index|[
literal|0
index|]
operator|=
literal|0xfff0
expr_stmt|;
name|words
index|[
literal|1
index|]
operator|=
literal|0x0
expr_stmt|;
name|words
index|[
literal|2
index|]
operator|=
literal|0x0
expr_stmt|;
name|words
index|[
literal|3
index|]
operator|=
literal|0x0
expr_stmt|;
block|}
return|return
operator|(
name|return_value
operator|)
return|;
block|}
comment|/* 	 * The floating point formats we support have: 	 * Bit 15 is sign bit. 	 * Bits 14:n are excess-whatever exponent. 	 * Bits n-1:0 (if any) are most significant bits of fraction. 	 * Bits 15:0 of the next word(s) are the next most significant bits. 	 * 	 * So we need: number of bits of exponent, number of bits of 	 * mantissa. 	 */
name|bits_left_in_littlenum
operator|=
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
name|littlenum_pointer
operator|=
name|generic_floating_point_number
operator|.
name|leader
expr_stmt|;
name|littlenums_left
operator|=
literal|1
operator|+
name|generic_floating_point_number
operator|.
name|leader
operator|-
name|generic_floating_point_number
operator|.
name|low
expr_stmt|;
comment|/* Seek (and forget) 1st significant bit */
for|for
control|(
name|exponent_skippage
operator|=
literal|0
init|;
operator|!
name|next_bits
argument_list|(
literal|1
argument_list|)
condition|;
operator|++
name|exponent_skippage
control|)
empty_stmt|;
empty_stmt|;
name|exponent_1
operator|=
name|generic_floating_point_number
operator|.
name|exponent
operator|+
name|generic_floating_point_number
operator|.
name|leader
operator|+
literal|1
operator|-
name|generic_floating_point_number
operator|.
name|low
expr_stmt|;
comment|/* Radix LITTLENUM_RADIX, point just higher than generic_floating_point_number.leader. */
name|exponent_2
operator|=
name|exponent_1
operator|*
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
comment|/* Radix 2. */
name|exponent_3
operator|=
name|exponent_2
operator|-
name|exponent_skippage
expr_stmt|;
comment|/* Forget leading zeros, forget 1st bit. */
name|exponent_4
operator|=
name|exponent_3
operator|+
operator|(
operator|(
literal|1
operator|<<
operator|(
name|exponent_bits
operator|-
literal|1
operator|)
operator|)
operator|-
literal|2
operator|)
expr_stmt|;
comment|/* Offset exponent. */
name|lp
operator|=
name|words
expr_stmt|;
comment|/* Word 1. Sign, exponent and perhaps high bits. */
name|word1
operator|=
operator|(
name|generic_floating_point_number
operator|.
name|sign
operator|==
literal|'+'
operator|)
condition|?
literal|0
else|:
operator|(
literal|1
operator|<<
operator|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* Assume 2's complement integers. */
if|if
condition|(
name|exponent_4
operator|<
literal|1
operator|&&
name|exponent_4
operator|>=
operator|-
literal|62
condition|)
block|{
name|int
name|prec_bits
decl_stmt|;
name|int
name|num_bits
decl_stmt|;
name|unget_bits
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|num_bits
operator|=
operator|-
name|exponent_4
expr_stmt|;
name|prec_bits
operator|=
name|LITTLENUM_NUMBER_OF_BITS
operator|*
name|precision
operator|-
operator|(
name|exponent_bits
operator|+
literal|1
operator|+
name|num_bits
operator|)
expr_stmt|;
if|if
condition|(
name|precision
operator|==
name|X_PRECISION
operator|&&
name|exponent_bits
operator|==
literal|15
condition|)
name|prec_bits
operator|-=
name|LITTLENUM_NUMBER_OF_BITS
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|num_bits
operator|>=
name|LITTLENUM_NUMBER_OF_BITS
operator|-
name|exponent_bits
condition|)
block|{
comment|/* Bigger than one littlenum */
name|num_bits
operator|-=
operator|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
literal|1
operator|)
operator|-
name|exponent_bits
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
name|word1
expr_stmt|;
if|if
condition|(
name|num_bits
operator|+
name|exponent_bits
operator|+
literal|1
operator|>=
name|precision
operator|*
name|LITTLENUM_NUMBER_OF_BITS
condition|)
block|{
comment|/* Exponent overflow */
name|make_invalid_floating_point_number
argument_list|(
name|words
argument_list|)
expr_stmt|;
return|return
operator|(
name|return_value
operator|)
return|;
block|}
if|if
condition|(
name|precision
operator|==
name|X_PRECISION
operator|&&
name|exponent_bits
operator|==
literal|15
condition|)
block|{
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
name|num_bits
operator|-=
name|LITTLENUM_NUMBER_OF_BITS
operator|-
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|num_bits
operator|>=
name|LITTLENUM_NUMBER_OF_BITS
condition|)
block|{
name|num_bits
operator|-=
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|num_bits
condition|)
operator|*
name|lp
operator|++
operator|=
name|next_bits
argument_list|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
operator|(
name|num_bits
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|precision
operator|==
name|X_PRECISION
operator|&&
name|exponent_bits
operator|==
literal|15
condition|)
block|{
operator|*
name|lp
operator|++
operator|=
name|word1
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|num_bits
operator|==
name|LITTLENUM_NUMBER_OF_BITS
condition|)
block|{
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
name|next_bits
argument_list|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num_bits
operator|==
name|LITTLENUM_NUMBER_OF_BITS
operator|-
literal|1
condition|)
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|lp
operator|++
operator|=
name|next_bits
argument_list|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
literal|1
operator|-
name|num_bits
argument_list|)
expr_stmt|;
name|num_bits
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|word1
operator||=
name|next_bits
argument_list|(
operator|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
literal|1
operator|)
operator|-
operator|(
name|exponent_bits
operator|+
name|num_bits
operator|)
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
name|word1
expr_stmt|;
block|}
block|}
while|while
condition|(
name|lp
operator|<
name|words
operator|+
name|precision
condition|)
operator|*
name|lp
operator|++
operator|=
name|next_bits
argument_list|(
name|LITTLENUM_NUMBER_OF_BITS
argument_list|)
expr_stmt|;
comment|/* Round the mantissa up, but don't change the number */
if|if
condition|(
name|next_bits
argument_list|(
literal|1
argument_list|)
condition|)
block|{
operator|--
name|lp
expr_stmt|;
if|if
condition|(
name|prec_bits
operator|>
name|LITTLENUM_NUMBER_OF_BITS
condition|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|int
name|tmp_bits
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|tmp_bits
operator|=
name|prec_bits
expr_stmt|;
while|while
condition|(
name|tmp_bits
operator|>
name|LITTLENUM_NUMBER_OF_BITS
condition|)
block|{
if|if
condition|(
name|lp
index|[
name|n
index|]
operator|!=
operator|(
name|LITTLENUM_TYPE
operator|)
operator|-
literal|1
condition|)
break|break;
operator|--
name|n
expr_stmt|;
name|tmp_bits
operator|-=
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
block|}
if|if
condition|(
name|tmp_bits
operator|>
name|LITTLENUM_NUMBER_OF_BITS
operator|||
operator|(
name|lp
index|[
name|n
index|]
operator|&
name|mask
index|[
name|tmp_bits
index|]
operator|)
operator|!=
name|mask
index|[
name|tmp_bits
index|]
condition|)
block|{
name|unsigned
name|long
name|carry
decl_stmt|;
for|for
control|(
name|carry
operator|=
literal|1
init|;
name|carry
operator|&&
operator|(
name|lp
operator|>=
name|words
operator|)
condition|;
name|lp
operator|--
control|)
block|{
name|carry
operator|=
operator|*
name|lp
operator|+
name|carry
expr_stmt|;
operator|*
name|lp
operator|=
name|carry
expr_stmt|;
name|carry
operator|>>=
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|lp
operator|&
name|mask
index|[
name|prec_bits
index|]
operator|)
operator|!=
name|mask
index|[
name|prec_bits
index|]
condition|)
name|lp
operator|++
expr_stmt|;
block|}
return|return
name|return_value
return|;
block|}
elseif|else
if|if
condition|(
name|exponent_4
operator|&
operator|~
name|mask
index|[
name|exponent_bits
index|]
condition|)
block|{
comment|/* 		 * Exponent overflow. Lose immediately. 		 */
comment|/* 		 * We leave return_value alone: admit we read the 		 * number, but return a floating exception 		 * because we can't encode the number. 		 */
name|make_invalid_floating_point_number
argument_list|(
name|words
argument_list|)
expr_stmt|;
return|return
name|return_value
return|;
block|}
else|else
block|{
name|word1
operator||=
operator|(
name|exponent_4
operator|<<
operator|(
operator|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
literal|1
operator|)
operator|-
name|exponent_bits
operator|)
operator|)
operator||
name|next_bits
argument_list|(
operator|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
literal|1
operator|)
operator|-
name|exponent_bits
argument_list|)
expr_stmt|;
block|}
operator|*
name|lp
operator|++
operator|=
name|word1
expr_stmt|;
comment|/* X_PRECISION is special: it has 16 bits of zero in the middle, 	   followed by a 1 bit. */
if|if
condition|(
name|exponent_bits
operator|==
literal|15
operator|&&
name|precision
operator|==
name|X_PRECISION
condition|)
block|{
operator|*
name|lp
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|lp
operator|++
operator|=
literal|1
operator|<<
operator|(
name|LITTLENUM_NUMBER_OF_BITS
operator|)
operator||
name|next_bits
argument_list|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* The rest of the words are just mantissa bits. */
while|while
condition|(
name|lp
operator|<
name|words
operator|+
name|precision
condition|)
operator|*
name|lp
operator|++
operator|=
name|next_bits
argument_list|(
name|LITTLENUM_NUMBER_OF_BITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_bits
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|carry
decl_stmt|;
comment|/* 		 * Since the NEXT bit is a 1, round UP the mantissa. 		 * The cunning design of these hidden-1 floats permits 		 * us to let the mantissa overflow into the exponent, and 		 * it 'does the right thing'. However, we lose if the 		 * highest-order bit of the lowest-order word flips. 		 * Is that clear? 		 */
comment|/* #if (sizeof(carry))< ((sizeof(bits[0]) * BITS_PER_CHAR) + 2) 		   Please allow at least 1 more bit in carry than is in a LITTLENUM. 		   We need that extra bit to hold a carry during a LITTLENUM carry 		   propagation. Another extra bit (kept 0) will assure us that we 		   don't get a sticky sign bit after shifting right, and that 		   permits us to propagate the carry without any masking of bits. 		   #endif */
for|for
control|(
name|carry
operator|=
literal|1
operator|,
name|lp
operator|--
init|;
name|carry
operator|&&
operator|(
name|lp
operator|>=
name|words
operator|)
condition|;
name|lp
operator|--
control|)
block|{
name|carry
operator|=
operator|*
name|lp
operator|+
name|carry
expr_stmt|;
operator|*
name|lp
operator|=
name|carry
expr_stmt|;
name|carry
operator|>>=
name|LITTLENUM_NUMBER_OF_BITS
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|word1
operator|^
operator|*
name|words
operator|)
operator|&
operator|(
literal|1
operator|<<
operator|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* We leave return_value alone: admit we read the 			 * number, but return a floating exception 			 * because we can't encode the number. 			 */
operator|*
name|words
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|LITTLENUM_NUMBER_OF_BITS
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* make_invalid_floating_point_number (words); */
comment|/* return return_value; */
block|}
block|}
return|return
operator|(
name|return_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This routine is a real kludge.  Someone really should do it better, but    I'm too lazy, and I don't understand this stuff all too well anyway    (JF)    */
end_comment

begin_function
name|void
name|int_to_gen
parameter_list|(
name|x
parameter_list|)
name|long
name|x
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|bufp
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld"
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|&
name|buf
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|atof_generic
argument_list|(
operator|&
name|bufp
argument_list|,
literal|"."
argument_list|,
name|EXP_CHARS
argument_list|,
operator|&
name|generic_floating_point_number
argument_list|)
condition|)
name|as_bad
argument_list|(
literal|"Error converting number to floating point (Exponent overflow?)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_function
name|char
modifier|*
name|print_gen
parameter_list|(
name|gen
parameter_list|)
name|FLONUM_TYPE
modifier|*
name|gen
decl_stmt|;
block|{
name|FLONUM_TYPE
name|f
decl_stmt|;
name|LITTLENUM_TYPE
name|arr
index|[
literal|10
index|]
decl_stmt|;
name|double
name|dv
decl_stmt|;
name|float
name|fv
decl_stmt|;
specifier|static
name|char
name|sbuf
index|[
literal|40
index|]
decl_stmt|;
if|if
condition|(
name|gen
condition|)
block|{
name|f
operator|=
name|generic_floating_point_number
expr_stmt|;
name|generic_floating_point_number
operator|=
operator|*
name|gen
expr_stmt|;
block|}
name|gen_to_words
argument_list|(
operator|&
name|arr
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|dv
argument_list|,
operator|&
name|arr
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|double
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sbuf
argument_list|,
literal|"%x %x %x %x %.14G   "
argument_list|,
name|arr
index|[
literal|0
index|]
argument_list|,
name|arr
index|[
literal|1
index|]
argument_list|,
name|arr
index|[
literal|2
index|]
argument_list|,
name|arr
index|[
literal|3
index|]
argument_list|,
name|dv
argument_list|)
expr_stmt|;
name|gen_to_words
argument_list|(
operator|&
name|arr
index|[
literal|0
index|]
argument_list|,
literal|2
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|fv
argument_list|,
operator|&
name|arr
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sbuf
operator|+
name|strlen
argument_list|(
name|sbuf
argument_list|)
argument_list|,
literal|"%x %x %.12g\n"
argument_list|,
name|arr
index|[
literal|0
index|]
argument_list|,
name|arr
index|[
literal|1
index|]
argument_list|,
name|fv
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen
condition|)
block|{
name|generic_floating_point_number
operator|=
name|f
expr_stmt|;
block|}
return|return
operator|(
name|sbuf
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* end of atof-ieee.c */
end_comment

end_unit

