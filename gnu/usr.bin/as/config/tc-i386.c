begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* i386.c -- Assemble code for the Intel 80386    Copyright (C) 1989, 1991, 1992 Free Software Foundation.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*   Intel 80386 machine specific gas.   Written by Eliot Dresselhaus (eliot@mgm.mit.edu).   Bugs& suggestions are completely welcome.  This is free software.   Please help us make it better.   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"opcode/i386.h"
end_include

begin_comment
comment|/* 'md_assemble ()' gathers together information and puts it into a    i386_insn. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
comment|/* TM holds the template for the insn were currently assembling. */
name|template
name|tm
decl_stmt|;
comment|/* SUFFIX holds the opcode suffix (e.g. 'l' for 'movl') if given. */
name|char
name|suffix
decl_stmt|;
comment|/* Operands are coded with OPERANDS, TYPES, DISPS, IMMS, and REGS. */
comment|/* OPERANDS gives the number of given operands. */
name|unsigned
name|int
name|operands
decl_stmt|;
comment|/* REG_OPERANDS, DISP_OPERANDS, MEM_OPERANDS, IMM_OPERANDS give the number of 	   given register, displacement, memory operands and immediate operands. */
name|unsigned
name|int
name|reg_operands
decl_stmt|,
name|disp_operands
decl_stmt|,
name|mem_operands
decl_stmt|,
name|imm_operands
decl_stmt|;
comment|/* TYPES [i] is the type (see above #defines) which tells us how to 	   search through DISPS [i]& IMMS [i]& REGS [i] for the required 	   operand. */
name|unsigned
name|int
name|types
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Displacements (if given) for each operand. */
name|expressionS
modifier|*
name|disps
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|PIC
comment|/* Relocation type for operand */
name|enum
name|reloc_type
name|disp_reloc
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* Immediate operands (if given) for each operand. */
name|expressionS
modifier|*
name|imms
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* Register operands (if given) for each operand. */
name|reg_entry
modifier|*
name|regs
index|[
name|MAX_OPERANDS
index|]
decl_stmt|;
comment|/* BASE_REG, INDEX_REG, and LOG2_SCALE_FACTOR are used to encode 	   the base index byte below.  */
name|reg_entry
modifier|*
name|base_reg
decl_stmt|;
name|reg_entry
modifier|*
name|index_reg
decl_stmt|;
name|unsigned
name|int
name|log2_scale_factor
decl_stmt|;
comment|/* SEG gives the seg_entry of this insn.  It is equal to zero unless 	   an explicit segment override is given. */
specifier|const
name|seg_entry
modifier|*
name|seg
decl_stmt|;
comment|/* segment for memory operands (if given) */
comment|/* PREFIX holds all the given prefix opcodes (usually null). 	   PREFIXES is the size of PREFIX. */
comment|/* richfix: really unsigned? */
name|unsigned
name|char
name|prefix
index|[
name|MAX_PREFIXES
index|]
decl_stmt|;
name|unsigned
name|int
name|prefixes
decl_stmt|;
comment|/* RM and IB are the modrm byte and the base index byte where the addressing 	   modes of this insn are encoded. */
name|modrm_byte
name|rm
decl_stmt|;
name|base_index_byte
name|bi
decl_stmt|;
block|}
name|i386_insn
typedef|;
end_typedef

begin_comment
comment|/* This array holds the chars that always start a comment.  If the    pre-processor is disabled, these aren't very useful */
end_comment

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array holds the chars that only start a comment at the beginning of    a line.  If the line seems to have the form '# 123 filename'    .line and .file directives will appear in the pre-processed output */
end_comment

begin_comment
comment|/* Note that input_file.c hand checks for '#' at the beginning of the    first line of the input file.  This is because the compiler outputs    #NO_APP at the beginning of its output. */
end_comment

begin_comment
comment|/* Also note that comments started like this one will always work if    '/' isn't otherwise defined. */
end_comment

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
literal|"#/"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* removed '#' xoxorich. */
end_comment

begin_comment
comment|/* Chars that can be used to separate mant from exp in floating point nums */
end_comment

begin_decl_stmt
specifier|const
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Chars that mean this number is a floating point constant */
end_comment

begin_comment
comment|/* As in 0f12.456 */
end_comment

begin_comment
comment|/* or    0d1.2345e12 */
end_comment

begin_decl_stmt
specifier|const
name|char
name|FLT_CHARS
index|[]
init|=
literal|"fFdDxX"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tables for lexical analysis */
end_comment

begin_decl_stmt
specifier|static
name|char
name|opcode_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|register_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|operand_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|space_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|identifier_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|digit_chars
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lexical macros */
end_comment

begin_define
define|#
directive|define
name|is_opcode_char
parameter_list|(
name|x
parameter_list|)
value|(opcode_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_operand_char
parameter_list|(
name|x
parameter_list|)
value|(operand_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_register_char
parameter_list|(
name|x
parameter_list|)
value|(register_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_space_char
parameter_list|(
name|x
parameter_list|)
value|(space_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_identifier_char
parameter_list|(
name|x
parameter_list|)
value|(identifier_chars[(unsigned char) x])
end_define

begin_define
define|#
directive|define
name|is_digit_char
parameter_list|(
name|x
parameter_list|)
value|(digit_chars[(unsigned char) x])
end_define

begin_comment
comment|/* put here all non-digit non-letter charcters that may occur in an operand */
end_comment

begin_decl_stmt
specifier|static
name|char
name|operand_special_chars
index|[]
init|=
literal|"%$-+(,)*._~/<>|&^!:"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ordinal_names
index|[]
init|=
block|{
literal|"first"
block|,
literal|"second"
block|,
literal|"third"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for printfs */
end_comment

begin_comment
comment|/* md_assemble() always leaves the strings it's passed unaltered.  To    effect this we maintain a stack of saved characters that we've smashed    with '\0's (indicating end of strings for various sub-fields of the    assembler instruction). */
end_comment

begin_decl_stmt
specifier|static
name|char
name|save_stack
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|save_stack_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stack pointer */
end_comment

begin_define
define|#
directive|define
name|END_STRING_AND_SAVE
parameter_list|(
name|s
parameter_list|)
value|*save_stack_p++ = *s; *s = '\0'
end_define

begin_define
define|#
directive|define
name|RESTORE_END_STRING
parameter_list|(
name|s
parameter_list|)
value|*s = *--save_stack_p
end_define

begin_comment
comment|/* The instruction we're assembling. */
end_comment

begin_decl_stmt
specifier|static
name|i386_insn
name|i
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Per instruction expressionS buffers: 2 displacements& 2 immediate max. */
end_comment

begin_decl_stmt
specifier|static
name|expressionS
name|disp_expressions
index|[
literal|2
index|]
decl_stmt|,
name|im_expressions
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers to ebp& esp entries in reg_hash hash table */
end_comment

begin_decl_stmt
specifier|static
name|reg_entry
modifier|*
name|ebp
decl_stmt|,
modifier|*
name|esp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|this_operand
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current operand we are working on */
end_comment

begin_comment
comment|/*   Interface to relax_segment.   There are 2 relax states for 386 jump insns: one for conditional& one   for unconditional jumps.  This is because the these two types of jumps   add different sizes to frags when we're figuring out what sort of jump   to choose to reach a given label.  */
end_comment

begin_comment
comment|/* types */
end_comment

begin_define
define|#
directive|define
name|COND_JUMP
value|1
end_define

begin_comment
comment|/* conditional jump */
end_comment

begin_define
define|#
directive|define
name|UNCOND_JUMP
value|2
end_define

begin_comment
comment|/* unconditional jump */
end_comment

begin_comment
comment|/* sizes */
end_comment

begin_define
define|#
directive|define
name|BYTE
value|0
end_define

begin_define
define|#
directive|define
name|WORD
value|1
end_define

begin_define
define|#
directive|define
name|DWORD
value|2
end_define

begin_define
define|#
directive|define
name|UNKNOWN_SIZE
value|3
end_define

begin_define
define|#
directive|define
name|ENCODE_RELAX_STATE
parameter_list|(
name|type
parameter_list|,
name|size
parameter_list|)
value|((type<<2) | (size))
end_define

begin_define
define|#
directive|define
name|SIZE_FROM_RELAX_STATE
parameter_list|(
name|s
parameter_list|)
define|\
value|( (((s)& 0x3) == BYTE ? 1 : (((s)& 0x3) == WORD ? 2 : 4)) )
end_define

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
comment|/* 	  The fields are: 	  1) most positive reach of this state, 	  2) most negative reach of this state, 	  3) how many bytes this mode will add to the size of the current frag 	  4) which index into the table to try if we can't fit into this one. 	  */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* For now we don't use word displacement jumps:  they may be 	   untrustworthy. */
block|{
literal|127
operator|+
literal|1
block|,
operator|-
literal|128
operator|+
literal|1
block|,
literal|0
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|COND_JUMP
argument_list|,
argument|DWORD
argument_list|)
block|}
block|,
comment|/* word conditionals add 3 bytes to frag: 	   2 opcode prefix; 1 displacement bytes */
block|{
literal|32767
operator|+
literal|2
block|,
operator|-
literal|32768
operator|+
literal|2
block|,
literal|3
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|COND_JUMP
argument_list|,
argument|DWORD
argument_list|)
block|}
block|,
comment|/* dword conditionals adds 4 bytes to frag: 	   1 opcode prefix; 3 displacement bytes */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|127
operator|+
literal|1
block|,
operator|-
literal|128
operator|+
literal|1
block|,
literal|0
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|UNCOND_JUMP
argument_list|,
argument|DWORD
argument_list|)
block|}
block|,
comment|/* word jmp adds 2 bytes to frag: 	   1 opcode prefix; 1 displacement bytes */
block|{
literal|32767
operator|+
literal|2
block|,
operator|-
literal|32768
operator|+
literal|2
block|,
literal|2
block|,
name|ENCODE_RELAX_STATE
argument_list|(
argument|UNCOND_JUMP
argument_list|,
argument|DWORD
argument_list|)
block|}
block|,
comment|/* dword jmp adds 3 bytes to frag: 	   0 opcode prefix; 3 displacement bytes */
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,  }
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|__STDC__
operator|==
literal|1
end_if

begin_function_decl
specifier|static
name|char
modifier|*
name|output_invalid
parameter_list|(
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fits_in_signed_byte
parameter_list|(
name|long
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fits_in_signed_word
parameter_list|(
name|long
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fits_in_unsigned_byte
parameter_list|(
name|long
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fits_in_unsigned_word
parameter_list|(
name|long
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i386_operand
parameter_list|(
name|char
modifier|*
name|operand_string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smallest_imm_type
parameter_list|(
name|long
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg_entry
modifier|*
name|parse_register
parameter_list|(
name|char
modifier|*
name|reg_string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|mode_from_disp_size
parameter_list|(
name|unsigned
name|long
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|opcode_suffix_to_type
parameter_list|(
name|unsigned
name|long
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_bss
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not __STDC__ */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|output_invalid
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fits_in_signed_byte
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fits_in_signed_word
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fits_in_unsigned_byte
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fits_in_unsigned_word
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|i386_operand
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smallest_imm_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|reg_entry
modifier|*
name|parse_register
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|mode_from_disp_size
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|opcode_suffix_to_type
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_bss
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __STDC__ */
end_comment

begin_comment
comment|/* Ignore certain directives generated by gcc. This probably should    not be here. */
end_comment

begin_function
name|void
name|dummy
parameter_list|()
block|{
while|while
condition|(
operator|*
name|input_line_pointer
operator|&&
operator|*
name|input_line_pointer
operator|!=
literal|'\n'
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
block|{
literal|"bss"
block|,
name|s_bss
block|,
literal|0
block|}
block|,
ifndef|#
directive|ifndef
name|OLD_GAS
block|{
literal|"align"
block|,
name|s_align_bytes
block|,
literal|0
block|}
block|,
else|#
directive|else
comment|/* OLD_GAS */
block|{
literal|"align"
block|,
name|s_align_ptwo
block|,
literal|0
block|}
block|,
endif|#
directive|endif
comment|/* OLD_GAS */
block|{
literal|"ffloat"
block|,
name|float_cons
block|,
literal|'f'
block|}
block|,
block|{
literal|"dfloat"
block|,
name|float_cons
block|,
literal|'d'
block|}
block|,
block|{
literal|"tfloat"
block|,
name|float_cons
block|,
literal|'x'
block|}
block|,
block|{
literal|"value"
block|,
name|cons
block|,
literal|2
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for interface with expression () */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|input_line_pointer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* obstack for constructing various things in md_begin */
end_comment

begin_decl_stmt
name|struct
name|obstack
name|o
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash table for opcode lookup */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|op_hash
init|=
operator|(
expr|struct
name|hash_control
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash table for register lookup */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|reg_hash
init|=
operator|(
expr|struct
name|hash_control
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hash table for prefix lookup */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hash_control
modifier|*
name|prefix_hash
init|=
operator|(
expr|struct
name|hash_control
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|md_begin
parameter_list|()
block|{
name|char
modifier|*
name|hash_err
decl_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|o
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
comment|/* initialize op_hash hash table */
name|op_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
comment|/* xmalloc handles error */
block|{
specifier|register
specifier|const
name|template
modifier|*
name|optab
decl_stmt|;
specifier|register
name|templates
modifier|*
name|core_optab
decl_stmt|;
name|char
modifier|*
name|prev_name
decl_stmt|;
name|optab
operator|=
name|i386_optab
expr_stmt|;
comment|/* setup for loop */
name|prev_name
operator|=
name|optab
operator|->
name|name
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|o
argument_list|,
name|optab
argument_list|,
sizeof|sizeof
argument_list|(
name|template
argument_list|)
argument_list|)
expr_stmt|;
name|core_optab
operator|=
operator|(
name|templates
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|templates
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|optab
operator|++
init|;
name|optab
operator|<
name|i386_optab_end
condition|;
name|optab
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|optab
operator|->
name|name
argument_list|,
name|prev_name
argument_list|)
condition|)
block|{
comment|/* same name as before --> append to current template list */
name|obstack_grow
argument_list|(
operator|&
name|o
argument_list|,
name|optab
argument_list|,
sizeof|sizeof
argument_list|(
name|template
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* different name --> ship out current template list; 				   add to hash table;& begin anew */
comment|/* Note: end must be set before start! since obstack_next_free changes 				   upon opstack_finish */
name|core_optab
operator|->
name|end
operator|=
operator|(
name|template
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|o
argument_list|)
expr_stmt|;
name|core_optab
operator|->
name|start
operator|=
operator|(
name|template
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|o
argument_list|)
expr_stmt|;
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|op_hash
argument_list|,
name|prev_name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|core_optab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
operator|&&
operator|*
name|hash_err
condition|)
block|{
name|hash_error
label|:
name|as_fatal
argument_list|(
literal|"Internal Error:  Can't hash %s: %s"
argument_list|,
name|prev_name
argument_list|,
name|hash_err
argument_list|)
expr_stmt|;
block|}
name|prev_name
operator|=
name|optab
operator|->
name|name
expr_stmt|;
name|core_optab
operator|=
operator|(
name|templates
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|templates
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|o
argument_list|,
name|optab
argument_list|,
sizeof|sizeof
argument_list|(
name|template
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* initialize reg_hash hash table */
name|reg_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
block|{
specifier|register
specifier|const
name|reg_entry
modifier|*
name|regtab
decl_stmt|;
for|for
control|(
name|regtab
operator|=
name|i386_regtab
init|;
name|regtab
operator|<
name|i386_regtab_end
condition|;
name|regtab
operator|++
control|)
block|{
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|reg_hash
argument_list|,
name|regtab
operator|->
name|reg_name
argument_list|,
name|regtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
operator|&&
operator|*
name|hash_err
condition|)
goto|goto
name|hash_error
goto|;
block|}
block|}
name|esp
operator|=
operator|(
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
literal|"esp"
argument_list|)
expr_stmt|;
name|ebp
operator|=
operator|(
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
literal|"ebp"
argument_list|)
expr_stmt|;
comment|/* initialize reg_hash hash table */
name|prefix_hash
operator|=
name|hash_new
argument_list|()
expr_stmt|;
block|{
specifier|register
specifier|const
name|prefix_entry
modifier|*
name|prefixtab
decl_stmt|;
for|for
control|(
name|prefixtab
operator|=
name|i386_prefixtab
init|;
name|prefixtab
operator|<
name|i386_prefixtab_end
condition|;
name|prefixtab
operator|++
control|)
block|{
name|hash_err
operator|=
name|hash_insert
argument_list|(
name|prefix_hash
argument_list|,
name|prefixtab
operator|->
name|prefix_name
argument_list|,
name|prefixtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash_err
operator|&&
operator|*
name|hash_err
condition|)
goto|goto
name|hash_error
goto|;
block|}
block|}
comment|/* fill in lexical tables:  opcode_chars, operand_chars, space_chars */
block|{
specifier|register
name|unsigned
name|int
name|c
decl_stmt|;
name|memset
argument_list|(
name|opcode_chars
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|opcode_chars
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|operand_chars
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|operand_chars
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|space_chars
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|space_chars
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|identifier_chars
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|identifier_chars
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|digit_chars
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|digit_chars
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|256
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|islower
argument_list|(
name|c
argument_list|)
operator|||
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|opcode_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
name|register_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|opcode_chars
index|[
name|c
index|]
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|register_chars
index|[
name|c
index|]
operator|=
name|opcode_chars
index|[
name|c
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|PREFIX_SEPERATOR
condition|)
block|{
name|opcode_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|')'
operator|||
name|c
operator|==
literal|'('
condition|)
block|{
name|register_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|isupper
argument_list|(
name|c
argument_list|)
operator|||
name|islower
argument_list|(
name|c
argument_list|)
operator|||
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|operand_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|&&
name|strchr
argument_list|(
name|operand_special_chars
argument_list|,
name|c
argument_list|)
condition|)
name|operand_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'-'
condition|)
name|digit_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'.'
operator|||
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|identifier_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|space_chars
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|md_end
parameter_list|()
block|{}
end_function

begin_comment
comment|/* not much to do here. */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|DEBUG386
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG386
end_ifdef

begin_comment
comment|/* debugging routines for md_assemble */
end_comment

begin_decl_stmt
specifier|static
name|void
name|pi
argument_list|()
decl_stmt|,
name|pte
argument_list|()
decl_stmt|,
name|pt
argument_list|()
decl_stmt|,
name|pe
argument_list|()
decl_stmt|,
name|ps
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|pi
parameter_list|(
name|line
parameter_list|,
name|x
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|i386_insn
modifier|*
name|x
decl_stmt|;
block|{
specifier|register
name|template
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s: template "
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|pte
argument_list|(
operator|&
name|x
operator|->
name|tm
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"  modrm:  mode %x  reg %x  reg/mem %x"
argument_list|,
name|x
operator|->
name|rm
operator|.
name|mode
argument_list|,
name|x
operator|->
name|rm
operator|.
name|reg
argument_list|,
name|x
operator|->
name|rm
operator|.
name|regmem
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" base %x  index %x  scale %x\n"
argument_list|,
name|x
operator|->
name|bi
operator|.
name|base
argument_list|,
name|x
operator|->
name|bi
operator|.
name|index
argument_list|,
name|x
operator|->
name|bi
operator|.
name|scale
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|x
operator|->
name|operands
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    #%d:  "
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pt
argument_list|(
name|x
operator|->
name|types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|types
index|[
name|i
index|]
operator|&
name|Reg
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s\n"
argument_list|,
name|x
operator|->
name|regs
index|[
name|i
index|]
operator|->
name|reg_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|types
index|[
name|i
index|]
operator|&
name|Imm
condition|)
name|pe
argument_list|(
name|x
operator|->
name|imms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|types
index|[
name|i
index|]
operator|&
operator|(
name|Disp
operator||
name|Abs
operator|)
condition|)
name|pe
argument_list|(
name|x
operator|->
name|disps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pte
parameter_list|(
name|t
parameter_list|)
name|template
modifier|*
name|t
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" %d operands "
argument_list|,
name|t
operator|->
name|operands
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"opcode %x "
argument_list|,
name|t
operator|->
name|base_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|extension_opcode
operator|!=
name|None
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"ext %x "
argument_list|,
name|t
operator|->
name|extension_opcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|D
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"D"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|W
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"W"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t
operator|->
name|operands
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    #%d type "
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pt
argument_list|(
name|t
operator|->
name|operand_types
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pe
parameter_list|(
name|e
parameter_list|)
name|expressionS
modifier|*
name|e
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    segment       %s\n"
argument_list|,
name|segment_name
argument_list|(
name|e
operator|->
name|X_seg
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    add_number    %ld (%lx)\n"
argument_list|,
name|e
operator|->
name|X_add_number
argument_list|,
name|e
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|X_add_symbol
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    add_symbol    "
argument_list|)
expr_stmt|;
name|ps
argument_list|(
name|e
operator|->
name|X_add_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|->
name|X_subtract_symbol
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"    sub_symbol    "
argument_list|)
expr_stmt|;
name|ps
argument_list|(
name|e
operator|->
name|X_subtract_symbol
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ps
parameter_list|(
name|s
parameter_list|)
name|symbolS
modifier|*
name|s
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s type %s%s"
argument_list|,
name|S_GET_NAME
argument_list|(
name|s
argument_list|)
argument_list|,
name|S_IS_EXTERNAL
argument_list|(
name|s
argument_list|)
condition|?
literal|"EXTERNAL "
else|:
literal|""
argument_list|,
name|segment_name
argument_list|(
name|S_GET_SEGMENT
argument_list|(
name|s
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|type_name
block|{
name|unsigned
name|int
name|mask
decl_stmt|;
name|char
modifier|*
name|tname
decl_stmt|;
block|}
name|type_names
index|[]
init|=
block|{
block|{
name|Reg8
block|,
literal|"r8"
block|}
block|,
block|{
name|Reg16
block|,
literal|"r16"
block|}
block|,
block|{
name|Reg32
block|,
literal|"r32"
block|}
block|,
block|{
name|Imm8
block|,
literal|"i8"
block|}
block|,
block|{
name|Imm8S
block|,
literal|"i8s"
block|}
block|,
block|{
name|Imm16
block|,
literal|"i16"
block|}
block|,
block|{
name|Imm32
block|,
literal|"i32"
block|}
block|,
block|{
name|Mem8
block|,
literal|"Mem8"
block|}
block|,
block|{
name|Mem16
block|,
literal|"Mem16"
block|}
block|,
block|{
name|Mem32
block|,
literal|"Mem32"
block|}
block|,
block|{
name|BaseIndex
block|,
literal|"BaseIndex"
block|}
block|,
block|{
name|Abs8
block|,
literal|"Abs8"
block|}
block|,
block|{
name|Abs16
block|,
literal|"Abs16"
block|}
block|,
block|{
name|Abs32
block|,
literal|"Abs32"
block|}
block|,
block|{
name|Disp8
block|,
literal|"d8"
block|}
block|,
block|{
name|Disp16
block|,
literal|"d16"
block|}
block|,
block|{
name|Disp32
block|,
literal|"d32"
block|}
block|,
block|{
name|SReg2
block|,
literal|"SReg2"
block|}
block|,
block|{
name|SReg3
block|,
literal|"SReg3"
block|}
block|,
block|{
name|Acc
block|,
literal|"Acc"
block|}
block|,
block|{
name|InOutPortReg
block|,
literal|"InOutPortReg"
block|}
block|,
block|{
name|ShiftCount
block|,
literal|"ShiftCount"
block|}
block|,
block|{
name|Imm1
block|,
literal|"i1"
block|}
block|,
block|{
name|Control
block|,
literal|"control reg"
block|}
block|,
block|{
name|Test
block|,
literal|"test reg"
block|}
block|,
block|{
name|FloatReg
block|,
literal|"FReg"
block|}
block|,
block|{
name|FloatAcc
block|,
literal|"FAcc"
block|}
block|,
block|{
name|JumpAbsolute
block|,
literal|"Jump Absolute"
block|}
block|,
block|{
literal|0
block|,
literal|""
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|pt
parameter_list|(
name|t
parameter_list|)
name|unsigned
name|int
name|t
decl_stmt|;
block|{
specifier|register
name|struct
name|type_name
modifier|*
name|ty
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|Unknown
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Unknown"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|ty
operator|=
name|type_names
init|;
name|ty
operator|->
name|mask
condition|;
name|ty
operator|++
control|)
if|if
condition|(
name|t
operator|&
name|ty
operator|->
name|mask
condition|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s, "
argument_list|,
name|ty
operator|->
name|tname
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG386 */
end_comment

begin_escape
end_escape

begin_comment
comment|/*   This is the guts of the machine-dependent assembler.  LINE points to a   machine dependent instruction.  This funciton is supposed to emit   the frags/bytes it assembles to.   */
end_comment

begin_function
name|void
name|md_assemble
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
block|{
comment|/* Holds temlate once we've found it. */
specifier|register
name|template
modifier|*
name|t
decl_stmt|;
comment|/* Possible templates for current insn */
name|templates
modifier|*
name|current_templates
init|=
operator|(
name|templates
operator|*
operator|)
literal|0
decl_stmt|;
comment|/* Initialize globals. */
name|memset
argument_list|(
operator|&
name|i
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|disp_expressions
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|disp_expressions
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|im_expressions
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|im_expressions
argument_list|)
argument_list|)
expr_stmt|;
name|save_stack_p
operator|=
name|save_stack
expr_stmt|;
comment|/* reset stack pointer */
comment|/* Fist parse an opcode& call i386_operand for the operands. 	   We assume that the scrubber has arranged it so that line[0] is the valid 	   start of a (possibly prefixed) opcode. */
block|{
specifier|register
name|char
modifier|*
name|l
init|=
name|line
decl_stmt|;
comment|/* Fast place to put LINE. */
comment|/* 1 if operand is pending after ','. */
name|unsigned
name|int
name|expecting_operand
init|=
literal|0
decl_stmt|;
comment|/* 1 if we found a prefix only acceptable with string insns. */
name|unsigned
name|int
name|expecting_string_instruction
init|=
literal|0
decl_stmt|;
comment|/* Non-zero if operand parens not balenced. */
name|unsigned
name|int
name|paren_not_balenced
decl_stmt|;
name|char
modifier|*
name|token_start
init|=
name|l
decl_stmt|;
while|while
condition|(
operator|!
name|is_space_char
argument_list|(
operator|*
name|l
argument_list|)
operator|&&
operator|*
name|l
operator|!=
name|END_OF_INSN
condition|)
block|{
if|if
condition|(
operator|!
name|is_opcode_char
argument_list|(
operator|*
name|l
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"invalid character %s in opcode"
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|l
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|*
name|l
operator|!=
name|PREFIX_SEPERATOR
condition|)
block|{
operator|*
name|l
operator|=
name|opcode_chars
index|[
operator|(
name|unsigned
name|char
operator|)
operator|*
name|l
index|]
expr_stmt|;
comment|/* fold case of opcodes */
name|l
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* this opcode's got a prefix */
specifier|register
name|unsigned
name|int
name|q
decl_stmt|;
specifier|register
name|prefix_entry
modifier|*
name|prefix
decl_stmt|;
if|if
condition|(
name|l
operator|==
name|token_start
condition|)
block|{
name|as_bad
argument_list|(
literal|"expecting prefix; got nothing"
argument_list|)
expr_stmt|;
return|return;
block|}
name|END_STRING_AND_SAVE
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|prefix
operator|=
operator|(
name|prefix_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|prefix_hash
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prefix
condition|)
block|{
name|as_bad
argument_list|(
literal|"no such opcode prefix ('%s')"
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
return|return;
block|}
name|RESTORE_END_STRING
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* check for repeated prefix */
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|i
operator|.
name|prefixes
condition|;
name|q
operator|++
control|)
if|if
condition|(
name|i
operator|.
name|prefix
index|[
name|q
index|]
operator|==
name|prefix
operator|->
name|prefix_code
condition|)
block|{
name|as_bad
argument_list|(
literal|"same prefix used twice; you don't really want this!"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|.
name|prefixes
operator|==
name|MAX_PREFIXES
condition|)
block|{
name|as_bad
argument_list|(
literal|"too many opcode prefixes"
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|.
name|prefix
index|[
name|i
operator|.
name|prefixes
operator|++
index|]
operator|=
name|prefix
operator|->
name|prefix_code
expr_stmt|;
if|if
condition|(
name|prefix
operator|->
name|prefix_code
operator|==
name|REPE
operator|||
name|prefix
operator|->
name|prefix_code
operator|==
name|REPNE
condition|)
name|expecting_string_instruction
operator|=
literal|1
expr_stmt|;
comment|/* skip past PREFIX_SEPERATOR and reset token_start */
name|token_start
operator|=
operator|++
name|l
expr_stmt|;
block|}
block|}
name|END_STRING_AND_SAVE
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|token_start
operator|==
name|l
condition|)
block|{
name|as_bad
argument_list|(
literal|"expecting opcode; got nothing"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Lookup insn in hash; try intel& att naming conventions if appropriate; 		   that is:  we only use the opcode suffix 'b' 'w' or 'l' if we need to. */
name|current_templates
operator|=
operator|(
name|templates
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current_templates
condition|)
block|{
name|int
name|last_index
init|=
name|strlen
argument_list|(
name|token_start
argument_list|)
operator|-
literal|1
decl_stmt|;
name|char
name|last_char
init|=
name|token_start
index|[
name|last_index
index|]
decl_stmt|;
switch|switch
condition|(
name|last_char
condition|)
block|{
case|case
name|DWORD_OPCODE_SUFFIX
case|:
case|case
name|WORD_OPCODE_SUFFIX
case|:
case|case
name|BYTE_OPCODE_SUFFIX
case|:
name|token_start
index|[
name|last_index
index|]
operator|=
literal|'\0'
expr_stmt|;
name|current_templates
operator|=
operator|(
name|templates
operator|*
operator|)
name|hash_find
argument_list|(
name|op_hash
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
name|token_start
index|[
name|last_index
index|]
operator|=
name|last_char
expr_stmt|;
name|i
operator|.
name|suffix
operator|=
name|last_char
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|current_templates
condition|)
block|{
name|as_bad
argument_list|(
literal|"no such 386 instruction: `%s'"
argument_list|,
name|token_start
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|RESTORE_END_STRING
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* check for rep/repne without a string instruction */
if|if
condition|(
name|expecting_string_instruction
operator|&&
operator|!
name|IS_STRING_INSTRUCTION
argument_list|(
name|current_templates
operator|->
name|start
operator|->
name|base_opcode
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"expecting string instruction after rep/repne"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* There may be operands to parse. */
if|if
condition|(
operator|*
name|l
operator|!=
name|END_OF_INSN
operator|&&
comment|/* For string instructions, we ignore any operands if given.  This 		       kludges, for example, 'rep/movsb %ds:(%esi), %es:(%edi)' where 		       the operands are always going to be the same, and are not really 		       encoded in machine code. */
operator|!
name|IS_STRING_INSTRUCTION
argument_list|(
name|current_templates
operator|->
name|start
operator|->
name|base_opcode
argument_list|)
condition|)
block|{
comment|/* parse operands */
do|do
block|{
comment|/* skip optional white space before operand */
while|while
condition|(
operator|!
name|is_operand_char
argument_list|(
operator|*
name|l
argument_list|)
operator|&&
operator|*
name|l
operator|!=
name|END_OF_INSN
condition|)
block|{
if|if
condition|(
operator|!
name|is_space_char
argument_list|(
operator|*
name|l
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"invalid character %s before %s operand"
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|l
argument_list|)
argument_list|,
name|ordinal_names
index|[
name|i
operator|.
name|operands
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|l
operator|++
expr_stmt|;
block|}
name|token_start
operator|=
name|l
expr_stmt|;
comment|/* after white space */
name|paren_not_balenced
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|paren_not_balenced
operator|||
operator|*
name|l
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
operator|*
name|l
operator|==
name|END_OF_INSN
condition|)
block|{
if|if
condition|(
name|paren_not_balenced
condition|)
block|{
name|as_bad
argument_list|(
literal|"unbalenced parenthesis in %s operand."
argument_list|,
name|ordinal_names
index|[
name|i
operator|.
name|operands
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
break|break;
comment|/* we are done */
block|}
elseif|else
if|if
condition|(
operator|!
name|is_operand_char
argument_list|(
operator|*
name|l
argument_list|)
operator|&&
operator|!
name|is_space_char
argument_list|(
operator|*
name|l
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"invalid character %s in %s operand"
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|l
argument_list|)
argument_list|,
name|ordinal_names
index|[
name|i
operator|.
name|operands
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|l
operator|==
literal|'('
condition|)
operator|++
name|paren_not_balenced
expr_stmt|;
if|if
condition|(
operator|*
name|l
operator|==
literal|')'
condition|)
operator|--
name|paren_not_balenced
expr_stmt|;
name|l
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|!=
name|token_start
condition|)
block|{
comment|/* yes, we've read in another operand */
name|unsigned
name|int
name|operand_ok
decl_stmt|;
name|this_operand
operator|=
name|i
operator|.
name|operands
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|operands
operator|>
name|MAX_OPERANDS
condition|)
block|{
name|as_bad
argument_list|(
literal|"spurious operands; (%d operands/instruction max)"
argument_list|,
name|MAX_OPERANDS
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* now parse operand adding info to 'i' as we go along */
name|END_STRING_AND_SAVE
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|operand_ok
operator|=
name|i386_operand
argument_list|(
name|token_start
argument_list|)
expr_stmt|;
name|RESTORE_END_STRING
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* restore old contents */
if|if
condition|(
operator|!
name|operand_ok
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
name|expecting_operand
condition|)
block|{
name|expecting_operand_after_comma
label|:
name|as_bad
argument_list|(
literal|"expecting operand after ','; got nothing"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|l
operator|==
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"expecting operand before ','; got nothing"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* now *l must be either ',' or END_OF_INSN */
if|if
condition|(
operator|*
name|l
operator|==
literal|','
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|l
operator|==
name|END_OF_INSN
condition|)
block|{
comment|/* just skip it, if it's \n complain */
goto|goto
name|expecting_operand_after_comma
goto|;
block|}
name|expecting_operand
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|l
operator|!=
name|END_OF_INSN
condition|)
do|;
comment|/* until we get end of insn */
block|}
block|}
comment|/* Now we've parsed the opcode into a set of templates, and have the 	   operands at hand. 	   Next, we find a template that matches the given insn, 	   making sure the overlap of the given operands types is consistent 	   with the template operand types. */
define|#
directive|define
name|MATCH
parameter_list|(
name|overlap
parameter_list|,
name|given_type
parameter_list|)
define|\
value|(overlap&& \ 	 (overlap& (JumpAbsolute|BaseIndex|Mem8)) \ 	 == (given_type& (JumpAbsolute|BaseIndex|Mem8)))
comment|/* If m0 and m1 are register matches they must be consistent 	       with the expected operand types t0 and t1. 	       That is, if both m0& m1 are register matches 	       i.e. ( ((m0& (Reg))&& (m1& (Reg)) ) ? 	       then, either 1. or 2. must be true: 	       1. the expected operand type register overlap is null: 	       (t0& t1& Reg) == 0 	       AND 	       the given register overlap is null: 	       (m0& m1& Reg) == 0 	       2. the expected operand type register overlap == the given 	       operand type overlap:  (t0& t1& m0& m1& Reg). 	       */
define|#
directive|define
name|CONSISTENT_REGISTER_MATCH
parameter_list|(
name|m0
parameter_list|,
name|m1
parameter_list|,
name|t0
parameter_list|,
name|t1
parameter_list|)
define|\
value|( ((m0& (Reg))&& (m1& (Reg))) ? \ 	     ( ((t0& t1& (Reg)) == 0&& (m0& m1& (Reg)) == 0) || \ 	      ((t0& t1)& (m0& m1)& (Reg)) \ 	      ) : 1)
block|{
specifier|register
name|unsigned
name|int
name|overlap0
decl_stmt|,
name|overlap1
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|unsigned
name|int
name|overlap2
decl_stmt|;
name|unsigned
name|int
name|found_reverse_match
decl_stmt|;
name|overlap0
operator|=
name|overlap1
operator|=
name|overlap2
operator|=
name|found_reverse_match
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|current_templates
operator|->
name|start
init|;
name|t
operator|<
name|current_templates
operator|->
name|end
condition|;
name|t
operator|++
control|)
block|{
comment|/* must have right number of operands */
if|if
condition|(
name|i
operator|.
name|operands
operator|!=
name|t
operator|->
name|operands
condition|)
continue|continue;
elseif|else
if|if
condition|(
operator|!
name|t
operator|->
name|operands
condition|)
break|break;
comment|/* 0 operands always matches */
name|overlap0
operator|=
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|operands
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|)
condition|)
continue|continue;
break|break;
case|case
literal|2
case|:
case|case
literal|3
case|:
name|overlap1
operator|=
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|MATCH
argument_list|(
name|overlap1
argument_list|,
name|i
operator|.
name|types
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|CONSISTENT_REGISTER_MATCH
argument_list|(
name|overlap0
argument_list|,
name|overlap1
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* check if other direction is valid ... */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
name|COMES_IN_BOTH_DIRECTIONS
operator|)
condition|)
continue|continue;
comment|/* try reversing direction of operands */
name|overlap0
operator|=
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
expr_stmt|;
name|overlap1
operator|=
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap0
argument_list|,
name|i
operator|.
name|types
index|[
literal|0
index|]
argument_list|)
operator|||
operator|!
name|MATCH
argument_list|(
name|overlap1
argument_list|,
name|i
operator|.
name|types
index|[
literal|1
index|]
argument_list|)
operator|||
operator|!
name|CONSISTENT_REGISTER_MATCH
argument_list|(
name|overlap0
argument_list|,
name|overlap1
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* does not match either direction */
continue|continue;
block|}
comment|/* found a reverse match here -- slip through */
comment|/* found_reverse_match holds which of D or FloatD we've found */
name|found_reverse_match
operator|=
name|t
operator|->
name|opcode_modifier
operator|&
name|COMES_IN_BOTH_DIRECTIONS
expr_stmt|;
block|}
comment|/* endif: not forward match */
comment|/* found either forward/reverse 2 operand match here */
if|if
condition|(
name|t
operator|->
name|operands
operator|==
literal|3
condition|)
block|{
name|overlap2
operator|=
name|i
operator|.
name|types
index|[
literal|2
index|]
operator|&
name|t
operator|->
name|operand_types
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|overlap2
argument_list|,
name|i
operator|.
name|types
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|CONSISTENT_REGISTER_MATCH
argument_list|(
name|overlap0
argument_list|,
name|overlap2
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|CONSISTENT_REGISTER_MATCH
argument_list|(
name|overlap1
argument_list|,
name|overlap2
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
argument_list|,
name|t
operator|->
name|operand_types
index|[
literal|2
index|]
argument_list|)
condition|)
continue|continue;
block|}
comment|/* found either forward/reverse 2 or 3 operand match here: 					   slip through to break */
block|}
break|break;
comment|/* we've found a match; break out of loop */
block|}
comment|/* for (t = ... */
if|if
condition|(
name|t
operator|==
name|current_templates
operator|->
name|end
condition|)
block|{
comment|/* we found no match */
name|as_bad
argument_list|(
literal|"operands given don't match any known 386 instruction"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Copy the template we found (we may change it!). */
name|memcpy
argument_list|(
operator|&
name|i
operator|.
name|tm
argument_list|,
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|template
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|=
operator|&
name|i
operator|.
name|tm
expr_stmt|;
comment|/* alter new copy of template */
comment|/* If there's no opcode suffix we try to invent one based on register 			   operands. */
if|if
condition|(
operator|!
name|i
operator|.
name|suffix
operator|&&
name|i
operator|.
name|reg_operands
condition|)
block|{
comment|/* We take i.suffix from the LAST register operand specified.  This 				   assumes that the last register operands is the destination register 				   operand. */
name|int
name|o
decl_stmt|;
for|for
control|(
name|o
operator|=
literal|0
init|;
name|o
operator|<
name|MAX_OPERANDS
condition|;
name|o
operator|++
control|)
if|if
condition|(
name|i
operator|.
name|types
index|[
name|o
index|]
operator|&
name|Reg
condition|)
block|{
name|i
operator|.
name|suffix
operator|=
operator|(
name|i
operator|.
name|types
index|[
name|o
index|]
operator|==
name|Reg8
operator|)
condition|?
name|BYTE_OPCODE_SUFFIX
else|:
operator|(
name|i
operator|.
name|types
index|[
name|o
index|]
operator|==
name|Reg16
operator|)
condition|?
name|WORD_OPCODE_SUFFIX
else|:
name|DWORD_OPCODE_SUFFIX
expr_stmt|;
block|}
block|}
comment|/* Make still unresolved immediate matches conform to size of immediate 			   given in i.suffix. Note:  overlap2 cannot be an immediate! 			   We assume this. */
if|if
condition|(
operator|(
name|overlap0
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator||
name|Imm16
operator||
name|Imm32
operator|)
operator|)
operator|&&
name|overlap0
operator|!=
name|Imm8
operator|&&
name|overlap0
operator|!=
name|Imm8S
operator|&&
name|overlap0
operator|!=
name|Imm16
operator|&&
name|overlap0
operator|!=
name|Imm32
condition|)
block|{
if|if
condition|(
operator|!
name|i
operator|.
name|suffix
condition|)
block|{
name|as_bad
argument_list|(
literal|"no opcode suffix given; can't determine immediate size"
argument_list|)
expr_stmt|;
return|return;
block|}
name|overlap0
operator|&=
operator|(
name|i
operator|.
name|suffix
operator|==
name|BYTE_OPCODE_SUFFIX
condition|?
operator|(
name|Imm8
operator||
name|Imm8S
operator|)
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|WORD_OPCODE_SUFFIX
condition|?
name|Imm16
else|:
name|Imm32
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|overlap1
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator||
name|Imm16
operator||
name|Imm32
operator|)
operator|)
operator|&&
name|overlap1
operator|!=
name|Imm8
operator|&&
name|overlap1
operator|!=
name|Imm8S
operator|&&
name|overlap1
operator|!=
name|Imm16
operator|&&
name|overlap1
operator|!=
name|Imm32
condition|)
block|{
if|if
condition|(
operator|!
name|i
operator|.
name|suffix
condition|)
block|{
name|as_bad
argument_list|(
literal|"no opcode suffix given; can't determine immediate size"
argument_list|)
expr_stmt|;
return|return;
block|}
name|overlap1
operator|&=
operator|(
name|i
operator|.
name|suffix
operator|==
name|BYTE_OPCODE_SUFFIX
condition|?
operator|(
name|Imm8
operator||
name|Imm8S
operator|)
else|:
operator|(
name|i
operator|.
name|suffix
operator|==
name|WORD_OPCODE_SUFFIX
condition|?
name|Imm16
else|:
name|Imm32
operator|)
operator|)
expr_stmt|;
block|}
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|=
name|overlap0
expr_stmt|;
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|=
name|overlap1
expr_stmt|;
name|i
operator|.
name|types
index|[
literal|2
index|]
operator|=
name|overlap2
expr_stmt|;
if|if
condition|(
name|overlap0
operator|&
name|ImplicitRegister
condition|)
name|i
operator|.
name|reg_operands
operator|--
expr_stmt|;
if|if
condition|(
name|overlap1
operator|&
name|ImplicitRegister
condition|)
name|i
operator|.
name|reg_operands
operator|--
expr_stmt|;
if|if
condition|(
name|overlap2
operator|&
name|ImplicitRegister
condition|)
name|i
operator|.
name|reg_operands
operator|--
expr_stmt|;
if|if
condition|(
name|overlap0
operator|&
name|Imm1
condition|)
name|i
operator|.
name|imm_operands
operator|=
literal|0
expr_stmt|;
comment|/* kludge for shift insns */
if|if
condition|(
name|found_reverse_match
condition|)
block|{
name|unsigned
name|int
name|save
decl_stmt|;
name|save
operator|=
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
expr_stmt|;
name|t
operator|->
name|operand_types
index|[
literal|0
index|]
operator|=
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
expr_stmt|;
name|t
operator|->
name|operand_types
index|[
literal|1
index|]
operator|=
name|save
expr_stmt|;
block|}
comment|/* Finalize opcode.  First, we change the opcode based on the operand 			   size given by i.suffix: we never have to change things for byte insns, 			   or when no opcode suffix is need to size the operands. */
if|if
condition|(
operator|!
name|i
operator|.
name|suffix
operator|&&
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
name|W
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"no opcode suffix given and no register operands; can't size instruction"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|.
name|suffix
operator|&&
name|i
operator|.
name|suffix
operator|!=
name|BYTE_OPCODE_SUFFIX
condition|)
block|{
comment|/* Select between byte and word/dword operations. */
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|W
condition|)
name|t
operator|->
name|base_opcode
operator||=
name|W
expr_stmt|;
comment|/* Now select between word& dword operations via the 				   operand size prefix. */
if|if
condition|(
name|i
operator|.
name|suffix
operator|==
name|WORD_OPCODE_SUFFIX
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|prefixes
operator|==
name|MAX_PREFIXES
condition|)
block|{
name|as_bad
argument_list|(
literal|"%d prefixes given and 'w' opcode suffix gives too many prefixes"
argument_list|,
name|MAX_PREFIXES
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|.
name|prefix
index|[
name|i
operator|.
name|prefixes
operator|++
index|]
operator|=
name|WORD_PREFIX_OPCODE
expr_stmt|;
block|}
block|}
comment|/* For insns with operands there are more diddles to do to the opcode. */
if|if
condition|(
name|i
operator|.
name|operands
condition|)
block|{
comment|/* If we found a reverse match we must alter the opcode direction bit 				   found_reverse_match holds bit to set (different for int& 				   float insns). */
if|if
condition|(
name|found_reverse_match
condition|)
block|{
name|t
operator|->
name|base_opcode
operator||=
name|found_reverse_match
expr_stmt|;
block|}
comment|/* 				  The imul $imm, %reg instruction is converted into 				  imul $imm, %reg, %reg. */
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|imulKludge
condition|)
block|{
name|i
operator|.
name|regs
index|[
literal|2
index|]
operator|=
name|i
operator|.
name|regs
index|[
literal|1
index|]
expr_stmt|;
comment|/* Pretend we saw the 3 operand case. */
name|i
operator|.
name|reg_operands
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Certain instructions expect the destination to be in the i.rm.reg 				   field.  This is by far the exceptional case.  For these instructions, 				   if the source operand is a register, we must reverse the i.rm.reg 				   and i.rm.regmem fields.  We accomplish this by faking that the 				   two register operands were given in the reverse order. */
if|if
condition|(
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
name|ReverseRegRegmem
operator|)
operator|&&
name|i
operator|.
name|reg_operands
operator|==
literal|2
condition|)
block|{
name|unsigned
name|int
name|first_reg_operand
init|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|Reg
operator|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|second_reg_operand
init|=
name|first_reg_operand
operator|+
literal|1
decl_stmt|;
name|reg_entry
modifier|*
name|tmp
init|=
name|i
operator|.
name|regs
index|[
name|first_reg_operand
index|]
decl_stmt|;
name|i
operator|.
name|regs
index|[
name|first_reg_operand
index|]
operator|=
name|i
operator|.
name|regs
index|[
name|second_reg_operand
index|]
expr_stmt|;
name|i
operator|.
name|regs
index|[
name|second_reg_operand
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|ShortForm
condition|)
block|{
comment|/* The register or float register operand is in operand 0 or 1. */
name|unsigned
name|int
name|o
init|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
operator|(
name|Reg
operator||
name|FloatReg
operator|)
operator|)
condition|?
literal|0
else|:
literal|1
decl_stmt|;
comment|/* Register goes in low 3 bits of opcode. */
name|t
operator|->
name|base_opcode
operator||=
name|i
operator|.
name|regs
index|[
name|o
index|]
operator|->
name|reg_num
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|ShortFormW
condition|)
block|{
comment|/* Short form with 0x8 width bit.  Register is always dest. operand */
name|t
operator|->
name|base_opcode
operator||=
name|i
operator|.
name|regs
index|[
literal|1
index|]
operator|->
name|reg_num
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|suffix
operator|==
name|WORD_OPCODE_SUFFIX
operator|||
name|i
operator|.
name|suffix
operator|==
name|DWORD_OPCODE_SUFFIX
condition|)
name|t
operator|->
name|base_opcode
operator||=
literal|0x8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|Seg2ShortForm
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|base_opcode
operator|==
name|POP_SEG_SHORT
operator|&&
name|i
operator|.
name|regs
index|[
literal|0
index|]
operator|->
name|reg_num
operator|==
literal|1
condition|)
block|{
name|as_bad
argument_list|(
literal|"you can't 'pop cs' on the 386."
argument_list|)
expr_stmt|;
return|return;
block|}
name|t
operator|->
name|base_opcode
operator||=
operator|(
name|i
operator|.
name|regs
index|[
literal|0
index|]
operator|->
name|reg_num
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|Seg3ShortForm
condition|)
block|{
comment|/* 'push %fs' is 0x0fa0; 'pop %fs' is 0x0fa1. 					   'push %gs' is 0x0fa8; 'pop %fs' is 0x0fa9. 					   So, only if i.regs[0]->reg_num == 5 (%gs) do we need 					   to change the opcode. */
if|if
condition|(
name|i
operator|.
name|regs
index|[
literal|0
index|]
operator|->
name|reg_num
operator|==
literal|5
condition|)
name|t
operator|->
name|base_opcode
operator||=
literal|0x08
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|Modrm
condition|)
block|{
comment|/* The opcode is completed (modulo t->extension_opcode which must 					   be put into the modrm byte. 					   Now, we make the modrm& index base bytes based on all the info 					   we've collected. */
comment|/* i.reg_operands MUST be the number of real register operands; 					   implicit registers do not count. */
if|if
condition|(
name|i
operator|.
name|reg_operands
operator|==
literal|2
condition|)
block|{
name|unsigned
name|int
name|source
decl_stmt|,
name|dest
decl_stmt|;
name|source
operator|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
operator|(
name|Reg
operator||
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator|)
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|dest
operator|=
name|source
operator|+
literal|1
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
literal|3
expr_stmt|;
comment|/* We must be careful to make sure that all segment/control/test/ 						   debug registers go into the i.rm.reg field (despite the whether 						   they are source or destination operands). */
if|if
condition|(
name|i
operator|.
name|regs
index|[
name|dest
index|]
operator|->
name|reg_type
operator|&
operator|(
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator|)
condition|)
block|{
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|i
operator|.
name|regs
index|[
name|dest
index|]
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|regs
index|[
name|source
index|]
operator|->
name|reg_num
expr_stmt|;
block|}
else|else
block|{
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|i
operator|.
name|regs
index|[
name|source
index|]
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|regs
index|[
name|dest
index|]
operator|->
name|reg_num
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* if it's not 2 reg operands... */
if|if
condition|(
name|i
operator|.
name|mem_operands
condition|)
block|{
name|unsigned
name|int
name|fake_zero_displacement
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|o
init|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
name|Mem
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
name|Mem
operator|)
condition|?
literal|1
else|:
literal|2
operator|)
decl_stmt|;
comment|/* Encode memory operand into modrm byte and base index byte. */
if|if
condition|(
name|i
operator|.
name|base_reg
operator|==
name|esp
operator|&&
operator|!
name|i
operator|.
name|index_reg
condition|)
block|{
comment|/*<disp>(%esp) becomes two byte modrm with no index register. */
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
name|mode_from_disp_size
argument_list|(
name|i
operator|.
name|types
index|[
name|o
index|]
argument_list|)
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|base
operator|=
name|ESP_REG_NUM
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|index
operator|=
name|NO_INDEX_REGISTER
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|scale
operator|=
literal|0
expr_stmt|;
comment|/* Must be zero! */
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|base_reg
operator|==
name|ebp
operator|&&
operator|!
name|i
operator|.
name|index_reg
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|i
operator|.
name|types
index|[
name|o
index|]
operator|&
name|Disp
operator|)
condition|)
block|{
comment|/* Must fake a zero byte displacement. 									   There is no direct way to code '(%ebp)' directly. */
name|fake_zero_displacement
operator|=
literal|1
expr_stmt|;
comment|/* fake_zero_displacement code does not set this. */
name|i
operator|.
name|types
index|[
name|o
index|]
operator||=
name|Disp8
expr_stmt|;
block|}
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
name|mode_from_disp_size
argument_list|(
name|i
operator|.
name|types
index|[
name|o
index|]
argument_list|)
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|EBP_REG_NUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|i
operator|.
name|base_reg
operator|&&
operator|(
name|i
operator|.
name|types
index|[
name|o
index|]
operator|&
name|BaseIndex
operator|)
condition|)
block|{
comment|/* There are three cases here. 								   Case 1:  '<32bit disp>(,1)' -- indirect absolute. 								   (Same as cases 2& 3 with NO index register) 								   Case 2:<32bit disp> (,<index>) -- no base register with disp 								   Case 3:  (,<index>)       --- no base register; 								   no disp (must add 32bit 0 disp). */
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
comment|/* 32bit mode */
name|i
operator|.
name|bi
operator|.
name|base
operator|=
name|NO_BASE_REGISTER
expr_stmt|;
name|i
operator|.
name|types
index|[
name|o
index|]
operator|&=
operator|~
name|Disp
expr_stmt|;
name|i
operator|.
name|types
index|[
name|o
index|]
operator||=
name|Disp32
expr_stmt|;
comment|/* Must be 32bit! */
if|if
condition|(
name|i
operator|.
name|index_reg
condition|)
block|{
comment|/* case 2 or case 3 */
name|i
operator|.
name|bi
operator|.
name|index
operator|=
name|i
operator|.
name|index_reg
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|scale
operator|=
name|i
operator|.
name|log2_scale_factor
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|disp_operands
operator|==
literal|0
condition|)
name|fake_zero_displacement
operator|=
literal|1
expr_stmt|;
comment|/* case 3 */
block|}
else|else
block|{
name|i
operator|.
name|bi
operator|.
name|index
operator|=
name|NO_INDEX_REGISTER
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|scale
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|disp_operands
operator|&&
operator|!
name|i
operator|.
name|base_reg
operator|&&
operator|!
name|i
operator|.
name|index_reg
condition|)
block|{
comment|/* Operand is just<32bit disp> */
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|EBP_REG_NUM
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|i
operator|.
name|types
index|[
name|o
index|]
operator|&=
operator|~
name|Disp
expr_stmt|;
name|i
operator|.
name|types
index|[
name|o
index|]
operator||=
name|Disp32
expr_stmt|;
block|}
else|else
block|{
comment|/* It's not a special case; rev'em up. */
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|base_reg
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
name|mode_from_disp_size
argument_list|(
name|i
operator|.
name|types
index|[
name|o
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|index_reg
condition|)
block|{
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|base
operator|=
name|i
operator|.
name|base_reg
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|index
operator|=
name|i
operator|.
name|index_reg
operator|->
name|reg_num
expr_stmt|;
name|i
operator|.
name|bi
operator|.
name|scale
operator|=
name|i
operator|.
name|log2_scale_factor
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|base_reg
operator|==
name|ebp
operator|&&
name|i
operator|.
name|disp_operands
operator|==
literal|0
condition|)
block|{
comment|/* pace */
name|fake_zero_displacement
operator|=
literal|1
expr_stmt|;
name|i
operator|.
name|types
index|[
name|o
index|]
operator||=
name|Disp8
expr_stmt|;
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
name|mode_from_disp_size
argument_list|(
name|i
operator|.
name|types
index|[
name|o
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|fake_zero_displacement
condition|)
block|{
comment|/* Fakes a zero displacement assuming that i.types[o] holds 								   the correct displacement size. */
name|exp
operator|=
operator|&
name|disp_expressions
index|[
name|i
operator|.
name|disp_operands
operator|++
index|]
expr_stmt|;
name|i
operator|.
name|disps
index|[
name|o
index|]
operator|=
name|exp
expr_stmt|;
name|exp
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
name|exp
operator|->
name|X_subtract_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* Select the correct segment for the memory operand. */
if|if
condition|(
name|i
operator|.
name|seg
condition|)
block|{
name|unsigned
name|int
name|seg_index
decl_stmt|;
specifier|const
name|seg_entry
modifier|*
name|default_seg
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|rm
operator|.
name|regmem
operator|==
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
condition|)
block|{
name|seg_index
operator|=
operator|(
name|i
operator|.
name|rm
operator|.
name|mode
operator|<<
literal|3
operator|)
operator||
name|i
operator|.
name|bi
operator|.
name|base
expr_stmt|;
name|default_seg
operator|=
name|two_byte_segment_defaults
index|[
name|seg_index
index|]
expr_stmt|;
block|}
else|else
block|{
name|seg_index
operator|=
operator|(
name|i
operator|.
name|rm
operator|.
name|mode
operator|<<
literal|3
operator|)
operator||
name|i
operator|.
name|rm
operator|.
name|regmem
expr_stmt|;
name|default_seg
operator|=
name|one_byte_segment_defaults
index|[
name|seg_index
index|]
expr_stmt|;
block|}
comment|/* If the specified segment is not the default, use an 								   opcode prefix to select it */
if|if
condition|(
name|i
operator|.
name|seg
operator|!=
name|default_seg
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|prefixes
operator|==
name|MAX_PREFIXES
condition|)
block|{
name|as_bad
argument_list|(
literal|"%d prefixes given and %s segment override gives too many prefixes"
argument_list|,
name|MAX_PREFIXES
argument_list|,
name|i
operator|.
name|seg
operator|->
name|seg_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|.
name|prefix
index|[
name|i
operator|.
name|prefixes
operator|++
index|]
operator|=
name|i
operator|.
name|seg
operator|->
name|seg_prefix
expr_stmt|;
block|}
block|}
block|}
comment|/* Fill in i.rm.reg or i.rm.regmem field with register operand 						   (if any) based on t->extension_opcode. Again, we must be careful 						   to make sure that segment/control/debug/test registers are coded 						   into the i.rm.reg field. */
if|if
condition|(
name|i
operator|.
name|reg_operands
condition|)
block|{
name|unsigned
name|int
name|o
init|=
operator|(
name|i
operator|.
name|types
index|[
literal|0
index|]
operator|&
operator|(
name|Reg
operator||
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator|)
operator|)
condition|?
literal|0
else|:
operator|(
name|i
operator|.
name|types
index|[
literal|1
index|]
operator|&
operator|(
name|Reg
operator||
name|SReg2
operator||
name|SReg3
operator||
name|Control
operator||
name|Debug
operator||
name|Test
operator|)
operator|)
condition|?
literal|1
else|:
literal|2
decl_stmt|;
comment|/* If there is an extension opcode to put here, the register number 							   must be put into the regmem field. */
if|if
condition|(
name|t
operator|->
name|extension_opcode
operator|!=
name|None
condition|)
name|i
operator|.
name|rm
operator|.
name|regmem
operator|=
name|i
operator|.
name|regs
index|[
name|o
index|]
operator|->
name|reg_num
expr_stmt|;
else|else
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|i
operator|.
name|regs
index|[
name|o
index|]
operator|->
name|reg_num
expr_stmt|;
comment|/* Now, if no memory operand has set i.rm.mode = 0, 1, 2 							   we must set it to 3 to indicate this is a register operand 							   int the regmem field */
if|if
condition|(
operator|!
name|i
operator|.
name|mem_operands
condition|)
name|i
operator|.
name|rm
operator|.
name|mode
operator|=
literal|3
expr_stmt|;
block|}
comment|/* Fill in i.rm.reg field with extension opcode (if any). */
if|if
condition|(
name|t
operator|->
name|extension_opcode
operator|!=
name|None
condition|)
name|i
operator|.
name|rm
operator|.
name|reg
operator|=
name|t
operator|->
name|extension_opcode
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Handle conversion of 'int $3' --> special int3 insn. */
if|if
condition|(
name|t
operator|->
name|base_opcode
operator|==
name|INT_OPCODE
operator|&&
name|i
operator|.
name|imms
index|[
literal|0
index|]
operator|->
name|X_add_number
operator|==
literal|3
condition|)
block|{
name|t
operator|->
name|base_opcode
operator|=
name|INT3_OPCODE
expr_stmt|;
name|i
operator|.
name|imm_operands
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We are ready to output the insn. */
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Output jumps. */
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|Jump
condition|)
block|{
name|int
name|n
init|=
name|i
operator|.
name|disps
index|[
literal|0
index|]
operator|->
name|X_add_number
decl_stmt|;
switch|switch
condition|(
name|i
operator|.
name|disps
index|[
literal|0
index|]
operator|->
name|X_seg
condition|)
block|{
case|case
name|SEG_ABSOLUTE
case|:
if|if
condition|(
name|fits_in_signed_byte
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|t
operator|->
name|base_opcode
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|n
expr_stmt|;
if|#
directive|if
literal|0
comment|/* leave out 16 bit jumps - pace */
block|} else if (fits_in_signed_word(n)) { 					p = frag_more (4); 					p[0] = WORD_PREFIX_OPCODE; 					p[1] = t->base_opcode; 					md_number_to_chars (&p[2], n, 2);
endif|#
directive|endif
block|}
else|else
block|{
comment|/* It's an absolute dword displacement. */
if|if
condition|(
name|t
operator|->
name|base_opcode
operator|==
name|JUMP_PC_RELATIVE
condition|)
block|{
comment|/* pace */
comment|/* unconditional jump */
name|p
operator|=
name|frag_more
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|0xe9
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|&
name|p
index|[
literal|1
index|]
argument_list|,
name|n
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* conditional jump */
name|p
operator|=
name|frag_more
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|TWO_BYTE_OPCODE_ESCAPE
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|t
operator|->
name|base_opcode
operator|+
literal|0x10
expr_stmt|;
name|md_number_to_chars
argument_list|(
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
name|n
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
comment|/* It's a symbol; end frag& setup for relax. 				   Make sure there are 6 chars left in the current frag; if not 				   we'll have to start a new one. */
comment|/* I caught it failing with obstack_room == 6, 				   so I changed to<= pace */
if|if
condition|(
name|obstack_room
argument_list|(
operator|&
name|frags
argument_list|)
operator|<=
literal|6
condition|)
block|{
name|frag_wane
argument_list|(
name|frag_now
argument_list|)
expr_stmt|;
name|frag_new
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|t
operator|->
name|base_opcode
expr_stmt|;
name|frag_var
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|6
argument_list|,
comment|/* 2 opcode/prefix + 4 displacement */
literal|1
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
operator|==
name|JUMP_PC_RELATIVE
condition|?
name|ENCODE_RELAX_STATE
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|BYTE
argument_list|)
else|:
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP
argument_list|,
name|BYTE
argument_list|)
operator|)
argument_list|,
name|i
operator|.
name|disps
index|[
literal|0
index|]
operator|->
name|X_add_symbol
argument_list|,
name|n
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/*  * XXX - what do we do about jmp x@PLT ??  * kludged in md_estimate_size_before_relax() below  */
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
operator|(
name|JumpByte
operator||
name|JumpDword
operator|)
condition|)
block|{
name|int
name|size
init|=
operator|(
name|t
operator|->
name|opcode_modifier
operator|&
name|JumpByte
operator|)
condition|?
literal|1
else|:
literal|4
decl_stmt|;
name|int
name|n
init|=
name|i
operator|.
name|disps
index|[
literal|0
index|]
operator|->
name|X_add_number
decl_stmt|;
if|if
condition|(
name|fits_in_unsigned_byte
argument_list|(
name|t
operator|->
name|base_opcode
argument_list|)
condition|)
block|{
name|FRAG_APPEND_1_CHAR
argument_list|(
name|t
operator|->
name|base_opcode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* opcode can be at most two bytes */
comment|/* put out high byte first: can't use md_number_to_chars! */
operator|*
name|p
operator|++
operator|=
operator|(
name|t
operator|->
name|base_opcode
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|p
operator|=
name|t
operator|->
name|base_opcode
operator|&
literal|0xff
expr_stmt|;
block|}
name|p
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
operator|.
name|disps
index|[
literal|0
index|]
operator|->
name|X_seg
condition|)
block|{
case|case
name|SEG_ABSOLUTE
case|:
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|n
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|1
operator|&&
operator|!
name|fits_in_signed_byte
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"loop/jecx only takes byte displacement; %d shortened to %d"
argument_list|,
name|n
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
name|i
operator|.
name|disps
index|[
literal|0
index|]
operator|->
name|X_add_symbol
argument_list|,
name|i
operator|.
name|disps
index|[
literal|0
index|]
operator|->
name|X_subtract_symbol
argument_list|,
name|i
operator|.
name|disps
index|[
literal|0
index|]
operator|->
name|X_add_number
argument_list|,
literal|1
argument_list|,
name|i
operator|.
name|disp_reloc
index|[
literal|0
index|]
argument_list|,
name|i
operator|.
name|disps
index|[
literal|0
index|]
operator|->
name|X_got_symbol
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|JumpInterSegment
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
operator|+
literal|2
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* 1 opcode; 2 segment; 4 offset */
name|p
index|[
literal|0
index|]
operator|=
name|t
operator|->
name|base_opcode
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|imms
index|[
literal|1
index|]
operator|->
name|X_seg
operator|==
name|SEG_ABSOLUTE
condition|)
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|i
operator|.
name|imms
index|[
literal|1
index|]
operator|->
name|X_add_number
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|+
literal|1
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|i
operator|.
name|imms
index|[
literal|1
index|]
operator|->
name|X_add_symbol
argument_list|,
name|i
operator|.
name|imms
index|[
literal|1
index|]
operator|->
name|X_subtract_symbol
argument_list|,
name|i
operator|.
name|imms
index|[
literal|1
index|]
operator|->
name|X_add_number
argument_list|,
literal|0
argument_list|,
name|NO_RELOC
argument_list|,
name|i
operator|.
name|imms
index|[
literal|1
index|]
operator|->
name|X_got_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|imms
index|[
literal|0
index|]
operator|->
name|X_seg
operator|!=
name|SEG_ABSOLUTE
condition|)
name|as_bad
argument_list|(
literal|"can't handle non absolute segment in long call/jmp"
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
operator|+
literal|5
argument_list|,
name|i
operator|.
name|imms
index|[
literal|0
index|]
operator|->
name|X_add_number
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Output normal instructions here. */
name|unsigned
name|char
modifier|*
name|q
decl_stmt|;
ifdef|#
directive|ifdef
name|PIC
comment|/* 			 * Remember # of opcode bytes to put in pcrel_adjust 			 * for use in _GLOBAL_OFFSET_TABLE_ expressions. 			 */
name|int
name|nopbytes
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* First the prefix bytes. */
for|for
control|(
name|q
operator|=
name|i
operator|.
name|prefix
init|;
name|q
operator|<
name|i
operator|.
name|prefix
operator|+
name|i
operator|.
name|prefixes
condition|;
name|q
operator|++
control|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|nopbytes
operator|+=
literal|1
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|unsigned
name|int
operator|)
operator|*
name|q
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now the opcode; be careful about word order here! */
if|if
condition|(
name|fits_in_unsigned_byte
argument_list|(
name|t
operator|->
name|base_opcode
argument_list|)
condition|)
block|{
name|nopbytes
operator|+=
literal|1
expr_stmt|;
name|FRAG_APPEND_1_CHAR
argument_list|(
name|t
operator|->
name|base_opcode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fits_in_unsigned_word
argument_list|(
name|t
operator|->
name|base_opcode
argument_list|)
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|nopbytes
operator|+=
literal|2
expr_stmt|;
comment|/* put out high byte first: can't use md_number_to_chars! */
operator|*
name|p
operator|++
operator|=
operator|(
name|t
operator|->
name|base_opcode
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|p
operator|=
name|t
operator|->
name|base_opcode
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
comment|/* opcode is either 3 or 4 bytes */
if|if
condition|(
name|t
operator|->
name|base_opcode
operator|&
literal|0xff000000
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|nopbytes
operator|+=
literal|4
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|t
operator|->
name|base_opcode
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|nopbytes
operator|+=
literal|3
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
operator|(
name|t
operator|->
name|base_opcode
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|t
operator|->
name|base_opcode
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|p
operator|=
operator|(
name|t
operator|->
name|base_opcode
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
comment|/* Now the modrm byte and base index byte (if present). */
if|if
condition|(
name|t
operator|->
name|opcode_modifier
operator|&
name|Modrm
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|nopbytes
operator|+=
literal|1
expr_stmt|;
comment|/* md_number_to_chars (p, i.rm, 1); */
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|i
operator|.
name|rm
operator|.
name|regmem
operator|<<
literal|0
operator||
name|i
operator|.
name|rm
operator|.
name|reg
operator|<<
literal|3
operator||
name|i
operator|.
name|rm
operator|.
name|mode
operator|<<
literal|6
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If i.rm.regmem == ESP (4)&& i.rm.mode != Mode 3 (Register mode) 				   ==> need second modrm byte. */
if|if
condition|(
name|i
operator|.
name|rm
operator|.
name|regmem
operator|==
name|ESCAPE_TO_TWO_BYTE_ADDRESSING
operator|&&
name|i
operator|.
name|rm
operator|.
name|mode
operator|!=
literal|3
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|nopbytes
operator|+=
literal|1
expr_stmt|;
comment|/* md_number_to_chars (p, i.bi, 1); */
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
operator|(
name|i
operator|.
name|bi
operator|.
name|base
operator|<<
literal|0
operator||
name|i
operator|.
name|bi
operator|.
name|index
operator|<<
literal|3
operator||
name|i
operator|.
name|bi
operator|.
name|scale
operator|<<
literal|6
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|.
name|disp_operands
condition|)
block|{
specifier|register
name|unsigned
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|i
operator|.
name|operands
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|.
name|disps
index|[
name|n
index|]
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|disps
index|[
name|n
index|]
operator|->
name|X_seg
operator|==
name|SEG_ABSOLUTE
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Disp8
operator||
name|Abs8
operator|)
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|i
operator|.
name|disps
index|[
name|n
index|]
operator|->
name|X_add_number
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Disp16
operator||
name|Abs16
operator|)
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|i
operator|.
name|disps
index|[
name|n
index|]
operator|->
name|X_add_number
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Disp32|Abs32 */
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|i
operator|.
name|disps
index|[
name|n
index|]
operator|->
name|X_add_number
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* not SEG_ABSOLUTE */
comment|/* need a 32-bit fixup (don't support 8bit non-absolute disps) */
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|fixP
operator|=
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|i
operator|.
name|disps
index|[
name|n
index|]
operator|->
name|X_add_symbol
argument_list|,
name|i
operator|.
name|disps
index|[
name|n
index|]
operator|->
name|X_subtract_symbol
argument_list|,
name|i
operator|.
name|disps
index|[
name|n
index|]
operator|->
name|X_add_number
argument_list|,
literal|0
argument_list|,
name|i
operator|.
name|disp_reloc
index|[
name|n
index|]
argument_list|,
name|i
operator|.
name|disps
index|[
name|n
index|]
operator|->
name|X_got_symbol
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PIC
if|if
condition|(
name|i
operator|.
name|disps
index|[
name|n
index|]
operator|->
name|X_got_symbol
condition|)
block|{
name|fixP
operator|->
name|fx_pcrel_adjust
operator|=
name|nopbytes
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
block|}
block|}
comment|/* end displacement output */
comment|/* output immediate */
if|if
condition|(
name|i
operator|.
name|imm_operands
condition|)
block|{
specifier|register
name|unsigned
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|i
operator|.
name|operands
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|.
name|imms
index|[
name|n
index|]
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_seg
operator|==
name|SEG_ABSOLUTE
condition|)
block|{
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator|)
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_add_number
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Imm16
condition|)
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_add_number
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|frag_more
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|p
argument_list|,
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_add_number
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* not SEG_ABSOLUTE */
comment|/* need a 32-bit fixup (don't support 8bit non-absolute ims) */
comment|/* try to support other sizes ... */
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
operator|(
name|Imm8
operator||
name|Imm8S
operator|)
condition|)
name|size
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|.
name|types
index|[
name|n
index|]
operator|&
name|Imm16
condition|)
name|size
operator|=
literal|2
expr_stmt|;
else|else
name|size
operator|=
literal|4
expr_stmt|;
name|p
operator|=
name|frag_more
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|fixP
operator|=
name|fix_new
argument_list|(
name|frag_now
argument_list|,
name|p
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|,
name|size
argument_list|,
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_add_symbol
argument_list|,
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_subtract_symbol
argument_list|,
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_add_number
argument_list|,
literal|0
argument_list|,
name|NO_RELOC
argument_list|,
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_got_symbol
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PIC
if|if
condition|(
name|i
operator|.
name|imms
index|[
name|n
index|]
operator|->
name|X_got_symbol
condition|)
block|{
name|fixP
operator|->
name|fx_pcrel_adjust
operator|=
name|nopbytes
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
block|}
block|}
comment|/* end immediate output */
block|}
ifdef|#
directive|ifdef
name|DEBUG386
if|if
condition|(
name|flagseen
index|[
literal|'D'
index|]
condition|)
block|{
name|pi
argument_list|(
name|line
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG386 */
block|}
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Parse OPERAND_STRING into the i386_insn structure I.  Returns non-zero    on error. */
end_comment

begin_function
specifier|static
name|int
name|i386_operand
parameter_list|(
name|operand_string
parameter_list|)
name|char
modifier|*
name|operand_string
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|op_string
init|=
name|operand_string
decl_stmt|;
comment|/* Address of '\0' at end of operand_string. */
name|char
modifier|*
name|end_of_operand_string
init|=
name|operand_string
operator|+
name|strlen
argument_list|(
name|operand_string
argument_list|)
decl_stmt|;
comment|/* Start and end of displacement string expression (if found). */
name|char
modifier|*
name|displacement_string_start
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|displacement_string_end
init|=
name|NULL
decl_stmt|;
comment|/* We check for an absolute prefix (differentiating, 	   for example, 'jmp pc_relative_label' from 'jmp *absolute_label'. */
if|if
condition|(
operator|*
name|op_string
operator|==
name|ABSOLUTE_PREFIX
condition|)
block|{
name|op_string
operator|++
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|JumpAbsolute
expr_stmt|;
block|}
comment|/* Check if operand is a register. */
if|if
condition|(
operator|*
name|op_string
operator|==
name|REGISTER_PREFIX
condition|)
block|{
specifier|register
name|reg_entry
modifier|*
name|r
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|r
operator|=
name|parse_register
argument_list|(
name|op_string
argument_list|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"bad register name ('%s')"
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check for segment override, rather than segment register by 		   searching for ':' after %<x>s where<x> = s, c, d, e, f, g. */
if|if
condition|(
operator|(
name|r
operator|->
name|reg_type
operator|&
operator|(
name|SReg2
operator||
name|SReg3
operator|)
operator|)
operator|&&
name|op_string
index|[
literal|3
index|]
operator|==
literal|':'
condition|)
block|{
switch|switch
condition|(
name|r
operator|->
name|reg_num
condition|)
block|{
case|case
literal|0
case|:
name|i
operator|.
name|seg
operator|=
operator|(
name|seg_entry
operator|*
operator|)
operator|&
name|es
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|i
operator|.
name|seg
operator|=
operator|(
name|seg_entry
operator|*
operator|)
operator|&
name|cs
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|i
operator|.
name|seg
operator|=
operator|(
name|seg_entry
operator|*
operator|)
operator|&
name|ss
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|i
operator|.
name|seg
operator|=
operator|(
name|seg_entry
operator|*
operator|)
operator|&
name|ds
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|i
operator|.
name|seg
operator|=
operator|(
name|seg_entry
operator|*
operator|)
operator|&
name|fs
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|i
operator|.
name|seg
operator|=
operator|(
name|seg_entry
operator|*
operator|)
operator|&
name|gs
expr_stmt|;
break|break;
block|}
name|op_string
operator|+=
literal|4
expr_stmt|;
comment|/* skip %<x> s : */
name|operand_string
operator|=
name|op_string
expr_stmt|;
comment|/* Pretend given string starts here. */
if|if
condition|(
operator|!
name|is_digit_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|&&
operator|!
name|is_identifier_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|&&
operator|*
name|op_string
operator|!=
literal|'('
operator|&&
operator|*
name|op_string
operator|!=
name|ABSOLUTE_PREFIX
condition|)
block|{
name|as_bad
argument_list|(
literal|"bad memory operand after segment override"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Handle case of %es:*foo. */
if|if
condition|(
operator|*
name|op_string
operator|==
name|ABSOLUTE_PREFIX
condition|)
block|{
name|op_string
operator|++
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|JumpAbsolute
expr_stmt|;
block|}
goto|goto
name|do_memory_reference
goto|;
block|}
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|r
operator|->
name|reg_type
expr_stmt|;
name|i
operator|.
name|regs
index|[
name|this_operand
index|]
operator|=
name|r
expr_stmt|;
name|i
operator|.
name|reg_operands
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|op_string
operator|==
name|IMMEDIATE_PREFIX
condition|)
block|{
comment|/* ... or an immediate */
name|char
modifier|*
name|save_input_line_pointer
decl_stmt|;
name|segT
name|exp_seg
init|=
name|SEG_GOOF
decl_stmt|;
name|expressionS
modifier|*
name|exp
decl_stmt|;
if|if
condition|(
name|i
operator|.
name|imm_operands
operator|==
name|MAX_IMMEDIATE_OPERANDS
condition|)
block|{
name|as_bad
argument_list|(
literal|"only 1 or 2 immediate operands are allowed"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|exp
operator|=
operator|&
name|im_expressions
index|[
name|i
operator|.
name|imm_operands
operator|++
index|]
expr_stmt|;
name|i
operator|.
name|imms
index|[
name|this_operand
index|]
operator|=
name|exp
expr_stmt|;
name|save_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
comment|/* must advance op_string! */
name|input_line_pointer
operator|=
operator|++
name|op_string
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
name|exp_seg
operator|=
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save_input_line_pointer
expr_stmt|;
switch|switch
condition|(
name|exp_seg
condition|)
block|{
case|case
name|SEG_ABSENT
case|:
comment|/* missing or bad expr becomes absolute 0 */
name|as_bad
argument_list|(
literal|"missing or invalid immediate expression '%s' taken as 0"
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
name|exp
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
name|exp
operator|->
name|X_subtract_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Imm
expr_stmt|;
break|break;
case|case
name|SEG_ABSOLUTE
case|:
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|smallest_imm_type
argument_list|(
name|exp
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEG_TEXT
case|:
case|case
name|SEG_DATA
case|:
case|case
name|SEG_BSS
case|:
case|case
name|SEG_UNKNOWN
case|:
case|case
name|SEG_DIFFERENCE
case|:
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Imm32
expr_stmt|;
comment|/* this is an address ==> 32bit */
break|break;
default|default:
name|seg_unimplemented
label|:
name|as_bad
argument_list|(
literal|"Unimplemented segment type %d in parse_operand"
argument_list|,
name|exp_seg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* shorten this type of this operand if the instruction wants 		 * fewer bits than are present in the immediate.  The bit field 		 * code can put out 'andb $0xffffff, %al', for example.   pace 		 * also 'movw $foo,(%eax)' 		 */
switch|switch
condition|(
name|i
operator|.
name|suffix
condition|)
block|{
case|case
name|WORD_OPCODE_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Imm16
expr_stmt|;
break|break;
case|case
name|BYTE_OPCODE_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Imm16
operator||
name|Imm8
operator||
name|Imm8S
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|is_digit_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|||
name|is_identifier_char
argument_list|(
operator|*
name|op_string
argument_list|)
operator|||
operator|*
name|op_string
operator|==
literal|'('
condition|)
block|{
comment|/* This is a memory reference of some sort. */
specifier|register
name|char
modifier|*
name|base_string
decl_stmt|;
name|unsigned
name|int
name|found_base_index_form
decl_stmt|;
name|do_memory_reference
label|:
if|if
condition|(
name|i
operator|.
name|mem_operands
operator|==
name|MAX_MEMORY_OPERANDS
condition|)
block|{
name|as_bad
argument_list|(
literal|"more than 1 memory reference in instruction"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|.
name|mem_operands
operator|++
expr_stmt|;
comment|/* Determine type of memory operand from opcode_suffix; 		   no opcode suffix implies general memory references. */
switch|switch
condition|(
name|i
operator|.
name|suffix
condition|)
block|{
case|case
name|BYTE_OPCODE_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Mem8
expr_stmt|;
break|break;
case|case
name|WORD_OPCODE_SUFFIX
case|:
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Mem16
expr_stmt|;
break|break;
case|case
name|DWORD_OPCODE_SUFFIX
case|:
default|default:
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Mem32
expr_stmt|;
block|}
comment|/*  Check for base index form.  We detect the base index form by 		    looking for an ')' at the end of the operand, searching 		    for the '(' matching it, and finding a REGISTER_PREFIX or ',' 		    after it. */
name|base_string
operator|=
name|end_of_operand_string
operator|-
literal|1
expr_stmt|;
name|found_base_index_form
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|')'
condition|)
block|{
name|unsigned
name|int
name|parens_balenced
init|=
literal|1
decl_stmt|;
comment|/* We've already checked that the number of left& right ()'s are equal, 			   so this loop will not be infinite. */
do|do
block|{
name|base_string
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|')'
condition|)
name|parens_balenced
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|base_string
operator|==
literal|'('
condition|)
name|parens_balenced
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|parens_balenced
condition|)
do|;
name|base_string
operator|++
expr_stmt|;
comment|/* Skip past '('. */
if|if
condition|(
operator|*
name|base_string
operator|==
name|REGISTER_PREFIX
operator|||
operator|*
name|base_string
operator|==
literal|','
condition|)
name|found_base_index_form
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If we can't parse a base index register expression, we've found 		   a pure displacement expression.  We set up displacement_string_start 		   and displacement_string_end for the code below. */
if|if
condition|(
operator|!
name|found_base_index_form
condition|)
block|{
name|displacement_string_start
operator|=
name|op_string
expr_stmt|;
name|displacement_string_end
operator|=
name|end_of_operand_string
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|base_reg_name
decl_stmt|,
modifier|*
name|index_reg_name
decl_stmt|,
modifier|*
name|num_string
decl_stmt|;
name|int
name|num
decl_stmt|;
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|BaseIndex
expr_stmt|;
comment|/* If there is a displacement set-up for it to be parsed later. */
if|if
condition|(
name|base_string
operator|!=
name|op_string
operator|+
literal|1
condition|)
block|{
name|displacement_string_start
operator|=
name|op_string
expr_stmt|;
name|displacement_string_end
operator|=
name|base_string
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Find base register (if any). */
if|if
condition|(
operator|*
name|base_string
operator|!=
literal|','
condition|)
block|{
name|base_reg_name
operator|=
name|base_string
operator|++
expr_stmt|;
comment|/* skip past register name& parse it */
while|while
condition|(
name|isalpha
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
name|base_string
operator|++
expr_stmt|;
if|if
condition|(
name|base_string
operator|==
name|base_reg_name
operator|+
literal|1
condition|)
block|{
name|as_bad
argument_list|(
literal|"can't find base register name after '(%c'"
argument_list|,
name|REGISTER_PREFIX
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|END_STRING_AND_SAVE
argument_list|(
name|base_string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|.
name|base_reg
operator|=
name|parse_register
argument_list|(
name|base_reg_name
argument_list|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"bad base register name ('%s')"
argument_list|,
name|base_reg_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|RESTORE_END_STRING
argument_list|(
name|base_string
argument_list|)
expr_stmt|;
block|}
comment|/* Now check seperator; must be ',' ==> index reg 			   OR num ==> no index reg. just scale factor 			   OR ')' ==> end. (scale factor = 1) */
if|if
condition|(
operator|*
name|base_string
operator|!=
literal|','
operator|&&
operator|*
name|base_string
operator|!=
literal|')'
condition|)
block|{
name|as_bad
argument_list|(
literal|"expecting ',' or ')' after base register in `%s'"
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* There may index reg here; and there may be a scale factor. */
if|if
condition|(
operator|*
name|base_string
operator|==
literal|','
operator|&&
operator|*
operator|(
name|base_string
operator|+
literal|1
operator|)
operator|==
name|REGISTER_PREFIX
condition|)
block|{
name|index_reg_name
operator|=
operator|++
name|base_string
expr_stmt|;
while|while
condition|(
name|isalpha
argument_list|(
operator|*
operator|++
name|base_string
argument_list|)
condition|)
empty_stmt|;
name|END_STRING_AND_SAVE
argument_list|(
name|base_string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|.
name|index_reg
operator|=
name|parse_register
argument_list|(
name|index_reg_name
argument_list|)
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"bad index register name ('%s')"
argument_list|,
name|index_reg_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|RESTORE_END_STRING
argument_list|(
name|base_string
argument_list|)
expr_stmt|;
block|}
comment|/* Check for scale factor. */
if|if
condition|(
operator|*
name|base_string
operator|==
literal|','
operator|&&
name|isdigit
argument_list|(
operator|*
operator|(
name|base_string
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|num_string
operator|=
operator|++
name|base_string
expr_stmt|;
while|while
condition|(
name|is_digit_char
argument_list|(
operator|*
name|base_string
argument_list|)
condition|)
name|base_string
operator|++
expr_stmt|;
if|if
condition|(
name|base_string
operator|==
name|num_string
condition|)
block|{
name|as_bad
argument_list|(
literal|"can't find a scale factor after ','"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|END_STRING_AND_SAVE
argument_list|(
name|base_string
argument_list|)
expr_stmt|;
comment|/* We've got a scale factor. */
if|if
condition|(
operator|!
name|sscanf
argument_list|(
name|num_string
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|num
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"can't parse scale factor from '%s'"
argument_list|,
name|num_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|RESTORE_END_STRING
argument_list|(
name|base_string
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|num
condition|)
block|{
comment|/* must be 1 digit scale */
case|case
literal|1
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|i
operator|.
name|log2_scale_factor
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|as_bad
argument_list|(
literal|"expecting scale factor of 1, 2, 4, 8; got %d"
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|i
operator|.
name|index_reg
operator|&&
operator|*
name|base_string
operator|==
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"expecting index register or scale factor after ','; got '%c'"
argument_list|,
operator|*
operator|(
name|base_string
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
comment|/* If there's an expression begining the operand, parse it, 		   assuming displacement_string_start and displacement_string_end 		   are meaningful. */
if|if
condition|(
name|displacement_string_start
condition|)
block|{
specifier|register
name|expressionS
modifier|*
name|exp
decl_stmt|;
name|segT
name|exp_seg
init|=
name|SEG_GOOF
decl_stmt|;
name|char
modifier|*
name|save_input_line_pointer
decl_stmt|;
name|exp
operator|=
operator|&
name|disp_expressions
index|[
name|i
operator|.
name|disp_operands
index|]
expr_stmt|;
name|i
operator|.
name|disps
index|[
name|this_operand
index|]
operator|=
name|exp
expr_stmt|;
name|i
operator|.
name|disp_reloc
index|[
name|this_operand
index|]
operator|=
name|NO_RELOC
expr_stmt|;
name|i
operator|.
name|disp_operands
operator|++
expr_stmt|;
name|save_input_line_pointer
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|displacement_string_start
expr_stmt|;
name|END_STRING_AND_SAVE
argument_list|(
name|displacement_string_end
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PIC
block|{
comment|/* 			 * We can have operands of the form 			 *<symbol>@GOTOFF+<nnn> 			 * Take the easy way out here and copy everything 			 * into a temporary buffer... 			 */
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|picmode
operator|&&
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|input_line_pointer
argument_list|,
literal|'@'
argument_list|)
operator|)
condition|)
block|{
name|char
name|tmpbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"PLT"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|disp_reloc
index|[
name|this_operand
index|]
operator|=
name|RELOC_JMP_TBL
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
name|cp
operator|+
literal|1
operator|+
literal|3
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'@'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"GOTOFF"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|disp_reloc
index|[
name|this_operand
index|]
operator|=
name|RELOC_GOTOFF
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
name|cp
operator|+
literal|1
operator|+
literal|6
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'@'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|"GOT"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|.
name|disp_reloc
index|[
name|this_operand
index|]
operator|=
name|RELOC_GOT
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|tmpbuf
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmpbuf
argument_list|,
name|cp
operator|+
literal|1
operator|+
literal|3
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'@'
expr_stmt|;
block|}
else|else
name|as_bad
argument_list|(
literal|"Bad reloc specifier '%s' in expression"
argument_list|,
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|tmpbuf
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|exp_seg
operator|=
name|expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PIC
if|if
condition|(
name|i
operator|.
name|disp_reloc
index|[
name|this_operand
index|]
operator|==
name|RELOC_GOTOFF
condition|)
name|exp
operator|->
name|X_add_symbol
operator|->
name|sy_forceout
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|*
name|input_line_pointer
condition|)
name|as_bad
argument_list|(
literal|"Ignoring junk '%s' after expression"
argument_list|,
name|input_line_pointer
argument_list|)
expr_stmt|;
name|RESTORE_END_STRING
argument_list|(
name|displacement_string_end
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|save_input_line_pointer
expr_stmt|;
switch|switch
condition|(
name|exp_seg
condition|)
block|{
case|case
name|SEG_ABSENT
case|:
comment|/* missing expr becomes absolute 0 */
name|as_bad
argument_list|(
literal|"missing or invalid displacement '%s' taken as 0"
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|disp_reloc
index|[
name|this_operand
index|]
operator|!=
name|NO_RELOC
operator|||
operator|!
name|found_base_index_form
operator|||
operator|!
name|i
operator|.
name|base_reg
condition|)
block|{
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
operator|(
name|Disp
operator||
name|Abs
operator|)
expr_stmt|;
name|exp
operator|->
name|X_seg
operator|=
name|SEG_ABSOLUTE
expr_stmt|;
name|exp
operator|->
name|X_add_number
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|X_add_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
name|exp
operator|->
name|X_subtract_symbol
operator|=
operator|(
name|symbolS
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUGxxx
name|printf
argument_list|(
literal|"displacement removed in operand `%s'\n"
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|.
name|disp_operands
operator|--
expr_stmt|;
name|i
operator|.
name|disps
index|[
name|this_operand
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|SEG_ABSOLUTE
case|:
if|if
condition|(
name|i
operator|.
name|disp_reloc
index|[
name|this_operand
index|]
operator|!=
name|NO_RELOC
operator|||
operator|!
name|found_base_index_form
operator|||
operator|!
name|i
operator|.
name|base_reg
operator|||
name|exp
operator|->
name|X_add_symbol
operator|||
name|exp
operator|->
name|X_subtract_symbol
operator|||
name|exp
operator|->
name|X_add_number
operator|!=
literal|0
condition|)
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|SMALLEST_DISP_TYPE
argument_list|(
name|exp
operator|->
name|X_add_number
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUGxxx
name|printf
argument_list|(
literal|"displacement removed in operand `%s'\n"
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|.
name|disp_operands
operator|--
expr_stmt|;
name|i
operator|.
name|disps
index|[
name|this_operand
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|SEG_TEXT
case|:
case|case
name|SEG_DATA
case|:
case|case
name|SEG_BSS
case|:
case|case
name|SEG_UNKNOWN
case|:
comment|/* must be 32 bit displacement (i.e. address) */
if|if
condition|(
name|i
operator|.
name|disp_reloc
index|[
name|this_operand
index|]
operator|!=
name|NO_RELOC
operator|||
operator|!
name|found_base_index_form
operator|||
operator|!
name|i
operator|.
name|base_reg
operator|||
name|exp
operator|->
name|X_add_symbol
operator|||
name|exp
operator|->
name|X_subtract_symbol
operator|||
name|exp
operator|->
name|X_add_number
operator|!=
literal|0
condition|)
name|i
operator|.
name|types
index|[
name|this_operand
index|]
operator||=
name|Disp32
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUGxxx
name|printf
argument_list|(
literal|"displacement removed in operand `%s'\n"
argument_list|,
name|operand_string
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|.
name|disp_operands
operator|--
expr_stmt|;
name|i
operator|.
name|disps
index|[
name|this_operand
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
goto|goto
name|seg_unimplemented
goto|;
block|}
block|}
comment|/* Make sure the memory operand we've been dealt is valid. */
if|if
condition|(
name|i
operator|.
name|base_reg
operator|&&
name|i
operator|.
name|index_reg
operator|&&
operator|!
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
name|i
operator|.
name|index_reg
operator|->
name|reg_type
operator|&
name|Reg
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"register size mismatch in (base,index,scale) expression"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 		 * special case for (%dx) while doing input/output op 		 */
if|if
condition|(
operator|(
name|i
operator|.
name|base_reg
operator|&&
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|==
operator|(
name|Reg16
operator||
name|InOutPortReg
operator|)
operator|)
operator|&&
operator|(
name|i
operator|.
name|index_reg
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|i
operator|.
name|base_reg
operator|&&
operator|(
name|i
operator|.
name|base_reg
operator|->
name|reg_type
operator|&
name|Reg32
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|i
operator|.
name|index_reg
operator|&&
operator|(
name|i
operator|.
name|index_reg
operator|->
name|reg_type
operator|&
name|Reg32
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"base/index register must be 32 bit register"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|i
operator|.
name|index_reg
operator|&&
name|i
operator|.
name|index_reg
operator|==
name|esp
condition|)
block|{
name|as_bad
argument_list|(
literal|"%s may not be used as an index register"
argument_list|,
name|esp
operator|->
name|reg_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* it's not a memory operand; argh! */
name|as_bad
argument_list|(
literal|"invalid char %s begining %s operand '%s'"
argument_list|,
name|output_invalid
argument_list|(
operator|*
name|op_string
argument_list|)
argument_list|,
name|ordinal_names
index|[
name|this_operand
index|]
argument_list|,
name|op_string
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
comment|/* normal return */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			md_estimate_size_before_relax()  *  * Called just before relax().  * Any symbol that is now undefined will not become defined.  * Return the correct fr_subtype in the frag.  * Return the initial "guess for fr_var" to caller.  * The guess for fr_var is ACTUALLY the growth beyond fr_fix.  * Whatever we do to grow fr_fix or fr_var contributes to our returned value.  * Although it may not be explicit in the frag, pretend fr_var starts with a  * 0 value.  */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment
parameter_list|)
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
specifier|register
name|segT
name|segment
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|opcode
decl_stmt|;
specifier|register
name|int
name|old_fr_fix
decl_stmt|;
name|old_fr_fix
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|opcode
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
comment|/* We've already got fragP->fr_subtype right;  all we have to do is check 	   for un-relaxable symbols. */
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|!=
name|segment
condition|)
block|{
comment|/* symbol is undefined in this segment */
switch|switch
condition|(
name|opcode
index|[
literal|0
index|]
condition|)
block|{
case|case
name|JUMP_PC_RELATIVE
case|:
comment|/* make jmp (0xeb) a dword displacement jump */
name|opcode
index|[
literal|0
index|]
operator|=
literal|0xe9
expr_stmt|;
comment|/* dword disp jmp */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
ifdef|#
directive|ifdef
name|PIC
comment|/* XXX - oops, the JMP_TBL relocation info should have percolated through  * here, define a field in frag to this?  */
operator|(
name|picmode
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|SEG_UNKNOWN
operator|)
condition|?
name|RELOC_JMP_TBL
else|:
endif|#
directive|endif
name|NO_RELOC
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* This changes the byte-displacement jump 0x7N --> 			   the dword-displacement jump 0x0f8N */
name|opcode
index|[
literal|1
index|]
operator|=
name|opcode
index|[
literal|0
index|]
operator|+
literal|0x10
expr_stmt|;
name|opcode
index|[
literal|0
index|]
operator|=
name|TWO_BYTE_OPCODE_ESCAPE
expr_stmt|;
comment|/* two-byte escape */
name|fragP
operator|->
name|fr_fix
operator|+=
literal|1
operator|+
literal|4
expr_stmt|;
comment|/* we've added an opcode byte */
name|fix_new
argument_list|(
name|fragP
argument_list|,
name|old_fr_fix
operator|+
literal|1
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
ifdef|#
directive|ifdef
name|PIC
comment|/*XXX*/
operator|(
name|picmode
operator|&&
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|SEG_UNKNOWN
operator|)
condition|?
name|RELOC_JMP_TBL
else|:
endif|#
directive|endif
name|NO_RELOC
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fragP
operator|->
name|fr_var
operator|+
name|fragP
operator|->
name|fr_fix
operator|-
name|old_fr_fix
operator|)
return|;
block|}
end_function

begin_comment
comment|/* md_estimate_size_before_relax() */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *			md_convert_frag();  *  * Called after relax() is finished.  * In:	Address of frag.  *	fr_type == rs_machine_dependent.  *	fr_subtype is what the address relaxed to.  *  * Out:	Any fixSs and constants are set up.  *	Caller will turn frag into a ".space 0".  */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|headers
parameter_list|,
name|fragP
parameter_list|)
name|object_headers
modifier|*
name|headers
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|opcode
decl_stmt|;
name|unsigned
name|char
modifier|*
name|where_to_put_displacement
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|target_address
decl_stmt|;
name|unsigned
name|int
name|opcode_address
decl_stmt|;
name|unsigned
name|int
name|extension
init|=
literal|0
decl_stmt|;
name|int
name|displacement_from_opcode_start
decl_stmt|;
name|opcode
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|fragP
operator|->
name|fr_opcode
expr_stmt|;
comment|/* Address we want to reach in file space. */
name|target_address
operator|=
name|S_GET_VALUE
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|+
name|fragP
operator|->
name|fr_offset
expr_stmt|;
comment|/* Address opcode resides at in file space. */
name|opcode_address
operator|=
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
expr_stmt|;
comment|/* Displacement from opcode start to fill into instruction. */
name|displacement_from_opcode_start
operator|=
name|target_address
operator|-
name|opcode_address
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP
argument_list|,
name|BYTE
argument_list|)
case|:
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|BYTE
argument_list|)
case|:
comment|/* don't have to change opcode */
name|extension
operator|=
literal|1
expr_stmt|;
comment|/* 1 opcode + 1 displacement */
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP
argument_list|,
name|WORD
argument_list|)
case|:
name|opcode
index|[
literal|1
index|]
operator|=
name|TWO_BYTE_OPCODE_ESCAPE
expr_stmt|;
name|opcode
index|[
literal|2
index|]
operator|=
name|opcode
index|[
literal|0
index|]
operator|+
literal|0x10
expr_stmt|;
name|opcode
index|[
literal|0
index|]
operator|=
name|WORD_PREFIX_OPCODE
expr_stmt|;
name|extension
operator|=
literal|4
expr_stmt|;
comment|/* 3 opcode + 2 displacement */
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|3
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|WORD
argument_list|)
case|:
name|opcode
index|[
literal|1
index|]
operator|=
literal|0xe9
expr_stmt|;
name|opcode
index|[
literal|0
index|]
operator|=
name|WORD_PREFIX_OPCODE
expr_stmt|;
name|extension
operator|=
literal|3
expr_stmt|;
comment|/* 2 opcode + 2 displacement */
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|COND_JUMP
argument_list|,
name|DWORD
argument_list|)
case|:
name|opcode
index|[
literal|1
index|]
operator|=
name|opcode
index|[
literal|0
index|]
operator|+
literal|0x10
expr_stmt|;
name|opcode
index|[
literal|0
index|]
operator|=
name|TWO_BYTE_OPCODE_ESCAPE
expr_stmt|;
name|extension
operator|=
literal|5
expr_stmt|;
comment|/* 2 opcode + 4 displacement */
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|ENCODE_RELAX_STATE
argument_list|(
name|UNCOND_JUMP
argument_list|,
name|DWORD
argument_list|)
case|:
name|opcode
index|[
literal|0
index|]
operator|=
literal|0xe9
expr_stmt|;
name|extension
operator|=
literal|4
expr_stmt|;
comment|/* 1 opcode + 4 displacement */
name|where_to_put_displacement
operator|=
operator|&
name|opcode
index|[
literal|1
index|]
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* now put displacement after opcode */
name|md_number_to_chars
argument_list|(
operator|(
name|char
operator|*
operator|)
name|where_to_put_displacement
argument_list|,
name|displacement_from_opcode_start
operator|-
name|extension
argument_list|,
name|SIZE_FROM_RELAX_STATE
argument_list|(
name|fragP
operator|->
name|fr_subtype
argument_list|)
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|extension
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|int
name|md_short_jump_size
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of byte displacement jmp */
end_comment

begin_decl_stmt
name|int
name|md_long_jump_size
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of dword displacement jmp */
end_comment

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of relocation record */
end_comment

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|long
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|long
name|offset
decl_stmt|;
name|offset
operator|=
name|to_addr
operator|-
operator|(
name|from_addr
operator|+
literal|2
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|long
operator|)
literal|0xeb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* opcode for byte-disp jump */
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|long
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|long
name|offset
decl_stmt|;
if|if
condition|(
name|flagseen
index|[
literal|'m'
index|]
condition|)
block|{
name|offset
operator|=
name|to_addr
operator|-
name|S_GET_VALUE
argument_list|(
name|to_symbol
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
literal|0xe9
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* opcode for long jmp */
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|fix_new
argument_list|(
name|frag
argument_list|,
operator|(
name|ptr
operator|+
literal|1
operator|)
operator|-
name|frag
operator|->
name|fr_literal
argument_list|,
literal|4
argument_list|,
name|to_symbol
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|NO_RELOC
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|to_addr
operator|-
operator|(
name|from_addr
operator|+
literal|5
operator|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|long
operator|)
literal|0xe9
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|md_parse_option
parameter_list|(
name|argP
parameter_list|,
name|cntP
parameter_list|,
name|vecP
parameter_list|)
name|char
modifier|*
modifier|*
name|argP
decl_stmt|;
name|int
modifier|*
name|cntP
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|vecP
decl_stmt|;
block|{
switch|switch
condition|(
operator|*
operator|*
name|argP
condition|)
block|{
ifdef|#
directive|ifdef
name|PIC
case|case
literal|'k'
case|:
case|case
literal|'K'
case|:
if|#
directive|if
literal|00
name|char
modifier|*
name|tmp
init|=
name|xmalloc
argument_list|(
literal|3
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|operand_special_chars
argument_list|)
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|operand_special_chars
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp
argument_list|,
literal|"@[]"
argument_list|)
expr_stmt|;
name|operand_special_chars
operator|=
name|tmp
expr_stmt|;
endif|#
directive|endif
comment|/* Allow `[', `]' in expressions and `@' in operands */
name|operand_chars
index|[
literal|'@'
index|]
operator|=
literal|'@'
expr_stmt|;
name|operand_chars
index|[
literal|'['
index|]
operator|=
literal|'['
expr_stmt|;
name|operand_chars
index|[
literal|']'
index|]
operator|=
literal|']'
expr_stmt|;
comment|/* Disallow `[' as a name beginner */
name|lex_type
index|[
literal|'['
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Predefine GOT symbol */
name|GOT_symbol
operator|=
name|symbol_find_or_make
argument_list|(
literal|"__GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* write out in little endian. */
end_comment

begin_function
name|void
comment|/* Knows about order of bytes in address. */
name|md_number_to_chars
parameter_list|(
name|con
parameter_list|,
name|value
parameter_list|,
name|nbytes
parameter_list|)
name|char
name|con
index|[]
decl_stmt|;
comment|/* Return 'nbytes' of chars here. */
name|long
name|value
decl_stmt|;
comment|/* The value of the bits. */
name|int
name|nbytes
decl_stmt|;
comment|/* Number of bytes in the output. */
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|con
decl_stmt|;
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|1
case|:
name|p
index|[
literal|0
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|p
index|[
literal|0
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|p
index|[
literal|0
index|]
operator|=
name|value
operator|&
literal|0xff
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Apply a fixup (fixS) to segment data, once it has been determined    by our caller that we have all the info we need to fix it up.     On the 386, immediates, displacements, and data pointers are all in    the same (little-endian) format, so we don't need to care about which    we are handling.  */
end_comment

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixP
parameter_list|,
name|value
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
comment|/* The fix we're to put in */
name|long
name|value
decl_stmt|;
comment|/* The value of the bits. */
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_size
condition|)
block|{
case|case
literal|1
case|:
operator|*
name|p
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|p
operator|++
operator|=
name|value
expr_stmt|;
operator|*
name|p
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
operator|*
name|p
operator|++
operator|=
name|value
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|value
operator|>>
literal|16
operator|)
expr_stmt|;
operator|*
name|p
operator|=
operator|(
name|value
operator|>>
literal|24
operator|)
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|long
comment|/* Knows about the byte order in a word. */
name|md_chars_to_number
parameter_list|(
name|con
parameter_list|,
name|nbytes
parameter_list|)
name|unsigned
name|char
name|con
index|[]
decl_stmt|;
comment|/* Low order byte 1st. */
name|int
name|nbytes
decl_stmt|;
comment|/* Number of bytes in the input. */
block|{
name|long
name|retval
decl_stmt|;
for|for
control|(
name|retval
operator|=
literal|0
operator|,
name|con
operator|+=
name|nbytes
operator|-
literal|1
init|;
name|nbytes
operator|--
condition|;
name|con
operator|--
control|)
block|{
name|retval
operator|<<=
name|BITS_PER_CHAR
expr_stmt|;
name|retval
operator||=
operator|*
name|con
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Not needed for coff since relocation structure does not    contain bitfields. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OBJ_AOUT
argument_list|)
operator||
name|defined
argument_list|(
name|OBJ_BOUT
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|comment
end_ifdef

begin_comment
comment|/* Output relocation information in the target's format.  */
end_comment

begin_function
name|void
name|md_ri_to_chars
parameter_list|(
name|the_bytes
parameter_list|,
name|ri
parameter_list|)
name|char
modifier|*
name|the_bytes
decl_stmt|;
name|struct
name|reloc_info_generic
modifier|*
name|ri
decl_stmt|;
block|{
comment|/* this is easy */
name|md_number_to_chars
argument_list|(
name|the_bytes
argument_list|,
name|ri
operator|->
name|r_address
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* now the fun stuff */
name|the_bytes
index|[
literal|6
index|]
operator|=
operator|(
name|ri
operator|->
name|r_symbolnum
operator|>>
literal|16
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|the_bytes
index|[
literal|5
index|]
operator|=
operator|(
name|ri
operator|->
name|r_symbolnum
operator|>>
literal|8
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|the_bytes
index|[
literal|4
index|]
operator|=
name|ri
operator|->
name|r_symbolnum
operator|&
literal|0x0ff
expr_stmt|;
name|the_bytes
index|[
literal|7
index|]
operator|=
operator|(
operator|(
operator|(
name|ri
operator|->
name|r_extern
operator|<<
literal|3
operator|)
operator|&
literal|0x08
operator|)
operator||
operator|(
operator|(
name|ri
operator|->
name|r_length
operator|<<
literal|1
operator|)
operator|&
literal|0x06
operator|)
operator||
operator|(
operator|(
name|ri
operator|->
name|r_pcrel
operator|<<
literal|0
operator|)
operator|&
literal|0x01
operator|)
operator|)
operator|&
literal|0x0F
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* comment */
end_comment

begin_function
name|void
name|tc_aout_fix_to_chars
parameter_list|(
name|where
parameter_list|,
name|fixP
parameter_list|,
name|segment_address_in_file
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|relax_addressT
name|segment_address_in_file
decl_stmt|;
block|{
comment|/* 	 * In: length of relocation (or of address) in chars: 1, 2 or 4. 	 * Out: GNU LD relocation length code: 0, 1, or 2. 	 */
specifier|static
name|unsigned
name|char
name|nbytes_r_length
index|[]
init|=
block|{
literal|42
block|,
literal|0
block|,
literal|1
block|,
literal|42
block|,
literal|2
block|}
decl_stmt|;
name|long
name|r_symbolnum
decl_stmt|;
name|know
argument_list|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|segment_address_in_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|r_symbolnum
operator|=
operator|(
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|?
name|S_GET_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
else|:
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_number
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PIC
block|{
name|int
name|extra_bits
init|=
literal|0
decl_stmt|;
name|int
name|extrn_bit
init|=
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|NO_RELOC
case|:
break|break;
case|case
name|RELOC_32
case|:
if|if
condition|(
operator|!
name|picmode
operator|||
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
break|break;
name|r_symbolnum
operator|=
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_number
expr_stmt|;
name|extrn_bit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RELOC_GOT
case|:
name|extra_bits
operator|=
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|&
literal|0x10
expr_stmt|;
comment|/* r_baserel */
name|r_symbolnum
operator|=
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_number
expr_stmt|;
if|if
condition|(
operator|!
name|extrn_bit
operator|&&
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
name|as_warn
argument_list|(
literal|"GOT relocation burb: `%s' should be global"
argument_list|,
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|)
expr_stmt|;
name|S_SET_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
expr_stmt|;
name|extrn_bit
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|RELOC_GOTOFF
case|:
name|extra_bits
operator|=
operator|(
literal|1
operator|<<
literal|4
operator|)
operator|&
literal|0x10
expr_stmt|;
comment|/* r_baserel */
name|r_symbolnum
operator|=
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_number
expr_stmt|;
if|if
condition|(
name|extrn_bit
operator|||
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
name|as_warn
argument_list|(
literal|"GOT relocation burb: `%s' should be static"
argument_list|,
name|S_GET_NAME
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|RELOC_JMP_TBL
case|:
name|extra_bits
operator|=
operator|(
literal|1
operator|<<
literal|5
operator|)
operator|&
literal|0x20
expr_stmt|;
comment|/* r_jmptable */
break|break;
case|case
name|RELOC_RELATIVE
case|:
comment|/* consider using this bit (together with r_baserel) for 		 * GOTOFFs, so ld can check 		 */
name|as_fatal
argument_list|(
literal|"relocation botch"
argument_list|)
expr_stmt|;
name|extra_bits
operator|=
operator|(
literal|1
operator|<<
literal|6
operator|)
operator|&
literal|0x40
expr_stmt|;
comment|/* r_relative */
break|break;
block|}
name|where
index|[
literal|6
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|16
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|5
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|8
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|4
index|]
operator|=
name|r_symbolnum
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|7
index|]
operator|=
operator|(
operator|(
operator|(
name|extrn_bit
operator|<<
literal|3
operator|)
operator|&
literal|0x08
operator|)
operator||
operator|(
operator|(
name|nbytes_r_length
index|[
name|fixP
operator|->
name|fx_size
index|]
operator|<<
literal|1
operator|)
operator|&
literal|0x06
operator|)
operator||
operator|(
operator|(
name|fixP
operator|->
name|fx_pcrel
operator|<<
literal|0
operator|)
operator|&
literal|0x01
operator|)
operator||
operator|(
name|extra_bits
operator|)
operator|)
expr_stmt|;
block|}
else|#
directive|else
name|where
index|[
literal|6
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|16
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|5
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|8
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|4
index|]
operator|=
name|r_symbolnum
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|7
index|]
operator|=
operator|(
operator|(
operator|(
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|)
operator|<<
literal|3
operator|)
operator|&
literal|0x08
operator|)
operator||
operator|(
operator|(
name|nbytes_r_length
index|[
name|fixP
operator|->
name|fx_size
index|]
operator|<<
literal|1
operator|)
operator|&
literal|0x06
operator|)
operator||
operator|(
operator|(
operator|(
name|fixP
operator|->
name|fx_pcrel
operator|<<
literal|0
operator|)
operator|&
literal|0x01
operator|)
operator|&
literal|0x0f
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/* tc_aout_fix_to_chars() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_AOUT or OBJ_BOUT */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_comment
comment|/* Turn the string pointed to by litP into a floating point constant of type    type, and emit the appropriate bytes.  The number of LITTLENUMS emitted    is stored in *sizeP. An error message is returned, or NULL on OK.    */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
name|prec
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
literal|"Bad call to md_atof ()"
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
comment|/* this loops outputs the LITTLENUMs in REVERSE order; in accord with 	   the bigendian 386 */
for|for
control|(
name|wordP
operator|=
name|words
operator|+
name|prec
operator|-
literal|1
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
name|wordP
operator|--
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
comment|/* Someone should teach Dean about null pointers */
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
name|char
name|output_invalid_buf
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|output_invalid
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|sprintf
argument_list|(
name|output_invalid_buf
argument_list|,
literal|"'%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|output_invalid_buf
argument_list|,
literal|"(0x%x)"
argument_list|,
operator|(
name|unsigned
operator|)
name|c
argument_list|)
expr_stmt|;
return|return
name|output_invalid_buf
return|;
block|}
end_function

begin_function
specifier|static
name|reg_entry
modifier|*
name|parse_register
parameter_list|(
name|reg_string
parameter_list|)
name|char
modifier|*
name|reg_string
decl_stmt|;
comment|/* reg_string starts *before* REGISTER_PREFIX */
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|reg_string
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|reg_name_given
index|[
name|MAX_REG_NAME_SIZE
index|]
decl_stmt|;
name|s
operator|++
expr_stmt|;
comment|/* skip REGISTER_PREFIX */
for|for
control|(
name|p
operator|=
name|reg_name_given
init|;
name|is_register_char
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|p
operator|++
operator|,
name|s
operator|++
control|)
block|{
operator|*
name|p
operator|=
name|register_chars
index|[
operator|*
name|s
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|reg_name_given
operator|+
name|MAX_REG_NAME_SIZE
condition|)
return|return
operator|(
name|reg_entry
operator|*
operator|)
literal|0
return|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|reg_entry
operator|*
operator|)
name|hash_find
argument_list|(
name|reg_hash
argument_list|,
name|reg_name_given
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* We have no need to default values of symbols.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|PIC
comment|/* HACK: 	 * Sun's ld expects __GLOBAL_OFFSET_TABLE_, 	 * gcc generates _GLOBAL_OFFSET_TABLE_ 	 * should probably fix ld - new SVR4 style?? 	 */
if|if
condition|(
operator|*
name|name
operator|==
literal|'_'
operator|&&
operator|*
operator|(
name|name
operator|+
literal|1
operator|)
operator|==
literal|'G'
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"_GLOBAL_OFFSET_TABLE_"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|symbol_find
argument_list|(
literal|"__GLOBAL_OFFSET_TABLE_"
argument_list|)
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Parse an operand that is machine-specific.    We just return without modifying the expression if we have nothing    to do.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|long
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
return|return
name|size
return|;
comment|/* Byte alignment is fine */
block|}
end_function

begin_comment
comment|/* Exactly what point is a PC-relative offset relative TO?    On the i386, they're relative to the address of the offset, plus    its size. (??? Is this right?  FIXME-SOON!) */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|PIC
comment|/* 	 * _GLOBAL_OFFSET_TABLE_ refs are relative to the offset of the 	 * current instruction. fx_pcrel_adjust has been setup to account 	 * for the number of opcode bytes preceding the fixup location, 	 * it is zero for eg. .long pseudo-ops. 	 */
if|if
condition|(
name|fixP
operator|->
name|fx_gotsy
condition|)
return|return
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|-
name|fixP
operator|->
name|fx_pcrel_adjust
return|;
else|else
endif|#
directive|endif
return|return
name|fixP
operator|->
name|fx_size
operator|+
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
return|;
block|}
end_function

begin_comment
comment|/* these were macros, but I don't trust macros that eval their     arguments more than once.  Besides, gcc can static inline them.     xoxorich.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|mode_from_disp_size
parameter_list|(
name|t
parameter_list|)
name|unsigned
name|long
name|t
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|t
operator|&
operator|(
name|Disp8
operator|)
operator|)
condition|?
literal|1
else|:
operator|(
operator|(
name|t
operator|&
operator|(
name|Disp32
operator|)
operator|)
condition|?
literal|2
else|:
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mode_from_disp_size() */
end_comment

begin_comment
comment|/* convert opcode suffix ('b' 'w' 'l' typically) into type specifyer */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|opcode_suffix_to_type
parameter_list|(
name|s
parameter_list|)
name|unsigned
name|long
name|s
decl_stmt|;
block|{
return|return
operator|(
name|s
operator|==
name|BYTE_OPCODE_SUFFIX
condition|?
name|Byte
else|:
operator|(
name|s
operator|==
name|WORD_OPCODE_SUFFIX
condition|?
name|Word
else|:
name|DWord
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* opcode_suffix_to_type() */
end_comment

begin_function
specifier|static
name|int
name|fits_in_signed_byte
parameter_list|(
name|num
parameter_list|)
name|long
name|num
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|num
operator|>=
operator|-
literal|128
operator|)
operator|&&
operator|(
name|num
operator|<=
literal|127
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* fits_in_signed_byte() */
end_comment

begin_function
specifier|static
name|int
name|fits_in_unsigned_byte
parameter_list|(
name|num
parameter_list|)
name|long
name|num
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|num
operator|&
literal|0xff
operator|)
operator|==
name|num
operator|)
return|;
block|}
end_function

begin_comment
comment|/* fits_in_unsigned_byte() */
end_comment

begin_function
specifier|static
name|int
name|fits_in_unsigned_word
parameter_list|(
name|num
parameter_list|)
name|long
name|num
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|num
operator|&
literal|0xffff
operator|)
operator|==
name|num
operator|)
return|;
block|}
end_function

begin_comment
comment|/* fits_in_unsigned_word() */
end_comment

begin_function
specifier|static
name|int
name|fits_in_signed_word
parameter_list|(
name|num
parameter_list|)
name|long
name|num
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|-
literal|32768
operator|<=
name|num
operator|)
operator|&&
operator|(
name|num
operator|<=
literal|32767
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* fits_in_signed_word() */
end_comment

begin_function
specifier|static
name|int
name|smallest_imm_type
parameter_list|(
name|num
parameter_list|)
name|long
name|num
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|num
operator|==
literal|1
operator|)
condition|?
operator|(
name|Imm1
operator||
name|Imm8
operator||
name|Imm8S
operator||
name|Imm16
operator||
name|Imm32
operator|)
else|:
operator|(
name|fits_in_signed_byte
argument_list|(
name|num
argument_list|)
condition|?
operator|(
name|Imm8S
operator||
name|Imm8
operator||
name|Imm16
operator||
name|Imm32
operator|)
else|:
operator|(
name|fits_in_unsigned_byte
argument_list|(
name|num
argument_list|)
condition|?
operator|(
name|Imm8
operator||
name|Imm16
operator||
name|Imm32
operator|)
else|:
operator|(
operator|(
name|fits_in_signed_word
argument_list|(
name|num
argument_list|)
operator|||
name|fits_in_unsigned_word
argument_list|(
name|num
argument_list|)
operator|)
condition|?
operator|(
name|Imm16
operator||
name|Imm32
operator|)
else|:
operator|(
name|Imm32
operator|)
operator|)
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* smallest_imm_type() */
end_comment

begin_function
specifier|static
name|void
name|s_bss
parameter_list|()
block|{
specifier|register
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_new
argument_list|(
name|SEG_BSS
argument_list|,
operator|(
name|subsegT
operator|)
name|temp
argument_list|)
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * comment-column: 0  * End:  */
end_comment

begin_comment
comment|/* end of tc-i386.c */
end_comment

end_unit

