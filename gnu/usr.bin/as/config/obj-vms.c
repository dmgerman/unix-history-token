begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* vms.c -- Write out a VAX/VMS object file    Copyright (C) 1987, 1988, 1992 Free Software Foundation, Inc.  This file is part of GAS, the GNU Assembler.  GAS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GAS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GAS; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Written by David L. Kashtan */
end_comment

begin_comment
comment|/* Modified by Eric Youngdale to write VMS debug records for program    variables */
end_comment

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"subsegs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* What we do if there is a goof. */
end_comment

begin_define
define|#
directive|define
name|error
value|as_fatal
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HO_VMS
end_ifdef

begin_comment
comment|/* These are of no use if we are cross assembling. */
end_comment

begin_include
include|#
directive|include
file|<fab.h>
end_include

begin_comment
comment|/* Define File Access Block	  */
end_comment

begin_include
include|#
directive|include
file|<nam.h>
end_include

begin_comment
comment|/* Define NAM Block		  */
end_comment

begin_include
include|#
directive|include
file|<xab.h>
end_include

begin_comment
comment|/* Define XAB - all different types*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *	Version string of the compiler that produced the code we are  *	assembling.  (And this assembler, if we do not have compiler info.)  */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|char
name|version_string
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|compiler_version_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag that determines how we map names.  This takes several values, and  * is set with the -h switch.  A value of zero implies names should be  * upper case, and the presence of the -h switch inhibits the case hack.  * No -h switch at all sets vms_name_mapping to 0, and allows case hacking.  * A value of 2 (set with -h2) implies names should be  * all lower case, with no case hack.  A value of 3 (set with -h3) implies  * that case should be preserved.  */
end_comment

begin_comment
comment|/* If the -+ switch is given, then the hash is appended to any name that is  * longer than 31 characters, irregardless of the setting of the -h switch.  */
end_comment

begin_decl_stmt
name|char
name|vms_name_mapping
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|strchr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|myname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|Entry_Point_Symbol
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to "_main" */
end_comment

begin_comment
comment|/*  *	We augment the "gas" symbol structure with this  */
end_comment

begin_struct
struct|struct
name|VMS_Symbol
block|{
name|struct
name|VMS_Symbol
modifier|*
name|Next
decl_stmt|;
name|struct
name|symbol
modifier|*
name|Symbol
decl_stmt|;
name|int
name|Size
decl_stmt|;
name|int
name|Psect_Index
decl_stmt|;
name|int
name|Psect_Offset
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|VMS_Symbol
modifier|*
name|VMS_Symbols
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We need this to keep track of the various input files, so that we can  * give the debugger the correct source line.  */
end_comment

begin_struct
struct|struct
name|input_file
block|{
name|struct
name|input_file
modifier|*
name|next
decl_stmt|;
name|struct
name|input_file
modifier|*
name|same_file_fpnt
decl_stmt|;
name|int
name|file_number
decl_stmt|;
name|int
name|max_line
decl_stmt|;
name|int
name|min_line
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|char
name|flag
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|symbolS
modifier|*
name|spnt
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|input_file
modifier|*
name|file_root
init|=
operator|(
expr|struct
name|input_file
operator|*
operator|)
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|input_file
modifier|*
name|find_file
parameter_list|(
name|symbolS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * This enum is used to keep track of the various types of variables that  * may be present.  */
end_comment

begin_enum
enum|enum
name|advanced_type
block|{
name|BASIC
block|,
name|POINTER
block|,
name|ARRAY
block|,
name|ENUM
block|,
name|STRUCT
block|,
name|UNION
block|,
name|FUNCTION
block|,
name|VOID
block|,
name|UNKNOWN
block|}
enum|;
end_enum

begin_comment
comment|/*  * This structure contains the information from the stabs directives, and the  * information is filled in by VMS_typedef_parse.  Everything that is needed  * to generate the debugging record for a given symbol is present here.  * This could be done more efficiently, using nested struct/unions, but for now  * I am happy that it works.  */
end_comment

begin_struct
struct|struct
name|VMS_DBG_Symbol
block|{
name|struct
name|VMS_DBG_Symbol
modifier|*
name|next
decl_stmt|;
name|enum
name|advanced_type
name|advanced
decl_stmt|;
comment|/* description of what this is */
name|int
name|dbx_type
decl_stmt|;
comment|/* this record is for this type */
name|int
name|type2
decl_stmt|;
comment|/* For advanced types this is the type referred to. 					i.e. the type a pointer points to, or the type 					of object that makes up an array */
name|int
name|VMS_type
decl_stmt|;
comment|/* Use this type when generating a variable def */
name|int
name|index_min
decl_stmt|;
comment|/* used for arrays - this will be present for all */
name|int
name|index_max
decl_stmt|;
comment|/* entries, but will be meaningless for non-arrays */
name|int
name|data_size
decl_stmt|;
comment|/* size in bytes of the data type.  For an array, this 				   is the size of one element in the array */
name|int
name|struc_numb
decl_stmt|;
comment|/* Number of the structure/union/enum - used for ref */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|VMS_DBG_Symbol
modifier|*
name|VMS_Symbol_type_list
init|=
block|{
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We need this structure to keep track of forward references to  * struct/union/enum that have not been defined yet.  When they are ultimately  * defined, then we can go back and generate the TIR commands to make a back  * reference.  */
end_comment

begin_struct
struct|struct
name|forward_ref
block|{
name|struct
name|forward_ref
modifier|*
name|next
decl_stmt|;
name|int
name|dbx_type
decl_stmt|;
name|int
name|struc_numb
decl_stmt|;
name|char
name|resolved
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|forward_ref
modifier|*
name|f_ref_root
init|=
block|{
operator|(
expr|struct
name|forward_ref
operator|*
operator|)
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This routine is used to compare the names of certain types to various  * fixed types that are known by the debugger.  */
end_comment

begin_define
define|#
directive|define
name|type_check
parameter_list|(
name|x
parameter_list|)
value|!strcmp( symbol_name , x )
end_define

begin_comment
comment|/*  * This variable is used to keep track of the name of the symbol we are  * working on while we are parsing the stabs directives.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|symbol_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We use this counter to assign numbers to all of the structures, unions  * and enums that we define.  When we actually declare a variable to the  * debugger, we can simply do it by number, rather than describing the  * whole thing each time.  */
end_comment

begin_expr_stmt
specifier|static
name|structure_count
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This variable is used to keep track of the current structure number  * for a given variable.  If this is< 0, that means that the structure  * has not yet been defined to the debugger.  This is still cool, since  * the VMS object language has ways of fixing things up after the fact,  * so we just make a note of this, and generate fixups at the end.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|struct_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Variable descriptors are used tell the debugger the data types of certain  * more complicated variables (basically anything involving a structure,  * union, enum, array or pointer).  Some non-pointer variables of the  * basic types that the debugger knows about do not require a variable  * descriptor.  *  * Since it is impossible to have a variable descriptor longer than 128  * bytes by virtue of the way that the VMS object language is set up,  * it makes not sense to make the arrays any longer than this, or worrying  * about dynamic sizing of the array.  *  * These are the arrays and counters that we use to build a variable  * descriptor.  */
end_comment

begin_define
define|#
directive|define
name|MAX_DEBUG_RECORD
value|128
end_define

begin_decl_stmt
specifier|static
name|char
name|Local
index|[
name|MAX_DEBUG_RECORD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for variable descriptor */
end_comment

begin_decl_stmt
specifier|static
name|char
name|Asuffix
index|[
name|MAX_DEBUG_RECORD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for array descriptor */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Lpnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index into Local */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Apoint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index into Asuffix */
end_comment

begin_decl_stmt
specifier|static
name|char
name|overflow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag to indicate we have written too much*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|total_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to calculate the total length of variable 				descriptor plus array descriptor - used for len byte*/
end_comment

begin_comment
comment|/* Flag if we have told user about finding global constants in the text    section. */
end_comment

begin_expr_stmt
specifier|static
name|gave_compiler_message
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* A pointer to the current routine that we are working on.  */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|Current_Routine
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The psect number for $code a.k.a. the text section. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Text_Psect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Global data (Object records limited to 512 bytes by VAX-11 "C" runtime)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|VMS_Object_File_FD
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File Descriptor for object file */
end_comment

begin_decl_stmt
specifier|static
name|char
name|Object_Record_Buffer
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for object file records  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Object_Record_Offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offset to end of data	   */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Current_Object_Record_Type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type of record in above	   */
end_comment

begin_comment
comment|/*  *	Macros for placing data into the object record buffer  */
end_comment

begin_define
define|#
directive|define
name|PUT_LONG
parameter_list|(
name|val
parameter_list|)
define|\
value|{ md_number_to_chars(Object_Record_Buffer + \ 		     Object_Record_Offset, val, 4); \ 			 Object_Record_Offset += 4; }
end_define

begin_define
define|#
directive|define
name|PUT_SHORT
parameter_list|(
name|val
parameter_list|)
define|\
value|{ md_number_to_chars(Object_Record_Buffer + \ 		     Object_Record_Offset, val, 2); \ 			 Object_Record_Offset += 2; }
end_define

begin_define
define|#
directive|define
name|PUT_CHAR
parameter_list|(
name|val
parameter_list|)
value|Object_Record_Buffer[Object_Record_Offset++] = val
end_define

begin_define
define|#
directive|define
name|PUT_COUNTED_STRING
parameter_list|(
name|cp
parameter_list|)
value|{\ 			register char *p = cp; \ 			PUT_CHAR(strlen(p)); \ 			while (*p) PUT_CHAR(*p++);}
end_define

begin_comment
comment|/*  *	Macro for determining if a Name has psect attributes attached  *	to it.  */
end_comment

begin_define
define|#
directive|define
name|PSECT_ATTRIBUTES_STRING
value|"$$PsectAttributes_"
end_define

begin_define
define|#
directive|define
name|PSECT_ATTRIBUTES_STRING_LENGTH
value|18
end_define

begin_define
define|#
directive|define
name|HAS_PSECT_ATTRIBUTES
parameter_list|(
name|Name
parameter_list|)
define|\
value|(strncmp((Name[0] == '_' ? Name + 1 : Name), \ 		 PSECT_ATTRIBUTES_STRING, \ 		 PSECT_ATTRIBUTES_STRING_LENGTH) == 0)
end_define

begin_escape
end_escape

begin_comment
comment|/* in: segT   out: N_TYPE bits */
end_comment

begin_decl_stmt
specifier|const
name|short
name|seg_N_TYPE
index|[]
init|=
block|{
name|N_ABS
block|,
name|N_TEXT
block|,
name|N_DATA
block|,
name|N_BSS
block|,
name|N_UNDF
block|,
comment|/* unknown */
name|N_UNDF
block|,
comment|/* absent */
name|N_UNDF
block|,
comment|/* pass1 */
name|N_UNDF
block|,
comment|/* error */
name|N_UNDF
block|,
comment|/* bignum/flonum */
name|N_UNDF
block|,
comment|/* difference */
name|N_UNDF
block|,
comment|/* debug */
name|N_UNDF
block|,
comment|/* ntv */
name|N_UNDF
block|,
comment|/* ptv */
name|N_REGISTER
block|,
comment|/* register */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|segT
name|N_TYPE_seg
index|[
name|N_TYPE
operator|+
literal|2
index|]
init|=
block|{
comment|/* N_TYPE == 0x1E = 32-2 */
name|SEG_UNKNOWN
block|,
comment|/* N_UNDF == 0 */
name|SEG_GOOF
block|,
name|SEG_ABSOLUTE
block|,
comment|/* N_ABS == 2 */
name|SEG_GOOF
block|,
name|SEG_TEXT
block|,
comment|/* N_TEXT == 4 */
name|SEG_GOOF
block|,
name|SEG_DATA
block|,
comment|/* N_DATA == 6 */
name|SEG_GOOF
block|,
name|SEG_BSS
block|,
comment|/* N_BSS == 8 */
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_GOOF
block|,
name|SEG_REGISTER
block|,
comment|/* dummy N_REGISTER for regs = 30 */
name|SEG_GOOF
block|, }
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The following code defines the special types of pseudo-ops that we  *  use with VMS.  */
end_comment

begin_decl_stmt
name|char
name|const_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|s_const
parameter_list|()
block|{
specifier|register
name|int
name|temp
decl_stmt|;
name|temp
operator|=
name|get_absolute_expression
argument_list|()
expr_stmt|;
name|subseg_new
argument_list|(
name|SEG_DATA
argument_list|,
operator|(
name|subsegT
operator|)
name|temp
argument_list|)
expr_stmt|;
name|const_flag
operator|=
literal|1
expr_stmt|;
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *			stab()  *  * Handle .stabX directives, which used to be open-coded.  * So much creeping featurism overloaded the semantics that we decided  * to put all .stabX thinking in one place. Here.  *  * We try to make any .stabX directive legal. Other people's AS will often  * do assembly-time consistency checks: eg assigning meaning to n_type bits  * and "protecting" you from setting them to certain values. (They also zero  * certain bits before emitting symbols. Tut tut.)  *  * If an expression is not absolute we either gripe or use the relocation  * information. Other people's assemblers silently forget information they  * don't need and invent information they need that you didn't supply.  *  * .stabX directives always make a symbol table entry. It may be junk if  * the rest of your .stabX directive is malformed.  */
end_comment

begin_function
specifier|static
name|void
name|obj_aout_stab
parameter_list|(
name|what
parameter_list|)
name|int
name|what
decl_stmt|;
block|{
specifier|register
name|symbolS
modifier|*
name|symbolP
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|saved_type
init|=
literal|0
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|goof
decl_stmt|;
comment|/* TRUE if we have aborted. */
name|long
name|longint
decl_stmt|;
comment|/*  * Enter with input_line_pointer pointing past .stabX and any following  * whitespace.  */
name|goof
operator|=
literal|0
expr_stmt|;
comment|/* JF who forgot this?? */
if|if
condition|(
name|what
operator|==
literal|'s'
condition|)
block|{
name|string
operator|=
name|demand_copy_C_string
argument_list|(
operator|&
name|length
argument_list|)
expr_stmt|;
name|SKIP_WHITESPACE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|input_line_pointer
operator|==
literal|','
condition|)
name|input_line_pointer
operator|++
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
literal|"I need a comma after symbol's name"
argument_list|)
expr_stmt|;
name|goof
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|string
operator|=
literal|""
expr_stmt|;
comment|/*  * Input_line_pointer->after ','.  String->symbol name.  */
if|if
condition|(
operator|!
name|goof
condition|)
block|{
name|symbolP
operator|=
name|symbol_new
argument_list|(
name|string
argument_list|,
name|SEG_UNKNOWN
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|frag
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
literal|'d'
case|:
name|S_SET_NAME
argument_list|(
name|symbolP
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* .stabd feature. */
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|obstack_next_free
argument_list|(
operator|&
name|frags
argument_list|)
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
name|frag_now
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|symbolP
operator|->
name|sy_frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|symbolP
operator|->
name|sy_frag
operator|=
operator|&
name|zero_address_frag
expr_stmt|;
break|break;
default|default:
name|BAD_CASE
argument_list|(
name|what
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|longint
argument_list|)
operator|==
literal|','
condition|)
name|symbolP
operator|->
name|sy_symbol
operator|.
name|n_type
operator|=
name|saved_type
operator|=
name|longint
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
literal|"I want a comma after the n_type expression"
argument_list|)
expr_stmt|;
name|goof
operator|=
literal|1
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Backup over a non-',' char. */
block|}
block|}
if|if
condition|(
operator|!
name|goof
condition|)
block|{
if|if
condition|(
name|get_absolute_expression_and_terminator
argument_list|(
operator|&
name|longint
argument_list|)
operator|==
literal|','
condition|)
name|S_SET_OTHER
argument_list|(
name|symbolP
argument_list|,
name|longint
argument_list|)
expr_stmt|;
else|else
block|{
name|as_bad
argument_list|(
literal|"I want a comma after the n_other expression"
argument_list|)
expr_stmt|;
name|goof
operator|=
literal|1
expr_stmt|;
name|input_line_pointer
operator|--
expr_stmt|;
comment|/* Backup over a non-',' char. */
block|}
block|}
if|if
condition|(
operator|!
name|goof
condition|)
block|{
name|S_SET_DESC
argument_list|(
name|symbolP
argument_list|,
name|get_absolute_expression
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|==
literal|'s'
operator|||
name|what
operator|==
literal|'n'
condition|)
block|{
if|if
condition|(
operator|*
name|input_line_pointer
operator|!=
literal|','
condition|)
block|{
name|as_bad
argument_list|(
literal|"I want a comma after the n_desc expression"
argument_list|)
expr_stmt|;
name|goof
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|input_line_pointer
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
operator|!
name|goof
operator|)
operator|&&
operator|(
name|what
operator|==
literal|'s'
operator|||
name|what
operator|==
literal|'n'
operator|)
condition|)
block|{
name|pseudo_set
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_symbol
operator|.
name|n_type
operator|=
name|saved_type
expr_stmt|;
block|}
if|if
condition|(
name|goof
condition|)
name|ignore_rest_of_line
argument_list|()
expr_stmt|;
else|else
name|demand_empty_rest_of_line
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* obj_aout_stab() */
end_comment

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|obj_pseudo_table
index|[]
init|=
block|{
block|{
literal|"stabd"
block|,
name|obj_aout_stab
block|,
literal|'d'
block|}
block|,
comment|/* stabs */
block|{
literal|"stabn"
block|,
name|obj_aout_stab
block|,
literal|'n'
block|}
block|,
comment|/* stabs */
block|{
literal|"stabs"
block|,
name|obj_aout_stab
block|,
literal|'s'
block|}
block|,
comment|/* stabs */
block|{
literal|"const"
block|,
name|s_const
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,  }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* obj_pseudo_table */
end_comment

begin_function
name|void
name|obj_read_begin_hook
parameter_list|()
block|{
return|return;
block|}
end_function

begin_comment
comment|/* obj_read_begin_hook() */
end_comment

begin_function
name|void
name|obj_crawl_symbol_chain
parameter_list|(
name|headers
parameter_list|)
name|object_headers
modifier|*
name|headers
decl_stmt|;
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|symbolS
modifier|*
modifier|*
name|symbolPP
decl_stmt|;
name|int
name|symbol_number
init|=
literal|0
decl_stmt|;
comment|/* JF deal with forward references first... */
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
if|if
condition|(
name|symbolP
operator|->
name|sy_forward
condition|)
block|{
name|S_SET_VALUE
argument_list|(
name|symbolP
argument_list|,
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|+
name|S_GET_VALUE
argument_list|(
name|symbolP
operator|->
name|sy_forward
argument_list|)
operator|+
name|symbolP
operator|->
name|sy_forward
operator|->
name|sy_frag
operator|->
name|fr_address
argument_list|)
expr_stmt|;
name|symbolP
operator|->
name|sy_forward
operator|=
literal|0
expr_stmt|;
block|}
comment|/* if it has a forward reference */
block|}
comment|/* walk the symbol chain */
block|{
comment|/* crawl symbol table */
specifier|register
name|int
name|symbol_number
init|=
literal|0
decl_stmt|;
block|{
name|symbolPP
operator|=
operator|&
name|symbol_rootP
expr_stmt|;
comment|/* -> last symbol chain link. */
while|while
condition|(
operator|(
name|symbolP
operator|=
operator|*
name|symbolPP
operator|)
operator|!=
name|NULL
condition|)
block|{
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|+=
name|symbolP
operator|->
name|sy_frag
operator|->
name|fr_address
expr_stmt|;
comment|/* OK, here is how we decide which symbols go out into the 	     brave new symtab.  Symbols that do are:  	     * symbols with no name (stabd's?) 	     * symbols with debug info in their N_TYPE  	     Symbols that don't are: 	     * symbols that are registers 	     * symbols with \1 as their 3rd character (numeric labels) 	     * "local labels" as defined by S_LOCAL_NAME(name) 	     if the -L switch was passed to gas.  	     All other symbols are output.  We complain if a deleted 	     symbol was marked external.  */
if|if
condition|(
operator|!
name|S_IS_REGISTER
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|symbolP
operator|->
name|sy_name_offset
operator|=
literal|0
expr_stmt|;
name|symbolPP
operator|=
operator|&
operator|(
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
operator|||
operator|!
name|S_IS_DEFINED
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
name|as_bad
argument_list|(
literal|"Local symbol %s never defined"
argument_list|,
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* oops. */
block|}
comment|/* if this symbol should be in the output */
block|}
comment|/* for each symbol */
block|}
name|H_SET_STRING_SIZE
argument_list|(
name|headers
argument_list|,
name|string_byte_count
argument_list|)
expr_stmt|;
name|H_SET_SYMBOL_TABLE_SIZE
argument_list|(
name|headers
argument_list|,
name|symbol_number
argument_list|)
expr_stmt|;
block|}
comment|/* crawl symbol table */
block|}
end_function

begin_comment
comment|/* obj_crawl_symbol_chain() */
end_comment

begin_escape
end_escape

begin_comment
comment|/****** VMS OBJECT FILE HACKING ROUTINES *******/
end_comment

begin_comment
comment|/*  *	Create the VMS object file  */
end_comment

begin_expr_stmt
specifier|static
name|Create_VMS_Object_File
argument_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|eunice
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|HO_VMS
argument_list|)
name|VMS_Object_File_FD
operator|=
name|creat
argument_list|(
name|out_file_name
argument_list|,
literal|0777
argument_list|,
literal|"var"
argument_list|)
block|;
else|#
directive|else
comment|/* eunice */
name|VMS_Object_File_FD
operator|=
name|creat
argument_list|(
name|out_file_name
argument_list|,
literal|0
argument_list|,
literal|"rfm=var"
argument_list|,
literal|"mbc=16"
argument_list|,
literal|"deq=64"
argument_list|,
literal|"fop=tef"
argument_list|,
literal|"shr=nil"
argument_list|)
block|;
endif|#
directive|endif
comment|/* eunice */
comment|/*    *	Deal with errors    */
if|if
condition|(
name|VMS_Object_File_FD
operator|<
literal|0
condition|)
block|{
name|char
name|Error_Line
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|Error_Line
argument_list|,
literal|"Couldn't create VMS object file \"%s\""
argument_list|,
name|out_file_name
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|Error_Line
argument_list|)
expr_stmt|;
block|}
comment|/*    *	Initialize object file hacking variables    */
name|Object_Record_Offset
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Current_Object_Record_Type
operator|=
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_escape
unit|}
end_escape

begin_comment
comment|/*  *	Flush the object record buffer to the object file  */
end_comment

begin_macro
unit|static
name|Flush_VMS_Object_Record_Buffer
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|short
name|int
name|zero
decl_stmt|;
comment|/*    *	If the buffer is empty, we are done    */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
return|return;
comment|/*    *	Write the data to the file    */
ifndef|#
directive|ifndef
name|HO_VMS
comment|/* For cross-assembly purposes. */
name|i
operator|=
name|write
argument_list|(
name|VMS_Object_File_FD
argument_list|,
operator|&
name|Object_Record_Offset
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HO_VMS */
name|i
operator|=
name|write
argument_list|(
name|VMS_Object_File_FD
argument_list|,
name|Object_Record_Buffer
argument_list|,
name|Object_Record_Offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|Object_Record_Offset
condition|)
name|error
argument_list|(
literal|"I/O error writing VMS object file"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HO_VMS
comment|/* When cross-assembling, we need to pad the record to an even 						number of bytes. */
comment|/* pad it if needed */
name|zero
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Object_Record_Offset
operator|&
literal|1
operator|!=
literal|0
condition|)
name|write
argument_list|(
name|VMS_Object_File_FD
argument_list|,
operator|&
name|zero
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not HO_VMS */
comment|/*    *	The buffer is now empty    */
name|Object_Record_Offset
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Declare a particular type of object file record  */
end_comment

begin_expr_stmt
specifier|static
name|Set_VMS_Object_File_Record
argument_list|(
argument|Type
argument_list|)
name|int
name|Type
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/*    *	If the type matches, we are done    */
if|if
condition|(
name|Type
operator|==
name|Current_Object_Record_Type
condition|)
return|return;
comment|/*    *	Otherwise: flush the buffer    */
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
comment|/*    *	Set the new type    */
name|Current_Object_Record_Type
operator|=
name|Type
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Close the VMS Object file  */
end_comment

begin_expr_stmt
specifier|static
name|Close_VMS_Object_File
argument_list|()
block|{
name|short
name|int
name|m_one
operator|=
operator|-
literal|1
block|;
ifndef|#
directive|ifndef
name|HO_VMS
comment|/* For cross-assembly purposes. */
comment|/* Write a 0xffff into the file, which means "End of File" */
name|write
argument_list|(
name|VMS_Object_File_FD
argument_list|,
operator|&
name|m_one
argument_list|,
literal|2
argument_list|)
block|;
endif|#
directive|endif
comment|/* not HO_VMS */
name|close
argument_list|(
name|VMS_Object_File_FD
argument_list|)
block|; }
comment|/*  *	Store immediate data in current Psect  */
specifier|static
name|VMS_Store_Immediate_Data
argument_list|(
name|Pointer
argument_list|,
name|Size
argument_list|,
name|Record_Type
argument_list|)
specifier|register
name|char
operator|*
name|Pointer
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|Size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Record_Type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/*    *	We are writing a "Record_Type" record    */
name|Set_VMS_Object_File_Record
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/*    *	We can only store 128 bytes at a time    */
while|while
condition|(
name|Size
operator|>
literal|0
condition|)
block|{
comment|/*        *	Store a maximum of 128 bytes        */
name|i
operator|=
operator|(
name|Size
operator|>
literal|128
operator|)
condition|?
literal|128
else|:
name|Size
expr_stmt|;
name|Size
operator|-=
name|i
expr_stmt|;
comment|/*        *	If we cannot accommodate this record, flush the        *	buffer.        */
if|if
condition|(
operator|(
name|Object_Record_Offset
operator|+
name|i
operator|+
literal|1
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
comment|/*        *	If the buffer is empty we must insert record type        */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/*        *	Store the count        */
name|PUT_CHAR
argument_list|(
operator|-
name|i
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/*        *	Store the data        */
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|PUT_CHAR
argument_list|(
operator|*
name|Pointer
operator|++
argument_list|)
expr_stmt|;
comment|/*        *	Flush the buffer if it is more than 75% full        */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  *	Make a data reference  */
end_comment

begin_expr_stmt
specifier|static
name|VMS_Set_Data
argument_list|(
argument|Psect_Index
argument_list|,
argument|Offset
argument_list|,
argument|Record_Type
argument_list|,
argument|Force
argument_list|)
name|int
name|Psect_Index
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|Offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Record_Type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Force
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/*    *	We are writing a "Record_Type" record    */
name|Set_VMS_Object_File_Record
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/*    *	If the buffer is empty we must insert the record type    */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/*    *	Stack the Psect base + Longword Offset    */
if|if
condition|(
name|Force
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|Psect_Index
operator|>
literal|127
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_WPL
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Psect_Index
argument_list|)
expr_stmt|;
name|PUT_LONG
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_PL
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|Psect_Index
argument_list|)
expr_stmt|;
name|PUT_LONG
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|Offset
operator|>
literal|32767
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_WPL
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Psect_Index
argument_list|)
expr_stmt|;
name|PUT_LONG
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Offset
operator|>
literal|127
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_WPW
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Psect_Index
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_WPB
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Psect_Index
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/*    *	Set relocation base    */
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STO_PIDR
argument_list|)
expr_stmt|;
comment|/*    *	Flush the buffer if it is more than 75% full    */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	Make a debugger reference to a struct, union or enum.  */
end_comment

begin_expr_stmt
specifier|static
name|VMS_Store_Struct
argument_list|(
argument|int Struct_Index
argument_list|)
block|{
comment|/*    *	We are writing a "OBJ_S_C_DBG" record    */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ_S_C_DBG
argument_list|)
block|;
comment|/*    *	If the buffer is empty we must insert the record type    */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_UW
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PUT_SHORT
argument_list|(
name|Struct_Index
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PUT_CHAR
argument_list|(
name|TIR_S_C_CTL_STKDL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STO_L
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*    *	Flush the buffer if it is more than 75% full    */
end_comment

begin_if
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
end_if

begin_comment
unit|}
comment|/*  *	Make a debugger reference to partially define a struct, union or enum.  */
end_comment

begin_macro
unit|static
name|VMS_Def_Struct
argument_list|(
argument|int Struct_Index
argument_list|)
end_macro

begin_block
block|{
comment|/*    *	We are writing a "OBJ_S_C_DBG" record    */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
comment|/*    *	If the buffer is empty we must insert the record type    */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_UW
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Struct_Index
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|TIR_S_C_CTL_DFLOC
argument_list|)
expr_stmt|;
comment|/*    *	Flush the buffer if it is more than 75% full    */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|VMS_Set_Struct
argument_list|(
argument|int Struct_Index
argument_list|)
block|{
comment|/* see previous functions for comments */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ_S_C_DBG
argument_list|)
block|;
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_UW
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PUT_SHORT
argument_list|(
name|Struct_Index
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PUT_CHAR
argument_list|(
name|TIR_S_C_CTL_STLOC
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
end_if

begin_escape
unit|}
end_escape

begin_comment
comment|/*  *	Write the Traceback Module Begin record  */
end_comment

begin_macro
unit|static
name|VMS_TBT_Module_Begin
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
name|int
name|Size
decl_stmt|;
name|char
name|Module_Name
index|[
literal|256
index|]
decl_stmt|;
name|char
name|Local
index|[
literal|256
index|]
decl_stmt|;
comment|/*    *	Get module name (the FILENAME part of the object file)    */
name|cp
operator|=
name|out_file_name
expr_stmt|;
name|cp1
operator|=
name|Module_Name
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|']'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'>'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|':'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'/'
operator|)
condition|)
block|{
name|cp1
operator|=
name|Module_Name
expr_stmt|;
name|cp
operator|++
expr_stmt|;
continue|continue;
block|}
operator|*
name|cp1
operator|++
operator|=
name|islower
argument_list|(
operator|*
name|cp
argument_list|)
condition|?
name|toupper
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
else|:
operator|*
name|cp
operator|++
expr_stmt|;
block|}
operator|*
name|cp1
operator|=
literal|0
expr_stmt|;
comment|/*    *	Limit it to 31 characters    */
while|while
condition|(
operator|--
name|cp1
operator|>=
name|Module_Name
condition|)
if|if
condition|(
operator|*
name|cp1
operator|==
literal|'.'
condition|)
operator|*
name|cp1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|Module_Name
argument_list|)
operator|>
literal|31
condition|)
block|{
if|if
condition|(
name|flagseen
index|[
literal|'+'
index|]
condition|)
name|printf
argument_list|(
literal|"%s: Module name truncated: %s\n"
argument_list|,
name|myname
argument_list|,
name|Module_Name
argument_list|)
expr_stmt|;
name|Module_Name
index|[
literal|31
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/*    *	Arrange to store the data locally (leave room for size byte)    */
name|cp
operator|=
name|Local
operator|+
literal|1
expr_stmt|;
comment|/*    *	Begin module    */
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_MODBEG
expr_stmt|;
comment|/*    *	Unused    */
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/*    *	Language type == "C"    */
operator|*
operator|(
name|long
operator|*
operator|)
name|cp
operator|=
name|DST_S_C_C
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
comment|/*    *	Store the module name    */
operator|*
name|cp
operator|++
operator|=
name|strlen
argument_list|(
name|Module_Name
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|Module_Name
expr_stmt|;
while|while
condition|(
operator|*
name|cp1
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
comment|/*    *	Now we can store the record size    */
name|Size
operator|=
operator|(
name|cp
operator|-
name|Local
operator|)
expr_stmt|;
name|Local
index|[
literal|0
index|]
operator|=
name|Size
operator|-
literal|1
expr_stmt|;
comment|/*    *	Put it into the object record    */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|Size
argument_list|,
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Write the Traceback Module End record */
end_comment

begin_expr_stmt
specifier|static
name|VMS_TBT_Module_End
argument_list|()
block|{
name|char
name|Local
index|[
literal|2
index|]
block|;
comment|/*    *	End module    */
name|Local
index|[
literal|0
index|]
operator|=
literal|1
block|;
name|Local
index|[
literal|1
index|]
operator|=
name|DST_S_C_MODEND
block|;
comment|/*    *	Put it into the object record    */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
literal|2
argument_list|,
name|OBJ_S_C_TBT
argument_list|)
block|; }
comment|/*  *	Write the Traceback Routine Begin record  */
specifier|static
name|VMS_TBT_Routine_Begin
argument_list|(
argument|symbolP
argument_list|,
argument|Psect
argument_list|)
expr|struct
name|symbol
operator|*
name|symbolP
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|Psect
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
name|char
modifier|*
name|Name
decl_stmt|;
name|int
name|Offset
decl_stmt|;
name|int
name|Size
decl_stmt|;
name|char
name|Local
index|[
literal|512
index|]
decl_stmt|;
comment|/*    *	Strip the leading "_" from the name    */
name|Name
operator|=
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|Name
operator|==
literal|'_'
condition|)
name|Name
operator|++
expr_stmt|;
comment|/*    *	Get the text psect offset    */
name|Offset
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
comment|/*    *	Calculate the record size    */
name|Size
operator|=
literal|1
operator|+
literal|1
operator|+
literal|4
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|Name
argument_list|)
expr_stmt|;
comment|/*    *	Record Size    */
name|Local
index|[
literal|0
index|]
operator|=
name|Size
expr_stmt|;
comment|/*    *	Begin Routine    */
name|Local
index|[
literal|1
index|]
operator|=
name|DST_S_C_RTNBEG
expr_stmt|;
comment|/*    *	Uses CallS/CallG    */
name|Local
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/*    *	Store the data so far    */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
literal|3
argument_list|,
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
comment|/*    *	Make sure we are still generating a OBJ_S_C_TBT record    */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
comment|/*    *	Now get the symbol address    */
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_WPL
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Psect
argument_list|)
expr_stmt|;
name|PUT_LONG
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
comment|/*    *	Store the data reference    */
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STO_PIDR
argument_list|)
expr_stmt|;
comment|/*    *	Store the counted string as data    */
name|cp
operator|=
name|Local
expr_stmt|;
name|cp1
operator|=
name|Name
expr_stmt|;
name|Size
operator|=
name|strlen
argument_list|(
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|Size
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|cp1
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|Size
argument_list|,
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Write the Traceback Routine End record  * 	We *must* search the symbol table to find the next routine, since  * 	the assember has a way of reassembling the symbol table OUT OF ORDER  * 	Thus the next routine in the symbol list is not necessarily the  *	next one in memory.  For debugging to work correctly we must know the  *	size of the routine.  */
end_comment

begin_expr_stmt
specifier|static
name|VMS_TBT_Routine_End
argument_list|(
argument|Max_Size
argument_list|,
argument|sp
argument_list|)
name|int
name|Max_Size
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|sp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|int
name|Size
init|=
literal|0x7fffffff
decl_stmt|;
name|char
name|Local
index|[
literal|16
index|]
decl_stmt|;
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|S_IS_DEBUG
argument_list|(
name|symbolP
argument_list|)
operator|&&
name|S_GET_TYPE
argument_list|(
name|symbolP
argument_list|)
operator|==
name|N_TEXT
condition|)
block|{
if|if
condition|(
operator|*
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|'L'
condition|)
continue|continue;
if|if
condition|(
operator|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|>
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
operator|)
operator|&&
operator|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|<
name|Size
operator|)
condition|)
name|Size
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
comment|/* check if gcc_compiled. has size of zero */
if|if
condition|(
operator|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|==
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
operator|)
operator|&&
name|sp
operator|!=
name|symbolP
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|"gcc_compiled."
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|"gcc2_compiled."
argument_list|)
operator|)
condition|)
name|Size
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|Size
operator|==
literal|0x7fffffff
condition|)
name|Size
operator|=
name|Max_Size
expr_stmt|;
name|Size
operator|-=
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* and get the size of the routine */
comment|/*    *	Record Size    */
name|Local
index|[
literal|0
index|]
operator|=
literal|6
expr_stmt|;
comment|/*    *	End of Routine    */
name|Local
index|[
literal|1
index|]
operator|=
name|DST_S_C_RTNEND
expr_stmt|;
comment|/*    *	Unused    */
name|Local
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/*    *	Size of routine    */
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
operator|(
name|Local
operator|+
literal|3
operator|)
operator|)
operator|=
name|Size
expr_stmt|;
comment|/*    *	Store the record    */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
literal|7
argument_list|,
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  *	Write the Traceback Block End record  */
end_comment

begin_expr_stmt
specifier|static
name|VMS_TBT_Block_Begin
argument_list|(
argument|symbolP
argument_list|,
argument|Psect
argument_list|,
argument|Name
argument_list|)
expr|struct
name|symbol
operator|*
name|symbolP
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|Psect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
name|int
name|Offset
decl_stmt|;
name|int
name|Size
decl_stmt|;
name|char
name|Local
index|[
literal|512
index|]
decl_stmt|;
comment|/*    *	Begin block    */
name|Size
operator|=
literal|1
operator|+
literal|1
operator|+
literal|4
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|Name
argument_list|)
expr_stmt|;
comment|/*    *	Record Size    */
name|Local
index|[
literal|0
index|]
operator|=
name|Size
expr_stmt|;
comment|/*    *	Begin Block - We simulate with a phony routine    */
name|Local
index|[
literal|1
index|]
operator|=
name|DST_S_C_BLKBEG
expr_stmt|;
comment|/*    *	Uses CallS/CallG    */
name|Local
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/*    *	Store the data so far    */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
literal|3
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
comment|/*    *	Make sure we are still generating a OBJ_S_C_DBG record    */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
comment|/*    *	Now get the symbol address    */
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_WPL
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Psect
argument_list|)
expr_stmt|;
comment|/*    *	Get the text psect offset    */
name|Offset
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|PUT_LONG
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
comment|/*    *	Store the data reference    */
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STO_PIDR
argument_list|)
expr_stmt|;
comment|/*    *	Store the counted string as data    */
name|cp
operator|=
name|Local
expr_stmt|;
name|cp1
operator|=
name|Name
expr_stmt|;
name|Size
operator|=
name|strlen
argument_list|(
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|Size
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|cp1
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|Size
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Write the Traceback Block End record  */
end_comment

begin_expr_stmt
specifier|static
name|VMS_TBT_Block_End
argument_list|(
argument|int Size
argument_list|)
block|{
name|char
name|Local
index|[
literal|16
index|]
block|;
comment|/*    *	End block - simulate with a phony end routine    */
name|Local
index|[
literal|0
index|]
operator|=
literal|6
block|;
name|Local
index|[
literal|1
index|]
operator|=
name|DST_S_C_BLKEND
block|;
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
operator|(
name|Local
operator|+
literal|3
operator|)
operator|)
operator|=
name|Size
block|;
comment|/*    *	Unused    */
name|Local
index|[
literal|2
index|]
operator|=
literal|0
block|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
literal|7
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
block|; }
comment|/*  *	Write a Line number / PC correlation record  */
specifier|static
name|VMS_TBT_Line_PC_Correlation
argument_list|(
argument|Line_Number
argument_list|,
argument|Offset
argument_list|,
argument|Psect
argument_list|,
argument|Do_Delta
argument_list|)
name|int
name|Line_Number
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|Offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Psect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Do_Delta
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|Local
index|[
literal|64
index|]
decl_stmt|;
comment|/* *	If not delta, set our PC/Line number correlation */
if|if
condition|(
name|Do_Delta
operator|==
literal|0
condition|)
block|{
comment|/*        *	Size        */
name|Local
index|[
literal|0
index|]
operator|=
literal|1
operator|+
literal|1
operator|+
literal|2
operator|+
literal|1
operator|+
literal|4
expr_stmt|;
comment|/*        *	Line Number/PC correlation        */
name|Local
index|[
literal|1
index|]
operator|=
name|DST_S_C_LINE_NUM
expr_stmt|;
comment|/*        *	Set Line number        */
name|Local
index|[
literal|2
index|]
operator|=
name|DST_S_C_SET_LINE_NUM
expr_stmt|;
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|Local
operator|+
literal|3
operator|)
operator|)
operator|=
name|Line_Number
operator|-
literal|1
expr_stmt|;
comment|/*        *	Set PC        */
name|Local
index|[
literal|5
index|]
operator|=
name|DST_S_C_SET_ABS_PC
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
literal|6
argument_list|,
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
comment|/*        *	Make sure we are still generating a OBJ_S_C_TBT record        */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
if|if
condition|(
name|Psect
operator|<
literal|255
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_PL
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|Psect
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_WPL
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Psect
argument_list|)
expr_stmt|;
block|}
name|PUT_LONG
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STO_PIDR
argument_list|)
expr_stmt|;
comment|/*        *	Do a PC offset of 0 to register the line number        */
name|Local
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
name|Local
index|[
literal|1
index|]
operator|=
name|DST_S_C_LINE_NUM
expr_stmt|;
name|Local
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Increment PC by 0 and register line # */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
literal|3
argument_list|,
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*        *	If Delta is negative, terminate the line numbers        */
if|if
condition|(
name|Do_Delta
operator|<
literal|0
condition|)
block|{
name|Local
index|[
literal|0
index|]
operator|=
literal|1
operator|+
literal|1
operator|+
literal|4
expr_stmt|;
name|Local
index|[
literal|1
index|]
operator|=
name|DST_S_C_LINE_NUM
expr_stmt|;
name|Local
index|[
literal|2
index|]
operator|=
name|DST_S_C_TERM_L
expr_stmt|;
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
operator|(
name|Local
operator|+
literal|3
operator|)
operator|)
operator|=
name|Offset
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
literal|7
argument_list|,
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
comment|/* 	   *	Done 	   */
return|return;
block|}
comment|/*        *	Do a PC/Line delta        */
name|cp
operator|=
name|Local
operator|+
literal|1
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_LINE_NUM
expr_stmt|;
if|if
condition|(
name|Line_Number
operator|>
literal|1
condition|)
block|{
comment|/* 	   *	We need to increment the line number 	   */
if|if
condition|(
name|Line_Number
operator|-
literal|1
operator|<=
literal|255
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_INCR_LINUM
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|Line_Number
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_INCR_LINUM_W
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
name|cp
operator|=
name|Line_Number
operator|-
literal|1
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*        *	Increment the PC        */
if|if
condition|(
name|Offset
operator|<=
literal|128
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
operator|-
name|Offset
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Offset
operator|<
literal|0x10000
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_DELTA_PC_W
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
name|cp
operator|=
name|Offset
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_DELTA_PC_L
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|cp
operator|=
name|Offset
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
block|}
block|}
name|Local
index|[
literal|0
index|]
operator|=
name|cp
operator|-
operator|(
name|Local
operator|+
literal|1
operator|)
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|cp
operator|-
name|Local
argument_list|,
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Describe a source file to the debugger  */
end_comment

begin_expr_stmt
specifier|static
name|VMS_TBT_Source_File
argument_list|(
argument|Filename
argument_list|,
argument|ID_Number
argument_list|)
name|char
operator|*
name|Filename
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ID_Number
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
name|int
name|Status
decl_stmt|,
name|i
decl_stmt|;
name|char
name|Local
index|[
literal|512
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|HO_VMS
comment|/* Used for cross-assembly */
name|i
operator|=
name|strlen
argument_list|(
name|Filename
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* HO_VMS */
specifier|static
name|struct
name|FAB
name|Fab
decl_stmt|;
specifier|static
name|struct
name|NAM
name|Nam
decl_stmt|;
specifier|static
name|struct
name|XABDAT
name|Date_Xab
decl_stmt|;
specifier|static
name|struct
name|XABFHC
name|File_Header_Xab
decl_stmt|;
name|char
name|Es_String
index|[
literal|255
index|]
decl_stmt|,
name|Rs_String
index|[
literal|255
index|]
decl_stmt|;
comment|/*    *	Setup the Fab    */
name|Fab
operator|.
name|fab$b_bid
operator|=
name|FAB$C_BID
expr_stmt|;
name|Fab
operator|.
name|fab$b_bln
operator|=
sizeof|sizeof
argument_list|(
name|Fab
argument_list|)
expr_stmt|;
name|Fab
operator|.
name|fab$l_nam
operator|=
operator|(
operator|&
name|Nam
operator|)
expr_stmt|;
name|Fab
operator|.
name|fab$l_xab
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|Date_Xab
expr_stmt|;
comment|/*    *	Setup the Nam block so we can find out the FULL name    *	of the source file.    */
name|Nam
operator|.
name|nam$b_bid
operator|=
name|NAM$C_BID
expr_stmt|;
name|Nam
operator|.
name|nam$b_bln
operator|=
sizeof|sizeof
argument_list|(
name|Nam
argument_list|)
expr_stmt|;
name|Nam
operator|.
name|nam$l_rsa
operator|=
name|Rs_String
expr_stmt|;
name|Nam
operator|.
name|nam$b_rss
operator|=
sizeof|sizeof
argument_list|(
name|Rs_String
argument_list|)
expr_stmt|;
name|Nam
operator|.
name|nam$l_esa
operator|=
name|Es_String
expr_stmt|;
name|Nam
operator|.
name|nam$b_ess
operator|=
sizeof|sizeof
argument_list|(
name|Es_String
argument_list|)
expr_stmt|;
comment|/*    *	Setup the Date and File Header Xabs    */
name|Date_Xab
operator|.
name|xab$b_cod
operator|=
name|XAB$C_DAT
expr_stmt|;
name|Date_Xab
operator|.
name|xab$b_bln
operator|=
sizeof|sizeof
argument_list|(
name|Date_Xab
argument_list|)
expr_stmt|;
name|Date_Xab
operator|.
name|xab$l_nxt
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|File_Header_Xab
expr_stmt|;
name|File_Header_Xab
operator|.
name|xab$b_cod
operator|=
name|XAB$C_FHC
expr_stmt|;
name|File_Header_Xab
operator|.
name|xab$b_bln
operator|=
sizeof|sizeof
argument_list|(
name|File_Header_Xab
argument_list|)
expr_stmt|;
comment|/*    *	Get the file information    */
name|Fab
operator|.
name|fab$l_fna
operator|=
name|Filename
expr_stmt|;
name|Fab
operator|.
name|fab$b_fns
operator|=
name|strlen
argument_list|(
name|Filename
argument_list|)
expr_stmt|;
name|Status
operator|=
name|sys$open
argument_list|(
operator|&
name|Fab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|Status
operator|&
literal|1
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"gas: Couldn't find source file \"%s\", Error = %%X%x\n"
argument_list|,
name|Filename
argument_list|,
name|Status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sys$close
argument_list|(
operator|&
name|Fab
argument_list|)
expr_stmt|;
comment|/*    *	Calculate the size of the resultant string    */
name|i
operator|=
name|Nam
operator|.
name|nam$b_rsl
expr_stmt|;
endif|#
directive|endif
comment|/* HO_VMS */
comment|/*    *	Size of record    */
name|Local
index|[
literal|0
index|]
operator|=
literal|1
operator|+
literal|1
operator|+
literal|1
operator|+
literal|1
operator|+
literal|1
operator|+
literal|2
operator|+
literal|8
operator|+
literal|4
operator|+
literal|2
operator|+
literal|1
operator|+
literal|1
operator|+
name|i
operator|+
literal|1
expr_stmt|;
comment|/*    *	Source declaration    */
name|Local
index|[
literal|1
index|]
operator|=
name|DST_S_C_SOURCE
expr_stmt|;
comment|/*    *	Make formfeeds count as source records    */
name|Local
index|[
literal|2
index|]
operator|=
name|DST_S_C_SRC_FORMFEED
expr_stmt|;
comment|/*    *	Declare source file    */
name|Local
index|[
literal|3
index|]
operator|=
name|DST_S_C_SRC_DECLFILE
expr_stmt|;
name|Local
index|[
literal|4
index|]
operator|=
literal|1
operator|+
literal|2
operator|+
literal|8
operator|+
literal|4
operator|+
literal|2
operator|+
literal|1
operator|+
literal|1
operator|+
name|i
operator|+
literal|1
expr_stmt|;
name|cp
operator|=
name|Local
operator|+
literal|5
expr_stmt|;
comment|/*    *	Flags    */
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/*    *	File ID    */
operator|*
operator|(
name|short
operator|*
operator|)
name|cp
operator|=
name|ID_Number
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HO_VMS
comment|/*    *	Creation Date.  Unknown, so we fill with zeroes.    */
operator|*
operator|(
name|long
operator|*
operator|)
name|cp
operator|=
literal|0
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|cp
operator|=
literal|0
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
comment|/*    *	End of file block    */
operator|*
operator|(
name|long
operator|*
operator|)
name|cp
operator|=
literal|0
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
comment|/*    *	First free byte    */
operator|*
operator|(
name|short
operator|*
operator|)
name|cp
operator|=
literal|0
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
comment|/*    *	Record format    */
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/*    *	Filename    */
operator|*
name|cp
operator|++
operator|=
name|i
expr_stmt|;
name|cp1
operator|=
name|Filename
expr_stmt|;
else|#
directive|else
comment|/* Use this code when assembling for VMS on a VMS system */
comment|/*    *	Creation Date    */
operator|*
operator|(
name|long
operator|*
operator|)
name|cp
operator|=
operator|(
operator|(
name|long
operator|*
operator|)
operator|&
name|Date_Xab
operator|.
name|xab$q_cdt
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|cp
operator|=
operator|(
operator|(
name|long
operator|*
operator|)
operator|&
name|Date_Xab
operator|.
name|xab$q_cdt
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
comment|/*    *	End of file block    */
operator|*
operator|(
name|long
operator|*
operator|)
name|cp
operator|=
name|File_Header_Xab
operator|.
name|xab$l_ebk
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
comment|/*    *	First free byte    */
operator|*
operator|(
name|short
operator|*
operator|)
name|cp
operator|=
name|File_Header_Xab
operator|.
name|xab$w_ffb
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
comment|/*    *	Record format    */
operator|*
name|cp
operator|++
operator|=
name|File_Header_Xab
operator|.
name|xab$b_rfo
expr_stmt|;
comment|/*    *	Filename    */
operator|*
name|cp
operator|++
operator|=
name|i
expr_stmt|;
name|cp1
operator|=
name|Rs_String
expr_stmt|;
endif|#
directive|endif
comment|/* HO_VMS */
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
comment|/*    *	Library module name (none)    */
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/*    *	Done    */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|cp
operator|-
name|Local
argument_list|,
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Give the number of source lines to the debugger  */
end_comment

begin_expr_stmt
specifier|static
name|VMS_TBT_Source_Lines
argument_list|(
argument|ID_Number
argument_list|,
argument|Starting_Line_Number
argument_list|,
argument|Number_Of_Lines
argument_list|)
name|int
name|ID_Number
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|Starting_Line_Number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Number_Of_Lines
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
name|char
name|Local
index|[
literal|16
index|]
decl_stmt|;
comment|/*    *	Size of record    */
name|Local
index|[
literal|0
index|]
operator|=
literal|1
operator|+
literal|1
operator|+
literal|2
operator|+
literal|1
operator|+
literal|4
operator|+
literal|1
operator|+
literal|2
expr_stmt|;
comment|/*    *	Source declaration    */
name|Local
index|[
literal|1
index|]
operator|=
name|DST_S_C_SOURCE
expr_stmt|;
comment|/*    *	Set Source File    */
name|cp
operator|=
name|Local
operator|+
literal|2
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_SRC_SETFILE
expr_stmt|;
comment|/*    *	File ID Number    */
operator|*
operator|(
name|short
operator|*
operator|)
name|cp
operator|=
name|ID_Number
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
comment|/*    *	Set record number    */
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_SRC_SETREC_L
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|cp
operator|=
name|Starting_Line_Number
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
comment|/*    *	Define lines    */
operator|*
name|cp
operator|++
operator|=
name|DST_S_C_SRC_DEFLINES_W
expr_stmt|;
operator|*
operator|(
name|short
operator|*
operator|)
name|cp
operator|=
name|Number_Of_Lines
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
comment|/*    *	Done    */
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|cp
operator|-
name|Local
argument_list|,
name|OBJ_S_C_TBT
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This routine locates a file in the list of files.  If an entry does not  * exist, one is created.  For include files, a new entry is always created  * such that inline functions can be properly debugged. */
end_comment

begin_function
specifier|static
name|struct
name|input_file
modifier|*
name|find_file
parameter_list|(
name|sp
parameter_list|)
name|symbolS
modifier|*
name|sp
decl_stmt|;
block|{
name|struct
name|input_file
modifier|*
name|same_file
decl_stmt|;
name|struct
name|input_file
modifier|*
name|fpnt
decl_stmt|;
name|same_file
operator|=
operator|(
expr|struct
name|input_file
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|fpnt
operator|=
name|file_root
init|;
name|fpnt
condition|;
name|fpnt
operator|=
name|fpnt
operator|->
name|next
control|)
block|{
if|if
condition|(
name|fpnt
operator|==
operator|(
expr|struct
name|input_file
operator|*
operator|)
name|NULL
condition|)
break|break;
if|if
condition|(
name|fpnt
operator|->
name|spnt
operator|==
name|sp
condition|)
return|return
name|fpnt
return|;
block|}
empty_stmt|;
for|for
control|(
name|fpnt
operator|=
name|file_root
init|;
name|fpnt
condition|;
name|fpnt
operator|=
name|fpnt
operator|->
name|next
control|)
block|{
if|if
condition|(
name|fpnt
operator|==
operator|(
expr|struct
name|input_file
operator|*
operator|)
name|NULL
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
argument_list|,
name|fpnt
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fpnt
operator|->
name|flag
operator|==
literal|1
condition|)
return|return
name|fpnt
return|;
name|same_file
operator|=
name|fpnt
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
empty_stmt|;
name|fpnt
operator|=
operator|(
expr|struct
name|input_file
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|input_file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_root
operator|==
operator|(
expr|struct
name|input_file
operator|*
operator|)
name|NULL
condition|)
name|file_root
operator|=
name|fpnt
expr_stmt|;
else|else
block|{
name|struct
name|input_file
modifier|*
name|fpnt1
decl_stmt|;
for|for
control|(
name|fpnt1
operator|=
name|file_root
init|;
name|fpnt1
operator|->
name|next
condition|;
name|fpnt1
operator|=
name|fpnt1
operator|->
name|next
control|)
empty_stmt|;
name|fpnt1
operator|->
name|next
operator|=
name|fpnt
expr_stmt|;
block|}
empty_stmt|;
name|fpnt
operator|->
name|next
operator|=
operator|(
expr|struct
name|input_file
operator|*
operator|)
name|NULL
expr_stmt|;
name|fpnt
operator|->
name|name
operator|=
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|fpnt
operator|->
name|min_line
operator|=
literal|0x7fffffff
expr_stmt|;
name|fpnt
operator|->
name|max_line
operator|=
literal|0
expr_stmt|;
name|fpnt
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|fpnt
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
name|fpnt
operator|->
name|file_number
operator|=
literal|0
expr_stmt|;
name|fpnt
operator|->
name|spnt
operator|=
name|sp
expr_stmt|;
name|fpnt
operator|->
name|same_file_fpnt
operator|=
name|same_file
expr_stmt|;
return|return
name|fpnt
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * The following functions and definitions are used to generate object records  * that will describe program variables to the VMS debugger.  *  * This file contains many of the routines needed to output debugging info into  * the object file that the VMS debugger needs to understand symbols.  These  * routines are called very late in the assembly process, and thus we can be  * fairly lax about changing things, since the GSD and the TIR sections have  * already been output.  */
end_comment

begin_comment
comment|/* This routine converts a number string into an integer, and stops when it  * sees an invalid character the return value is the address of the character  * just past the last character read.  No error is generated.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|cvt_integer
parameter_list|(
name|str
parameter_list|,
name|rtn
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
modifier|*
name|rtn
decl_stmt|;
block|{
name|int
name|ival
decl_stmt|,
name|neg
decl_stmt|;
name|neg
operator|=
operator|*
name|str
operator|==
literal|'-'
condition|?
operator|++
name|str
operator|,
operator|-
literal|1
operator|:
literal|1
expr_stmt|;
name|ival
operator|=
literal|0
expr_stmt|;
comment|/* first get the number of the type for dbx */
while|while
condition|(
operator|(
operator|*
name|str
operator|<=
literal|'9'
operator|)
operator|&&
operator|(
operator|*
name|str
operator|>=
literal|'0'
operator|)
condition|)
name|ival
operator|=
literal|10
operator|*
name|ival
operator|+
operator|*
name|str
operator|++
operator|-
literal|'0'
expr_stmt|;
operator|*
name|rtn
operator|=
name|neg
operator|*
name|ival
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* this routine fixes the names that are generated by C++, ".this" is a good  * example.  The period does not work for the debugger, since it looks like  * the syntax for a structure element, and thus it gets mightily confused  *  * We also use this to strip the PsectAttribute hack from the name before we  * write a debugger record */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|fix_name
parameter_list|(
name|pnt
parameter_list|)
name|char
modifier|*
name|pnt
decl_stmt|;
block|{
name|char
modifier|*
name|pnt1
decl_stmt|;
comment|/*    *	Kill any leading "_"    */
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'_'
condition|)
name|pnt
operator|++
expr_stmt|;
comment|/*    *	Is there a Psect Attribute to skip??    */
if|if
condition|(
name|HAS_PSECT_ATTRIBUTES
argument_list|(
name|pnt
argument_list|)
condition|)
block|{
comment|/*        *	Yes: Skip it        */
name|pnt
operator|+=
name|PSECT_ATTRIBUTES_STRING_LENGTH
expr_stmt|;
while|while
condition|(
operator|*
name|pnt
condition|)
block|{
if|if
condition|(
operator|(
name|pnt
index|[
literal|0
index|]
operator|==
literal|'$'
operator|)
operator|&&
operator|(
name|pnt
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|)
block|{
name|pnt
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
name|pnt
operator|++
expr_stmt|;
block|}
block|}
comment|/* Here we fix the .this -> $this conversion */
for|for
control|(
name|pnt1
operator|=
name|pnt
init|;
operator|*
name|pnt1
operator|!=
literal|0
condition|;
name|pnt1
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|pnt1
operator|==
literal|'.'
condition|)
operator|*
name|pnt1
operator|=
literal|'$'
expr_stmt|;
block|}
empty_stmt|;
return|return
name|pnt
return|;
block|}
end_function

begin_comment
comment|/* When defining a structure, this routine is called to find the name of  * the actual structure.  It is assumed that str points to the equal sign  * in the definition, and it moves backward until it finds the start of the  * name.  If it finds a 0, then it knows that this structure def is in the  * outermost level, and thus symbol_name points to the symbol name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_struct_name
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|pnt
decl_stmt|;
name|pnt
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|pnt
operator|!=
literal|':'
operator|)
operator|&&
operator|(
operator|*
name|pnt
operator|!=
literal|'\0'
operator|)
condition|)
name|pnt
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'\0'
condition|)
return|return
name|symbol_name
return|;
operator|*
name|pnt
operator|--
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|pnt
operator|!=
literal|';'
operator|)
operator|&&
operator|(
operator|*
name|pnt
operator|!=
literal|'='
operator|)
condition|)
name|pnt
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|';'
condition|)
return|return
name|pnt
operator|+
literal|1
return|;
while|while
condition|(
operator|(
operator|*
name|pnt
operator|<
literal|'0'
operator|)
operator|||
operator|(
operator|*
name|pnt
operator|>
literal|'9'
operator|)
condition|)
name|pnt
operator|++
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|pnt
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|pnt
operator|<=
literal|'9'
operator|)
condition|)
name|pnt
operator|++
expr_stmt|;
return|return
name|pnt
return|;
block|}
end_function

begin_comment
comment|/* search symbol list for type number dbx_type.  Return a pointer to struct */
end_comment

begin_function
specifier|static
name|struct
name|VMS_DBG_Symbol
modifier|*
name|find_symbol
parameter_list|(
name|dbx_type
parameter_list|)
name|int
name|dbx_type
decl_stmt|;
block|{
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
decl_stmt|;
name|spnt
operator|=
name|VMS_Symbol_type_list
expr_stmt|;
while|while
condition|(
name|spnt
operator|!=
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|spnt
operator|->
name|dbx_type
operator|==
name|dbx_type
condition|)
break|break;
name|spnt
operator|=
name|spnt
operator|->
name|next
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|spnt
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
return|return
literal|0
return|;
comment|/*Dunno what this is*/
return|return
name|spnt
return|;
block|}
end_function

begin_comment
comment|/* this routine puts info into either Local or Asuffix, depending on the sign  * of size.  The reason is that it is easier to build the variable descriptor  * backwards, while the array descriptor is best built forwards.  In the end  * they get put together, if there is not a struct/union/enum along the way  */
end_comment

begin_expr_stmt
specifier|static
name|push
argument_list|(
argument|value
argument_list|,
argument|size
argument_list|)
name|int
name|value
operator|,
name|size
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|pnt
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|size1
decl_stmt|;
name|long
name|int
name|val
decl_stmt|;
name|val
operator|=
name|value
expr_stmt|;
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|val
expr_stmt|;
name|size1
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|size1
operator|=
operator|-
name|size
expr_stmt|;
name|pnt
operator|+=
name|size1
operator|-
literal|1
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size1
condition|;
name|i
operator|++
control|)
block|{
name|Local
index|[
name|Lpnt
operator|--
index|]
operator|=
operator|*
name|pnt
operator|--
expr_stmt|;
if|if
condition|(
name|Lpnt
operator|<
literal|0
condition|)
block|{
name|overflow
operator|=
literal|1
expr_stmt|;
name|Lpnt
operator|=
literal|1
expr_stmt|;
block|}
empty_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size1
condition|;
name|i
operator|++
control|)
block|{
name|Asuffix
index|[
name|Apoint
operator|++
index|]
operator|=
operator|*
name|pnt
operator|++
expr_stmt|;
if|if
condition|(
name|Apoint
operator|>=
name|MAX_DEBUG_RECORD
condition|)
block|{
name|overflow
operator|=
literal|1
expr_stmt|;
name|Apoint
operator|=
name|MAX_DEBUG_RECORD
operator|-
literal|1
expr_stmt|;
block|}
empty_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* this routine generates the array descriptor for a given array */
end_comment

begin_expr_stmt
specifier|static
name|array_suffix
argument_list|(
argument|spnt2
argument_list|)
expr|struct
name|VMS_DBG_Symbol
operator|*
name|spnt2
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
decl_stmt|;
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt1
decl_stmt|;
name|int
name|rank
decl_stmt|;
name|int
name|total_size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rank
operator|=
literal|0
expr_stmt|;
name|spnt
operator|=
name|spnt2
expr_stmt|;
while|while
condition|(
name|spnt
operator|->
name|advanced
operator|!=
name|ARRAY
condition|)
block|{
name|spnt
operator|=
name|find_symbol
argument_list|(
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
name|spnt
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
return|return;
block|}
empty_stmt|;
name|spnt1
operator|=
name|spnt
expr_stmt|;
name|spnt1
operator|=
name|spnt
expr_stmt|;
name|total_size
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|spnt1
operator|->
name|advanced
operator|==
name|ARRAY
condition|)
block|{
name|rank
operator|++
expr_stmt|;
name|total_size
operator|*=
operator|(
name|spnt1
operator|->
name|index_max
operator|-
name|spnt1
operator|->
name|index_min
operator|+
literal|1
operator|)
expr_stmt|;
name|spnt1
operator|=
name|find_symbol
argument_list|(
name|spnt1
operator|->
name|type2
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|total_size
operator|=
name|total_size
operator|*
name|spnt1
operator|->
name|data_size
expr_stmt|;
name|push
argument_list|(
name|spnt1
operator|->
name|data_size
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|spnt1
operator|->
name|VMS_type
operator|==
literal|0xa3
condition|)
name|push
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|push
argument_list|(
name|spnt1
operator|->
name|VMS_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|push
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|0xc0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|rank
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|total_size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|spnt1
operator|=
name|spnt
expr_stmt|;
while|while
condition|(
name|spnt1
operator|->
name|advanced
operator|==
name|ARRAY
condition|)
block|{
name|push
argument_list|(
name|spnt1
operator|->
name|index_max
operator|-
name|spnt1
operator|->
name|index_min
operator|+
literal|1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|spnt1
operator|=
name|find_symbol
argument_list|(
name|spnt1
operator|->
name|type2
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|spnt1
operator|=
name|spnt
expr_stmt|;
while|while
condition|(
name|spnt1
operator|->
name|advanced
operator|==
name|ARRAY
condition|)
block|{
name|push
argument_list|(
name|spnt1
operator|->
name|index_min
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|spnt1
operator|->
name|index_max
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|spnt1
operator|=
name|find_symbol
argument_list|(
name|spnt1
operator|->
name|type2
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
end_block

begin_comment
comment|/* this routine generates the start of a variable descriptor based upon  * a struct/union/enum that has yet to be defined.  We define this spot as  * a new location, and save four bytes for the address.  When the struct is  * finally defined, then we can go back and plug in the correct address */
end_comment

begin_expr_stmt
specifier|static
name|new_forward_ref
argument_list|(
argument|dbx_type
argument_list|)
name|int
name|dbx_type
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|forward_ref
modifier|*
name|fpnt
decl_stmt|;
name|fpnt
operator|=
operator|(
expr|struct
name|forward_ref
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|forward_ref
argument_list|)
argument_list|)
expr_stmt|;
name|fpnt
operator|->
name|next
operator|=
name|f_ref_root
expr_stmt|;
name|f_ref_root
operator|=
name|fpnt
expr_stmt|;
name|fpnt
operator|->
name|dbx_type
operator|=
name|dbx_type
expr_stmt|;
name|fpnt
operator|->
name|struc_numb
operator|=
operator|++
name|structure_count
expr_stmt|;
name|fpnt
operator|->
name|resolved
operator|=
literal|'N'
expr_stmt|;
name|push
argument_list|(
literal|3
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|total_len
operator|=
literal|5
expr_stmt|;
name|push
argument_list|(
name|total_len
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
name|struct_number
operator|=
operator|-
name|fpnt
operator|->
name|struc_numb
expr_stmt|;
block|}
end_block

begin_comment
comment|/* this routine generates the variable descriptor used to describe non-basic  * variables.  It calls itself recursively until it gets to the bottom of it  * all, and then builds the descriptor backwards.  It is easiest to do it this  *way since we must periodically write length bytes, and it is easiest if we know  *the value when it is time to write it.  */
end_comment

begin_function
specifier|static
name|int
name|gen1
parameter_list|(
name|spnt
parameter_list|,
name|array_suffix_len
parameter_list|)
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
decl_stmt|;
name|int
name|array_suffix_len
decl_stmt|;
block|{
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt1
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|spnt
operator|->
name|advanced
condition|)
block|{
case|case
name|VOID
case|:
name|push
argument_list|(
name|DBG_S_C_VOID
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|total_len
operator|+=
literal|1
expr_stmt|;
name|push
argument_list|(
name|total_len
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|BASIC
case|:
case|case
name|FUNCTION
case|:
if|if
condition|(
name|array_suffix_len
operator|==
literal|0
condition|)
block|{
name|push
argument_list|(
name|spnt
operator|->
name|VMS_type
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|DBG_S_C_BASIC
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|total_len
operator|=
literal|2
expr_stmt|;
name|push
argument_list|(
name|total_len
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
empty_stmt|;
name|push
argument_list|(
literal|0
argument_list|,
operator|-
literal|4
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|0xfa02
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
name|total_len
operator|=
operator|-
literal|2
expr_stmt|;
return|return
literal|1
return|;
case|case
name|STRUCT
case|:
case|case
name|UNION
case|:
case|case
name|ENUM
case|:
name|struct_number
operator|=
name|spnt
operator|->
name|struc_numb
expr_stmt|;
if|if
condition|(
name|struct_number
operator|<
literal|0
condition|)
block|{
name|new_forward_ref
argument_list|(
name|spnt
operator|->
name|dbx_type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|push
argument_list|(
name|DBG_S_C_STRUCT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|total_len
operator|=
literal|5
expr_stmt|;
name|push
argument_list|(
name|total_len
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|POINTER
case|:
name|spnt1
operator|=
name|find_symbol
argument_list|(
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|spnt1
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
name|new_forward_ref
argument_list|(
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
else|else
name|i
operator|=
name|gen1
argument_list|(
name|spnt1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
comment|/* (*void) is a special case, do not put pointer suffix*/
name|push
argument_list|(
name|DBG_S_C_POINTER
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|total_len
operator|+=
literal|3
expr_stmt|;
name|push
argument_list|(
name|total_len
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return
literal|1
return|;
case|case
name|ARRAY
case|:
name|spnt1
operator|=
name|spnt
expr_stmt|;
while|while
condition|(
name|spnt1
operator|->
name|advanced
operator|==
name|ARRAY
condition|)
block|{
name|spnt1
operator|=
name|find_symbol
argument_list|(
name|spnt1
operator|->
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
name|spnt1
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"gcc-as warning(debugger output):"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Forward reference error, dbx type %d\n"
argument_list|,
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
empty_stmt|;
comment|/* It is too late to generate forward references, so the user gets a message.  * This should only happen on a compiler error */
name|i
operator|=
name|gen1
argument_list|(
name|spnt1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|Apoint
expr_stmt|;
name|array_suffix
argument_list|(
name|spnt
argument_list|)
expr_stmt|;
name|array_suffix_len
operator|=
name|Apoint
operator|-
name|i
expr_stmt|;
switch|switch
condition|(
name|spnt1
operator|->
name|advanced
condition|)
block|{
case|case
name|BASIC
case|:
case|case
name|FUNCTION
case|:
break|break;
default|default:
name|push
argument_list|(
literal|0
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
name|total_len
operator|+=
literal|2
expr_stmt|;
name|push
argument_list|(
name|total_len
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|0xfa
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|0x0101
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|DBG_S_C_COMPLEX_ARRAY
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|total_len
operator|+=
name|array_suffix_len
operator|+
literal|8
expr_stmt|;
name|push
argument_list|(
name|total_len
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/* This generates a suffix for a variable.  If it is not a defined type yet,  * then dbx_type contains the type we are expecting so we can generate a  * forward reference.  This calls gen1 to build most of the descriptor, and  * then it puts the icing on at the end.  It then dumps whatever is needed  * to get a complete descriptor (i.e. struct reference, array suffix ).  */
end_comment

begin_expr_stmt
specifier|static
name|generate_suffix
argument_list|(
argument|spnt
argument_list|,
argument|dbx_type
argument_list|)
expr|struct
name|VMS_DBG_Symbol
operator|*
name|spnt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|dbx_type
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ilen
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|pvoid
index|[
literal|6
index|]
init|=
block|{
literal|5
block|,
literal|0xaf
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|5
block|}
decl_stmt|;
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt1
decl_stmt|;
name|Apoint
operator|=
literal|0
expr_stmt|;
name|Lpnt
operator|=
name|MAX_DEBUG_RECORD
operator|-
literal|1
expr_stmt|;
name|total_len
operator|=
literal|0
expr_stmt|;
name|struct_number
operator|=
literal|0
expr_stmt|;
name|overflow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|spnt
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
name|new_forward_ref
argument_list|(
name|dbx_type
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|spnt
operator|->
name|VMS_type
operator|!=
literal|0xa3
condition|)
return|return
literal|0
return|;
comment|/* no suffix needed */
name|gen1
argument_list|(
name|spnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|push
argument_list|(
literal|0x00af
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
name|total_len
operator|+=
literal|4
expr_stmt|;
name|push
argument_list|(
name|total_len
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* if the variable descriptor overflows the record, output a descriptor for  * a pointer to void.  */
if|if
condition|(
operator|(
name|total_len
operator|>=
name|MAX_DEBUG_RECORD
operator|)
operator|||
name|overflow
condition|)
block|{
name|printf
argument_list|(
literal|" Variable descriptor %d too complicated. Defined as *void "
argument_list|,
name|spnt
operator|->
name|dbx_type
argument_list|)
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|pvoid
argument_list|,
literal|6
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
return|return;
block|}
empty_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|Lpnt
operator|<
name|MAX_DEBUG_RECORD
operator|-
literal|1
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|Local
index|[
operator|++
name|Lpnt
index|]
expr_stmt|;
name|Lpnt
operator|=
name|i
expr_stmt|;
comment|/* we use this for a reference to a structure that has already been defined */
if|if
condition|(
name|struct_number
operator|>
literal|0
condition|)
block|{
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|Lpnt
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|Lpnt
operator|=
literal|0
expr_stmt|;
name|VMS_Store_Struct
argument_list|(
name|struct_number
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* we use this for a forward reference to a structure that has yet to be *defined.  We store four bytes of zero to make room for the actual address once * it is known */
if|if
condition|(
name|struct_number
operator|<
literal|0
condition|)
block|{
name|struct_number
operator|=
operator|-
name|struct_number
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|Lpnt
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|Lpnt
operator|=
literal|0
expr_stmt|;
name|VMS_Def_Struct
argument_list|(
name|struct_number
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|Local
index|[
name|Lpnt
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|Lpnt
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|Lpnt
operator|=
literal|0
expr_stmt|;
block|}
empty_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|Apoint
condition|)
name|Local
index|[
name|Lpnt
operator|++
index|]
operator|=
name|Asuffix
index|[
name|i
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|Lpnt
operator|!=
literal|0
condition|)
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|Lpnt
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|Lpnt
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* This routine generates a symbol definition for a C sybmol for the debugger.  * It takes a psect and offset for global symbols - if psect< 0, then this is  * a local variable and the offset is relative to FP.  In this case it can  * be either a variable (Offset< 0) or a parameter (Offset> 0).  */
end_comment

begin_expr_stmt
specifier|static
name|VMS_DBG_record
argument_list|(
argument|spnt
argument_list|,
argument|Psect
argument_list|,
argument|Offset
argument_list|,
argument|Name
argument_list|)
expr|struct
name|VMS_DBG_Symbol
operator|*
name|spnt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|Psect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|pnt
decl_stmt|;
name|char
modifier|*
name|Name_pnt
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|maxlen
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|Name_pnt
operator|=
name|fix_name
argument_list|(
name|Name
argument_list|)
expr_stmt|;
comment|/* if there are bad characters in name, convert them */
if|if
condition|(
name|Psect
operator|<
literal|0
condition|)
block|{
comment|/* this is a local variable, referenced to SP */
name|maxlen
operator|=
literal|7
operator|+
name|strlen
argument_list|(
name|Name_pnt
argument_list|)
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|maxlen
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|spnt
operator|->
name|VMS_type
expr_stmt|;
if|if
condition|(
name|Offset
operator|>
literal|0
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG_S_C_FUNCTION_PARAMETER
expr_stmt|;
else|else
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG_S_C_LOCAL_SYM
expr_stmt|;
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|Offset
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt
operator|++
expr_stmt|;
comment|/* copy the offset */
block|}
else|else
block|{
name|maxlen
operator|=
literal|7
operator|+
name|strlen
argument_list|(
name|Name_pnt
argument_list|)
expr_stmt|;
comment|/* symbols fixed in memory */
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|7
operator|+
name|strlen
argument_list|(
name|Name_pnt
argument_list|)
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|spnt
operator|->
name|VMS_type
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|1
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|VMS_Set_Data
argument_list|(
name|Psect
argument_list|,
name|Offset
argument_list|,
name|OBJ_S_C_DBG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|Name_pnt
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|Name_pnt
operator|!=
literal|'\0'
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|Name_pnt
operator|++
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
if|if
condition|(
name|spnt
operator|->
name|VMS_type
operator|==
name|DBG_S_C_ADVANCED_TYPE
condition|)
name|generate_suffix
argument_list|(
name|spnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* This routine parses the stabs entries in order to make the definition  * for the debugger of local symbols and function parameters  */
end_comment

begin_function
specifier|static
name|int
name|VMS_local_stab_Parse
parameter_list|(
name|sp
parameter_list|)
name|symbolS
modifier|*
name|sp
decl_stmt|;
block|{
name|char
modifier|*
name|pnt
decl_stmt|;
name|char
modifier|*
name|pnt1
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
decl_stmt|;
name|struct
name|VMS_Symbol
modifier|*
name|vsp
decl_stmt|;
name|int
name|dbx_type
decl_stmt|;
name|int
name|VMS_type
decl_stmt|;
name|dbx_type
operator|=
literal|0
expr_stmt|;
name|str
operator|=
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|str
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnt
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return;
comment|/* no colon present */
name|pnt1
operator|=
name|pnt
operator|++
expr_stmt|;
comment|/* save this for later, and skip colon */
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'c'
condition|)
return|return
literal|0
return|;
comment|/* ignore static constants */
comment|/* there is one little catch that we must be aware of.  Sometimes function  * parameters are optimized into registers, and the compiler, in its infiite  * wisdom outputs stabs records for *both*.  In general we want to use the  * register if it is present, so we must search the rest of the symbols for  * this function to see if this parameter is assigned to a register.  */
block|{
name|char
modifier|*
name|str1
decl_stmt|;
name|char
modifier|*
name|pnt2
decl_stmt|;
name|symbolS
modifier|*
name|sp1
decl_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'p'
condition|)
block|{
for|for
control|(
name|sp1
operator|=
name|symbol_next
argument_list|(
name|sp
argument_list|)
init|;
name|sp1
condition|;
name|sp1
operator|=
name|symbol_next
argument_list|(
name|sp1
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|S_IS_DEBUG
argument_list|(
name|sp1
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|sp1
argument_list|)
operator|==
name|N_FUN
condition|)
block|{
name|char
modifier|*
name|pnt3
init|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|S_GET_NAME
argument_list|(
name|sp1
argument_list|)
argument_list|,
literal|':'
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|*
name|pnt3
operator|==
literal|'F'
operator|||
operator|*
name|pnt3
operator|==
literal|'f'
condition|)
break|break;
block|}
empty_stmt|;
if|if
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|sp1
argument_list|)
operator|!=
name|N_RSYM
condition|)
continue|continue;
name|str1
operator|=
name|S_GET_NAME
argument_list|(
name|sp1
argument_list|)
expr_stmt|;
comment|/* and get the name */
name|pnt2
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|*
name|pnt2
operator|!=
literal|':'
condition|)
block|{
if|if
condition|(
operator|*
name|pnt2
operator|!=
operator|*
name|str1
condition|)
break|break;
name|pnt2
operator|++
expr_stmt|;
name|str1
operator|++
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|(
operator|*
name|str1
operator|!=
literal|':'
operator|)
operator|||
operator|(
operator|*
name|pnt2
operator|!=
literal|':'
operator|)
condition|)
continue|continue;
return|return;
comment|/* they are the same!  lets skip this one */
block|}
empty_stmt|;
comment|/* for */
comment|/* first find the dbx symbol type from list, and then find VMS type */
name|pnt
operator|++
expr_stmt|;
comment|/* skip p in case no register */
block|}
empty_stmt|;
comment|/* if */
block|}
empty_stmt|;
comment|/* p block */
name|pnt
operator|=
name|cvt_integer
argument_list|(
name|pnt
argument_list|,
operator|&
name|dbx_type
argument_list|)
expr_stmt|;
name|spnt
operator|=
name|find_symbol
argument_list|(
name|dbx_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|spnt
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
return|return
literal|0
return|;
comment|/*Dunno what this is*/
operator|*
name|pnt1
operator|=
literal|'\0'
expr_stmt|;
name|VMS_DBG_record
argument_list|(
name|spnt
argument_list|,
operator|-
literal|1
argument_list|,
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
operator|*
name|pnt1
operator|=
literal|':'
expr_stmt|;
comment|/* and restore the string */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This routine parses a stabs entry to find the information required to define  * a variable.  It is used for global and static variables.  * Basically we need to know the address of the symbol.  With older versions  * of the compiler, const symbols are  * treated differently, in that if they are global they are written into the  * text psect.  The global symbol entry for such a const is actually written  * as a program entry point (Yuk!!), so if we cannot find a symbol in the list  * of psects, we must search the entry points as well.  static consts are even  * harder, since they are never assigned a memory address.  The compiler passes  * a stab to tell us the value, but I am not sure what to do with it.  */
end_comment

begin_expr_stmt
specifier|static
name|VMS_stab_parse
argument_list|(
argument|sp
argument_list|,
argument|expected_type
argument_list|,
argument|type1
argument_list|,
argument|type2
argument_list|,
argument|Text_Psect
argument_list|)
name|symbolS
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|expected_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type1
decl_stmt|,
name|type2
decl_stmt|,
name|Text_Psect
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|pnt
decl_stmt|;
name|char
modifier|*
name|pnt1
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|symbolS
modifier|*
name|sp1
decl_stmt|;
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
decl_stmt|;
name|struct
name|VMS_Symbol
modifier|*
name|vsp
decl_stmt|;
name|int
name|dbx_type
decl_stmt|;
name|int
name|VMS_type
decl_stmt|;
name|dbx_type
operator|=
literal|0
expr_stmt|;
name|str
operator|=
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|str
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnt
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return;
comment|/* no colon present */
name|pnt1
operator|=
name|pnt
expr_stmt|;
comment|/* save this for later*/
name|pnt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
name|expected_type
condition|)
block|{
name|pnt
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|dbx_type
argument_list|)
expr_stmt|;
name|spnt
operator|=
name|find_symbol
argument_list|(
name|dbx_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|spnt
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
return|return
literal|0
return|;
comment|/*Dunno what this is*/
comment|/* now we need to search the symbol table to find the psect and offset for  * this variable.  */
operator|*
name|pnt1
operator|=
literal|'\0'
expr_stmt|;
name|vsp
operator|=
name|VMS_Symbols
expr_stmt|;
while|while
condition|(
name|vsp
operator|!=
operator|(
expr|struct
name|VMS_Symbol
operator|*
operator|)
name|NULL
condition|)
block|{
name|pnt
operator|=
name|S_GET_NAME
argument_list|(
name|vsp
operator|->
name|Symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnt
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
if|if
condition|(
operator|*
name|pnt
operator|++
operator|==
literal|'_'
condition|)
comment|/* make sure name is the same, and make sure correct symbol type */
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|pnt
argument_list|)
operator|==
name|strlen
argument_list|(
name|str
argument_list|)
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|pnt
argument_list|,
name|str
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|S_GET_RAW_TYPE
argument_list|(
name|vsp
operator|->
name|Symbol
argument_list|)
operator|==
name|type1
operator|)
operator|||
operator|(
name|S_GET_RAW_TYPE
argument_list|(
name|vsp
operator|->
name|Symbol
argument_list|)
operator|==
name|type2
operator|)
operator|)
condition|)
break|break;
name|vsp
operator|=
name|vsp
operator|->
name|Next
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|vsp
operator|!=
operator|(
expr|struct
name|VMS_Symbol
operator|*
operator|)
name|NULL
condition|)
block|{
name|VMS_DBG_record
argument_list|(
name|spnt
argument_list|,
name|vsp
operator|->
name|Psect_Index
argument_list|,
name|vsp
operator|->
name|Psect_Offset
argument_list|,
name|str
argument_list|)
expr_stmt|;
operator|*
name|pnt1
operator|=
literal|':'
expr_stmt|;
comment|/* and restore the string */
return|return
literal|1
return|;
block|}
empty_stmt|;
comment|/* the symbol was not in the symbol list, but it may be an "entry point"    if it was a constant */
for|for
control|(
name|sp1
operator|=
name|symbol_rootP
init|;
name|sp1
condition|;
name|sp1
operator|=
name|symbol_next
argument_list|(
name|sp1
argument_list|)
control|)
block|{
comment|/* 	   *	Dispatch on STAB type 	   */
if|if
condition|(
name|S_IS_DEBUG
argument_list|(
name|sp1
argument_list|)
operator|||
operator|(
name|S_GET_TYPE
argument_list|(
name|sp1
argument_list|)
operator|!=
name|N_TEXT
operator|)
condition|)
continue|continue;
name|pnt
operator|=
name|S_GET_NAME
argument_list|(
name|sp1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'_'
condition|)
name|pnt
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pnt
argument_list|,
name|str
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|gave_compiler_message
operator|&&
name|expected_type
operator|==
literal|'G'
condition|)
block|{
name|printf
argument_list|(
literal|"***Warning - the assembly code generated by the compiler has placed\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"global constant(s) in the text psect.  These will not be available to\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"other modules, since this is not the correct way to handle this. You\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"have two options: 1) get a patched compiler that does not put global\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"constants in the text psect, or 2) remove the 'const' keyword from\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"definitions of global variables in your source module(s).  Don't say\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"I didn't warn you!"
argument_list|)
expr_stmt|;
name|gave_compiler_message
operator|=
literal|1
expr_stmt|;
block|}
empty_stmt|;
name|VMS_DBG_record
argument_list|(
name|spnt
argument_list|,
name|Text_Psect
argument_list|,
name|S_GET_VALUE
argument_list|(
name|sp1
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
operator|*
name|pnt1
operator|=
literal|':'
expr_stmt|;
operator|*
name|S_GET_NAME
argument_list|(
name|sp1
argument_list|)
operator|=
literal|'L'
expr_stmt|;
comment|/* fool assembler to not output this 	       * as a routine in the TBT */
return|return
literal|1
return|;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
operator|*
name|pnt1
operator|=
literal|':'
expr_stmt|;
comment|/* and restore the string */
return|return
literal|0
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|VMS_GSYM_Parse
argument_list|(
argument|sp
argument_list|,
argument|Text_Psect
argument_list|)
name|symbolS
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|Text_Psect
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Global variables */
name|VMS_stab_parse
argument_list|(
name|sp
argument_list|,
literal|'G'
argument_list|,
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
argument_list|,
operator|(
name|N_DATA
operator||
name|N_EXT
operator|)
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|VMS_LCSYM_Parse
argument_list|(
argument|sp
argument_list|,
argument|Text_Psect
argument_list|)
name|symbolS
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|Text_Psect
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Static symbols - uninitialized */
name|VMS_stab_parse
argument_list|(
name|sp
argument_list|,
literal|'S'
argument_list|,
name|N_BSS
argument_list|,
operator|-
literal|1
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|VMS_STSYM_Parse
argument_list|(
argument|sp
argument_list|,
argument|Text_Psect
argument_list|)
name|symbolS
operator|*
name|sp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|Text_Psect
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Static symbols - initialized */
name|VMS_stab_parse
argument_list|(
name|sp
argument_list|,
literal|'S'
argument_list|,
name|N_DATA
argument_list|,
operator|-
literal|1
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* for register symbols, we must figure out what range of addresses within the  * psect are valid. We will use the brackets in the stab directives to give us  * guidance as to the PC range that this variable is in scope.  I am still not  * completely comfortable with this but as I learn more, I seem to get a better  * handle on what is going on.  * Caveat Emptor.  */
end_comment

begin_expr_stmt
specifier|static
name|VMS_RSYM_Parse
argument_list|(
argument|sp
argument_list|,
argument|Current_Routine
argument_list|,
argument|Text_Psect
argument_list|)
name|symbolS
operator|*
name|sp
operator|,
operator|*
name|Current_Routine
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|Text_Psect
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|pnt
decl_stmt|;
name|char
modifier|*
name|pnt1
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|dbx_type
decl_stmt|;
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|maxlen
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|bcnt
init|=
literal|0
decl_stmt|;
name|int
name|Min_Offset
init|=
operator|-
literal|1
decl_stmt|;
comment|/* min PC of validity */
name|int
name|Max_Offset
init|=
literal|0
decl_stmt|;
comment|/* max PC of validity */
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
for|for
control|(
name|symbolP
operator|=
name|sp
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
comment|/*        *	Dispatch on STAB type        */
switch|switch
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
case|case
name|N_LBRAC
case|:
if|if
condition|(
name|bcnt
operator|++
operator|==
literal|0
condition|)
name|Min_Offset
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_RBRAC
case|:
if|if
condition|(
operator|--
name|bcnt
operator|==
literal|0
condition|)
name|Max_Offset
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|Min_Offset
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|bcnt
operator|==
literal|0
operator|)
condition|)
break|break;
if|if
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|symbolP
argument_list|)
operator|==
name|N_FUN
condition|)
block|{
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
argument_list|,
literal|':'
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'F'
operator|||
operator|*
name|pnt
operator|==
literal|'f'
condition|)
break|break;
block|}
empty_stmt|;
block|}
comment|/* check to see that the addresses were defined.  If not, then there were no  * brackets in the function, and we must try to search for the next function  * Since functions can be in any order, we should search all of the symbol list  * to find the correct ending address. */
if|if
condition|(
name|Min_Offset
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|Max_Source_Offset
decl_stmt|;
name|int
name|This_Offset
decl_stmt|;
name|Min_Offset
operator|=
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
comment|/* 	   *	Dispatch on STAB type 	   */
name|This_Offset
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
if|if
condition|(
operator|(
name|This_Offset
operator|>
name|Min_Offset
operator|)
operator|&&
operator|(
name|This_Offset
operator|<
name|Max_Offset
operator|)
condition|)
name|Max_Offset
operator|=
name|This_Offset
expr_stmt|;
break|break;
case|case
name|N_SLINE
case|:
if|if
condition|(
name|This_Offset
operator|>
name|Max_Source_Offset
condition|)
name|Max_Source_Offset
operator|=
name|This_Offset
expr_stmt|;
block|}
block|}
comment|/* if this is the last routine, then we use the PC of the last source line  * as a marker of the max PC for which this reg is valid */
if|if
condition|(
name|Max_Offset
operator|==
literal|0x7fffffff
condition|)
name|Max_Offset
operator|=
name|Max_Source_Offset
expr_stmt|;
block|}
empty_stmt|;
name|dbx_type
operator|=
literal|0
expr_stmt|;
name|str
operator|=
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|str
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnt
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return;
comment|/* no colon present */
name|pnt1
operator|=
name|pnt
expr_stmt|;
comment|/* save this for later*/
name|pnt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|!=
literal|'r'
condition|)
return|return
literal|0
return|;
name|pnt
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|dbx_type
argument_list|)
expr_stmt|;
name|spnt
operator|=
name|find_symbol
argument_list|(
name|dbx_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|spnt
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
return|return
literal|0
return|;
comment|/*Dunno what this is yet*/
operator|*
name|pnt1
operator|=
literal|'\0'
expr_stmt|;
name|pnt
operator|=
name|fix_name
argument_list|(
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if there are bad characters in name, convert them */
name|maxlen
operator|=
literal|25
operator|+
name|strlen
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|maxlen
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|spnt
operator|->
name|VMS_type
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0xfb
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|pnt
argument_list|)
operator|+
literal|1
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x00
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x00
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x00
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|pnt
operator|!=
literal|'\0'
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt
operator|++
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0xfd
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x0f
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x00
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x03
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x01
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|VMS_Set_Data
argument_list|(
name|Text_Psect
argument_list|,
name|Min_Offset
argument_list|,
name|OBJ_S_C_DBG
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VMS_Set_Data
argument_list|(
name|Text_Psect
argument_list|,
name|Max_Offset
argument_list|,
name|OBJ_S_C_DBG
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x03
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x00
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x00
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x00
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
operator|*
name|pnt1
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
name|spnt
operator|->
name|VMS_type
operator|==
name|DBG_S_C_ADVANCED_TYPE
condition|)
name|generate_suffix
argument_list|(
name|spnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* this function examines a structure definition, checking all of the elements  * to make sure that all of them are fully defined.  The only thing that we  * kick out are arrays of undefined structs, since we do not know how big  * they are.  All others we can handle with a normal forward reference.  */
end_comment

begin_function
specifier|static
name|int
name|forward_reference
parameter_list|(
name|pnt
parameter_list|)
name|char
modifier|*
name|pnt
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
decl_stmt|;
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt1
decl_stmt|;
name|pnt
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|';'
condition|)
return|return
literal|0
return|;
comment|/* no forward references */
do|do
block|{
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|pnt
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|pnt
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|spnt
operator|=
name|find_symbol
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|spnt
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|(
name|spnt
operator|->
name|advanced
operator|==
name|POINTER
operator|)
operator|||
operator|(
name|spnt
operator|->
name|advanced
operator|==
name|ARRAY
operator|)
condition|)
block|{
name|i
operator|=
name|spnt
operator|->
name|type2
expr_stmt|;
name|spnt1
operator|=
name|find_symbol
argument_list|(
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|spnt
operator|->
name|advanced
operator|==
name|ARRAY
operator|)
operator|&&
operator|(
name|spnt1
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|spnt1
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
break|break;
name|spnt
operator|=
name|spnt1
expr_stmt|;
block|}
empty_stmt|;
name|pnt
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
name|pnt
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
operator|++
name|pnt
operator|!=
literal|';'
condition|)
do|;
return|return
literal|0
return|;
comment|/* no forward refences found */
block|}
end_function

begin_comment
comment|/* This routine parses the stabs directives to find any definitions of dbx type  * numbers.  It makes a note of all of them, creating a structure element  * of VMS_DBG_Symbol that describes it.  This also generates the info for the  * debugger that describes the struct/union/enum, so that further references  * to these data types will be by number  * 	We have to process pointers right away, since there can be references  * to them later in the same stabs directive.  We cannot have forward  * references to pointers, (but we can have a forward reference to a pointer to  * a structure/enum/union) and this is why we process them immediately.  * After we process the pointer, then we search for defs that are nested even  * deeper.  */
end_comment

begin_function
specifier|static
name|int
name|VMS_typedef_parse
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|pnt
decl_stmt|;
name|char
modifier|*
name|pnt1
decl_stmt|;
name|char
modifier|*
name|pnt2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|dtype
decl_stmt|;
name|struct
name|forward_ref
modifier|*
name|fpnt
decl_stmt|;
name|int
name|i1
decl_stmt|,
name|i2
decl_stmt|,
name|i3
decl_stmt|;
name|int
name|convert_integer
decl_stmt|;
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
decl_stmt|;
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt1
decl_stmt|;
comment|/* check for any nested def's */
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|str
operator|+
literal|1
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pnt
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
operator|*
operator|(
name|str
operator|+
literal|1
operator|)
operator|!=
literal|'*'
operator|)
condition|)
if|if
condition|(
name|VMS_typedef_parse
argument_list|(
name|pnt
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|1
return|;
comment|/* now find dbx_type of entry */
name|pnt
operator|=
name|str
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'c'
condition|)
block|{
comment|/* check for static constants */
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
comment|/* for now we ignore them */
return|return
literal|0
return|;
block|}
empty_stmt|;
while|while
condition|(
operator|(
operator|*
name|pnt
operator|<=
literal|'9'
operator|)
operator|&&
operator|(
operator|*
name|pnt
operator|>=
literal|'0'
operator|)
condition|)
name|pnt
operator|--
expr_stmt|;
name|pnt
operator|++
expr_stmt|;
comment|/* and get back to the number */
name|cvt_integer
argument_list|(
name|pnt
argument_list|,
operator|&
name|i1
argument_list|)
expr_stmt|;
name|spnt
operator|=
name|find_symbol
argument_list|(
name|i1
argument_list|)
expr_stmt|;
comment|/* first we see if this has been defined already, due to a forward reference*/
if|if
condition|(
name|spnt
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|VMS_Symbol_type_list
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
block|{
name|spnt
operator|=
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|VMS_DBG_Symbol
argument_list|)
argument_list|)
expr_stmt|;
name|spnt
operator|->
name|next
operator|=
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
expr_stmt|;
name|VMS_Symbol_type_list
operator|=
name|spnt
expr_stmt|;
block|}
else|else
block|{
name|spnt
operator|=
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|VMS_DBG_Symbol
argument_list|)
argument_list|)
expr_stmt|;
name|spnt
operator|->
name|next
operator|=
name|VMS_Symbol_type_list
expr_stmt|;
name|VMS_Symbol_type_list
operator|=
name|spnt
expr_stmt|;
block|}
empty_stmt|;
name|spnt
operator|->
name|dbx_type
operator|=
name|i1
expr_stmt|;
comment|/* and save the type */
block|}
empty_stmt|;
comment|/* for structs and unions, do a partial parse, otherwise we sometimes get  * circular definitions that are impossible to resolve. We read enough info  * so that any reference to this type has enough info to be resolved  */
name|pnt
operator|=
name|str
operator|+
literal|1
expr_stmt|;
comment|/* point to character past equal sign */
if|if
condition|(
operator|(
operator|*
name|pnt
operator|==
literal|'u'
operator|)
operator|||
operator|(
operator|*
name|pnt
operator|==
literal|'s'
operator|)
condition|)
block|{     }
empty_stmt|;
if|if
condition|(
operator|(
operator|*
name|pnt
operator|<=
literal|'9'
operator|)
operator|&&
operator|(
operator|*
name|pnt
operator|>=
literal|'0'
operator|)
condition|)
block|{
if|if
condition|(
name|type_check
argument_list|(
literal|"void"
argument_list|)
condition|)
block|{
comment|/* this is the void symbol */
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
name|spnt
operator|->
name|advanced
operator|=
name|VOID
expr_stmt|;
return|return
literal|0
return|;
block|}
empty_stmt|;
if|if
condition|(
name|type_check
argument_list|(
literal|"unknown type"
argument_list|)
condition|)
block|{
comment|/* this is the void symbol */
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
name|spnt
operator|->
name|advanced
operator|=
name|UNKNOWN
expr_stmt|;
return|return
literal|0
return|;
block|}
empty_stmt|;
name|printf
argument_list|(
literal|"gcc-as warning(debugger output):"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %d is an unknown untyped variable.\n"
argument_list|,
name|spnt
operator|->
name|dbx_type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* do not know what this is */
block|}
empty_stmt|;
comment|/* now define this module*/
name|pnt
operator|=
name|str
operator|+
literal|1
expr_stmt|;
comment|/* point to character past equal sign */
switch|switch
condition|(
operator|*
name|pnt
condition|)
block|{
case|case
literal|'r'
case|:
name|spnt
operator|->
name|advanced
operator|=
name|BASIC
expr_stmt|;
if|if
condition|(
name|type_check
argument_list|(
literal|"int"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_SLINT
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"long int"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_SLINT
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"unsigned int"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_ULINT
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"long unsigned int"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_ULINT
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"short int"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_SSINT
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"short unsigned int"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_USINT
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"char"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_SCHAR
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"signed char"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_SCHAR
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"unsigned char"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_UCHAR
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"float"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_REAL4
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type_check
argument_list|(
literal|"double"
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_REAL8
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|8
expr_stmt|;
block|}
name|pnt1
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|str
argument_list|,
literal|';'
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'u'
case|:
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'s'
condition|)
name|spnt
operator|->
name|advanced
operator|=
name|STRUCT
expr_stmt|;
else|else
name|spnt
operator|->
name|advanced
operator|=
name|UNION
expr_stmt|;
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_ADVANCED_TYPE
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|spnt
operator|->
name|data_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|forward_reference
argument_list|(
name|pnt
argument_list|)
condition|)
block|{
name|spnt
operator|->
name|struc_numb
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
name|spnt
operator|->
name|struc_numb
operator|=
operator|++
name|structure_count
expr_stmt|;
name|pnt1
operator|--
expr_stmt|;
name|pnt
operator|=
name|get_struct_name
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|VMS_Def_Struct
argument_list|(
name|spnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
name|fpnt
operator|=
name|f_ref_root
expr_stmt|;
while|while
condition|(
name|fpnt
operator|!=
operator|(
expr|struct
name|forward_ref
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|fpnt
operator|->
name|dbx_type
operator|==
name|spnt
operator|->
name|dbx_type
condition|)
block|{
name|fpnt
operator|->
name|resolved
operator|=
literal|'Y'
expr_stmt|;
name|VMS_Set_Struct
argument_list|(
name|fpnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
name|VMS_Store_Struct
argument_list|(
name|spnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|fpnt
operator|=
name|fpnt
operator|->
name|next
expr_stmt|;
block|}
empty_stmt|;
name|VMS_Set_Struct
argument_list|(
name|spnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|11
operator|+
name|strlen
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG_S_C_STRUCT_START
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x80
expr_stmt|;
for|for
control|(
name|i1
operator|=
literal|0
init|;
name|i1
operator|<
literal|4
condition|;
name|i1
operator|++
control|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x00
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|pnt2
operator|=
name|pnt
expr_stmt|;
while|while
condition|(
operator|*
name|pnt2
operator|!=
literal|'\0'
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt2
operator|++
expr_stmt|;
name|i2
operator|=
name|spnt
operator|->
name|data_size
operator|*
literal|8
expr_stmt|;
comment|/* number of bits */
name|pnt2
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|i2
expr_stmt|;
for|for
control|(
name|i1
operator|=
literal|0
init|;
name|i1
operator|<
literal|4
condition|;
name|i1
operator|++
control|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt2
operator|++
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pnt
operator|!=
name|symbol_name
condition|)
block|{
name|pnt
operator|+=
name|strlen
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
operator|*
name|pnt
operator|=
literal|':'
expr_stmt|;
block|}
empty_stmt|;
comment|/* replace colon for later */
while|while
condition|(
operator|*
operator|++
name|pnt1
operator|!=
literal|';'
condition|)
block|{
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|pnt1
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
operator|*
name|pnt
operator|=
literal|'\0'
expr_stmt|;
name|pnt2
operator|=
name|pnt1
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|dtype
argument_list|)
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt1
operator|+
literal|1
argument_list|,
operator|&
name|i2
argument_list|)
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt1
operator|+
literal|1
argument_list|,
operator|&
name|i3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dtype
operator|==
literal|1
operator|)
operator|&&
operator|(
name|i3
operator|!=
literal|32
operator|)
condition|)
block|{
comment|/* bitfield */
name|Apoint
operator|=
literal|0
expr_stmt|;
name|push
argument_list|(
literal|19
operator|+
name|strlen
argument_list|(
name|pnt2
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|0xfa22
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|1
operator|+
name|strlen
argument_list|(
name|pnt2
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|strlen
argument_list|(
name|pnt2
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|pnt2
operator|!=
literal|'\0'
condition|)
name|push
argument_list|(
operator|*
name|pnt2
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|i3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* size of bitfield */
name|push
argument_list|(
literal|0x0d22
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|push
argument_list|(
literal|0x00
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|push
argument_list|(
name|i2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* start position */
name|VMS_Store_Immediate_Data
argument_list|(
name|Asuffix
argument_list|,
name|Apoint
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|Apoint
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|7
operator|+
name|strlen
argument_list|(
name|pnt2
argument_list|)
expr_stmt|;
name|spnt1
operator|=
name|find_symbol
argument_list|(
name|dtype
argument_list|)
expr_stmt|;
comment|/* check if this is a forward reference */
if|if
condition|(
name|spnt1
operator|!=
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|spnt1
operator|->
name|VMS_type
expr_stmt|;
else|else
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG_S_C_ADVANCED_TYPE
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG_S_C_STRUCT_ITEM
expr_stmt|;
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|i2
expr_stmt|;
for|for
control|(
name|i1
operator|=
literal|0
init|;
name|i1
operator|<
literal|4
condition|;
name|i1
operator|++
control|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt
operator|++
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|pnt2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|pnt2
operator|!=
literal|'\0'
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt2
operator|++
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|spnt1
operator|==
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
name|generate_suffix
argument_list|(
name|spnt1
argument_list|,
name|dtype
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|spnt1
operator|->
name|VMS_type
operator|==
name|DBG_S_C_ADVANCED_TYPE
condition|)
name|generate_suffix
argument_list|(
name|spnt1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
name|pnt1
operator|++
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x01
expr_stmt|;
comment|/* length byte */
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG_S_C_STRUCT_END
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|spnt
operator|->
name|advanced
operator|=
name|ENUM
expr_stmt|;
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_ADVANCED_TYPE
expr_stmt|;
name|spnt
operator|->
name|struc_numb
operator|=
operator|++
name|structure_count
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
name|VMS_Def_Struct
argument_list|(
name|spnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
name|fpnt
operator|=
name|f_ref_root
expr_stmt|;
while|while
condition|(
name|fpnt
operator|!=
operator|(
expr|struct
name|forward_ref
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|fpnt
operator|->
name|dbx_type
operator|==
name|spnt
operator|->
name|dbx_type
condition|)
block|{
name|fpnt
operator|->
name|resolved
operator|=
literal|'Y'
expr_stmt|;
name|VMS_Set_Struct
argument_list|(
name|fpnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
name|VMS_Store_Struct
argument_list|(
name|spnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|fpnt
operator|=
name|fpnt
operator|->
name|next
expr_stmt|;
block|}
empty_stmt|;
name|VMS_Set_Struct
argument_list|(
name|spnt
operator|->
name|struc_numb
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|3
operator|+
name|strlen
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG_S_C_ENUM_START
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x20
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|symbol_name
argument_list|)
expr_stmt|;
name|pnt2
operator|=
name|symbol_name
expr_stmt|;
while|while
condition|(
operator|*
name|pnt2
operator|!=
literal|'\0'
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt2
operator|++
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|pnt
operator|!=
literal|';'
condition|)
block|{
name|pnt1
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|pnt
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
operator|*
name|pnt1
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt1
argument_list|,
operator|&
name|i1
argument_list|)
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|7
operator|+
name|strlen
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG_S_C_ENUM_ITEM
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x00
expr_stmt|;
name|pnt2
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|i1
expr_stmt|;
for|for
control|(
name|i2
operator|=
literal|0
init|;
name|i2
operator|<
literal|4
condition|;
name|i2
operator|++
control|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt2
operator|++
expr_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|pnt
argument_list|)
expr_stmt|;
name|pnt2
operator|=
name|pnt
expr_stmt|;
while|while
condition|(
operator|*
name|pnt
operator|!=
literal|'\0'
condition|)
name|Local
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|pnt
operator|++
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|pnt
operator|=
name|pnt1
expr_stmt|;
comment|/* Skip final semicolon */
block|}
empty_stmt|;
name|Local
index|[
name|i
operator|++
index|]
operator|=
literal|0x01
expr_stmt|;
comment|/* len byte */
name|Local
index|[
name|i
operator|++
index|]
operator|=
name|DBG_S_C_ENUM_END
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
name|Local
argument_list|,
name|i
argument_list|,
name|OBJ_S_C_DBG
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|pnt1
operator|=
name|pnt
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|spnt
operator|->
name|advanced
operator|=
name|ARRAY
expr_stmt|;
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_ADVANCED_TYPE
expr_stmt|;
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|pnt
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnt
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
return|return
literal|1
return|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|spnt
operator|->
name|index_min
argument_list|)
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt1
operator|+
literal|1
argument_list|,
operator|&
name|spnt
operator|->
name|index_max
argument_list|)
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt1
operator|+
literal|1
argument_list|,
operator|&
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|spnt
operator|->
name|advanced
operator|=
name|FUNCTION
expr_stmt|;
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_FUNCTION_ADDR
expr_stmt|;
comment|/* this masquerades as a basic type*/
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|spnt
operator|->
name|advanced
operator|=
name|POINTER
expr_stmt|;
name|spnt
operator|->
name|VMS_type
operator|=
name|DBG_S_C_ADVANCED_TYPE
expr_stmt|;
name|spnt
operator|->
name|data_size
operator|=
literal|4
expr_stmt|;
name|pnt1
operator|=
name|cvt_integer
argument_list|(
name|pnt
operator|+
literal|1
argument_list|,
operator|&
name|spnt
operator|->
name|type2
argument_list|)
expr_stmt|;
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|str
operator|+
literal|1
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pnt
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
condition|)
if|if
condition|(
name|VMS_typedef_parse
argument_list|(
name|pnt
argument_list|)
operator|==
literal|1
condition|)
return|return
literal|1
return|;
break|break;
default|default:
name|spnt
operator|->
name|advanced
operator|=
name|UNKNOWN
expr_stmt|;
name|spnt
operator|->
name|VMS_type
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"gcc-as warning(debugger output):"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %d is an unknown type of variable.\n"
argument_list|,
name|spnt
operator|->
name|dbx_type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* unable to decipher */
block|}
empty_stmt|;
comment|/* this removes the evidence of the definition so that the outer levels of parsing do not have to worry about it */
name|pnt
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|*
name|pnt1
operator|!=
literal|'\0'
condition|)
operator|*
name|pnt
operator|++
operator|=
operator|*
name|pnt1
operator|++
expr_stmt|;
operator|*
name|pnt
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This is the root routine that parses the stabs entries for definitions.  * it calls VMS_typedef_parse, which can in turn call itself.  * We need to be careful, since sometimes there are forward references to  * other symbol types, and these cannot be resolved until we have completed  * the parse.  */
end_comment

begin_function
specifier|static
name|int
name|VMS_LSYM_Parse
parameter_list|()
block|{
name|char
modifier|*
name|pnt
decl_stmt|;
name|char
modifier|*
name|pnt1
decl_stmt|;
name|char
modifier|*
name|pnt2
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|char
name|fixit
index|[
literal|10
index|]
decl_stmt|;
name|int
name|incomplete
decl_stmt|,
name|i
decl_stmt|,
name|pass
decl_stmt|,
name|incom1
decl_stmt|;
name|struct
name|VMS_DBG_Symbol
modifier|*
name|spnt
decl_stmt|;
name|struct
name|VMS_Symbol
modifier|*
name|vsp
decl_stmt|;
name|struct
name|forward_ref
modifier|*
name|fpnt
decl_stmt|;
name|symbolS
modifier|*
name|sp
decl_stmt|;
name|pass
operator|=
literal|0
expr_stmt|;
name|incomplete
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|incom1
operator|=
name|incomplete
expr_stmt|;
name|incomplete
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|symbol_rootP
init|;
name|sp
condition|;
name|sp
operator|=
name|symbol_next
argument_list|(
name|sp
argument_list|)
control|)
block|{
comment|/* 	   *	Deal with STAB symbols 	   */
if|if
condition|(
name|S_IS_DEBUG
argument_list|(
name|sp
argument_list|)
condition|)
block|{
comment|/* 	       *	Dispatch on STAB type 	       */
switch|switch
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|sp
argument_list|)
condition|)
block|{
case|case
name|N_GSYM
case|:
case|case
name|N_LCSYM
case|:
case|case
name|N_STSYM
case|:
case|case
name|N_PSYM
case|:
case|case
name|N_RSYM
case|:
case|case
name|N_LSYM
case|:
case|case
name|N_FUN
case|:
comment|/*sometimes these contain typedefs*/
name|str
operator|=
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|symbol_name
operator|=
name|str
expr_stmt|;
name|pnt
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|str
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnt
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
break|break;
operator|*
name|pnt
operator|=
literal|'\0'
expr_stmt|;
name|pnt1
operator|=
name|pnt
operator|+
literal|1
expr_stmt|;
name|pnt2
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|pnt1
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnt2
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
operator|*
name|pnt
operator|=
literal|':'
expr_stmt|;
comment|/* replace colon */
break|break;
block|}
empty_stmt|;
comment|/* no symbol here */
name|incomplete
operator|+=
name|VMS_typedef_parse
argument_list|(
name|pnt2
argument_list|)
expr_stmt|;
operator|*
name|pnt
operator|=
literal|':'
expr_stmt|;
comment|/* put back colon so variable def code finds dbx_type*/
break|break;
block|}
comment|/*switch*/
block|}
comment|/* if */
block|}
comment|/*for*/
name|pass
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|incomplete
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|incomplete
operator|!=
name|incom1
operator|)
condition|)
do|;
comment|/* repeat until all refs resolved if possible */
comment|/*	if (pass> 1) printf(" Required %d passes\n",pass);*/
if|if
condition|(
name|incomplete
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"gcc-as warning(debugger output):"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Unable to resolve %d circular references.\n"
argument_list|,
name|incomplete
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|fpnt
operator|=
name|f_ref_root
expr_stmt|;
name|symbol_name
operator|=
literal|"\0"
expr_stmt|;
while|while
condition|(
name|fpnt
operator|!=
operator|(
expr|struct
name|forward_ref
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|fpnt
operator|->
name|resolved
operator|!=
literal|'Y'
condition|)
block|{
if|if
condition|(
name|find_symbol
argument_list|(
name|fpnt
operator|->
name|dbx_type
argument_list|)
operator|!=
operator|(
expr|struct
name|VMS_DBG_Symbol
operator|*
operator|)
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"gcc-as warning(debugger output):"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Forward reference error, dbx type %d\n"
argument_list|,
name|fpnt
operator|->
name|dbx_type
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|fixit
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
operator|&
name|fixit
index|[
literal|1
index|]
argument_list|,
literal|"%d=s4;"
argument_list|,
name|fpnt
operator|->
name|dbx_type
argument_list|)
expr_stmt|;
name|pnt2
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
operator|&
name|fixit
index|[
literal|1
index|]
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|VMS_typedef_parse
argument_list|(
name|pnt2
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|fpnt
operator|=
name|fpnt
operator|->
name|next
expr_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|Define_Local_Symbols
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
name|symbolS
operator|*
name|s1
operator|,
operator|*
name|s2
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|symbolS
modifier|*
name|symbolP1
decl_stmt|;
for|for
control|(
name|symbolP1
operator|=
name|symbol_next
argument_list|(
name|s1
argument_list|)
init|;
name|symbolP1
operator|!=
name|s2
condition|;
name|symbolP1
operator|=
name|symbol_next
argument_list|(
name|symbolP1
argument_list|)
control|)
block|{
if|if
condition|(
name|symbolP1
operator|==
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
return|return;
if|if
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|symbolP1
argument_list|)
operator|==
name|N_FUN
condition|)
block|{
name|char
modifier|*
name|pnt
init|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP1
argument_list|)
argument_list|,
literal|':'
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'F'
operator|||
operator|*
name|pnt
operator|==
literal|'f'
condition|)
break|break;
block|}
empty_stmt|;
comment|/*        *	Deal with STAB symbols        */
if|if
condition|(
name|S_IS_DEBUG
argument_list|(
name|symbolP1
argument_list|)
condition|)
block|{
comment|/* 	   *	Dispatch on STAB type 	   */
switch|switch
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|symbolP1
argument_list|)
condition|)
block|{
case|case
name|N_LSYM
case|:
case|case
name|N_PSYM
case|:
name|VMS_local_stab_Parse
argument_list|(
name|symbolP1
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_RSYM
case|:
name|VMS_RSYM_Parse
argument_list|(
name|symbolP1
argument_list|,
name|Current_Routine
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*switch*/
block|}
comment|/* if */
block|}
comment|/* for */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This function crawls the symbol chain searching for local symbols that need  * to be described to the debugger.  When we enter a new scope with a "{", it  * creates a new "block", which helps the debugger keep track of which scope  * we are currently in.  */
end_comment

begin_function
specifier|static
name|symbolS
modifier|*
name|Define_Routine
parameter_list|(
name|symbolP
parameter_list|,
name|Level
parameter_list|)
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
name|int
name|Level
decl_stmt|;
block|{
name|symbolS
modifier|*
name|sstart
decl_stmt|;
name|symbolS
modifier|*
name|symbolP1
decl_stmt|;
name|char
name|str
index|[
literal|10
index|]
decl_stmt|;
name|int
name|rcount
init|=
literal|0
decl_stmt|;
name|int
name|Offset
decl_stmt|;
name|sstart
operator|=
name|symbolP
expr_stmt|;
for|for
control|(
name|symbolP1
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
init|;
name|symbolP1
condition|;
name|symbolP1
operator|=
name|symbol_next
argument_list|(
name|symbolP1
argument_list|)
control|)
block|{
if|if
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|symbolP1
argument_list|)
operator|==
name|N_FUN
condition|)
block|{
name|char
modifier|*
name|pnt
init|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|S_GET_NAME
argument_list|(
name|symbolP1
argument_list|)
argument_list|,
literal|':'
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|==
literal|'F'
operator|||
operator|*
name|pnt
operator|==
literal|'f'
condition|)
break|break;
block|}
empty_stmt|;
comment|/*        *	Deal with STAB symbols        */
if|if
condition|(
name|S_IS_DEBUG
argument_list|(
name|symbolP1
argument_list|)
condition|)
block|{
comment|/* 	   *	Dispatch on STAB type 	   */
switch|switch
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|symbolP1
argument_list|)
condition|)
block|{
case|case
name|N_LBRAC
case|:
if|if
condition|(
name|Level
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"$%d"
argument_list|,
name|rcount
operator|++
argument_list|)
expr_stmt|;
name|VMS_TBT_Block_Begin
argument_list|(
name|symbolP1
argument_list|,
name|Text_Psect
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|Offset
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP1
argument_list|)
expr_stmt|;
name|Define_Local_Symbols
argument_list|(
name|sstart
argument_list|,
name|symbolP1
argument_list|)
expr_stmt|;
name|symbolP1
operator|=
name|Define_Routine
argument_list|(
name|symbolP1
argument_list|,
name|Level
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Level
operator|!=
literal|0
condition|)
name|VMS_TBT_Block_End
argument_list|(
name|S_GET_VALUE
argument_list|(
name|symbolP1
argument_list|)
operator|-
name|Offset
argument_list|)
expr_stmt|;
name|sstart
operator|=
name|symbolP1
expr_stmt|;
break|break;
case|case
name|N_RBRAC
case|:
return|return
name|symbolP1
return|;
block|}
comment|/*switch*/
block|}
comment|/* if */
block|}
comment|/* for */
comment|/* we end up here if there were no brackets in this function. Define everything */
name|Define_Local_Symbols
argument_list|(
name|sstart
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|symbolP1
return|;
block|}
end_function

begin_escape
end_escape

begin_expr_stmt
specifier|static
name|VMS_DBG_Define_Routine
argument_list|(
argument|symbolP
argument_list|,
argument|Curr_Routine
argument_list|,
argument|Txt_Psect
argument_list|)
name|symbolS
operator|*
name|symbolP
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|symbolS
modifier|*
name|Curr_Routine
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Txt_Psect
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Current_Routine
operator|=
name|Curr_Routine
expr_stmt|;
name|Text_Psect
operator|=
name|Txt_Psect
expr_stmt|;
name|Define_Routine
argument_list|(
name|symbolP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|HO_VMS
end_ifndef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/* Manufacure a VMS like time on a unix based system. */
end_comment

begin_macro
name|get_VMS_time_on_unix
argument_list|(
argument|char *Now
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|pnt
decl_stmt|;
name|time_t
name|timeb
decl_stmt|;
name|time
argument_list|(
operator|&
name|timeb
argument_list|)
expr_stmt|;
name|pnt
operator|=
name|ctime
argument_list|(
operator|&
name|timeb
argument_list|)
expr_stmt|;
name|pnt
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|pnt
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
name|pnt
index|[
literal|10
index|]
operator|=
literal|0
expr_stmt|;
name|pnt
index|[
literal|16
index|]
operator|=
literal|0
expr_stmt|;
name|pnt
index|[
literal|24
index|]
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|Now
argument_list|,
literal|"%2s-%3s-%s %s"
argument_list|,
name|pnt
operator|+
literal|8
argument_list|,
name|pnt
operator|+
literal|4
argument_list|,
name|pnt
operator|+
literal|20
argument_list|,
name|pnt
operator|+
literal|11
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not HO_VMS */
end_comment

begin_comment
comment|/*  *	Write the MHD (Module Header) records  */
end_comment

begin_expr_stmt
specifier|static
name|Write_VMS_MHD_Records
argument_list|()
block|{
specifier|register
name|char
operator|*
name|cp
block|,
operator|*
name|cp1
block|;
specifier|register
name|int
name|i
block|;   struct
block|{
name|int
name|Size
block|;
name|char
operator|*
name|Ptr
block|;   }
name|Descriptor
block|;
name|char
name|Module_Name
index|[
literal|256
index|]
block|;
name|char
name|Now
index|[
literal|18
index|]
block|;
comment|/*    *	We are writing a module header record    */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ_S_C_HDR
argument_list|)
block|;
comment|/*    *	***************************    *	*MAIN MODULE HEADER RECORD*    *	***************************    *    *	Store record type and header type    */
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_HDR
argument_list|)
block|;
name|PUT_CHAR
argument_list|(
name|MHD_S_C_MHD
argument_list|)
block|;
comment|/*    *	Structure level is 0    */
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_STRLVL
argument_list|)
block|;
comment|/*    *	Maximum record size is size of the object record buffer    */
name|PUT_SHORT
argument_list|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
argument_list|)
block|;
comment|/*    *	Get module name (the FILENAME part of the object file)    */
name|cp
operator|=
name|out_file_name
block|;
name|cp1
operator|=
name|Module_Name
block|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|']'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'>'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|':'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'/'
operator|)
condition|)
block|{
name|cp1
operator|=
name|Module_Name
expr_stmt|;
name|cp
operator|++
expr_stmt|;
continue|continue;
block|}
operator|*
name|cp1
operator|++
operator|=
name|islower
argument_list|(
operator|*
name|cp
argument_list|)
condition|?
name|toupper
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
else|:
operator|*
name|cp
operator|++
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}   *
name|cp1
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*    *	Limit it to 31 characters and store in the object record    */
end_comment

begin_while
while|while
condition|(
operator|--
name|cp1
operator|>=
name|Module_Name
condition|)
if|if
condition|(
operator|*
name|cp1
operator|==
literal|'.'
condition|)
operator|*
name|cp1
operator|=
literal|0
expr_stmt|;
end_while

begin_if
if|if
condition|(
name|strlen
argument_list|(
name|Module_Name
argument_list|)
operator|>
literal|31
condition|)
block|{
if|if
condition|(
name|flagseen
index|[
literal|'+'
index|]
condition|)
name|printf
argument_list|(
literal|"%s: Module name truncated: %s\n"
argument_list|,
name|myname
argument_list|,
name|Module_Name
argument_list|)
expr_stmt|;
name|Module_Name
index|[
literal|31
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|PUT_COUNTED_STRING
argument_list|(
name|Module_Name
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*    *	Module Version is "V1.0"    */
end_comment

begin_expr_stmt
name|PUT_COUNTED_STRING
argument_list|(
literal|"V1.0"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*    *	Creation time is "now" (17 chars of time string)    */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HO_VMS
end_ifndef

begin_expr_stmt
name|get_VMS_time_on_unix
argument_list|(
operator|&
name|Now
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* HO_VMS */
end_comment

begin_expr_stmt
name|Descriptor
operator|.
name|Size
operator|=
literal|17
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Descriptor
operator|.
name|Ptr
operator|=
name|Now
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|sys$asctim
argument_list|(
literal|0
argument_list|,
operator|&
name|Descriptor
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HO_VMS */
end_comment

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|17
condition|;
name|i
operator|++
control|)
name|PUT_CHAR
argument_list|(
name|Now
index|[
name|i
index|]
argument_list|)
expr_stmt|;
end_for

begin_comment
comment|/*    *	Patch time is "never" (17 zeros)    */
end_comment

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|17
condition|;
name|i
operator|++
control|)
name|PUT_CHAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_for

begin_comment
comment|/*    *	Flush the record    */
end_comment

begin_expr_stmt
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*    *	*************************    *	*LANGUAGE PROCESSOR NAME*    *	*************************    *    *	Store record type and header type    */
end_comment

begin_expr_stmt
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_HDR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PUT_CHAR
argument_list|(
name|MHD_S_C_LNM
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*    *	Store language processor name and version    *	(not a counted string!)    */
end_comment

begin_expr_stmt
name|cp
operator|=
name|compiler_version_string
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
block|{
name|cp
operator|=
literal|"GNU AS  V"
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|PUT_CHAR
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
operator|&
name|version_string
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|' '
condition|)
name|cp
operator|--
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
end_if

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_while
while|while
condition|(
operator|*
name|cp
operator|>=
literal|32
condition|)
name|PUT_CHAR
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
end_while

begin_comment
comment|/*    *	Flush the record    */
end_comment

begin_expr_stmt
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
end_expr_stmt

begin_escape
unit|}
end_escape

begin_comment
comment|/*  *	Write the EOM (End Of Module) record  */
end_comment

begin_macro
unit|static
name|Write_VMS_EOM_Record
argument_list|(
argument|Psect
argument_list|,
argument|Offset
argument_list|)
end_macro

begin_decl_stmt
name|int
name|Psect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Offset
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/*    *	We are writing an end-of-module record    */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ_S_C_EOM
argument_list|)
expr_stmt|;
comment|/*    *	Store record Type    */
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_EOM
argument_list|)
expr_stmt|;
comment|/*    *	Store the error severity (0)    */
name|PUT_CHAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*    *	Store the entry point, if it exists    */
if|if
condition|(
name|Psect
operator|>=
literal|0
condition|)
block|{
comment|/*        *	Store the entry point Psect        */
name|PUT_CHAR
argument_list|(
name|Psect
argument_list|)
expr_stmt|;
comment|/*        *	Store the entry point Psect offset        */
name|PUT_LONG
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
block|}
comment|/*    *	Flush the record    */
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* this hash routine borrowed from GNU-EMACS, and strengthened slightly  ERY*/
end_comment

begin_function
specifier|static
name|int
name|hash_string
parameter_list|(
name|ptr
parameter_list|)
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
block|{
specifier|register
name|unsigned
name|char
modifier|*
name|p
init|=
name|ptr
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|end
init|=
name|p
operator|+
name|strlen
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|char
name|c
decl_stmt|;
specifier|register
name|int
name|hash
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
condition|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|hash
operator|=
operator|(
operator|(
name|hash
operator|<<
literal|3
operator|)
operator|+
operator|(
name|hash
operator|<<
literal|15
operator|)
operator|+
operator|(
name|hash
operator|>>
literal|28
operator|)
operator|+
name|c
operator|)
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
end_function

begin_comment
comment|/*  *	Generate a Case-Hacked VMS symbol name (limited to 31 chars)  */
end_comment

begin_expr_stmt
specifier|static
name|VMS_Case_Hack_Symbol
argument_list|(
name|In
argument_list|,
name|Out
argument_list|)
specifier|register
name|char
operator|*
name|In
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|Out
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|int
name|init
init|=
literal|0
decl_stmt|;
name|long
name|int
name|result
decl_stmt|;
name|char
modifier|*
name|pnt
decl_stmt|;
name|char
modifier|*
name|new_name
decl_stmt|;
name|char
modifier|*
name|old_name
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|destructor
init|=
literal|0
decl_stmt|;
comment|/*hack to allow for case sens in a destructor*/
name|int
name|truncate
init|=
literal|0
decl_stmt|;
name|int
name|Case_Hack_Bits
init|=
literal|0
decl_stmt|;
name|int
name|Saw_Dollar
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|Hex_Table
index|[
literal|16
index|]
init|=
block|{
literal|'0'
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
literal|'7'
block|,
literal|'8'
block|,
literal|'9'
block|,
literal|'A'
block|,
literal|'B'
block|,
literal|'C'
block|,
literal|'D'
block|,
literal|'E'
block|,
literal|'F'
block|}
decl_stmt|;
comment|/*    *	Kill any leading "_"    */
if|if
condition|(
operator|(
name|In
index|[
literal|0
index|]
operator|==
literal|'_'
operator|)
operator|&&
operator|(
operator|(
name|In
index|[
literal|1
index|]
operator|>
literal|'9'
operator|)
operator|||
operator|(
name|In
index|[
literal|1
index|]
operator|<
literal|'0'
operator|)
operator|)
condition|)
name|In
operator|++
expr_stmt|;
name|new_name
operator|=
name|Out
expr_stmt|;
comment|/* save this for later*/
if|#
directive|if
name|barfoo
comment|/* Dead code */
if|if
condition|(
operator|(
name|In
index|[
literal|0
index|]
operator|==
literal|'_'
operator|)
operator|&&
operator|(
name|In
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
operator|&&
operator|(
name|In
index|[
literal|2
index|]
operator|==
literal|'_'
operator|)
condition|)
name|destructor
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* We may need to truncate the symbol, save the hash for later*/
if|if
condition|(
name|strlen
argument_list|(
name|In
argument_list|)
operator|>
literal|23
condition|)
name|result
operator|=
name|hash_string
argument_list|(
name|In
argument_list|)
expr_stmt|;
comment|/*    *	Is there a Psect Attribute to skip??    */
if|if
condition|(
name|HAS_PSECT_ATTRIBUTES
argument_list|(
name|In
argument_list|)
condition|)
block|{
comment|/*        *	Yes: Skip it        */
name|In
operator|+=
name|PSECT_ATTRIBUTES_STRING_LENGTH
expr_stmt|;
while|while
condition|(
operator|*
name|In
condition|)
block|{
if|if
condition|(
operator|(
name|In
index|[
literal|0
index|]
operator|==
literal|'$'
operator|)
operator|&&
operator|(
name|In
index|[
literal|1
index|]
operator|==
literal|'$'
operator|)
condition|)
block|{
name|In
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
name|In
operator|++
expr_stmt|;
block|}
block|}
name|old_name
operator|=
name|In
expr_stmt|;
comment|/*	if (strlen(In)> 31&& flagseen['+']) 		printf("%s: Symbol name truncated: %s\n",myname,In);*/
comment|/*    *	Do the case conversion    */
name|i
operator|=
literal|23
expr_stmt|;
comment|/* Maximum of 23 chars */
while|while
condition|(
operator|*
name|In
operator|&&
operator|(
operator|--
name|i
operator|>=
literal|0
operator|)
condition|)
block|{
name|Case_Hack_Bits
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|In
operator|==
literal|'$'
condition|)
name|Saw_Dollar
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|destructor
operator|==
literal|1
operator|)
operator|&&
operator|(
name|i
operator|==
literal|21
operator|)
condition|)
name|Saw_Dollar
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|vms_name_mapping
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|In
argument_list|)
condition|)
block|{
operator|*
name|Out
operator|++
operator|=
operator|*
name|In
operator|++
expr_stmt|;
name|Case_Hack_Bits
operator||=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|Out
operator|++
operator|=
name|islower
argument_list|(
operator|*
name|In
argument_list|)
condition|?
name|toupper
argument_list|(
operator|*
name|In
operator|++
argument_list|)
else|:
operator|*
name|In
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
operator|*
name|Out
operator|++
operator|=
operator|*
name|In
operator|++
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|islower
argument_list|(
operator|*
name|In
argument_list|)
condition|)
block|{
operator|*
name|Out
operator|++
operator|=
operator|*
name|In
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|Out
operator|++
operator|=
name|isupper
argument_list|(
operator|*
name|In
argument_list|)
condition|?
name|tolower
argument_list|(
operator|*
name|In
operator|++
argument_list|)
else|:
operator|*
name|In
operator|++
expr_stmt|;
block|}
break|break;
block|}
empty_stmt|;
block|}
comment|/*    *	If we saw a dollar sign, we don't do case hacking    */
if|if
condition|(
name|flagseen
index|[
literal|'h'
index|]
operator|||
name|Saw_Dollar
condition|)
name|Case_Hack_Bits
operator|=
literal|0
expr_stmt|;
comment|/*    *	If we have more than 23 characters and everything is lowercase    *	we can insert the full 31 characters    */
if|if
condition|(
operator|*
name|In
condition|)
block|{
comment|/*        *	We  have more than 23 characters        * If we must add the case hack, then we have truncated the str        */
name|pnt
operator|=
name|Out
expr_stmt|;
name|truncate
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|Case_Hack_Bits
operator|==
literal|0
condition|)
block|{
comment|/* 	   *	And so far they are all lower case: 	   *		Check up to 8 more characters 	   *		and ensure that they are lowercase 	   */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|In
index|[
name|i
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|i
operator|<
literal|8
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
name|In
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|Saw_Dollar
operator|&&
operator|!
name|flagseen
index|[
literal|'h'
index|]
condition|)
break|break;
if|if
condition|(
name|In
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|truncate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
literal|8
operator|)
operator|||
operator|(
name|In
index|[
name|i
index|]
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 	       *	They are:  Copy up to 31 characters 	       *			to the output string 	       */
name|i
operator|=
literal|8
expr_stmt|;
while|while
condition|(
operator|(
operator|--
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|*
name|In
operator|)
condition|)
switch|switch
condition|(
name|vms_name_mapping
condition|)
block|{
case|case
literal|0
case|:
operator|*
name|Out
operator|++
operator|=
name|islower
argument_list|(
operator|*
name|In
argument_list|)
condition|?
name|toupper
argument_list|(
operator|*
name|In
operator|++
argument_list|)
else|:
operator|*
name|In
operator|++
expr_stmt|;
break|break;
case|case
literal|3
case|:
operator|*
name|Out
operator|++
operator|=
operator|*
name|In
operator|++
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|Out
operator|++
operator|=
name|isupper
argument_list|(
operator|*
name|In
argument_list|)
condition|?
name|tolower
argument_list|(
operator|*
name|In
operator|++
argument_list|)
else|:
operator|*
name|In
operator|++
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
block|}
block|}
comment|/*    *	If there were any uppercase characters in the name we    *	take on the case hacking string    */
comment|/* Old behavior for regular GNU-C compiler */
if|if
condition|(
operator|!
name|flagseen
index|[
literal|'+'
index|]
condition|)
name|truncate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|Case_Hack_Bits
operator|!=
literal|0
operator|)
operator|||
operator|(
name|truncate
operator|==
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|truncate
operator|==
literal|0
condition|)
block|{
operator|*
name|Out
operator|++
operator|=
literal|'_'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|Out
operator|++
operator|=
name|Hex_Table
index|[
name|Case_Hack_Bits
operator|&
literal|0xf
index|]
expr_stmt|;
name|Case_Hack_Bits
operator|>>=
literal|4
expr_stmt|;
block|}
operator|*
name|Out
operator|++
operator|=
literal|'X'
expr_stmt|;
block|}
else|else
block|{
name|Out
operator|=
name|pnt
expr_stmt|;
comment|/*Cut back to 23 characters maximum */
operator|*
name|Out
operator|++
operator|=
literal|'_'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|init
operator|=
name|result
operator|&
literal|0x01f
expr_stmt|;
if|if
condition|(
name|init
operator|<
literal|10
condition|)
operator|*
name|Out
operator|++
operator|=
literal|'0'
operator|+
name|init
expr_stmt|;
else|else
operator|*
name|Out
operator|++
operator|=
literal|'A'
operator|+
name|init
operator|-
literal|10
expr_stmt|;
name|result
operator|=
name|result
operator|>>
literal|5
expr_stmt|;
block|}
block|}
block|}
comment|/*Case Hack */
comment|/*    *	Done    */
operator|*
name|Out
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|truncate
operator|==
literal|1
operator|&&
name|flagseen
index|[
literal|'+'
index|]
operator|&&
name|flagseen
index|[
literal|'H'
index|]
condition|)
name|printf
argument_list|(
literal|"%s: Symbol %s replaced by %s\n"
argument_list|,
name|myname
argument_list|,
name|old_name
argument_list|,
name|new_name
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Scan a symbol name for a psect attribute specification  */
end_comment

begin_define
define|#
directive|define
name|GLOBALSYMBOL_BIT
value|0x10000
end_define

begin_define
define|#
directive|define
name|GLOBALVALUE_BIT
value|0x20000
end_define

begin_expr_stmt
specifier|static
name|VMS_Modify_Psect_Attributes
argument_list|(
argument|Name
argument_list|,
argument|Attribute_Pointer
argument_list|)
name|char
operator|*
name|Name
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
modifier|*
name|Attribute_Pointer
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|Negate
decl_stmt|;
specifier|static
struct|struct
block|{
name|char
modifier|*
name|Name
decl_stmt|;
name|int
name|Value
decl_stmt|;
block|}
name|Attributes
index|[]
init|=
block|{
block|{
literal|"PIC"
block|,
name|GPS_S_M_PIC
block|}
block|,
block|{
literal|"LIB"
block|,
name|GPS_S_M_LIB
block|}
block|,
block|{
literal|"OVR"
block|,
name|GPS_S_M_OVR
block|}
block|,
block|{
literal|"REL"
block|,
name|GPS_S_M_REL
block|}
block|,
block|{
literal|"GBL"
block|,
name|GPS_S_M_GBL
block|}
block|,
block|{
literal|"SHR"
block|,
name|GPS_S_M_SHR
block|}
block|,
block|{
literal|"EXE"
block|,
name|GPS_S_M_EXE
block|}
block|,
block|{
literal|"RD"
block|,
name|GPS_S_M_RD
block|}
block|,
block|{
literal|"WRT"
block|,
name|GPS_S_M_WRT
block|}
block|,
block|{
literal|"VEC"
block|,
name|GPS_S_M_VEC
block|}
block|,
block|{
literal|"GLOBALSYMBOL"
block|,
name|GLOBALSYMBOL_BIT
block|}
block|,
block|{
literal|"GLOBALVALUE"
block|,
name|GLOBALVALUE_BIT
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
comment|/*    *	Kill leading "_"    */
if|if
condition|(
operator|*
name|Name
operator|==
literal|'_'
condition|)
name|Name
operator|++
expr_stmt|;
comment|/*    *	Check for a PSECT attribute list    */
if|if
condition|(
operator|!
name|HAS_PSECT_ATTRIBUTES
argument_list|(
name|Name
argument_list|)
condition|)
return|return;
comment|/* If not, return */
comment|/*    *	Skip the attribute list indicator    */
name|Name
operator|+=
name|PSECT_ATTRIBUTES_STRING_LENGTH
expr_stmt|;
comment|/*    *	Process the attributes ("_" separated, "$" terminated)    */
while|while
condition|(
operator|*
name|Name
operator|!=
literal|'$'
condition|)
block|{
comment|/*        *	Assume not negating        */
name|Negate
operator|=
literal|0
expr_stmt|;
comment|/*        *	Check for "NO"        */
if|if
condition|(
operator|(
name|Name
index|[
literal|0
index|]
operator|==
literal|'N'
operator|)
operator|&&
operator|(
name|Name
index|[
literal|1
index|]
operator|==
literal|'O'
operator|)
condition|)
block|{
comment|/* 	   *	We are negating (and skip the NO) 	   */
name|Negate
operator|=
literal|1
expr_stmt|;
name|Name
operator|+=
literal|2
expr_stmt|;
block|}
comment|/*        *	Find the token delimiter        */
name|cp
operator|=
name|Name
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|'_'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|'$'
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
comment|/*        *	Look for the token in the attribute list        */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|Attributes
index|[
name|i
index|]
operator|.
name|Name
condition|;
name|i
operator|++
control|)
block|{
comment|/* 	   *	If the strings match, set/clear the attr. 	   */
if|if
condition|(
name|strncmp
argument_list|(
name|Name
argument_list|,
name|Attributes
index|[
name|i
index|]
operator|.
name|Name
argument_list|,
name|cp
operator|-
name|Name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 	       *	Set or clear 	       */
if|if
condition|(
name|Negate
condition|)
operator|*
name|Attribute_Pointer
operator|&=
operator|~
name|Attributes
index|[
name|i
index|]
operator|.
name|Value
expr_stmt|;
else|else
operator|*
name|Attribute_Pointer
operator||=
name|Attributes
index|[
name|i
index|]
operator|.
name|Value
expr_stmt|;
comment|/* 	       *	Done 	       */
break|break;
block|}
block|}
comment|/*        *	Now skip the attribute        */
name|Name
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|*
name|Name
operator|==
literal|'_'
condition|)
name|Name
operator|++
expr_stmt|;
block|}
comment|/*    *	Done    */
return|return;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Define a global symbol  */
end_comment

begin_expr_stmt
specifier|static
name|VMS_Global_Symbol_Spec
argument_list|(
argument|Name
argument_list|,
argument|Psect_Number
argument_list|,
argument|Psect_Offset
argument_list|,
argument|Defined
argument_list|)
name|char
operator|*
name|Name
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|Psect_Number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Psect_Offset
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|Local
index|[
literal|32
index|]
decl_stmt|;
comment|/*    *	We are writing a GSD record    */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ_S_C_GSD
argument_list|)
expr_stmt|;
comment|/*    *	If the buffer is empty we must insert the GSD record type    */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_GSD
argument_list|)
expr_stmt|;
comment|/*    *	We are writing a Global symbol definition subrecord    */
if|if
condition|(
name|Psect_Number
operator|<=
literal|255
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|GSD_S_C_SYM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_CHAR
argument_list|(
name|GSD_S_C_SYMW
argument_list|)
expr_stmt|;
block|}
comment|/*    *	Data type is undefined    */
name|PUT_CHAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*    *	Switch on Definition/Reference    */
if|if
condition|(
operator|(
name|Defined
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/*        *	Definition:        *	Flags = "RELOCATABLE" and "DEFINED" for regular symbol        *	      = "DEFINED" for globalvalue (Defined& 2 == 1)        */
if|if
condition|(
operator|(
name|Defined
operator|&
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
name|PUT_SHORT
argument_list|(
name|GSY_S_M_DEF
operator||
name|GSY_S_M_REL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_SHORT
argument_list|(
name|GSY_S_M_DEF
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/*        *	Psect Number        */
if|if
condition|(
name|Psect_Number
operator|<=
literal|255
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|Psect_Number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_SHORT
argument_list|(
name|Psect_Number
argument_list|)
expr_stmt|;
block|}
comment|/*        *	Offset        */
name|PUT_LONG
argument_list|(
name|Psect_Offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*        *	Reference:        *	Flags = "RELOCATABLE" for regular symbol,        *	      = "" for globalvalue (Defined& 2 == 1)        */
if|if
condition|(
operator|(
name|Defined
operator|&
literal|2
operator|)
operator|==
literal|0
condition|)
block|{
name|PUT_SHORT
argument_list|(
name|GSY_S_M_REL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_SHORT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
comment|/*    *	Finally, the global symbol name    */
name|VMS_Case_Hack_Symbol
argument_list|(
name|Name
argument_list|,
name|Local
argument_list|)
expr_stmt|;
name|PUT_COUNTED_STRING
argument_list|(
name|Local
argument_list|)
expr_stmt|;
comment|/*    *	Flush the buffer if it is more than 75% full    */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Define a psect  */
end_comment

begin_function
specifier|static
name|int
name|VMS_Psect_Spec
parameter_list|(
name|Name
parameter_list|,
name|Size
parameter_list|,
name|Type
parameter_list|,
name|vsp
parameter_list|)
name|char
modifier|*
name|Name
decl_stmt|;
name|int
name|Size
decl_stmt|;
name|char
modifier|*
name|Type
decl_stmt|;
name|struct
name|VMS_Symbol
modifier|*
name|vsp
decl_stmt|;
block|{
name|char
name|Local
index|[
literal|32
index|]
decl_stmt|;
name|int
name|Psect_Attributes
decl_stmt|;
comment|/*    *	Generate the appropriate PSECT flags given the PSECT type    */
if|if
condition|(
name|strcmp
argument_list|(
name|Type
argument_list|,
literal|"COMMON"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/*        *	Common block psects are:  PIC,OVR,REL,GBL,SHR,RD,WRT        */
name|Psect_Attributes
operator|=
operator|(
name|GPS_S_M_PIC
operator||
name|GPS_S_M_OVR
operator||
name|GPS_S_M_REL
operator||
name|GPS_S_M_GBL
operator||
name|GPS_S_M_SHR
operator||
name|GPS_S_M_RD
operator||
name|GPS_S_M_WRT
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|Type
argument_list|,
literal|"CONST"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/*        *	Common block psects are:  PIC,OVR,REL,GBL,SHR,RD        */
name|Psect_Attributes
operator|=
operator|(
name|GPS_S_M_PIC
operator||
name|GPS_S_M_OVR
operator||
name|GPS_S_M_REL
operator||
name|GPS_S_M_GBL
operator||
name|GPS_S_M_SHR
operator||
name|GPS_S_M_RD
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|Type
argument_list|,
literal|"DATA"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/*        *	The Data psects are PIC,REL,RD,WRT        */
name|Psect_Attributes
operator|=
operator|(
name|GPS_S_M_PIC
operator||
name|GPS_S_M_REL
operator||
name|GPS_S_M_RD
operator||
name|GPS_S_M_WRT
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|Type
argument_list|,
literal|"TEXT"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/*        *	The Text psects are PIC,REL,SHR,EXE,RD        */
name|Psect_Attributes
operator|=
operator|(
name|GPS_S_M_PIC
operator||
name|GPS_S_M_REL
operator||
name|GPS_S_M_SHR
operator||
name|GPS_S_M_EXE
operator||
name|GPS_S_M_RD
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/*        *	Error: Unknown psect type        */
name|error
argument_list|(
literal|"Unknown VMS psect type"
argument_list|)
expr_stmt|;
block|}
comment|/*    *	Modify the psect attributes according to any attribute string    */
if|if
condition|(
name|HAS_PSECT_ATTRIBUTES
argument_list|(
name|Name
argument_list|)
condition|)
name|VMS_Modify_Psect_Attributes
argument_list|(
name|Name
argument_list|,
operator|&
name|Psect_Attributes
argument_list|)
expr_stmt|;
comment|/*    *	Check for globalref/def/val.    */
if|if
condition|(
operator|(
name|Psect_Attributes
operator|&
name|GLOBALVALUE_BIT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/*        * globalvalue symbols were generated before. This code        * prevents unsightly psect buildup, and makes sure that        * fixup references are emitted correctly.        */
name|vsp
operator|->
name|Psect_Index
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* to catch errors */
name|S_GET_RAW_TYPE
argument_list|(
name|vsp
operator|->
name|Symbol
argument_list|)
operator|=
name|N_UNDF
expr_stmt|;
comment|/* make refs work */
return|return
literal|1
return|;
comment|/* decrement psect counter */
block|}
empty_stmt|;
if|if
condition|(
operator|(
name|Psect_Attributes
operator|&
name|GLOBALSYMBOL_BIT
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|vsp
operator|->
name|Symbol
argument_list|)
condition|)
block|{
case|case
name|N_UNDF
operator||
name|N_EXT
case|:
name|VMS_Global_Symbol_Spec
argument_list|(
name|Name
argument_list|,
name|vsp
operator|->
name|Psect_Index
argument_list|,
name|vsp
operator|->
name|Psect_Offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Psect_Index
operator|=
operator|-
literal|1
expr_stmt|;
name|S_GET_RAW_TYPE
argument_list|(
name|vsp
operator|->
name|Symbol
argument_list|)
operator|=
name|N_UNDF
expr_stmt|;
return|return
literal|1
return|;
comment|/* return and indicate no psect */
case|case
name|N_DATA
operator||
name|N_EXT
case|:
name|VMS_Global_Symbol_Spec
argument_list|(
name|Name
argument_list|,
name|vsp
operator|->
name|Psect_Index
argument_list|,
name|vsp
operator|->
name|Psect_Offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* In this case we still generate the psect */
break|break;
default|default:
block|{
name|char
name|Error_Line
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|Error_Line
argument_list|,
literal|"Globalsymbol attribute for"
literal|" symbol %s was unexpected.\n"
argument_list|,
name|Name
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|Error_Line
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/* switch */
block|}
empty_stmt|;
name|Psect_Attributes
operator|&=
literal|0xffff
expr_stmt|;
comment|/* clear out the globalref/def stuff */
comment|/*    *	We are writing a GSD record    */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ_S_C_GSD
argument_list|)
expr_stmt|;
comment|/*    *	If the buffer is empty we must insert the GSD record type    */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_GSD
argument_list|)
expr_stmt|;
comment|/*    *	We are writing a PSECT definition subrecord    */
name|PUT_CHAR
argument_list|(
name|GSD_S_C_PSC
argument_list|)
expr_stmt|;
comment|/*    *	Psects are always LONGWORD aligned    */
name|PUT_CHAR
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/*    *	Specify the psect attributes    */
name|PUT_SHORT
argument_list|(
name|Psect_Attributes
argument_list|)
expr_stmt|;
comment|/*    *	Specify the allocation    */
name|PUT_LONG
argument_list|(
name|Size
argument_list|)
expr_stmt|;
comment|/*    *	Finally, the psect name    */
name|VMS_Case_Hack_Symbol
argument_list|(
name|Name
argument_list|,
name|Local
argument_list|)
expr_stmt|;
name|PUT_COUNTED_STRING
argument_list|(
name|Local
argument_list|)
expr_stmt|;
comment|/*    *	Flush the buffer if it is more than 75% full    */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	Given the pointer to a symbol we calculate how big the data at the  *	symbol is.  We do this by looking for the next symbol (local or  *	global) which will indicate the start of another datum.  */
end_comment

begin_function
specifier|static
name|int
name|VMS_Initialized_Data_Size
parameter_list|(
name|sp
parameter_list|,
name|End_Of_Data
parameter_list|)
specifier|register
name|struct
name|symbol
modifier|*
name|sp
decl_stmt|;
name|int
name|End_Of_Data
decl_stmt|;
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sp1
decl_stmt|,
modifier|*
name|Next_Symbol
decl_stmt|;
comment|/*    *	Find the next symbol    *	it delimits this datum    */
name|Next_Symbol
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sp1
operator|=
name|symbol_rootP
init|;
name|sp1
condition|;
name|sp1
operator|=
name|symbol_next
argument_list|(
name|sp1
argument_list|)
control|)
block|{
comment|/*        *	The data type must match        */
if|if
condition|(
name|S_GET_TYPE
argument_list|(
name|sp1
argument_list|)
operator|!=
name|N_DATA
condition|)
continue|continue;
comment|/*        *	The symbol must be AFTER this symbol        */
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|sp1
argument_list|)
operator|<=
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
condition|)
continue|continue;
comment|/*        *	We ignore THIS symbol        */
if|if
condition|(
name|sp1
operator|==
name|sp
condition|)
continue|continue;
comment|/*        *	If there is already a candidate selected for the        *	next symbol, see if we are a better candidate        */
if|if
condition|(
name|Next_Symbol
condition|)
block|{
comment|/* 	   *	We are a better candidate if we are "closer" 	   *	to the symbol 	   */
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|sp1
argument_list|)
operator|>
name|S_GET_VALUE
argument_list|(
name|Next_Symbol
argument_list|)
condition|)
continue|continue;
comment|/* 	   *	Win:  Make this the candidate 	   */
name|Next_Symbol
operator|=
name|sp1
expr_stmt|;
block|}
else|else
block|{
comment|/* 	   *	This is the 1st candidate 	   */
name|Next_Symbol
operator|=
name|sp1
expr_stmt|;
block|}
block|}
comment|/*    *	Calculate its size    */
return|return
operator|(
name|Next_Symbol
condition|?
operator|(
name|S_GET_VALUE
argument_list|(
name|Next_Symbol
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
operator|)
else|:
operator|(
name|End_Of_Data
operator|-
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *	Check symbol names for the Psect hack with a globalvalue, and then  *	generate globalvalues for those that have it.  */
end_comment

begin_expr_stmt
specifier|static
name|VMS_Emit_Globalvalues
argument_list|(
argument|text_siz
argument_list|,
argument|data_siz
argument_list|,
argument|Data_Segment
argument_list|)
name|unsigned
name|text_siz
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|unsigned
name|data_siz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Data_Segment
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|symbolS
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|stripped_name
decl_stmt|,
modifier|*
name|Name
decl_stmt|;
name|int
name|Size
decl_stmt|;
name|int
name|Psect_Attributes
decl_stmt|;
name|int
name|globalvalue
decl_stmt|;
comment|/*    * Scan the symbol table for globalvalues, and emit def/ref when    * required.  These will be caught again later and converted to    * N_UNDF    */
for|for
control|(
name|sp
operator|=
name|symbol_rootP
init|;
name|sp
condition|;
name|sp
operator|=
name|sp
operator|->
name|sy_next
control|)
block|{
comment|/*        *	See if this is something we want to look at.        */
if|if
condition|(
operator|(
name|S_GET_RAW_TYPE
argument_list|(
name|sp
argument_list|)
operator|!=
operator|(
name|N_DATA
operator||
name|N_EXT
operator|)
operator|)
operator|&&
operator|(
name|S_GET_RAW_TYPE
argument_list|(
name|sp
argument_list|)
operator|!=
operator|(
name|N_UNDF
operator||
name|N_EXT
operator|)
operator|)
condition|)
continue|continue;
comment|/*        *	See if this has globalvalue specification.        */
name|Name
operator|=
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HAS_PSECT_ATTRIBUTES
argument_list|(
name|Name
argument_list|)
condition|)
continue|continue;
name|stripped_name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|Name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|stripped_name
argument_list|,
name|Name
argument_list|)
expr_stmt|;
name|Psect_Attributes
operator|=
literal|0
expr_stmt|;
name|VMS_Modify_Psect_Attributes
argument_list|(
name|stripped_name
argument_list|,
operator|&
name|Psect_Attributes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Psect_Attributes
operator|&
name|GLOBALVALUE_BIT
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|sp
argument_list|)
condition|)
block|{
case|case
name|N_UNDF
operator||
name|N_EXT
case|:
name|VMS_Global_Symbol_Spec
argument_list|(
name|stripped_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_DATA
operator||
name|N_EXT
case|:
name|Size
operator|=
name|VMS_Initialized_Data_Size
argument_list|(
name|sp
argument_list|,
name|text_siz
operator|+
name|data_siz
argument_list|)
expr_stmt|;
if|if
condition|(
name|Size
operator|>
literal|4
condition|)
name|error
argument_list|(
literal|"Invalid data type for globalvalue"
argument_list|)
expr_stmt|;
name|globalvalue
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|globalvalue
argument_list|,
name|Data_Segment
operator|+
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
operator|-
name|text_siz
argument_list|,
name|Size
argument_list|)
expr_stmt|;
comment|/* Three times for good luck.  The linker seems to get confused 	         if there are fewer than three */
name|VMS_Global_Symbol_Spec
argument_list|(
name|stripped_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|VMS_Global_Symbol_Spec
argument_list|(
name|stripped_name
argument_list|,
literal|0
argument_list|,
name|globalvalue
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|VMS_Global_Symbol_Spec
argument_list|(
name|stripped_name
argument_list|,
literal|0
argument_list|,
name|globalvalue
argument_list|,
literal|3
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|" Invalid globalvalue of %s\n"
argument_list|,
name|stripped_name
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
comment|/* switch */
block|}
empty_stmt|;
comment|/* if */
name|free
argument_list|(
name|stripped_name
argument_list|)
expr_stmt|;
comment|/* clean up */
block|}
empty_stmt|;
comment|/* for */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Define a procedure entry pt/mask  */
end_comment

begin_expr_stmt
specifier|static
name|VMS_Procedure_Entry_Pt
argument_list|(
argument|Name
argument_list|,
argument|Psect_Number
argument_list|,
argument|Psect_Offset
argument_list|,
argument|Entry_Mask
argument_list|)
name|char
operator|*
name|Name
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|Psect_Number
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Psect_Offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Entry_Mask
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|Local
index|[
literal|32
index|]
decl_stmt|;
comment|/*    *	We are writing a GSD record    */
name|Set_VMS_Object_File_Record
argument_list|(
name|OBJ_S_C_GSD
argument_list|)
expr_stmt|;
comment|/*    *	If the buffer is empty we must insert the GSD record type    */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|OBJ_S_C_GSD
argument_list|)
expr_stmt|;
comment|/*    *	We are writing a Procedure Entry Pt/Mask subrecord    */
if|if
condition|(
name|Psect_Number
operator|<=
literal|255
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|GSD_S_C_EPM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_CHAR
argument_list|(
name|GSD_S_C_EPMW
argument_list|)
expr_stmt|;
block|}
comment|/*    *	Data type is undefined    */
name|PUT_CHAR
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*    *	Flags = "RELOCATABLE" and "DEFINED"    */
name|PUT_SHORT
argument_list|(
name|GSY_S_M_DEF
operator||
name|GSY_S_M_REL
argument_list|)
expr_stmt|;
comment|/*    *	Psect Number    */
if|if
condition|(
name|Psect_Number
operator|<=
literal|255
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|Psect_Number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_SHORT
argument_list|(
name|Psect_Number
argument_list|)
expr_stmt|;
block|}
comment|/*    *	Offset    */
name|PUT_LONG
argument_list|(
name|Psect_Offset
argument_list|)
expr_stmt|;
comment|/*    *	Entry mask    */
name|PUT_SHORT
argument_list|(
name|Entry_Mask
argument_list|)
expr_stmt|;
comment|/*    *	Finally, the global symbol name    */
name|VMS_Case_Hack_Symbol
argument_list|(
name|Name
argument_list|,
name|Local
argument_list|)
expr_stmt|;
name|PUT_COUNTED_STRING
argument_list|(
name|Local
argument_list|)
expr_stmt|;
comment|/*    *	Flush the buffer if it is more than 75% full    */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Set the current location counter to a particular Psect and Offset  */
end_comment

begin_expr_stmt
specifier|static
name|VMS_Set_Psect
argument_list|(
argument|Psect_Index
argument_list|,
argument|Offset
argument_list|,
argument|Record_Type
argument_list|)
name|int
name|Psect_Index
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|Offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Record_Type
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/*    *	We are writing a "Record_Type" record    */
name|Set_VMS_Object_File_Record
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/*    *	If the buffer is empty we must insert the record type    */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/*    *	Stack the Psect base + Longword Offset    */
if|if
condition|(
name|Psect_Index
operator|<
literal|255
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_PL
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|Psect_Index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_WPL
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|Psect_Index
argument_list|)
expr_stmt|;
block|}
name|PUT_LONG
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
comment|/*    *	Set relocation base    */
name|PUT_CHAR
argument_list|(
name|TIR_S_C_CTL_SETRB
argument_list|)
expr_stmt|;
comment|/*    *	Flush the buffer if it is more than 75% full    */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Store repeated immediate data in current Psect  */
end_comment

begin_expr_stmt
specifier|static
name|VMS_Store_Repeated_Data
argument_list|(
argument|Repeat_Count
argument_list|,
argument|Pointer
argument_list|,
argument|Size
argument_list|,
argument|Record_Type
argument_list|)
name|int
name|Repeat_Count
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|Pointer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Record_Type
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/*    *	Ignore zero bytes/words/longwords    */
if|if
condition|(
operator|(
name|Size
operator|==
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
operator|&&
operator|(
operator|*
name|Pointer
operator|==
literal|0
operator|)
condition|)
return|return;
if|if
condition|(
operator|(
name|Size
operator|==
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|)
operator|&&
operator|(
operator|*
operator|(
name|short
operator|*
operator|)
name|Pointer
operator|==
literal|0
operator|)
condition|)
return|return;
if|if
condition|(
operator|(
name|Size
operator|==
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
operator|&&
operator|(
operator|*
operator|(
name|long
operator|*
operator|)
name|Pointer
operator|==
literal|0
operator|)
condition|)
return|return;
comment|/*    *	If the data is too big for a TIR_S_C_STO_RIVB sub-record    *	then we do it manually    */
if|if
condition|(
name|Size
operator|>
literal|255
condition|)
block|{
while|while
condition|(
operator|--
name|Repeat_Count
operator|>=
literal|0
condition|)
name|VMS_Store_Immediate_Data
argument_list|(
name|Pointer
argument_list|,
name|Size
argument_list|,
name|Record_Type
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*    *	We are writing a "Record_Type" record    */
name|Set_VMS_Object_File_Record
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/*    *	If the buffer is empty we must insert record type    */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/*    *	Stack the repeat count    */
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_LW
argument_list|)
expr_stmt|;
name|PUT_LONG
argument_list|(
name|Repeat_Count
argument_list|)
expr_stmt|;
comment|/*    *	And now the command and its data    */
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STO_RIVB
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|Size
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|Size
operator|>=
literal|0
condition|)
name|PUT_CHAR
argument_list|(
operator|*
name|Pointer
operator|++
argument_list|)
expr_stmt|;
comment|/*    *	Flush the buffer if it is more than 75% full    */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Store a Position Independent Reference  */
end_comment

begin_expr_stmt
specifier|static
name|VMS_Store_PIC_Symbol_Reference
argument_list|(
argument|Symbol
argument_list|,
argument|Offset
argument_list|,
argument|PC_Relative
argument_list|,
argument|Psect
argument_list|,
argument|Psect_Offset
argument_list|,
argument|Record_Type
argument_list|)
expr|struct
name|symbol
operator|*
name|Symbol
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|Offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|PC_Relative
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Psect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Psect_Offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Record_Type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|VMS_Symbol
modifier|*
name|vsp
init|=
operator|(
expr|struct
name|VMS_Symbol
operator|*
operator|)
operator|(
name|Symbol
operator|->
name|sy_number
operator|)
decl_stmt|;
name|char
name|Local
index|[
literal|32
index|]
decl_stmt|;
comment|/*    *	We are writing a "Record_Type" record    */
name|Set_VMS_Object_File_Record
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/*    *	If the buffer is empty we must insert record type    */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/*    *	Set to the appropriate offset in the Psect    */
if|if
condition|(
name|PC_Relative
condition|)
block|{
comment|/*        *	For a Code reference we need to fix the operand        *	specifier as well (so back up 1 byte)        */
name|VMS_Set_Psect
argument_list|(
name|Psect
argument_list|,
name|Psect_Offset
operator|-
literal|1
argument_list|,
name|Record_Type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*        *	For a Data reference we just store HERE        */
name|VMS_Set_Psect
argument_list|(
name|Psect
argument_list|,
name|Psect_Offset
argument_list|,
name|Record_Type
argument_list|)
expr_stmt|;
block|}
comment|/*    *	Make sure we are still generating a "Record Type" record    */
if|if
condition|(
name|Object_Record_Offset
operator|==
literal|0
condition|)
name|PUT_CHAR
argument_list|(
name|Record_Type
argument_list|)
expr_stmt|;
comment|/*    *	Dispatch on symbol type (so we can stack its value)    */
switch|switch
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|Symbol
argument_list|)
condition|)
block|{
comment|/*        *	Global symbol        */
ifdef|#
directive|ifdef
name|NOT_VAX_11_C_COMPATIBLE
case|case
name|N_UNDF
operator||
name|N_EXT
case|:
case|case
name|N_DATA
operator||
name|N_EXT
case|:
endif|#
directive|endif
comment|/* NOT_VAX_11_C_COMPATIBLE */
case|case
name|N_UNDF
case|:
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
comment|/*        *	Get the symbol name (case hacked)        */
name|VMS_Case_Hack_Symbol
argument_list|(
name|S_GET_NAME
argument_list|(
name|Symbol
argument_list|)
argument_list|,
name|Local
argument_list|)
expr_stmt|;
comment|/*        *	Stack the global symbol value        */
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_GBL
argument_list|)
expr_stmt|;
name|PUT_COUNTED_STRING
argument_list|(
name|Local
argument_list|)
expr_stmt|;
if|if
condition|(
name|Offset
condition|)
block|{
comment|/* 	   *	Stack the longword offset 	   */
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_LW
argument_list|)
expr_stmt|;
name|PUT_LONG
argument_list|(
name|Offset
argument_list|)
expr_stmt|;
comment|/* 	   *	Add the two, leaving the result on the stack 	   */
name|PUT_CHAR
argument_list|(
name|TIR_S_C_OPR_ADD
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/*        *	Uninitialized local data        */
case|case
name|N_BSS
case|:
comment|/*        *	Stack the Psect (+offset)        */
if|if
condition|(
name|vsp
operator|->
name|Psect_Index
operator|<
literal|255
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_PL
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|vsp
operator|->
name|Psect_Index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_WPL
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|vsp
operator|->
name|Psect_Index
argument_list|)
expr_stmt|;
block|}
name|PUT_LONG
argument_list|(
name|vsp
operator|->
name|Psect_Offset
operator|+
name|Offset
argument_list|)
expr_stmt|;
break|break;
comment|/*        *	Local text        */
case|case
name|N_TEXT
case|:
comment|/*        *	Stack the Psect (+offset)        */
if|if
condition|(
name|vsp
operator|->
name|Psect_Index
operator|<
literal|255
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_PL
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|vsp
operator|->
name|Psect_Index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_WPL
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|vsp
operator|->
name|Psect_Index
argument_list|)
expr_stmt|;
block|}
name|PUT_LONG
argument_list|(
name|S_GET_VALUE
argument_list|(
name|Symbol
argument_list|)
operator|+
name|Offset
argument_list|)
expr_stmt|;
break|break;
comment|/*        *	Initialized local or global data        */
case|case
name|N_DATA
case|:
ifndef|#
directive|ifndef
name|NOT_VAX_11_C_COMPATIBLE
case|case
name|N_UNDF
operator||
name|N_EXT
case|:
case|case
name|N_DATA
operator||
name|N_EXT
case|:
endif|#
directive|endif
comment|/* NOT_VAX_11_C_COMPATIBLE */
comment|/*        *	Stack the Psect (+offset)        */
if|if
condition|(
name|vsp
operator|->
name|Psect_Index
operator|<
literal|255
condition|)
block|{
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_PL
argument_list|)
expr_stmt|;
name|PUT_CHAR
argument_list|(
name|vsp
operator|->
name|Psect_Index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUT_CHAR
argument_list|(
name|TIR_S_C_STA_WPL
argument_list|)
expr_stmt|;
name|PUT_SHORT
argument_list|(
name|vsp
operator|->
name|Psect_Index
argument_list|)
expr_stmt|;
block|}
name|PUT_LONG
argument_list|(
name|vsp
operator|->
name|Psect_Offset
operator|+
name|Offset
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*    *	Store either a code or data reference    */
name|PUT_CHAR
argument_list|(
name|PC_Relative
condition|?
name|TIR_S_C_STO_PICR
else|:
name|TIR_S_C_STO_PIDR
argument_list|)
expr_stmt|;
comment|/*    *	Flush the buffer if it is more than 75% full    */
if|if
condition|(
name|Object_Record_Offset
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|Object_Record_Buffer
argument_list|)
operator|*
literal|3
operator|/
literal|4
operator|)
condition|)
name|Flush_VMS_Object_Record_Buffer
argument_list|()
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Check in the text area for an indirect pc-relative reference  *	and fix it up with addressing mode 0xff [PC indirect]  *  *	THIS SHOULD BE REPLACED BY THE USE OF TIR_S_C_STO_PIRR IN THE  *	PIC CODE GENERATING FIXUP ROUTINE.  */
end_comment

begin_expr_stmt
specifier|static
name|VMS_Fix_Indirect_Reference
argument_list|(
argument|Text_Psect
argument_list|,
argument|Offset
argument_list|,
argument|fragP
argument_list|,
argument|text_frag_root
argument_list|)
name|int
name|Text_Psect
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|Offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frag
modifier|*
name|text_frag_root
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/*    *	The addressing mode byte is 1 byte before the address    */
name|Offset
operator|--
expr_stmt|;
comment|/*    *	Is it in THIS frag??    */
if|if
condition|(
operator|(
name|Offset
operator|<
name|fragP
operator|->
name|fr_address
operator|)
operator|||
operator|(
name|Offset
operator|>=
operator|(
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
operator|)
operator|)
condition|)
block|{
comment|/*        *	We need to search for the fragment containing this        *	Offset        */
for|for
control|(
name|fragP
operator|=
name|text_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
if|if
condition|(
operator|(
name|Offset
operator|>=
name|fragP
operator|->
name|fr_address
operator|)
operator|&&
operator|(
name|Offset
operator|<
operator|(
name|fragP
operator|->
name|fr_address
operator|+
name|fragP
operator|->
name|fr_fix
operator|)
operator|)
condition|)
break|break;
block|}
comment|/*        *	If we couldn't find the frag, things are BAD!!        */
if|if
condition|(
name|fragP
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Couldn't find fixup fragment when checking for indirect reference"
argument_list|)
expr_stmt|;
block|}
comment|/*    *	Check for indirect PC relative addressing mode    */
if|if
condition|(
name|fragP
operator|->
name|fr_literal
index|[
name|Offset
operator|-
name|fragP
operator|->
name|fr_address
index|]
operator|==
operator|(
name|char
operator|)
literal|0xff
condition|)
block|{
specifier|static
name|char
name|Address_Mode
init|=
literal|0xff
decl_stmt|;
comment|/*        *	Yes: Store the indirect mode back into the image        *	     to fix up the damage done by STO_PICR        */
name|VMS_Set_Psect
argument_list|(
name|Text_Psect
argument_list|,
name|Offset
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
operator|&
name|Address_Mode
argument_list|,
literal|1
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	This is a hacked _doprnt() for VAX-11 "C".  It understands that  *	it is ONLY called by as_fatal(Format, Args) with a pointer to the  *	"Args" argument.  From this we can make it all work right!  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|eunice
argument_list|)
operator|&&
name|defined
argument_list|(
name|HO_VMS
argument_list|)
end_if

begin_macro
name|_doprnt
argument_list|(
argument|Format
argument_list|,
argument|a
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|Format
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|Nargs
init|=
operator|(
operator|(
name|int
operator|*
operator|)
name|a
operator|)
index|[
operator|-
literal|2
index|]
decl_stmt|;
comment|/* This understands as_fatal() */
switch|switch
condition|(
name|Nargs
condition|)
block|{
default|default:
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"_doprnt error on \"%s\"!!"
argument_list|,
name|Format
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|Format
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|Format
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|Format
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|Format
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|Format
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|Format
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|Format
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|,
name|a
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|Format
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|,
name|a
index|[
literal|5
index|]
argument_list|,
name|a
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|Format
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|,
name|a
index|[
literal|5
index|]
argument_list|,
name|a
index|[
literal|6
index|]
argument_list|,
name|a
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|fprintf
argument_list|(
name|f
argument_list|,
name|Format
argument_list|,
name|a
index|[
literal|0
index|]
argument_list|,
name|a
index|[
literal|1
index|]
argument_list|,
name|a
index|[
literal|2
index|]
argument_list|,
name|a
index|[
literal|3
index|]
argument_list|,
name|a
index|[
literal|4
index|]
argument_list|,
name|a
index|[
literal|5
index|]
argument_list|,
name|a
index|[
literal|6
index|]
argument_list|,
name|a
index|[
literal|7
index|]
argument_list|,
name|a
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* eunice */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  *	If the procedure "main()" exists we have to add the instruction  *	"jsb c$main_args" at the beginning to be compatible with VAX-11 "C".  */
end_comment

begin_macro
name|VMS_Check_For_Main
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
ifdef|#
directive|ifdef
name|HACK_DEC_C_STARTUP
comment|/* JF */
specifier|register
name|struct
name|frchain
modifier|*
name|frchainP
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
specifier|register
name|fragS
modifier|*
modifier|*
name|prev_fragPP
decl_stmt|;
specifier|register
name|struct
name|fix
modifier|*
name|fixP
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|New_Frag
decl_stmt|;
name|int
name|i
decl_stmt|;
endif|#
directive|endif
comment|/* HACK_DEC_C_STARTUP */
name|symbolP
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|symbol_find
argument_list|(
literal|"_main"
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolP
operator|&&
operator|!
name|S_IS_DEBUG
argument_list|(
name|symbolP
argument_list|)
operator|&&
name|S_IS_EXTERNAL
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|(
name|S_GET_TYPE
argument_list|(
name|symbolP
argument_list|)
operator|==
name|N_TEXT
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HACK_DEC_C_STARTUP
if|if
condition|(
operator|!
name|flagseen
index|[
literal|'+'
index|]
condition|)
block|{
endif|#
directive|endif
comment|/* 	   *	Remember the entry point symbol 	   */
name|Entry_Point_Symbol
operator|=
name|symbolP
expr_stmt|;
ifdef|#
directive|ifdef
name|HACK_DEC_C_STARTUP
block|}
else|else
block|{
comment|/* 	   *	Scan all the fragment chains for the one with "_main" 	   *	(Actually we know the fragment from the symbol, but we need 	   *	 the previous fragment so we can change its pointer) 	   */
name|frchainP
operator|=
name|frchain_root
expr_stmt|;
while|while
condition|(
name|frchainP
condition|)
block|{
comment|/* 	       *	Scan all the fragments in this chain, remembering 	       *	the "previous fragment" 	       */
name|prev_fragPP
operator|=
operator|&
name|frchainP
operator|->
name|frch_root
expr_stmt|;
name|fragP
operator|=
name|frchainP
operator|->
name|frch_root
expr_stmt|;
while|while
condition|(
name|fragP
operator|&&
operator|(
name|fragP
operator|!=
name|frchainP
operator|->
name|frch_last
operator|)
condition|)
block|{
comment|/* 		   *	Is this the fragment? 		   */
if|if
condition|(
name|fragP
operator|==
name|symbolP
operator|->
name|sy_frag
condition|)
block|{
comment|/* 		       *	Yes: Modify the fragment by replacing 		       *	     it with a new fragment. 		       */
name|New_Frag
operator|=
operator|(
name|fragS
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|New_Frag
argument_list|)
operator|+
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_var
operator|+
literal|5
argument_list|)
expr_stmt|;
comment|/* 		       *	The fragments are the same except 		       *	that the "fixed" area is larger 		       */
operator|*
name|New_Frag
operator|=
operator|*
name|fragP
expr_stmt|;
name|New_Frag
operator|->
name|fr_fix
operator|+=
literal|6
expr_stmt|;
comment|/* 		       *	Copy the literal data opening a hole 		       *	2 bytes after "_main" (i.e. just after 		       *	the entry mask).  Into which we place 		       *	the JSB instruction. 		       */
name|New_Frag
operator|->
name|fr_literal
index|[
literal|0
index|]
operator|=
name|fragP
operator|->
name|fr_literal
index|[
literal|0
index|]
expr_stmt|;
name|New_Frag
operator|->
name|fr_literal
index|[
literal|1
index|]
operator|=
name|fragP
operator|->
name|fr_literal
index|[
literal|1
index|]
expr_stmt|;
name|New_Frag
operator|->
name|fr_literal
index|[
literal|2
index|]
operator|=
literal|0x16
expr_stmt|;
comment|/* Jsb */
name|New_Frag
operator|->
name|fr_literal
index|[
literal|3
index|]
operator|=
literal|0xef
expr_stmt|;
name|New_Frag
operator|->
name|fr_literal
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|New_Frag
operator|->
name|fr_literal
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|New_Frag
operator|->
name|fr_literal
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|New_Frag
operator|->
name|fr_literal
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_var
condition|;
name|i
operator|++
control|)
name|New_Frag
operator|->
name|fr_literal
index|[
name|i
operator|+
literal|6
index|]
operator|=
name|fragP
operator|->
name|fr_literal
index|[
name|i
index|]
expr_stmt|;
comment|/* 		       *	Now replace the old fragment with the 		       *	newly generated one. 		       */
operator|*
name|prev_fragPP
operator|=
name|New_Frag
expr_stmt|;
comment|/* 		       *	Remember the entry point symbol 		       */
name|Entry_Point_Symbol
operator|=
name|symbolP
expr_stmt|;
comment|/* 		       *	Scan the text area fixup structures 		       *	as offsets in the fragment may have 		       *	changed 		       */
for|for
control|(
name|fixP
operator|=
name|text_fix_root
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
block|{
comment|/* 			   *	Look for references to this 			   *	fragment. 			   */
if|if
condition|(
name|fixP
operator|->
name|fx_frag
operator|==
name|fragP
condition|)
block|{
comment|/* 			       *	Change the fragment 			       *	pointer 			       */
name|fixP
operator|->
name|fx_frag
operator|=
name|New_Frag
expr_stmt|;
comment|/* 			       *	If the offset is after 			       *	the entry mask we need 			       *	to account for the JSB 			       *	instruction we just 			       *	inserted. 			       */
if|if
condition|(
name|fixP
operator|->
name|fx_where
operator|>=
literal|2
condition|)
name|fixP
operator|->
name|fx_where
operator|+=
literal|6
expr_stmt|;
block|}
block|}
comment|/* 		       *	Scan the symbols as offsets in the 		       *	fragment may have changed 		       */
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
comment|/* 			   *	Look for references to this 			   *	fragment. 			   */
if|if
condition|(
name|symbolP
operator|->
name|sy_frag
operator|==
name|fragP
condition|)
block|{
comment|/* 			       *	Change the fragment 			       *	pointer 			       */
name|symbolP
operator|->
name|sy_frag
operator|=
name|New_Frag
expr_stmt|;
comment|/* 			       *	If the offset is after 			       *	the entry mask we need 			       *	to account for the JSB 			       *	instruction we just 			       *	inserted. 			       */
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|>=
literal|2
condition|)
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|+=
literal|6
expr_stmt|;
block|}
block|}
comment|/* 		       *	Make a symbol reference to 		       *	"_c$main_args" so we can get 		       *	its address inserted into the 		       *	JSB instruction. 		       */
name|symbolP
operator|=
operator|(
name|symbolS
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|symbolP
argument_list|)
argument_list|)
expr_stmt|;
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
operator|=
literal|"_c$main_args"
expr_stmt|;
name|S_SET_TYPE
argument_list|(
name|symbolP
argument_list|,
name|N_UNDF
argument_list|)
expr_stmt|;
name|S_GET_OTHER
argument_list|(
name|symbolP
argument_list|)
operator|=
literal|0
expr_stmt|;
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
operator|=
literal|0
expr_stmt|;
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|->
name|sy_name_offset
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|->
name|sy_number
operator|=
literal|0
expr_stmt|;
name|symbolP
operator|->
name|sy_frag
operator|=
name|New_Frag
expr_stmt|;
name|symbolP
operator|->
name|sy_forward
operator|=
literal|0
expr_stmt|;
comment|/* this actually inserts at the beginning of the list */
name|symbol_append
argument_list|(
name|symbol_rootP
argument_list|,
name|symbolP
argument_list|,
operator|&
name|symbol_rootP
argument_list|,
operator|&
name|symbol_lastP
argument_list|)
expr_stmt|;
name|symbol_rootP
operator|=
name|symbolP
expr_stmt|;
comment|/* 		       *	Generate a text fixup structure 		       *	to get "_c$main_args" stored into the 		       *	JSB instruction. 		       */
name|fixP
operator|=
operator|(
expr|struct
name|fix
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|fixP
argument_list|)
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_frag
operator|=
name|New_Frag
expr_stmt|;
name|fixP
operator|->
name|fx_where
operator|=
literal|4
expr_stmt|;
name|fixP
operator|->
name|fx_addsy
operator|=
name|symbolP
expr_stmt|;
name|fixP
operator|->
name|fx_subsy
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_offset
operator|=
literal|0
expr_stmt|;
name|fixP
operator|->
name|fx_size
operator|=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|fixP
operator|->
name|fx_pcrel
operator|=
literal|1
expr_stmt|;
name|fixP
operator|->
name|fx_next
operator|=
name|text_fix_root
expr_stmt|;
name|text_fix_root
operator|=
name|fixP
expr_stmt|;
comment|/* 		       *	Now make sure we exit from the loop 		       */
name|frchainP
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 		   *	Try the next fragment 		   */
name|prev_fragPP
operator|=
operator|&
name|fragP
operator|->
name|fr_next
expr_stmt|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
expr_stmt|;
block|}
comment|/* 	       *	Try the next fragment chain 	       */
if|if
condition|(
name|frchainP
condition|)
name|frchainP
operator|=
name|frchainP
operator|->
name|frch_next
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* HACK_DEC_C_STARTUP */
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  *	Write a VAX/VMS object file (everything else has been done!)  */
end_comment

begin_macro
name|VMS_write_object_file
argument_list|(
argument|text_siz
argument_list|,
argument|data_siz
argument_list|,
argument|text_frag_root
argument_list|,
argument|data_frag_root
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|text_siz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|data_siz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frag
modifier|*
name|text_frag_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|frag
modifier|*
name|data_frag_root
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|symbolP
decl_stmt|;
specifier|register
name|symbolS
modifier|*
name|sp
decl_stmt|;
specifier|register
name|struct
name|fix
modifier|*
name|fixP
decl_stmt|;
specifier|register
name|struct
name|VMS_Symbol
modifier|*
name|vsp
decl_stmt|;
name|char
modifier|*
name|Data_Segment
decl_stmt|;
name|int
name|Local_Initialized_Data_Size
init|=
literal|0
decl_stmt|;
name|int
name|Globalref
decl_stmt|;
name|int
name|Psect_Number
init|=
literal|0
decl_stmt|;
comment|/* Psect Index Number */
name|int
name|Text_Psect
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Text Psect Index   */
name|int
name|Data_Psect
init|=
operator|-
literal|2
decl_stmt|;
comment|/* Data Psect Index   JF: Was -1 */
name|int
name|Bss_Psect
init|=
operator|-
literal|3
decl_stmt|;
comment|/* Bss Psect Index    JF: Was -1 */
comment|/*    *	Create the VMS object file    */
name|Create_VMS_Object_File
argument_list|()
expr_stmt|;
comment|/*    *	Write the module header records    */
name|Write_VMS_MHD_Records
argument_list|()
expr_stmt|;
comment|/*    *	Store the Data segment:    *    *	Since this is REALLY hard to do any other way,    *	we actually manufacture the data segment and    *	the store the appropriate values out of it.    *	We need to generate this early, so that globalvalues    *	can be properly emitted.    */
if|if
condition|(
name|data_siz
operator|>
literal|0
condition|)
block|{
comment|/*        *	Allocate the data segment        */
name|Data_Segment
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|data_siz
argument_list|)
expr_stmt|;
comment|/*        *	Run through the data fragments, filling in the segment        */
for|for
control|(
name|fragP
operator|=
name|data_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
specifier|register
name|long
name|int
name|count
decl_stmt|;
specifier|register
name|char
modifier|*
name|fill_literal
decl_stmt|;
specifier|register
name|long
name|int
name|fill_size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
name|fragP
operator|->
name|fr_address
operator|-
name|text_siz
expr_stmt|;
if|if
condition|(
name|fragP
operator|->
name|fr_fix
condition|)
name|memcpy
argument_list|(
name|Data_Segment
operator|+
name|i
argument_list|,
name|fragP
operator|->
name|fr_literal
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|)
expr_stmt|;
name|i
operator|+=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|fill_literal
operator|=
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
expr_stmt|;
name|fill_size
operator|=
name|fragP
operator|->
name|fr_var
expr_stmt|;
for|for
control|(
name|count
operator|=
name|fragP
operator|->
name|fr_offset
init|;
name|count
condition|;
name|count
operator|--
control|)
block|{
if|if
condition|(
name|fill_size
condition|)
name|memcpy
argument_list|(
name|Data_Segment
operator|+
name|i
argument_list|,
name|fill_literal
argument_list|,
name|fill_size
argument_list|)
expr_stmt|;
name|i
operator|+=
name|fill_size
expr_stmt|;
block|}
block|}
block|}
comment|/*    *	Generate the VMS object file records    *	1st GSD then TIR records    */
comment|/*******       Global Symbol Dictionary       *******/
comment|/*    * Emit globalvalues now.  We must do this before the text psect    * is defined, or we will get linker warnings about multiply defined    * symbols.  All of the globalvalues "reference" psect 0, although    * it really does not have anything to do with it.    */
name|VMS_Emit_Globalvalues
argument_list|(
name|text_siz
argument_list|,
name|data_siz
argument_list|,
name|Data_Segment
argument_list|)
expr_stmt|;
comment|/*    *	Define the Text Psect    */
name|Text_Psect
operator|=
name|Psect_Number
operator|++
expr_stmt|;
name|VMS_Psect_Spec
argument_list|(
literal|"$code"
argument_list|,
name|text_siz
argument_list|,
literal|"TEXT"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*    *	Define the BSS Psect    */
if|if
condition|(
name|local_bss_counter
operator|>
literal|0
condition|)
block|{
name|Bss_Psect
operator|=
name|Psect_Number
operator|++
expr_stmt|;
name|VMS_Psect_Spec
argument_list|(
literal|"$uninitialized_data"
argument_list|,
name|local_bss_counter
argument_list|,
literal|"DATA"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|gxx_bug_fixed
comment|/*    * The g++ compiler does not write out external references to vtables    * correctly.  Check for this and holler if we see it happening.    * If that compiler bug is ever fixed we can remove this.    */
for|for
control|(
name|sp
operator|=
name|symbol_rootP
init|;
name|sp
condition|;
name|sp
operator|=
name|symbol_next
argument_list|(
name|sp
argument_list|)
control|)
block|{
comment|/*        *	Dispatch on symbol type        */
switch|switch
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|sp
argument_list|)
condition|)
block|{
comment|/* 	 *	Global Reference 	 */
case|case
name|N_UNDF
case|:
comment|/* 	 *	Make a GSD global symbol reference 	 *	record. 	 */
if|if
condition|(
name|strncmp
argument_list|(
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|"__vt."
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|S_GET_RAW_TYPE
argument_list|(
name|sp
argument_list|)
operator|=
name|N_UNDF
operator||
name|N_EXT
expr_stmt|;
name|as_warn
argument_list|(
literal|"g++ wrote an extern reference to %s as a routine."
argument_list|,
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|as_warn
argument_list|(
literal|"I will fix it, but I hope that it was not really a routine"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* gxx_bug_fixed */
comment|/*    *	Now scan the symbols and emit the appropriate GSD records    */
for|for
control|(
name|sp
operator|=
name|symbol_rootP
init|;
name|sp
condition|;
name|sp
operator|=
name|symbol_next
argument_list|(
name|sp
argument_list|)
control|)
block|{
comment|/*        *	Dispatch on symbol type        */
switch|switch
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|sp
argument_list|)
condition|)
block|{
comment|/* 	   *	Global uninitialized data 	   */
case|case
name|N_UNDF
operator||
name|N_EXT
case|:
comment|/* 	   *	Make a VMS data symbol entry 	   */
name|vsp
operator|=
operator|(
expr|struct
name|VMS_Symbol
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vsp
argument_list|)
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Symbol
operator|=
name|sp
expr_stmt|;
name|vsp
operator|->
name|Size
operator|=
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Psect_Index
operator|=
name|Psect_Number
operator|++
expr_stmt|;
name|vsp
operator|->
name|Psect_Offset
operator|=
literal|0
expr_stmt|;
name|vsp
operator|->
name|Next
operator|=
name|VMS_Symbols
expr_stmt|;
name|VMS_Symbols
operator|=
name|vsp
expr_stmt|;
name|sp
operator|->
name|sy_number
operator|=
operator|(
name|int
operator|)
name|vsp
expr_stmt|;
comment|/* 	   *	Make the psect for this data 	   */
if|if
condition|(
name|S_GET_OTHER
argument_list|(
name|sp
argument_list|)
condition|)
name|Globalref
operator|=
name|VMS_Psect_Spec
argument_list|(
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
argument_list|,
name|vsp
operator|->
name|Size
argument_list|,
literal|"CONST"
argument_list|,
name|vsp
argument_list|)
expr_stmt|;
else|else
name|Globalref
operator|=
name|VMS_Psect_Spec
argument_list|(
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
argument_list|,
name|vsp
operator|->
name|Size
argument_list|,
literal|"COMMON"
argument_list|,
name|vsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|Globalref
condition|)
name|Psect_Number
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|NOT_VAX_11_C_COMPATIBLE
comment|/* 	   *	Place a global symbol at the 	   *	beginning of the Psect 	   */
name|VMS_Global_Symbol_Spec
argument_list|(
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
argument_list|,
name|vsp
operator|->
name|Psect_Index
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NOT_VAX_11_C_COMPATIBLE */
break|break;
comment|/* 	   *	Local uninitialized data 	   */
case|case
name|N_BSS
case|:
comment|/* 	   *	Make a VMS data symbol entry 	   */
name|vsp
operator|=
operator|(
expr|struct
name|VMS_Symbol
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vsp
argument_list|)
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Symbol
operator|=
name|sp
expr_stmt|;
name|vsp
operator|->
name|Size
operator|=
literal|0
expr_stmt|;
name|vsp
operator|->
name|Psect_Index
operator|=
name|Bss_Psect
expr_stmt|;
name|vsp
operator|->
name|Psect_Offset
operator|=
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
operator|-
name|bss_address_frag
operator|.
name|fr_address
expr_stmt|;
name|vsp
operator|->
name|Next
operator|=
name|VMS_Symbols
expr_stmt|;
name|VMS_Symbols
operator|=
name|vsp
expr_stmt|;
name|sp
operator|->
name|sy_number
operator|=
operator|(
name|int
operator|)
name|vsp
expr_stmt|;
break|break;
comment|/* 	   *	Global initialized data 	   */
case|case
name|N_DATA
operator||
name|N_EXT
case|:
comment|/* 	   *	Make a VMS data symbol entry 	   */
name|vsp
operator|=
operator|(
expr|struct
name|VMS_Symbol
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vsp
argument_list|)
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Symbol
operator|=
name|sp
expr_stmt|;
name|vsp
operator|->
name|Size
operator|=
name|VMS_Initialized_Data_Size
argument_list|(
name|sp
argument_list|,
name|text_siz
operator|+
name|data_siz
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Psect_Index
operator|=
name|Psect_Number
operator|++
expr_stmt|;
name|vsp
operator|->
name|Psect_Offset
operator|=
literal|0
expr_stmt|;
name|vsp
operator|->
name|Next
operator|=
name|VMS_Symbols
expr_stmt|;
name|VMS_Symbols
operator|=
name|vsp
expr_stmt|;
name|sp
operator|->
name|sy_number
operator|=
operator|(
name|int
operator|)
name|vsp
expr_stmt|;
comment|/* 	   *	Make its psect 	   */
if|if
condition|(
name|S_GET_OTHER
argument_list|(
name|sp
argument_list|)
condition|)
name|Globalref
operator|=
name|VMS_Psect_Spec
argument_list|(
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
argument_list|,
name|vsp
operator|->
name|Size
argument_list|,
literal|"CONST"
argument_list|,
name|vsp
argument_list|)
expr_stmt|;
else|else
name|Globalref
operator|=
name|VMS_Psect_Spec
argument_list|(
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
argument_list|,
name|vsp
operator|->
name|Size
argument_list|,
literal|"COMMON"
argument_list|,
name|vsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|Globalref
condition|)
name|Psect_Number
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|NOT_VAX_11_C_COMPATIBLE
comment|/* 	   *	Place a global symbol at the 	   *	beginning of the Psect 	   */
name|VMS_Global_Symbol_Spec
argument_list|(
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
argument_list|,
name|vsp
operator|->
name|Psect_Index
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NOT_VAX_11_C_COMPATIBLE */
break|break;
comment|/* 	   *	Local initialized data 	   */
case|case
name|N_DATA
case|:
comment|/* 	   *	Make a VMS data symbol entry 	   */
name|vsp
operator|=
operator|(
expr|struct
name|VMS_Symbol
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vsp
argument_list|)
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Symbol
operator|=
name|sp
expr_stmt|;
name|vsp
operator|->
name|Size
operator|=
name|VMS_Initialized_Data_Size
argument_list|(
name|sp
argument_list|,
name|text_siz
operator|+
name|data_siz
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Psect_Index
operator|=
name|Data_Psect
expr_stmt|;
name|vsp
operator|->
name|Psect_Offset
operator|=
name|Local_Initialized_Data_Size
expr_stmt|;
name|Local_Initialized_Data_Size
operator|+=
name|vsp
operator|->
name|Size
expr_stmt|;
name|vsp
operator|->
name|Next
operator|=
name|VMS_Symbols
expr_stmt|;
name|VMS_Symbols
operator|=
name|vsp
expr_stmt|;
name|sp
operator|->
name|sy_number
operator|=
operator|(
name|int
operator|)
name|vsp
expr_stmt|;
break|break;
comment|/* 	   *	Global Text definition 	   */
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
block|{
name|unsigned
name|short
name|Entry_Mask
decl_stmt|;
comment|/* 	     *	Get the entry mask 	     */
name|fragP
operator|=
name|sp
operator|->
name|sy_frag
expr_stmt|;
name|Entry_Mask
operator|=
operator|(
name|fragP
operator|->
name|fr_literal
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|+
operator|(
operator|(
name|fragP
operator|->
name|fr_literal
index|[
literal|1
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* 	     *	Define the Procedure entry pt. 	     */
name|VMS_Procedure_Entry_Pt
argument_list|(
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
argument_list|,
name|Text_Psect
argument_list|,
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
argument_list|,
name|Entry_Mask
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	   *	Local Text definition 	   */
case|case
name|N_TEXT
case|:
comment|/* 	   *	Make a VMS data symbol entry 	   */
if|if
condition|(
name|Text_Psect
operator|!=
operator|-
literal|1
condition|)
block|{
name|vsp
operator|=
operator|(
expr|struct
name|VMS_Symbol
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vsp
argument_list|)
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Symbol
operator|=
name|sp
expr_stmt|;
name|vsp
operator|->
name|Size
operator|=
literal|0
expr_stmt|;
name|vsp
operator|->
name|Psect_Index
operator|=
name|Text_Psect
expr_stmt|;
name|vsp
operator|->
name|Psect_Offset
operator|=
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Next
operator|=
name|VMS_Symbols
expr_stmt|;
name|VMS_Symbols
operator|=
name|vsp
expr_stmt|;
name|sp
operator|->
name|sy_number
operator|=
operator|(
name|int
operator|)
name|vsp
expr_stmt|;
block|}
break|break;
comment|/* 	   *	Global Reference 	   */
case|case
name|N_UNDF
case|:
comment|/* 	   *	Make a GSD global symbol reference 	   *	record. 	   */
name|VMS_Global_Symbol_Spec
argument_list|(
name|S_GET_NAME
argument_list|(
name|sp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* 	   *	Anything else 	   */
default|default:
comment|/* 	   *	Ignore STAB symbols 	   *	Including .stabs emitted by g++ 	   */
if|if
condition|(
name|S_IS_DEBUG
argument_list|(
name|sp
argument_list|)
operator|||
operator|(
name|S_GET_TYPE
argument_list|(
name|sp
argument_list|)
operator|==
literal|22
operator|)
condition|)
break|break;
comment|/* 	   *	Error 	   */
if|if
condition|(
name|S_GET_TYPE
argument_list|(
name|sp
argument_list|)
operator|!=
literal|22
condition|)
name|printf
argument_list|(
literal|" ERROR, unknown type (%d)\n"
argument_list|,
name|S_GET_TYPE
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/*    *	Define the Data Psect    */
if|if
condition|(
operator|(
name|data_siz
operator|>
literal|0
operator|)
operator|&&
operator|(
name|Local_Initialized_Data_Size
operator|>
literal|0
operator|)
condition|)
block|{
comment|/*        *	Do it        */
name|Data_Psect
operator|=
name|Psect_Number
operator|++
expr_stmt|;
name|VMS_Psect_Spec
argument_list|(
literal|"$data"
argument_list|,
name|Local_Initialized_Data_Size
argument_list|,
literal|"DATA"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*        *	Scan the VMS symbols and fill in the data psect        */
for|for
control|(
name|vsp
operator|=
name|VMS_Symbols
init|;
name|vsp
condition|;
name|vsp
operator|=
name|vsp
operator|->
name|Next
control|)
block|{
comment|/* 	   *	Only look for undefined psects 	   */
if|if
condition|(
name|vsp
operator|->
name|Psect_Index
operator|<
literal|0
condition|)
block|{
comment|/* 	       *	And only initialized data 	       */
if|if
condition|(
operator|(
name|S_GET_TYPE
argument_list|(
name|vsp
operator|->
name|Symbol
argument_list|)
operator|==
name|N_DATA
operator|)
operator|&&
operator|!
name|S_IS_EXTERNAL
argument_list|(
name|vsp
operator|->
name|Symbol
argument_list|)
condition|)
name|vsp
operator|->
name|Psect_Index
operator|=
name|Data_Psect
expr_stmt|;
block|}
block|}
block|}
comment|/*******  Text Information and Relocation Records  *******/
comment|/*    *	Write the text segment data    */
if|if
condition|(
name|text_siz
operator|>
literal|0
condition|)
block|{
comment|/*        *	Scan the text fragments        */
for|for
control|(
name|fragP
operator|=
name|text_frag_root
init|;
name|fragP
condition|;
name|fragP
operator|=
name|fragP
operator|->
name|fr_next
control|)
block|{
comment|/* 	   *	Stop if we get to the data fragments 	   */
if|if
condition|(
name|fragP
operator|==
name|data_frag_root
condition|)
break|break;
comment|/* 	   *	Ignore fragments with no data 	   */
if|if
condition|(
operator|(
name|fragP
operator|->
name|fr_fix
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fragP
operator|->
name|fr_var
operator|==
literal|0
operator|)
condition|)
continue|continue;
comment|/* 	   *	Go the the appropriate offset in the 	   *	Text Psect. 	   */
name|VMS_Set_Psect
argument_list|(
name|Text_Psect
argument_list|,
name|fragP
operator|->
name|fr_address
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
comment|/* 	   *	Store the "fixed" part 	   */
if|if
condition|(
name|fragP
operator|->
name|fr_fix
condition|)
name|VMS_Store_Immediate_Data
argument_list|(
name|fragP
operator|->
name|fr_literal
argument_list|,
name|fragP
operator|->
name|fr_fix
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
comment|/* 	   *	Store the "variable" part 	   */
if|if
condition|(
name|fragP
operator|->
name|fr_var
operator|&&
name|fragP
operator|->
name|fr_offset
condition|)
name|VMS_Store_Repeated_Data
argument_list|(
name|fragP
operator|->
name|fr_offset
argument_list|,
name|fragP
operator|->
name|fr_literal
operator|+
name|fragP
operator|->
name|fr_fix
argument_list|,
name|fragP
operator|->
name|fr_var
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
block|}
comment|/*        *	Now we go through the text segment fixups and        *	generate TIR records to fix up addresses within        *	the Text Psect        */
for|for
control|(
name|fixP
operator|=
name|text_fix_root
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
block|{
comment|/* 	   *	We DO handle the case of "Symbol - Symbol" as 	   *	long as it is in the same segment. 	   */
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|&&
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	       *	They need to be in the same segment 	       */
if|if
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
operator|!=
name|S_GET_RAW_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
name|error
argument_list|(
literal|"Fixup data addsy and subsy didn't have the same type"
argument_list|)
expr_stmt|;
comment|/* 	       *	And they need to be in one that we 	       *	can check the psect on 	       */
if|if
condition|(
operator|(
name|S_GET_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|N_DATA
operator|)
operator|&&
operator|(
name|S_GET_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|N_TEXT
operator|)
condition|)
name|error
argument_list|(
literal|"Fixup data addsy and subsy didn't have an appropriate type"
argument_list|)
expr_stmt|;
comment|/* 	       *	This had better not be PC relative! 	       */
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|error
argument_list|(
literal|"Fixup data was erroneously \"pcrel\""
argument_list|)
expr_stmt|;
comment|/* 	       *	Subtract their values to get the 	       *	difference. 	       */
name|i
operator|=
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
comment|/* 	       *	Now generate the fixup object records 	       *	Set the psect and store the data 	       */
name|VMS_Set_Psect
argument_list|(
name|Text_Psect
argument_list|,
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
operator|&
name|i
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
comment|/* 	       *	Done 	       */
continue|continue;
block|}
comment|/* 	   *	Size will HAVE to be "long" 	   */
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|!=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
name|error
argument_list|(
literal|"Fixup datum was not a longword"
argument_list|)
expr_stmt|;
comment|/* 	   *	Symbol must be "added" (if it is ever 	   *				subtracted we can 	   *				fix this assumption) 	   */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Fixup datum was not \"fixP->fx_addsy\""
argument_list|)
expr_stmt|;
comment|/* 	   *	Store the symbol value in a PIC fashion 	   */
name|VMS_Store_PIC_Symbol_Reference
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|,
name|fixP
operator|->
name|fx_offset
argument_list|,
name|fixP
operator|->
name|fx_pcrel
argument_list|,
name|Text_Psect
argument_list|,
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
comment|/* 	   *	Check for indirect address reference, 	   *	which has to be fixed up (as the linker 	   *	will screw it up with TIR_S_C_STO_PICR). 	   */
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|VMS_Fix_Indirect_Reference
argument_list|(
name|Text_Psect
argument_list|,
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
argument_list|,
name|fixP
operator|->
name|fx_frag
argument_list|,
name|text_frag_root
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    *	Store the Data segment:    *    *	Since this is REALLY hard to do any other way,    *	we actually manufacture the data segment and    *	the store the appropriate values out of it.    *	The segment was manufactured before, now we just    *	dump it into the appropriate psects.    */
if|if
condition|(
name|data_siz
operator|>
literal|0
condition|)
block|{
comment|/*        *	Now we can run through all the data symbols        *	and store the data        */
for|for
control|(
name|vsp
operator|=
name|VMS_Symbols
init|;
name|vsp
condition|;
name|vsp
operator|=
name|vsp
operator|->
name|Next
control|)
block|{
comment|/* 	   *	Ignore anything other than data symbols 	   */
if|if
condition|(
name|S_GET_TYPE
argument_list|(
name|vsp
operator|->
name|Symbol
argument_list|)
operator|!=
name|N_DATA
condition|)
continue|continue;
comment|/* 	   *	Set the Psect + Offset 	   */
name|VMS_Set_Psect
argument_list|(
name|vsp
operator|->
name|Psect_Index
argument_list|,
name|vsp
operator|->
name|Psect_Offset
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
comment|/* 	   *	Store the data 	   */
name|VMS_Store_Immediate_Data
argument_list|(
name|Data_Segment
operator|+
name|S_GET_VALUE
argument_list|(
name|vsp
operator|->
name|Symbol
argument_list|)
operator|-
name|text_siz
argument_list|,
name|vsp
operator|->
name|Size
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
block|}
comment|/*        *	Now we go through the data segment fixups and        *	generate TIR records to fix up addresses within        *	the Data Psects        */
for|for
control|(
name|fixP
operator|=
name|data_fix_root
init|;
name|fixP
condition|;
name|fixP
operator|=
name|fixP
operator|->
name|fx_next
control|)
block|{
comment|/* 	   *	Find the symbol for the containing datum 	   */
for|for
control|(
name|vsp
operator|=
name|VMS_Symbols
init|;
name|vsp
condition|;
name|vsp
operator|=
name|vsp
operator|->
name|Next
control|)
block|{
comment|/* 	       *	Only bother with Data symbols 	       */
name|sp
operator|=
name|vsp
operator|->
name|Symbol
expr_stmt|;
if|if
condition|(
name|S_GET_TYPE
argument_list|(
name|sp
argument_list|)
operator|!=
name|N_DATA
condition|)
continue|continue;
comment|/* 	       *	Ignore symbol if After fixup 	       */
if|if
condition|(
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
operator|>
operator|(
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|)
condition|)
continue|continue;
comment|/* 	       *	See if the datum is here 	       */
if|if
condition|(
operator|(
name|S_GET_VALUE
argument_list|(
name|sp
argument_list|)
operator|+
name|vsp
operator|->
name|Size
operator|)
operator|<=
operator|(
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|)
condition|)
continue|continue;
comment|/* 	       *	We DO handle the case of "Symbol - Symbol" as 	       *	long as it is in the same segment. 	       */
if|if
condition|(
name|fixP
operator|->
name|fx_subsy
operator|&&
name|fixP
operator|->
name|fx_addsy
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 		   *	They need to be in the same segment 		   */
if|if
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
operator|!=
name|S_GET_RAW_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
name|error
argument_list|(
literal|"Fixup data addsy and subsy didn't have the same type"
argument_list|)
expr_stmt|;
comment|/* 		   *	And they need to be in one that we 		   *	can check the psect on 		   */
if|if
condition|(
operator|(
name|S_GET_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|N_DATA
operator|)
operator|&&
operator|(
name|S_GET_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|!=
name|N_TEXT
operator|)
condition|)
name|error
argument_list|(
literal|"Fixup data addsy and subsy didn't have an appropriate type"
argument_list|)
expr_stmt|;
comment|/* 		   *	This had better not be PC relative! 		   */
if|if
condition|(
name|fixP
operator|->
name|fx_pcrel
condition|)
name|error
argument_list|(
literal|"Fixup data was erroneously \"pcrel\""
argument_list|)
expr_stmt|;
comment|/* 		   *	Subtract their values to get the 		   *	difference. 		   */
name|i
operator|=
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|-
name|S_GET_VALUE
argument_list|(
name|fixP
operator|->
name|fx_subsy
argument_list|)
expr_stmt|;
comment|/* 		   *	Now generate the fixup object records 		   *	Set the psect and store the data 		   */
name|VMS_Set_Psect
argument_list|(
name|vsp
operator|->
name|Psect_Index
argument_list|,
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|S_GET_VALUE
argument_list|(
name|vsp
operator|->
name|Symbol
argument_list|)
operator|+
name|vsp
operator|->
name|Psect_Offset
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
name|VMS_Store_Immediate_Data
argument_list|(
operator|&
name|i
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
comment|/* 		   *	Done 		   */
break|break;
block|}
comment|/* 	       *	Size will HAVE to be "long" 	       */
if|if
condition|(
name|fixP
operator|->
name|fx_size
operator|!=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
name|error
argument_list|(
literal|"Fixup datum was not a longword"
argument_list|)
expr_stmt|;
comment|/* 	       *	Symbol must be "added" (if it is ever 	       *				subtracted we can 	       *				fix this assumption) 	       */
if|if
condition|(
name|fixP
operator|->
name|fx_addsy
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Fixup datum was not \"fixP->fx_addsy\""
argument_list|)
expr_stmt|;
comment|/* 	       *	Store the symbol value in a PIC fashion 	       */
name|VMS_Store_PIC_Symbol_Reference
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|,
name|fixP
operator|->
name|fx_offset
argument_list|,
name|fixP
operator|->
name|fx_pcrel
argument_list|,
name|vsp
operator|->
name|Psect_Index
argument_list|,
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|S_GET_VALUE
argument_list|(
name|vsp
operator|->
name|Symbol
argument_list|)
operator|+
name|vsp
operator|->
name|Psect_Offset
argument_list|,
name|OBJ_S_C_TIR
argument_list|)
expr_stmt|;
comment|/* 	       *	Done 	       */
break|break;
block|}
block|}
block|}
comment|/*    *	Write the Traceback Begin Module record    */
name|VMS_TBT_Module_Begin
argument_list|()
expr_stmt|;
comment|/*    *	Scan the symbols and write out the routines    *	(this makes the assumption that symbols are in    *	 order of ascending text segment offset)    */
block|{
name|struct
name|symbol
modifier|*
name|Current_Routine
init|=
literal|0
decl_stmt|;
name|int
name|Current_Line_Number
init|=
literal|0
decl_stmt|;
name|int
name|Current_Offset
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|input_file
modifier|*
name|Current_File
decl_stmt|;
comment|/* Output debugging info for global variables and static variables that are not  * specific to one routine. We also need to examine all stabs directives, to  * find the definitions to all of the advanced data types, and this is done by  * VMS_LSYM_Parse.  This needs to be done before any definitions are output to  * the object file, since there can be forward references in the stabs  * directives. When through with parsing, the text of the stabs directive  * is altered, with the definitions removed, so that later passes will see  * directives as they would be written if the type were already defined.  *  * We also look for files and include files, and make a list of them.  We  * examine the source file numbers to establish the actual lines that code was  * generated from, and then generate offsets.  */
name|VMS_LSYM_Parse
argument_list|()
expr_stmt|;
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
comment|/* 	 *	Deal with STAB symbols 	 */
if|if
condition|(
name|S_IS_DEBUG
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* 	     *	Dispatch on STAB type 	     */
switch|switch
condition|(
operator|(
name|unsigned
name|char
operator|)
name|S_GET_RAW_TYPE
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
case|case
name|N_SLINE
case|:
if|if
condition|(
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
operator|>
name|Current_File
operator|->
name|max_line
condition|)
name|Current_File
operator|->
name|max_line
operator|=
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
operator|<
name|Current_File
operator|->
name|min_line
condition|)
name|Current_File
operator|->
name|min_line
operator|=
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_SO
case|:
name|Current_File
operator|=
name|find_file
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|Current_File
operator|->
name|flag
operator|=
literal|1
expr_stmt|;
name|Current_File
operator|->
name|min_line
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|N_SOL
case|:
name|Current_File
operator|=
name|find_file
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_GSYM
case|:
name|VMS_GSYM_Parse
argument_list|(
name|symbolP
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_LCSYM
case|:
name|VMS_LCSYM_Parse
argument_list|(
name|symbolP
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
break|break;
case|case
name|N_FUN
case|:
comment|/* For static constant symbols */
case|case
name|N_STSYM
case|:
name|VMS_STSYM_Parse
argument_list|(
name|symbolP
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* now we take a quick sweep through the files and assign offsets     to each one.  This will essentially be the starting line number to the    debugger for each file.  Output the info for the debugger to specify the    files, and then tell it how many lines to use */
block|{
name|int
name|File_Number
init|=
literal|0
decl_stmt|;
name|int
name|Debugger_Offset
init|=
literal|0
decl_stmt|;
name|int
name|file_available
decl_stmt|;
name|Current_File
operator|=
name|file_root
expr_stmt|;
for|for
control|(
name|Current_File
operator|=
name|file_root
init|;
name|Current_File
condition|;
name|Current_File
operator|=
name|Current_File
operator|->
name|next
control|)
block|{
if|if
condition|(
name|Current_File
operator|==
operator|(
expr|struct
name|input_file
operator|*
operator|)
name|NULL
condition|)
break|break;
if|if
condition|(
name|Current_File
operator|->
name|max_line
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|Current_File
operator|->
name|name
argument_list|,
literal|"GNU_GXX_INCLUDE:"
argument_list|,
literal|16
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|flagseen
index|[
literal|'D'
index|]
condition|)
continue|continue;
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|Current_File
operator|->
name|name
argument_list|,
literal|"GNU_CC_INCLUDE:"
argument_list|,
literal|15
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|flagseen
index|[
literal|'D'
index|]
condition|)
continue|continue;
comment|/* show a few extra lines at the start of the region selected */
if|if
condition|(
name|Current_File
operator|->
name|min_line
operator|>
literal|2
condition|)
name|Current_File
operator|->
name|min_line
operator|-=
literal|2
expr_stmt|;
name|Current_File
operator|->
name|offset
operator|=
name|Debugger_Offset
operator|-
name|Current_File
operator|->
name|min_line
operator|+
literal|1
expr_stmt|;
name|Debugger_Offset
operator|+=
name|Current_File
operator|->
name|max_line
operator|-
name|Current_File
operator|->
name|min_line
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|Current_File
operator|->
name|same_file_fpnt
operator|!=
operator|(
expr|struct
name|input_file
operator|*
operator|)
name|NULL
condition|)
name|Current_File
operator|->
name|file_number
operator|=
name|Current_File
operator|->
name|same_file_fpnt
operator|->
name|file_number
expr_stmt|;
else|else
block|{
name|Current_File
operator|->
name|file_number
operator|=
operator|++
name|File_Number
expr_stmt|;
name|file_available
operator|=
name|VMS_TBT_Source_File
argument_list|(
name|Current_File
operator|->
name|name
argument_list|,
name|Current_File
operator|->
name|file_number
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_available
condition|)
block|{
name|Current_File
operator|->
name|file_number
operator|=
literal|0
expr_stmt|;
name|File_Number
operator|--
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
block|}
empty_stmt|;
name|VMS_TBT_Source_Lines
argument_list|(
name|Current_File
operator|->
name|file_number
argument_list|,
name|Current_File
operator|->
name|min_line
argument_list|,
name|Current_File
operator|->
name|max_line
operator|-
name|Current_File
operator|->
name|min_line
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* for */
block|}
empty_stmt|;
comment|/* scope */
name|Current_File
operator|=
operator|(
expr|struct
name|input_file
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|symbolP
operator|=
name|symbol_rootP
init|;
name|symbolP
condition|;
name|symbolP
operator|=
name|symbol_next
argument_list|(
name|symbolP
argument_list|)
control|)
block|{
comment|/* 	 *	Deal with text symbols 	 */
if|if
condition|(
operator|!
name|S_IS_DEBUG
argument_list|(
name|symbolP
argument_list|)
operator|&&
operator|(
name|S_GET_TYPE
argument_list|(
name|symbolP
argument_list|)
operator|==
name|N_TEXT
operator|)
condition|)
block|{
comment|/* 	     *	Ignore symbols starting with "L", 	     *	as they are local symbols 	     */
if|if
condition|(
operator|*
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
operator|==
literal|'L'
condition|)
continue|continue;
comment|/* 	     *	If there is a routine start defined, 	     *	terminate it. 	     */
if|if
condition|(
name|Current_Routine
condition|)
block|{
comment|/* 		 *	End the routine 		 */
name|VMS_TBT_Routine_End
argument_list|(
name|text_siz
argument_list|,
name|Current_Routine
argument_list|)
expr_stmt|;
block|}
comment|/* 	     *	Store the routine begin traceback info 	     */
if|if
condition|(
name|Text_Psect
operator|!=
operator|-
literal|1
condition|)
block|{
name|VMS_TBT_Routine_Begin
argument_list|(
name|symbolP
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
name|Current_Routine
operator|=
name|symbolP
expr_stmt|;
block|}
comment|/* Output local symbols, i.e. all symbols that are associated with a specific  * routine.  We output them now so the debugger recognizes them as local to  * this routine.  */
block|{
name|symbolS
modifier|*
name|symbolP1
decl_stmt|;
name|char
modifier|*
name|pnt
decl_stmt|;
name|char
modifier|*
name|pnt1
decl_stmt|;
for|for
control|(
name|symbolP1
operator|=
name|Current_Routine
init|;
name|symbolP1
condition|;
name|symbolP1
operator|=
name|symbol_next
argument_list|(
name|symbolP1
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|S_IS_DEBUG
argument_list|(
name|symbolP1
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|S_GET_RAW_TYPE
argument_list|(
name|symbolP1
argument_list|)
operator|!=
name|N_FUN
condition|)
continue|continue;
name|pnt
operator|=
name|S_GET_NAME
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|pnt1
operator|=
name|S_GET_NAME
argument_list|(
name|symbolP1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pnt
operator|++
operator|!=
literal|'_'
condition|)
continue|continue;
while|while
condition|(
operator|*
name|pnt
operator|++
operator|==
operator|*
name|pnt1
operator|++
condition|)
block|{ 		    }
empty_stmt|;
if|if
condition|(
operator|*
name|pnt1
operator|!=
literal|'F'
operator|&&
operator|*
name|pnt1
operator|!=
literal|'f'
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|*
operator|(
operator|--
name|pnt
operator|)
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
operator|*
operator|(
operator|--
name|pnt1
operator|)
operator|==
literal|':'
operator|)
condition|)
break|break;
block|}
empty_stmt|;
if|if
condition|(
name|symbolP1
operator|!=
operator|(
name|symbolS
operator|*
operator|)
name|NULL
condition|)
name|VMS_DBG_Define_Routine
argument_list|(
name|symbolP1
argument_list|,
name|Current_Routine
argument_list|,
name|Text_Psect
argument_list|)
expr_stmt|;
block|}
comment|/* local symbol block */
comment|/* 	     *	Done 	     */
continue|continue;
block|}
comment|/* 	 *	Deal with STAB symbols 	 */
if|if
condition|(
name|S_IS_DEBUG
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* 	     *	Dispatch on STAB type 	     */
switch|switch
condition|(
operator|(
name|unsigned
name|char
operator|)
name|S_GET_RAW_TYPE
argument_list|(
name|symbolP
argument_list|)
condition|)
block|{
comment|/* 		 *	Line number 		 */
case|case
name|N_SLINE
case|:
comment|/* Offset the line into the correct portion 		 * of the file */
if|if
condition|(
name|Current_File
operator|->
name|file_number
operator|==
literal|0
condition|)
break|break;
comment|/* Sometimes the same offset gets several source 		 * lines assigned to it. 		 * We should be selective about which lines 		 * we allow, we should prefer lines that are 		 * in the main source file when debugging 		 * inline functions. */
if|if
condition|(
operator|(
name|Current_File
operator|->
name|file_number
operator|!=
literal|1
operator|)
operator|&&
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|==
name|Current_Offset
condition|)
break|break;
comment|/* calculate actual debugger source line */
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
operator|+=
name|Current_File
operator|->
name|offset
expr_stmt|;
comment|/* 		 *	If this is the 1st N_SLINE, setup 		 *	PC/Line correlation.  Otherwise 		 *	do the delta PC/Line.  If the offset 		 *	for the line number is not +ve we need 		 *	to do another PC/Line correlation 		 *	setup 		 */
if|if
condition|(
name|Current_Offset
operator|==
operator|-
literal|1
condition|)
block|{
name|VMS_TBT_Line_PC_Correlation
argument_list|(
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|Text_Psect
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
operator|-
name|Current_Line_Number
operator|)
operator|<=
literal|0
condition|)
block|{
comment|/* 			 *	Line delta is not +ve, we 			 *	need to close the line and 			 *	start a new PC/Line 			 *	correlation. 			 */
name|VMS_TBT_Line_PC_Correlation
argument_list|(
literal|0
argument_list|,
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|-
name|Current_Offset
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|VMS_TBT_Line_PC_Correlation
argument_list|(
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
argument_list|,
name|Text_Psect
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 *	Line delta is +ve, all is well 			 */
name|VMS_TBT_Line_PC_Correlation
argument_list|(
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
operator|-
name|Current_Line_Number
argument_list|,
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
operator|-
name|Current_Offset
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 *	Update the current line/PC 		 */
name|Current_Line_Number
operator|=
name|S_GET_DESC
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
name|Current_Offset
operator|=
name|S_GET_VALUE
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
comment|/* 		 *	Done 		 */
break|break;
comment|/* 		 *	Source file 		 */
case|case
name|N_SO
case|:
comment|/* 		 *	Remember that we had a source file 		 *	and emit the source file debugger 		 *	record 		 */
name|Current_File
operator|=
name|find_file
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
break|break;
comment|/* We need to make sure that we are really in the actual source file when  * we compute the maximum line number.  Otherwise the debugger gets really  * confused */
case|case
name|N_SOL
case|:
name|Current_File
operator|=
name|find_file
argument_list|(
name|symbolP
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/*      *	If there is a routine start defined,      *	terminate it (and the line numbers)      */
if|if
condition|(
name|Current_Routine
condition|)
block|{
comment|/* 	 *	Terminate the line numbers 	 */
name|VMS_TBT_Line_PC_Correlation
argument_list|(
literal|0
argument_list|,
name|text_siz
operator|-
name|S_GET_VALUE
argument_list|(
name|Current_Routine
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 *	Terminate the routine 	 */
name|VMS_TBT_Routine_End
argument_list|(
name|text_siz
argument_list|,
name|Current_Routine
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    *	Write the Traceback End Module TBT record    */
name|VMS_TBT_Module_End
argument_list|()
expr_stmt|;
comment|/*    *	Write the End Of Module record    */
if|if
condition|(
name|Entry_Point_Symbol
operator|==
literal|0
condition|)
name|Write_VMS_EOM_Record
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|Write_VMS_EOM_Record
argument_list|(
name|Text_Psect
argument_list|,
name|S_GET_VALUE
argument_list|(
name|Entry_Point_Symbol
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    *	All done, close the object file    */
name|Close_VMS_Object_File
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end of obj-vms.c */
end_comment

end_unit

