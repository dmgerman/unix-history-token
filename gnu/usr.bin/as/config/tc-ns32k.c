begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ns32k.c  -- Assemble on the National Semiconductor 32k series    Copyright (C) 1987, 1992 Free Software Foundation, Inc.     This file is part of GAS, the GNU Assembler.     GAS is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     GAS is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with GAS; see the file COPYING.  If not, write to    the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*#define SHOW_NUM 1*/
end_comment

begin_comment
comment|/* uncomment for debugging */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"opcode/ns32k.h"
end_include

begin_include
include|#
directive|include
file|"as.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_comment
comment|/* Macros */
end_comment

begin_define
define|#
directive|define
name|IIF_ENTRIES
value|13
end_define

begin_comment
comment|/* number of entries in iif */
end_comment

begin_define
define|#
directive|define
name|PRIVATE_SIZE
value|256
end_define

begin_comment
comment|/* size of my garbage memory */
end_comment

begin_define
define|#
directive|define
name|MAX_ARGS
value|4
end_define

begin_define
define|#
directive|define
name|DEFAULT
value|-1
end_define

begin_comment
comment|/* addr_mode returns this value when plain constant or label is encountered */
end_comment

begin_define
define|#
directive|define
name|IIF
parameter_list|(
name|ptr
parameter_list|,
name|a1
parameter_list|,
name|c1
parameter_list|,
name|e1
parameter_list|,
name|g1
parameter_list|,
name|i1
parameter_list|,
name|k1
parameter_list|,
name|m1
parameter_list|,
name|o1
parameter_list|,
name|q1
parameter_list|,
name|s1
parameter_list|,
name|u1
parameter_list|)
define|\
value|iif.iifP[ptr].type= a1; \     iif.iifP[ptr].size= c1; \     iif.iifP[ptr].object= e1; \     iif.iifP[ptr].object_adjust= g1; \     iif.iifP[ptr].pcrel= i1; \     iif.iifP[ptr].pcrel_adjust= k1; \     iif.iifP[ptr].im_disp= m1; \     iif.iifP[ptr].relax_substate= o1; \     iif.iifP[ptr].bit_fixP= q1; \     iif.iifP[ptr].addr_mode= s1; \     iif.iifP[ptr].bsr= u1;
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|TE_SEQUENT
end_ifdef

begin_define
define|#
directive|define
name|LINE_COMMENT_CHARS
value|"|"
end_define

begin_define
define|#
directive|define
name|ABSOLUTE_PREFIX
value|'@'
end_define

begin_define
define|#
directive|define
name|IMMEDIATE_PREFIX
value|'#'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LINE_COMMENT_CHARS
end_ifndef

begin_define
define|#
directive|define
name|LINE_COMMENT_CHARS
value|"#"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|char
name|comment_chars
index|[]
init|=
literal|"#"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|line_comment_chars
index|[]
init|=
name|LINE_COMMENT_CHARS
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ABSOLUTE_PREFIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|IMMEDIATE_PREFIX
argument_list|)
end_if

begin_define
define|#
directive|define
name|ABSOLUTE_PREFIX
value|'@'
end_define

begin_comment
comment|/* One or the other MUST be defined */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|addr_mode
block|{
name|char
name|mode
decl_stmt|;
comment|/* addressing mode of operand (0-31) */
name|char
name|scaled_mode
decl_stmt|;
comment|/* mode combined with scaled mode */
name|char
name|scaled_reg
decl_stmt|;
comment|/* register used in scaled+1 (1-8) */
name|char
name|float_flag
decl_stmt|;
comment|/* set if R0..R7 was F0..F7 ie a floating-point-register */
name|char
name|am_size
decl_stmt|;
comment|/* estimated max size of general addr-mode parts*/
name|char
name|im_disp
decl_stmt|;
comment|/* if im_disp == 1 we have a displacement */
name|char
name|pcrel
decl_stmt|;
comment|/* 1 if pcrel, this is really redundant info */
name|char
name|disp_suffix
index|[
literal|2
index|]
decl_stmt|;
comment|/* length of displacement(s), 0=undefined */
name|char
modifier|*
name|disp
index|[
literal|2
index|]
decl_stmt|;
comment|/* pointer(s) at displacement(s) 				   or immediates(s)     (ascii) */
name|char
name|index_byte
decl_stmt|;
comment|/* index byte */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|addr_mode
name|addr_modeS
typedef|;
end_typedef

begin_decl_stmt
name|char
modifier|*
name|freeptr
decl_stmt|,
modifier|*
name|freeptr_static
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* points at some number of free bytes */
end_comment

begin_decl_stmt
name|struct
name|hash_control
modifier|*
name|inst_hash_handle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ns32k_opcode
modifier|*
name|desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer at description of instruction */
end_comment

begin_decl_stmt
name|addr_modeS
name|addr_modeP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|EXP_CHARS
index|[]
init|=
literal|"eE"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|FLT_CHARS
index|[]
init|=
literal|"fd"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* we don't want to support lowercase, do we */
end_comment

begin_comment
comment|/* UPPERCASE denotes live names  * when an instruction is built, IIF is used as an intermidiate form to store  * the actual parts of the instruction. A ns32k machine instruction can  * be divided into a couple of sub PARTs. When an instruction is assembled  * the appropriate PART get an assignment. When an IIF has been completed it's  * converted to a FRAGment as specified in AS.H */
end_comment

begin_comment
comment|/* internal structs */
end_comment

begin_struct
struct|struct
name|option
block|{
name|char
modifier|*
name|pattern
decl_stmt|;
name|unsigned
name|long
name|or
decl_stmt|;
name|unsigned
name|long
name|and
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|type
decl_stmt|;
comment|/* how to interpret object */
name|int
name|size
decl_stmt|;
comment|/* Estimated max size of object */
name|unsigned
name|long
name|object
decl_stmt|;
comment|/* binary data */
name|int
name|object_adjust
decl_stmt|;
comment|/* number added to object */
name|int
name|pcrel
decl_stmt|;
comment|/* True if object is pcrel */
name|int
name|pcrel_adjust
decl_stmt|;
comment|/* length in bytes from the 					   instruction start to the 					   displacement */
name|int
name|im_disp
decl_stmt|;
comment|/* True if the object is a displacement */
name|relax_substateT
name|relax_substate
decl_stmt|;
comment|/* Initial relaxsubstate */
name|bit_fixS
modifier|*
name|bit_fixP
decl_stmt|;
comment|/* Pointer at bit_fix struct */
name|int
name|addr_mode
decl_stmt|;
comment|/* What addrmode do we associate with this iif-entry */
name|char
name|bsr
decl_stmt|;
comment|/* Sequent hack */
block|}
name|iif_entryT
typedef|;
end_typedef

begin_comment
comment|/* Internal Instruction Format */
end_comment

begin_struct
struct|struct
name|int_ins_form
block|{
name|int
name|instr_size
decl_stmt|;
comment|/* Max size of instruction in bytes. */
name|iif_entryT
name|iifP
index|[
name|IIF_ENTRIES
operator|+
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|int_ins_form
name|iif
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|expressionS
name|exprP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|input_line_pointer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* description of the PARTs in IIF  *object[n]:  * 0	total length in bytes of entries in iif  * 1	opcode  * 2	index_byte_a  * 3	index_byte_b  * 4	disp_a_1  * 5	disp_a_2  * 6	disp_b_1  * 7	disp_b_2  * 8	imm_a  * 9	imm_b  * 10	implied1  * 11	implied2  *  * For every entry there is a datalength in bytes. This is stored in size[n].  *	 0,	the objectlength is not explicitly given by the instruction  *		and the operand is undefined. This is a case for relaxation.  *		Reserve 4 bytes for the final object.  *  *	 1,	the entry contains one byte  *	 2,	the entry contains two bytes  *	 3,	the entry contains three bytes  *	 4,	the entry contains four bytes  *	etc  *  * Furthermore, every entry has a data type identifier in type[n].  *  * 	 0,	the entry is void, ignore it.  * 	 1,	the entry is a binary number.  *	 2,	the entry is a pointer at an expression.  *		Where expression may be as simple as a single '1',  *		and as complicated as  foo-bar+12,  * 		foo and bar may be undefined but suffixed by :{b|w|d} to  *		control the length of the object.  *  *	 3,	the entry is a pointer at a bignum struct  *  *  * The low-order-byte coresponds to low physical memory.  * Obviously a FRAGment must be created for each valid disp in PART whose  * datalength is undefined (to bad) .  * The case where just the expression is undefined is less severe and is  * handled by fix. Here the number of bytes in the objectfile is known.  * With this representation we simplify the assembly and separates the  * machine dependent/independent parts in a more clean way (said OE)  */
end_comment

begin_escape
end_escape

begin_decl_stmt
name|struct
name|option
name|opt1
index|[]
init|=
comment|/* restore, exit */
block|{
block|{
literal|"r0"
block|,
literal|0x80
block|,
literal|0xff
block|}
block|,
block|{
literal|"r1"
block|,
literal|0x40
block|,
literal|0xff
block|}
block|,
block|{
literal|"r2"
block|,
literal|0x20
block|,
literal|0xff
block|}
block|,
block|{
literal|"r3"
block|,
literal|0x10
block|,
literal|0xff
block|}
block|,
block|{
literal|"r4"
block|,
literal|0x08
block|,
literal|0xff
block|}
block|,
block|{
literal|"r5"
block|,
literal|0x04
block|,
literal|0xff
block|}
block|,
block|{
literal|"r6"
block|,
literal|0x02
block|,
literal|0xff
block|}
block|,
block|{
literal|"r7"
block|,
literal|0x01
block|,
literal|0xff
block|}
block|,
block|{
literal|0
block|,
literal|0x00
block|,
literal|0xff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|opt2
index|[]
init|=
comment|/* save, enter */
block|{
block|{
literal|"r0"
block|,
literal|0x01
block|,
literal|0xff
block|}
block|,
block|{
literal|"r1"
block|,
literal|0x02
block|,
literal|0xff
block|}
block|,
block|{
literal|"r2"
block|,
literal|0x04
block|,
literal|0xff
block|}
block|,
block|{
literal|"r3"
block|,
literal|0x08
block|,
literal|0xff
block|}
block|,
block|{
literal|"r4"
block|,
literal|0x10
block|,
literal|0xff
block|}
block|,
block|{
literal|"r5"
block|,
literal|0x20
block|,
literal|0xff
block|}
block|,
block|{
literal|"r6"
block|,
literal|0x40
block|,
literal|0xff
block|}
block|,
block|{
literal|"r7"
block|,
literal|0x80
block|,
literal|0xff
block|}
block|,
block|{
literal|0
block|,
literal|0x00
block|,
literal|0xff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|opt3
index|[]
init|=
comment|/* setcfg */
block|{
block|{
literal|"c"
block|,
literal|0x8
block|,
literal|0xff
block|}
block|,
block|{
literal|"m"
block|,
literal|0x4
block|,
literal|0xff
block|}
block|,
block|{
literal|"f"
block|,
literal|0x2
block|,
literal|0xff
block|}
block|,
block|{
literal|"i"
block|,
literal|0x1
block|,
literal|0xff
block|}
block|,
block|{
literal|0
block|,
literal|0x0
block|,
literal|0xff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|opt4
index|[]
init|=
comment|/* cinv */
block|{
block|{
literal|"a"
block|,
literal|0x4
block|,
literal|0xff
block|}
block|,
block|{
literal|"i"
block|,
literal|0x2
block|,
literal|0xff
block|}
block|,
block|{
literal|"d"
block|,
literal|0x1
block|,
literal|0xff
block|}
block|,
block|{
literal|0
block|,
literal|0x0
block|,
literal|0xff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|opt5
index|[]
init|=
comment|/* string inst */
block|{
block|{
literal|"b"
block|,
literal|0x2
block|,
literal|0xff
block|}
block|,
block|{
literal|"u"
block|,
literal|0xc
block|,
literal|0xff
block|}
block|,
block|{
literal|"w"
block|,
literal|0x4
block|,
literal|0xff
block|}
block|,
block|{
literal|0
block|,
literal|0x0
block|,
literal|0xff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|opt6
index|[]
init|=
comment|/* plain reg ext,cvtp etc */
block|{
block|{
literal|"r0"
block|,
literal|0x00
block|,
literal|0xff
block|}
block|,
block|{
literal|"r1"
block|,
literal|0x01
block|,
literal|0xff
block|}
block|,
block|{
literal|"r2"
block|,
literal|0x02
block|,
literal|0xff
block|}
block|,
block|{
literal|"r3"
block|,
literal|0x03
block|,
literal|0xff
block|}
block|,
block|{
literal|"r4"
block|,
literal|0x04
block|,
literal|0xff
block|}
block|,
block|{
literal|"r5"
block|,
literal|0x05
block|,
literal|0xff
block|}
block|,
block|{
literal|"r6"
block|,
literal|0x06
block|,
literal|0xff
block|}
block|,
block|{
literal|"r7"
block|,
literal|0x07
block|,
literal|0xff
block|}
block|,
block|{
literal|0
block|,
literal|0x00
block|,
literal|0xff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NS32032
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NS32532
argument_list|)
end_if

begin_define
define|#
directive|define
name|NS32032
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|option
name|cpureg_532
index|[]
init|=
comment|/* lpr spr */
block|{
block|{
literal|"us"
block|,
literal|0x0
block|,
literal|0xff
block|}
block|,
block|{
literal|"dcr"
block|,
literal|0x1
block|,
literal|0xff
block|}
block|,
block|{
literal|"bpc"
block|,
literal|0x2
block|,
literal|0xff
block|}
block|,
block|{
literal|"dsr"
block|,
literal|0x3
block|,
literal|0xff
block|}
block|,
block|{
literal|"car"
block|,
literal|0x4
block|,
literal|0xff
block|}
block|,
block|{
literal|"fp"
block|,
literal|0x8
block|,
literal|0xff
block|}
block|,
block|{
literal|"sp"
block|,
literal|0x9
block|,
literal|0xff
block|}
block|,
block|{
literal|"sb"
block|,
literal|0xa
block|,
literal|0xff
block|}
block|,
block|{
literal|"usp"
block|,
literal|0xb
block|,
literal|0xff
block|}
block|,
block|{
literal|"cfg"
block|,
literal|0xc
block|,
literal|0xff
block|}
block|,
block|{
literal|"psr"
block|,
literal|0xd
block|,
literal|0xff
block|}
block|,
block|{
literal|"intbase"
block|,
literal|0xe
block|,
literal|0xff
block|}
block|,
block|{
literal|"mod"
block|,
literal|0xf
block|,
literal|0xff
block|}
block|,
block|{
literal|0
block|,
literal|0x00
block|,
literal|0xff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|mmureg_532
index|[]
init|=
comment|/* lmr smr */
block|{
block|{
literal|"mcr"
block|,
literal|0x9
block|,
literal|0xff
block|}
block|,
block|{
literal|"msr"
block|,
literal|0xa
block|,
literal|0xff
block|}
block|,
block|{
literal|"tear"
block|,
literal|0xb
block|,
literal|0xff
block|}
block|,
block|{
literal|"ptb0"
block|,
literal|0xc
block|,
literal|0xff
block|}
block|,
block|{
literal|"ptb1"
block|,
literal|0xd
block|,
literal|0xff
block|}
block|,
block|{
literal|"ivar0"
block|,
literal|0xe
block|,
literal|0xff
block|}
block|,
block|{
literal|"ivar1"
block|,
literal|0xf
block|,
literal|0xff
block|}
block|,
block|{
literal|0
block|,
literal|0x0
block|,
literal|0xff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|cpureg_032
index|[]
init|=
comment|/* lpr spr */
block|{
block|{
literal|"upsr"
block|,
literal|0x0
block|,
literal|0xff
block|}
block|,
block|{
literal|"fp"
block|,
literal|0x8
block|,
literal|0xff
block|}
block|,
block|{
literal|"sp"
block|,
literal|0x9
block|,
literal|0xff
block|}
block|,
block|{
literal|"sb"
block|,
literal|0xa
block|,
literal|0xff
block|}
block|,
block|{
literal|"psr"
block|,
literal|0xd
block|,
literal|0xff
block|}
block|,
block|{
literal|"intbase"
block|,
literal|0xe
block|,
literal|0xff
block|}
block|,
block|{
literal|"mod"
block|,
literal|0xf
block|,
literal|0xff
block|}
block|,
block|{
literal|0
block|,
literal|0x0
block|,
literal|0xff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
name|mmureg_032
index|[]
init|=
comment|/* lmr smr */
block|{
block|{
literal|"bpr0"
block|,
literal|0x0
block|,
literal|0xff
block|}
block|,
block|{
literal|"bpr1"
block|,
literal|0x1
block|,
literal|0xff
block|}
block|,
block|{
literal|"pf0"
block|,
literal|0x4
block|,
literal|0xff
block|}
block|,
block|{
literal|"pf1"
block|,
literal|0x5
block|,
literal|0xff
block|}
block|,
block|{
literal|"sc"
block|,
literal|0x8
block|,
literal|0xff
block|}
block|,
block|{
literal|"msr"
block|,
literal|0xa
block|,
literal|0xff
block|}
block|,
block|{
literal|"bcnt"
block|,
literal|0xb
block|,
literal|0xff
block|}
block|,
block|{
literal|"ptb0"
block|,
literal|0xc
block|,
literal|0xff
block|}
block|,
block|{
literal|"ptb1"
block|,
literal|0xd
block|,
literal|0xff
block|}
block|,
block|{
literal|"eia"
block|,
literal|0xf
block|,
literal|0xff
block|}
block|,
block|{
literal|0
block|,
literal|0x0
block|,
literal|0xff
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NS32532
argument_list|)
end_if

begin_decl_stmt
name|struct
name|option
modifier|*
name|cpureg
init|=
name|cpureg_532
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
modifier|*
name|mmureg
init|=
name|mmureg_532
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|struct
name|option
modifier|*
name|cpureg
init|=
name|cpureg_032
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|option
modifier|*
name|mmureg
init|=
name|mmureg_032
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_decl_stmt
specifier|const
name|pseudo_typeS
name|md_pseudo_table
index|[]
init|=
block|{
comment|/* so far empty */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IND
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x)<<2)+(y))
end_define

begin_comment
comment|/* those are index's to relax groups in md_relax_table    ie it must be multiplied by 4 to point at a group start. Viz IND(x,y)    Se function relax_segment in write.c for more info */
end_comment

begin_define
define|#
directive|define
name|BRANCH
value|1
end_define

begin_define
define|#
directive|define
name|PCREL
value|2
end_define

begin_comment
comment|/* those are index's to entries in a relax group */
end_comment

begin_define
define|#
directive|define
name|BYTE
value|0
end_define

begin_define
define|#
directive|define
name|WORD
value|1
end_define

begin_define
define|#
directive|define
name|DOUBLE
value|2
end_define

begin_define
define|#
directive|define
name|UNDEF
value|3
end_define

begin_comment
comment|/* Those limits are calculated from the displacement start in memory.    The ns32k uses the begining of the instruction as displacement base.    This type of displacements could be handled here by moving the limit window    up or down. I choose to use an internal displacement base-adjust as there    are other routines that must consider this. Also, as we have two various    offset-adjusts in the ns32k (acb versus br/brs/jsr/bcond), two set of limits    would have had to be used.    Now we dont have to think about that. */
end_comment

begin_decl_stmt
specifier|const
name|relax_typeS
name|md_relax_table
index|[]
init|=
block|{
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
operator|(
literal|63
operator|)
block|,
operator|(
operator|-
literal|64
operator|)
block|,
literal|1
block|,
name|IND
argument_list|(
argument|BRANCH
argument_list|,
argument|WORD
argument_list|)
block|}
block|,
block|{
operator|(
literal|8191
operator|)
block|,
operator|(
operator|-
literal|8192
operator|)
block|,
literal|2
block|,
name|IND
argument_list|(
argument|BRANCH
argument_list|,
argument|DOUBLE
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array used to test if mode contains displacements.    Value is true if mode contains displacement. */
end_comment

begin_decl_stmt
name|char
name|disp_test
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array used to calculate max size of displacements */
end_comment

begin_decl_stmt
name|char
name|disp_size
index|[]
init|=
block|{
literal|4
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
literal|4
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PIC
end_ifdef

begin_comment
comment|/* In pic-mode all external pc-relative references are jmpslot    references except references to __GLOBAL_OFFSET_TABLE_. */
end_comment

begin_decl_stmt
specifier|static
name|symbolS
modifier|*
name|got_symbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The size of got-offsets. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|got_offset_size
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_if
if|#
directive|if
name|__STDC__
operator|==
literal|1
end_if

begin_function_decl
specifier|static
name|segT
name|evaluate_expr
parameter_list|(
name|expressionS
modifier|*
name|resultP
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|md_number_to_disp
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|long
name|val
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|md_number_to_imm
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|long
name|val
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not __STDC__ */
end_comment

begin_function_decl
specifier|static
name|segT
name|evaluate_expr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|md_number_to_disp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|md_number_to_imm
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not __STDC__ */
end_comment

begin_comment
comment|/* Parses a general operand into an addressingmode struct     in:  pointer at operand in ascii form    pointer at addr_mode struct for result    the level of recursion. (always 0 or 1)     out: data in addr_mode struct    */
end_comment

begin_function
name|int
name|addr_mode
parameter_list|(
name|operand
parameter_list|,
name|addr_modeP
parameter_list|,
name|recursive_level
parameter_list|)
name|char
modifier|*
name|operand
decl_stmt|;
specifier|register
name|addr_modeS
modifier|*
name|addr_modeP
decl_stmt|;
name|int
name|recursive_level
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|strl
decl_stmt|;
specifier|register
name|int
name|mode
decl_stmt|;
name|int
name|j
decl_stmt|;
name|mode
operator|=
name|DEFAULT
expr_stmt|;
comment|/* default */
name|addr_modeP
operator|->
name|scaled_mode
operator|=
literal|0
expr_stmt|;
comment|/* why not */
name|addr_modeP
operator|->
name|scaled_reg
operator|=
literal|0
expr_stmt|;
comment|/* if 0, not scaled index */
name|addr_modeP
operator|->
name|float_flag
operator|=
literal|0
expr_stmt|;
name|addr_modeP
operator|->
name|am_size
operator|=
literal|0
expr_stmt|;
name|addr_modeP
operator|->
name|im_disp
operator|=
literal|0
expr_stmt|;
name|addr_modeP
operator|->
name|pcrel
operator|=
literal|0
expr_stmt|;
comment|/* not set in this function */
name|addr_modeP
operator|->
name|disp_suffix
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|addr_modeP
operator|->
name|disp_suffix
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|addr_modeP
operator|->
name|disp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|addr_modeP
operator|->
name|disp
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|str
operator|=
name|operand
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* we don't want this */
name|strl
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|str
index|[
literal|0
index|]
condition|)
block|{
comment|/* the following three case statements controls the mode-chars 		   this is the place to ed if you want to change them */
ifdef|#
directive|ifdef
name|ABSOLUTE_PREFIX
case|case
name|ABSOLUTE_PREFIX
case|:
if|if
condition|(
name|str
index|[
name|strl
operator|-
literal|1
index|]
operator|==
literal|']'
condition|)
break|break;
name|addr_modeP
operator|->
name|mode
operator|=
literal|21
expr_stmt|;
comment|/* absolute */
name|addr_modeP
operator|->
name|disp
index|[
literal|0
index|]
operator|=
name|str
operator|+
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IMMEDIATE_PREFIX
case|case
name|IMMEDIATE_PREFIX
case|:
if|if
condition|(
name|str
index|[
name|strl
operator|-
literal|1
index|]
operator|==
literal|']'
condition|)
break|break;
name|addr_modeP
operator|->
name|mode
operator|=
literal|20
expr_stmt|;
comment|/* immediate */
name|addr_modeP
operator|->
name|disp
index|[
literal|0
index|]
operator|=
name|str
operator|+
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
case|case
literal|'.'
case|:
if|if
condition|(
name|str
index|[
name|strl
operator|-
literal|1
index|]
operator|!=
literal|']'
condition|)
block|{
switch|switch
condition|(
name|str
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'-'
case|:
case|case
literal|'+'
case|:
if|if
condition|(
name|str
index|[
literal|2
index|]
operator|!=
literal|'\000'
condition|)
block|{
name|addr_modeP
operator|->
name|mode
operator|=
literal|27
expr_stmt|;
comment|/* pc-relativ */
name|addr_modeP
operator|->
name|disp
index|[
literal|0
index|]
operator|=
name|str
operator|+
literal|2
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
default|default:
name|as_warn
argument_list|(
literal|"Invalid syntax in PC-relative addressing mode"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|str
index|[
name|strl
operator|-
literal|1
index|]
operator|!=
literal|']'
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"ext("
argument_list|,
literal|4
argument_list|)
operator|)
operator|&&
name|strl
operator|>
literal|7
condition|)
block|{
comment|/* external */
name|addr_modeP
operator|->
name|disp
index|[
literal|0
index|]
operator|=
name|str
operator|+
literal|4
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|2
expr_stmt|;
do|do
block|{
comment|/* disp[0]'s termination point */
name|j
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|str
index|[
name|j
index|]
operator|==
literal|'('
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|str
index|[
name|j
index|]
operator|==
literal|')'
condition|)
name|i
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|<
name|strl
operator|&&
name|i
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|i
operator|!=
literal|0
operator|||
operator|!
operator|(
name|str
index|[
name|j
operator|+
literal|1
index|]
operator|==
literal|'-'
operator|||
name|str
index|[
name|j
operator|+
literal|1
index|]
operator|==
literal|'+'
operator|)
condition|)
block|{
name|as_warn
argument_list|(
literal|"Invalid syntax in External addressing mode"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|str
index|[
name|j
index|]
operator|=
literal|'\000'
expr_stmt|;
comment|/* null terminate disp[0] */
name|addr_modeP
operator|->
name|disp
index|[
literal|1
index|]
operator|=
name|str
operator|+
name|j
operator|+
literal|2
expr_stmt|;
name|addr_modeP
operator|->
name|mode
operator|=
literal|22
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
break|break;
default|default:
empty_stmt|;
block|}
name|strl
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|strl
condition|)
block|{
case|case
literal|2
case|:
switch|switch
condition|(
name|str
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'f'
case|:
name|addr_modeP
operator|->
name|float_flag
operator|=
literal|1
expr_stmt|;
case|case
literal|'r'
case|:
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|str
index|[
literal|1
index|]
operator|<
literal|'8'
condition|)
block|{
name|addr_modeP
operator|->
name|mode
operator|=
name|str
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
case|case
literal|3
case|:
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|str
argument_list|,
literal|"tos"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|addr_modeP
operator|->
name|mode
operator|=
literal|23
expr_stmt|;
comment|/* TopOfStack */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
default|default:
empty_stmt|;
block|}
if|if
condition|(
name|strl
operator|>
literal|4
condition|)
block|{
if|if
condition|(
name|str
index|[
name|strl
operator|-
literal|1
index|]
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
name|str
index|[
name|strl
operator|-
literal|2
index|]
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|str
index|[
name|strl
operator|-
literal|5
index|]
argument_list|,
literal|"(fp"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|mode
operator|=
literal|16
expr_stmt|;
comment|/* Memory Relative */
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|str
index|[
name|strl
operator|-
literal|5
index|]
argument_list|,
literal|"(sp"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|mode
operator|=
literal|17
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|str
index|[
name|strl
operator|-
literal|5
index|]
argument_list|,
literal|"(sb"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|mode
operator|=
literal|18
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|!=
name|DEFAULT
condition|)
block|{
comment|/* memory relative */
name|addr_modeP
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|j
operator|=
name|strl
operator|-
literal|5
expr_stmt|;
comment|/* temp for end of disp[0] */
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|strl
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|str
index|[
name|strl
index|]
operator|==
literal|')'
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|str
index|[
name|strl
index|]
operator|==
literal|'('
condition|)
name|i
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|strl
operator|>
operator|-
literal|1
operator|&&
name|i
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"Invalid syntax in Memory Relative addressing mode"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|addr_modeP
operator|->
name|disp
index|[
literal|1
index|]
operator|=
name|str
expr_stmt|;
name|addr_modeP
operator|->
name|disp
index|[
literal|0
index|]
operator|=
name|str
operator|+
name|strl
operator|+
literal|1
expr_stmt|;
name|str
index|[
name|j
index|]
operator|=
literal|'\000'
expr_stmt|;
comment|/* null terminate disp[0] */
name|str
index|[
name|strl
index|]
operator|=
literal|'\000'
expr_stmt|;
comment|/* null terminate disp[1] */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
switch|switch
condition|(
name|str
index|[
name|strl
operator|-
literal|3
index|]
condition|)
block|{
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
if|if
condition|(
name|str
index|[
name|strl
operator|-
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|str
index|[
name|strl
operator|-
literal|2
index|]
operator|<
literal|'8'
operator|&&
name|str
index|[
name|strl
operator|-
literal|4
index|]
operator|==
literal|'('
condition|)
block|{
name|addr_modeP
operator|->
name|mode
operator|=
name|str
index|[
name|strl
operator|-
literal|2
index|]
operator|-
literal|'0'
operator|+
literal|8
expr_stmt|;
name|addr_modeP
operator|->
name|disp
index|[
literal|0
index|]
operator|=
name|str
expr_stmt|;
name|str
index|[
name|strl
operator|-
literal|4
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* reg rel */
block|}
default|default:
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|str
index|[
name|strl
operator|-
literal|4
index|]
argument_list|,
literal|"(fp"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|mode
operator|=
literal|24
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|str
index|[
name|strl
operator|-
literal|4
index|]
argument_list|,
literal|"(sp"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|mode
operator|=
literal|25
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|str
index|[
name|strl
operator|-
literal|4
index|]
argument_list|,
literal|"(sb"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|mode
operator|=
literal|26
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|&
name|str
index|[
name|strl
operator|-
literal|4
index|]
argument_list|,
literal|"(pc"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|mode
operator|=
literal|27
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|!=
name|DEFAULT
condition|)
block|{
name|addr_modeP
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|addr_modeP
operator|->
name|disp
index|[
literal|0
index|]
operator|=
name|str
expr_stmt|;
name|str
index|[
name|strl
operator|-
literal|4
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* memory space */
block|}
block|}
block|}
comment|/* no trailing ')' do we have a ']' ? */
if|if
condition|(
name|str
index|[
name|strl
operator|-
literal|1
index|]
operator|==
literal|']'
condition|)
block|{
switch|switch
condition|(
name|str
index|[
name|strl
operator|-
literal|2
index|]
condition|)
block|{
case|case
literal|'b'
case|:
name|mode
operator|=
literal|28
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|mode
operator|=
literal|29
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|mode
operator|=
literal|30
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|mode
operator|=
literal|31
expr_stmt|;
break|break;
default|default:
empty_stmt|;
name|as_warn
argument_list|(
literal|"Invalid scaled-indexed mode, use (b,w,d,q)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
index|[
name|strl
operator|-
literal|3
index|]
operator|!=
literal|':'
operator|||
name|str
index|[
name|strl
operator|-
literal|6
index|]
operator|!=
literal|'['
operator|||
name|str
index|[
name|strl
operator|-
literal|5
index|]
operator|==
literal|'r'
operator|||
name|str
index|[
name|strl
operator|-
literal|4
index|]
operator|<
literal|'0'
operator|||
name|str
index|[
name|strl
operator|-
literal|4
index|]
operator|>
literal|'7'
condition|)
block|{
name|as_warn
argument_list|(
literal|"Syntax in scaled-indexed mode, use [Rn:m] where n=[0..7] m={b,w,d,q}"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* scaled index */
block|{
if|if
condition|(
name|recursive_level
operator|>
literal|0
condition|)
block|{
name|as_warn
argument_list|(
literal|"Scaled-indexed addressing mode combined with scaled-index"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|addr_modeP
operator|->
name|am_size
operator|+=
literal|1
expr_stmt|;
comment|/* scaled index byte */
name|j
operator|=
name|str
index|[
name|strl
operator|-
literal|4
index|]
operator|-
literal|'0'
expr_stmt|;
comment|/* store temporary */
name|str
index|[
name|strl
operator|-
literal|6
index|]
operator|=
literal|'\000'
expr_stmt|;
comment|/* nullterminate for recursive call */
name|i
operator|=
name|addr_mode
argument_list|(
name|str
argument_list|,
name|addr_modeP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|||
name|addr_modeP
operator|->
name|mode
operator|==
literal|20
condition|)
block|{
name|as_warn
argument_list|(
literal|"Invalid or illegal addressing mode combined with scaled-index"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|addr_modeP
operator|->
name|scaled_mode
operator|=
name|addr_modeP
operator|->
name|mode
expr_stmt|;
comment|/* store the inferior mode */
name|addr_modeP
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|addr_modeP
operator|->
name|scaled_reg
operator|=
name|j
operator|+
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
name|addr_modeP
operator|->
name|mode
operator|=
name|DEFAULT
expr_stmt|;
comment|/* default to whatever */
name|addr_modeP
operator|->
name|disp
index|[
literal|0
index|]
operator|=
name|str
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ptr points at string    addr_modeP points at struct with result    This routine calls addr_mode to determine the general addr.mode of    the operand. When this is ready it parses the displacements for size    specifying suffixes and determines size of immediate mode via ns32k-opcode.    Also builds index bytes if needed.    */
end_comment

begin_function
name|int
name|get_addr_mode
parameter_list|(
name|ptr
parameter_list|,
name|addr_modeP
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|addr_modeS
modifier|*
name|addr_modeP
decl_stmt|;
block|{
name|int
name|tmp
decl_stmt|;
name|addr_mode
argument_list|(
name|ptr
argument_list|,
name|addr_modeP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr_modeP
operator|->
name|mode
operator|==
name|DEFAULT
operator|||
name|addr_modeP
operator|->
name|scaled_mode
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* resolve ambigious operands, this shouldn't 		   be necessary if one uses standard NSC operand 		   syntax. But the sequent compiler doesn't!!! 		   This finds a proper addressinging mode if it 		   is implicitly stated. See ns32k-opcode.h */
operator|(
name|void
operator|)
name|evaluate_expr
argument_list|(
operator|&
name|exprP
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
comment|/* this call takes time Sigh! */
if|if
condition|(
name|addr_modeP
operator|->
name|mode
operator|==
name|DEFAULT
condition|)
block|{
if|if
condition|(
name|exprP
operator|.
name|X_add_symbol
operator|||
name|exprP
operator|.
name|X_subtract_symbol
condition|)
block|{
name|addr_modeP
operator|->
name|mode
operator|=
name|desc
operator|->
name|default_model
expr_stmt|;
comment|/* we have a label */
block|}
else|else
block|{
name|addr_modeP
operator|->
name|mode
operator|=
name|desc
operator|->
name|default_modec
expr_stmt|;
comment|/* we have a constant */
block|}
block|}
else|else
block|{
if|if
condition|(
name|exprP
operator|.
name|X_add_symbol
operator|||
name|exprP
operator|.
name|X_subtract_symbol
condition|)
block|{
name|addr_modeP
operator|->
name|scaled_mode
operator|=
name|desc
operator|->
name|default_model
expr_stmt|;
block|}
else|else
block|{
name|addr_modeP
operator|->
name|scaled_mode
operator|=
name|desc
operator|->
name|default_modec
expr_stmt|;
block|}
block|}
comment|/* must put this mess down in addr_mode to handle the scaled case better */
block|}
comment|/* It appears as the sequent compiler wants an absolute when we have a 	   label without @. Constants becomes immediates besides the addr case. 	   Think it does so with local labels too, not optimum, pcrel is better. 	   When I have time I will make gas check this and select pcrel when possible 	   Actually that is trivial. 	   */
if|if
condition|(
name|tmp
operator|=
name|addr_modeP
operator|->
name|scaled_reg
condition|)
block|{
comment|/* build indexbyte */
name|tmp
operator|--
expr_stmt|;
comment|/* remember regnumber comes incremented for flagpurpose */
name|tmp
operator||=
name|addr_modeP
operator|->
name|scaled_mode
operator|<<
literal|3
expr_stmt|;
name|addr_modeP
operator|->
name|index_byte
operator|=
operator|(
name|char
operator|)
name|tmp
expr_stmt|;
name|addr_modeP
operator|->
name|am_size
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|disp_test
index|[
name|addr_modeP
operator|->
name|mode
index|]
condition|)
block|{
comment|/* there was a displacement, probe for length specifying suffix*/
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
name|suffix
decl_stmt|;
specifier|register
name|char
name|suffix_sub
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|toP
decl_stmt|;
specifier|register
name|char
modifier|*
name|fromP
decl_stmt|;
name|addr_modeP
operator|->
name|pcrel
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|disp_test
index|[
name|addr_modeP
operator|->
name|mode
index|]
condition|)
block|{
comment|/* there is a displacement */
if|if
condition|(
name|addr_modeP
operator|->
name|mode
operator|==
literal|27
operator|||
name|addr_modeP
operator|->
name|scaled_mode
operator|==
literal|27
condition|)
block|{
comment|/* do we have pcrel. mode */
name|addr_modeP
operator|->
name|pcrel
operator|=
literal|1
expr_stmt|;
block|}
name|addr_modeP
operator|->
name|im_disp
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|suffix_sub
operator|=
name|suffix
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|toP
operator|=
name|addr_modeP
operator|->
name|disp
index|[
name|i
index|]
condition|)
block|{
comment|/* suffix of expression, the largest size rules */
name|fromP
operator|=
name|toP
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|fromP
operator|++
condition|)
block|{
operator|*
name|toP
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
block|{
switch|switch
condition|(
operator|*
name|fromP
condition|)
block|{
case|case
literal|'\0'
case|:
name|as_warn
argument_list|(
literal|"Premature end of suffix--Defaulting to d"
argument_list|)
expr_stmt|;
name|suffix
operator|=
literal|4
expr_stmt|;
continue|continue;
case|case
literal|'b'
case|:
name|suffix_sub
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|suffix_sub
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|suffix_sub
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|as_warn
argument_list|(
literal|"Bad suffix after ':' use {b|w|d} Defaulting to d"
argument_list|)
expr_stmt|;
name|suffix
operator|=
literal|4
expr_stmt|;
block|}
name|fromP
operator|++
expr_stmt|;
name|toP
operator|--
expr_stmt|;
comment|/* So we write over the ':' */
if|if
condition|(
name|suffix
operator|<
name|suffix_sub
condition|)
name|suffix
operator|=
name|suffix_sub
expr_stmt|;
block|}
block|}
operator|*
name|toP
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate properly */
name|addr_modeP
operator|->
name|disp_suffix
index|[
name|i
index|]
operator|=
name|suffix
expr_stmt|;
name|addr_modeP
operator|->
name|am_size
operator|+=
name|suffix
condition|?
name|suffix
else|:
literal|4
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|addr_modeP
operator|->
name|mode
operator|==
literal|20
condition|)
block|{
comment|/* look in ns32k_opcode for size */
name|addr_modeP
operator|->
name|disp_suffix
index|[
literal|0
index|]
operator|=
name|addr_modeP
operator|->
name|am_size
operator|=
name|desc
operator|->
name|im_size
expr_stmt|;
name|addr_modeP
operator|->
name|im_disp
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|addr_modeP
operator|->
name|mode
return|;
block|}
end_function

begin_comment
comment|/* read an optionlist */
end_comment

begin_function
name|void
name|optlist
parameter_list|(
name|str
parameter_list|,
name|optionP
parameter_list|,
name|default_map
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
comment|/* the string to extract options from */
name|struct
name|option
modifier|*
name|optionP
decl_stmt|;
comment|/* how to search the string */
name|unsigned
name|long
modifier|*
name|default_map
decl_stmt|;
comment|/* default pattern and output */
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|strlen1
decl_stmt|,
name|strlen2
decl_stmt|;
specifier|register
name|char
modifier|*
name|patternP
decl_stmt|,
modifier|*
name|strP
decl_stmt|;
name|strlen1
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen1
operator|<
literal|1
condition|)
block|{
name|as_fatal
argument_list|(
literal|"Very short instr to option, ie you can't do it on a NULLstr"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|optionP
index|[
name|i
index|]
operator|.
name|pattern
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|strlen2
operator|=
name|strlen
argument_list|(
name|optionP
index|[
name|i
index|]
operator|.
name|pattern
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|strlen1
condition|;
name|j
operator|++
control|)
block|{
name|patternP
operator|=
name|optionP
index|[
name|i
index|]
operator|.
name|pattern
expr_stmt|;
name|strP
operator|=
operator|&
name|str
index|[
name|j
index|]
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|strlen2
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|strP
operator|++
operator|)
operator|!=
operator|*
operator|(
name|patternP
operator|++
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|k
operator|==
name|strlen2
condition|)
block|{
comment|/* match */
operator|*
name|default_map
operator||=
name|optionP
index|[
name|i
index|]
operator|.
name|or
expr_stmt|;
operator|*
name|default_map
operator|&=
name|optionP
index|[
name|i
index|]
operator|.
name|and
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* search struct for symbols    This function is used to get the short integer form of reg names    in the instructions lmr, smr, lpr, spr    return true if str is found in list */
end_comment

begin_function
name|int
name|list_search
parameter_list|(
name|str
parameter_list|,
name|optionP
parameter_list|,
name|default_map
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
comment|/* the string to match */
name|struct
name|option
modifier|*
name|optionP
decl_stmt|;
comment|/* list to search */
name|unsigned
name|long
modifier|*
name|default_map
decl_stmt|;
comment|/* default pattern and output */
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|optionP
index|[
name|i
index|]
operator|.
name|pattern
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|optionP
index|[
name|i
index|]
operator|.
name|pattern
argument_list|,
name|str
argument_list|,
literal|20
argument_list|)
condition|)
block|{
comment|/* use strncmp to be safe */
operator|*
name|default_map
operator||=
name|optionP
index|[
name|i
index|]
operator|.
name|or
expr_stmt|;
operator|*
name|default_map
operator|&=
name|optionP
index|[
name|i
index|]
operator|.
name|and
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|as_warn
argument_list|(
literal|"No such entry in list. (cpu/mmu register)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|segT
name|evaluate_expr
parameter_list|(
name|resultP
parameter_list|,
name|ptr
parameter_list|)
name|expressionS
modifier|*
name|resultP
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|tmp_line
decl_stmt|;
specifier|register
name|segT
name|segment
decl_stmt|;
name|tmp_line
operator|=
name|input_line_pointer
expr_stmt|;
name|input_line_pointer
operator|=
name|ptr
expr_stmt|;
name|segment
operator|=
name|expression
argument_list|(
operator|&
name|exprP
argument_list|)
expr_stmt|;
name|input_line_pointer
operator|=
name|tmp_line
expr_stmt|;
return|return
operator|(
name|segment
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert operands to iif-format and adds bitfields to the opcode.    Operands are parsed in such an order that the opcode is updated from    its most significant bit, that is when the operand need to alter the    opcode.    Be carefull not to put to objects in the same iif-slot.    */
end_comment

begin_function
name|void
name|encode_operand
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|,
name|operandsP
parameter_list|,
name|suffixP
parameter_list|,
name|im_size
parameter_list|,
name|opcode_bit_ptr
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|operandsP
decl_stmt|;
name|char
modifier|*
name|suffixP
decl_stmt|;
name|char
name|im_size
decl_stmt|;
name|char
name|opcode_bit_ptr
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|pcrel
decl_stmt|,
name|tmp
decl_stmt|,
name|b
decl_stmt|,
name|loop
decl_stmt|,
name|pcrel_adjust
decl_stmt|;
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
name|argc
condition|;
name|loop
operator|++
control|)
block|{
name|i
operator|=
name|operandsP
index|[
name|loop
operator|<<
literal|1
index|]
operator|-
literal|'1'
expr_stmt|;
comment|/* what operand are we supposed to work on */
if|if
condition|(
name|i
operator|>
literal|3
condition|)
name|as_fatal
argument_list|(
literal|"Internal consistency error.  check ns32k-opcode.h"
argument_list|)
expr_stmt|;
name|pcrel
operator|=
literal|0
expr_stmt|;
name|pcrel_adjust
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|operandsP
index|[
operator|(
name|loop
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
condition|)
block|{
case|case
literal|'f'
case|:
comment|/* operand of sfsr turns out to be a nasty specialcase */
name|opcode_bit_ptr
operator|-=
literal|5
expr_stmt|;
case|case
literal|'F'
case|:
comment|/* 32 bit float	general form */
case|case
literal|'L'
case|:
comment|/* 64 bit float	*/
case|case
literal|'Q'
case|:
comment|/* quad-word	*/
case|case
literal|'B'
case|:
comment|/* byte	 */
case|case
literal|'W'
case|:
comment|/* word	 */
case|case
literal|'D'
case|:
comment|/* double-word	*/
case|case
literal|'A'
case|:
comment|/* double-word	gen-address-form ie no regs allowed */
name|get_addr_mode
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
operator|&
name|addr_modeP
argument_list|)
expr_stmt|;
name|iif
operator|.
name|instr_size
operator|+=
name|addr_modeP
operator|.
name|am_size
expr_stmt|;
if|if
condition|(
name|opcode_bit_ptr
operator|==
name|desc
operator|->
name|opcode_size
condition|)
name|b
operator|=
literal|4
expr_stmt|;
else|else
name|b
operator|=
literal|6
expr_stmt|;
for|for
control|(
name|j
operator|=
name|b
init|;
name|j
operator|<
operator|(
name|b
operator|+
literal|2
operator|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|addr_modeP
operator|.
name|disp
index|[
name|j
operator|-
name|b
index|]
condition|)
block|{
name|IIF
argument_list|(
name|j
argument_list|,
literal|2
argument_list|,
name|addr_modeP
operator|.
name|disp_suffix
index|[
name|j
operator|-
name|b
index|]
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr_modeP
operator|.
name|disp
index|[
name|j
operator|-
name|b
index|]
argument_list|,
literal|0
argument_list|,
name|addr_modeP
operator|.
name|pcrel
argument_list|,
name|iif
operator|.
name|instr_size
operator|-
name|addr_modeP
operator|.
name|am_size
argument_list|,
comment|/* this aint used (now) */
name|addr_modeP
operator|.
name|im_disp
argument_list|,
name|IND
argument_list|(
name|BRANCH
argument_list|,
name|BYTE
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|addr_modeP
operator|.
name|scaled_reg
condition|?
name|addr_modeP
operator|.
name|scaled_mode
else|:
name|addr_modeP
operator|.
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|opcode_bit_ptr
operator|-=
literal|5
expr_stmt|;
name|iif
operator|.
name|iifP
index|[
literal|1
index|]
operator|.
name|object
operator||=
operator|(
operator|(
name|long
operator|)
name|addr_modeP
operator|.
name|mode
operator|)
operator|<<
name|opcode_bit_ptr
expr_stmt|;
if|if
condition|(
name|addr_modeP
operator|.
name|scaled_reg
condition|)
block|{
name|j
operator|=
name|b
operator|/
literal|2
expr_stmt|;
name|IIF
argument_list|(
name|j
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr_modeP
operator|.
name|index_byte
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'b'
case|:
comment|/* multiple instruction disp */
name|freeptr
operator|++
expr_stmt|;
comment|/* OVE:this is an useful hack */
name|tmp
operator|=
operator|(
name|int
operator|)
name|sprintf
argument_list|(
name|freeptr
argument_list|,
literal|"((%s-1)*%d)\000"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|desc
operator|->
name|im_size
argument_list|)
expr_stmt|;
name|argv
index|[
name|i
index|]
operator|=
name|freeptr
expr_stmt|;
name|freeptr
operator|=
operator|(
name|char
operator|*
operator|)
name|tmp
expr_stmt|;
name|pcrel
operator|-=
literal|1
expr_stmt|;
comment|/* make pcrel 0 inspite of what case 'p': wants */
comment|/* fall thru */
case|case
literal|'p'
case|:
comment|/* displacement - pc relative addressing */
name|pcrel
operator|+=
literal|1
expr_stmt|;
comment|/* fall thru */
case|case
literal|'d'
case|:
comment|/* displacement */
name|iif
operator|.
name|instr_size
operator|+=
name|suffixP
index|[
name|i
index|]
condition|?
name|suffixP
index|[
name|i
index|]
else|:
literal|4
expr_stmt|;
name|IIF
argument_list|(
literal|12
argument_list|,
literal|2
argument_list|,
name|suffixP
index|[
name|i
index|]
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|argv
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|pcrel
argument_list|,
name|pcrel_adjust
argument_list|,
literal|1
argument_list|,
name|IND
argument_list|(
name|BRANCH
argument_list|,
name|BYTE
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* sequent-hack: the linker wants a bit set when bsr */
name|pcrel
operator|=
literal|1
expr_stmt|;
name|iif
operator|.
name|instr_size
operator|+=
name|suffixP
index|[
name|i
index|]
condition|?
name|suffixP
index|[
name|i
index|]
else|:
literal|4
expr_stmt|;
name|IIF
argument_list|(
literal|12
argument_list|,
literal|2
argument_list|,
name|suffixP
index|[
name|i
index|]
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|argv
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|pcrel
argument_list|,
name|pcrel_adjust
argument_list|,
literal|1
argument_list|,
name|IND
argument_list|(
name|BRANCH
argument_list|,
name|BYTE
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* quick */
name|opcode_bit_ptr
operator|-=
literal|4
expr_stmt|;
name|IIF
argument_list|(
literal|11
argument_list|,
literal|2
argument_list|,
literal|42
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|argv
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|bit_fix_new
argument_list|(
literal|4
argument_list|,
name|opcode_bit_ptr
argument_list|,
operator|-
literal|8
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* register number (3 bits) */
name|list_search
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|opt6
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|opcode_bit_ptr
operator|-=
literal|3
expr_stmt|;
name|iif
operator|.
name|iifP
index|[
literal|1
index|]
operator|.
name|object
operator||=
name|tmp
operator|<<
name|opcode_bit_ptr
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
comment|/* setcfg instruction optionslist */
name|optlist
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|opt3
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|opcode_bit_ptr
operator|-=
literal|4
expr_stmt|;
name|iif
operator|.
name|iifP
index|[
literal|1
index|]
operator|.
name|object
operator||=
name|tmp
operator|<<
literal|15
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* cinv instruction optionslist */
name|optlist
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|opt4
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|opcode_bit_ptr
operator|-=
literal|4
expr_stmt|;
name|iif
operator|.
name|iifP
index|[
literal|1
index|]
operator|.
name|object
operator||=
name|tmp
operator|<<
literal|15
expr_stmt|;
comment|/*insert the regtype in opcode */
break|break;
case|case
literal|'S'
case|:
comment|/* stringinstruction optionslist */
name|optlist
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|opt5
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|opcode_bit_ptr
operator|-=
literal|4
expr_stmt|;
name|iif
operator|.
name|iifP
index|[
literal|1
index|]
operator|.
name|object
operator||=
name|tmp
operator|<<
literal|15
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
case|case
literal|'U'
case|:
comment|/* registerlist */
name|IIF
argument_list|(
literal|10
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|operandsP
index|[
operator|(
name|i
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
condition|)
block|{
case|case
literal|'u'
case|:
comment|/* restore, exit */
name|optlist
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|opt1
argument_list|,
operator|&
name|iif
operator|.
name|iifP
index|[
literal|10
index|]
operator|.
name|object
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* save,enter */
name|optlist
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|opt2
argument_list|,
operator|&
name|iif
operator|.
name|iifP
index|[
literal|10
index|]
operator|.
name|object
argument_list|)
expr_stmt|;
break|break;
block|}
name|iif
operator|.
name|instr_size
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* mmu register */
name|list_search
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|mmureg
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|opcode_bit_ptr
operator|-=
literal|4
expr_stmt|;
name|iif
operator|.
name|iifP
index|[
literal|1
index|]
operator|.
name|object
operator||=
name|tmp
operator|<<
name|opcode_bit_ptr
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* cpu register  */
name|list_search
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|cpureg
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|opcode_bit_ptr
operator|-=
literal|4
expr_stmt|;
name|iif
operator|.
name|iifP
index|[
literal|1
index|]
operator|.
name|object
operator||=
name|tmp
operator|<<
name|opcode_bit_ptr
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* inss exts */
name|iif
operator|.
name|instr_size
operator|+=
literal|1
expr_stmt|;
comment|/* 1 byte is allocated after the opcode */
name|IIF
argument_list|(
literal|10
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|argv
index|[
name|i
index|]
argument_list|,
comment|/* i always 2 here */
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|bit_fix_new
argument_list|(
literal|3
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
comment|/* a bit_fix is targeted to the byte */
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'G'
case|:
name|IIF
argument_list|(
literal|11
argument_list|,
literal|2
argument_list|,
literal|42
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|argv
index|[
name|i
index|]
argument_list|,
comment|/* i always 3 here */
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|bit_fix_new
argument_list|(
literal|5
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|32
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|iif
operator|.
name|instr_size
operator|+=
literal|1
expr_stmt|;
name|b
operator|=
literal|2
operator|+
name|i
expr_stmt|;
comment|/* put the extension byte after opcode */
name|IIF
argument_list|(
name|b
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
default|default:
name|as_fatal
argument_list|(
literal|"Bad opcode-table-option, check in file ns32k-opcode.h"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* in:  instruction line    out: internal structure of instruction    that has been prepared for direct conversion to fragment(s) and    fixes in a systematical fashion    Return-value = recursive_level    */
end_comment

begin_comment
comment|/* build iif of one assembly text line */
end_comment

begin_function
name|int
name|parse
parameter_list|(
name|line
parameter_list|,
name|recursive_level
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|int
name|recursive_level
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|lineptr
decl_stmt|,
name|c
decl_stmt|,
name|suffix_separator
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|argc
decl_stmt|,
name|arg_type
decl_stmt|;
name|char
name|sqr
decl_stmt|,
name|sep
decl_stmt|;
name|char
name|suffix
index|[
name|MAX_ARGS
index|]
decl_stmt|,
modifier|*
name|argv
index|[
name|MAX_ARGS
index|]
decl_stmt|;
comment|/* no more than 4 operands */
if|if
condition|(
name|recursive_level
operator|<=
literal|0
condition|)
block|{
comment|/* called from md_assemble */
for|for
control|(
name|lineptr
operator|=
name|line
init|;
operator|(
operator|*
name|lineptr
operator|)
operator|!=
literal|'\0'
operator|&&
operator|(
operator|*
name|lineptr
operator|)
operator|!=
literal|' '
condition|;
name|lineptr
operator|++
control|)
empty_stmt|;
name|c
operator|=
operator|*
name|lineptr
expr_stmt|;
operator|*
name|lineptr
operator|=
literal|'\0'
expr_stmt|;
name|desc
operator|=
operator|(
expr|struct
name|ns32k_opcode
operator|*
operator|)
name|hash_find
argument_list|(
name|inst_hash_handle
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|desc
condition|)
block|{
name|as_fatal
argument_list|(
literal|"No such opcode"
argument_list|)
expr_stmt|;
block|}
operator|*
name|lineptr
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|lineptr
operator|=
name|line
expr_stmt|;
block|}
name|argc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|desc
operator|->
name|operands
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|lineptr
operator|++
operator|!=
literal|'\0'
condition|)
block|{
name|sqr
operator|=
literal|'['
expr_stmt|;
name|sep
operator|=
literal|','
expr_stmt|;
while|while
condition|(
operator|*
name|lineptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|desc
operator|->
name|operands
index|[
name|argc
operator|<<
literal|1
index|]
condition|)
block|{
name|suffix
index|[
name|argc
index|]
operator|=
literal|0
expr_stmt|;
name|arg_type
operator|=
name|desc
operator|->
name|operands
index|[
operator|(
name|argc
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|arg_type
condition|)
block|{
case|case
literal|'d'
case|:
case|case
literal|'b'
case|:
case|case
literal|'p'
case|:
case|case
literal|'H'
case|:
comment|/* the operand is supposed to be a displacement */
comment|/* Hackwarning: do not forget to update the 4 cases above when editing ns32k-opcode.h */
name|suffix_separator
operator|=
literal|':'
expr_stmt|;
break|break;
default|default:
name|suffix_separator
operator|=
literal|'\255'
expr_stmt|;
comment|/* if this char occurs we loose */
block|}
name|suffix
index|[
name|argc
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 0 when no ':' is encountered */
name|argv
index|[
name|argc
index|]
operator|=
name|freeptr
expr_stmt|;
operator|*
name|freeptr
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|lineptr
operator|)
operator|!=
literal|'\0'
operator|&&
name|c
operator|!=
name|sep
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|sqr
condition|)
block|{
if|if
condition|(
name|sqr
operator|==
literal|'['
condition|)
block|{
name|sqr
operator|=
literal|']'
expr_stmt|;
name|sep
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|sqr
operator|=
literal|'['
expr_stmt|;
name|sep
operator|=
literal|','
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
name|suffix_separator
condition|)
block|{
comment|/* ':' - label/suffix separator */
switch|switch
condition|(
name|lineptr
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'b'
case|:
name|suffix
index|[
name|argc
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|suffix
index|[
name|argc
index|]
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|suffix
index|[
name|argc
index|]
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
name|as_warn
argument_list|(
literal|"Bad suffix, defaulting to d"
argument_list|)
expr_stmt|;
name|suffix
index|[
name|argc
index|]
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|lineptr
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|lineptr
index|[
literal|1
index|]
operator|==
name|sep
condition|)
block|{
name|lineptr
operator|+=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
name|lineptr
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
operator|*
name|freeptr
operator|++
operator|=
name|c
expr_stmt|;
name|lineptr
operator|++
expr_stmt|;
block|}
operator|*
name|freeptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|argc
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|lineptr
operator|==
literal|'\0'
condition|)
continue|continue;
name|lineptr
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|as_fatal
argument_list|(
literal|"Too many operands passed to instruction"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|argc
operator|!=
name|strlen
argument_list|(
name|desc
operator|->
name|operands
argument_list|)
operator|/
literal|2
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|desc
operator|->
name|default_args
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* we can apply default, dont goof */
if|if
condition|(
name|parse
argument_list|(
name|desc
operator|->
name|default_args
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
comment|/* check error in default */
name|as_fatal
argument_list|(
literal|"Wrong numbers of operands in default, check ns32k-opcodes.h"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|as_fatal
argument_list|(
literal|"Wrong number of operands"
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IIF_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
comment|/* mark all entries as void*/
block|}
comment|/* build opcode iif-entry */
name|iif
operator|.
name|instr_size
operator|=
name|desc
operator|->
name|opcode_size
operator|/
literal|8
expr_stmt|;
name|IIF
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
name|iif
operator|.
name|instr_size
argument_list|,
name|desc
operator|->
name|opcode_seed
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* this call encodes operands to iif format */
if|if
condition|(
name|argc
condition|)
block|{
name|encode_operand
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|desc
operator|->
name|operands
index|[
literal|0
index|]
argument_list|,
operator|&
name|suffix
index|[
literal|0
index|]
argument_list|,
name|desc
operator|->
name|im_size
argument_list|,
name|desc
operator|->
name|opcode_size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|recursive_level
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert iif to fragments.    From this point we start to dribble with functions in other files than    this one.(Except hash.c) So, if it's possible to make an iif for an other    CPU, you don't need to know what frags, relax, obstacks, etc is in order    to port this assembler. You only need to know if it's possible to reduce    your cpu-instruction to iif-format (takes some work) and adopt the other    md_? parts according to given instructions    Note that iif was invented for the clean ns32k`s architecure.    */
end_comment

begin_function
name|void
name|convert_iif
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|bit_fixS
modifier|*
name|bit_fixP
decl_stmt|;
name|fragS
modifier|*
name|inst_frag
decl_stmt|;
name|char
modifier|*
name|inst_offset
decl_stmt|;
name|char
modifier|*
name|inst_opcode
decl_stmt|;
name|char
modifier|*
name|memP
decl_stmt|;
name|segT
name|segment
decl_stmt|;
name|int
name|l
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|rem_size
decl_stmt|;
comment|/* count the remaining bytes of instruction */
name|char
name|type
decl_stmt|;
name|char
name|size
init|=
literal|0
decl_stmt|;
name|int
name|size_so_far
init|=
literal|0
decl_stmt|;
comment|/* used to calculate pcrel_adjust */
name|int
name|pcrel_symbols
init|=
literal|0
decl_stmt|;
comment|/* kludge by jkp@hut.fi to make  				   movd _foo(pc),_bar(pc) work.  				   It should be done with two frags  				   for one insn, but I don't understand  				   enough to make it work */
name|rem_size
operator|=
name|iif
operator|.
name|instr_size
expr_stmt|;
name|memP
operator|=
name|frag_more
argument_list|(
name|iif
operator|.
name|instr_size
argument_list|)
expr_stmt|;
comment|/* make sure we have enough bytes for instruction */
name|inst_opcode
operator|=
name|memP
expr_stmt|;
name|inst_offset
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|memP
operator|-
name|frag_now
operator|->
name|fr_literal
operator|)
expr_stmt|;
name|inst_frag
operator|=
name|frag_now
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IIF_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
comment|/* jkp kludge alert */
if|if
condition|(
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|type
operator|&&
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|size
operator|==
literal|0
operator|&&
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|pcrel
condition|)
block|{
name|evaluate_expr
argument_list|(
operator|&
name|exprP
argument_list|,
operator|(
name|char
operator|*
operator|)
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|exprP
operator|.
name|X_add_symbol
operator|||
name|exprP
operator|.
name|X_subtract_symbol
condition|)
name|pcrel_symbols
operator|++
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IIF_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|type
operator|=
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
comment|/* the object exist, so handle it */
ifdef|#
directive|ifdef
name|PIC
name|int
name|reloc_mode
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
literal|4
operator|||
name|i
operator|==
literal|6
operator|)
operator|&&
name|picmode
operator|&&
operator|(
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|addr_mode
operator|==
literal|18
operator|||
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|addr_mode
operator|==
literal|26
operator|)
condition|)
name|reloc_mode
operator|=
name|RELOC_GLOB_DAT
expr_stmt|;
else|else
name|reloc_mode
operator|=
name|NO_RELOC
expr_stmt|;
else|#
directive|else
name|int
name|reloc_mode
init|=
name|NO_RELOC
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|size
operator|=
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|size
condition|)
block|{
case|case
literal|42
case|:
name|size
operator|=
literal|0
expr_stmt|;
comment|/* it's a bitfix that operates on an existing object*/
if|if
condition|(
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|bit_fixP
operator|->
name|fx_bit_base
condition|)
block|{
comment|/* expand fx_bit_base to point at opcode */
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|bit_fixP
operator|->
name|fx_bit_base
operator|=
operator|(
name|long
operator|)
name|inst_opcode
expr_stmt|;
block|}
case|case
literal|8
case|:
comment|/* bignum or doublefloat */
name|memset
argument_list|(
name|memP
argument_list|,
literal|'\0'
argument_list|,
literal|8
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
literal|4
case|:
comment|/* the final size in objectmemory is known */
name|bit_fixP
operator|=
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|bit_fixP
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|1
case|:
comment|/* the object is pure binary */
if|if
condition|(
name|bit_fixP
operator|||
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|pcrel
condition|)
block|{
name|fix_new_ns32k
argument_list|(
name|frag_now
argument_list|,
call|(
name|long
call|)
argument_list|(
name|memP
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|)
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|object
argument_list|,
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|pcrel
argument_list|,
operator|(
name|char
operator|)
name|size_so_far
argument_list|,
comment|/*iif.iifP[i].pcrel_adjust,*/
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|im_disp
argument_list|,
name|bit_fixP
argument_list|,
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|bsr
argument_list|,
comment|/* sequent hack */
name|reloc_mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* good, just put them bytes out */
switch|switch
condition|(
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|im_disp
condition|)
block|{
case|case
literal|0
case|:
name|md_number_to_chars
argument_list|(
name|memP
argument_list|,
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|object
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|md_number_to_disp
argument_list|(
name|memP
argument_list|,
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|object
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"iif convert internal pcrel/binary"
argument_list|)
expr_stmt|;
block|}
block|}
name|memP
operator|+=
name|size
expr_stmt|;
name|rem_size
operator|-=
name|size
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* the object is a pointer at an expression, so unpack 					   it, note that bignums may result from the expression 					   */
if|if
condition|(
operator|(
name|segment
operator|=
name|evaluate_expr
argument_list|(
operator|&
name|exprP
argument_list|,
operator|(
name|char
operator|*
operator|)
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|object
argument_list|)
operator|)
operator|==
name|SEG_BIG
operator|||
name|size
operator|==
literal|8
condition|)
block|{
if|if
condition|(
operator|(
name|k
operator|=
name|exprP
operator|.
name|X_add_number
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* we have a bignum ie a quad */
comment|/* this can only happens in a long suffixed instruction */
name|memset
argument_list|(
name|memP
argument_list|,
literal|'\0'
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* size normally is 8 */
if|if
condition|(
name|k
operator|*
literal|2
operator|>
name|size
condition|)
name|as_warn
argument_list|(
literal|"Bignum too big for long"
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|3
condition|)
name|memP
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|k
operator|>
literal|0
condition|;
name|k
operator|--
operator|,
name|l
operator|+=
literal|2
control|)
block|{
name|md_number_to_chars
argument_list|(
name|memP
operator|+
name|l
argument_list|,
name|generic_bignum
index|[
name|l
operator|>>
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* flonum */
name|LITTLENUM_TYPE
name|words
index|[
literal|4
index|]
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|4
case|:
name|gen_to_words
argument_list|(
name|words
argument_list|,
literal|2
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|md_number_to_imm
argument_list|(
name|memP
argument_list|,
operator|(
name|long
operator|)
name|words
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_imm
argument_list|(
name|memP
operator|+
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|words
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|gen_to_words
argument_list|(
name|words
argument_list|,
literal|4
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|md_number_to_imm
argument_list|(
name|memP
argument_list|,
operator|(
name|long
operator|)
name|words
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_imm
argument_list|(
name|memP
operator|+
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|words
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_imm
argument_list|(
name|memP
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|words
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_imm
argument_list|(
name|memP
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|words
index|[
literal|3
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|memP
operator|+=
name|size
expr_stmt|;
name|rem_size
operator|-=
name|size
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bit_fixP
operator|||
name|exprP
operator|.
name|X_add_symbol
operator|||
name|exprP
operator|.
name|X_subtract_symbol
operator|||
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|pcrel
condition|)
block|{
comment|/* fixit */
comment|/* the expression was undefined due to an undefined label */
comment|/* create a fix so we can fix the object later */
name|exprP
operator|.
name|X_add_number
operator|+=
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|object_adjust
expr_stmt|;
name|fix_new_ns32k
argument_list|(
name|frag_now
argument_list|,
call|(
name|long
call|)
argument_list|(
name|memP
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|)
argument_list|,
name|size
argument_list|,
name|exprP
operator|.
name|X_add_symbol
argument_list|,
name|exprP
operator|.
name|X_subtract_symbol
argument_list|,
name|exprP
operator|.
name|X_add_number
argument_list|,
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|pcrel
argument_list|,
operator|(
name|char
operator|)
name|size_so_far
argument_list|,
comment|/*iif.iifP[i].pcrel_adjust,*/
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|im_disp
argument_list|,
name|bit_fixP
argument_list|,
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|bsr
argument_list|,
comment|/* sequent hack */
name|reloc_mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* good, just put them bytes out */
switch|switch
condition|(
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|im_disp
condition|)
block|{
case|case
literal|0
case|:
name|md_number_to_imm
argument_list|(
name|memP
argument_list|,
name|exprP
operator|.
name|X_add_number
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|md_number_to_disp
argument_list|(
name|memP
argument_list|,
name|exprP
operator|.
name|X_add_number
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"iif convert internal pcrel/pointer"
argument_list|)
expr_stmt|;
block|}
block|}
name|memP
operator|+=
name|size
expr_stmt|;
name|rem_size
operator|-=
name|size
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"Internal logic error in iif.iifP[n].type"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0
case|:
comment|/* To bad, the object may be undefined as far as its final 					    nsize in object memory is concerned. The size of the object 					    in objectmemory is not explicitly given. 					    If the object is defined its length can be determined and 					    a fix can replace the frag. 					    */
block|{
name|int
name|temp
decl_stmt|;
name|segment
operator|=
name|evaluate_expr
argument_list|(
operator|&
name|exprP
argument_list|,
operator|(
name|char
operator|*
operator|)
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|exprP
operator|.
name|X_add_symbol
operator|||
name|exprP
operator|.
name|X_subtract_symbol
operator|)
operator|&&
operator|!
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|pcrel
operator|)
operator|||
name|pcrel_symbols
operator|>=
literal|2
comment|/*jkp*/
condition|)
block|{
comment|/* OVE: hack, clamp to 4 bytes */
ifdef|#
directive|ifdef
name|PIC
if|if
condition|(
name|reloc_mode
operator|==
name|RELOC_GLOB_DAT
operator|&&
name|got_offset_size
operator|==
literal|2
condition|)
block|{
name|size
operator|=
literal|2
expr_stmt|;
comment|/* rewind the bytes not used */
name|obstack_blank_fast
argument_list|(
operator|&
name|frags
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|size
operator|=
literal|4
expr_stmt|;
comment|/* we dont wan't to frag this, use 4 so it reaches */
name|fix_new_ns32k
argument_list|(
name|frag_now
argument_list|,
call|(
name|long
call|)
argument_list|(
name|memP
operator|-
name|frag_now
operator|->
name|fr_literal
argument_list|)
argument_list|,
name|size
argument_list|,
name|exprP
operator|.
name|X_add_symbol
argument_list|,
name|exprP
operator|.
name|X_subtract_symbol
argument_list|,
name|exprP
operator|.
name|X_add_number
argument_list|,
name|pcrel_symbols
operator|>=
literal|2
condition|?
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|pcrel
else|:
literal|0
argument_list|,
comment|/*jkp*/
comment|/* never iif.iifP[i].pcrel, */
operator|(
name|char
operator|)
name|size_so_far
argument_list|,
comment|/*iif.iifP[i].pcrel_adjust,*/
literal|1
argument_list|,
comment|/* always iif.iifP[i].im_disp, */
literal|0
argument_list|,
literal|0
argument_list|,
name|reloc_mode
argument_list|)
expr_stmt|;
name|memP
operator|+=
name|size
expr_stmt|;
name|rem_size
operator|-=
literal|4
expr_stmt|;
break|break;
comment|/* exit this absolute hack */
block|}
if|if
condition|(
name|exprP
operator|.
name|X_add_symbol
operator|||
name|exprP
operator|.
name|X_subtract_symbol
condition|)
block|{
comment|/* frag it */
if|if
condition|(
name|exprP
operator|.
name|X_subtract_symbol
condition|)
block|{
comment|/* We cant relax this case */
name|as_fatal
argument_list|(
literal|"Can't relax difference"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* at this stage we must undo some of the effect caused 							   by frag_more, ie we must make sure that frag_var causes 							   frag_new to creat a valid fix-size in the frag it`s closing 							   */
name|temp
operator|=
operator|-
operator|(
name|rem_size
operator|-
literal|4
operator|)
expr_stmt|;
name|obstack_blank_fast
argument_list|(
operator|&
name|frags
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* we rewind none, some or all of the requested size we 							   requested by the first frag_more for this iif chunk. 							   Note: that we allocate 4 bytes to an object we NOT YET 							   know the size of, thus rem_size-4. 							   */
operator|(
name|void
operator|)
name|frag_variant
argument_list|(
name|rs_machine_dependent
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|IND
argument_list|(
name|BRANCH
argument_list|,
name|UNDEF
argument_list|)
argument_list|,
comment|/* expecting the worst */
name|exprP
operator|.
name|X_add_symbol
argument_list|,
name|exprP
operator|.
name|X_add_number
argument_list|,
name|inst_opcode
argument_list|,
operator|(
name|char
operator|)
name|size_so_far
argument_list|,
comment|/*iif.iifP[i].pcrel_adjust);*/
name|iif
operator|.
name|iifP
index|[
name|i
index|]
operator|.
name|bsr
argument_list|)
expr_stmt|;
comment|/* sequent linker hack */
name|rem_size
operator|-=
literal|4
expr_stmt|;
if|if
condition|(
name|rem_size
operator|>
literal|0
condition|)
block|{
name|memP
operator|=
name|frag_more
argument_list|(
name|rem_size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Double work, this is done in md_number_to_disp */
comment|/* exprP.X_add_number; fixme-soon what was this supposed to be? xoxorich. */
if|if
condition|(
operator|-
literal|64
operator|<=
name|exprP
operator|.
name|X_add_number
operator|&&
name|exprP
operator|.
name|X_add_number
operator|<=
literal|63
condition|)
block|{
name|size
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|-
literal|8192
operator|<=
name|exprP
operator|.
name|X_add_number
operator|&&
name|exprP
operator|.
name|X_add_number
operator|<=
literal|8191
condition|)
block|{
name|size
operator|=
literal|2
expr_stmt|;
comment|/* Dave Taylor<taylor@think.com> says: Note: The reason the lower 								   limit is -0x1f000000 and not -0x20000000 is that, according to 								   Nat'l Semi's data sheet on the ns32532, ``the pattern 11100000 								   for the most significant byte of the displacement is reserved by 								   National for future enhancements''.  */
block|}
elseif|else
if|if
condition|(
comment|/* -0x40000000<= exprP.X_add_number&& 								    exprP.X_add_number<= 0x3fffffff */
operator|-
literal|0x1f000000
operator|<=
name|exprP
operator|.
name|X_add_number
operator|&&
name|exprP
operator|.
name|X_add_number
operator|<=
literal|0x1fffffff
condition|)
block|{
name|size
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|as_warn
argument_list|(
literal|"Displacement too large for :d"
argument_list|)
expr_stmt|;
name|size
operator|=
literal|4
expr_stmt|;
block|}
block|}
comment|/* rewind the bytes not used */
name|temp
operator|=
operator|-
operator|(
literal|4
operator|-
name|size
operator|)
expr_stmt|;
name|md_number_to_disp
argument_list|(
name|memP
argument_list|,
name|exprP
operator|.
name|X_add_number
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|obstack_blank_fast
argument_list|(
operator|&
name|frags
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|memP
operator|+=
name|size
expr_stmt|;
name|rem_size
operator|-=
literal|4
expr_stmt|;
comment|/* we allocated this amount */
block|}
block|}
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"Internal logic error in iif.iifP[].type"
argument_list|)
expr_stmt|;
block|}
name|size_so_far
operator|+=
name|size
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|md_assemble
parameter_list|(
name|line
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
block|{
name|freeptr
operator|=
name|freeptr_static
expr_stmt|;
name|parse
argument_list|(
name|line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* explode line to more fix form in iif */
name|convert_iif
argument_list|()
expr_stmt|;
comment|/* convert iif to frags, fix's etc */
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|" \t\t\t%s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|md_begin
parameter_list|()
block|{
comment|/* build a hashtable of the instructions */
specifier|register
specifier|const
name|struct
name|ns32k_opcode
modifier|*
name|ptr
decl_stmt|;
specifier|register
name|char
modifier|*
name|stat
decl_stmt|;
name|inst_hash_handle
operator|=
name|hash_new
argument_list|()
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|ns32k_opcodes
init|;
name|ptr
operator|<
name|endop
condition|;
name|ptr
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|stat
operator|=
name|hash_insert
argument_list|(
name|inst_hash_handle
argument_list|,
name|ptr
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ptr
argument_list|)
operator|)
condition|)
block|{
name|as_fatal
argument_list|(
literal|"Can't hash %s: %s"
argument_list|,
name|ptr
operator|->
name|name
argument_list|,
name|stat
argument_list|)
expr_stmt|;
comment|/*fatal*/
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|freeptr_static
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|PRIVATE_SIZE
argument_list|)
expr_stmt|;
comment|/* some private space please! */
block|}
end_function

begin_function
name|void
name|md_end
parameter_list|()
block|{
name|free
argument_list|(
name|freeptr_static
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Must be equal to MAX_PRECISON in atof-ieee.c */
end_comment

begin_define
define|#
directive|define
name|MAX_LITTLENUMS
value|6
end_define

begin_comment
comment|/* Turn the string pointed to by litP into a floating point constant of type    type, and emit the appropriate bytes.  The number of LITTLENUMS emitted    is stored in *sizeP. An error message is returned, or NULL on OK.    */
end_comment

begin_function
name|char
modifier|*
name|md_atof
parameter_list|(
name|type
parameter_list|,
name|litP
parameter_list|,
name|sizeP
parameter_list|)
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|litP
decl_stmt|;
name|int
modifier|*
name|sizeP
decl_stmt|;
block|{
name|int
name|prec
decl_stmt|;
name|LITTLENUM_TYPE
name|words
index|[
name|MAX_LITTLENUMS
index|]
decl_stmt|;
name|LITTLENUM_TYPE
modifier|*
name|wordP
decl_stmt|;
specifier|extern
name|char
modifier|*
name|atof_ieee
parameter_list|()
function_decl|;
name|char
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'f'
case|:
name|prec
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|prec
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
operator|*
name|sizeP
operator|=
literal|0
expr_stmt|;
return|return
literal|"Bad call to MD_ATOF()"
return|;
block|}
name|t
operator|=
name|atof_ieee
argument_list|(
name|input_line_pointer
argument_list|,
name|type
argument_list|,
name|words
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|input_line_pointer
operator|=
name|t
expr_stmt|;
operator|*
name|sizeP
operator|=
name|prec
operator|*
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
for|for
control|(
name|wordP
operator|=
name|words
operator|+
name|prec
init|;
name|prec
operator|--
condition|;
control|)
block|{
name|md_number_to_chars
argument_list|(
name|litP
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|*
operator|--
name|wordP
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
argument_list|)
expr_stmt|;
name|litP
operator|+=
sizeof|sizeof
argument_list|(
name|LITTLENUM_TYPE
argument_list|)
expr_stmt|;
block|}
return|return
literal|""
return|;
comment|/* Someone should teach Dean about null pointers */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert number to chars in correct order */
end_comment

begin_function
name|void
name|md_number_to_chars
parameter_list|(
name|buf
parameter_list|,
name|value
parameter_list|,
name|nbytes
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|value
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
while|while
condition|(
name|nbytes
operator|--
condition|)
block|{
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|value
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
name|value
expr_stmt|;
comment|/* Lint wants& MASK_CHAR. */
name|value
operator|>>=
name|BITS_PER_CHAR
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* md_number_to_chars() */
end_comment

begin_comment
comment|/* This is a variant of md_numbers_to_chars. The reason for its' existence    is the fact that ns32k uses Huffman coded displacements. This implies    that the bit order is reversed in displacements and that they are prefixed    with a size-tag.     binary: msb->lsb    0xxxxxxx				byte    10xxxxxx xxxxxxxx			word    11xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx	double word     This must be taken care of and we do it here!    */
end_comment

begin_function
specifier|static
name|void
name|md_number_to_disp
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|val
decl_stmt|;
name|char
name|n
decl_stmt|;
block|{
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|val
operator|<
operator|-
literal|64
operator|||
name|val
operator|>
literal|63
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"val = %d\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|as_warn
argument_list|(
literal|"Byte displacement out of range.  line number not valid"
argument_list|)
expr_stmt|;
block|}
name|val
operator|&=
literal|0x7f
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|val
operator|<
operator|-
literal|8192
operator|||
name|val
operator|>
literal|8191
condition|)
name|as_warn
argument_list|(
literal|"Word displacement out of range.  line number not valid"
argument_list|)
expr_stmt|;
name|val
operator|&=
literal|0x3fff
expr_stmt|;
name|val
operator||=
literal|0x8000
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|>>
literal|8
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* Dave Taylor<taylor@think.com> says: Note: The reason the 		   lower limit is -0x1f000000 and not -0x20000000 is that, 		   according to Nat'l Semi's data sheet on the ns32532, ``the 		   pattern 11100000 for the most significant byte of the 		   displacement is reserved by National for future 		   enhancements''.  */
if|if
condition|(
name|val
operator|<
operator|-
literal|0x1f000000
operator|||
name|val
operator|>=
literal|0x20000000
condition|)
name|as_warn
argument_list|(
literal|"Double word displacement out of range"
argument_list|)
expr_stmt|;
name|val
operator||=
literal|0xc0000000
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|>>
literal|24
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|24
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|>>
literal|16
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|>>
literal|8
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"Internal logic error.  line %s, file \"%s\""
argument_list|,
name|__LINE__
argument_list|,
name|__FILE__
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|md_number_to_imm
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|val
decl_stmt|;
name|char
name|n
decl_stmt|;
block|{
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|1
case|:
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
case|case
literal|2
case|:
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|>>
literal|8
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
case|case
literal|4
case|:
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|>>
literal|24
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|24
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|>>
literal|16
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|>>
literal|8
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
operator|(
name|val
operator|>>
literal|8
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_NUM
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|val
operator|&
literal|0xff
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
name|val
expr_stmt|;
break|break;
default|default:
name|as_fatal
argument_list|(
literal|"Internal logic error. line %s, file \"%s\""
argument_list|,
name|__LINE__
argument_list|,
name|__FILE__
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Translate internal representation of relocation info into target format.     OVE: on a ns32k the twiddling continues at an even deeper level    here we have to distinguish between displacements and immediates.     The sequent has a bit for this. It also has a bit for relocobjects that    points at the target for a bsr (BranchSubRoutine) !?!?!?!     This md_ri.... is tailored for sequent.    */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|comment
end_ifdef

begin_function
name|void
name|md_ri_to_chars
parameter_list|(
name|the_bytes
parameter_list|,
name|ri
parameter_list|)
name|char
modifier|*
name|the_bytes
decl_stmt|;
name|struct
name|reloc_info_generic
modifier|*
name|ri
decl_stmt|;
block|{
if|if
condition|(
name|ri
operator|->
name|r_bsr
condition|)
block|{
name|ri
operator|->
name|r_pcrel
operator|=
literal|0
expr_stmt|;
block|}
comment|/* sequent seems to want this */
name|md_number_to_chars
argument_list|(
name|the_bytes
argument_list|,
name|ri
operator|->
name|r_address
argument_list|,
sizeof|sizeof
argument_list|(
name|ri
operator|->
name|r_address
argument_list|)
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|the_bytes
operator|+
literal|4
argument_list|,
operator|(
call|(
name|long
call|)
argument_list|(
name|ri
operator|->
name|r_symbolnum
argument_list|)
operator||
call|(
name|long
call|)
argument_list|(
name|ri
operator|->
name|r_pcrel
operator|<<
literal|24
argument_list|)
operator||
call|(
name|long
call|)
argument_list|(
name|ri
operator|->
name|r_length
operator|<<
literal|25
argument_list|)
operator||
call|(
name|long
call|)
argument_list|(
name|ri
operator|->
name|r_extern
operator|<<
literal|27
argument_list|)
operator||
call|(
name|long
call|)
argument_list|(
name|ri
operator|->
name|r_bsr
operator|<<
literal|28
argument_list|)
operator||
call|(
name|long
call|)
argument_list|(
name|ri
operator|->
name|r_disp
operator|<<
literal|29
argument_list|)
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* the first and second md_number_to_chars never overlaps (32bit cpu case) */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* comment */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|OBJ_AOUT
end_ifdef

begin_function
name|void
name|tc_aout_fix_to_chars
parameter_list|(
name|where
parameter_list|,
name|fixP
parameter_list|,
name|segment_address_in_file
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|relax_addressT
name|segment_address_in_file
decl_stmt|;
block|{
comment|/* 	 * In: length of relocation (or of address) in chars: 1, 2 or 4. 	 * Out: GNU LD relocation length code: 0, 1, or 2. 	 */
specifier|static
name|unsigned
name|char
name|nbytes_r_length
index|[]
init|=
block|{
literal|42
block|,
literal|0
block|,
literal|1
block|,
literal|42
block|,
literal|2
block|}
decl_stmt|;
name|long
name|r_symbolnum
decl_stmt|;
name|int
name|r_flags
decl_stmt|;
name|know
argument_list|(
name|fixP
operator|->
name|fx_addsy
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|where
argument_list|,
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
operator|+
name|fixP
operator|->
name|fx_where
operator|-
name|segment_address_in_file
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|r_symbolnum
operator|=
operator|(
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|?
name|S_GET_TYPE
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
else|:
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_number
operator|)
expr_stmt|;
name|r_flags
operator|=
operator|(
name|fixP
operator|->
name|fx_pcrel
condition|?
literal|1
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|nbytes_r_length
index|[
name|fixP
operator|->
name|fx_size
index|]
operator|&
literal|3
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|?
literal|8
else|:
literal|0
operator|)
if|#
directive|if
name|defined
argument_list|(
name|TE_SEQUENT
argument_list|)
operator||
operator|(
name|fixP
operator|->
name|fx_bsr
condition|?
literal|0x10
else|:
literal|0
operator|)
elif|#
directive|elif
name|defined
argument_list|(
name|PIC
argument_list|)
comment|/* Undefined pc-relative relocations are of type jmpslot */
operator||
operator|(
operator|(
operator|!
name|S_IS_DEFINED
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
operator|&&
name|fixP
operator|->
name|fx_pcrel
operator|&&
name|fixP
operator|->
name|fx_addsy
operator|!=
name|got_symbol
operator|&&
name|picmode
operator|)
condition|?
literal|0x10
else|:
literal|0
operator|)
endif|#
directive|endif
operator||
operator|(
name|fixP
operator|->
name|fx_im_disp
operator|&
literal|3
operator|)
operator|<<
literal|5
expr_stmt|;
ifdef|#
directive|ifdef
name|PIC
switch|switch
condition|(
name|fixP
operator|->
name|fx_r_type
condition|)
block|{
case|case
name|NO_RELOC
case|:
break|break;
case|case
name|RELOC_32
case|:
if|if
condition|(
name|picmode
operator|&&
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
block|{
name|r_symbolnum
operator|=
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_number
expr_stmt|;
name|r_flags
operator||=
literal|8
expr_stmt|;
comment|/* set extern bit */
block|}
break|break;
case|case
name|RELOC_GLOB_DAT
case|:
if|if
condition|(
operator|!
name|fixP
operator|->
name|fx_pcrel
condition|)
block|{
name|r_flags
operator||=
literal|0x80
expr_stmt|;
comment|/* set baserel bit */
name|r_symbolnum
operator|=
name|fixP
operator|->
name|fx_addsy
operator|->
name|sy_number
expr_stmt|;
if|if
condition|(
name|S_IS_EXTERNAL
argument_list|(
name|fixP
operator|->
name|fx_addsy
argument_list|)
condition|)
name|r_flags
operator||=
literal|8
expr_stmt|;
block|}
break|break;
case|case
name|RELOC_RELATIVE
case|:
comment|/* should never happen */
name|as_fatal
argument_list|(
literal|"relocation botch"
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* PIC */
name|where
index|[
literal|4
index|]
operator|=
name|r_symbolnum
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|5
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|8
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|6
index|]
operator|=
operator|(
name|r_symbolnum
operator|>>
literal|16
operator|)
operator|&
literal|0x0ff
expr_stmt|;
name|where
index|[
literal|7
index|]
operator|=
name|r_flags
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* tc_aout_fix_to_chars() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJ_AOUT */
end_comment

begin_comment
comment|/* fast bitfiddling support */
end_comment

begin_comment
comment|/* mask used to zero bitfield before oring in the true field */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|l_mask
index|[]
init|=
block|{
literal|0xffffffff
block|,
literal|0xfffffffe
block|,
literal|0xfffffffc
block|,
literal|0xfffffff8
block|,
literal|0xfffffff0
block|,
literal|0xffffffe0
block|,
literal|0xffffffc0
block|,
literal|0xffffff80
block|,
literal|0xffffff00
block|,
literal|0xfffffe00
block|,
literal|0xfffffc00
block|,
literal|0xfffff800
block|,
literal|0xfffff000
block|,
literal|0xffffe000
block|,
literal|0xffffc000
block|,
literal|0xffff8000
block|,
literal|0xffff0000
block|,
literal|0xfffe0000
block|,
literal|0xfffc0000
block|,
literal|0xfff80000
block|,
literal|0xfff00000
block|,
literal|0xffe00000
block|,
literal|0xffc00000
block|,
literal|0xff800000
block|,
literal|0xff000000
block|,
literal|0xfe000000
block|,
literal|0xfc000000
block|,
literal|0xf8000000
block|,
literal|0xf0000000
block|,
literal|0xe0000000
block|,
literal|0xc0000000
block|,
literal|0x80000000
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|r_mask
index|[]
init|=
block|{
literal|0x00000000
block|,
literal|0x00000001
block|,
literal|0x00000003
block|,
literal|0x00000007
block|,
literal|0x0000000f
block|,
literal|0x0000001f
block|,
literal|0x0000003f
block|,
literal|0x0000007f
block|,
literal|0x000000ff
block|,
literal|0x000001ff
block|,
literal|0x000003ff
block|,
literal|0x000007ff
block|,
literal|0x00000fff
block|,
literal|0x00001fff
block|,
literal|0x00003fff
block|,
literal|0x00007fff
block|,
literal|0x0000ffff
block|,
literal|0x0001ffff
block|,
literal|0x0003ffff
block|,
literal|0x0007ffff
block|,
literal|0x000fffff
block|,
literal|0x001fffff
block|,
literal|0x003fffff
block|,
literal|0x007fffff
block|,
literal|0x00ffffff
block|,
literal|0x01ffffff
block|,
literal|0x03ffffff
block|,
literal|0x07ffffff
block|,
literal|0x0fffffff
block|,
literal|0x1fffffff
block|,
literal|0x3fffffff
block|,
literal|0x7fffffff
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MASK_BITS
value|31
end_define

begin_comment
comment|/* Insert bitfield described by field_ptr and val at buf    This routine is written for modification of the first 4 bytes pointed    to by buf, to yield speed.    The ifdef stuff is for selection between a ns32k-dependent routine    and a general version. (My advice: use the general version!)    */
end_comment

begin_function
specifier|static
name|void
name|md_number_to_field
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|,
name|field_ptr
parameter_list|)
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
specifier|register
name|long
name|val
decl_stmt|;
specifier|register
name|bit_fixS
modifier|*
name|field_ptr
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|object
decl_stmt|;
specifier|register
name|unsigned
name|long
name|mask
decl_stmt|;
comment|/* define ENDIAN on a ns32k machine */
ifdef|#
directive|ifdef
name|ENDIAN
specifier|register
name|unsigned
name|long
modifier|*
name|mem_ptr
decl_stmt|;
else|#
directive|else
specifier|register
name|char
modifier|*
name|mem_ptr
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|field_ptr
operator|->
name|fx_bit_min
operator|<=
name|val
operator|&&
name|val
operator|<=
name|field_ptr
operator|->
name|fx_bit_max
condition|)
block|{
ifdef|#
directive|ifdef
name|ENDIAN
if|if
condition|(
name|field_ptr
operator|->
name|fx_bit_base
condition|)
block|{
comment|/* override buf */
name|mem_ptr
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|field_ptr
operator|->
name|fx_bit_base
expr_stmt|;
block|}
else|else
block|{
name|mem_ptr
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|buf
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|field_ptr
operator|->
name|fx_bit_base
condition|)
block|{
comment|/* override buf */
name|mem_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|field_ptr
operator|->
name|fx_bit_base
expr_stmt|;
block|}
else|else
block|{
name|mem_ptr
operator|=
name|buf
expr_stmt|;
block|}
endif|#
directive|endif
name|mem_ptr
operator|+=
name|field_ptr
operator|->
name|fx_bit_base_adj
expr_stmt|;
ifdef|#
directive|ifdef
name|ENDIAN
comment|/* we have a nice ns32k machine with lowbyte at low-physical mem */
name|object
operator|=
operator|*
name|mem_ptr
expr_stmt|;
comment|/* get some bytes */
else|#
directive|else
comment|/* OVE Goof! the machine is a m68k or dito */
comment|/* That takes more byte fiddling */
name|object
operator|=
literal|0
expr_stmt|;
name|object
operator||=
name|mem_ptr
index|[
literal|3
index|]
operator|&
literal|0xff
expr_stmt|;
name|object
operator|<<=
literal|8
expr_stmt|;
name|object
operator||=
name|mem_ptr
index|[
literal|2
index|]
operator|&
literal|0xff
expr_stmt|;
name|object
operator|<<=
literal|8
expr_stmt|;
name|object
operator||=
name|mem_ptr
index|[
literal|1
index|]
operator|&
literal|0xff
expr_stmt|;
name|object
operator|<<=
literal|8
expr_stmt|;
name|object
operator||=
name|mem_ptr
index|[
literal|0
index|]
operator|&
literal|0xff
expr_stmt|;
endif|#
directive|endif
name|mask
operator|=
literal|0
expr_stmt|;
name|mask
operator||=
operator|(
name|r_mask
index|[
name|field_ptr
operator|->
name|fx_bit_offset
index|]
operator|)
expr_stmt|;
name|mask
operator||=
operator|(
name|l_mask
index|[
name|field_ptr
operator|->
name|fx_bit_offset
operator|+
name|field_ptr
operator|->
name|fx_bit_size
index|]
operator|)
expr_stmt|;
name|object
operator|&=
name|mask
expr_stmt|;
name|val
operator|+=
name|field_ptr
operator|->
name|fx_bit_add
expr_stmt|;
name|object
operator||=
operator|(
operator|(
name|val
operator|<<
name|field_ptr
operator|->
name|fx_bit_offset
operator|)
operator|&
operator|(
name|mask
operator|^
literal|0xffffffff
operator|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENDIAN
operator|*
name|mem_ptr
operator|=
name|object
expr_stmt|;
else|#
directive|else
name|mem_ptr
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|object
expr_stmt|;
name|object
operator|>>=
literal|8
expr_stmt|;
name|mem_ptr
index|[
literal|1
index|]
operator|=
operator|(
name|char
operator|)
name|object
expr_stmt|;
name|object
operator|>>=
literal|8
expr_stmt|;
name|mem_ptr
index|[
literal|2
index|]
operator|=
operator|(
name|char
operator|)
name|object
expr_stmt|;
name|object
operator|>>=
literal|8
expr_stmt|;
name|mem_ptr
index|[
literal|3
index|]
operator|=
operator|(
name|char
operator|)
name|object
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|as_warn
argument_list|(
literal|"Bit field out of range"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Apply a fixS (fixup of an instruction or data that we didn't have    enough info to complete immediately) to the data in a frag.     On the ns32k, everything is in a different format, so we have broken    out separate functions for each kind of thing we could be fixing.    They all get called from here.  */
end_comment

begin_function
name|void
name|md_apply_fix
parameter_list|(
name|fixP
parameter_list|,
name|val
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
name|long
name|val
decl_stmt|;
block|{
name|char
modifier|*
name|buf
init|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_literal
decl_stmt|;
if|if
condition|(
name|fixP
operator|->
name|fx_bit_fixP
condition|)
block|{
comment|/* Bitfields to fix, sigh */
name|md_number_to_field
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|fixP
operator|->
name|fx_bit_fixP
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|fixP
operator|->
name|fx_im_disp
condition|)
block|{
case|case
literal|0
case|:
comment|/* Immediate field */
name|md_number_to_imm
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Displacement field */
name|md_number_to_disp
argument_list|(
name|buf
argument_list|,
name|fixP
operator|->
name|fx_pcrel
condition|?
name|val
operator|+
name|fixP
operator|->
name|fx_pcrel_adjust
else|:
name|val
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Pointer in a data object */
name|md_number_to_chars
argument_list|(
name|buf
argument_list|,
name|val
argument_list|,
name|fixP
operator|->
name|fx_size
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert a relaxed displacement to ditto in final output */
end_comment

begin_function
name|void
name|md_convert_frag
parameter_list|(
name|headers
parameter_list|,
name|fragP
parameter_list|)
name|object_headers
modifier|*
name|headers
decl_stmt|;
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
block|{
name|long
name|disp
decl_stmt|;
name|long
name|ext
init|=
literal|0
decl_stmt|;
comment|/* Address in gas core of the place to store the displacement.  */
specifier|register
name|char
modifier|*
name|buffer_address
init|=
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_literal
decl_stmt|;
comment|/* Address in object code of the displacement.  */
specifier|register
name|int
name|object_address
init|=
name|fragP
operator|->
name|fr_fix
operator|+
name|fragP
operator|->
name|fr_address
decl_stmt|;
name|know
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
expr_stmt|;
comment|/* The displacement of the address, from current location.  */
name|disp
operator|=
operator|(
name|S_GET_VALUE
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|+
name|fragP
operator|->
name|fr_offset
operator|)
operator|-
name|object_address
expr_stmt|;
name|disp
operator|+=
name|fragP
operator|->
name|fr_pcrel_adjust
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|IND
argument_list|(
name|BRANCH
argument_list|,
name|BYTE
argument_list|)
case|:
name|ext
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IND
argument_list|(
name|BRANCH
argument_list|,
name|WORD
argument_list|)
case|:
name|ext
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|IND
argument_list|(
name|BRANCH
argument_list|,
name|DOUBLE
argument_list|)
case|:
name|ext
operator|=
literal|4
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ext
condition|)
block|{
name|md_number_to_disp
argument_list|(
name|buffer_address
argument_list|,
operator|(
name|long
operator|)
name|disp
argument_list|,
operator|(
name|int
operator|)
name|ext
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
name|ext
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* md_convert_frag() */
end_comment

begin_comment
comment|/* This function returns the estimated size a variable object will occupy,    one can say that we tries to guess the size of the objects before we    actually know it */
end_comment

begin_function
name|int
name|md_estimate_size_before_relax
parameter_list|(
name|fragP
parameter_list|,
name|segment
parameter_list|)
specifier|register
name|fragS
modifier|*
name|fragP
decl_stmt|;
name|segT
name|segment
decl_stmt|;
block|{
name|int
name|old_fix
decl_stmt|;
name|old_fix
operator|=
name|fragP
operator|->
name|fr_fix
expr_stmt|;
switch|switch
condition|(
name|fragP
operator|->
name|fr_subtype
condition|)
block|{
case|case
name|IND
argument_list|(
name|BRANCH
argument_list|,
name|UNDEF
argument_list|)
case|:
if|if
condition|(
name|S_GET_SEGMENT
argument_list|(
name|fragP
operator|->
name|fr_symbol
argument_list|)
operator|==
name|segment
condition|)
block|{
comment|/* the symbol has been assigned a value */
name|fragP
operator|->
name|fr_subtype
operator|=
name|IND
argument_list|(
name|BRANCH
argument_list|,
name|BYTE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we don't relax symbols defined in an other segment 		       the thing to do is to assume the object will occupy 4 bytes */
name|fix_new_ns32k
argument_list|(
name|fragP
argument_list|,
call|(
name|int
call|)
argument_list|(
name|fragP
operator|->
name|fr_fix
argument_list|)
argument_list|,
literal|4
argument_list|,
name|fragP
operator|->
name|fr_symbol
argument_list|,
operator|(
name|symbolS
operator|*
operator|)
literal|0
argument_list|,
name|fragP
operator|->
name|fr_offset
argument_list|,
literal|1
argument_list|,
name|fragP
operator|->
name|fr_pcrel_adjust
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|fragP
operator|->
name|fr_bsr
argument_list|,
comment|/*sequent hack */
name|NO_RELOC
argument_list|)
expr_stmt|;
name|fragP
operator|->
name|fr_fix
operator|+=
literal|4
expr_stmt|;
comment|/* fragP->fr_opcode[1]=0xff; */
name|frag_wane
argument_list|(
name|fragP
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IND
argument_list|(
name|BRANCH
argument_list|,
name|BYTE
argument_list|)
case|:
name|fragP
operator|->
name|fr_var
operator|+=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|fragP
operator|->
name|fr_var
operator|+
name|fragP
operator|->
name|fr_fix
operator|-
name|old_fix
return|;
block|}
end_function

begin_decl_stmt
name|int
name|md_short_jump_size
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|md_long_jump_size
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|md_reloc_size
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of relocation record */
end_comment

begin_function
name|void
name|md_create_short_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|long
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|long
name|offset
decl_stmt|;
name|offset
operator|=
name|to_addr
operator|-
name|from_addr
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|long
operator|)
literal|0xEA
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|md_number_to_disp
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
operator|(
name|long
operator|)
name|offset
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|md_create_long_jump
parameter_list|(
name|ptr
parameter_list|,
name|from_addr
parameter_list|,
name|to_addr
parameter_list|,
name|frag
parameter_list|,
name|to_symbol
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|long
name|from_addr
decl_stmt|,
name|to_addr
decl_stmt|;
name|fragS
modifier|*
name|frag
decl_stmt|;
name|symbolS
modifier|*
name|to_symbol
decl_stmt|;
block|{
name|long
name|offset
decl_stmt|;
name|offset
operator|=
name|to_addr
operator|-
name|from_addr
expr_stmt|;
name|md_number_to_chars
argument_list|(
name|ptr
argument_list|,
operator|(
name|long
operator|)
literal|0xEA
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|md_number_to_disp
argument_list|(
name|ptr
operator|+
literal|2
argument_list|,
operator|(
name|long
operator|)
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* JF this is a new function to parse machine-dep options */
end_comment

begin_function
name|int
name|md_parse_option
parameter_list|(
name|argP
parameter_list|,
name|cntP
parameter_list|,
name|vecP
parameter_list|)
name|char
modifier|*
modifier|*
name|argP
decl_stmt|;
name|int
modifier|*
name|cntP
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|vecP
decl_stmt|;
block|{
switch|switch
condition|(
operator|*
operator|*
name|argP
condition|)
block|{
case|case
literal|'m'
case|:
operator|(
operator|*
name|argP
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argP
argument_list|,
literal|"32032"
argument_list|)
condition|)
block|{
name|cpureg
operator|=
name|cpureg_032
expr_stmt|;
name|mmureg
operator|=
name|mmureg_032
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|argP
argument_list|,
literal|"32532"
argument_list|)
condition|)
block|{
name|cpureg
operator|=
name|cpureg_532
expr_stmt|;
name|mmureg
operator|=
name|mmureg_532
expr_stmt|;
block|}
else|else
name|as_warn
argument_list|(
literal|"Unknown -m option ignored"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|argP
condition|)
operator|(
operator|*
name|argP
operator|)
operator|++
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|PIC
case|case
literal|'K'
case|:
name|got_offset_size
operator|=
literal|4
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
literal|'k'
case|:
name|got_symbol
operator|=
name|symbol_find_or_make
argument_list|(
literal|"__GLOBAL_OFFSET_TABLE_"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *			bit_fix_new()  *  * Create a bit_fixS in obstack 'notes'.  * This struct is used to profile the normal fix. If the bit_fixP is a  * valid pointer (not NULL) the bit_fix data will be used to format the fix.  */
end_comment

begin_function
name|bit_fixS
modifier|*
name|bit_fix_new
parameter_list|(
name|size
parameter_list|,
name|offset
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|,
name|add
parameter_list|,
name|base_type
parameter_list|,
name|base_adj
parameter_list|)
name|char
name|size
decl_stmt|;
comment|/* Length of bitfield		*/
name|char
name|offset
decl_stmt|;
comment|/* Bit offset to bitfield	*/
name|long
name|base_type
decl_stmt|;
comment|/* 0 or 1, if 1 it's exploded to opcode ptr */
name|long
name|base_adj
decl_stmt|;
name|long
name|min
decl_stmt|;
comment|/* Signextended min for bitfield */
name|long
name|max
decl_stmt|;
comment|/* Signextended max for bitfield */
name|long
name|add
decl_stmt|;
comment|/* Add mask, used for huffman prefix */
block|{
specifier|register
name|bit_fixS
modifier|*
name|bit_fixP
decl_stmt|;
name|bit_fixP
operator|=
operator|(
name|bit_fixS
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|notes
argument_list|,
sizeof|sizeof
argument_list|(
name|bit_fixS
argument_list|)
argument_list|)
expr_stmt|;
name|bit_fixP
operator|->
name|fx_bit_size
operator|=
name|size
expr_stmt|;
name|bit_fixP
operator|->
name|fx_bit_offset
operator|=
name|offset
expr_stmt|;
name|bit_fixP
operator|->
name|fx_bit_base
operator|=
name|base_type
expr_stmt|;
name|bit_fixP
operator|->
name|fx_bit_base_adj
operator|=
name|base_adj
expr_stmt|;
name|bit_fixP
operator|->
name|fx_bit_max
operator|=
name|max
expr_stmt|;
name|bit_fixP
operator|->
name|fx_bit_min
operator|=
name|min
expr_stmt|;
name|bit_fixP
operator|->
name|fx_bit_add
operator|=
name|add
expr_stmt|;
return|return
operator|(
name|bit_fixP
operator|)
return|;
block|}
end_function

begin_function
name|void
name|fix_new_ns32k
parameter_list|(
name|frag
parameter_list|,
name|where
parameter_list|,
name|size
parameter_list|,
name|add_symbol
parameter_list|,
name|sub_symbol
parameter_list|,
name|offset
parameter_list|,
name|pcrel
parameter_list|,
name|pcrel_adjust
parameter_list|,
name|im_disp
parameter_list|,
name|bit_fixP
parameter_list|,
name|bsr
parameter_list|,
name|r_type
parameter_list|)
name|fragS
modifier|*
name|frag
decl_stmt|;
comment|/* Which frag? */
name|int
name|where
decl_stmt|;
comment|/* Where in that frag? */
name|int
name|size
decl_stmt|;
comment|/* 1, 2  or 4 usually. */
name|symbolS
modifier|*
name|add_symbol
decl_stmt|;
comment|/* X_add_symbol. */
name|symbolS
modifier|*
name|sub_symbol
decl_stmt|;
comment|/* X_subtract_symbol. */
name|long
name|offset
decl_stmt|;
comment|/* X_add_number. */
name|int
name|pcrel
decl_stmt|;
comment|/* TRUE if PC-relative relocation. */
name|char
name|pcrel_adjust
decl_stmt|;
comment|/* not zero if adjustment of pcrel offset is needed */
name|char
name|im_disp
decl_stmt|;
comment|/* true if the value to write is a displacement */
name|bit_fixS
modifier|*
name|bit_fixP
decl_stmt|;
comment|/* pointer at struct of bit_fix's, ignored if NULL */
name|char
name|bsr
decl_stmt|;
comment|/* sequent-linker-hack: 1 when relocobject is a bsr */
name|int
name|r_type
decl_stmt|;
comment|/* Relocation type */
block|{
ifdef|#
directive|ifdef
name|PIC
name|fixS
modifier|*
name|fixP
init|=
name|fix_new
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|add_symbol
argument_list|,
name|sub_symbol
argument_list|,
name|offset
argument_list|,
name|pcrel
argument_list|,
name|r_type
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
else|#
directive|else
name|fixS
modifier|*
name|fixP
init|=
name|fix_new
argument_list|(
name|frag
argument_list|,
name|where
argument_list|,
name|size
argument_list|,
name|add_symbol
argument_list|,
name|sub_symbol
argument_list|,
name|offset
argument_list|,
name|pcrel
argument_list|,
name|r_type
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* PIC */
name|fixP
operator|->
name|fx_pcrel_adjust
operator|=
name|pcrel_adjust
expr_stmt|;
name|fixP
operator|->
name|fx_im_disp
operator|=
name|im_disp
expr_stmt|;
name|fixP
operator|->
name|fx_bit_fixP
operator|=
name|bit_fixP
expr_stmt|;
name|fixP
operator|->
name|fx_bsr
operator|=
name|bsr
expr_stmt|;
ifdef|#
directive|ifdef
name|PIC
if|if
condition|(
name|r_type
operator|==
name|RELOC_GLOB_DAT
condition|)
name|add_symbol
operator|->
name|sy_forceout
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* PIC */
block|}
end_function

begin_comment
comment|/* fix_new_ns32k() */
end_comment

begin_comment
comment|/* We have no need to default values of symbols.  */
end_comment

begin_function
name|symbolS
modifier|*
name|md_undefined_symbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Parse an operand that is machine-specific.    We just return without modifying the expression if we have nothing    to do.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|md_operand
parameter_list|(
name|expressionP
parameter_list|)
name|expressionS
modifier|*
name|expressionP
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* Round up a section size to the appropriate boundary.  */
end_comment

begin_function
name|long
name|md_section_align
parameter_list|(
name|segment
parameter_list|,
name|size
parameter_list|)
name|segT
name|segment
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
return|return
name|size
return|;
comment|/* Byte alignment is fine */
block|}
end_function

begin_comment
comment|/* Exactly what point is a PC-relative offset relative TO?    On the National warts, they're relative to the address of the offset,    with some funny adjustments in some circumstances during blue moons.    (??? Is this right?  FIXME-SOON) */
end_comment

begin_function
name|long
name|md_pcrel_from
parameter_list|(
name|fixP
parameter_list|)
name|fixS
modifier|*
name|fixP
decl_stmt|;
block|{
name|long
name|res
decl_stmt|;
name|res
operator|=
name|fixP
operator|->
name|fx_where
operator|+
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_address
expr_stmt|;
ifdef|#
directive|ifdef
name|TE_SEQUENT
if|if
condition|(
name|fixP
operator|->
name|fx_frag
operator|->
name|fr_bsr
condition|)
name|res
operator|+=
literal|0x12
expr_stmt|;
comment|/* FOO Kludge alert! */
endif|#
directive|endif
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Local Variables:  * comment-column: 0  * End:  */
end_comment

begin_comment
comment|/* end of tc-ns32k.c */
end_comment

end_unit

