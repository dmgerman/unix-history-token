begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* List a tar archive.    Copyright (C) 1988, 1992, 1993 Free Software Foundation  This file is part of GNU Tar.  GNU Tar is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Tar is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Tar; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*  * List a tar archive.  *  * Also includes support routines for reading a tar archive.  *  * this version written 26 Aug 1985 by John Gilmore (ihnp4!hoptoad!gnu).  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|STDC_HEADERS
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|V7
end_ifndef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|isodigit
parameter_list|(
name|c
parameter_list|)
value|( ((c)>= '0')&& ((c)<= '7') )
end_define

begin_include
include|#
directive|include
file|"tar.h"
end_include

begin_include
include|#
directive|include
file|"port.h"
end_include

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|msg_file
decl_stmt|;
end_decl_stmt

begin_function_decl
name|long
name|from_oct
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Decode octal number */
end_comment

begin_function_decl
name|void
name|demode
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Print file mode */
end_comment

begin_function_decl
name|void
name|restore_saved_dir_info
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PTR
name|ck_malloc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|union
name|record
modifier|*
name|head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Points to current archive header */
end_comment

begin_decl_stmt
name|struct
name|stat
name|hstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stat struct corresponding */
end_comment

begin_decl_stmt
name|int
name|head_standard
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tape header is in ANSI format */
end_comment

begin_function_decl
name|int
name|check_exclude
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|close_archive
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|decode_header
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|findgid
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|finduid
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|name_gather
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|name_match
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|names_notfound
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|open_archive
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_header
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|read_header
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|saverec
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|skip_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|skip_extended_headers
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|quote_copy_string
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Main loop for reading an archive.  */
end_comment

begin_function_decl
name|void
name|read_and
function_decl|(
name|do_something
function_decl|)
name|void
argument_list|(
argument|*do_something
argument_list|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|int
name|status
init|=
literal|3
decl_stmt|;
comment|/* Initial status at start of archive */
name|int
name|prev_status
decl_stmt|;
specifier|extern
name|time_t
name|new_time
decl_stmt|;
name|char
name|save_linkflag
decl_stmt|;
name|name_gather
argument_list|()
expr_stmt|;
comment|/* Gather all the names */
name|open_archive
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Open for reading */
for|for
control|(
init|;
condition|;
control|)
block|{
name|prev_status
operator|=
name|status
expr_stmt|;
name|status
operator|=
name|read_header
argument_list|()
expr_stmt|;
comment|/* check if the namelist got emptied during the course of reading */
comment|/* the tape, if so stop by setting status to EOF */
if|if
condition|(
operator|(
name|namelist
operator|==
name|NULL
operator|)
operator|&&
name|nlpsfreed
condition|)
block|{
name|status
operator|=
name|EOF
expr_stmt|;
block|}
switch|switch
condition|(
name|status
condition|)
block|{
case|case
literal|1
case|:
comment|/* Valid header */
comment|/* We should decode next field (mode) first... */
comment|/* Ensure incoming names are null terminated. */
if|if
condition|(
operator|!
name|name_match
argument_list|(
name|current_file_name
argument_list|)
operator|||
operator|(
name|f_new_files
operator|&&
name|hstat
operator|.
name|st_mtime
operator|<
name|new_time
operator|)
operator|||
operator|(
name|f_exclude
operator|&&
name|check_exclude
argument_list|(
name|current_file_name
argument_list|)
operator|)
condition|)
block|{
name|int
name|isextended
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|head
operator|->
name|header
operator|.
name|linkflag
operator|==
name|LF_VOLHDR
operator|||
name|head
operator|->
name|header
operator|.
name|linkflag
operator|==
name|LF_MULTIVOL
operator|||
name|head
operator|->
name|header
operator|.
name|linkflag
operator|==
name|LF_NAMES
condition|)
block|{
call|(
modifier|*
name|do_something
call|)
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|f_show_omitted_dirs
operator|&&
name|head
operator|->
name|header
operator|.
name|linkflag
operator|==
name|LF_DIR
condition|)
name|msg
argument_list|(
literal|"Omitting %s\n"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
comment|/* Skip past it in the archive */
if|if
condition|(
name|head
operator|->
name|header
operator|.
name|isextended
condition|)
name|isextended
operator|=
literal|1
expr_stmt|;
name|save_linkflag
operator|=
name|head
operator|->
name|header
operator|.
name|linkflag
expr_stmt|;
name|userec
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|isextended
condition|)
block|{
comment|/*					register union record *exhdr;  					for (;;) { 					    exhdr = findrec(); 					    if (!exhdr->ext_hdr.isextended) { 					    	userec(exhdr); 					    	break; 					    } 					} 					userec(exhdr);*/
name|skip_extended_headers
argument_list|()
expr_stmt|;
block|}
comment|/* Skip to the next header on the archive */
if|if
condition|(
name|save_linkflag
operator|!=
name|LF_DIR
condition|)
name|skip_file
argument_list|(
operator|(
name|long
operator|)
name|hstat
operator|.
name|st_size
argument_list|)
expr_stmt|;
continue|continue;
block|}
call|(
modifier|*
name|do_something
call|)
argument_list|()
expr_stmt|;
continue|continue;
comment|/* 			 * If the previous header was good, tell them 			 * that we are skipping bad ones. 			 */
case|case
literal|0
case|:
comment|/* Invalid header */
name|userec
argument_list|(
name|head
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|prev_status
condition|)
block|{
case|case
literal|3
case|:
comment|/* Error on first record */
name|msg
argument_list|(
literal|"Hmm, this doesn't look like a tar archive."
argument_list|)
expr_stmt|;
comment|/* FALL THRU */
case|case
literal|2
case|:
comment|/* Error after record of zeroes */
case|case
literal|1
case|:
comment|/* Error after header rec */
name|msg
argument_list|(
literal|"Skipping to next file header..."
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
comment|/* Error after error */
break|break;
block|}
continue|continue;
case|case
literal|2
case|:
comment|/* Record of zeroes */
name|userec
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|status
operator|=
name|prev_status
expr_stmt|;
comment|/* If error after 0's */
if|if
condition|(
name|f_ignorez
condition|)
continue|continue;
comment|/* FALL THRU */
case|case
name|EOF
case|:
comment|/* End of archive */
break|break;
block|}
break|break;
block|}
empty_stmt|;
name|restore_saved_dir_info
argument_list|()
expr_stmt|;
name|close_archive
argument_list|()
expr_stmt|;
name|names_notfound
argument_list|()
expr_stmt|;
comment|/* Print names not found */
block|}
end_block

begin_comment
comment|/*  * Print a header record, based on tar options.  */
end_comment

begin_function
name|void
name|list_archive
parameter_list|()
block|{
specifier|extern
name|char
modifier|*
name|save_name
decl_stmt|;
name|int
name|isextended
init|=
literal|0
decl_stmt|;
comment|/* Flag to remember if head is extended */
comment|/* Save the record */
name|saverec
argument_list|(
operator|&
name|head
argument_list|)
expr_stmt|;
comment|/* Print the header record */
if|if
condition|(
name|f_verbose
condition|)
block|{
if|if
condition|(
name|f_verbose
operator|>
literal|1
condition|)
name|decode_header
argument_list|(
name|head
argument_list|,
operator|&
name|hstat
argument_list|,
operator|&
name|head_standard
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_header
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|f_gnudump
operator|&&
name|head
operator|->
name|header
operator|.
name|linkflag
operator|==
name|LF_DUMPDIR
condition|)
block|{
name|size_t
name|size
decl_stmt|,
name|written
decl_stmt|,
name|check
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
specifier|extern
name|long
name|save_totsize
decl_stmt|;
specifier|extern
name|long
name|save_sizeleft
decl_stmt|;
name|userec
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_multivol
condition|)
block|{
name|save_name
operator|=
name|current_file_name
expr_stmt|;
name|save_totsize
operator|=
name|hstat
operator|.
name|st_size
expr_stmt|;
block|}
for|for
control|(
name|size
operator|=
name|hstat
operator|.
name|st_size
init|;
name|size
operator|>
literal|0
condition|;
name|size
operator|-=
name|written
control|)
block|{
if|if
condition|(
name|f_multivol
condition|)
name|save_sizeleft
operator|=
name|size
expr_stmt|;
name|data
operator|=
name|findrec
argument_list|()
operator|->
name|charptr
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|msg
argument_list|(
literal|"EOF in archive file?"
argument_list|)
expr_stmt|;
break|break;
block|}
name|written
operator|=
name|endofrecs
argument_list|()
operator|->
name|charptr
operator|-
name|data
expr_stmt|;
if|if
condition|(
name|written
operator|>
name|size
condition|)
name|written
operator|=
name|size
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|check
operator|=
name|fwrite
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|written
argument_list|,
name|msg_file
argument_list|)
expr_stmt|;
name|userec
argument_list|(
operator|(
expr|union
name|record
operator|*
operator|)
operator|(
name|data
operator|+
name|written
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
operator|!=
name|written
condition|)
block|{
name|msg_perror
argument_list|(
literal|"only wrote %ld of %ld bytes to file %s"
argument_list|,
name|check
argument_list|,
name|written
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
name|skip_file
argument_list|(
call|(
name|long
call|)
argument_list|(
name|size
argument_list|)
operator|-
name|written
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|f_multivol
condition|)
name|save_name
operator|=
literal|0
expr_stmt|;
name|saverec
argument_list|(
operator|(
expr|union
name|record
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Unsave it */
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|msg_file
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|msg_file
argument_list|)
expr_stmt|;
return|return;
block|}
name|saverec
argument_list|(
operator|(
expr|union
name|record
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Unsave it */
comment|/* Check to see if we have an extended header to skip over also */
if|if
condition|(
name|head
operator|->
name|header
operator|.
name|isextended
condition|)
name|isextended
operator|=
literal|1
expr_stmt|;
comment|/* Skip past the header in the archive */
name|userec
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/*  	 * If we needed to skip any extended headers, do so now, by  	 * reading extended headers and skipping past them in the 	 * archive. 	 */
if|if
condition|(
name|isextended
condition|)
block|{
comment|/*		register union record *exhdr;  		for (;;) { 			exhdr = findrec();  			if (!exhdr->ext_hdr.isextended) { 				userec(exhdr); 				break; 			} 			userec(exhdr); 		}*/
name|skip_extended_headers
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|f_multivol
condition|)
name|save_name
operator|=
name|current_file_name
expr_stmt|;
comment|/* Skip to the next header on the archive */
name|skip_file
argument_list|(
operator|(
name|long
operator|)
name|hstat
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_multivol
condition|)
name|save_name
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read a record that's supposed to be a header record.  * Return its address in "head", and if it is good, the file's  * size in hstat.st_size.  *  * Return 1 for success, 0 if the checksum is bad, EOF on eof,  * 2 for a record full of zeros (EOF marker).  *  * You must always userec(head) to skip past the header which this  * routine reads.  */
end_comment

begin_function
name|int
name|read_header
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|long
name|sum
decl_stmt|,
name|signed_sum
decl_stmt|,
name|recsum
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|union
name|record
modifier|*
name|header
decl_stmt|;
name|long
name|from_oct
parameter_list|()
function_decl|;
name|char
modifier|*
modifier|*
name|longp
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|data
decl_stmt|;
name|int
name|size
decl_stmt|,
name|written
decl_stmt|;
specifier|static
name|char
modifier|*
name|next_long_name
decl_stmt|,
modifier|*
name|next_long_link
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|recurse
label|:
name|header
operator|=
name|findrec
argument_list|()
expr_stmt|;
name|head
operator|=
name|header
expr_stmt|;
comment|/* This is our current header */
if|if
condition|(
name|NULL
operator|==
name|header
condition|)
return|return
name|EOF
return|;
name|recsum
operator|=
name|from_oct
argument_list|(
literal|8
argument_list|,
name|header
operator|->
name|header
operator|.
name|chksum
argument_list|)
expr_stmt|;
name|signed_sum
operator|=
name|sum
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|header
operator|->
name|charptr
expr_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
comment|/* 		 * We can't use unsigned char here because of old compilers, 		 * e.g. V7. 		 */
name|signed_sum
operator|+=
operator|*
name|p
expr_stmt|;
name|sum
operator|+=
literal|0xFF
operator|&
operator|*
name|p
operator|++
expr_stmt|;
block|}
comment|/* Adjust checksum to count the "chksum" field as blanks. */
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|header
operator|->
name|header
operator|.
name|chksum
argument_list|)
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|sum
operator|-=
literal|0xFF
operator|&
name|header
operator|->
name|header
operator|.
name|chksum
index|[
name|i
index|]
expr_stmt|;
name|signed_sum
operator|-=
operator|(
name|char
operator|)
name|header
operator|->
name|header
operator|.
name|chksum
index|[
name|i
index|]
expr_stmt|;
block|}
name|sum
operator|+=
literal|' '
operator|*
sizeof|sizeof
name|header
operator|->
name|header
operator|.
name|chksum
expr_stmt|;
name|signed_sum
operator|+=
literal|' '
operator|*
sizeof|sizeof
name|header
operator|->
name|header
operator|.
name|chksum
expr_stmt|;
if|if
condition|(
name|sum
operator|==
literal|8
operator|*
literal|' '
condition|)
block|{
comment|/* 		 * This is a zeroed record...whole record is 0's except 		 * for the 8 blanks we faked for the checksum field. 		 */
return|return
literal|2
return|;
block|}
if|if
condition|(
name|sum
operator|!=
name|recsum
operator|&&
name|signed_sum
operator|!=
name|recsum
condition|)
return|return
literal|0
return|;
comment|/* 	 * Good record.  Decode file size and return. 	 */
if|if
condition|(
name|header
operator|->
name|header
operator|.
name|linkflag
operator|==
name|LF_LINK
condition|)
name|hstat
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
comment|/* Links 0 size on tape */
else|else
name|hstat
operator|.
name|st_size
operator|=
name|from_oct
argument_list|(
literal|1
operator|+
literal|12
argument_list|,
name|header
operator|->
name|header
operator|.
name|size
argument_list|)
expr_stmt|;
name|header
operator|->
name|header
operator|.
name|arch_name
index|[
name|NAMSIZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|header
operator|.
name|linkflag
operator|==
name|LF_LONGNAME
operator|||
name|header
operator|->
name|header
operator|.
name|linkflag
operator|==
name|LF_LONGLINK
condition|)
block|{
name|longp
operator|=
operator|(
operator|(
name|header
operator|->
name|header
operator|.
name|linkflag
operator|==
name|LF_LONGNAME
operator|)
condition|?
operator|&
name|next_long_name
else|:
operator|&
name|next_long_link
operator|)
expr_stmt|;
name|userec
argument_list|(
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|longp
condition|)
name|free
argument_list|(
operator|*
name|longp
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|*
name|longp
operator|=
operator|(
name|char
operator|*
operator|)
name|ck_malloc
argument_list|(
name|hstat
operator|.
name|st_size
argument_list|)
expr_stmt|;
for|for
control|(
name|size
operator|=
name|hstat
operator|.
name|st_size
init|;
name|size
operator|>
literal|0
condition|;
name|size
operator|-=
name|written
control|)
block|{
name|data
operator|=
name|findrec
argument_list|()
operator|->
name|charptr
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|msg
argument_list|(
literal|"Unexpected EOF on archive file"
argument_list|)
expr_stmt|;
break|break;
block|}
name|written
operator|=
name|endofrecs
argument_list|()
operator|->
name|charptr
operator|-
name|data
expr_stmt|;
if|if
condition|(
name|written
operator|>
name|size
condition|)
name|written
operator|=
name|size
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|bp
argument_list|,
name|written
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|written
expr_stmt|;
name|userec
argument_list|(
operator|(
expr|union
name|record
operator|*
operator|)
operator|(
name|data
operator|+
name|written
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
goto|goto
name|recurse
goto|;
block|}
else|else
block|{
name|name
operator|=
operator|(
name|next_long_name
condition|?
name|next_long_name
else|:
name|head
operator|->
name|header
operator|.
name|arch_name
operator|)
expr_stmt|;
if|if
condition|(
name|current_file_name
condition|)
name|free
argument_list|(
name|current_file_name
argument_list|)
expr_stmt|;
name|current_file_name
operator|=
name|ck_malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|current_file_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
operator|(
name|next_long_link
condition|?
name|next_long_link
else|:
name|head
operator|->
name|header
operator|.
name|arch_linkname
operator|)
expr_stmt|;
if|if
condition|(
name|current_link_name
condition|)
name|free
argument_list|(
name|current_link_name
argument_list|)
expr_stmt|;
name|current_link_name
operator|=
name|ck_malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|current_link_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|next_long_link
operator|=
name|next_long_name
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Decode things from a file header record into a "struct stat".  * Also set "*stdp" to !=0 or ==0 depending whether header record is "Unix  * Standard" tar format or regular old tar format.  *  * read_header() has already decoded the checksum and length, so we don't.  *  * If wantug != 0, we want the uid/group info decoded from Unix Standard  * tapes (for extraction).  If == 0, we are just printing anyway, so save time.  *  * decode_header should NOT be called twice for the same record, since the  * two calls might use different "wantug" values and thus might end up with  * different uid/gid for the two calls.  If anybody wants the uid/gid they  * should decode it first, and other callers should decode it without uid/gid  * before calling a routine, e.g. print_header, that assumes decoded data.  */
end_comment

begin_function
name|void
name|decode_header
parameter_list|(
name|header
parameter_list|,
name|st
parameter_list|,
name|stdp
parameter_list|,
name|wantug
parameter_list|)
specifier|register
name|union
name|record
modifier|*
name|header
decl_stmt|;
specifier|register
name|struct
name|stat
modifier|*
name|st
decl_stmt|;
name|int
modifier|*
name|stdp
decl_stmt|;
name|int
name|wantug
decl_stmt|;
block|{
name|long
name|from_oct
parameter_list|()
function_decl|;
name|st
operator|->
name|st_mode
operator|=
name|from_oct
argument_list|(
literal|8
argument_list|,
name|header
operator|->
name|header
operator|.
name|mode
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_mode
operator|&=
literal|07777
expr_stmt|;
name|st
operator|->
name|st_mtime
operator|=
name|from_oct
argument_list|(
literal|1
operator|+
literal|12
argument_list|,
name|header
operator|->
name|header
operator|.
name|mtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_gnudump
condition|)
block|{
name|st
operator|->
name|st_atime
operator|=
name|from_oct
argument_list|(
literal|1
operator|+
literal|12
argument_list|,
name|header
operator|->
name|header
operator|.
name|atime
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_ctime
operator|=
name|from_oct
argument_list|(
literal|1
operator|+
literal|12
argument_list|,
name|header
operator|->
name|header
operator|.
name|ctime
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|header
operator|->
name|header
operator|.
name|magic
argument_list|,
name|TMAGIC
argument_list|)
condition|)
block|{
comment|/* Unix Standard tar archive */
operator|*
name|stdp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|wantug
condition|)
block|{
ifdef|#
directive|ifdef
name|NONAMES
name|st
operator|->
name|st_uid
operator|=
name|from_oct
argument_list|(
literal|8
argument_list|,
name|header
operator|->
name|header
operator|.
name|uid
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_gid
operator|=
name|from_oct
argument_list|(
literal|8
argument_list|,
name|header
operator|->
name|header
operator|.
name|gid
argument_list|)
expr_stmt|;
else|#
directive|else
name|st
operator|->
name|st_uid
operator|=
operator|(
operator|*
name|header
operator|->
name|header
operator|.
name|uname
condition|?
name|finduid
argument_list|(
name|header
operator|->
name|header
operator|.
name|uname
argument_list|)
else|:
name|from_oct
argument_list|(
literal|8
argument_list|,
name|header
operator|->
name|header
operator|.
name|uid
argument_list|)
operator|)
expr_stmt|;
name|st
operator|->
name|st_gid
operator|=
operator|(
operator|*
name|header
operator|->
name|header
operator|.
name|gname
condition|?
name|findgid
argument_list|(
name|header
operator|->
name|header
operator|.
name|gname
argument_list|)
else|:
name|from_oct
argument_list|(
literal|8
argument_list|,
name|header
operator|->
name|header
operator|.
name|gid
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|S_IFBLK
argument_list|)
operator|||
name|defined
argument_list|(
name|S_IFCHR
argument_list|)
switch|switch
condition|(
name|header
operator|->
name|header
operator|.
name|linkflag
condition|)
block|{
case|case
name|LF_BLK
case|:
case|case
name|LF_CHR
case|:
name|st
operator|->
name|st_rdev
operator|=
name|makedev
argument_list|(
name|from_oct
argument_list|(
literal|8
argument_list|,
name|header
operator|->
name|header
operator|.
name|devmajor
argument_list|)
argument_list|,
name|from_oct
argument_list|(
literal|8
argument_list|,
name|header
operator|->
name|header
operator|.
name|devminor
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Old fashioned tar archive */
operator|*
name|stdp
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|st_uid
operator|=
name|from_oct
argument_list|(
literal|8
argument_list|,
name|header
operator|->
name|header
operator|.
name|uid
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_gid
operator|=
name|from_oct
argument_list|(
literal|8
argument_list|,
name|header
operator|->
name|header
operator|.
name|gid
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_rdev
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Quick and dirty octal conversion.  *  * Result is -1 if the field is invalid (all blank, or nonoctal).  */
end_comment

begin_function
name|long
name|from_oct
parameter_list|(
name|digs
parameter_list|,
name|where
parameter_list|)
specifier|register
name|int
name|digs
decl_stmt|;
specifier|register
name|char
modifier|*
name|where
decl_stmt|;
block|{
specifier|register
name|long
name|value
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|where
argument_list|)
condition|)
block|{
comment|/* Skip spaces */
name|where
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|digs
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* All blank field */
block|}
name|value
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|digs
operator|>
literal|0
operator|&&
name|isodigit
argument_list|(
operator|*
name|where
argument_list|)
condition|)
block|{
comment|/* Scan til nonoctal */
name|value
operator|=
operator|(
name|value
operator|<<
literal|3
operator|)
operator||
operator|(
operator|*
name|where
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|--
name|digs
expr_stmt|;
block|}
if|if
condition|(
name|digs
operator|>
literal|0
operator|&&
operator|*
name|where
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|where
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Ended on non-space/nul */
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/*  * Actually print it.  *  * Plain and fancy file header block logging.  * Non-verbose just prints the name, e.g. for "tar t" or "tar x".  * This should just contain file names, so it can be fed back into tar  * with xargs or the "-T" option.  The verbose option can give a bunch  * of info, one line per file.  I doubt anybody tries to parse its  * format, or if they do, they shouldn't.  Unix tar is pretty random here  * anyway.  *  * Note that print_header uses the globals<head>,<hstat>, and  *<head_standard>, which must be set up in advance.  This is not very clean  * and should be cleaned up.  FIXME.  */
end_comment

begin_define
define|#
directive|define
name|UGSWIDTH
value|18
end_define

begin_comment
comment|/* min width of User, group, size */
end_comment

begin_comment
comment|/* UGSWIDTH of 18 means that with user and group names<= 8 chars the columns    never shift during the listing.  */
end_comment

begin_define
define|#
directive|define
name|DATEWIDTH
value|19
end_define

begin_comment
comment|/* Last mod date */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ugswidth
init|=
name|UGSWIDTH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Max width encountered so far */
end_comment

begin_function
name|void
name|print_header
parameter_list|()
block|{
name|char
name|modes
index|[
literal|11
index|]
decl_stmt|;
name|char
name|timestamp
index|[
literal|80
index|]
decl_stmt|;
name|char
name|uform
index|[
literal|11
index|]
decl_stmt|,
name|gform
index|[
literal|11
index|]
decl_stmt|;
comment|/* These hold formatted ints */
name|char
modifier|*
name|user
decl_stmt|,
modifier|*
name|group
decl_stmt|;
name|char
name|size
index|[
literal|24
index|]
decl_stmt|;
comment|/* Holds a formatted long or maj, min */
name|time_t
name|longie
decl_stmt|;
name|int
name|pad
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|extern
name|long
name|baserec
decl_stmt|;
if|if
condition|(
name|f_sayblock
condition|)
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"rec %10ld: "
argument_list|,
name|baserec
operator|+
operator|(
name|ar_record
operator|-
name|ar_block
operator|)
argument_list|)
expr_stmt|;
comment|/* annofile(msg_file, (char *)NULL); */
if|if
condition|(
name|f_verbose
operator|<=
literal|1
condition|)
block|{
comment|/* Just the fax, mam. */
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|quote_copy_string
argument_list|(
name|current_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|name
operator|=
name|current_file_name
expr_stmt|;
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|current_file_name
condition|)
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* File type and modes */
name|modes
index|[
literal|0
index|]
operator|=
literal|'?'
expr_stmt|;
switch|switch
condition|(
name|head
operator|->
name|header
operator|.
name|linkflag
condition|)
block|{
case|case
name|LF_VOLHDR
case|:
name|modes
index|[
literal|0
index|]
operator|=
literal|'V'
expr_stmt|;
break|break;
case|case
name|LF_MULTIVOL
case|:
name|modes
index|[
literal|0
index|]
operator|=
literal|'M'
expr_stmt|;
break|break;
case|case
name|LF_NAMES
case|:
name|modes
index|[
literal|0
index|]
operator|=
literal|'N'
expr_stmt|;
break|break;
case|case
name|LF_LONGNAME
case|:
case|case
name|LF_LONGLINK
case|:
name|msg
argument_list|(
literal|"Visible longname error\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LF_SPARSE
case|:
case|case
name|LF_NORMAL
case|:
case|case
name|LF_OLDNORMAL
case|:
case|case
name|LF_LINK
case|:
name|modes
index|[
literal|0
index|]
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
literal|'/'
operator|==
name|current_file_name
index|[
name|strlen
argument_list|(
name|current_file_name
argument_list|)
operator|-
literal|1
index|]
condition|)
name|modes
index|[
literal|0
index|]
operator|=
literal|'d'
expr_stmt|;
break|break;
case|case
name|LF_DUMPDIR
case|:
name|modes
index|[
literal|0
index|]
operator|=
literal|'d'
expr_stmt|;
break|break;
case|case
name|LF_DIR
case|:
name|modes
index|[
literal|0
index|]
operator|=
literal|'d'
expr_stmt|;
break|break;
case|case
name|LF_SYMLINK
case|:
name|modes
index|[
literal|0
index|]
operator|=
literal|'l'
expr_stmt|;
break|break;
case|case
name|LF_BLK
case|:
name|modes
index|[
literal|0
index|]
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
name|LF_CHR
case|:
name|modes
index|[
literal|0
index|]
operator|=
literal|'c'
expr_stmt|;
break|break;
case|case
name|LF_FIFO
case|:
name|modes
index|[
literal|0
index|]
operator|=
literal|'p'
expr_stmt|;
break|break;
case|case
name|LF_CONTIG
case|:
name|modes
index|[
literal|0
index|]
operator|=
literal|'C'
expr_stmt|;
break|break;
block|}
name|demode
argument_list|(
operator|(
name|unsigned
operator|)
name|hstat
operator|.
name|st_mode
argument_list|,
name|modes
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Timestamp */
name|longie
operator|=
name|hstat
operator|.
name|st_mtime
expr_stmt|;
name|strftime
argument_list|(
name|timestamp
argument_list|,
sizeof|sizeof
argument_list|(
name|timestamp
argument_list|)
argument_list|,
literal|"%c"
argument_list|,
name|localtime
argument_list|(
operator|&
name|longie
argument_list|)
argument_list|)
expr_stmt|;
name|timestamp
index|[
literal|16
index|]
operator|=
literal|'\0'
expr_stmt|;
name|timestamp
index|[
literal|24
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* User and group names */
if|if
condition|(
operator|*
name|head
operator|->
name|header
operator|.
name|uname
operator|&&
name|head_standard
condition|)
block|{
name|user
operator|=
name|head
operator|->
name|header
operator|.
name|uname
expr_stmt|;
block|}
else|else
block|{
name|user
operator|=
name|uform
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|uform
argument_list|,
literal|"%ld"
argument_list|,
name|from_oct
argument_list|(
literal|8
argument_list|,
name|head
operator|->
name|header
operator|.
name|uid
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|head
operator|->
name|header
operator|.
name|gname
operator|&&
name|head_standard
condition|)
block|{
name|group
operator|=
name|head
operator|->
name|header
operator|.
name|gname
expr_stmt|;
block|}
else|else
block|{
name|group
operator|=
name|gform
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|gform
argument_list|,
literal|"%ld"
argument_list|,
name|from_oct
argument_list|(
literal|8
argument_list|,
name|head
operator|->
name|header
operator|.
name|gid
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Format the file size or major/minor device numbers */
switch|switch
condition|(
name|head
operator|->
name|header
operator|.
name|linkflag
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|S_IFBLK
argument_list|)
operator|||
name|defined
argument_list|(
name|S_IFCHR
argument_list|)
case|case
name|LF_CHR
case|:
case|case
name|LF_BLK
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|size
argument_list|,
literal|"%d,%d"
argument_list|,
name|major
argument_list|(
name|hstat
operator|.
name|st_rdev
argument_list|)
argument_list|,
name|minor
argument_list|(
name|hstat
operator|.
name|st_rdev
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|LF_SPARSE
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|size
argument_list|,
literal|"%ld"
argument_list|,
name|from_oct
argument_list|(
literal|1
operator|+
literal|12
argument_list|,
name|head
operator|->
name|header
operator|.
name|realsize
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|size
argument_list|,
literal|"%ld"
argument_list|,
operator|(
name|long
operator|)
name|hstat
operator|.
name|st_size
argument_list|)
expr_stmt|;
block|}
comment|/* Figure out padding and print the whole line. */
name|pad
operator|=
name|strlen
argument_list|(
name|user
argument_list|)
operator|+
name|strlen
argument_list|(
name|group
argument_list|)
operator|+
name|strlen
argument_list|(
name|size
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|pad
operator|>
name|ugswidth
condition|)
name|ugswidth
operator|=
name|pad
expr_stmt|;
name|name
operator|=
name|quote_copy_string
argument_list|(
name|current_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
name|name
operator|=
name|current_file_name
expr_stmt|;
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"%s %s/%s %*s%s %s %s %s"
argument_list|,
name|modes
argument_list|,
name|user
argument_list|,
name|group
argument_list|,
name|ugswidth
operator|-
name|pad
argument_list|,
literal|""
argument_list|,
name|size
argument_list|,
name|timestamp
operator|+
literal|4
argument_list|,
name|timestamp
operator|+
literal|20
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|current_file_name
condition|)
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|head
operator|->
name|header
operator|.
name|linkflag
condition|)
block|{
case|case
name|LF_SYMLINK
case|:
name|name
operator|=
name|quote_copy_string
argument_list|(
name|current_link_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
name|name
operator|=
name|current_link_name
expr_stmt|;
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|" -> %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|current_link_name
condition|)
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|LF_LINK
case|:
name|name
operator|=
name|quote_copy_string
argument_list|(
name|current_link_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
name|name
operator|=
name|current_link_name
expr_stmt|;
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|" link to %s\n"
argument_list|,
name|current_link_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|current_link_name
condition|)
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|" unknown file type '%c'\n"
argument_list|,
name|head
operator|->
name|header
operator|.
name|linkflag
argument_list|)
expr_stmt|;
break|break;
case|case
name|LF_OLDNORMAL
case|:
case|case
name|LF_NORMAL
case|:
case|case
name|LF_SPARSE
case|:
case|case
name|LF_CHR
case|:
case|case
name|LF_BLK
case|:
case|case
name|LF_DIR
case|:
case|case
name|LF_FIFO
case|:
case|case
name|LF_CONTIG
case|:
case|case
name|LF_DUMPDIR
case|:
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|msg_file
argument_list|)
expr_stmt|;
break|break;
case|case
name|LF_VOLHDR
case|:
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"--Volume Header--\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LF_MULTIVOL
case|:
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"--Continued at byte %ld--\n"
argument_list|,
name|from_oct
argument_list|(
literal|1
operator|+
literal|12
argument_list|,
name|head
operator|->
name|header
operator|.
name|offset
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LF_NAMES
case|:
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"--Mangled file names--\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fflush
argument_list|(
name|msg_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print a similar line when we make a directory automatically.  */
end_comment

begin_function
name|void
name|pr_mkdir
parameter_list|(
name|pathname
parameter_list|,
name|length
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|char
name|modes
index|[
literal|11
index|]
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|extern
name|long
name|baserec
decl_stmt|;
if|if
condition|(
name|f_verbose
operator|>
literal|1
condition|)
block|{
comment|/* File type and modes */
name|modes
index|[
literal|0
index|]
operator|=
literal|'d'
expr_stmt|;
name|demode
argument_list|(
operator|(
name|unsigned
operator|)
name|mode
argument_list|,
name|modes
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_sayblock
condition|)
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"rec %10ld: "
argument_list|,
name|baserec
operator|+
operator|(
name|ar_record
operator|-
name|ar_block
operator|)
argument_list|)
expr_stmt|;
comment|/* annofile(msg_file, (char *)NULL); */
name|name
operator|=
name|quote_copy_string
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
name|name
operator|=
name|pathname
expr_stmt|;
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"%s %*s %.*s\n"
argument_list|,
name|modes
argument_list|,
name|ugswidth
operator|+
name|DATEWIDTH
argument_list|,
literal|"Creating directory:"
argument_list|,
name|length
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|pathname
condition|)
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Skip over<size> bytes of data in records in the archive.  */
end_comment

begin_function
name|void
name|skip_file
parameter_list|(
name|size
parameter_list|)
specifier|register
name|long
name|size
decl_stmt|;
block|{
name|union
name|record
modifier|*
name|x
decl_stmt|;
specifier|extern
name|long
name|save_totsize
decl_stmt|;
specifier|extern
name|long
name|save_sizeleft
decl_stmt|;
if|if
condition|(
name|f_multivol
condition|)
block|{
name|save_totsize
operator|=
name|size
expr_stmt|;
name|save_sizeleft
operator|=
name|size
expr_stmt|;
block|}
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|x
operator|=
name|findrec
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL
condition|)
block|{
comment|/* Check it... */
name|msg
argument_list|(
literal|"Unexpected EOF on archive file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_BADARCH
argument_list|)
expr_stmt|;
block|}
name|userec
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|size
operator|-=
name|RECORDSIZE
expr_stmt|;
if|if
condition|(
name|f_multivol
condition|)
name|save_sizeleft
operator|-=
name|RECORDSIZE
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|skip_extended_headers
parameter_list|()
block|{
specifier|register
name|union
name|record
modifier|*
name|exhdr
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|exhdr
operator|=
name|findrec
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|exhdr
operator|->
name|ext_hdr
operator|.
name|isextended
condition|)
block|{
name|userec
argument_list|(
name|exhdr
argument_list|)
expr_stmt|;
break|break;
block|}
name|userec
argument_list|(
name|exhdr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Decode the mode string from a stat entry into a 9-char string and a null.  */
end_comment

begin_function
name|void
name|demode
parameter_list|(
name|mode
parameter_list|,
name|string
parameter_list|)
specifier|register
name|unsigned
name|mode
decl_stmt|;
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|unsigned
name|mask
decl_stmt|;
specifier|register
name|char
modifier|*
name|rwx
init|=
literal|"rwxrwxrwx"
decl_stmt|;
for|for
control|(
name|mask
operator|=
literal|0400
init|;
name|mask
operator|!=
literal|0
condition|;
name|mask
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|mode
operator|&
name|mask
condition|)
operator|*
name|string
operator|++
operator|=
operator|*
name|rwx
operator|++
expr_stmt|;
else|else
block|{
operator|*
name|string
operator|++
operator|=
literal|'-'
expr_stmt|;
name|rwx
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mode
operator|&
name|S_ISUID
condition|)
if|if
condition|(
name|string
index|[
operator|-
literal|7
index|]
operator|==
literal|'x'
condition|)
name|string
index|[
operator|-
literal|7
index|]
operator|=
literal|'s'
expr_stmt|;
else|else
name|string
index|[
operator|-
literal|7
index|]
operator|=
literal|'S'
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_ISGID
condition|)
if|if
condition|(
name|string
index|[
operator|-
literal|4
index|]
operator|==
literal|'x'
condition|)
name|string
index|[
operator|-
literal|4
index|]
operator|=
literal|'s'
expr_stmt|;
else|else
name|string
index|[
operator|-
literal|4
index|]
operator|=
literal|'S'
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_ISVTX
condition|)
if|if
condition|(
name|string
index|[
operator|-
literal|1
index|]
operator|==
literal|'x'
condition|)
name|string
index|[
operator|-
literal|1
index|]
operator|=
literal|'t'
expr_stmt|;
else|else
name|string
index|[
operator|-
literal|1
index|]
operator|=
literal|'T'
expr_stmt|;
operator|*
name|string
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

end_unit

