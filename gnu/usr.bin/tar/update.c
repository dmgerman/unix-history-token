begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Update a tar archive.    Copyright (C) 1988, 1992 Free Software Foundation  This file is part of GNU Tar.  GNU Tar is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Tar is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Tar; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* JF implement the 'r' 'u' and 'A' options for tar. */
end_comment

begin_comment
comment|/* The 'A' option is my own invention:  It means that the file-names are    tar files, and they should simply be appended to the end of the archive.    No attempt is made to block the reads from the args; if they're on raw    tape or something like that, it'll probably lose. . . */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|STDC_HEADERS
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_MTIO_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|V7
end_ifndef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__MSDOS__
end_ifndef

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|STDIN
value|0
end_define

begin_define
define|#
directive|define
name|STDOUT
value|1
end_define

begin_include
include|#
directive|include
file|"tar.h"
end_include

begin_include
include|#
directive|include
file|"port.h"
end_include

begin_include
include|#
directive|include
file|"rmt.h"
end_include

begin_decl_stmt
name|int
name|time_to_start_writing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We've hit the end of the old stuff, 				   and its time to start writing new stuff 				   to the tape.  This involves seeking 				   back one block and re-writing the current 				   block (which has been changed). */
end_comment

begin_decl_stmt
name|char
modifier|*
name|output_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to where we started to write in 				   the first block we write out.  This is used 				   if we can't backspace the output and have 				   to null out the first part of the block */
end_comment

begin_function_decl
specifier|extern
name|void
name|skip_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|skip_extended_headers
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|union
name|record
modifier|*
name|head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|stat
name|hstat
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|append_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|close_archive
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|confirm
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|decode_header
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fl_read
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fl_write
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|flush_archive
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|move_arch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|name
modifier|*
name|name_scan
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|name_from_list
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|name_expand
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|name_gather
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|names_notfound
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|open_archive
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|read_header
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|reset_eof
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|write_block
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|write_eot
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Implement the 'r' (add files to end of archive), and 'u' (add files to    end of archive if they arent there, or are more up to date than the    version in the archive.) commands.*/
end_comment

begin_function
name|void
name|update_archive
parameter_list|()
block|{
name|int
name|found_end
init|=
literal|0
decl_stmt|;
name|int
name|status
init|=
literal|3
decl_stmt|;
name|int
name|prev_status
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|name
modifier|*
name|name
decl_stmt|;
specifier|extern
name|void
name|dump_file
parameter_list|()
function_decl|;
name|name_gather
argument_list|()
expr_stmt|;
if|if
condition|(
name|cmd_mode
operator|==
name|CMD_UPDATE
condition|)
name|name_expand
argument_list|()
expr_stmt|;
name|open_archive
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Open for updating */
do|do
block|{
name|prev_status
operator|=
name|status
expr_stmt|;
name|status
operator|=
name|read_header
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|EOF
case|:
name|found_end
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* A bad record */
name|userec
argument_list|(
name|head
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|prev_status
condition|)
block|{
case|case
literal|3
case|:
name|msg
argument_list|(
literal|"This doesn't look like a tar archive."
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|2
case|:
case|case
literal|1
case|:
name|msg
argument_list|(
literal|"Skipping to next header"
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
break|break;
block|}
break|break;
comment|/* A good record */
case|case
literal|1
case|:
comment|/* printf("File %s\n",head->header.name); */
comment|/* head->header.name[NAMSIZ-1]='\0'; */
if|if
condition|(
name|cmd_mode
operator|==
name|CMD_UPDATE
operator|&&
operator|(
name|name
operator|=
name|name_scan
argument_list|(
name|current_file_name
argument_list|)
operator|)
condition|)
block|{
comment|/* struct stat hstat; */
name|struct
name|stat
name|nstat
decl_stmt|;
name|int
name|head_standard
decl_stmt|;
name|decode_header
argument_list|(
name|head
argument_list|,
operator|&
name|hstat
argument_list|,
operator|&
name|head_standard
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|current_file_name
argument_list|,
operator|&
name|nstat
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"can't stat %s:"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hstat
operator|.
name|st_mtime
operator|>=
name|nstat
operator|.
name|st_mtime
condition|)
name|name
operator|->
name|found
operator|++
expr_stmt|;
block|}
block|}
name|userec
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|header
operator|.
name|isextended
condition|)
name|skip_extended_headers
argument_list|()
expr_stmt|;
name|skip_file
argument_list|(
operator|(
name|long
operator|)
name|hstat
operator|.
name|st_size
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ar_record
operator|=
name|head
expr_stmt|;
name|found_end
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|!
name|found_end
condition|)
do|;
name|reset_eof
argument_list|()
expr_stmt|;
name|time_to_start_writing
operator|=
literal|1
expr_stmt|;
name|output_start
operator|=
name|ar_record
operator|->
name|charptr
expr_stmt|;
while|while
condition|(
name|p
operator|=
name|name_from_list
argument_list|()
condition|)
block|{
if|if
condition|(
name|f_confirm
operator|&&
operator|!
name|confirm
argument_list|(
literal|"add"
argument_list|,
name|p
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|cmd_mode
operator|==
name|CMD_CAT
condition|)
name|append_file
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|dump_file
argument_list|(
name|p
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|write_eot
argument_list|()
expr_stmt|;
name|close_archive
argument_list|()
expr_stmt|;
name|names_notfound
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Catenate file p to the archive without creating a header for it.  It had    better be a tar file or the archive is screwed */
end_comment

begin_function
name|void
name|append_file
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|long
name|bytes_left
decl_stmt|;
name|union
name|record
modifier|*
name|start
decl_stmt|;
name|long
name|bufsiz
decl_stmt|,
name|count
decl_stmt|;
if|if
condition|(
literal|0
operator|!=
name|stat
argument_list|(
name|p
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|||
operator|(
name|fd
operator|=
name|open
argument_list|(
name|p
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"can't open file %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
return|return;
block|}
name|bytes_left
operator|=
name|statbuf
operator|.
name|st_size
expr_stmt|;
while|while
condition|(
name|bytes_left
operator|>
literal|0
condition|)
block|{
name|start
operator|=
name|findrec
argument_list|()
expr_stmt|;
name|bufsiz
operator|=
name|endofrecs
argument_list|()
operator|->
name|charptr
operator|-
name|start
operator|->
name|charptr
expr_stmt|;
if|if
condition|(
name|bytes_left
operator|<
name|bufsiz
condition|)
block|{
name|bufsiz
operator|=
name|bytes_left
expr_stmt|;
name|count
operator|=
name|bufsiz
operator|%
name|RECORDSIZE
expr_stmt|;
if|if
condition|(
name|count
condition|)
name|bzero
argument_list|(
name|start
operator|->
name|charptr
operator|+
name|bytes_left
argument_list|,
call|(
name|int
call|)
argument_list|(
name|RECORDSIZE
operator|-
name|count
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|start
operator|->
name|charptr
argument_list|,
name|bufsiz
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"read error at byte %ld reading %d bytes in file %s"
argument_list|,
name|statbuf
operator|.
name|st_size
operator|-
name|bytes_left
argument_list|,
name|bufsiz
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
comment|/* FOO */
block|}
name|bytes_left
operator|-=
name|count
expr_stmt|;
name|userec
argument_list|(
name|start
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|/
name|RECORDSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|!=
name|bufsiz
condition|)
block|{
name|msg
argument_list|(
literal|"%s: file shrunk by %d bytes, yark!"
argument_list|,
name|p
argument_list|,
name|bytes_left
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DONTDEF
end_ifdef

begin_macro
name|bprint
argument_list|(
argument|fp
argument_list|,
argument|buf
argument_list|,
argument|num
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
operator|||
name|num
operator|==
operator|-
literal|1
condition|)
return|return;
name|fputs
argument_list|(
literal|" '"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
name|num
operator|--
condition|)
block|{
name|c
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|fputs
argument_list|(
literal|"\\\\"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<=
literal|'~'
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|fputs
argument_list|(
literal|"\\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|fputs
argument_list|(
literal|"\\r"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|fputs
argument_list|(
literal|"\\b"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
comment|/* fputs("\\-",fp); */
break|break;
default|default:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\\%03o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fputs
argument_list|(
literal|"'\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|number_of_blocks_read
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|number_of_new_records
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|number_of_records_needed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|union
name|record
modifier|*
name|new_block
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|union
name|record
modifier|*
name|save_block
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|junk_archive
parameter_list|()
block|{
name|int
name|found_stuff
init|=
literal|0
decl_stmt|;
name|int
name|status
init|=
literal|3
decl_stmt|;
name|int
name|prev_status
decl_stmt|;
name|struct
name|name
modifier|*
name|name
decl_stmt|;
comment|/* int dummy_head; */
name|int
name|number_of_records_to_skip
init|=
literal|0
decl_stmt|;
name|int
name|number_of_records_to_keep
init|=
literal|0
decl_stmt|;
name|int
name|number_of_kept_records_in_block
decl_stmt|;
name|int
name|sub_status
decl_stmt|;
specifier|extern
name|int
name|write_archive_to_stdout
decl_stmt|;
comment|/* fprintf(stderr,"Junk files\n"); */
name|name_gather
argument_list|()
expr_stmt|;
name|open_archive
argument_list|(
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|found_stuff
condition|)
block|{
name|prev_status
operator|=
name|status
expr_stmt|;
name|status
operator|=
name|read_header
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|EOF
case|:
name|found_stuff
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|userec
argument_list|(
name|head
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|prev_status
condition|)
block|{
case|case
literal|3
case|:
name|msg
argument_list|(
literal|"This doesn't look like a tar archive."
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|2
case|:
case|case
literal|1
case|:
name|msg
argument_list|(
literal|"Skipping to next header"
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|0
case|:
break|break;
block|}
break|break;
case|case
literal|1
case|:
comment|/* head->header.name[NAMSIZ-1] = '\0'; */
comment|/* fprintf(stderr,"file %s\n",head->header.name); */
if|if
condition|(
operator|(
name|name
operator|=
name|name_scan
argument_list|(
name|current_file_name
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|name
operator|*
operator|)
literal|0
condition|)
block|{
name|userec
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/* fprintf(stderr,"Skip %ld\n",(long)(hstat.st_size)); */
if|if
condition|(
name|head
operator|->
name|header
operator|.
name|isextended
condition|)
name|skip_extended_headers
argument_list|()
expr_stmt|;
name|skip_file
argument_list|(
call|(
name|long
call|)
argument_list|(
name|hstat
operator|.
name|st_size
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|name
operator|->
name|found
operator|=
literal|1
expr_stmt|;
name|found_stuff
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|found_stuff
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* fprintf(stderr,"Out of first loop\n"); */
if|if
condition|(
name|found_stuff
operator|!=
literal|2
condition|)
block|{
name|write_eot
argument_list|()
expr_stmt|;
name|close_archive
argument_list|()
expr_stmt|;
name|names_notfound
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|write_archive_to_stdout
condition|)
name|write_archive_to_stdout
operator|=
literal|0
expr_stmt|;
name|new_block
operator|=
operator|(
expr|union
name|record
operator|*
operator|)
name|malloc
argument_list|(
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_block
operator|==
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"Can't allocate secondary block of %d bytes"
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SYSTEM
argument_list|)
expr_stmt|;
block|}
comment|/* Save away records before this one in this block */
name|number_of_new_records
operator|=
name|ar_record
operator|-
name|ar_block
expr_stmt|;
name|number_of_records_needed
operator|=
name|blocking
operator|-
name|number_of_new_records
expr_stmt|;
if|if
condition|(
name|number_of_new_records
condition|)
name|bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ar_block
argument_list|,
operator|(
name|void
operator|*
operator|)
name|new_block
argument_list|,
operator|(
name|number_of_new_records
operator|)
operator|*
name|RECORDSIZE
argument_list|)
expr_stmt|;
comment|/* fprintf(stderr,"Saved %d recs, need %d more\n",number_of_new_records,number_of_records_needed); */
name|userec
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|header
operator|.
name|isextended
condition|)
name|skip_extended_headers
argument_list|()
expr_stmt|;
name|skip_file
argument_list|(
call|(
name|long
call|)
argument_list|(
name|hstat
operator|.
name|st_size
argument_list|)
argument_list|)
expr_stmt|;
name|found_stuff
operator|=
literal|0
expr_stmt|;
comment|/* goto flush_file; */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Fill in a block */
comment|/* another_file: */
if|if
condition|(
name|ar_record
operator|==
name|ar_last
condition|)
block|{
comment|/* fprintf(stderr,"New block\n"); */
name|flush_archive
argument_list|()
expr_stmt|;
name|number_of_blocks_read
operator|++
expr_stmt|;
block|}
name|sub_status
operator|=
name|read_header
argument_list|()
expr_stmt|;
comment|/* fprintf(stderr,"Header type %d\n",sub_status); */
if|if
condition|(
name|sub_status
operator|==
literal|2
operator|&&
name|f_ignorez
condition|)
block|{
name|userec
argument_list|(
name|head
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sub_status
operator|==
name|EOF
operator|||
name|sub_status
operator|==
literal|2
condition|)
block|{
name|found_stuff
operator|=
literal|1
expr_stmt|;
name|bzero
argument_list|(
name|new_block
index|[
name|number_of_new_records
index|]
operator|.
name|charptr
argument_list|,
name|RECORDSIZE
operator|*
name|number_of_records_needed
argument_list|)
expr_stmt|;
name|number_of_new_records
operator|+=
name|number_of_records_needed
expr_stmt|;
name|number_of_records_needed
operator|=
literal|0
expr_stmt|;
name|write_block
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sub_status
operator|==
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"Deleting non-header from archive."
argument_list|)
expr_stmt|;
name|userec
argument_list|(
name|head
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Found another header.  Yipee! */
comment|/* head->header.name[NAMSIZ-1] = '\0'; */
comment|/* fprintf(stderr,"File %s ",head->header.name); */
if|if
condition|(
name|name
operator|=
name|name_scan
argument_list|(
name|current_file_name
argument_list|)
condition|)
block|{
name|name
operator|->
name|found
operator|=
literal|1
expr_stmt|;
comment|/* fprintf(stderr,"Flush it\n"); */
comment|/* flush_file: */
comment|/* decode_header(head,&hstat,&dummy_head,0); */
name|userec
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|number_of_records_to_skip
operator|=
operator|(
name|hstat
operator|.
name|st_size
operator|+
name|RECORDSIZE
operator|-
literal|1
operator|)
operator|/
name|RECORDSIZE
expr_stmt|;
comment|/* fprintf(stderr,"Flushing %d recs from %s\n",number_of_records_to_skip,head->header.name); */
while|while
condition|(
name|ar_last
operator|-
name|ar_record
operator|<=
name|number_of_records_to_skip
condition|)
block|{
comment|/* fprintf(stderr,"Block: %d<= %d  ",ar_last-ar_record,number_of_records_to_skip); */
name|number_of_records_to_skip
operator|-=
operator|(
name|ar_last
operator|-
name|ar_record
operator|)
expr_stmt|;
name|flush_archive
argument_list|()
expr_stmt|;
name|number_of_blocks_read
operator|++
expr_stmt|;
comment|/* fprintf(stderr,"Block %d left\n",number_of_records_to_skip); */
block|}
name|ar_record
operator|+=
name|number_of_records_to_skip
expr_stmt|;
comment|/* fprintf(stderr,"Final %d\n",number_of_records_to_skip); */
name|number_of_records_to_skip
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* copy_header: */
name|new_block
index|[
name|number_of_new_records
index|]
operator|=
operator|*
name|head
expr_stmt|;
name|number_of_new_records
operator|++
expr_stmt|;
name|number_of_records_needed
operator|--
expr_stmt|;
name|number_of_records_to_keep
operator|=
operator|(
name|hstat
operator|.
name|st_size
operator|+
name|RECORDSIZE
operator|-
literal|1
operator|)
operator|/
name|RECORDSIZE
expr_stmt|;
name|userec
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|number_of_records_needed
operator|==
literal|0
condition|)
name|write_block
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* copy_data: */
name|number_of_kept_records_in_block
operator|=
name|ar_last
operator|-
name|ar_record
expr_stmt|;
if|if
condition|(
name|number_of_kept_records_in_block
operator|>
name|number_of_records_to_keep
condition|)
name|number_of_kept_records_in_block
operator|=
name|number_of_records_to_keep
expr_stmt|;
comment|/* fprintf(stderr,"Need %d kept_in %d keep %d\n",blocking,number_of_kept_records_in_block,number_of_records_to_keep); */
while|while
condition|(
name|number_of_records_to_keep
condition|)
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|ar_record
operator|==
name|ar_last
condition|)
block|{
comment|/* fprintf(stderr,"Flush. . .\n"); */
name|fl_read
argument_list|()
expr_stmt|;
name|number_of_blocks_read
operator|++
expr_stmt|;
name|ar_record
operator|=
name|ar_block
expr_stmt|;
name|number_of_kept_records_in_block
operator|=
name|blocking
expr_stmt|;
if|if
condition|(
name|number_of_kept_records_in_block
operator|>
name|number_of_records_to_keep
condition|)
name|number_of_kept_records_in_block
operator|=
name|number_of_records_to_keep
expr_stmt|;
block|}
name|n
operator|=
name|number_of_kept_records_in_block
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|number_of_records_needed
condition|)
name|n
operator|=
name|number_of_records_needed
expr_stmt|;
comment|/* fprintf(stderr,"Copying %d\n",n); */
name|bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ar_record
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|new_block
operator|+
name|number_of_new_records
operator|)
argument_list|,
name|n
operator|*
name|RECORDSIZE
argument_list|)
expr_stmt|;
name|number_of_new_records
operator|+=
name|n
expr_stmt|;
name|number_of_records_needed
operator|-=
name|n
expr_stmt|;
name|ar_record
operator|+=
name|n
expr_stmt|;
name|number_of_records_to_keep
operator|-=
name|n
expr_stmt|;
name|number_of_kept_records_in_block
operator|-=
name|n
expr_stmt|;
comment|/* fprintf(stderr,"Now new %d  need %d  keep %d  keep_in %d rec %d/%d\n",  number_of_new_records,number_of_records_needed,number_of_records_to_keep,  number_of_kept_records_in_block,ar_record-ar_block,ar_last-ar_block); */
if|if
condition|(
name|number_of_records_needed
operator|==
literal|0
condition|)
block|{
name|write_block
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|write_eot
argument_list|()
expr_stmt|;
name|close_archive
argument_list|()
expr_stmt|;
name|names_notfound
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|write_block
parameter_list|(
name|f
parameter_list|)
name|int
name|f
decl_stmt|;
block|{
comment|/* fprintf(stderr,"Write block\n"); */
comment|/* We've filled out a block.  Write it out. */
comment|/* Backspace back to where we started. . . */
if|if
condition|(
name|archive
operator|!=
name|STDIN
condition|)
operator|(
name|void
operator|)
name|move_arch
argument_list|(
operator|-
operator|(
name|number_of_blocks_read
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|save_block
operator|=
name|ar_block
expr_stmt|;
name|ar_block
operator|=
name|new_block
expr_stmt|;
if|if
condition|(
name|archive
operator|==
name|STDIN
condition|)
name|archive
operator|=
name|STDOUT
expr_stmt|;
name|fl_write
argument_list|()
expr_stmt|;
if|if
condition|(
name|archive
operator|==
name|STDOUT
condition|)
name|archive
operator|=
name|STDIN
expr_stmt|;
name|ar_block
operator|=
name|save_block
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
comment|/* Move the tape head back to where we were */
if|if
condition|(
name|archive
operator|!=
name|STDIN
condition|)
operator|(
name|void
operator|)
name|move_arch
argument_list|(
name|number_of_blocks_read
argument_list|)
expr_stmt|;
name|number_of_blocks_read
operator|--
expr_stmt|;
block|}
name|number_of_records_needed
operator|=
name|blocking
expr_stmt|;
name|number_of_new_records
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move archive descriptor by n blocks worth.  If n is positive we move    forward, else we move negative.   If its a tape, MTIOCTOP had better    work.  If its something else, we try to seek on it.  If we can't    seek, we lose! */
end_comment

begin_function
name|int
name|move_arch
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|long
name|cur
decl_stmt|;
ifdef|#
directive|ifdef
name|MTIOCTOP
name|struct
name|mtop
name|t
decl_stmt|;
name|int
name|er
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|t
operator|.
name|mt_op
operator|=
name|MTFSR
expr_stmt|;
name|t
operator|.
name|mt_count
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
name|t
operator|.
name|mt_op
operator|=
name|MTBSR
expr_stmt|;
name|t
operator|.
name|mt_count
operator|=
operator|-
name|n
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|er
operator|=
name|rmtioctl
argument_list|(
name|archive
argument_list|,
name|MTIOCTOP
argument_list|,
operator|&
name|t
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|errno
operator|==
name|EIO
operator|&&
operator|(
name|er
operator|=
name|rmtioctl
argument_list|(
name|archive
argument_list|,
name|MTIOCTOP
argument_list|,
operator|&
name|t
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
name|cur
operator|=
name|rmtlseek
argument_list|(
name|archive
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cur
operator|+=
name|blocksize
operator|*
name|n
expr_stmt|;
comment|/* fprintf(stderr,"Fore to %x\n",cur); */
if|if
condition|(
name|rmtlseek
argument_list|(
name|archive
argument_list|,
name|cur
argument_list|,
literal|0
argument_list|)
operator|!=
name|cur
condition|)
block|{
comment|/* Lseek failed.  Try a different method */
name|msg
argument_list|(
literal|"Couldn't re-position archive file."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_BADARCH
argument_list|)
expr_stmt|;
block|}
return|return
literal|3
return|;
block|}
end_function

end_unit

