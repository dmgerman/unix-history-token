begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Supporting routines which may sometimes be missing.    Copyright (C) 1988, 1992 Free Software Foundation  This file is part of GNU Tar.  GNU Tar is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Tar is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Tar; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|STDC_HEADERS
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|V7
end_ifndef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"tar.h"
end_include

begin_include
include|#
directive|include
file|"port.h"
end_include

begin_decl_stmt
specifier|extern
name|long
name|baserec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* All machine-dependent #ifdefs should appear here, instead of    being scattered through the file.  For UN*X systems, it is better to    figure out what is needed in the configure script, for most of the    features. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__MSDOS__
end_ifdef

begin_decl_stmt
name|char
name|TTY_NAME
index|[]
init|=
literal|"con"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HAVE_STRSTR
end_define

begin_define
define|#
directive|define
name|HAVE_RENAME
end_define

begin_define
define|#
directive|define
name|HAVE_MKDIR
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
name|TTY_NAME
index|[]
init|=
literal|"/dev/tty"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* End of system-dependent #ifdefs */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_VALLOC
end_ifndef

begin_comment
comment|/*  * valloc() does a malloc() on a page boundary.  On some systems,  * this can make large block I/O more efficient.  */
end_comment

begin_function
name|char
modifier|*
name|valloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
block|{
return|return
operator|(
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_VALLOC */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_MKDIR
end_ifndef

begin_comment
comment|/*  * Written by Robert Rother, Mariah Corporation, August 1985.  *  * If you want it, it's yours.  All I ask in return is that if you  * figure out how to do this in a Bourne Shell script you send me  * a copy.  *					sdcsvax!rmr or rmr@uscd  *  * Severely hacked over by John Gilmore to make a 4.2BSD compatible  * subroutine.	11Mar86; hoptoad!gnu  *  * Modified by rmtodd@uokmax 6-28-87 -- when making an already existing dir,  * subroutine didn't return EEXIST.  It does now.  */
end_comment

begin_comment
comment|/*  * Make a directory.  */
end_comment

begin_function
name|int
name|mkdir
parameter_list|(
name|dpath
parameter_list|,
name|dmode
parameter_list|)
name|char
modifier|*
name|dpath
decl_stmt|;
name|int
name|dmode
decl_stmt|;
block|{
name|int
name|cpid
decl_stmt|,
name|status
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dpath
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EEXIST
expr_stmt|;
comment|/* Stat worked, so it already exists */
return|return
operator|-
literal|1
return|;
block|}
comment|/* If stat fails for a reason other than non-existence, return error */
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|cpid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* Error in fork() */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Errno is set already */
case|case
literal|0
case|:
comment|/* Child process */
comment|/* 		 * Cheap hack to set mode of new directory.  Since this 		 * child process is going away anyway, we zap its umask. 		 * FIXME, this won't suffice to set SUID, SGID, etc. on this 		 * directory.  Does anybody care? 		 */
name|status
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Get current umask */
name|status
operator|=
name|umask
argument_list|(
name|status
operator||
operator|(
literal|0777
operator|&
operator|~
name|dmode
operator|)
argument_list|)
expr_stmt|;
comment|/* Set for mkdir */
name|execl
argument_list|(
literal|"/bin/mkdir"
argument_list|,
literal|"mkdir"
argument_list|,
name|dpath
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Can't exec /bin/mkdir */
default|default:
comment|/* Parent process */
while|while
condition|(
name|cpid
operator|!=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
condition|)
empty_stmt|;
comment|/* Wait for kid to finish */
block|}
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
operator|||
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|EIO
expr_stmt|;
comment|/* We don't know why, but */
return|return
operator|-
literal|1
return|;
comment|/* /bin/mkdir failed */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|rmdir
parameter_list|(
name|dpath
parameter_list|)
name|char
modifier|*
name|dpath
decl_stmt|;
block|{
name|int
name|cpid
decl_stmt|,
name|status
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dpath
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Stat just set errno.  We don't have to */
return|return
operator|-
literal|1
return|;
block|}
switch|switch
condition|(
name|cpid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* Error in fork() */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Errno is set already */
case|case
literal|0
case|:
comment|/* Child process */
name|execl
argument_list|(
literal|"/bin/rmdir"
argument_list|,
literal|"rmdir"
argument_list|,
name|dpath
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Can't exec /bin/mkdir */
default|default:
comment|/* Parent process */
while|while
condition|(
name|cpid
operator|!=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
condition|)
empty_stmt|;
comment|/* Wait for kid to finish */
block|}
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
operator|||
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|EIO
expr_stmt|;
comment|/* We don't know why, but */
return|return
operator|-
literal|1
return|;
comment|/* /bin/mkdir failed */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_MKDIR */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_RENAME
end_ifndef

begin_comment
comment|/* Rename file FROM to file TO.    Return 0 if successful, -1 if not. */
end_comment

begin_function
name|int
name|rename
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
block|{
name|struct
name|stat
name|from_stats
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|from
argument_list|,
operator|&
name|from_stats
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|unlink
argument_list|(
name|to
argument_list|)
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|link
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|unlink
argument_list|(
name|from
argument_list|)
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|unlink
argument_list|(
name|to
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_RENAME */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|minix
end_ifdef

begin_comment
comment|/* Minix has bcopy but not bzero, and no memset.  Thanks, Andy. */
end_comment

begin_function
name|void
name|bzero
parameter_list|(
name|s1
parameter_list|,
name|n
parameter_list|)
specifier|register
name|char
modifier|*
name|s1
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
block|{
while|while
condition|(
name|n
operator|--
condition|)
operator|*
name|s1
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* It also has no bcmp() */
end_comment

begin_function
name|int
name|bcmp
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|n
parameter_list|)
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
for|for
control|(
init|;
name|n
operator|--
condition|;
operator|++
name|s1
operator|,
operator|++
name|s2
control|)
block|{
if|if
condition|(
operator|*
name|s1
operator|!=
operator|*
name|s2
condition|)
return|return
operator|*
name|s1
operator|-
operator|*
name|s2
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Groan, Minix doesn't have execlp either!  *  * execlp(file,arg0,arg1...argn,(char *)NULL)  * exec a program, automatically searching for the program through  * all the directories on the PATH.  *  * This version is naive about variable argument lists, it assumes  * a straightforward C calling sequence.  If your system has odd stacks  * *and* doesn't have execlp, YOU get to fix it.  */
end_comment

begin_function
name|int
name|execlp
parameter_list|(
name|filename
parameter_list|,
name|arg0
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|,
decl|*
name|arg0
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|path
decl_stmt|;
specifier|register
name|char
modifier|*
name|fnbuffer
decl_stmt|;
name|char
modifier|*
modifier|*
name|argstart
init|=
operator|&
name|arg0
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* couldn't find path variable -- try to exec given filename */
return|return
name|execve
argument_list|(
name|filename
argument_list|,
name|argstart
argument_list|,
name|environ
argument_list|)
return|;
block|}
comment|/* 	 * make a place to build the filename.  We malloc larger than we 	 * need, but we know it will fit in this. 	 */
name|fnbuffer
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fnbuffer
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * try each component of the path to see if the file's there 	 * and executable. 	 */
for|for
control|(
name|path
operator|=
name|p
init|;
name|path
condition|;
name|path
operator|=
name|p
control|)
block|{
comment|/* construct full path name to try */
if|if
condition|(
operator|(
name|p
operator|=
name|index
argument_list|(
name|path
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|fnbuffer
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|fnbuffer
argument_list|,
name|path
argument_list|,
name|p
operator|-
name|path
argument_list|)
expr_stmt|;
name|fnbuffer
index|[
name|p
operator|-
name|path
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|++
expr_stmt|;
comment|/* Skip : for next time */
block|}
if|if
condition|(
name|strlen
argument_list|(
name|fnbuffer
argument_list|)
operator|!=
literal|0
condition|)
name|strcat
argument_list|(
name|fnbuffer
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fnbuffer
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* check to see if file is there and is a normal file */
if|if
condition|(
name|stat
argument_list|(
name|fnbuffer
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
continue|continue;
comment|/* file not there,keep on looking */
else|else
goto|goto
name|fail
goto|;
comment|/* failed for some reason, return */
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|execve
argument_list|(
name|fnbuffer
argument_list|,
name|argstart
argument_list|,
name|environ
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
operator|&&
name|errno
operator|!=
name|ENOEXEC
condition|)
block|{
comment|/* failed, for some other reason besides "file 			 * not found" or "not a.out format" 			 */
goto|goto
name|fail
goto|;
block|}
comment|/* 		 * If we got error ENOEXEC, the file is executable but is 		 * not an object file.  Try to execute it as a shell script, 		 * returning error if we can't execute /bin/sh. 		 * 		 * FIXME, this code is broken in several ways.  Shell 		 * scripts should not in general be executed by the user's 		 * SHELL variable program.  On more mature systems, the 		 * script can specify with #!/bin/whatever.  Also, this 		 * code clobbers argstart[-1] if the exec of the shell 		 * fails. 		 */
if|if
condition|(
name|errno
operator|==
name|ENOEXEC
condition|)
block|{
name|char
modifier|*
name|shell
decl_stmt|;
comment|/* Try to execute command "sh arg0 arg1 ..." */
if|if
condition|(
operator|(
name|shell
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|shell
operator|=
literal|"/bin/sh"
expr_stmt|;
name|argstart
index|[
operator|-
literal|1
index|]
operator|=
name|shell
expr_stmt|;
name|argstart
index|[
literal|0
index|]
operator|=
name|fnbuffer
expr_stmt|;
name|execve
argument_list|(
name|shell
argument_list|,
operator|&
name|argstart
index|[
operator|-
literal|1
index|]
argument_list|,
name|environ
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
comment|/* Exec didn't work */
block|}
comment|/* 		 * If we succeeded, the execve() doesn't return, so we 		 * can only be here is if the file hasn't been found yet. 		 * Try the next place on the path. 		 */
block|}
comment|/* all attempts failed to locate the file.  Give up. */
name|errno
operator|=
name|ENOENT
expr_stmt|;
name|fail
label|:
name|free
argument_list|(
name|fnbuffer
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* minix */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EMUL_OPEN3
end_ifdef

begin_include
include|#
directive|include
file|"open3.h"
end_include

begin_comment
comment|/*  * open3 -- routine to emulate the 3-argument open system  * call that is present in most modern Unix systems.  * This version attempts to support all the flag bits except for O_NDELAY  * and O_APPEND, which are silently ignored.  The emulation is not as efficient  * as the real thing (at worst, 4 system calls instead of one), but there's  * not much I can do about that.  *  * Written 6/10/87 by rmtodd@uokmax  *  * open3(path, flag, mode)  * Attempts to open the file specified by  * the given pathname.  The following flag bits (#defined in tar.h)  * specify options to the routine:  *	O_RDONLY	file open for read only  *	O_WRONLY	file open for write only  *	O_RDWR		file open for both read& write  * (Needless to say, you should only specify one of the above).  * 	O_CREAT		file is created with specified mode if it needs to be.  *	O_TRUNC		if file exists, it is truncated to 0 bytes  *	O_EXCL		used with O_CREAT--routine returns error if file exists  * Function returns file descriptor if successful, -1 and errno if not.  */
end_comment

begin_comment
comment|/*  * array to give arguments to access for various modes  * FIXME, this table depends on the specific integer values of O_XXX,  * and also contains integers (args to 'access') that should be #define's.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|modes
index|[]
init|=
block|{
literal|04
block|,
comment|/* O_RDONLY */
literal|02
block|,
comment|/* O_WRONLY */
literal|06
block|,
comment|/* O_RDWR */
literal|06
block|,
comment|/* invalid but we'd better cope -- O_WRONLY+O_RDWR */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Shut off the automatic emulation of open(), we'll need it. */
end_comment

begin_undef
undef|#
directive|undef
name|open
end_undef

begin_function
name|int
name|open3
parameter_list|(
name|path
parameter_list|,
name|flags
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|mode
decl_stmt|;
block|{
name|int
name|exists
init|=
literal|1
decl_stmt|;
name|int
name|call_creat
init|=
literal|0
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* 	 * We actually do the work by calling the open() or creat() system 	 * call, depending on the flags.  Call_creat is true if we will use 	 * creat(), false if we will use open(). 	 */
comment|/* 	 * See if the file exists and is accessible in the requested mode. 	 * 	 * Strictly speaking we shouldn't be using access, since access checks 	 * against real uid, and the open call should check against euid. 	 * Most cases real uid == euid, so it won't matter.   FIXME. 	 * FIXME, the construction "flags& 3" and the modes table depends 	 * on the specific integer values of the O_XXX #define's.  Foo! 	 */
if|if
condition|(
name|access
argument_list|(
name|path
argument_list|,
name|modes
index|[
name|flags
operator|&
literal|3
index|]
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
comment|/* the file does not exist */
name|exists
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* probably permission violation */
if|if
condition|(
name|flags
operator|&
name|O_EXCL
condition|)
block|{
comment|/* Oops, the file exists, we didn't want it. */
comment|/* No matter what the error, claim EEXIST. */
name|errno
operator|=
name|EEXIST
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* if we have the O_CREAT bit set, check for O_EXCL */
if|if
condition|(
name|flags
operator|&
name|O_CREAT
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|O_EXCL
operator|)
operator|&&
name|exists
condition|)
block|{
comment|/* Oops, the file exists and we didn't want it to. */
name|errno
operator|=
name|EEXIST
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 		 * If the file doesn't exist, be sure to call creat() so that 		 * it will be created with the proper mode. 		 */
if|if
condition|(
operator|!
name|exists
condition|)
name|call_creat
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* If O_CREAT isn't set and the file doesn't exist, error. */
if|if
condition|(
operator|!
name|exists
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* 	 * If the O_TRUNC flag is set and the file exists, we want to call 	 * creat() anyway, since creat() guarantees that the file will be 	 * truncated and open()-for-writing doesn't. 	 * (If the file doesn't exist, we're calling creat() anyway and the 	 * file will be created with zero length.) 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|O_TRUNC
operator|)
operator|&&
name|exists
condition|)
name|call_creat
operator|=
literal|1
expr_stmt|;
comment|/* actually do the call */
if|if
condition|(
name|call_creat
condition|)
block|{
comment|/* 		 * call creat.  May have to close and reopen the file if we 		 * want O_RDONLY or O_RDWR access -- creat() only gives 		 * O_WRONLY. 		 */
name|fd
operator|=
name|creat
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|||
operator|(
name|flags
operator|&
name|O_WRONLY
operator|)
condition|)
return|return
name|fd
return|;
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Fall out to reopen the file we've created */
block|}
comment|/* 	 * calling old open, we strip most of the new flags just in case. 	 */
return|return
name|open
argument_list|(
name|path
argument_list|,
name|flags
operator|&
operator|(
name|O_RDONLY
operator||
name|O_WRONLY
operator||
name|O_RDWR
operator||
name|O_BINARY
operator|)
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EMUL_OPEN3 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_MKNOD
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__MSDOS__
end_ifdef

begin_typedef
typedef|typedef
name|int
name|dev_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Fake mknod by complaining */
end_comment

begin_function
name|int
name|mknod
parameter_list|(
name|path
parameter_list|,
name|mode
parameter_list|,
name|dev
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|unsigned
name|short
name|mode
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|errno
operator|=
name|ENXIO
expr_stmt|;
comment|/* No such device or address */
return|return
operator|-
literal|1
return|;
comment|/* Just give an error */
block|}
end_function

begin_comment
comment|/* Fake links by copying */
end_comment

begin_function
name|int
name|link
parameter_list|(
name|path1
parameter_list|,
name|path2
parameter_list|)
name|char
modifier|*
name|path1
decl_stmt|;
name|char
modifier|*
name|path2
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|int
name|ifd
decl_stmt|,
name|ofd
decl_stmt|;
name|int
name|nrbytes
decl_stmt|;
name|int
name|nwbytes
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s: cannot link to %s, copying instead\n"
argument_list|,
name|tar
argument_list|,
name|path1
argument_list|,
name|path2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifd
operator|=
name|open
argument_list|(
name|path1
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|ofd
operator|=
name|creat
argument_list|(
name|path2
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|setmode
argument_list|(
name|ofd
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|nrbytes
operator|=
name|read
argument_list|(
name|ifd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|nwbytes
operator|=
name|write
argument_list|(
name|ofd
argument_list|,
name|buf
argument_list|,
name|nrbytes
argument_list|)
operator|)
operator|!=
name|nrbytes
condition|)
block|{
name|nrbytes
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Note use of "|" rather than "||" below: we want to close 	 * the files even if an error occurs. 	 */
if|if
condition|(
operator|(
name|nrbytes
operator|<
literal|0
operator|)
operator||
operator|(
literal|0
operator|!=
name|close
argument_list|(
name|ifd
argument_list|)
operator|)
operator||
operator|(
literal|0
operator|!=
name|close
argument_list|(
name|ofd
argument_list|)
operator|)
condition|)
block|{
name|unlink
argument_list|(
name|path2
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* everyone owns everything on MS-DOS (or is it no one owns anything?) */
end_comment

begin_function
name|int
name|chown
parameter_list|(
name|path
parameter_list|,
name|uid
parameter_list|,
name|gid
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|uid
decl_stmt|;
name|int
name|gid
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|geteuid
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_MKNOD */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__TURBOC__
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_struct
struct|struct
name|utimbuf
block|{
name|time_t
name|actime
decl_stmt|;
comment|/* Access time. */
name|time_t
name|modtime
decl_stmt|;
comment|/* Modification time. */
block|}
struct|;
end_struct

begin_function
name|int
name|utime
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|struct
name|utimbuf
modifier|*
name|utb
parameter_list|)
block|{
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|struct
name|ftime
name|filetime
decl_stmt|;
name|time_t
name|when
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|utb
operator|==
literal|0
condition|)
name|when
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|when
operator|=
name|utb
operator|->
name|modtime
expr_stmt|;
name|fd
operator|=
name|_open
argument_list|(
name|filename
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|when
argument_list|)
expr_stmt|;
if|if
condition|(
name|tm
operator|->
name|tm_year
operator|<
literal|80
condition|)
name|filetime
operator|.
name|ft_year
operator|=
literal|0
expr_stmt|;
else|else
name|filetime
operator|.
name|ft_year
operator|=
name|tm
operator|->
name|tm_year
operator|-
literal|80
expr_stmt|;
name|filetime
operator|.
name|ft_month
operator|=
name|tm
operator|->
name|tm_mon
operator|+
literal|1
expr_stmt|;
name|filetime
operator|.
name|ft_day
operator|=
name|tm
operator|->
name|tm_mday
expr_stmt|;
if|if
condition|(
name|tm
operator|->
name|tm_hour
operator|<
literal|0
condition|)
name|filetime
operator|.
name|ft_hour
operator|=
literal|0
expr_stmt|;
else|else
name|filetime
operator|.
name|ft_hour
operator|=
name|tm
operator|->
name|tm_hour
expr_stmt|;
name|filetime
operator|.
name|ft_min
operator|=
name|tm
operator|->
name|tm_min
expr_stmt|;
name|filetime
operator|.
name|ft_tsec
operator|=
name|tm
operator|->
name|tm_sec
operator|/
literal|2
expr_stmt|;
name|status
operator|=
name|setftime
argument_list|(
name|fd
argument_list|,
operator|&
name|filetime
argument_list|)
expr_stmt|;
name|_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __TURBOC__ */
end_comment

begin_comment
comment|/* Stash argv[0] here so panic will know what the program is called */
end_comment

begin_decl_stmt
name|char
modifier|*
name|myname
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|panic
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|myname
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|PTR
name|ck_malloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
name|PTR
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|size
condition|)
name|size
operator|++
expr_stmt|;
name|ret
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"Couldn't allocate memory"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Used by alloca.c and bison.simple. */
end_comment

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|size_t
name|size
decl_stmt|;
block|{
return|return
operator|(
name|char
operator|*
operator|)
name|ck_malloc
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|PTR
name|ck_realloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
name|PTR
name|ptr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|PTR
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
name|ret
operator|=
name|ck_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"Couldn't re-allocate memory"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Implement a variable sized buffer of 'stuff'.  We don't know what it is,    nor do we care, as long as it doesn't mind being aligned on a char boundry.  */
end_comment

begin_struct
struct|struct
name|buffer
block|{
name|int
name|allocated
decl_stmt|;
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MIN_ALLOCATE
value|50
end_define

begin_function
name|char
modifier|*
name|init_buffer
parameter_list|()
block|{
name|struct
name|buffer
modifier|*
name|b
decl_stmt|;
name|b
operator|=
operator|(
expr|struct
name|buffer
operator|*
operator|)
name|ck_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|allocated
operator|=
name|MIN_ALLOCATE
expr_stmt|;
name|b
operator|->
name|b
operator|=
operator|(
name|char
operator|*
operator|)
name|ck_malloc
argument_list|(
name|MIN_ALLOCATE
argument_list|)
expr_stmt|;
name|b
operator|->
name|length
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|b
return|;
block|}
end_function

begin_function
name|void
name|flush_buffer
parameter_list|(
name|bb
parameter_list|)
name|char
modifier|*
name|bb
decl_stmt|;
block|{
name|struct
name|buffer
modifier|*
name|b
decl_stmt|;
name|b
operator|=
operator|(
expr|struct
name|buffer
operator|*
operator|)
name|bb
expr_stmt|;
name|free
argument_list|(
name|b
operator|->
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|b
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|allocated
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_buffer
parameter_list|(
name|bb
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|bb
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|struct
name|buffer
modifier|*
name|b
decl_stmt|;
name|b
operator|=
operator|(
expr|struct
name|buffer
operator|*
operator|)
name|bb
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|length
operator|+
name|n
operator|>
name|b
operator|->
name|allocated
condition|)
block|{
name|b
operator|->
name|allocated
operator|=
name|b
operator|->
name|length
operator|+
name|n
operator|+
name|MIN_ALLOCATE
expr_stmt|;
name|b
operator|->
name|b
operator|=
operator|(
name|char
operator|*
operator|)
name|ck_realloc
argument_list|(
name|b
operator|->
name|b
argument_list|,
name|b
operator|->
name|allocated
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|p
argument_list|,
name|b
operator|->
name|b
operator|+
name|b
operator|->
name|length
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|b
operator|->
name|length
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|get_buffer
parameter_list|(
name|bb
parameter_list|)
name|char
modifier|*
name|bb
decl_stmt|;
block|{
name|struct
name|buffer
modifier|*
name|b
decl_stmt|;
name|b
operator|=
operator|(
expr|struct
name|buffer
operator|*
operator|)
name|bb
expr_stmt|;
return|return
name|b
operator|->
name|b
return|;
block|}
end_function

begin_decl_stmt
name|char
modifier|*
name|merge_sort
argument_list|(
name|list
argument_list|,
name|n
argument_list|,
name|off
argument_list|,
name|cmp
argument_list|)
name|char
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|cmp
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|unsigned
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|off
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|char
modifier|*
name|alist
decl_stmt|,
modifier|*
name|blist
decl_stmt|;
name|unsigned
name|alength
decl_stmt|,
name|blength
decl_stmt|;
name|char
modifier|*
name|tptr
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|char
modifier|*
modifier|*
name|prev
decl_stmt|;
define|#
directive|define
name|NEXTOF
parameter_list|(
name|ptr
parameter_list|)
value|(* ((char **)(((char *)(ptr))+off) ) )
if|if
condition|(
name|n
operator|==
literal|1
condition|)
return|return
name|list
return|;
if|if
condition|(
name|n
operator|==
literal|2
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|cmp
call|)
argument_list|(
name|list
argument_list|,
name|NEXTOF
argument_list|(
name|list
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|ret
operator|=
name|NEXTOF
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|NEXTOF
argument_list|(
name|ret
argument_list|)
operator|=
name|list
expr_stmt|;
name|NEXTOF
argument_list|(
name|list
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|ret
return|;
block|}
return|return
name|list
return|;
block|}
name|alist
operator|=
name|list
expr_stmt|;
name|alength
operator|=
operator|(
name|n
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|blength
operator|=
name|n
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|tptr
operator|=
name|list
operator|,
name|tmp
operator|=
operator|(
name|n
operator|-
literal|1
operator|)
operator|/
literal|2
init|;
name|tmp
condition|;
name|tptr
operator|=
name|NEXTOF
argument_list|(
name|tptr
argument_list|)
operator|,
name|tmp
operator|--
control|)
empty_stmt|;
name|blist
operator|=
name|NEXTOF
argument_list|(
name|tptr
argument_list|)
expr_stmt|;
name|NEXTOF
argument_list|(
name|tptr
argument_list|)
operator|=
literal|0
expr_stmt|;
name|alist
operator|=
name|merge_sort
argument_list|(
name|alist
argument_list|,
name|alength
argument_list|,
name|off
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
name|blist
operator|=
name|merge_sort
argument_list|(
name|blist
argument_list|,
name|blength
argument_list|,
name|off
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
name|prev
operator|=
operator|&
name|ret
expr_stmt|;
for|for
control|(
init|;
name|alist
operator|&&
name|blist
condition|;
control|)
block|{
if|if
condition|(
call|(
modifier|*
name|cmp
call|)
argument_list|(
name|alist
argument_list|,
name|blist
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tptr
operator|=
name|NEXTOF
argument_list|(
name|alist
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|alist
expr_stmt|;
name|prev
operator|=
operator|&
operator|(
name|NEXTOF
argument_list|(
name|alist
argument_list|)
operator|)
expr_stmt|;
name|alist
operator|=
name|tptr
expr_stmt|;
block|}
else|else
block|{
name|tptr
operator|=
name|NEXTOF
argument_list|(
name|blist
argument_list|)
expr_stmt|;
operator|*
name|prev
operator|=
name|blist
expr_stmt|;
name|prev
operator|=
operator|&
operator|(
name|NEXTOF
argument_list|(
name|blist
argument_list|)
operator|)
expr_stmt|;
name|blist
operator|=
name|tptr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|alist
condition|)
operator|*
name|prev
operator|=
name|alist
expr_stmt|;
else|else
operator|*
name|prev
operator|=
name|blist
expr_stmt|;
return|return
name|ret
return|;
block|}
end_block

begin_function
name|void
name|ck_close
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
if|if
condition|(
name|close
argument_list|(
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"can't close a file #%d"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SYSTEM
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* Quote_copy_string is like quote_string, but instead of modifying the    string in place, it malloc-s a copy  of the string, and returns that.    If the string does not have to be quoted, it returns the NULL string.    The allocated copy can, of course, be freed with free() after the    caller is done with it.  */
end_comment

begin_function
name|char
modifier|*
name|quote_copy_string
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|from_here
decl_stmt|;
name|char
modifier|*
name|to_there
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|copy_buf
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|copying
init|=
literal|0
decl_stmt|;
name|from_here
operator|=
name|string
expr_stmt|;
while|while
condition|(
operator|*
name|from_here
condition|)
block|{
name|c
operator|=
operator|*
name|from_here
operator|++
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|!
name|copying
condition|)
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
operator|(
name|from_here
operator|-
name|string
operator|)
operator|-
literal|1
expr_stmt|;
name|copying
operator|++
expr_stmt|;
name|copy_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|n
operator|+
literal|5
operator|+
name|strlen
argument_list|(
name|from_here
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|copy_buf
condition|)
return|return
literal|0
return|;
name|bcopy
argument_list|(
name|string
argument_list|,
name|copy_buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|to_there
operator|=
name|copy_buf
operator|+
name|n
expr_stmt|;
block|}
operator|*
name|to_there
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|to_there
operator|++
operator|=
literal|'\\'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|copying
condition|)
operator|*
name|to_there
operator|++
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|copying
condition|)
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
operator|(
name|from_here
operator|-
name|string
operator|)
operator|-
literal|1
expr_stmt|;
name|copying
operator|++
expr_stmt|;
name|copy_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|n
operator|+
literal|5
operator|+
name|strlen
argument_list|(
name|from_here
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|copy_buf
condition|)
return|return
literal|0
return|;
name|bcopy
argument_list|(
name|string
argument_list|,
name|copy_buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|to_there
operator|=
name|copy_buf
operator|+
name|n
expr_stmt|;
block|}
operator|*
name|to_there
operator|++
operator|=
literal|'\\'
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|*
name|to_there
operator|++
operator|=
literal|'n'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
operator|*
name|to_there
operator|++
operator|=
literal|'t'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\f'
condition|)
operator|*
name|to_there
operator|++
operator|=
literal|'f'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\b'
condition|)
operator|*
name|to_there
operator|++
operator|=
literal|'b'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
operator|*
name|to_there
operator|++
operator|=
literal|'r'
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\177'
condition|)
operator|*
name|to_there
operator|++
operator|=
literal|'?'
expr_stmt|;
else|else
block|{
name|to_there
index|[
literal|0
index|]
operator|=
operator|(
name|c
operator|>>
literal|6
operator|)
operator|+
literal|'0'
expr_stmt|;
name|to_there
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|c
operator|>>
literal|3
operator|)
operator|&
literal|07
operator|)
operator|+
literal|'0'
expr_stmt|;
name|to_there
index|[
literal|2
index|]
operator|=
operator|(
name|c
operator|&
literal|07
operator|)
operator|+
literal|'0'
expr_stmt|;
name|to_there
operator|+=
literal|3
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|copying
condition|)
block|{
operator|*
name|to_there
operator|=
literal|'\0'
expr_stmt|;
return|return
name|copy_buf
return|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Un_quote_string takes a quoted c-string (like those produced by    quote_string or quote_copy_string and turns it back into the    un-quoted original.  This is done in place.  */
end_comment

begin_comment
comment|/* There is no un-quote-copy-string.  Write it yourself */
end_comment

begin_function
name|char
modifier|*
name|un_quote_string
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|char
modifier|*
name|from_here
decl_stmt|;
name|char
modifier|*
name|to_there
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|ret
operator|=
name|string
expr_stmt|;
name|to_there
operator|=
name|string
expr_stmt|;
name|from_here
operator|=
name|string
expr_stmt|;
while|while
condition|(
operator|*
name|from_here
condition|)
block|{
if|if
condition|(
operator|*
name|from_here
operator|!=
literal|'\\'
condition|)
block|{
if|if
condition|(
name|from_here
operator|!=
name|to_there
condition|)
operator|*
name|to_there
operator|++
operator|=
operator|*
name|from_here
operator|++
expr_stmt|;
else|else
name|from_here
operator|++
operator|,
name|to_there
operator|++
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
operator|*
operator|++
name|from_here
condition|)
block|{
case|case
literal|'\\'
case|:
operator|*
name|to_there
operator|++
operator|=
operator|*
name|from_here
operator|++
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
operator|*
name|to_there
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|from_here
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|to_there
operator|++
operator|=
literal|'\t'
expr_stmt|;
name|from_here
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|*
name|to_there
operator|++
operator|=
literal|'\f'
expr_stmt|;
name|from_here
operator|++
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
operator|*
name|to_there
operator|++
operator|=
literal|'\b'
expr_stmt|;
name|from_here
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|to_there
operator|++
operator|=
literal|'\r'
expr_stmt|;
name|from_here
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
operator|*
name|to_there
operator|++
operator|=
literal|0177
expr_stmt|;
name|from_here
operator|++
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|tmp
operator|=
operator|*
name|from_here
operator|-
literal|'0'
expr_stmt|;
name|from_here
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|from_here
operator|<
literal|'0'
operator|||
operator|*
name|from_here
operator|>
literal|'7'
condition|)
block|{
operator|*
name|to_there
operator|++
operator|=
name|tmp
expr_stmt|;
break|break;
block|}
name|tmp
operator|=
name|tmp
operator|*
literal|8
operator|+
operator|*
name|from_here
operator|-
literal|'0'
expr_stmt|;
name|from_here
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|from_here
operator|<
literal|'0'
operator|||
operator|*
name|from_here
operator|>
literal|'7'
condition|)
block|{
operator|*
name|to_there
operator|++
operator|=
name|tmp
expr_stmt|;
break|break;
block|}
name|tmp
operator|=
name|tmp
operator|*
literal|8
operator|+
operator|*
name|from_here
operator|-
literal|'0'
expr_stmt|;
name|from_here
operator|++
expr_stmt|;
operator|*
name|to_there
operator|=
name|tmp
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
literal|0
expr_stmt|;
operator|*
name|to_there
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|to_there
operator|++
operator|=
operator|*
name|from_here
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|to_there
condition|)
operator|*
name|to_there
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|__MSDOS__
end_ifndef

begin_function
name|void
name|ck_pipe
parameter_list|(
name|pipes
parameter_list|)
name|int
modifier|*
name|pipes
decl_stmt|;
block|{
if|if
condition|(
name|pipe
argument_list|(
name|pipes
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"can't open a pipe"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SYSTEM
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__MSDOS__ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRSTR
end_ifndef

begin_comment
comment|/*  * strstr - find first occurrence of wanted in s  */
end_comment

begin_function
name|char
modifier|*
comment|/* found string, or NULL if none */
name|strstr
parameter_list|(
name|s
parameter_list|,
name|wanted
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|wanted
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|scan
decl_stmt|;
specifier|register
name|size_t
name|len
decl_stmt|;
specifier|register
name|char
name|firstc
decl_stmt|;
if|if
condition|(
operator|*
name|wanted
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
comment|/* 	 * The odd placement of the two tests is so "" is findable. 	 * Also, we inline the first char for speed. 	 * The ++ on scan has been moved down for optimization. 	 */
name|firstc
operator|=
operator|*
name|wanted
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|wanted
argument_list|)
expr_stmt|;
for|for
control|(
name|scan
operator|=
name|s
init|;
operator|*
name|scan
operator|!=
name|firstc
operator|||
name|strncmp
argument_list|(
name|scan
argument_list|,
name|wanted
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|;
control|)
if|if
condition|(
operator|*
name|scan
operator|++
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
return|return
name|scan
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_STRSTR */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_FTRUNCATE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|F_CHSIZE
end_ifdef

begin_function
name|int
name|ftruncate
parameter_list|(
name|fd
parameter_list|,
name|length
parameter_list|)
name|int
name|fd
decl_stmt|;
name|off_t
name|length
decl_stmt|;
block|{
return|return
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_CHSIZE
argument_list|,
name|length
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !F_CHSIZE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|F_FREESP
end_ifdef

begin_comment
comment|/* code courtesy of William Kucharski, kucharsk@Solbourne.com */
end_comment

begin_function
name|int
name|ftruncate
parameter_list|(
name|fd
parameter_list|,
name|length
parameter_list|)
name|int
name|fd
decl_stmt|;
comment|/* file descriptor */
name|off_t
name|length
decl_stmt|;
comment|/* length to set file to */
block|{
name|struct
name|flock
name|fl
decl_stmt|;
name|fl
operator|.
name|l_whence
operator|=
literal|0
expr_stmt|;
name|fl
operator|.
name|l_len
operator|=
literal|0
expr_stmt|;
name|fl
operator|.
name|l_start
operator|=
name|length
expr_stmt|;
name|fl
operator|.
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
comment|/* write lock on file space */
comment|/* 	 * This relies on the UNDOCUMENTED F_FREESP argument to 	 * fcntl(2), which truncates the file so that it ends at the 	 * position indicated by fl.l_start. 	 * 	 * Will minor miracles never cease? 	 */
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_FREESP
argument_list|,
operator|&
name|fl
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !F_FREESP */
end_comment

begin_function
name|int
name|ftruncate
parameter_list|(
name|fd
parameter_list|,
name|length
parameter_list|)
name|int
name|fd
decl_stmt|;
name|off_t
name|length
decl_stmt|;
block|{
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !F_FREESP */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !F_CHSIZE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_FTRUNCATE */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|msg_file
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VPRINTF
argument_list|)
operator|&&
name|__STDC__
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_function
name|void
name|msg
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|msg_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|tar
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_sayblock
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rec %ld: "
argument_list|,
name|baserec
operator|+
operator|(
name|ar_record
operator|-
name|ar_block
operator|)
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|str
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|msg_perror
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|int
name|save_e
decl_stmt|;
name|save_e
operator|=
name|errno
expr_stmt|;
name|fflush
argument_list|(
name|msg_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|tar
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_sayblock
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rec %ld: "
argument_list|,
name|baserec
operator|+
operator|(
name|ar_record
operator|-
name|ar_block
operator|)
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|str
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_e
expr_stmt|;
name|perror
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_VPRINTF and __STDC__ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_VPRINTF
argument_list|)
operator|&&
operator|!
name|__STDC__
end_if

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_function
name|void
name|msg
parameter_list|(
name|str
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|fflush
argument_list|(
name|msg_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|tar
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_sayblock
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rec %d: "
argument_list|,
name|baserec
operator|+
operator|(
name|ar_record
operator|-
name|ar_block
operator|)
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|str
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|msg_perror
parameter_list|(
name|str
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
function|va_dcl
block|{
name|va_list
name|args
decl_stmt|;
name|int
name|save_e
decl_stmt|;
name|save_e
operator|=
name|errno
expr_stmt|;
name|fflush
argument_list|(
name|msg_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|tar
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_sayblock
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rec %d: "
argument_list|,
name|baserec
operator|+
operator|(
name|ar_record
operator|-
name|ar_block
operator|)
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|str
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_e
expr_stmt|;
name|perror
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_VPRINTF and not __STDC__ */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_VPRINTF
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_DOPRNT
argument_list|)
end_if

begin_function
name|void
name|msg
parameter_list|(
name|str
parameter_list|,
name|args
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|args
decl_stmt|;
block|{
name|fflush
argument_list|(
name|msg_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|tar
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_sayblock
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rec %d: "
argument_list|,
name|baserec
operator|+
operator|(
name|ar_record
operator|-
name|ar_block
operator|)
argument_list|)
expr_stmt|;
name|_doprnt
argument_list|(
name|str
argument_list|,
operator|&
name|args
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|msg_perror
parameter_list|(
name|str
parameter_list|,
name|args
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|args
decl_stmt|;
block|{
name|int
name|save_e
decl_stmt|;
name|save_e
operator|=
name|errno
expr_stmt|;
name|fflush
argument_list|(
name|msg_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|tar
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_sayblock
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rec %d: "
argument_list|,
name|baserec
operator|+
operator|(
name|ar_record
operator|-
name|ar_block
operator|)
argument_list|)
expr_stmt|;
name|_doprnt
argument_list|(
name|str
argument_list|,
operator|&
name|args
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_e
expr_stmt|;
name|perror
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_VPRINTF and HAVE_DOPRNT */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_VPRINTF
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_DOPRNT
argument_list|)
end_if

begin_function
name|void
name|msg
parameter_list|(
name|str
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|,
name|a3
parameter_list|,
name|a4
parameter_list|,
name|a5
parameter_list|,
name|a6
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|fflush
argument_list|(
name|msg_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|tar
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_sayblock
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rec %d: "
argument_list|,
name|baserec
operator|+
operator|(
name|ar_record
operator|-
name|ar_block
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|str
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|msg_perror
parameter_list|(
name|str
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|,
name|a3
parameter_list|,
name|a4
parameter_list|,
name|a5
parameter_list|,
name|a6
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|save_e
decl_stmt|;
name|save_e
operator|=
name|errno
expr_stmt|;
name|fflush
argument_list|(
name|msg_file
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|tar
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_sayblock
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rec %d: "
argument_list|,
name|baserec
operator|+
operator|(
name|ar_record
operator|-
name|ar_block
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|str
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_e
expr_stmt|;
name|perror
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_VPRINTF and !HAVE_DOPRNT */
end_comment

end_unit

