begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Tar -- a tape archiver.    Copyright (C) 1988, 1992, 1993 Free Software Foundation  This file is part of GNU Tar.  GNU Tar is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Tar is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Tar; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*  * A tar (tape archiver) program.  *  * Written by John Gilmore, ihnp4!hoptoad!gnu, starting 25 Aug 85.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* Needed for typedefs in tar.h */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_comment
comment|/*  * The following causes "tar.h" to produce definitions of all the  * global variables, rather than just "extern" declarations of them.  */
end_comment

begin_define
define|#
directive|define
name|TAR_EXTERN
end_define

begin_comment
comment|/**/
end_comment

begin_include
include|#
directive|include
file|"tar.h"
end_include

begin_include
include|#
directive|include
file|"port.h"
end_include

begin_include
include|#
directive|include
file|"gnuregex.h"
end_include

begin_include
include|#
directive|include
file|<fnmatch.h>
end_include

begin_comment
comment|/*  * We should use a conversion routine that does reasonable error  * checking -- atoi doesn't.  For now, punt.  FIXME.  */
end_comment

begin_define
define|#
directive|define
name|intconv
value|atoi
end_define

begin_function_decl
name|PTR
name|ck_malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|PTR
name|ck_realloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|getoldopt
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|read_and
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|list_archive
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|extract_archive
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|diff_archive
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|create_archive
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|update_archive
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|junk_archive
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|init_volume_number
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|closeout_volume_number
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* JF */
end_comment

begin_function_decl
specifier|extern
name|time_t
name|get_date
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|time_t
name|new_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|namef
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File to read names from */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|n_argv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Argv used by name routines */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_argc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Argc used by name routines */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|n_ind
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Store an array of names */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_indalloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How big is the array? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_indused
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many entries does it have? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_indscan
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many of the entries have we scanned? */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|msg_file
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|check_exclude
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|add_exclude
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|add_exclude_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|addname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|describe
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|diff_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|extr_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|is_regex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|name_add
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|name_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|options
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|un_quote_string
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|nlpsfreed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISLNK
end_ifndef

begin_define
define|#
directive|define
name|lstat
value|stat
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEFBLOCKING
end_ifndef

begin_define
define|#
directive|define
name|DEFBLOCKING
value|20
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEF_AR_FILE
end_ifndef

begin_define
define|#
directive|define
name|DEF_AR_FILE
value|"tar.out"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For long options that unconditionally set a single flag, we have getopt    do it.  For the others, we share the code for the equivalent short    named option, the name of which is stored in the otherwise-unused `val'    field of the `struct option'; for long options that have no equivalent    short option, we use nongraphic characters as pseudo short option    characters, starting (for no particular reason) with character 10. */
end_comment

begin_decl_stmt
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"create"
block|,
literal|0
block|,
literal|0
block|,
literal|'c'
block|}
block|,
block|{
literal|"append"
block|,
literal|0
block|,
literal|0
block|,
literal|'r'
block|}
block|,
block|{
literal|"extract"
block|,
literal|0
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"get"
block|,
literal|0
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"list"
block|,
literal|0
block|,
literal|0
block|,
literal|'t'
block|}
block|,
block|{
literal|"update"
block|,
literal|0
block|,
literal|0
block|,
literal|'u'
block|}
block|,
block|{
literal|"catenate"
block|,
literal|0
block|,
literal|0
block|,
literal|'A'
block|}
block|,
block|{
literal|"concatenate"
block|,
literal|0
block|,
literal|0
block|,
literal|'A'
block|}
block|,
block|{
literal|"compare"
block|,
literal|0
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"diff"
block|,
literal|0
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"delete"
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|}
block|,
block|{
literal|"help"
block|,
literal|0
block|,
literal|0
block|,
literal|12
block|}
block|,
block|{
literal|"null"
block|,
literal|0
block|,
literal|0
block|,
literal|16
block|}
block|,
block|{
literal|"directory"
block|,
literal|1
block|,
literal|0
block|,
literal|'C'
block|}
block|,
block|{
literal|"record-number"
block|,
literal|0
block|,
operator|&
name|f_sayblock
block|,
literal|1
block|}
block|,
block|{
literal|"files-from"
block|,
literal|1
block|,
literal|0
block|,
literal|'T'
block|}
block|,
block|{
literal|"label"
block|,
literal|1
block|,
literal|0
block|,
literal|'V'
block|}
block|,
block|{
literal|"exclude-from"
block|,
literal|1
block|,
literal|0
block|,
literal|'X'
block|}
block|,
block|{
literal|"exclude"
block|,
literal|1
block|,
literal|0
block|,
literal|15
block|}
block|,
block|{
literal|"file"
block|,
literal|1
block|,
literal|0
block|,
literal|'f'
block|}
block|,
block|{
literal|"block-size"
block|,
literal|1
block|,
literal|0
block|,
literal|'b'
block|}
block|,
block|{
literal|"version"
block|,
literal|0
block|,
literal|0
block|,
literal|11
block|}
block|,
block|{
literal|"verbose"
block|,
literal|0
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"totals"
block|,
literal|0
block|,
operator|&
name|f_totals
block|,
literal|1
block|}
block|,
block|{
literal|"read-full-blocks"
block|,
literal|0
block|,
operator|&
name|f_reblock
block|,
literal|1
block|}
block|,
block|{
literal|"starting-file"
block|,
literal|1
block|,
literal|0
block|,
literal|'K'
block|}
block|,
block|{
literal|"to-stdout"
block|,
literal|0
block|,
operator|&
name|f_exstdout
block|,
literal|1
block|}
block|,
block|{
literal|"ignore-zeros"
block|,
literal|0
block|,
operator|&
name|f_ignorez
block|,
literal|1
block|}
block|,
block|{
literal|"keep-old-files"
block|,
literal|0
block|,
literal|0
block|,
literal|'k'
block|}
block|,
block|{
literal|"same-permissions"
block|,
literal|0
block|,
operator|&
name|f_use_protection
block|,
literal|1
block|}
block|,
block|{
literal|"preserve-permissions"
block|,
literal|0
block|,
operator|&
name|f_use_protection
block|,
literal|1
block|}
block|,
block|{
literal|"modification-time"
block|,
literal|0
block|,
operator|&
name|f_modified
block|,
literal|1
block|}
block|,
block|{
literal|"preserve"
block|,
literal|0
block|,
literal|0
block|,
literal|10
block|}
block|,
block|{
literal|"same-order"
block|,
literal|0
block|,
operator|&
name|f_sorted_names
block|,
literal|1
block|}
block|,
block|{
literal|"same-owner"
block|,
literal|0
block|,
operator|&
name|f_do_chown
block|,
literal|1
block|}
block|,
block|{
literal|"preserve-order"
block|,
literal|0
block|,
operator|&
name|f_sorted_names
block|,
literal|1
block|}
block|,
block|{
literal|"newer"
block|,
literal|1
block|,
literal|0
block|,
literal|'N'
block|}
block|,
block|{
literal|"after-date"
block|,
literal|1
block|,
literal|0
block|,
literal|'N'
block|}
block|,
block|{
literal|"newer-mtime"
block|,
literal|1
block|,
literal|0
block|,
literal|13
block|}
block|,
block|{
literal|"incremental"
block|,
literal|0
block|,
literal|0
block|,
literal|'G'
block|}
block|,
block|{
literal|"listed-incremental"
block|,
literal|1
block|,
literal|0
block|,
literal|'g'
block|}
block|,
block|{
literal|"multi-volume"
block|,
literal|0
block|,
operator|&
name|f_multivol
block|,
literal|1
block|}
block|,
block|{
literal|"info-script"
block|,
literal|1
block|,
literal|0
block|,
literal|'F'
block|}
block|,
block|{
literal|"new-volume-script"
block|,
literal|1
block|,
literal|0
block|,
literal|'F'
block|}
block|,
block|{
literal|"absolute-paths"
block|,
literal|0
block|,
operator|&
name|f_absolute_paths
block|,
literal|1
block|}
block|,
block|{
literal|"interactive"
block|,
literal|0
block|,
operator|&
name|f_confirm
block|,
literal|1
block|}
block|,
block|{
literal|"confirmation"
block|,
literal|0
block|,
operator|&
name|f_confirm
block|,
literal|1
block|}
block|,
block|{
literal|"verify"
block|,
literal|0
block|,
operator|&
name|f_verify
block|,
literal|1
block|}
block|,
block|{
literal|"dereference"
block|,
literal|0
block|,
operator|&
name|f_follow_links
block|,
literal|1
block|}
block|,
block|{
literal|"one-file-system"
block|,
literal|0
block|,
operator|&
name|f_local_filesys
block|,
literal|1
block|}
block|,
block|{
literal|"old-archive"
block|,
literal|0
block|,
literal|0
block|,
literal|'o'
block|}
block|,
block|{
literal|"portability"
block|,
literal|0
block|,
literal|0
block|,
literal|'o'
block|}
block|,
block|{
literal|"compress"
block|,
literal|0
block|,
literal|0
block|,
literal|'Z'
block|}
block|,
block|{
literal|"uncompress"
block|,
literal|0
block|,
literal|0
block|,
literal|'Z'
block|}
block|,
block|{
literal|"block-compress"
block|,
literal|0
block|,
operator|&
name|f_compress_block
block|,
literal|1
block|}
block|,
block|{
literal|"gzip"
block|,
literal|0
block|,
literal|0
block|,
literal|'z'
block|}
block|,
block|{
literal|"ungzip"
block|,
literal|0
block|,
literal|0
block|,
literal|'z'
block|}
block|,
block|{
literal|"use-compress-program"
block|,
literal|1
block|,
literal|0
block|,
literal|18
block|}
block|,
block|{
literal|"same-permissions"
block|,
literal|0
block|,
operator|&
name|f_use_protection
block|,
literal|1
block|}
block|,
block|{
literal|"sparse"
block|,
literal|0
block|,
operator|&
name|f_sparse_files
block|,
literal|1
block|}
block|,
block|{
literal|"tape-length"
block|,
literal|1
block|,
literal|0
block|,
literal|'L'
block|}
block|,
block|{
literal|"remove-files"
block|,
literal|0
block|,
operator|&
name|f_remove_files
block|,
literal|1
block|}
block|,
block|{
literal|"ignore-failed-read"
block|,
literal|0
block|,
operator|&
name|f_ignore_failed_read
block|,
literal|1
block|}
block|,
block|{
literal|"checkpoint"
block|,
literal|0
block|,
operator|&
name|f_checkpoint
block|,
literal|1
block|}
block|,
block|{
literal|"show-omitted-dirs"
block|,
literal|0
block|,
operator|&
name|f_show_omitted_dirs
block|,
literal|1
block|}
block|,
block|{
literal|"volno-file"
block|,
literal|1
block|,
literal|0
block|,
literal|17
block|}
block|,
block|{
literal|"force-local"
block|,
literal|0
block|,
operator|&
name|f_force_local
block|,
literal|1
block|}
block|,
block|{
literal|"atime-preserve"
block|,
literal|0
block|,
operator|&
name|f_atime_preserve
block|,
literal|1
block|}
block|,
block|{
literal|"unlink"
block|,
literal|0
block|,
operator|&
name|f_unlink
block|,
literal|1
block|}
block|,
block|{
literal|"fast-read"
block|,
literal|0
block|,
operator|&
name|f_fast_read
block|,
literal|1
block|}
block|,
block|{
literal|"norecurse"
block|,
literal|0
block|,
literal|0
block|,
literal|'n'
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Main routine for tar.  */
end_comment

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|extern
name|char
name|version_string
index|[]
decl_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tar
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* JF: was "tar" Set program name */
name|filename_terminator
operator|=
literal|'\n'
expr_stmt|;
name|errors
operator|=
literal|0
expr_stmt|;
name|options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n_argv
condition|)
name|name_init
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_volno_file
condition|)
name|init_volume_number
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd_mode
condition|)
block|{
case|case
name|CMD_CAT
case|:
case|case
name|CMD_UPDATE
case|:
case|case
name|CMD_APPEND
case|:
name|update_archive
argument_list|()
expr_stmt|;
break|break;
case|case
name|CMD_DELETE
case|:
name|junk_archive
argument_list|()
expr_stmt|;
break|break;
case|case
name|CMD_CREATE
case|:
name|create_archive
argument_list|()
expr_stmt|;
if|if
condition|(
name|f_totals
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total bytes written: %d\n"
argument_list|,
name|tot_written
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_EXTRACT
case|:
if|if
condition|(
name|f_volhdr
condition|)
block|{
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|label_pattern
operator|=
operator|(
expr|struct
name|re_pattern_buffer
operator|*
operator|)
name|ck_malloc
argument_list|(
sizeof|sizeof
expr|*
name|label_pattern
argument_list|)
expr_stmt|;
name|err
operator|=
name|re_compile_pattern
argument_list|(
name|f_volhdr
argument_list|,
name|strlen
argument_list|(
name|f_volhdr
argument_list|)
argument_list|,
name|label_pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad regular expression: %s\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|extr_init
argument_list|()
expr_stmt|;
name|read_and
argument_list|(
name|extract_archive
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_LIST
case|:
if|if
condition|(
name|f_volhdr
condition|)
block|{
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|label_pattern
operator|=
operator|(
expr|struct
name|re_pattern_buffer
operator|*
operator|)
name|ck_malloc
argument_list|(
sizeof|sizeof
expr|*
name|label_pattern
argument_list|)
expr_stmt|;
name|err
operator|=
name|re_compile_pattern
argument_list|(
name|f_volhdr
argument_list|,
name|strlen
argument_list|(
name|f_volhdr
argument_list|)
argument_list|,
name|label_pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad regular expression: %s\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|read_and
argument_list|(
name|list_archive
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (!errors) 	errors = different;
endif|#
directive|endif
break|break;
case|case
name|CMD_DIFF
case|:
name|diff_init
argument_list|()
expr_stmt|;
name|read_and
argument_list|(
name|diff_archive
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_VERSION
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_NONE
case|:
name|msg
argument_list|(
literal|"you must specify exactly one of the r, c, t, x, or d options\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"For more information, type ``%s --help''.\n"
argument_list|,
name|tar
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f_volno_file
condition|)
name|closeout_volume_number
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|errors
condition|?
name|EX_ARGSBAD
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME (should be EX_NONDESCRIPT) */
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Parse the options for tar.  */
end_comment

begin_function
name|void
name|options
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
comment|/* Option letter */
name|int
name|ind
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Set default option values */
name|blocking
operator|=
name|DEFBLOCKING
expr_stmt|;
comment|/* From Makefile */
name|ar_files
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ck_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
literal|10
argument_list|)
expr_stmt|;
name|ar_files_len
operator|=
literal|10
expr_stmt|;
name|n_ar_files
operator|=
literal|0
expr_stmt|;
name|cur_ar_file
operator|=
literal|0
expr_stmt|;
comment|/* Parse options */
while|while
condition|(
operator|(
name|c
operator|=
name|getoldopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"-01234567Ab:BcC:df:F:g:GhikK:lL:mMnN:oOpPrRsStT:uvV:wWxX:zZ"
argument_list|,
name|long_options
argument_list|,
operator|&
name|ind
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
comment|/* long options that set a single flag */
break|break;
case|case
literal|1
case|:
comment|/* File name or non-parsed option */
name|name_add
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|name_add
argument_list|(
literal|"-C"
argument_list|)
expr_stmt|;
name|name_add
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
comment|/* preserve */
name|f_use_protection
operator|=
name|f_sorted_names
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|11
case|:
if|if
condition|(
name|cmd_mode
operator|!=
name|CMD_NONE
condition|)
goto|goto
name|badopt
goto|;
name|cmd_mode
operator|=
name|CMD_VERSION
expr_stmt|;
break|break;
case|case
literal|12
case|:
comment|/* help */
name|printf
argument_list|(
literal|"This is GNU tar, the tape archiving program.\n"
argument_list|)
expr_stmt|;
name|describe
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
literal|13
case|:
name|f_new_files
operator|++
expr_stmt|;
goto|goto
name|get_newer
goto|;
case|case
literal|14
case|:
comment|/* Delete in the archive */
if|if
condition|(
name|cmd_mode
operator|!=
name|CMD_NONE
condition|)
goto|goto
name|badopt
goto|;
name|cmd_mode
operator|=
name|CMD_DELETE
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|f_exclude
operator|++
expr_stmt|;
name|add_exclude
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
comment|/* -T reads null terminated filenames. */
name|filename_terminator
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|17
case|:
name|f_volno_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|18
case|:
if|if
condition|(
name|f_compressprog
condition|)
block|{
name|msg
argument_list|(
literal|"Only one compression option permitted\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
name|f_compressprog
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* We are making a GNU dump; save 				   directories at the beginning of 				   the archive, and include in each 				   directory its contents */
if|if
condition|(
name|f_oldarch
condition|)
goto|goto
name|badopt
goto|;
name|f_gnudump
operator|++
expr_stmt|;
name|gnu_dumpfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
block|{
comment|/* JF this'll have to be modified for other 				   systems, of course! */
name|int
name|d
decl_stmt|,
name|add
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|d
operator|=
name|getoldopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"lmh"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAYBEDEF
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"/dev/rmt/%d%c"
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|LOW_NUM
define|#
directive|define
name|LOW_NUM
value|0
define|#
directive|define
name|MID_NUM
value|8
define|#
directive|define
name|HGH_NUM
value|16
endif|#
directive|endif
if|if
condition|(
name|d
operator|==
literal|'l'
condition|)
name|add
operator|=
name|LOW_NUM
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|==
literal|'m'
condition|)
name|add
operator|=
name|MID_NUM
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|==
literal|'h'
condition|)
name|add
operator|=
name|HGH_NUM
expr_stmt|;
else|else
goto|goto
name|badopt
goto|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"/dev/rmt%d"
argument_list|,
name|add
operator|+
name|c
operator|-
literal|'0'
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|n_ar_files
operator|==
name|ar_files_len
condition|)
name|ar_files
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ck_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|ar_files_len
operator|*=
literal|2
operator|)
argument_list|)
expr_stmt|;
name|ar_files
index|[
name|n_ar_files
operator|++
index|]
operator|=
name|buf
expr_stmt|;
block|}
break|break;
case|case
literal|'A'
case|:
comment|/* Arguments are tar files, 				   just cat them onto the end 				   of the archive.  */
if|if
condition|(
name|cmd_mode
operator|!=
name|CMD_NONE
condition|)
goto|goto
name|badopt
goto|;
name|cmd_mode
operator|=
name|CMD_CAT
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* Set blocking factor */
name|blocking
operator|=
name|intconv
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* Try to reblock input */
name|f_reblock
operator|++
expr_stmt|;
comment|/* For reading 4.2BSD pipes */
break|break;
case|case
literal|'c'
case|:
comment|/* Create an archive */
if|if
condition|(
name|cmd_mode
operator|!=
name|CMD_NONE
condition|)
goto|goto
name|badopt
goto|;
name|cmd_mode
operator|=
name|CMD_CREATE
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case 'C': 	  if (chdir (optarg)< 0) 	    msg_perror ("Can't change directory to %d", optarg); 	  break;
endif|#
directive|endif
case|case
literal|'d'
case|:
comment|/* Find difference tape/disk */
if|if
condition|(
name|cmd_mode
operator|!=
name|CMD_NONE
condition|)
goto|goto
name|badopt
goto|;
name|cmd_mode
operator|=
name|CMD_DIFF
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Use ar_file for the archive */
if|if
condition|(
name|n_ar_files
operator|==
name|ar_files_len
condition|)
name|ar_files
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|ck_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|ar_files_len
operator|*=
literal|2
operator|)
argument_list|)
expr_stmt|;
name|ar_files
index|[
name|n_ar_files
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* Since -F is only useful with -M , make it implied */
name|f_run_script_at_end
operator|++
expr_stmt|;
comment|/* run this script at the end */
name|info_script
operator|=
name|optarg
expr_stmt|;
comment|/* of each tape */
name|f_multivol
operator|++
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
comment|/* We are making a GNU dump; save 				   directories at the beginning of 				   the archive, and include in each 				   directory its contents */
if|if
condition|(
name|f_oldarch
condition|)
goto|goto
name|badopt
goto|;
name|f_gnudump
operator|++
expr_stmt|;
name|gnu_dumpfile
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|f_follow_links
operator|++
expr_stmt|;
comment|/* follow symbolic links */
break|break;
case|case
literal|'i'
case|:
name|f_ignorez
operator|++
expr_stmt|;
comment|/* Ignore zero records (eofs) */
comment|/* 			 * This can't be the default, because Unix tar 			 * writes two records of zeros, then pads out the 			 * block with garbage. 			 */
break|break;
case|case
literal|'k'
case|:
comment|/* Don't overwrite files */
ifdef|#
directive|ifdef
name|NO_OPEN3
name|msg
argument_list|(
literal|"can't keep old files on this system"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
else|#
directive|else
name|f_keep
operator|++
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'K'
case|:
name|f_startfile
operator|++
expr_stmt|;
name|addname
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* When dumping directories, don't 				   dump files/subdirectories that are 				   on other filesystems. */
name|f_local_filesys
operator|++
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|tape_length
operator|=
name|intconv
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|f_multivol
operator|++
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|f_modified
operator|++
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* Make Multivolume archive: 				   When we can't write any more 				   into the archive, re-open it, 				   and continue writing */
name|f_multivol
operator|++
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* don't recurse into subdirectories */
if|if
condition|(
name|f_oldarch
condition|)
goto|goto
name|badopt
goto|;
name|f_dironly
operator|++
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* Only write files newer than X */
name|get_newer
label|:
name|f_new_files
operator|++
expr_stmt|;
name|new_time
operator|=
name|get_date
argument_list|(
name|optarg
argument_list|,
operator|(
name|PTR
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_time
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
block|{
name|msg
argument_list|(
literal|"invalid date format `%s'"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'o'
case|:
comment|/* Generate old archive */
if|if
condition|(
name|f_gnudump
operator|||
name|f_dironly
condition|)
goto|goto
name|badopt
goto|;
name|f_oldarch
operator|++
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|f_exstdout
operator|++
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|f_use_protection
operator|++
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|f_absolute_paths
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Append files to the archive */
if|if
condition|(
name|cmd_mode
operator|!=
name|CMD_NONE
condition|)
goto|goto
name|badopt
goto|;
name|cmd_mode
operator|=
name|CMD_APPEND
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|f_sayblock
operator|++
expr_stmt|;
comment|/* Print block #s for debug */
break|break;
comment|/* of bad tar archives */
case|case
literal|'s'
case|:
name|f_sorted_names
operator|++
expr_stmt|;
comment|/* Names to extr are sorted */
break|break;
case|case
literal|'S'
case|:
comment|/* deal with sparse files */
name|f_sparse_files
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|cmd_mode
operator|!=
name|CMD_NONE
condition|)
goto|goto
name|badopt
goto|;
name|cmd_mode
operator|=
name|CMD_LIST
expr_stmt|;
name|f_verbose
operator|++
expr_stmt|;
comment|/* "t" output == "cv" or "xv" */
break|break;
case|case
literal|'T'
case|:
name|name_file
operator|=
name|optarg
expr_stmt|;
name|f_namefile
operator|++
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Append files to the archive that 				   aren't there, or are newer than the 				   copy in the archive */
if|if
condition|(
name|cmd_mode
operator|!=
name|CMD_NONE
condition|)
goto|goto
name|badopt
goto|;
name|cmd_mode
operator|=
name|CMD_UPDATE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|f_verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|f_volhdr
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|f_confirm
operator|++
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|f_verify
operator|++
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* Extract files from the archive */
if|if
condition|(
name|cmd_mode
operator|!=
name|CMD_NONE
condition|)
goto|goto
name|badopt
goto|;
name|cmd_mode
operator|=
name|CMD_EXTRACT
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|f_exclude
operator|++
expr_stmt|;
name|add_exclude_file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
if|if
condition|(
name|f_compressprog
condition|)
block|{
name|msg
argument_list|(
literal|"Only one compression option permitted\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
name|f_compressprog
operator|=
literal|"gzip"
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
if|if
condition|(
name|f_compressprog
condition|)
block|{
name|msg
argument_list|(
literal|"Only one compression option permitted\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
name|f_compressprog
operator|=
literal|"compress"
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|badopt
label|:
name|msg
argument_list|(
literal|"Unknown option.  Use '%s --help' for a complete list of options."
argument_list|,
name|tar
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
block|}
name|blocksize
operator|=
name|blocking
operator|*
name|RECORDSIZE
expr_stmt|;
if|if
condition|(
name|n_ar_files
operator|==
literal|0
condition|)
block|{
name|n_ar_files
operator|=
literal|1
expr_stmt|;
name|ar_files
index|[
literal|0
index|]
operator|=
name|getenv
argument_list|(
literal|"TAPE"
argument_list|)
expr_stmt|;
comment|/* From environment, or */
if|if
condition|(
name|ar_files
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|ar_files
index|[
literal|0
index|]
operator|=
name|DEF_AR_FILE
expr_stmt|;
comment|/* From Makefile */
block|}
if|if
condition|(
name|n_ar_files
operator|>
literal|1
operator|&&
operator|!
name|f_multivol
condition|)
block|{
name|msg
argument_list|(
literal|"Multiple archive files requires --multi-volume\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f_compress_block
operator|&&
operator|!
name|f_compressprog
condition|)
block|{
name|msg
argument_list|(
literal|"You must use a compression option (--gzip, --compress\n\ or --use-compress-program) with --block-compress.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print as much help as the user's gonna get.  *  * We have to sprinkle in the KLUDGE lines because too many compilers  * cannot handle character strings longer than about 512 bytes.  Yuk!  * In particular, MS-DOS and Xenix MSC and PDP-11 V7 Unix have this  * problem.  */
end_comment

begin_function
name|void
name|describe
parameter_list|()
block|{
name|puts
argument_list|(
literal|"choose one of the following:"
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\ -A, --catenate,\n\     --concatenate	append tar files to an archive\n\ -c, --create		create a new archive\n\ -d, --diff,\n\     --compare		find differences between archive and file system\n\ --delete		delete from the archive (not for use on mag tapes!)\n\ -r, --append		append files to the end of an archive\n\ -t, --list		list the contents of an archive\n\ -u, --update		only append files that are newer than copy in archive\n\ -x, --extract,\n\     --get		extract files from an archive\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\ Other options:\n\ --atime-preserve	don't change access times on dumped files\n\ -b, --block-size N	block size of Nx512 bytes (default N=%d)\n"
argument_list|,
name|DEFBLOCKING
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\ -B, --read-full-blocks	reblock as we read (for reading 4.2BSD pipes)\n\ -C, --directory DIR	change to directory DIR\n\ --checkpoint		print directory names while reading the archive\n\ "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* KLUDGE */
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\ -f, --file [HOSTNAME:]F	use archive file or device F (default %s)\n"
argument_list|,
name|DEF_AR_FILE
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\ --force-local		archive file is local even if has a colon\n\ -F, --info-script F\n\     --new-volume-script F run script at end of each tape (implies -M)\n\ -G, --incremental	create/list/extract old GNU-format incremental backup\n\ -g, --listed-incremental F create/list/extract new GNU-format incremental backup\n\ -h, --dereference	don't dump symlinks; dump the files they point to\n\ -i, --ignore-zeros	ignore blocks of zeros in archive (normally mean EOF)\n\ --ignore-failed-read	don't exit with non-zero status on unreadable files\n\ -k, --keep-old-files	keep existing files; don't overwrite them from archive\n\ -K, --starting-file F	begin at file F in the archive\n\ -l, --one-file-system	stay in local file system when creating an archive\n\ -L, --tape-length N	change tapes after writing N*1024 bytes\n\ "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* KLUDGE */
name|fputs
argument_list|(
literal|"\ -m, --modification-time	don't extract file modified time\n\ -M, --multi-volume	create/list/extract multi-volume archive\n\ -n, --norecurse		don't recurse into subdircectories\n\ -N, --after-date DATE,\n\     --newer DATE	only store files newer than DATE\n\ -o, --old-archive,\n\     --portability	write a V7 format archive, rather than ANSI format\n\ -O, --to-stdout		extract files to standard output\n\ -p, --same-permissions,\n\     --preserve-permissions extract all protection information\n\ -P, --absolute-paths	don't strip leading `/'s from file names\n\ --preserve		like -p -s\n\ "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* KLUDGE */
name|fputs
argument_list|(
literal|"\ -R, --record-number	show record number within archive with each message\n\ --remove-files		remove files after adding them to the archive\n\ -s, --same-order,\n\     --preserve-order	list of names to extract is sorted to match archive\n\ --same-owner		create extracted files with the same ownership \n\ -S, --sparse		handle sparse files efficiently\n\ -T, --files-from F	get names to extract or create from file F\n\ --null			-T reads null-terminated names, disable -C\n\ --totals		print total bytes written with --create\n\ -v, --verbose		verbosely list files processed\n\ -V, --label NAME	create archive with volume name NAME\n\ --version		print tar program version number\n\ -w, --interactive,\n\     --confirmation	ask for confirmation for every action\n\ "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* KLUDGE */
name|fputs
argument_list|(
literal|"\ -W, --verify		attempt to verify the archive after writing it\n\ --exclude FILE		exclude file FILE\n\ -X, --exclude-from FILE	exclude files listed in FILE\n\ -Z, --compress,\n\     --uncompress      	filter the archive through compress\n\ -z, --gzip,\n\     --ungzip		filter the archive through gzip\n\ --use-compress-program PROG\n\ 			filter the archive through PROG (which must accept -d)\n\ --block-compress	block the output of compression program for tapes\n\ -[0-7][lmh]		specify drive and density\n\ --unlink		unlink files before creating them\n\ --fast-read 		stop after desired names in archive have been found\n\ "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|name_add
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|n_indalloc
operator|==
name|n_indused
condition|)
block|{
name|n_indalloc
operator|+=
literal|10
expr_stmt|;
name|n_ind
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|n_indused
condition|?
name|ck_realloc
argument_list|(
name|n_ind
argument_list|,
name|n_indalloc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
else|:
name|ck_malloc
argument_list|(
name|n_indalloc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|n_ind
index|[
name|n_indused
operator|++
index|]
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up to gather file names for tar.  *  * They can either come from stdin or from argv.  */
end_comment

begin_function
name|void
name|name_init
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
if|if
condition|(
name|f_namefile
condition|)
block|{
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|msg
argument_list|(
literal|"too many args with -T option"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name_file
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|namef
operator|=
name|stdin
expr_stmt|;
block|}
else|else
block|{
name|namef
operator|=
name|fopen
argument_list|(
name|name_file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|namef
operator|==
name|NULL
condition|)
block|{
name|msg_perror
argument_list|(
literal|"can't open file %s"
argument_list|,
name|name_file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_BADFILE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Get file names from argv, after options. */
name|n_argc
operator|=
name|argc
expr_stmt|;
name|n_argv
operator|=
name|argv
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read the next filename read from STREAM and null-terminate it.    Put it into BUFFER, reallocating and adjusting *PBUFFER_SIZE if necessary.    Return the new value for BUFFER, or NULL at end of file. */
end_comment

begin_function
name|char
modifier|*
name|read_name_from_file
parameter_list|(
name|buffer
parameter_list|,
name|pbuffer_size
parameter_list|,
name|stream
parameter_list|)
name|char
modifier|*
name|buffer
decl_stmt|;
name|size_t
modifier|*
name|pbuffer_size
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|indx
init|=
literal|0
decl_stmt|;
specifier|register
name|size_t
name|buffer_size
init|=
operator|*
name|pbuffer_size
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
name|filename_terminator
condition|)
block|{
if|if
condition|(
name|indx
operator|==
name|buffer_size
condition|)
block|{
name|buffer_size
operator|+=
name|NAMSIZ
expr_stmt|;
name|buffer
operator|=
name|ck_realloc
argument_list|(
name|buffer
argument_list|,
name|buffer_size
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|buffer
index|[
name|indx
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|indx
operator|==
literal|0
operator|&&
name|c
operator|==
name|EOF
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|indx
operator|==
name|buffer_size
condition|)
block|{
name|buffer_size
operator|+=
name|NAMSIZ
expr_stmt|;
name|buffer
operator|=
name|ck_realloc
argument_list|(
name|buffer
argument_list|,
name|buffer_size
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|buffer
index|[
name|indx
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|pbuffer_size
operator|=
name|buffer_size
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/*  * Get the next name from argv or the name file.  *  * Result is in static storage and can't be relied upon across two calls.  *  * If CHANGE_DIRS is non-zero, treat a filename of the form "-C" as  * meaning that the next filename is the name of a directory to change to.  * If `filename_terminator' is '\0', CHANGE_DIRS is effectively always 0.  */
end_comment

begin_function
name|char
modifier|*
name|name_next
parameter_list|(
name|change_dirs
parameter_list|)
name|int
name|change_dirs
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* Holding pattern */
specifier|static
name|int
name|buffer_siz
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|next_name_is_dir
init|=
literal|0
decl_stmt|;
specifier|extern
name|char
modifier|*
name|un_quote_string
parameter_list|()
function_decl|;
if|if
condition|(
name|buffer_siz
operator|==
literal|0
condition|)
block|{
name|buffer
operator|=
name|ck_malloc
argument_list|(
name|NAMSIZ
operator|+
literal|2
argument_list|)
expr_stmt|;
name|buffer_siz
operator|=
name|NAMSIZ
expr_stmt|;
block|}
if|if
condition|(
name|filename_terminator
operator|==
literal|'\0'
condition|)
name|change_dirs
operator|=
literal|0
expr_stmt|;
name|tryagain
label|:
if|if
condition|(
name|namef
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|n_indscan
operator|<
name|n_indused
condition|)
name|p
operator|=
name|n_ind
index|[
name|n_indscan
operator|++
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|optind
operator|<
name|n_argc
condition|)
comment|/* Names come from argv, after options */
name|p
operator|=
name|n_argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
name|q
condition|)
name|msg
argument_list|(
literal|"Missing filename after -C"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* JF trivial support for -C option.  I don't know if 		   chdir'ing at this point is dangerous or not. 		   It seems to work, which is all I ask. */
if|if
condition|(
name|change_dirs
operator|&&
operator|!
name|q
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'C'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|q
operator|=
name|p
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
if|if
condition|(
name|q
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
name|msg_perror
argument_list|(
literal|"Can't chdir to %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|q
operator|=
literal|0
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
comment|/* End of JF quick -C hack */
if|#
directive|if
literal|0
block|if (f_exclude&& check_exclude (p)) 	goto tryagain;
endif|#
directive|endif
return|return
name|un_quote_string
argument_list|(
name|p
argument_list|)
return|;
block|}
while|while
condition|(
name|p
operator|=
name|read_name_from_file
argument_list|(
name|buffer
argument_list|,
operator|&
name|buffer_siz
argument_list|,
name|namef
argument_list|)
condition|)
block|{
name|buffer
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* Ignore empty lines. */
name|q
operator|=
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|q
operator|>
name|p
operator|&&
operator|*
name|q
operator|==
literal|'/'
condition|)
comment|/* Zap trailing "/"s. */
operator|*
name|q
operator|--
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|change_dirs
operator|&&
name|next_name_is_dir
operator|==
literal|0
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'C'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|next_name_is_dir
operator|=
literal|1
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
if|if
condition|(
name|next_name_is_dir
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
name|msg_perror
argument_list|(
literal|"Can't change to directory %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|next_name_is_dir
operator|=
literal|0
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
if|#
directive|if
literal|0
block|if (f_exclude&& check_exclude (p)) 	goto tryagain;
endif|#
directive|endif
return|return
name|un_quote_string
argument_list|(
name|p
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Close the name file, if any.  */
end_comment

begin_function
name|void
name|name_close
parameter_list|()
block|{
if|if
condition|(
name|namef
operator|!=
name|NULL
operator|&&
name|namef
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|namef
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Gather names in a list for scanning.  * Could hash them later if we really care.  *  * If the names are already sorted to match the archive, we just  * read them one by one.  name_gather reads the first one, and it  * is called by name_match as appropriate to read the next ones.  * At EOF, the last name read is just left in the buffer.  * This option lets users of small machines extract an arbitrary  * number of files by doing "tar t" and editing down the list of files.  */
end_comment

begin_function
name|void
name|name_gather
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|struct
name|name
modifier|*
name|namebuf
decl_stmt|;
comment|/* One-name buffer */
specifier|static
name|namelen
expr_stmt|;
specifier|static
name|char
modifier|*
name|chdir_name
decl_stmt|;
if|if
condition|(
name|f_sorted_names
condition|)
block|{
if|if
condition|(
operator|!
name|namelen
condition|)
block|{
name|namelen
operator|=
name|NAMSIZ
expr_stmt|;
name|namebuf
operator|=
operator|(
expr|struct
name|name
operator|*
operator|)
name|ck_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|name
argument_list|)
operator|+
name|NAMSIZ
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|name_next
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'C'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|p
operator|=
name|name_next
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|chdir_name
operator|=
name|p
condition|?
name|strdup
argument_list|(
name|p
argument_list|)
else|:
name|p
expr_stmt|;
name|p
operator|=
name|name_next
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chdir_name
condition|)
block|{
name|msg
argument_list|(
literal|"Missing file name after -C"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
name|namebuf
operator|->
name|change_dir
operator|=
name|chdir_name
expr_stmt|;
block|}
name|namebuf
operator|->
name|length
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|namebuf
operator|->
name|length
operator|>=
name|namelen
condition|)
block|{
name|namebuf
operator|=
operator|(
expr|struct
name|name
operator|*
operator|)
name|ck_realloc
argument_list|(
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|name
argument_list|)
operator|+
name|namebuf
operator|->
name|length
argument_list|)
expr_stmt|;
name|namelen
operator|=
name|namebuf
operator|->
name|length
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|namebuf
operator|->
name|name
argument_list|,
name|p
argument_list|,
name|namebuf
operator|->
name|length
argument_list|)
expr_stmt|;
name|namebuf
operator|->
name|name
index|[
name|namebuf
operator|->
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|namebuf
operator|->
name|next
operator|=
operator|(
expr|struct
name|name
operator|*
operator|)
name|NULL
expr_stmt|;
name|namebuf
operator|->
name|found
operator|=
literal|0
expr_stmt|;
name|namelist
operator|=
name|namebuf
expr_stmt|;
name|namelast
operator|=
name|namelist
expr_stmt|;
block|}
return|return;
block|}
comment|/* Non sorted names -- read them all in */
while|while
condition|(
name|p
operator|=
name|name_next
argument_list|(
literal|0
argument_list|)
condition|)
name|addname
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a name to the namelist.  */
end_comment

begin_function
name|void
name|addname
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* pointer to name */
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Length of string */
specifier|register
name|struct
name|name
modifier|*
name|p
decl_stmt|;
comment|/* Current struct pointer */
specifier|static
name|char
modifier|*
name|chdir_name
decl_stmt|;
name|char
modifier|*
name|new_name
parameter_list|()
function_decl|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'C'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|name
operator|=
name|name_next
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|chdir_name
operator|=
name|name
condition|?
name|strdup
argument_list|(
name|name
argument_list|)
else|:
name|name
expr_stmt|;
name|name
operator|=
name|name_next
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chdir_name
condition|)
block|{
name|msg
argument_list|(
literal|"Missing file name after -C"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chdir_name
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|char
modifier|*
name|path
init|=
name|ck_malloc
argument_list|(
name|PATH_MAX
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_GETCWD
argument_list|)
operator|||
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
if|if
condition|(
operator|!
name|getcwd
argument_list|(
name|path
argument_list|,
name|PATH_MAX
argument_list|)
condition|)
block|{
name|msg
argument_list|(
literal|"Couldn't get current directory."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SYSTEM
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|char
modifier|*
name|getwd
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
name|getwd
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|msg
argument_list|(
literal|"Couldn't get current directory: %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SYSTEM
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|chdir_name
operator|=
name|new_name
argument_list|(
name|path
argument_list|,
name|chdir_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|name
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/*NOSTRICT*/
name|p
operator|=
operator|(
expr|struct
name|name
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|name
argument_list|)
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
operator|(
expr|struct
name|name
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|msg
argument_list|(
literal|"cannot allocate mem for name '%s'."
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|msg
argument_list|(
literal|"cannot allocate mem for chdir record."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SYSTEM
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|next
operator|=
operator|(
expr|struct
name|name
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|p
operator|->
name|fake
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|length
operator|=
name|i
expr_stmt|;
name|strncpy
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Null term */
block|}
else|else
name|p
operator|->
name|fake
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|found
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|regexp
operator|=
literal|0
expr_stmt|;
comment|/* Assume not a regular expression */
name|p
operator|->
name|firstch
operator|=
literal|1
expr_stmt|;
comment|/* Assume first char is literal */
name|p
operator|->
name|change_dir
operator|=
name|chdir_name
expr_stmt|;
name|p
operator|->
name|dir_contents
operator|=
literal|0
expr_stmt|;
comment|/* JF */
if|if
condition|(
name|name
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
name|name
argument_list|,
literal|'*'
argument_list|)
operator|||
name|index
argument_list|(
name|name
argument_list|,
literal|'['
argument_list|)
operator|||
name|index
argument_list|(
name|name
argument_list|,
literal|'?'
argument_list|)
condition|)
block|{
name|p
operator|->
name|regexp
operator|=
literal|1
expr_stmt|;
comment|/* No, it's a regexp */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'['
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'?'
condition|)
name|p
operator|->
name|firstch
operator|=
literal|0
expr_stmt|;
comment|/* Not even 1st char literal */
block|}
block|}
if|if
condition|(
name|namelast
condition|)
name|namelast
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|namelast
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|namelist
condition|)
name|namelist
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return nonzero if name P (from an archive) matches any name from  * the namelist, zero if not.  */
end_comment

begin_function
name|int
name|name_match
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|name
modifier|*
name|nlp
decl_stmt|;
name|struct
name|name
modifier|*
name|tmpnlp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|again
label|:
if|if
condition|(
literal|0
operator|==
operator|(
name|nlp
operator|=
name|namelist
operator|)
condition|)
comment|/* Empty namelist is easy */
return|return
literal|1
return|;
if|if
condition|(
name|nlp
operator|->
name|fake
condition|)
block|{
if|if
condition|(
name|nlp
operator|->
name|change_dir
operator|&&
name|chdir
argument_list|(
name|nlp
operator|->
name|change_dir
argument_list|)
condition|)
name|msg_perror
argument_list|(
literal|"Can't change to directory %s"
argument_list|,
name|nlp
operator|->
name|change_dir
argument_list|)
expr_stmt|;
name|namelist
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|nlp
operator|!=
literal|0
condition|;
name|nlp
operator|=
name|nlp
operator|->
name|next
control|)
block|{
comment|/* If first chars don't match, quick skip */
if|if
condition|(
name|nlp
operator|->
name|firstch
operator|&&
name|nlp
operator|->
name|name
index|[
literal|0
index|]
operator|!=
name|p
index|[
literal|0
index|]
condition|)
continue|continue;
comment|/* Regular expressions (shell globbing, actually). */
if|if
condition|(
name|nlp
operator|->
name|regexp
condition|)
block|{
if|if
condition|(
name|fnmatch
argument_list|(
name|nlp
operator|->
name|name
argument_list|,
name|p
argument_list|,
name|FNM_LEADING_DIR
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nlp
operator|->
name|found
operator|=
literal|1
expr_stmt|;
comment|/* Remember it matched */
if|if
condition|(
name|f_startfile
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|namelist
argument_list|)
expr_stmt|;
name|namelist
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|nlp
operator|->
name|change_dir
operator|&&
name|chdir
argument_list|(
name|nlp
operator|->
name|change_dir
argument_list|)
condition|)
name|msg_perror
argument_list|(
literal|"Can't change to directory %s"
argument_list|,
name|nlp
operator|->
name|change_dir
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* We got a match */
block|}
continue|continue;
block|}
comment|/* Plain Old Strings */
if|if
condition|(
name|nlp
operator|->
name|length
operator|<=
name|len
comment|/* Archive len>= specified */
operator|&&
operator|(
name|p
index|[
name|nlp
operator|->
name|length
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
name|nlp
operator|->
name|length
index|]
operator|==
literal|'/'
operator|)
comment|/* Full match on file/dirname */
operator|&&
name|strncmp
argument_list|(
name|p
argument_list|,
name|nlp
operator|->
name|name
argument_list|,
name|nlp
operator|->
name|length
argument_list|)
operator|==
literal|0
condition|)
comment|/* Name compare */
block|{
name|nlp
operator|->
name|found
operator|=
literal|1
expr_stmt|;
comment|/* Remember it matched */
if|if
condition|(
name|f_startfile
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|namelist
argument_list|)
expr_stmt|;
name|namelist
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|nlp
operator|->
name|change_dir
operator|&&
name|chdir
argument_list|(
name|nlp
operator|->
name|change_dir
argument_list|)
condition|)
name|msg_perror
argument_list|(
literal|"Can't change to directory %s"
argument_list|,
name|nlp
operator|->
name|change_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_fast_read
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
name|nlp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* remove the current entry, since we found a match */
comment|/* use brute force, this code is a mess anyway */
if|if
condition|(
name|namelist
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
comment|/* the list contains one element */
name|free
argument_list|(
name|namelist
argument_list|)
expr_stmt|;
name|namelist
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nlp
operator|==
name|namelist
condition|)
block|{
comment|/* the first element is the one */
name|tmpnlp
operator|=
name|namelist
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|namelist
argument_list|)
expr_stmt|;
name|namelist
operator|=
name|tmpnlp
expr_stmt|;
block|}
else|else
block|{
name|tmpnlp
operator|=
name|namelist
expr_stmt|;
while|while
condition|(
name|tmpnlp
operator|->
name|next
operator|!=
name|nlp
condition|)
block|{
name|tmpnlp
operator|=
name|tmpnlp
operator|->
name|next
expr_stmt|;
block|}
name|tmpnlp
operator|->
name|next
operator|=
name|nlp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|nlp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* set a boolean to decide wether we started with a  */
comment|/* non-empty  namelist, that was emptied */
name|nlpsfreed
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
comment|/* We got a match */
block|}
block|}
comment|/* 	 * Filename from archive not found in namelist. 	 * If we have the whole namelist here, just return 0. 	 * Otherwise, read the next name in and compare it. 	 * If this was the last name, namelist->found will remain on. 	 * If not, we loop to compare the newly read name. 	 */
if|if
condition|(
name|f_sorted_names
operator|&&
name|namelist
operator|->
name|found
condition|)
block|{
name|name_gather
argument_list|()
expr_stmt|;
comment|/* Read one more */
if|if
condition|(
operator|!
name|namelist
operator|->
name|found
condition|)
goto|goto
name|again
goto|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Print the names of things in the namelist that were not matched.  */
end_comment

begin_function
name|void
name|names_notfound
parameter_list|()
block|{
specifier|register
name|struct
name|name
modifier|*
name|nlp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|nlp
operator|=
name|namelist
init|;
name|nlp
operator|!=
literal|0
condition|;
name|nlp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|nlp
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|nlp
operator|->
name|found
condition|)
name|msg
argument_list|(
literal|"%s not found in archive"
argument_list|,
name|nlp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* 		 * We could free() the list, but the process is about 		 * to die anyway, so save some CPU time.  Amigas and 		 * other similarly broken software will need to waste 		 * the time, though. 		 */
ifdef|#
directive|ifdef
name|amiga
if|if
condition|(
operator|!
name|f_sorted_names
condition|)
name|free
argument_list|(
name|nlp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|namelist
operator|=
operator|(
expr|struct
name|name
operator|*
operator|)
name|NULL
expr_stmt|;
name|namelast
operator|=
operator|(
expr|struct
name|name
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|f_sorted_names
condition|)
block|{
while|while
condition|(
literal|0
operator|!=
operator|(
name|p
operator|=
name|name_next
argument_list|(
literal|1
argument_list|)
operator|)
condition|)
name|msg
argument_list|(
literal|"%s not found in archive"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* These next routines were created by JF */
end_comment

begin_function
name|void
name|name_expand
parameter_list|()
block|{
empty_stmt|;
block|}
end_function

begin_comment
comment|/* This is like name_match(), except that it returns a pointer to the name    it matched, and doesn't set ->found  The caller will have to do that    if it wants to.  Oh, and if the namelist is empty, it returns 0, unlike    name_match(), which returns TRUE */
end_comment

begin_function
name|struct
name|name
modifier|*
name|name_scan
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|name
modifier|*
name|nlp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|again
label|:
if|if
condition|(
literal|0
operator|==
operator|(
name|nlp
operator|=
name|namelist
operator|)
condition|)
comment|/* Empty namelist is easy */
return|return
literal|0
return|;
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|nlp
operator|!=
literal|0
condition|;
name|nlp
operator|=
name|nlp
operator|->
name|next
control|)
block|{
comment|/* If first chars don't match, quick skip */
if|if
condition|(
name|nlp
operator|->
name|firstch
operator|&&
name|nlp
operator|->
name|name
index|[
literal|0
index|]
operator|!=
name|p
index|[
literal|0
index|]
condition|)
continue|continue;
comment|/* Regular expressions */
if|if
condition|(
name|nlp
operator|->
name|regexp
condition|)
block|{
if|if
condition|(
name|fnmatch
argument_list|(
name|nlp
operator|->
name|name
argument_list|,
name|p
argument_list|,
name|FNM_LEADING_DIR
argument_list|)
operator|==
literal|0
condition|)
return|return
name|nlp
return|;
comment|/* We got a match */
continue|continue;
block|}
comment|/* Plain Old Strings */
if|if
condition|(
name|nlp
operator|->
name|length
operator|<=
name|len
comment|/* Archive len>= specified */
operator|&&
operator|(
name|p
index|[
name|nlp
operator|->
name|length
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
name|nlp
operator|->
name|length
index|]
operator|==
literal|'/'
operator|)
comment|/* Full match on file/dirname */
operator|&&
name|strncmp
argument_list|(
name|p
argument_list|,
name|nlp
operator|->
name|name
argument_list|,
name|nlp
operator|->
name|length
argument_list|)
operator|==
literal|0
condition|)
comment|/* Name compare */
return|return
name|nlp
return|;
comment|/* We got a match */
block|}
comment|/* 	 * Filename from archive not found in namelist. 	 * If we have the whole namelist here, just return 0. 	 * Otherwise, read the next name in and compare it. 	 * If this was the last name, namelist->found will remain on. 	 * If not, we loop to compare the newly read name. 	 */
if|if
condition|(
name|f_sorted_names
operator|&&
name|namelist
operator|->
name|found
condition|)
block|{
name|name_gather
argument_list|()
expr_stmt|;
comment|/* Read one more */
if|if
condition|(
operator|!
name|namelist
operator|->
name|found
condition|)
goto|goto
name|again
goto|;
block|}
return|return
operator|(
expr|struct
name|name
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This returns a name from the namelist which doesn't have ->found set.    It sets ->found before returning, so successive calls will find and return    all the non-found names in the namelist */
end_comment

begin_decl_stmt
name|struct
name|name
modifier|*
name|gnu_list_name
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|name_from_list
parameter_list|()
block|{
if|if
condition|(
operator|!
name|gnu_list_name
condition|)
name|gnu_list_name
operator|=
name|namelist
expr_stmt|;
while|while
condition|(
name|gnu_list_name
operator|&&
name|gnu_list_name
operator|->
name|found
condition|)
name|gnu_list_name
operator|=
name|gnu_list_name
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|gnu_list_name
condition|)
block|{
name|gnu_list_name
operator|->
name|found
operator|++
expr_stmt|;
if|if
condition|(
name|gnu_list_name
operator|->
name|change_dir
condition|)
if|if
condition|(
name|chdir
argument_list|(
name|gnu_list_name
operator|->
name|change_dir
argument_list|)
operator|<
literal|0
condition|)
name|msg_perror
argument_list|(
literal|"can't chdir to %s"
argument_list|,
name|gnu_list_name
operator|->
name|change_dir
argument_list|)
expr_stmt|;
return|return
name|gnu_list_name
operator|->
name|name
return|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_function
name|void
name|blank_name_list
parameter_list|()
block|{
name|struct
name|name
modifier|*
name|n
decl_stmt|;
name|gnu_list_name
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|namelist
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
name|n
operator|->
name|found
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|new_name
parameter_list|(
name|path
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|,
decl|*
name|name
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|path_buf
decl_stmt|;
name|path_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_buf
operator|==
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"Can't allocate memory for name '%s/%s"
argument_list|,
name|path
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SYSTEM
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|path_buf
argument_list|,
literal|"%s/%s"
argument_list|,
name|path
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|path_buf
return|;
block|}
end_block

begin_comment
comment|/* returns non-zero if the luser typed 'y' or 'Y', zero otherwise. */
end_comment

begin_function
name|int
name|confirm
parameter_list|(
name|action
parameter_list|,
name|file
parameter_list|)
name|char
modifier|*
name|action
decl_stmt|,
decl|*
name|file
decl_stmt|;
end_function

begin_block
block|{
name|int
name|c
decl_stmt|,
name|nl
decl_stmt|;
specifier|static
name|FILE
modifier|*
name|confirm_file
init|=
literal|0
decl_stmt|;
specifier|extern
name|FILE
modifier|*
name|msg_file
decl_stmt|;
specifier|extern
name|char
name|TTY_NAME
index|[]
decl_stmt|;
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"%s %s?"
argument_list|,
name|action
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|msg_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|confirm_file
condition|)
block|{
name|confirm_file
operator|=
operator|(
name|archive
operator|==
literal|0
operator|)
condition|?
name|fopen
argument_list|(
name|TTY_NAME
argument_list|,
literal|"r"
argument_list|)
else|:
name|stdin
expr_stmt|;
if|if
condition|(
operator|!
name|confirm_file
condition|)
block|{
name|msg
argument_list|(
literal|"Can't read confirmation from user"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SYSTEM
argument_list|)
expr_stmt|;
block|}
block|}
name|c
operator|=
name|getc
argument_list|(
name|confirm_file
argument_list|)
expr_stmt|;
for|for
control|(
name|nl
operator|=
name|c
init|;
name|nl
operator|!=
literal|'\n'
operator|&&
name|nl
operator|!=
name|EOF
condition|;
name|nl
operator|=
name|getc
argument_list|(
name|confirm_file
argument_list|)
control|)
empty_stmt|;
return|return
operator|(
name|c
operator|==
literal|'y'
operator|||
name|c
operator|==
literal|'Y'
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|x_buffer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size_x_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|free_x_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|exclude
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size_exclude
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|free_exclude
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|re_exclude
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size_re_exclude
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|free_re_exclude
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|add_exclude
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
comment|/*	char *rname;*/
comment|/*	char **tmp_ptr;*/
name|int
name|size_buf
decl_stmt|;
name|un_quote_string
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|size_buf
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_buffer
operator|==
literal|0
condition|)
block|{
name|x_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|ck_malloc
argument_list|(
name|size_buf
operator|+
literal|1024
argument_list|)
expr_stmt|;
name|free_x_buffer
operator|=
literal|1024
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|free_x_buffer
operator|<=
name|size_buf
condition|)
block|{
name|char
modifier|*
name|old_x_buffer
decl_stmt|;
name|char
modifier|*
modifier|*
name|tmp_ptr
decl_stmt|;
name|old_x_buffer
operator|=
name|x_buffer
expr_stmt|;
name|x_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|ck_realloc
argument_list|(
name|x_buffer
argument_list|,
name|size_x_buffer
operator|+
literal|1024
argument_list|)
expr_stmt|;
name|free_x_buffer
operator|=
literal|1024
expr_stmt|;
for|for
control|(
name|tmp_ptr
operator|=
name|exclude
init|;
name|tmp_ptr
operator|<
name|exclude
operator|+
name|size_exclude
condition|;
name|tmp_ptr
operator|++
control|)
operator|*
name|tmp_ptr
operator|=
name|x_buffer
operator|+
operator|(
operator|(
operator|*
name|tmp_ptr
operator|)
operator|-
name|old_x_buffer
operator|)
expr_stmt|;
for|for
control|(
name|tmp_ptr
operator|=
name|re_exclude
init|;
name|tmp_ptr
operator|<
name|re_exclude
operator|+
name|size_re_exclude
condition|;
name|tmp_ptr
operator|++
control|)
operator|*
name|tmp_ptr
operator|=
name|x_buffer
operator|+
operator|(
operator|(
operator|*
name|tmp_ptr
operator|)
operator|-
name|old_x_buffer
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|is_regex
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|free_re_exclude
operator|==
literal|0
condition|)
block|{
name|re_exclude
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|re_exclude
condition|?
name|ck_realloc
argument_list|(
name|re_exclude
argument_list|,
operator|(
name|size_re_exclude
operator|+
literal|32
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
else|:
name|ck_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
literal|32
argument_list|)
operator|)
expr_stmt|;
name|free_re_exclude
operator|+=
literal|32
expr_stmt|;
block|}
name|re_exclude
index|[
name|size_re_exclude
index|]
operator|=
name|x_buffer
operator|+
name|size_x_buffer
expr_stmt|;
name|size_re_exclude
operator|++
expr_stmt|;
name|free_re_exclude
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|free_exclude
operator|==
literal|0
condition|)
block|{
name|exclude
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|exclude
condition|?
name|ck_realloc
argument_list|(
name|exclude
argument_list|,
operator|(
name|size_exclude
operator|+
literal|32
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
else|:
name|ck_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
literal|32
argument_list|)
operator|)
expr_stmt|;
name|free_exclude
operator|+=
literal|32
expr_stmt|;
block|}
name|exclude
index|[
name|size_exclude
index|]
operator|=
name|x_buffer
operator|+
name|size_x_buffer
expr_stmt|;
name|size_exclude
operator|++
expr_stmt|;
name|free_exclude
operator|--
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|x_buffer
operator|+
name|size_x_buffer
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|size_x_buffer
operator|+=
name|size_buf
operator|+
literal|1
expr_stmt|;
name|free_x_buffer
operator|-=
name|size_buf
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_exclude_file
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
condition|)
name|fp
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|else
comment|/* Let's hope the person knows what they're doing. */
comment|/* Using -X - -T - -f - will get you *REALLY* strange 		   results. . . */
name|fp
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|msg_perror
argument_list|(
literal|"can't open %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
literal|1024
argument_list|,
name|fp
argument_list|)
condition|)
block|{
comment|/*		int size_buf;*/
name|char
modifier|*
name|end_str
decl_stmt|;
name|end_str
operator|=
name|rindex
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_str
condition|)
operator|*
name|end_str
operator|=
literal|'\0'
expr_stmt|;
name|add_exclude
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|is_regex
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
return|return
name|index
argument_list|(
name|str
argument_list|,
literal|'*'
argument_list|)
operator|||
name|index
argument_list|(
name|str
argument_list|,
literal|'['
argument_list|)
operator|||
name|index
argument_list|(
name|str
argument_list|,
literal|'?'
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if the file 'name' should not be added/extracted */
end_comment

begin_function
name|int
name|check_exclude
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
specifier|extern
name|char
modifier|*
name|strstr
parameter_list|()
function_decl|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|size_re_exclude
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|fnmatch
argument_list|(
name|re_exclude
index|[
name|n
index|]
argument_list|,
name|name
argument_list|,
name|FNM_LEADING_DIR
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|size_exclude
condition|;
name|n
operator|++
control|)
block|{
comment|/* Accept the output from strstr only if it is the last 		   part of the string.  There is certainly a faster way to 		   do this. . . */
if|if
condition|(
operator|(
name|str
operator|=
name|strstr
argument_list|(
name|name
argument_list|,
name|exclude
index|[
name|n
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|str
operator|==
name|name
operator|||
name|str
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|)
operator|&&
name|str
index|[
name|strlen
argument_list|(
name|exclude
index|[
name|n
index|]
argument_list|)
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

