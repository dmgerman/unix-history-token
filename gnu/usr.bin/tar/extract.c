begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Extract files from a tar archive.    Copyright (C) 1988, 1992, 1993 Free Software Foundation  This file is part of GNU Tar.  GNU Tar is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Tar is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Tar; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*  * Extract files from a tar archive.  *  * Written 19 Nov 1985 by John Gilmore, ihnp4!hoptoad!gnu.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|STDC_HEADERS
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_function_decl
name|time_t
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|V7
end_ifndef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_OPEN3
end_ifdef

begin_comment
comment|/* We need the #define's even though we don't use them. */
end_comment

begin_include
include|#
directive|include
file|"open3.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|EMUL_OPEN3
end_ifdef

begin_comment
comment|/* Simulated 3-argument open for systems that don't have it */
end_comment

begin_include
include|#
directive|include
file|"open3.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"tar.h"
end_include

begin_include
include|#
directive|include
file|"port.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_POSIX_VERSION
argument_list|)
end_if

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_else
else|#
directive|else
end_else

begin_struct
struct|struct
name|utimbuf
block|{
name|long
name|actime
decl_stmt|;
name|long
name|modtime
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|msg_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|union
name|record
modifier|*
name|head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Points to current tape header */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|stat
name|hstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stat struct corresponding */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|head_standard
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tape header is in ANSI format */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|save_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|save_totsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|save_sizeleft
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|confirm
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|decode_header
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|extract_mangle
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|extract_sparse_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|from_oct
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|gnu_restore
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|print_header
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|skip_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|skip_extended_headers
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|pr_mkdir
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|saverec
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|make_dirs
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Makes required directories */
end_comment

begin_decl_stmt
specifier|static
name|time_t
name|now
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current time */
end_comment

begin_expr_stmt
specifier|static
name|we_are_root
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* True if our effective uid == 0 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|notumask
init|=
operator|~
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Masks out bits user doesn't want */
end_comment

begin_comment
comment|/*  * "Scratch" space to store the information about a sparse file before  * writing the info into the header or extended header  */
end_comment

begin_comment
comment|/*struct sp_array	*sparsearray;*/
end_comment

begin_comment
comment|/* number of elts storable in the sparsearray */
end_comment

begin_comment
comment|/*int	sp_array_size = 10;*/
end_comment

begin_struct
struct|struct
name|saved_dir_info
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|atime
decl_stmt|;
name|int
name|mtime
decl_stmt|;
name|struct
name|saved_dir_info
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|saved_dir_info
modifier|*
name|saved_dir_info_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set up to extract files.  */
end_comment

begin_function
name|void
name|extr_init
parameter_list|()
block|{
name|int
name|ourmask
decl_stmt|;
name|now
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|geteuid
argument_list|()
operator|==
literal|0
condition|)
name|we_are_root
operator|=
literal|1
expr_stmt|;
comment|/* 	 * We need to know our umask.  But if f_use_protection is set, 	 * leave our kernel umask at 0, and our "notumask" at ~0. 	 */
name|ourmask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Read it */
if|if
condition|(
operator|!
name|f_use_protection
condition|)
block|{
operator|(
name|void
operator|)
name|umask
argument_list|(
name|ourmask
argument_list|)
expr_stmt|;
comment|/* Set it back how it was */
name|notumask
operator|=
operator|~
name|ourmask
expr_stmt|;
comment|/* Make umask override permissions */
block|}
block|}
end_function

begin_comment
comment|/*  * Extract a file from the archive.  */
end_comment

begin_function
name|void
name|extract_archive
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|check
decl_stmt|,
name|namelen
decl_stmt|,
name|written
decl_stmt|,
name|openflag
decl_stmt|;
name|long
name|size
decl_stmt|;
name|struct
name|utimbuf
name|acc_upd_times
decl_stmt|;
specifier|register
name|int
name|skipcrud
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/*	int sparse_ind = 0;*/
name|union
name|record
modifier|*
name|exhdr
decl_stmt|;
name|struct
name|saved_dir_info
modifier|*
name|tmp
decl_stmt|;
comment|/*	int end_nulls; */
name|saverec
argument_list|(
operator|&
name|head
argument_list|)
expr_stmt|;
comment|/* Make sure it sticks around */
name|userec
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/* And go past it in the archive */
name|decode_header
argument_list|(
name|head
argument_list|,
operator|&
name|hstat
argument_list|,
operator|&
name|head_standard
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Snarf fields */
if|if
condition|(
operator|(
name|f_confirm
operator|&&
operator|!
name|confirm
argument_list|(
literal|"extract"
argument_list|,
name|current_file_name
argument_list|)
operator|)
operator|||
operator|(
name|f_exstdout
operator|&&
name|head
operator|->
name|header
operator|.
name|linkflag
operator|!=
name|LF_OLDNORMAL
operator|&&
name|head
operator|->
name|header
operator|.
name|linkflag
operator|!=
name|LF_NORMAL
operator|&&
name|head
operator|->
name|header
operator|.
name|linkflag
operator|!=
name|LF_CONTIG
operator|)
condition|)
block|{
if|if
condition|(
name|head
operator|->
name|header
operator|.
name|isextended
condition|)
name|skip_extended_headers
argument_list|()
expr_stmt|;
name|skip_file
argument_list|(
operator|(
name|long
operator|)
name|hstat
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|saverec
argument_list|(
operator|(
expr|union
name|record
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Print the record from 'head' and 'hstat' */
if|if
condition|(
name|f_verbose
condition|)
name|print_header
argument_list|()
expr_stmt|;
comment|/* 	 * Check for fully specified pathnames and other atrocities. 	 * 	 * Note, we can't just make a pointer to the new file name, 	 * since saverec() might move the header and adjust "head". 	 * We have to start from "head" every time we want to touch 	 * the header record. 	 */
name|skipcrud
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|f_absolute_paths
operator|&&
literal|'/'
operator|==
name|current_file_name
index|[
name|skipcrud
index|]
condition|)
block|{
specifier|static
name|int
name|warned_once
init|=
literal|0
decl_stmt|;
name|skipcrud
operator|++
expr_stmt|;
comment|/* Force relative path */
if|if
condition|(
operator|!
name|warned_once
operator|++
condition|)
block|{
name|msg
argument_list|(
literal|"Removing leading / from absolute path names in the archive."
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|head
operator|->
name|header
operator|.
name|linkflag
condition|)
block|{
default|default:
name|msg
argument_list|(
literal|"Unknown file type '%c' for %s, extracted as normal file"
argument_list|,
name|head
operator|->
name|header
operator|.
name|linkflag
argument_list|,
name|skipcrud
operator|+
name|current_file_name
argument_list|)
expr_stmt|;
comment|/* FALL THRU */
comment|/* 	  * JK - What we want to do if the file is sparse is loop through 	  * the array of sparse structures in the header and read in 	  * and translate the character strings representing  1) the offset 	  * at which to write and 2) how many bytes to write into numbers, 	  * which we store into the scratch array, "sparsearray".  This 	  * array makes our life easier the same way it did in creating 	  * the tar file that had to deal with a sparse file. 	  * 	  * After we read in the first five (at most) sparse structures, 	  * we check to see if the file has an extended header, i.e., 	  * if more sparse structures are needed to describe the contents 	  * of the new file.  If so, we read in the extended headers 	  * and continue to store their contents into the sparsearray. 	  */
case|case
name|LF_SPARSE
case|:
name|sp_array_size
operator|=
literal|10
expr_stmt|;
name|sparsearray
operator|=
operator|(
expr|struct
name|sp_array
operator|*
operator|)
name|ck_malloc
argument_list|(
name|sp_array_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sp_array
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPARSE_IN_HDR
condition|;
name|i
operator|++
control|)
block|{
name|sparsearray
index|[
name|i
index|]
operator|.
name|offset
operator|=
name|from_oct
argument_list|(
literal|1
operator|+
literal|12
argument_list|,
name|head
operator|->
name|header
operator|.
name|sp
index|[
name|i
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
name|sparsearray
index|[
name|i
index|]
operator|.
name|numbytes
operator|=
name|from_oct
argument_list|(
literal|1
operator|+
literal|12
argument_list|,
name|head
operator|->
name|header
operator|.
name|sp
index|[
name|i
index|]
operator|.
name|numbytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sparsearray
index|[
name|i
index|]
operator|.
name|numbytes
condition|)
break|break;
block|}
comment|/*		end_nulls = from_oct(1+12, head->header.ending_blanks);*/
if|if
condition|(
name|head
operator|->
name|header
operator|.
name|isextended
condition|)
block|{
comment|/* read in the list of extended headers 			    and translate them into the sparsearray 			    as before */
comment|/* static */
name|int
name|ind
init|=
name|SPARSE_IN_HDR
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|exhdr
operator|=
name|findrec
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPARSE_EXT_HDR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|+
name|ind
operator|>
name|sp_array_size
operator|-
literal|1
condition|)
block|{
comment|/* 					  * realloc the scratch area 					  * since we've run out of room -- 					  */
name|sparsearray
operator|=
operator|(
expr|struct
name|sp_array
operator|*
operator|)
name|ck_realloc
argument_list|(
name|sparsearray
argument_list|,
literal|2
operator|*
name|sp_array_size
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sp_array
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|sp_array_size
operator|*=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|exhdr
operator|->
name|ext_hdr
operator|.
name|sp
index|[
name|i
index|]
operator|.
name|numbytes
condition|)
break|break;
name|sparsearray
index|[
name|i
operator|+
name|ind
index|]
operator|.
name|offset
operator|=
name|from_oct
argument_list|(
literal|1
operator|+
literal|12
argument_list|,
name|exhdr
operator|->
name|ext_hdr
operator|.
name|sp
index|[
name|i
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
name|sparsearray
index|[
name|i
operator|+
name|ind
index|]
operator|.
name|numbytes
operator|=
name|from_oct
argument_list|(
literal|1
operator|+
literal|12
argument_list|,
name|exhdr
operator|->
name|ext_hdr
operator|.
name|sp
index|[
name|i
index|]
operator|.
name|numbytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|exhdr
operator|->
name|ext_hdr
operator|.
name|isextended
condition|)
break|break;
else|else
block|{
name|ind
operator|+=
name|SPARSE_EXT_HDR
expr_stmt|;
name|userec
argument_list|(
name|exhdr
argument_list|)
expr_stmt|;
block|}
block|}
name|userec
argument_list|(
name|exhdr
argument_list|)
expr_stmt|;
block|}
comment|/* FALL THRU */
case|case
name|LF_OLDNORMAL
case|:
case|case
name|LF_NORMAL
case|:
case|case
name|LF_CONTIG
case|:
comment|/* 		  * Appears to be a file. 		  * See if it's really a directory. 		  */
name|namelen
operator|=
name|strlen
argument_list|(
name|skipcrud
operator|+
name|current_file_name
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|current_file_name
index|[
name|skipcrud
operator|+
name|namelen
index|]
operator|==
literal|'/'
condition|)
goto|goto
name|really_dir
goto|;
comment|/* FIXME, deal with protection issues */
name|again_file
label|:
name|openflag
operator|=
operator|(
name|f_keep
condition|?
name|O_BINARY
operator||
name|O_NDELAY
operator||
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
else|:
name|O_BINARY
operator||
name|O_NDELAY
operator||
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator|)
operator||
operator|(
operator|(
name|head
operator|->
name|header
operator|.
name|linkflag
operator|==
name|LF_SPARSE
operator|)
condition|?
literal|0
else|:
name|O_APPEND
operator|)
expr_stmt|;
comment|/* 			  * JK - The last | is a kludge to solve the problem 			  * the O_APPEND flag  causes with files we are 			  * trying to make sparse:  when a file is opened 			  * with O_APPEND, it writes  to the last place 			  * that something was written, thereby ignoring 			  * any lseeks that we have done.  We add this 			  * extra condition to make it able to lseek when 			  * a file is sparse, i.e., we don't open the new 			  * file with this flag.  (Grump -- this bug caused 			  * me to waste a good deal of time, I might add) 			  */
if|if
condition|(
name|f_exstdout
condition|)
block|{
name|fd
operator|=
literal|1
expr_stmt|;
goto|goto
name|extract_file
goto|;
block|}
if|if
condition|(
name|f_unlink
operator|&&
operator|!
name|f_keep
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|skipcrud
operator|+
name|current_file_name
argument_list|)
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|msg_perror
argument_list|(
literal|"Could not unlink %s"
argument_list|,
name|skipcrud
operator|+
name|current_file_name
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|O_CTG
comment|/* 		  * Contiguous files (on the Masscomp) have to specify 		  * the size in the open call that creates them. 		  */
if|if
condition|(
name|head
operator|->
name|header
operator|.
name|linkflag
operator|==
name|LF_CONTIG
condition|)
name|fd
operator|=
name|open
argument_list|(
operator|(
name|longname
condition|?
name|longname
else|:
name|head
operator|->
name|header
operator|.
name|name
operator|)
operator|+
name|skipcrud
argument_list|,
name|openflag
operator||
name|O_CTG
argument_list|,
name|hstat
operator|.
name|st_mode
argument_list|,
name|hstat
operator|.
name|st_size
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|NO_OPEN3
comment|/* 			  * On raw V7 we won't let them specify -k (f_keep), but 			  * we just bull ahead and create the files. 			  */
name|fd
operator|=
name|creat
argument_list|(
operator|(
name|longname
condition|?
name|longname
else|:
name|head
operator|->
name|header
operator|.
name|name
operator|)
operator|+
name|skipcrud
argument_list|,
name|hstat
operator|.
name|st_mode
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 			  * With 3-arg open(), we can do this up right. 			  */
name|fd
operator|=
name|open
argument_list|(
name|skipcrud
operator|+
name|current_file_name
argument_list|,
name|openflag
argument_list|,
name|hstat
operator|.
name|st_mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|make_dirs
argument_list|(
name|skipcrud
operator|+
name|current_file_name
argument_list|)
condition|)
goto|goto
name|again_file
goto|;
name|msg_perror
argument_list|(
literal|"Could not create file %s"
argument_list|,
name|skipcrud
operator|+
name|current_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|header
operator|.
name|isextended
condition|)
name|skip_extended_headers
argument_list|()
expr_stmt|;
name|skip_file
argument_list|(
operator|(
name|long
operator|)
name|hstat
operator|.
name|st_size
argument_list|)
expr_stmt|;
goto|goto
name|quit
goto|;
block|}
name|extract_file
label|:
if|if
condition|(
name|head
operator|->
name|header
operator|.
name|linkflag
operator|==
name|LF_SPARSE
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
comment|/* 			  * Kludge alert.  NAME is assigned to header.name 			  * because during the extraction, the space that 			  * contains the header will get scribbled on, and 			  * the name will get munged, so any error messages 			  * that happen to contain the filename will look 			  * REAL interesting unless we do this. 			  */
name|namelen
operator|=
name|strlen
argument_list|(
name|skipcrud
operator|+
name|current_file_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|ck_malloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
operator|*
name|namelen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|skipcrud
operator|+
name|current_file_name
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|size
operator|=
name|hstat
operator|.
name|st_size
expr_stmt|;
name|extract_sparse_file
argument_list|(
name|fd
argument_list|,
operator|&
name|size
argument_list|,
name|hstat
operator|.
name|st_size
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|size
operator|=
name|hstat
operator|.
name|st_size
init|;
name|size
operator|>
literal|0
condition|;
name|size
operator|-=
name|written
control|)
block|{
comment|/*			long	offset, 				 numbytes;*/
if|if
condition|(
name|f_multivol
condition|)
block|{
name|save_name
operator|=
name|current_file_name
expr_stmt|;
name|save_totsize
operator|=
name|hstat
operator|.
name|st_size
expr_stmt|;
name|save_sizeleft
operator|=
name|size
expr_stmt|;
block|}
comment|/* 			  * Locate data, determine max length 			  * writeable, write it, record that 			  * we have used the data, then check 			  * if the write worked. 			  */
name|data
operator|=
name|findrec
argument_list|()
operator|->
name|charptr
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
comment|/* Check it... */
name|msg
argument_list|(
literal|"Unexpected EOF on archive file"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			  * JK - If the file is sparse, use the sparsearray 			  * that we created before to lseek into the new 			  * file the proper amount, and to see how many 			  * bytes we want to write at that position. 			  */
comment|/*			if (head->header.linkflag == LF_SPARSE) { 				 off_t pos;  				 pos = lseek(fd, (off_t) sparsearray[sparse_ind].offset, 0); 				 printf("%d at %d\n", (int) pos, sparse_ind); 				 written = sparsearray[sparse_ind++].numbytes; 			 } else*/
name|written
operator|=
name|endofrecs
argument_list|()
operator|->
name|charptr
operator|-
name|data
expr_stmt|;
if|if
condition|(
name|written
operator|>
name|size
condition|)
name|written
operator|=
name|size
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|check
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|data
argument_list|,
name|written
argument_list|)
expr_stmt|;
comment|/* 			  * The following is in violation of strict 			  * typing, since the arg to userec 			  * should be a struct rec *.  FIXME. 			  */
name|userec
argument_list|(
operator|(
expr|union
name|record
operator|*
operator|)
operator|(
name|data
operator|+
name|written
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
operator|==
name|written
condition|)
continue|continue;
comment|/* 			  * Error in writing to file. 			  * Print it, skip to next file in archive. 			  */
if|if
condition|(
name|check
operator|<
literal|0
condition|)
name|msg_perror
argument_list|(
literal|"couldn't write to file %s"
argument_list|,
name|skipcrud
operator|+
name|current_file_name
argument_list|)
expr_stmt|;
else|else
name|msg
argument_list|(
literal|"could only write %d of %d bytes to file %s"
argument_list|,
name|check
argument_list|,
name|written
argument_list|,
name|skipcrud
operator|+
name|current_file_name
argument_list|)
expr_stmt|;
name|skip_file
argument_list|(
call|(
name|long
call|)
argument_list|(
name|size
operator|-
name|written
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* Still do the close, mod time, chmod, etc */
block|}
if|if
condition|(
name|f_multivol
condition|)
name|save_name
operator|=
literal|0
expr_stmt|;
comment|/* If writing to stdout, don't try to do anything 			    to the filename; it doesn't exist, or we don't 			    want to touch it anyway */
if|if
condition|(
name|f_exstdout
condition|)
break|break;
comment|/*		if (head->header.isextended) { 			 register union record *exhdr; 			 register int i;  			 for (i = 0; i< 21; i++) { 				 long offset;  				 if (!exhdr->ext_hdr.sp[i].numbytes) 					 break; 				 offset = from_oct(1+12, 						 exhdr->ext_hdr.sp[i].offset); 				 written = from_oct(1+12, 						 exhdr->ext_hdr.sp[i].numbytes); 				 lseek(fd, offset, 0); 				 check = write(fd, data, written); 				 if (check == written) continue;  			 }   		 }*/
name|check
operator|=
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"Error while closing %s"
argument_list|,
name|skipcrud
operator|+
name|current_file_name
argument_list|)
expr_stmt|;
block|}
name|set_filestat
label|:
comment|/* 		  * If we are root, set the owner and group of the extracted 		  * file.  This does what is wanted both on real Unix and on 		  * System V.  If we are running as a user, we extract as that 		  * user; if running as root, we extract as the original owner. 		  */
if|if
condition|(
name|we_are_root
operator|||
name|f_do_chown
condition|)
block|{
if|if
condition|(
name|chown
argument_list|(
name|skipcrud
operator|+
name|current_file_name
argument_list|,
name|hstat
operator|.
name|st_uid
argument_list|,
name|hstat
operator|.
name|st_gid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"cannot chown file %s to uid %d gid %d"
argument_list|,
name|skipcrud
operator|+
name|current_file_name
argument_list|,
name|hstat
operator|.
name|st_uid
argument_list|,
name|hstat
operator|.
name|st_gid
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*        * Set the modified time of the file.        *        * Note that we set the accessed time to "now", which        * is really "the time we started extracting files".        * unless f_gnudump is used, in which case .st_atime is used        */
if|if
condition|(
operator|!
name|f_modified
condition|)
block|{
comment|/* fixme if f_gnudump should set ctime too, but how? */
if|if
condition|(
name|f_gnudump
condition|)
name|acc_upd_times
operator|.
name|actime
operator|=
name|hstat
operator|.
name|st_atime
expr_stmt|;
else|else
name|acc_upd_times
operator|.
name|actime
operator|=
name|now
expr_stmt|;
comment|/* Accessed now */
name|acc_upd_times
operator|.
name|modtime
operator|=
name|hstat
operator|.
name|st_mtime
expr_stmt|;
comment|/* Mod'd */
if|if
condition|(
name|utime
argument_list|(
name|skipcrud
operator|+
name|current_file_name
argument_list|,
operator|&
name|acc_upd_times
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"couldn't change access and modification times of %s"
argument_list|,
name|skipcrud
operator|+
name|current_file_name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* We do the utime before the chmod because some versions of 		   utime are broken and trash the modes of the file.  Since 		   we then change the mode anyway, we don't care. . . */
comment|/* 		 * If '-k' is not set, open() or creat() could have saved 		 * the permission bits from a previously created file, 		 * ignoring the ones we specified. 		 * Even if -k is set, if the file has abnormal 		 * mode bits, we must chmod since writing or chown() has 		 * probably reset them. 		 * 		 * If -k is set, we know *we* created this file, so the mode 		 * bits were set by our open().   If the file is "normal", we 		 * skip the chmod.  This works because we did umask(0) if -p 		 * is set, so umask will have left the specified mode alone. 		 */
if|if
condition|(
operator|(
operator|!
name|f_keep
operator|)
operator|||
operator|(
name|hstat
operator|.
name|st_mode
operator|&
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator||
name|S_ISVTX
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|chmod
argument_list|(
name|skipcrud
operator|+
name|current_file_name
argument_list|,
name|notumask
operator|&
operator|(
name|int
operator|)
name|hstat
operator|.
name|st_mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"cannot change mode of file %s to 0%o"
argument_list|,
name|skipcrud
operator|+
name|current_file_name
argument_list|,
name|notumask
operator|&
operator|(
name|int
operator|)
name|hstat
operator|.
name|st_mode
argument_list|)
expr_stmt|;
block|}
block|}
name|quit
label|:
break|break;
case|case
name|LF_LINK
case|:
name|again_link
label|:
block|{
name|struct
name|stat
name|st1
decl_stmt|,
name|st2
decl_stmt|;
if|if
condition|(
name|f_unlink
operator|&&
operator|!
name|f_keep
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|skipcrud
operator|+
name|current_file_name
argument_list|)
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|msg_perror
argument_list|(
literal|"Could not unlink %s"
argument_list|,
name|skipcrud
operator|+
name|current_file_name
argument_list|)
expr_stmt|;
block|}
name|check
operator|=
name|link
argument_list|(
name|current_link_name
argument_list|,
name|skipcrud
operator|+
name|current_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|make_dirs
argument_list|(
name|skipcrud
operator|+
name|current_file_name
argument_list|)
condition|)
goto|goto
name|again_link
goto|;
if|if
condition|(
name|f_gnudump
operator|&&
name|errno
operator|==
name|EEXIST
condition|)
break|break;
if|if
condition|(
name|stat
argument_list|(
name|current_link_name
argument_list|,
operator|&
name|st1
argument_list|)
operator|==
literal|0
operator|&&
name|stat
argument_list|(
name|current_file_name
operator|+
name|skipcrud
argument_list|,
operator|&
name|st2
argument_list|)
operator|==
literal|0
operator|&&
name|st1
operator|.
name|st_dev
operator|==
name|st2
operator|.
name|st_dev
operator|&&
name|st1
operator|.
name|st_ino
operator|==
name|st2
operator|.
name|st_ino
condition|)
break|break;
name|msg_perror
argument_list|(
literal|"Could not link %s to %s"
argument_list|,
name|skipcrud
operator|+
name|current_file_name
argument_list|,
name|current_link_name
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|S_ISLNK
case|case
name|LF_SYMLINK
case|:
name|again_symlink
label|:
if|if
condition|(
name|f_unlink
operator|&&
operator|!
name|f_keep
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|skipcrud
operator|+
name|current_file_name
argument_list|)
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|msg_perror
argument_list|(
literal|"Could not unlink %s"
argument_list|,
name|skipcrud
operator|+
name|current_file_name
argument_list|)
expr_stmt|;
block|}
name|check
operator|=
name|symlink
argument_list|(
name|current_link_name
argument_list|,
name|skipcrud
operator|+
name|current_file_name
argument_list|)
expr_stmt|;
comment|/* FIXME, don't worry uid, gid, etc... */
if|if
condition|(
name|check
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|make_dirs
argument_list|(
name|current_file_name
operator|+
name|skipcrud
argument_list|)
condition|)
goto|goto
name|again_symlink
goto|;
name|msg_perror
argument_list|(
literal|"Could not create symlink to %s"
argument_list|,
name|current_link_name
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFCHR
case|case
name|LF_CHR
case|:
name|hstat
operator|.
name|st_mode
operator||=
name|S_IFCHR
expr_stmt|;
goto|goto
name|make_node
goto|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFBLK
case|case
name|LF_BLK
case|:
name|hstat
operator|.
name|st_mode
operator||=
name|S_IFBLK
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|S_IFCHR
argument_list|)
operator|||
name|defined
argument_list|(
name|S_IFBLK
argument_list|)
name|make_node
label|:
if|if
condition|(
name|f_unlink
operator|&&
operator|!
name|f_keep
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|skipcrud
operator|+
name|current_file_name
argument_list|)
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|msg_perror
argument_list|(
literal|"Could not unlink %s"
argument_list|,
name|skipcrud
operator|+
name|current_file_name
argument_list|)
expr_stmt|;
block|}
name|check
operator|=
name|mknod
argument_list|(
name|current_file_name
operator|+
name|skipcrud
argument_list|,
operator|(
name|int
operator|)
name|hstat
operator|.
name|st_mode
argument_list|,
operator|(
name|int
operator|)
name|hstat
operator|.
name|st_rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|make_dirs
argument_list|(
name|skipcrud
operator|+
name|current_file_name
argument_list|)
condition|)
goto|goto
name|make_node
goto|;
name|msg_perror
argument_list|(
literal|"Could not make %s"
argument_list|,
name|current_file_name
operator|+
name|skipcrud
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
goto|goto
name|set_filestat
goto|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISFIFO
comment|/* If local system doesn't support FIFOs, use default case */
case|case
name|LF_FIFO
case|:
name|make_fifo
label|:
if|if
condition|(
name|f_unlink
operator|&&
operator|!
name|f_keep
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|skipcrud
operator|+
name|current_file_name
argument_list|)
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|msg_perror
argument_list|(
literal|"Could not unlink %s"
argument_list|,
name|skipcrud
operator|+
name|current_file_name
argument_list|)
expr_stmt|;
block|}
name|check
operator|=
name|mkfifo
argument_list|(
name|current_file_name
operator|+
name|skipcrud
argument_list|,
operator|(
name|int
operator|)
name|hstat
operator|.
name|st_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|make_dirs
argument_list|(
name|current_file_name
operator|+
name|skipcrud
argument_list|)
condition|)
goto|goto
name|make_fifo
goto|;
name|msg_perror
argument_list|(
literal|"Could not make %s"
argument_list|,
name|skipcrud
operator|+
name|current_file_name
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
goto|goto
name|set_filestat
goto|;
endif|#
directive|endif
case|case
name|LF_DIR
case|:
case|case
name|LF_DUMPDIR
case|:
name|namelen
operator|=
name|strlen
argument_list|(
name|current_file_name
operator|+
name|skipcrud
argument_list|)
operator|-
literal|1
expr_stmt|;
name|really_dir
label|:
comment|/* Check for trailing /, and zap as many as we find. */
while|while
condition|(
name|namelen
operator|&&
name|current_file_name
index|[
name|skipcrud
operator|+
name|namelen
index|]
operator|==
literal|'/'
condition|)
name|current_file_name
index|[
name|skipcrud
operator|+
name|namelen
operator|--
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|f_gnudump
condition|)
block|{
comment|/* Read the entry and delete files 					   that aren't listed in the archive */
name|gnu_restore
argument_list|(
name|skipcrud
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|head
operator|->
name|header
operator|.
name|linkflag
operator|==
name|LF_DUMPDIR
condition|)
name|skip_file
argument_list|(
call|(
name|long
call|)
argument_list|(
name|hstat
operator|.
name|st_size
argument_list|)
argument_list|)
expr_stmt|;
name|again_dir
label|:
name|check
operator|=
name|mkdir
argument_list|(
name|skipcrud
operator|+
name|current_file_name
argument_list|,
operator|(
name|we_are_root
condition|?
literal|0
else|:
literal|0300
operator|)
operator||
operator|(
name|int
operator|)
name|hstat
operator|.
name|st_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
operator|!=
literal|0
condition|)
block|{
name|struct
name|stat
name|st1
decl_stmt|;
if|if
condition|(
name|make_dirs
argument_list|(
name|skipcrud
operator|+
name|current_file_name
argument_list|)
condition|)
goto|goto
name|again_dir
goto|;
comment|/* If we're trying to create '.', let it be. */
if|if
condition|(
name|current_file_name
index|[
name|skipcrud
operator|+
name|namelen
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|namelen
operator|==
literal|0
operator|||
name|current_file_name
index|[
name|skipcrud
operator|+
name|namelen
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
goto|goto
name|check_perms
goto|;
if|if
condition|(
name|errno
operator|==
name|EEXIST
operator|&&
name|stat
argument_list|(
name|skipcrud
operator|+
name|current_file_name
argument_list|,
operator|&
name|st1
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|S_ISDIR
argument_list|(
name|st1
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
break|break;
name|msg_perror
argument_list|(
literal|"Could not create directory %s"
argument_list|,
name|skipcrud
operator|+
name|current_file_name
argument_list|)
expr_stmt|;
break|break;
block|}
name|check_perms
label|:
if|if
condition|(
operator|!
name|we_are_root
operator|&&
literal|0300
operator|!=
operator|(
literal|0300
operator|&
operator|(
name|int
operator|)
name|hstat
operator|.
name|st_mode
operator|)
condition|)
block|{
name|hstat
operator|.
name|st_mode
operator||=
literal|0300
expr_stmt|;
name|msg
argument_list|(
literal|"Added write and execute permission to directory %s"
argument_list|,
name|skipcrud
operator|+
name|current_file_name
argument_list|)
expr_stmt|;
block|}
comment|/*        * If we are root, set the owner and group of the extracted        * file.  This does what is wanted both on real Unix and on        * System V.  If we are running as a user, we extract as that        * user; if running as root, we extract as the original owner.        */
if|if
condition|(
name|we_are_root
operator|||
name|f_do_chown
condition|)
block|{
if|if
condition|(
name|chown
argument_list|(
name|skipcrud
operator|+
name|current_file_name
argument_list|,
name|hstat
operator|.
name|st_uid
argument_list|,
name|hstat
operator|.
name|st_gid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"cannot chown file %s to uid %d gid %d"
argument_list|,
name|skipcrud
operator|+
name|current_file_name
argument_list|,
name|hstat
operator|.
name|st_uid
argument_list|,
name|hstat
operator|.
name|st_gid
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|f_modified
condition|)
block|{
name|tmp
operator|=
operator|(
operator|(
expr|struct
name|saved_dir_info
operator|*
operator|)
name|ck_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|saved_dir_info
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|tmp
operator|->
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|ck_malloc
argument_list|(
name|strlen
argument_list|(
name|skipcrud
operator|+
name|current_file_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
operator|->
name|path
argument_list|,
name|skipcrud
operator|+
name|current_file_name
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|mode
operator|=
name|hstat
operator|.
name|st_mode
expr_stmt|;
name|tmp
operator|->
name|atime
operator|=
name|hstat
operator|.
name|st_atime
expr_stmt|;
name|tmp
operator|->
name|mtime
operator|=
name|hstat
operator|.
name|st_mtime
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|saved_dir_info_head
expr_stmt|;
name|saved_dir_info_head
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
comment|/* This functions exactly as the code for set_filestat above. */
if|if
condition|(
operator|(
operator|!
name|f_keep
operator|)
operator|||
operator|(
name|hstat
operator|.
name|st_mode
operator|&
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator||
name|S_ISVTX
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|chmod
argument_list|(
name|skipcrud
operator|+
name|current_file_name
argument_list|,
name|notumask
operator|&
operator|(
name|int
operator|)
name|hstat
operator|.
name|st_mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"cannot change mode of file %s to 0%o"
argument_list|,
name|skipcrud
operator|+
name|current_file_name
argument_list|,
name|notumask
operator|&
operator|(
name|int
operator|)
name|hstat
operator|.
name|st_mode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|LF_VOLHDR
case|:
if|if
condition|(
name|f_verbose
condition|)
block|{
name|printf
argument_list|(
literal|"Reading %s\n"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LF_NAMES
case|:
name|extract_mangle
argument_list|(
name|head
argument_list|)
expr_stmt|;
break|break;
case|case
name|LF_MULTIVOL
case|:
name|msg
argument_list|(
literal|"Can't extract '%s'--file is continued from another volume\n"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
name|skip_file
argument_list|(
operator|(
name|long
operator|)
name|hstat
operator|.
name|st_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|LF_LONGNAME
case|:
case|case
name|LF_LONGLINK
case|:
name|msg
argument_list|(
literal|"Visible long name error\n"
argument_list|)
expr_stmt|;
name|skip_file
argument_list|(
operator|(
name|long
operator|)
name|hstat
operator|.
name|st_size
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* We don't need to save it any longer. */
name|saverec
argument_list|(
operator|(
expr|union
name|record
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Unsave it */
block|}
end_function

begin_comment
comment|/*  * After a file/link/symlink/dir creation has failed, see if  * it's because some required directory was not present, and if  * so, create all required dirs.  */
end_comment

begin_function
name|int
name|make_dirs
parameter_list|(
name|pathname
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Points into path */
name|int
name|madeone
init|=
literal|0
decl_stmt|;
comment|/* Did we do anything yet? */
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
comment|/* Remember caller's errno */
name|int
name|check
decl_stmt|;
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
return|return
literal|0
return|;
comment|/* Not our problem */
for|for
control|(
name|p
operator|=
name|index
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|index
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
control|)
block|{
comment|/* Avoid mkdir of empty string, if leading or double '/' */
if|if
condition|(
name|p
operator|==
name|pathname
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
continue|continue;
comment|/* Avoid mkdir where last part of path is '.' */
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
operator|==
name|pathname
operator|+
literal|1
operator|||
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'/'
operator|)
condition|)
continue|continue;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* Truncate the path there */
name|check
operator|=
name|mkdir
argument_list|(
name|pathname
argument_list|,
literal|0777
argument_list|)
expr_stmt|;
comment|/* Try to create it as a dir */
if|if
condition|(
name|check
operator|==
literal|0
condition|)
block|{
comment|/* Fix ownership */
if|if
condition|(
name|we_are_root
condition|)
block|{
if|if
condition|(
name|chown
argument_list|(
name|pathname
argument_list|,
name|hstat
operator|.
name|st_uid
argument_list|,
name|hstat
operator|.
name|st_gid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"cannot change owner of %s to uid %d gid %d"
argument_list|,
name|pathname
argument_list|,
name|hstat
operator|.
name|st_uid
argument_list|,
name|hstat
operator|.
name|st_gid
argument_list|)
expr_stmt|;
block|}
block|}
name|pr_mkdir
argument_list|(
name|pathname
argument_list|,
name|p
operator|-
name|pathname
argument_list|,
name|notumask
operator|&
literal|0777
argument_list|)
expr_stmt|;
name|madeone
operator|++
expr_stmt|;
comment|/* Remember if we made one */
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
continue|continue;
block|}
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EEXIST
condition|)
comment|/* Directory already exists */
continue|continue;
comment|/* 		 * Some other error in the mkdir.  We return to the caller. 		 */
break|break;
block|}
name|errno
operator|=
name|save_errno
expr_stmt|;
comment|/* Restore caller's errno */
return|return
name|madeone
return|;
comment|/* Tell them to retry if we made one */
block|}
end_function

begin_function
name|void
name|extract_sparse_file
parameter_list|(
name|fd
parameter_list|,
name|sizeleft
parameter_list|,
name|totalsize
parameter_list|,
name|name
parameter_list|)
name|int
name|fd
decl_stmt|;
name|long
modifier|*
name|sizeleft
decl_stmt|,
name|totalsize
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
comment|/*	register char	*data;*/
name|union
name|record
modifier|*
name|datarec
decl_stmt|;
name|int
name|sparse_ind
init|=
literal|0
decl_stmt|;
name|int
name|written
decl_stmt|,
name|count
decl_stmt|;
comment|/* assuming sizeleft is initially totalsize */
while|while
condition|(
operator|*
name|sizeleft
operator|>
literal|0
condition|)
block|{
name|datarec
operator|=
name|findrec
argument_list|()
expr_stmt|;
if|if
condition|(
name|datarec
operator|==
name|NULL
condition|)
block|{
name|msg
argument_list|(
literal|"Unexpected EOF on archive file"
argument_list|)
expr_stmt|;
return|return;
block|}
name|lseek
argument_list|(
name|fd
argument_list|,
name|sparsearray
index|[
name|sparse_ind
index|]
operator|.
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|written
operator|=
name|sparsearray
index|[
name|sparse_ind
operator|++
index|]
operator|.
name|numbytes
expr_stmt|;
while|while
condition|(
name|written
operator|>
name|RECORDSIZE
condition|)
block|{
name|count
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|datarec
operator|->
name|charptr
argument_list|,
name|RECORDSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|msg_perror
argument_list|(
literal|"couldn't write to file %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|written
operator|-=
name|count
expr_stmt|;
operator|*
name|sizeleft
operator|-=
name|count
expr_stmt|;
name|userec
argument_list|(
name|datarec
argument_list|)
expr_stmt|;
name|datarec
operator|=
name|findrec
argument_list|()
expr_stmt|;
block|}
name|count
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|datarec
operator|->
name|charptr
argument_list|,
name|written
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"couldn't write to file %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|!=
name|written
condition|)
block|{
name|msg
argument_list|(
literal|"could only write %d of %d bytes to file %s"
argument_list|,
name|count
argument_list|,
name|totalsize
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|skip_file
argument_list|(
call|(
name|long
call|)
argument_list|(
operator|*
name|sizeleft
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|written
operator|-=
name|count
expr_stmt|;
operator|*
name|sizeleft
operator|-=
name|count
expr_stmt|;
name|userec
argument_list|(
name|datarec
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sparsearray
argument_list|)
expr_stmt|;
comment|/*	if (end_nulls) { 		register int i;  		printf("%d\n", (int) end_nulls); 		for (i = 0; i< end_nulls; i++) 			write(fd, "\000", 1); 	}*/
name|userec
argument_list|(
name|datarec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set back the utime and mode for all the extracted directories. */
end_comment

begin_function
name|void
name|restore_saved_dir_info
parameter_list|()
block|{
name|struct
name|utimbuf
name|acc_upd_times
decl_stmt|;
while|while
condition|(
name|saved_dir_info_head
operator|!=
name|NULL
condition|)
block|{
comment|/* fixme if f_gnudump should set ctime too, but how? */
if|if
condition|(
name|f_gnudump
condition|)
name|acc_upd_times
operator|.
name|actime
operator|=
name|saved_dir_info_head
operator|->
name|atime
expr_stmt|;
else|else
name|acc_upd_times
operator|.
name|actime
operator|=
name|now
expr_stmt|;
comment|/* Accessed now */
name|acc_upd_times
operator|.
name|modtime
operator|=
name|saved_dir_info_head
operator|->
name|mtime
expr_stmt|;
comment|/* Mod'd */
if|if
condition|(
name|utime
argument_list|(
name|saved_dir_info_head
operator|->
name|path
argument_list|,
operator|&
name|acc_upd_times
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"couldn't change access and modification times of %s"
argument_list|,
name|saved_dir_info_head
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|f_keep
operator|)
operator|||
operator|(
name|saved_dir_info_head
operator|->
name|mode
operator|&
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator||
name|S_ISVTX
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|chmod
argument_list|(
name|saved_dir_info_head
operator|->
name|path
argument_list|,
name|notumask
operator|&
name|saved_dir_info_head
operator|->
name|mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"cannot change mode of file %s to 0%o"
argument_list|,
name|saved_dir_info_head
operator|->
name|path
argument_list|,
name|notumask
operator|&
name|saved_dir_info_head
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
block|}
name|saved_dir_info_head
operator|=
name|saved_dir_info_head
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

end_unit

