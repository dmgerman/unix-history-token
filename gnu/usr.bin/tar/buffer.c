begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Buffer management for tar.    Copyright (C) 1988, 1992, 1993 Free Software Foundation  This file is part of GNU Tar.  GNU Tar is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Tar is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Tar; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/*  * Buffer management for tar.  *  * Written by John Gilmore, ihnp4!hoptoad!gnu, on 25 August 1985.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|STDC_HEADERS
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* For non-Berkeley systems */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_function_decl
name|time_t
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_MTIO_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|V7
end_ifndef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__MSDOS__
end_ifdef

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|XENIX
end_ifdef

begin_include
include|#
directive|include
file|<sys/inode.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"tar.h"
end_include

begin_include
include|#
directive|include
file|"port.h"
end_include

begin_include
include|#
directive|include
file|"rmt.h"
end_include

begin_include
include|#
directive|include
file|"gnuregex.h"
end_include

begin_comment
comment|/* Either stdout or stderr:  The thing we write messages (standard msgs, not    errors) to.  Stdout unless we're writing a pipe, in which case stderr */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|msg_file
init|=
name|stdout
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|STDIN
value|0
end_define

begin_comment
comment|/* Standard input  file descriptor */
end_comment

begin_define
define|#
directive|define
name|STDOUT
value|1
end_define

begin_comment
comment|/* Standard output file descriptor */
end_comment

begin_define
define|#
directive|define
name|PREAD
value|0
end_define

begin_comment
comment|/* Read  file descriptor from pipe() */
end_comment

begin_define
define|#
directive|define
name|PWRITE
value|1
end_define

begin_comment
comment|/* Write file descriptor from pipe() */
end_comment

begin_define
define|#
directive|define
name|MAGIC_STAT
value|105
end_define

begin_comment
comment|/* Magic status returned by child, if 				   it can't exec.  We hope compress/sh 				   never return this status! */
end_comment

begin_function_decl
name|void
modifier|*
name|valloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|writeerror
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|readerror
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ck_pipe
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ck_close
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|backspace_output
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|finish_header
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|flush_archive
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|isfile
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|new_volume
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|verify_volume
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|to_oct
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|__MSDOS__
end_ifndef

begin_comment
comment|/* Obnoxious test to see if dimwit is trying to dump the archive */
end_comment

begin_decl_stmt
name|dev_t
name|ar_dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ino_t
name|ar_ino
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The record pointed to by save_rec should not be overlaid  * when reading in a new tape block.  Copy it to record_save_area first, and  * change the pointer in *save_rec to point to record_save_area.  * Saved_recno records the record number at the time of the save.  * This is used by annofile() to print the record number of a file's  * header record.  */
end_comment

begin_decl_stmt
specifier|static
name|union
name|record
modifier|*
modifier|*
name|save_rec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|union
name|record
name|record_save_area
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|saved_recno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * PID of child program, if f_compress or remote archive access.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|childpid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Record number of the start of this block of records  */
end_comment

begin_decl_stmt
name|long
name|baserec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Error recovery stuff  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|r_error_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Have we hit EOF yet?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hit_eof
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Checkpointing counter */
end_comment

begin_decl_stmt
specifier|static
name|int
name|checkpoint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* JF we're reading, but we just read the last record and its time to update */
end_comment

begin_extern
extern|extern time_to_start_writing;
end_extern

begin_decl_stmt
name|int
name|file_to_switch_to
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If remote update, close archive, and use 				   this descriptor to write to */
end_comment

begin_decl_stmt
specifier|static
name|int
name|volno
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* JF which volume of a multi-volume tape 				   we're on */
end_comment

begin_decl_stmt
specifier|static
name|int
name|global_volno
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Volume number to print in external messages. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|save_name
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of the file we are currently writing */
end_comment

begin_decl_stmt
name|long
name|save_totsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total size of file we are writing.  Only 				   valid if save_name is non_zero */
end_comment

begin_decl_stmt
name|long
name|save_sizeleft
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where we are in the file we are writing. 				   Only valid if save_name is non-zero */
end_comment

begin_decl_stmt
name|int
name|write_archive_to_stdout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used by fl_read and fl_write to store the real info about saved names */
end_comment

begin_decl_stmt
specifier|static
name|char
name|real_s_name
index|[
name|NAMSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|real_s_totsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|real_s_sizeleft
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reset the EOF flag (if set), and re-set ar_record, etc */
end_comment

begin_function
name|void
name|reset_eof
parameter_list|()
block|{
if|if
condition|(
name|hit_eof
condition|)
block|{
name|hit_eof
operator|=
literal|0
expr_stmt|;
name|ar_record
operator|=
name|ar_block
expr_stmt|;
name|ar_last
operator|=
name|ar_block
operator|+
name|blocking
expr_stmt|;
name|ar_reading
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return the location of the next available input or output record.  * Return NULL for EOF.  Once we have returned NULL, we just keep returning  * it, to avoid accidentally going on to the next file on the "tape".  */
end_comment

begin_function
name|union
name|record
modifier|*
name|findrec
parameter_list|()
block|{
if|if
condition|(
name|ar_record
operator|==
name|ar_last
condition|)
block|{
if|if
condition|(
name|hit_eof
condition|)
return|return
operator|(
expr|union
name|record
operator|*
operator|)
name|NULL
return|;
comment|/* EOF */
name|flush_archive
argument_list|()
expr_stmt|;
if|if
condition|(
name|ar_record
operator|==
name|ar_last
condition|)
block|{
name|hit_eof
operator|++
expr_stmt|;
return|return
operator|(
expr|union
name|record
operator|*
operator|)
name|NULL
return|;
comment|/* EOF */
block|}
block|}
return|return
name|ar_record
return|;
block|}
end_function

begin_comment
comment|/*  * Indicate that we have used all records up thru the argument.  * (should the arg have an off-by-1? XXX FIXME)  */
end_comment

begin_function
name|void
name|userec
parameter_list|(
name|rec
parameter_list|)
name|union
name|record
modifier|*
name|rec
decl_stmt|;
block|{
while|while
condition|(
name|rec
operator|>=
name|ar_record
condition|)
name|ar_record
operator|++
expr_stmt|;
comment|/* 	 * Do NOT flush the archive here.  If we do, the same 	 * argument to userec() could mean the next record (if the 	 * input block is exactly one record long), which is not what 	 * is intended. 	 */
if|if
condition|(
name|ar_record
operator|>
name|ar_last
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return a pointer to the end of the current records buffer.  * All the space between findrec() and endofrecs() is available  * for filling with data, or taking data from.  */
end_comment

begin_function
name|union
name|record
modifier|*
name|endofrecs
parameter_list|()
block|{
return|return
name|ar_last
return|;
block|}
end_function

begin_comment
comment|/*  * Duplicate a file descriptor into a certain slot.  * Equivalent to BSD "dup2" with error reporting.  */
end_comment

begin_function
name|void
name|dupto
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|msg
parameter_list|)
name|int
name|from
decl_stmt|,
name|to
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|from
operator|!=
name|to
condition|)
block|{
name|err
operator|=
name|close
argument_list|(
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EBADF
condition|)
block|{
name|msg_perror
argument_list|(
literal|"Cannot close descriptor %d"
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SYSTEM
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|dup
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|to
condition|)
block|{
name|msg_perror
argument_list|(
literal|"cannot dup %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SYSTEM
argument_list|)
expr_stmt|;
block|}
name|ck_close
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__MSDOS__
end_ifdef

begin_function
name|void
name|child_open
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"MS-DOS %s can't use compressed or remote archives\n"
argument_list|,
name|tar
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|child_open
parameter_list|()
block|{
name|int
name|pipe
index|[
literal|2
index|]
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|kidpipe
index|[
literal|2
index|]
decl_stmt|;
name|int
name|kidchildpid
decl_stmt|;
define|#
directive|define
name|READ
value|0
define|#
directive|define
name|WRITE
value|1
name|ck_pipe
argument_list|(
name|pipe
argument_list|)
expr_stmt|;
name|childpid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|childpid
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"cannot fork"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SYSTEM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|childpid
operator|>
literal|0
condition|)
block|{
comment|/* We're the parent.  Clean up and be happy */
comment|/* This, at least, is easy */
if|if
condition|(
name|ar_reading
condition|)
block|{
name|f_reblock
operator|++
expr_stmt|;
name|archive
operator|=
name|pipe
index|[
name|READ
index|]
expr_stmt|;
name|ck_close
argument_list|(
name|pipe
index|[
name|WRITE
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|archive
operator|=
name|pipe
index|[
name|WRITE
index|]
expr_stmt|;
name|ck_close
argument_list|(
name|pipe
index|[
name|READ
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* We're the kid */
if|if
condition|(
name|ar_reading
condition|)
block|{
name|dupto
argument_list|(
name|pipe
index|[
name|WRITE
index|]
argument_list|,
name|STDOUT
argument_list|,
literal|"(child) pipe to stdout"
argument_list|)
expr_stmt|;
name|ck_close
argument_list|(
name|pipe
index|[
name|READ
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dupto
argument_list|(
name|pipe
index|[
name|READ
index|]
argument_list|,
name|STDIN
argument_list|,
literal|"(child) pipe to stdin"
argument_list|)
expr_stmt|;
name|ck_close
argument_list|(
name|pipe
index|[
name|WRITE
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* We need a child tar only if 	   1: we're reading/writing stdin/out (to force reblocking) 	   2: the file is to be accessed by rmt (compress doesn't know how) 	   3: the file is not a plain file */
ifdef|#
directive|ifdef
name|NO_REMOTE
if|if
condition|(
operator|!
operator|(
name|ar_files
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|ar_files
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|&&
name|isfile
argument_list|(
name|ar_files
index|[
literal|0
index|]
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|ar_files
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|ar_files
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|&&
operator|!
name|_remdev
argument_list|(
name|ar_files
index|[
literal|0
index|]
argument_list|)
operator|&&
name|isfile
argument_list|(
name|ar_files
index|[
literal|0
index|]
argument_list|)
condition|)
endif|#
directive|endif
block|{
comment|/* We don't need a child tar.  Open the archive */
if|if
condition|(
name|ar_reading
condition|)
block|{
name|archive
operator|=
name|open
argument_list|(
name|ar_files
index|[
literal|0
index|]
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"can't open archive %s"
argument_list|,
name|ar_files
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_BADARCH
argument_list|)
expr_stmt|;
block|}
name|dupto
argument_list|(
name|archive
argument_list|,
name|STDIN
argument_list|,
literal|"archive to stdin"
argument_list|)
expr_stmt|;
comment|/* close(archive); */
block|}
else|else
block|{
name|archive
operator|=
name|creat
argument_list|(
name|ar_files
index|[
literal|0
index|]
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"can't open archive %s"
argument_list|,
name|ar_files
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_BADARCH
argument_list|)
expr_stmt|;
block|}
name|dupto
argument_list|(
name|archive
argument_list|,
name|STDOUT
argument_list|,
literal|"archive to stdout"
argument_list|)
expr_stmt|;
comment|/* close(archive); */
block|}
block|}
else|else
block|{
comment|/* We need a child tar */
name|ck_pipe
argument_list|(
name|kidpipe
argument_list|)
expr_stmt|;
name|kidchildpid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|kidchildpid
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"child can't fork"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SYSTEM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kidchildpid
operator|>
literal|0
condition|)
block|{
comment|/* About to exec compress:  set up the files */
if|if
condition|(
name|ar_reading
condition|)
block|{
name|dupto
argument_list|(
name|kidpipe
index|[
name|READ
index|]
argument_list|,
name|STDIN
argument_list|,
literal|"((child)) pipe to stdin"
argument_list|)
expr_stmt|;
name|ck_close
argument_list|(
name|kidpipe
index|[
name|WRITE
index|]
argument_list|)
expr_stmt|;
comment|/* dup2(pipe[WRITE],STDOUT); */
block|}
else|else
block|{
comment|/* dup2(pipe[READ],STDIN); */
name|dupto
argument_list|(
name|kidpipe
index|[
name|WRITE
index|]
argument_list|,
name|STDOUT
argument_list|,
literal|"((child)) pipe to stdout"
argument_list|)
expr_stmt|;
name|ck_close
argument_list|(
name|kidpipe
index|[
name|READ
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* ck_close(pipe[READ]); */
comment|/* ck_close(pipe[WRITE]); */
comment|/* ck_close(kidpipe[READ]); 			ck_close(kidpipe[WRITE]); */
block|}
else|else
block|{
comment|/* Grandchild.  Do the right thing, namely sit here and 		   read/write the archive, and feed stuff back to compress */
name|tar
operator|=
literal|"tar (child)"
expr_stmt|;
if|if
condition|(
name|ar_reading
condition|)
block|{
name|dupto
argument_list|(
name|kidpipe
index|[
name|WRITE
index|]
argument_list|,
name|STDOUT
argument_list|,
literal|"[child] pipe to stdout"
argument_list|)
expr_stmt|;
name|ck_close
argument_list|(
name|kidpipe
index|[
name|READ
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dupto
argument_list|(
name|kidpipe
index|[
name|READ
index|]
argument_list|,
name|STDIN
argument_list|,
literal|"[child] pipe to stdin"
argument_list|)
expr_stmt|;
name|ck_close
argument_list|(
name|kidpipe
index|[
name|WRITE
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ar_files
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|ar_files
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|ar_reading
condition|)
name|archive
operator|=
name|STDIN
expr_stmt|;
else|else
name|archive
operator|=
name|STDOUT
expr_stmt|;
block|}
elseif|else
comment|/* This can't happen if (ar_reading==2) 				archive = rmtopen(ar_files[0], O_RDWR|O_CREAT|O_BINARY, 0666); 	  	  			else */
if|if
condition|(
name|ar_reading
condition|)
name|archive
operator|=
name|rmtopen
argument_list|(
name|ar_files
index|[
literal|0
index|]
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
else|else
name|archive
operator|=
name|rmtcreat
argument_list|(
name|ar_files
index|[
literal|0
index|]
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"can't open archive %s"
argument_list|,
name|ar_files
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_BADARCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ar_reading
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|max
decl_stmt|,
name|count
decl_stmt|;
name|r_error_count
operator|=
literal|0
expr_stmt|;
name|error_loop
label|:
name|err
operator|=
name|rmtread
argument_list|(
name|archive
argument_list|,
name|ar_block
operator|->
name|charptr
argument_list|,
call|(
name|int
call|)
argument_list|(
name|blocksize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
name|readerror
argument_list|()
expr_stmt|;
goto|goto
name|error_loop
goto|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
break|break;
name|ptr
operator|=
name|ar_block
operator|->
name|charptr
expr_stmt|;
name|max
operator|=
name|err
expr_stmt|;
while|while
condition|(
name|max
condition|)
block|{
name|count
operator|=
operator|(
name|max
operator|<
name|RECORDSIZE
operator|)
condition|?
name|max
else|:
name|RECORDSIZE
expr_stmt|;
name|err
operator|=
name|write
argument_list|(
name|STDOUT
argument_list|,
name|ptr
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|count
condition|)
block|{
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"can't write to compression program"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SYSTEM
argument_list|)
expr_stmt|;
block|}
else|else
name|msg
argument_list|(
literal|"write to compression program short %d bytes"
argument_list|,
name|count
operator|-
name|err
argument_list|)
expr_stmt|;
name|count
operator|=
operator|(
name|err
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|err
expr_stmt|;
block|}
name|ptr
operator|+=
name|count
expr_stmt|;
name|max
operator|-=
name|count
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|n
operator|=
name|blocksize
expr_stmt|;
name|ptr
operator|=
name|ar_block
operator|->
name|charptr
expr_stmt|;
while|while
condition|(
name|n
condition|)
block|{
name|err
operator|=
name|read
argument_list|(
name|STDIN
argument_list|,
name|ptr
argument_list|,
operator|(
name|n
operator|<
name|RECORDSIZE
operator|)
condition|?
name|n
else|:
name|RECORDSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<=
literal|0
condition|)
break|break;
name|n
operator|-=
name|err
expr_stmt|;
name|ptr
operator|+=
name|err
expr_stmt|;
block|}
comment|/* EOF */
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|f_compress_block
condition|)
name|blocksize
operator|-=
name|n
expr_stmt|;
else|else
name|bzero
argument_list|(
name|ar_block
operator|->
name|charptr
operator|+
name|blocksize
operator|-
name|n
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|err
operator|=
name|rmtwrite
argument_list|(
name|archive
argument_list|,
name|ar_block
operator|->
name|charptr
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
operator|(
name|blocksize
operator|)
condition|)
name|writeerror
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f_compress_block
condition|)
name|blocksize
operator|+=
name|n
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
condition|)
block|{
name|msg_perror
argument_list|(
literal|"can't read from compression program"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SYSTEM
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|rmtwrite
argument_list|(
name|archive
argument_list|,
name|ar_block
operator|->
name|charptr
argument_list|,
operator|(
name|int
operator|)
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|blocksize
condition|)
name|writeerror
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* close_archive(); */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* So we should exec compress (-d) */
if|if
condition|(
name|ar_reading
condition|)
name|execlp
argument_list|(
name|f_compressprog
argument_list|,
name|f_compressprog
argument_list|,
literal|"-d"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
name|execlp
argument_list|(
name|f_compressprog
argument_list|,
name|f_compressprog
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|msg_perror
argument_list|(
literal|"can't exec %s"
argument_list|,
name|f_compressprog
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|EX_SYSTEM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* return non-zero if p is the name of a directory */
end_comment

begin_function
name|int
name|isfile
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|p
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|stbuf
operator|.
name|st_mode
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Open an archive file.  The argument specifies whether we are  * reading or writing.  */
end_comment

begin_comment
comment|/* JF if the arg is 2, open for reading and writing. */
end_comment

begin_function
name|void
name|open_archive
parameter_list|(
name|reading
parameter_list|)
name|int
name|reading
decl_stmt|;
block|{
name|msg_file
operator|=
name|f_exstdout
condition|?
name|stderr
else|:
name|stdout
expr_stmt|;
if|if
condition|(
name|blocksize
operator|==
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"invalid value for blocksize"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n_ar_files
operator|==
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"No archive name given, what should I do?"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_BADARCH
argument_list|)
expr_stmt|;
block|}
comment|/*NOSTRICT*/
if|if
condition|(
name|f_multivol
condition|)
block|{
name|ar_block
operator|=
operator|(
expr|union
name|record
operator|*
operator|)
name|valloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|blocksize
operator|+
operator|(
literal|2
operator|*
name|RECORDSIZE
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar_block
condition|)
name|ar_block
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|ar_block
operator|=
operator|(
expr|union
name|record
operator|*
operator|)
name|valloc
argument_list|(
operator|(
name|unsigned
operator|)
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ar_block
condition|)
block|{
name|msg
argument_list|(
literal|"could not allocate memory for blocking factor %d"
argument_list|,
name|blocking
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
name|ar_record
operator|=
name|ar_block
expr_stmt|;
name|ar_last
operator|=
name|ar_block
operator|+
name|blocking
expr_stmt|;
name|ar_reading
operator|=
name|reading
expr_stmt|;
if|if
condition|(
name|f_multivol
operator|&&
name|f_verify
condition|)
block|{
name|msg
argument_list|(
literal|"cannot verify multi-volume archives"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f_compressprog
condition|)
block|{
if|if
condition|(
name|reading
operator|==
literal|2
operator|||
name|f_verify
condition|)
block|{
name|msg
argument_list|(
literal|"cannot update or verify compressed archives"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f_multivol
condition|)
block|{
name|msg
argument_list|(
literal|"cannot use multi-volume compressed archives"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
name|child_open
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|reading
operator|&&
name|ar_files
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|ar_files
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|msg_file
operator|=
name|stderr
expr_stmt|;
comment|/* child_open(rem_host, rem_file); */
block|}
elseif|else
if|if
condition|(
name|ar_files
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|ar_files
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|f_reblock
operator|++
expr_stmt|;
comment|/* Could be a pipe, be safe */
if|if
condition|(
name|f_verify
condition|)
block|{
name|msg
argument_list|(
literal|"can't verify stdin/stdout archive"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reading
operator|==
literal|2
condition|)
block|{
name|archive
operator|=
name|STDIN
expr_stmt|;
name|msg_file
operator|=
name|stderr
expr_stmt|;
name|write_archive_to_stdout
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reading
condition|)
name|archive
operator|=
name|STDIN
expr_stmt|;
else|else
block|{
name|archive
operator|=
name|STDOUT
expr_stmt|;
name|msg_file
operator|=
name|stderr
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|reading
operator|==
literal|2
operator|||
name|f_verify
condition|)
block|{
name|archive
operator|=
name|rmtopen
argument_list|(
name|ar_files
index|[
literal|0
index|]
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_BINARY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reading
condition|)
block|{
name|archive
operator|=
name|rmtopen
argument_list|(
name|ar_files
index|[
literal|0
index|]
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|archive
operator|=
name|rmtcreat
argument_list|(
name|ar_files
index|[
literal|0
index|]
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|archive
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"can't open %s"
argument_list|,
name|ar_files
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_BADARCH
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|__MSDOS__
if|if
condition|(
operator|!
name|_isrmt
argument_list|(
name|archive
argument_list|)
condition|)
block|{
name|struct
name|stat
name|tmp_stat
decl_stmt|;
name|fstat
argument_list|(
name|archive
argument_list|,
operator|&
name|tmp_stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|tmp_stat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|ar_dev
operator|=
name|tmp_stat
operator|.
name|st_dev
expr_stmt|;
name|ar_ino
operator|=
name|tmp_stat
operator|.
name|st_ino
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__MSDOS__
name|setmode
argument_list|(
name|archive
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|reading
condition|)
block|{
name|ar_last
operator|=
name|ar_block
expr_stmt|;
comment|/* Set up for 1st block = # 0 */
operator|(
name|void
operator|)
name|findrec
argument_list|()
expr_stmt|;
comment|/* Read it in, check for EOF */
if|if
condition|(
name|f_volhdr
condition|)
block|{
name|union
name|record
modifier|*
name|head
decl_stmt|;
if|#
directive|if
literal|0
block|char *ptr;  	  if (f_multivol) 	    { 	      ptr = malloc (strlen (f_volhdr) + 20); 	      sprintf (ptr, "%s Volume %d", f_volhdr, 1); 	    } 	  else 	    ptr = f_volhdr;
endif|#
directive|endif
name|head
operator|=
name|findrec
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|head
condition|)
block|{
name|msg
argument_list|(
literal|"Archive not labelled to match %s"
argument_list|,
name|f_volhdr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_BADVOL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|re_match
argument_list|(
name|label_pattern
argument_list|,
name|head
operator|->
name|header
operator|.
name|arch_name
argument_list|,
name|strlen
argument_list|(
name|head
operator|->
name|header
operator|.
name|arch_name
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"Volume mismatch!  %s!=%s"
argument_list|,
name|f_volhdr
argument_list|,
name|head
operator|->
name|header
operator|.
name|arch_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_BADVOL
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (strcmp (ptr, head->header.name)) 	    { 	      msg ("Volume mismatch!  %s!=%s", ptr, head->header.name); 	      exit (EX_BADVOL); 	    } 	  if (ptr != f_volhdr) 	    free (ptr);
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
name|f_volhdr
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ar_block
argument_list|,
name|RECORDSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_multivol
condition|)
name|sprintf
argument_list|(
name|ar_block
operator|->
name|header
operator|.
name|arch_name
argument_list|,
literal|"%s Volume 1"
argument_list|,
name|f_volhdr
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|ar_block
operator|->
name|header
operator|.
name|arch_name
argument_list|,
name|f_volhdr
argument_list|)
expr_stmt|;
name|current_file_name
operator|=
name|ar_block
operator|->
name|header
operator|.
name|arch_name
expr_stmt|;
name|ar_block
operator|->
name|header
operator|.
name|linkflag
operator|=
name|LF_VOLHDR
expr_stmt|;
name|to_oct
argument_list|(
name|time
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|1
operator|+
literal|12
argument_list|,
name|ar_block
operator|->
name|header
operator|.
name|mtime
argument_list|)
expr_stmt|;
name|finish_header
argument_list|(
name|ar_block
argument_list|)
expr_stmt|;
comment|/* ar_record++; */
block|}
block|}
end_function

begin_comment
comment|/*  * Remember a union record * as pointing to something that we  * need to keep when reading onward in the file.  Only one such  * thing can be remembered at once, and it only works when reading  * an archive.  *  * We calculate "offset" then add it because some compilers end up  * adding (baserec+ar_record), doing a 9-bit shift of baserec, then  * subtracting ar_block from that, shifting it back, losing the top 9 bits.  */
end_comment

begin_function
name|void
name|saverec
parameter_list|(
name|pointer
parameter_list|)
name|union
name|record
modifier|*
modifier|*
name|pointer
decl_stmt|;
block|{
name|long
name|offset
decl_stmt|;
name|save_rec
operator|=
name|pointer
expr_stmt|;
name|offset
operator|=
name|ar_record
operator|-
name|ar_block
expr_stmt|;
name|saved_recno
operator|=
name|baserec
operator|+
name|offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform a write to flush the buffer.  */
end_comment

begin_comment
comment|/*send_buffer_to_file();   if(new_volume) {   	deal_with_new_volume_stuff(); 	send_buffer_to_file();   }  */
end_comment

begin_function
name|void
name|fl_write
parameter_list|()
block|{
name|int
name|err
decl_stmt|;
name|int
name|copy_back
decl_stmt|;
specifier|static
name|long
name|bytes_written
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|f_checkpoint
operator|&&
operator|!
operator|(
operator|++
name|checkpoint
operator|%
literal|10
operator|)
condition|)
name|msg
argument_list|(
literal|"Write checkpoint %d\n"
argument_list|,
name|checkpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|tape_length
operator|&&
name|bytes_written
operator|>=
name|tape_length
operator|*
literal|1024
condition|)
block|{
name|errno
operator|=
name|ENOSPC
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|err
operator|=
name|rmtwrite
argument_list|(
name|archive
argument_list|,
name|ar_block
operator|->
name|charptr
argument_list|,
operator|(
name|int
operator|)
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|blocksize
operator|&&
operator|!
name|f_multivol
condition|)
name|writeerror
argument_list|(
name|err
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|f_totals
condition|)
name|tot_written
operator|+=
name|blocksize
expr_stmt|;
if|if
condition|(
name|err
operator|>
literal|0
condition|)
name|bytes_written
operator|+=
name|err
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|blocksize
condition|)
block|{
if|if
condition|(
name|f_multivol
condition|)
block|{
if|if
condition|(
operator|!
name|save_name
condition|)
block|{
name|real_s_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|real_s_totsize
operator|=
literal|0
expr_stmt|;
name|real_s_sizeleft
operator|=
literal|0
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|__MSDOS__
if|if
condition|(
name|save_name
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|save_name
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|*
name|save_name
operator|==
literal|'/'
condition|)
name|save_name
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|real_s_name
argument_list|,
name|save_name
argument_list|)
expr_stmt|;
name|real_s_totsize
operator|=
name|save_totsize
expr_stmt|;
name|real_s_sizeleft
operator|=
name|save_sizeleft
expr_stmt|;
block|}
return|return;
block|}
comment|/* We're multivol  Panic if we didn't get the right kind of response */
comment|/* ENXIO is for the UNIX PC */
if|if
condition|(
name|err
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOSPC
operator|&&
name|errno
operator|!=
name|EIO
operator|&&
name|errno
operator|!=
name|ENXIO
condition|)
name|writeerror
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* If error indicates a short write, we just move to the next tape. */
if|if
condition|(
name|new_volume
argument_list|(
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|bytes_written
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|f_volhdr
operator|&&
name|real_s_name
index|[
literal|0
index|]
condition|)
block|{
name|copy_back
operator|=
literal|2
expr_stmt|;
name|ar_block
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f_volhdr
operator|||
name|real_s_name
index|[
literal|0
index|]
condition|)
block|{
name|copy_back
operator|=
literal|1
expr_stmt|;
name|ar_block
operator|--
expr_stmt|;
block|}
else|else
name|copy_back
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|f_volhdr
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ar_block
argument_list|,
name|RECORDSIZE
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|ar_block
operator|->
name|header
operator|.
name|arch_name
argument_list|,
literal|"%s Volume %d"
argument_list|,
name|f_volhdr
argument_list|,
name|volno
argument_list|)
expr_stmt|;
name|to_oct
argument_list|(
name|time
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|1
operator|+
literal|12
argument_list|,
name|ar_block
operator|->
name|header
operator|.
name|mtime
argument_list|)
expr_stmt|;
name|ar_block
operator|->
name|header
operator|.
name|linkflag
operator|=
name|LF_VOLHDR
expr_stmt|;
name|finish_header
argument_list|(
name|ar_block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|real_s_name
index|[
literal|0
index|]
condition|)
block|{
name|int
name|tmp
decl_stmt|;
if|if
condition|(
name|f_volhdr
condition|)
name|ar_block
operator|++
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ar_block
argument_list|,
name|RECORDSIZE
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ar_block
operator|->
name|header
operator|.
name|arch_name
argument_list|,
name|real_s_name
argument_list|)
expr_stmt|;
name|ar_block
operator|->
name|header
operator|.
name|linkflag
operator|=
name|LF_MULTIVOL
expr_stmt|;
name|to_oct
argument_list|(
operator|(
name|long
operator|)
name|real_s_sizeleft
argument_list|,
literal|1
operator|+
literal|12
argument_list|,
name|ar_block
operator|->
name|header
operator|.
name|size
argument_list|)
expr_stmt|;
name|to_oct
argument_list|(
operator|(
name|long
operator|)
name|real_s_totsize
operator|-
name|real_s_sizeleft
argument_list|,
literal|1
operator|+
literal|12
argument_list|,
name|ar_block
operator|->
name|header
operator|.
name|offset
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|f_verbose
expr_stmt|;
name|f_verbose
operator|=
literal|0
expr_stmt|;
name|finish_header
argument_list|(
name|ar_block
argument_list|)
expr_stmt|;
name|f_verbose
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|f_volhdr
condition|)
name|ar_block
operator|--
expr_stmt|;
block|}
name|err
operator|=
name|rmtwrite
argument_list|(
name|archive
argument_list|,
name|ar_block
operator|->
name|charptr
argument_list|,
operator|(
name|int
operator|)
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|blocksize
condition|)
name|writeerror
argument_list|(
name|err
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|f_totals
condition|)
name|tot_written
operator|+=
name|blocksize
expr_stmt|;
name|bytes_written
operator|=
name|blocksize
expr_stmt|;
if|if
condition|(
name|copy_back
condition|)
block|{
name|ar_block
operator|+=
name|copy_back
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|ar_block
operator|+
name|blocking
operator|-
name|copy_back
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ar_record
argument_list|,
name|copy_back
operator|*
name|RECORDSIZE
argument_list|)
expr_stmt|;
name|ar_record
operator|+=
name|copy_back
expr_stmt|;
if|if
condition|(
name|real_s_sizeleft
operator|>=
name|copy_back
operator|*
name|RECORDSIZE
condition|)
name|real_s_sizeleft
operator|-=
name|copy_back
operator|*
name|RECORDSIZE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|real_s_sizeleft
operator|+
name|RECORDSIZE
operator|-
literal|1
operator|)
operator|/
name|RECORDSIZE
operator|<=
name|copy_back
condition|)
name|real_s_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|__MSDOS__
if|if
condition|(
name|save_name
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|save_name
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|*
name|save_name
operator|==
literal|'/'
condition|)
name|save_name
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|real_s_name
argument_list|,
name|save_name
argument_list|)
expr_stmt|;
name|real_s_sizeleft
operator|=
name|save_sizeleft
expr_stmt|;
name|real_s_totsize
operator|=
name|save_totsize
expr_stmt|;
block|}
name|copy_back
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle write errors on the archive.  Write errors are always fatal */
end_comment

begin_comment
comment|/* Hitting the end of a volume does not cause a write error unless the write *  was the first block of the volume */
end_comment

begin_function
name|void
name|writeerror
parameter_list|(
name|err
parameter_list|)
name|int
name|err
decl_stmt|;
block|{
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"can't write to %s"
argument_list|,
name|ar_files
index|[
name|cur_ar_file
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_BADARCH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msg
argument_list|(
literal|"only wrote %u of %u bytes to %s"
argument_list|,
name|err
argument_list|,
name|blocksize
argument_list|,
name|ar_files
index|[
name|cur_ar_file
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_BADARCH
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle read errors on the archive.  *  * If the read should be retried, readerror() returns to the caller.  */
end_comment

begin_function
name|void
name|readerror
parameter_list|()
block|{
define|#
directive|define
name|READ_ERROR_MAX
value|10
name|read_error_flag
operator|++
expr_stmt|;
comment|/* Tell callers */
name|msg_perror
argument_list|(
literal|"read error on %s"
argument_list|,
name|ar_files
index|[
name|cur_ar_file
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|baserec
operator|==
literal|0
condition|)
block|{
comment|/* First block of tape.  Probably stupidity error */
name|exit
argument_list|(
name|EX_BADARCH
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Read error in mid archive.  We retry up to READ_ERROR_MAX times 	 * and then give up on reading the archive.  We set read_error_flag 	 * for our callers, so they can cope if they want. 	 */
if|if
condition|(
name|r_error_count
operator|++
operator|>
name|READ_ERROR_MAX
condition|)
block|{
name|msg
argument_list|(
literal|"Too many errors, quitting."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_BADARCH
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Perform a read to flush the buffer.  */
end_comment

begin_function
name|void
name|fl_read
parameter_list|()
block|{
name|int
name|err
decl_stmt|;
comment|/* Result from system call */
name|int
name|left
decl_stmt|;
comment|/* Bytes left */
name|char
modifier|*
name|more
decl_stmt|;
comment|/* Pointer to next byte to read */
if|if
condition|(
name|f_checkpoint
operator|&&
operator|!
operator|(
operator|++
name|checkpoint
operator|%
literal|10
operator|)
condition|)
name|msg
argument_list|(
literal|"Read checkpoint %d\n"
argument_list|,
name|checkpoint
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the count of errors.  This only applies to a single 	 * call to fl_read.  We leave read_error_flag alone; it is 	 * only turned off by higher level software. 	 */
name|r_error_count
operator|=
literal|0
expr_stmt|;
comment|/* Clear error count */
comment|/* 	 * If we are about to wipe out a record that 	 * somebody needs to keep, copy it out to a holding 	 * area and adjust somebody's pointer to it. 	 */
if|if
condition|(
name|save_rec
operator|&&
operator|*
name|save_rec
operator|>=
name|ar_record
operator|&&
operator|*
name|save_rec
operator|<
name|ar_last
condition|)
block|{
name|record_save_area
operator|=
operator|*
operator|*
name|save_rec
expr_stmt|;
operator|*
name|save_rec
operator|=
operator|&
name|record_save_area
expr_stmt|;
block|}
if|if
condition|(
name|write_archive_to_stdout
operator|&&
name|baserec
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|rmtwrite
argument_list|(
literal|1
argument_list|,
name|ar_block
operator|->
name|charptr
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|blocksize
condition|)
name|writeerror
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|f_multivol
condition|)
block|{
if|if
condition|(
name|save_name
condition|)
block|{
if|if
condition|(
name|save_name
operator|!=
name|real_s_name
condition|)
block|{
ifdef|#
directive|ifdef
name|__MSDOS__
if|if
condition|(
name|save_name
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
name|save_name
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|*
name|save_name
operator|==
literal|'/'
condition|)
name|save_name
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|real_s_name
argument_list|,
name|save_name
argument_list|)
expr_stmt|;
name|save_name
operator|=
name|real_s_name
expr_stmt|;
block|}
name|real_s_totsize
operator|=
name|save_totsize
expr_stmt|;
name|real_s_sizeleft
operator|=
name|save_sizeleft
expr_stmt|;
block|}
else|else
block|{
name|real_s_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|real_s_totsize
operator|=
literal|0
expr_stmt|;
name|real_s_sizeleft
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|error_loop
label|:
name|err
operator|=
name|rmtread
argument_list|(
name|archive
argument_list|,
name|ar_block
operator|->
name|charptr
argument_list|,
operator|(
name|int
operator|)
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|blocksize
condition|)
return|return;
if|if
condition|(
operator|(
name|err
operator|==
literal|0
operator|||
operator|(
name|err
operator|<
literal|0
operator|&&
name|errno
operator|==
name|ENOSPC
operator|)
operator|||
operator|(
name|err
operator|>
literal|0
operator|&&
operator|!
name|f_reblock
operator|)
operator|)
operator|&&
name|f_multivol
condition|)
block|{
name|union
name|record
modifier|*
name|head
decl_stmt|;
name|try_volume
label|:
if|if
condition|(
name|new_volume
argument_list|(
operator|(
name|cmd_mode
operator|==
name|CMD_APPEND
operator|||
name|cmd_mode
operator|==
name|CMD_CAT
operator|||
name|cmd_mode
operator|==
name|CMD_UPDATE
operator|)
condition|?
literal|2
else|:
literal|1
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|vol_error
label|:
name|err
operator|=
name|rmtread
argument_list|(
name|archive
argument_list|,
name|ar_block
operator|->
name|charptr
argument_list|,
operator|(
name|int
operator|)
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
name|readerror
argument_list|()
expr_stmt|;
goto|goto
name|vol_error
goto|;
block|}
if|if
condition|(
name|err
operator|!=
name|blocksize
condition|)
goto|goto
name|short_read
goto|;
name|head
operator|=
name|ar_block
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|header
operator|.
name|linkflag
operator|==
name|LF_VOLHDR
condition|)
block|{
if|if
condition|(
name|f_volhdr
condition|)
block|{
if|#
directive|if
literal|0
block|char *ptr;  	      ptr = (char *) malloc (strlen (f_volhdr) + 20); 	      sprintf (ptr, "%s Volume %d", f_volhdr, volno);
endif|#
directive|endif
if|if
condition|(
name|re_match
argument_list|(
name|label_pattern
argument_list|,
name|head
operator|->
name|header
operator|.
name|arch_name
argument_list|,
name|strlen
argument_list|(
name|head
operator|->
name|header
operator|.
name|arch_name
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"Volume mismatch! %s!=%s"
argument_list|,
name|f_volhdr
argument_list|,
name|head
operator|->
name|header
operator|.
name|arch_name
argument_list|)
expr_stmt|;
operator|--
name|volno
expr_stmt|;
operator|--
name|global_volno
expr_stmt|;
goto|goto
name|try_volume
goto|;
block|}
if|#
directive|if
literal|0
block|if (strcmp (ptr, head->header.name)) 		{ 		  msg ("Volume mismatch! %s!=%s", ptr, head->header.name); 		  --volno; 		  --global_volno; 		  free (ptr); 		  goto try_volume; 		} 	      free (ptr);
endif|#
directive|endif
block|}
if|if
condition|(
name|f_verbose
condition|)
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"Reading %s\n"
argument_list|,
name|head
operator|->
name|header
operator|.
name|arch_name
argument_list|)
expr_stmt|;
name|head
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f_volhdr
condition|)
block|{
name|msg
argument_list|(
literal|"Warning:  No volume header!"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|real_s_name
index|[
literal|0
index|]
condition|)
block|{
name|long
name|from_oct
parameter_list|()
function_decl|;
if|if
condition|(
name|head
operator|->
name|header
operator|.
name|linkflag
operator|!=
name|LF_MULTIVOL
operator|||
name|strcmp
argument_list|(
name|head
operator|->
name|header
operator|.
name|arch_name
argument_list|,
name|real_s_name
argument_list|)
condition|)
block|{
name|msg
argument_list|(
literal|"%s is not continued on this volume!"
argument_list|,
name|real_s_name
argument_list|)
expr_stmt|;
operator|--
name|volno
expr_stmt|;
operator|--
name|global_volno
expr_stmt|;
goto|goto
name|try_volume
goto|;
block|}
if|if
condition|(
name|real_s_totsize
operator|!=
name|from_oct
argument_list|(
literal|1
operator|+
literal|12
argument_list|,
name|head
operator|->
name|header
operator|.
name|size
argument_list|)
operator|+
name|from_oct
argument_list|(
literal|1
operator|+
literal|12
argument_list|,
name|head
operator|->
name|header
operator|.
name|offset
argument_list|)
condition|)
block|{
name|msg
argument_list|(
literal|"%s is the wrong size (%ld!=%ld+%ld)"
argument_list|,
name|head
operator|->
name|header
operator|.
name|arch_name
argument_list|,
name|save_totsize
argument_list|,
name|from_oct
argument_list|(
literal|1
operator|+
literal|12
argument_list|,
name|head
operator|->
name|header
operator|.
name|size
argument_list|)
argument_list|,
name|from_oct
argument_list|(
literal|1
operator|+
literal|12
argument_list|,
name|head
operator|->
name|header
operator|.
name|offset
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|volno
expr_stmt|;
operator|--
name|global_volno
expr_stmt|;
goto|goto
name|try_volume
goto|;
block|}
if|if
condition|(
name|real_s_totsize
operator|-
name|real_s_sizeleft
operator|!=
name|from_oct
argument_list|(
literal|1
operator|+
literal|12
argument_list|,
name|head
operator|->
name|header
operator|.
name|offset
argument_list|)
condition|)
block|{
name|msg
argument_list|(
literal|"This volume is out of sequence"
argument_list|)
expr_stmt|;
operator|--
name|volno
expr_stmt|;
operator|--
name|global_volno
expr_stmt|;
goto|goto
name|try_volume
goto|;
block|}
name|head
operator|++
expr_stmt|;
block|}
name|ar_record
operator|=
name|head
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
name|readerror
argument_list|()
expr_stmt|;
goto|goto
name|error_loop
goto|;
comment|/* Try again */
block|}
name|short_read
label|:
name|more
operator|=
name|ar_block
operator|->
name|charptr
operator|+
name|err
expr_stmt|;
name|left
operator|=
name|blocksize
operator|-
name|err
expr_stmt|;
name|again
label|:
if|if
condition|(
literal|0
operator|==
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|left
operator|)
operator|%
name|RECORDSIZE
operator|)
condition|)
block|{
comment|/* FIXME, for size=0, multi vol support */
comment|/* On the first block, warn about the problem */
if|if
condition|(
operator|!
name|f_reblock
operator|&&
name|baserec
operator|==
literal|0
operator|&&
name|f_verbose
operator|&&
name|err
operator|>
literal|0
condition|)
block|{
comment|/*	msg("Blocksize = %d record%s", 				err / RECORDSIZE, (err> RECORDSIZE)? "s": "");*/
name|msg
argument_list|(
literal|"Blocksize = %d records"
argument_list|,
name|err
operator|/
name|RECORDSIZE
argument_list|)
expr_stmt|;
block|}
name|ar_last
operator|=
name|ar_block
operator|+
operator|(
call|(
name|unsigned
call|)
argument_list|(
name|blocksize
operator|-
name|left
argument_list|)
operator|)
operator|/
name|RECORDSIZE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|f_reblock
condition|)
block|{
comment|/* 		 * User warned us about this.  Fix up. 		 */
if|if
condition|(
name|left
operator|>
literal|0
condition|)
block|{
name|error2loop
label|:
name|err
operator|=
name|rmtread
argument_list|(
name|archive
argument_list|,
name|more
argument_list|,
operator|(
name|int
operator|)
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
name|readerror
argument_list|()
expr_stmt|;
goto|goto
name|error2loop
goto|;
comment|/* Try again */
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"archive %s EOF not on block boundary"
argument_list|,
name|ar_files
index|[
name|cur_ar_file
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_BADARCH
argument_list|)
expr_stmt|;
block|}
name|left
operator|-=
name|err
expr_stmt|;
name|more
operator|+=
name|err
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
else|else
block|{
name|msg
argument_list|(
literal|"only read %d bytes from archive %s"
argument_list|,
name|err
argument_list|,
name|ar_files
index|[
name|cur_ar_file
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_BADARCH
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Flush the current buffer to/from the archive.  */
end_comment

begin_function
name|void
name|flush_archive
parameter_list|()
block|{
name|int
name|c
decl_stmt|;
name|baserec
operator|+=
name|ar_last
operator|-
name|ar_block
expr_stmt|;
comment|/* Keep track of block #s */
name|ar_record
operator|=
name|ar_block
expr_stmt|;
comment|/* Restore pointer to start */
name|ar_last
operator|=
name|ar_block
operator|+
name|blocking
expr_stmt|;
comment|/* Restore pointer to end */
if|if
condition|(
name|ar_reading
condition|)
block|{
if|if
condition|(
name|time_to_start_writing
condition|)
block|{
name|time_to_start_writing
operator|=
literal|0
expr_stmt|;
name|ar_reading
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|file_to_switch_to
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|rmtclose
argument_list|(
name|archive
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|msg_perror
argument_list|(
literal|"Warning: can't close %s(%d,%d)"
argument_list|,
name|ar_files
index|[
name|cur_ar_file
index|]
argument_list|,
name|archive
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|archive
operator|=
name|file_to_switch_to
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|backspace_output
argument_list|()
expr_stmt|;
name|fl_write
argument_list|()
expr_stmt|;
block|}
else|else
name|fl_read
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|fl_write
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Backspace the archive descriptor by one blocks worth.    If its a tape, MTIOCTOP will work.  If its something else,    we try to seek on it.  If we can't seek, we lose! */
end_comment

begin_function
name|int
name|backspace_output
parameter_list|()
block|{
name|long
name|cur
decl_stmt|;
comment|/* int er; */
specifier|extern
name|char
modifier|*
name|output_start
decl_stmt|;
ifdef|#
directive|ifdef
name|MTIOCTOP
name|struct
name|mtop
name|t
decl_stmt|;
name|t
operator|.
name|mt_op
operator|=
name|MTBSR
expr_stmt|;
name|t
operator|.
name|mt_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|rmtioctl
argument_list|(
name|archive
argument_list|,
name|MTIOCTOP
argument_list|,
operator|&
name|t
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|errno
operator|==
name|EIO
operator|&&
operator|(
name|rmtioctl
argument_list|(
name|archive
argument_list|,
name|MTIOCTOP
argument_list|,
operator|&
name|t
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
name|cur
operator|=
name|rmtlseek
argument_list|(
name|archive
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cur
operator|-=
name|blocksize
expr_stmt|;
comment|/* Seek back to the beginning of this block and 	   start writing there. */
if|if
condition|(
name|rmtlseek
argument_list|(
name|archive
argument_list|,
name|cur
argument_list|,
literal|0
argument_list|)
operator|!=
name|cur
condition|)
block|{
comment|/* Lseek failed.  Try a different method */
name|msg
argument_list|(
literal|"Couldn't backspace archive file.  It may be unreadable without -i."
argument_list|)
expr_stmt|;
comment|/* Replace the first part of the block with nulls */
if|if
condition|(
name|ar_block
operator|->
name|charptr
operator|!=
name|output_start
condition|)
name|bzero
argument_list|(
name|ar_block
operator|->
name|charptr
argument_list|,
name|output_start
operator|-
name|ar_block
operator|->
name|charptr
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
return|return
literal|3
return|;
block|}
end_function

begin_comment
comment|/*  * Close the archive file.  */
end_comment

begin_function
name|void
name|close_archive
parameter_list|()
block|{
name|int
name|child
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|time_to_start_writing
operator|||
operator|!
name|ar_reading
condition|)
name|flush_archive
argument_list|()
expr_stmt|;
if|if
condition|(
name|cmd_mode
operator|==
name|CMD_DELETE
condition|)
block|{
name|off_t
name|pos
decl_stmt|;
name|pos
operator|=
name|rmtlseek
argument_list|(
name|archive
argument_list|,
literal|0L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__MSDOS__
operator|(
name|void
operator|)
name|ftruncate
argument_list|(
name|archive
argument_list|,
name|pos
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|rmtwrite
argument_list|(
name|archive
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|f_verify
condition|)
name|verify_volume
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|__MSDOS__
comment|/*    * Closing the child's pipe before reading EOF guarantees that it    * will be unhappy - SIGPIPE, or exit 1.    * Either way it can screw us, so play nice.    */
if|if
condition|(
name|childpid
operator|&&
name|ar_reading
condition|)
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|read
argument_list|(
name|archive
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
empty_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|c
operator|=
name|rmtclose
argument_list|(
name|archive
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|msg_perror
argument_list|(
literal|"Warning: can't close %s(%d,%d)"
argument_list|,
name|ar_files
index|[
name|cur_ar_file
index|]
argument_list|,
name|archive
argument_list|,
name|c
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__MSDOS__
if|if
condition|(
name|childpid
condition|)
block|{
comment|/*        * Loop waiting for the right child to die, or for        * no more kids.        */
while|while
condition|(
operator|(
operator|(
name|child
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|childpid
operator|)
operator|&&
name|child
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
if|if
condition|(
name|child
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
comment|/* SIGPIPE is OK, everything else is a problem. */
if|if
condition|(
name|WTERMSIG
argument_list|(
name|status
argument_list|)
operator|!=
name|SIGPIPE
condition|)
name|msg
argument_list|(
literal|"child died with signal %d%s"
argument_list|,
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|,
name|WIFCOREDUMPED
argument_list|(
name|status
argument_list|)
condition|?
literal|" (core dumped)"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Child voluntarily terminated  -- but why? */
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|==
name|MAGIC_STAT
condition|)
block|{
name|exit
argument_list|(
name|EX_SYSTEM
argument_list|)
expr_stmt|;
comment|/* Child had trouble */
block|}
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|==
operator|(
name|SIGPIPE
operator|+
literal|128
operator|)
condition|)
block|{
comment|/* 		   * /bin/sh returns this if its child 		   * dies with SIGPIPE.  'Sok. 		   */
comment|/* Do nothing. */
block|}
elseif|else
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|msg
argument_list|(
literal|"child returned status %d"
argument_list|,
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_BADARCH
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|/* __MSDOS__ */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DONTDEF
end_ifdef

begin_comment
comment|/*  * Message management.  *  * anno writes a message prefix on stream (eg stdout, stderr).  *  * The specified prefix is normally output followed by a colon and a space.  * However, if other command line options are set, more output can come  * out, such as the record # within the archive.  *  * If the specified prefix is NULL, no output is produced unless the  * command line option(s) are set.  *  * If the third argument is 1, the "saved" record # is used; if 0, the  * "current" record # is used.  */
end_comment

begin_function
name|void
name|anno
parameter_list|(
name|stream
parameter_list|,
name|prefix
parameter_list|,
name|savedp
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
name|int
name|savedp
decl_stmt|;
block|{
define|#
directive|define
name|MAXANNO
value|50
name|char
name|buffer
index|[
name|MAXANNO
index|]
decl_stmt|;
comment|/* Holds annorecment */
define|#
directive|define
name|ANNOWIDTH
value|13
name|int
name|space
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|int
name|save_e
decl_stmt|;
name|save_e
operator|=
name|errno
expr_stmt|;
comment|/* Make sure previous output gets out in sequence */
if|if
condition|(
name|stream
operator|==
name|stderr
condition|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_sayblock
condition|)
block|{
if|if
condition|(
name|prefix
condition|)
block|{
name|fputs
argument_list|(
name|prefix
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|' '
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|offset
operator|=
name|ar_record
operator|-
name|ar_block
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"rec %d: "
argument_list|,
name|savedp
condition|?
name|saved_recno
else|:
name|baserec
operator|+
name|offset
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|buffer
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|space
operator|=
name|ANNOWIDTH
operator|-
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"%*s"
argument_list|,
name|space
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|prefix
condition|)
block|{
name|fputs
argument_list|(
name|prefix
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|": "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
name|save_e
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Called to initialize the global volume number. */
end_comment

begin_function
name|void
name|init_volume_number
parameter_list|()
block|{
name|FILE
modifier|*
name|vf
decl_stmt|;
name|vf
operator|=
name|fopen
argument_list|(
name|f_volno_file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vf
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
name|msg_perror
argument_list|(
literal|"%s"
argument_list|,
name|f_volno_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|vf
condition|)
block|{
name|fscanf
argument_list|(
name|vf
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|global_volno
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|vf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called to write out the closing global volume number. */
end_comment

begin_function
name|void
name|closeout_volume_number
parameter_list|()
block|{
name|FILE
modifier|*
name|vf
decl_stmt|;
name|vf
operator|=
name|fopen
argument_list|(
name|f_volno_file
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vf
condition|)
name|msg_perror
argument_list|(
literal|"%s"
argument_list|,
name|f_volno_file
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|vf
argument_list|,
literal|"%d\n"
argument_list|,
name|global_volno
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|vf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We've hit the end of the old volume.  Close it and open the next one */
end_comment

begin_comment
comment|/* Values for type:  0: writing  1: reading  2: updating */
end_comment

begin_function
name|int
name|new_volume
parameter_list|(
name|type
parameter_list|)
name|int
name|type
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|char
name|inbuf
index|[
literal|80
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|FILE
modifier|*
name|read_file
init|=
literal|0
decl_stmt|;
specifier|extern
name|int
name|now_verifying
decl_stmt|;
specifier|extern
name|char
name|TTY_NAME
index|[]
decl_stmt|;
specifier|static
name|int
name|looped
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|read_file
operator|&&
operator|!
name|f_run_script_at_end
condition|)
name|read_file
operator|=
operator|(
name|archive
operator|==
literal|0
operator|)
condition|?
name|fopen
argument_list|(
name|TTY_NAME
argument_list|,
literal|"r"
argument_list|)
else|:
name|stdin
expr_stmt|;
if|if
condition|(
name|now_verifying
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|f_verify
condition|)
name|verify_volume
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|rmtclose
argument_list|(
name|archive
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|msg_perror
argument_list|(
literal|"Warning: can't close %s(%d,%d)"
argument_list|,
name|ar_files
index|[
name|cur_ar_file
index|]
argument_list|,
name|archive
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|global_volno
operator|++
expr_stmt|;
name|volno
operator|++
expr_stmt|;
name|cur_ar_file
operator|++
expr_stmt|;
if|if
condition|(
name|cur_ar_file
operator|==
name|n_ar_files
condition|)
block|{
name|cur_ar_file
operator|=
literal|0
expr_stmt|;
name|looped
operator|=
literal|1
expr_stmt|;
block|}
name|tryagain
label|:
if|if
condition|(
name|looped
condition|)
block|{
comment|/* We have to prompt from now on. */
if|if
condition|(
name|f_run_script_at_end
condition|)
block|{
name|closeout_volume_number
argument_list|()
expr_stmt|;
name|system
argument_list|(
name|info_script
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
init|;
condition|;
control|)
block|{
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"\007Prepare volume #%d for %s and hit return: "
argument_list|,
name|global_volno
argument_list|,
name|ar_files
index|[
name|cur_ar_file
index|]
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|msg_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|inbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|inbuf
argument_list|)
argument_list|,
name|read_file
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"EOF?  What does that mean?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd_mode
operator|!=
name|CMD_EXTRACT
operator|&&
name|cmd_mode
operator|!=
name|CMD_LIST
operator|&&
name|cmd_mode
operator|!=
name|CMD_DIFF
condition|)
name|msg
argument_list|(
literal|"Warning:  Archive is INCOMPLETE!"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_BADARCH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inbuf
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|||
name|inbuf
index|[
literal|0
index|]
operator|==
literal|'y'
operator|||
name|inbuf
index|[
literal|0
index|]
operator|==
literal|'Y'
condition|)
break|break;
switch|switch
condition|(
name|inbuf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'?'
case|:
block|{
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"\  n [name]   Give a new filename for the next (and subsequent) volume(s)\n\  q          Abort tar\n\  !          Spawn a subshell\n\  ?          Print this list\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'q'
case|:
comment|/* Quit */
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"No new volume; exiting.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd_mode
operator|!=
name|CMD_EXTRACT
operator|&&
name|cmd_mode
operator|!=
name|CMD_LIST
operator|&&
name|cmd_mode
operator|!=
name|CMD_DIFF
condition|)
name|msg
argument_list|(
literal|"Warning:  Archive is INCOMPLETE!"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_BADARCH
argument_list|)
expr_stmt|;
case|case
literal|'n'
case|:
comment|/* Get new file name */
block|{
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
specifier|static
name|char
modifier|*
name|old_name
decl_stmt|;
for|for
control|(
name|q
operator|=
operator|&
name|inbuf
index|[
literal|1
index|]
init|;
operator|*
name|q
operator|==
literal|' '
operator|||
operator|*
name|q
operator|==
literal|'\t'
condition|;
name|q
operator|++
control|)
empty_stmt|;
for|for
control|(
name|r
operator|=
name|q
init|;
operator|*
name|r
condition|;
name|r
operator|++
control|)
if|if
condition|(
operator|*
name|r
operator|==
literal|'\n'
condition|)
operator|*
name|r
operator|=
literal|'\0'
expr_stmt|;
name|old_name
operator|=
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|strlen
argument_list|(
name|q
argument_list|)
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"Can't allocate memory for name"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SYSTEM
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|ar_files
index|[
name|cur_ar_file
index|]
operator|=
name|p
expr_stmt|;
block|}
break|break;
case|case
literal|'!'
case|:
ifdef|#
directive|ifdef
name|__MSDOS__
name|spawnl
argument_list|(
name|P_WAIT
argument_list|,
name|getenv
argument_list|(
literal|"COMSPEC"
argument_list|)
argument_list|,
literal|"-"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* JF this needs work! */
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|msg_perror
argument_list|(
literal|"can't fork!"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|p
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|p
operator|=
literal|"/bin/sh"
expr_stmt|;
name|execlp
argument_list|(
name|p
argument_list|,
literal|"-sh"
argument_list|,
literal|"-i"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msg_perror
argument_list|(
literal|"can't exec a shell %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|55
argument_list|)
expr_stmt|;
default|default:
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
break|break;
block|}
block|}
block|}
if|if
condition|(
name|type
operator|==
literal|2
operator|||
name|f_verify
condition|)
name|archive
operator|=
name|rmtopen
argument_list|(
name|ar_files
index|[
name|cur_ar_file
index|]
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
literal|1
condition|)
name|archive
operator|=
name|rmtopen
argument_list|(
name|ar_files
index|[
name|cur_ar_file
index|]
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
literal|0
condition|)
name|archive
operator|=
name|rmtcreat
argument_list|(
name|ar_files
index|[
name|cur_ar_file
index|]
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
else|else
name|archive
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|archive
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"can't open %s"
argument_list|,
name|ar_files
index|[
name|cur_ar_file
index|]
argument_list|)
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
ifdef|#
directive|ifdef
name|__MSDOS__
name|setmode
argument_list|(
name|archive
argument_list|,
name|O_BINARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* this is a useless function that takes a buffer returned by wantbytes    and does nothing with it.  If the function called by wantbytes returns    an error indicator (non-zero), this function is called for the rest of    the file.  */
end_comment

begin_function
name|int
name|no_op
parameter_list|(
name|size
parameter_list|,
name|data
parameter_list|)
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Some other routine wants SIZE bytes in the archive.  For each chunk of    the archive, call FUNC with the size of the chunk, and the address of    the chunk it can work with.  */
end_comment

begin_decl_stmt
name|int
name|wantbytes
argument_list|(
name|size
argument_list|,
name|func
argument_list|)
name|long
name|size
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|char
modifier|*
name|data
decl_stmt|;
name|long
name|data_size
decl_stmt|;
while|while
condition|(
name|size
condition|)
block|{
name|data
operator|=
name|findrec
argument_list|()
operator|->
name|charptr
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
comment|/* Check it... */
name|msg
argument_list|(
literal|"Unexpected EOF on archive file"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|data_size
operator|=
name|endofrecs
argument_list|()
operator|->
name|charptr
operator|-
name|data
expr_stmt|;
if|if
condition|(
name|data_size
operator|>
name|size
condition|)
name|data_size
operator|=
name|size
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|func
call|)
argument_list|(
name|data_size
argument_list|,
name|data
argument_list|)
condition|)
name|func
operator|=
name|no_op
expr_stmt|;
name|userec
argument_list|(
operator|(
expr|union
name|record
operator|*
operator|)
operator|(
name|data
operator|+
name|data_size
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|size
operator|-=
name|data_size
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

end_unit

