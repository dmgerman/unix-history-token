begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Diff files from a tar archive.    Copyright (C) 1988, 1992, 1993 Free Software Foundation  This file is part of GNU Tar.  GNU Tar is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU Tar is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU Tar; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * Diff files from a tar archive.  *  * Written 30 April 1987 by John Gilmore, ihnp4!hoptoad!gnu.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|STDC_HEADERS
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|V7
end_ifndef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_MTIO_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"tar.h"
end_include

begin_include
include|#
directive|include
file|"port.h"
end_include

begin_include
include|#
directive|include
file|"rmt.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISLNK
end_ifndef

begin_define
define|#
directive|define
name|lstat
value|stat
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|void
modifier|*
name|valloc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|union
name|record
modifier|*
name|head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Points to current tape header */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|stat
name|hstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stat struct corresponding */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|head_standard
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tape header is in ANSI format */
end_comment

begin_function_decl
name|void
name|decode_header
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|diff_sparse_files
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fill_in_sparse_array
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fl_read
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|from_oct
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|do_stat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|print_header
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|read_header
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|saverec
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sigh
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|skip_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|skip_extended_headers
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|wantbytes
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|msg_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|now_verifying
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Are we verifying at the moment? */
end_comment

begin_decl_stmt
name|int
name|diff_fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor of file we're diffing */
end_comment

begin_decl_stmt
name|char
modifier|*
name|diff_buf
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to area for reading 					   file contents into */
end_comment

begin_decl_stmt
name|char
modifier|*
name|diff_dir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Directory contents for LF_DUMPDIR */
end_comment

begin_decl_stmt
name|int
name|different
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*struct sp_array *sparsearray; int 		sp_ar_size = 10;*/
end_comment

begin_comment
comment|/*  * Initialize for a diff operation  */
end_comment

begin_function
name|void
name|diff_init
parameter_list|()
block|{
comment|/*NOSTRICT*/
name|diff_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|valloc
argument_list|(
operator|(
name|unsigned
operator|)
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|diff_buf
condition|)
block|{
name|msg
argument_list|(
literal|"could not allocate memory for diff buffer of %d bytes"
argument_list|,
name|blocksize
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Diff a file against the archive.  */
end_comment

begin_function
name|void
name|diff_archive
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|check
decl_stmt|,
name|namelen
decl_stmt|;
name|int
name|err
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|struct
name|stat
name|filestat
decl_stmt|;
name|int
name|compare_chunk
parameter_list|()
function_decl|;
name|int
name|compare_dir
parameter_list|()
function_decl|;
name|int
name|no_op
parameter_list|()
function_decl|;
ifndef|#
directive|ifndef
name|__MSDOS__
name|dev_t
name|dev
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|get_dir_contents
parameter_list|()
function_decl|;
name|long
name|from_oct
parameter_list|()
function_decl|;
name|errno
operator|=
name|EPIPE
expr_stmt|;
comment|/* FIXME, remove perrors */
name|saverec
argument_list|(
operator|&
name|head
argument_list|)
expr_stmt|;
comment|/* Make sure it sticks around */
name|userec
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/* And go past it in the archive */
name|decode_header
argument_list|(
name|head
argument_list|,
operator|&
name|hstat
argument_list|,
operator|&
name|head_standard
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Snarf fields */
comment|/* Print the record from 'head' and 'hstat' */
if|if
condition|(
name|f_verbose
condition|)
block|{
if|if
condition|(
name|now_verifying
condition|)
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"Verify "
argument_list|)
expr_stmt|;
name|print_header
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|head
operator|->
name|header
operator|.
name|linkflag
condition|)
block|{
default|default:
name|msg
argument_list|(
literal|"Unknown file type '%c' for %s, diffed as normal file"
argument_list|,
name|head
operator|->
name|header
operator|.
name|linkflag
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
comment|/* FALL THRU */
case|case
name|LF_OLDNORMAL
case|:
case|case
name|LF_NORMAL
case|:
case|case
name|LF_SPARSE
case|:
case|case
name|LF_CONTIG
case|:
comment|/* 		 * Appears to be a file. 		 * See if it's really a directory. 		 */
name|namelen
operator|=
name|strlen
argument_list|(
name|current_file_name
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|current_file_name
index|[
name|namelen
index|]
operator|==
literal|'/'
condition|)
goto|goto
name|really_dir
goto|;
if|if
condition|(
name|do_stat
argument_list|(
operator|&
name|filestat
argument_list|)
condition|)
block|{
if|if
condition|(
name|head
operator|->
name|header
operator|.
name|isextended
condition|)
name|skip_extended_headers
argument_list|()
expr_stmt|;
name|skip_file
argument_list|(
operator|(
name|long
operator|)
name|hstat
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|different
operator|++
expr_stmt|;
goto|goto
name|quit
goto|;
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|filestat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"%s: not a regular file\n"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
name|skip_file
argument_list|(
operator|(
name|long
operator|)
name|hstat
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|different
operator|++
expr_stmt|;
goto|goto
name|quit
goto|;
block|}
name|filestat
operator|.
name|st_mode
operator|&=
literal|07777
expr_stmt|;
if|if
condition|(
name|filestat
operator|.
name|st_mode
operator|!=
name|hstat
operator|.
name|st_mode
condition|)
name|sigh
argument_list|(
literal|"mode"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filestat
operator|.
name|st_uid
operator|!=
name|hstat
operator|.
name|st_uid
condition|)
name|sigh
argument_list|(
literal|"uid"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filestat
operator|.
name|st_gid
operator|!=
name|hstat
operator|.
name|st_gid
condition|)
name|sigh
argument_list|(
literal|"gid"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filestat
operator|.
name|st_mtime
operator|!=
name|hstat
operator|.
name|st_mtime
condition|)
name|sigh
argument_list|(
literal|"mod time"
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|header
operator|.
name|linkflag
operator|!=
name|LF_SPARSE
operator|&&
name|filestat
operator|.
name|st_size
operator|!=
name|hstat
operator|.
name|st_size
condition|)
block|{
name|sigh
argument_list|(
literal|"size"
argument_list|)
expr_stmt|;
name|skip_file
argument_list|(
operator|(
name|long
operator|)
name|hstat
operator|.
name|st_size
argument_list|)
expr_stmt|;
goto|goto
name|quit
goto|;
block|}
name|diff_fd
operator|=
name|open
argument_list|(
name|current_file_name
argument_list|,
name|O_NDELAY
operator||
name|O_RDONLY
operator||
name|O_BINARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff_fd
operator|<
literal|0
operator|&&
operator|!
name|f_absolute_paths
condition|)
block|{
name|char
name|tmpbuf
index|[
name|NAMSIZ
operator|+
literal|2
index|]
decl_stmt|;
name|tmpbuf
index|[
literal|0
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|tmpbuf
index|[
literal|1
index|]
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
name|diff_fd
operator|=
name|open
argument_list|(
name|tmpbuf
argument_list|,
name|O_NDELAY
operator||
name|O_RDONLY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|diff_fd
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"cannot open %s"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|header
operator|.
name|isextended
condition|)
name|skip_extended_headers
argument_list|()
expr_stmt|;
name|skip_file
argument_list|(
operator|(
name|long
operator|)
name|hstat
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|different
operator|++
expr_stmt|;
goto|goto
name|quit
goto|;
block|}
comment|/* 		 * Need to treat sparse files completely differently here. 		 */
if|if
condition|(
name|head
operator|->
name|header
operator|.
name|linkflag
operator|==
name|LF_SPARSE
condition|)
name|diff_sparse_files
argument_list|(
name|hstat
operator|.
name|st_size
argument_list|)
expr_stmt|;
else|else
name|wantbytes
argument_list|(
call|(
name|long
call|)
argument_list|(
name|hstat
operator|.
name|st_size
argument_list|)
argument_list|,
name|compare_chunk
argument_list|)
expr_stmt|;
name|check
operator|=
name|close
argument_list|(
name|diff_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
operator|<
literal|0
condition|)
name|msg_perror
argument_list|(
literal|"Error while closing %s"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
name|quit
label|:
break|break;
ifndef|#
directive|ifndef
name|__MSDOS__
case|case
name|LF_LINK
case|:
if|if
condition|(
name|do_stat
argument_list|(
operator|&
name|filestat
argument_list|)
condition|)
break|break;
name|dev
operator|=
name|filestat
operator|.
name|st_dev
expr_stmt|;
name|ino
operator|=
name|filestat
operator|.
name|st_ino
expr_stmt|;
name|err
operator|=
name|stat
argument_list|(
name|current_link_name
argument_list|,
operator|&
name|filestat
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"%s: does not exist\n"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msg_perror
argument_list|(
literal|"cannot stat file %s"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
block|}
name|different
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|filestat
operator|.
name|st_dev
operator|!=
name|dev
operator|||
name|filestat
operator|.
name|st_ino
operator|!=
name|ino
condition|)
block|{
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"%s not linked to %s\n"
argument_list|,
name|current_file_name
argument_list|,
name|current_link_name
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISLNK
case|case
name|LF_SYMLINK
case|:
block|{
name|char
name|linkbuf
index|[
name|NAMSIZ
operator|+
literal|3
index|]
decl_stmt|;
name|check
operator|=
name|readlink
argument_list|(
name|current_file_name
argument_list|,
name|linkbuf
argument_list|,
operator|(
sizeof|sizeof
name|linkbuf
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"%s: no such file or directory\n"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msg_perror
argument_list|(
literal|"cannot read link %s"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
block|}
name|different
operator|++
expr_stmt|;
break|break;
block|}
name|linkbuf
index|[
name|check
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Null-terminate it */
if|if
condition|(
name|strncmp
argument_list|(
name|current_link_name
argument_list|,
name|linkbuf
argument_list|,
name|check
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"%s: symlink differs\n"
argument_list|,
name|current_link_name
argument_list|)
expr_stmt|;
name|different
operator|++
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFCHR
case|case
name|LF_CHR
case|:
name|hstat
operator|.
name|st_mode
operator||=
name|S_IFCHR
expr_stmt|;
goto|goto
name|check_node
goto|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_IFBLK
comment|/* If local system doesn't support block devices, use default case */
case|case
name|LF_BLK
case|:
name|hstat
operator|.
name|st_mode
operator||=
name|S_IFBLK
expr_stmt|;
goto|goto
name|check_node
goto|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISFIFO
comment|/* If local system doesn't support FIFOs, use default case */
case|case
name|LF_FIFO
case|:
ifdef|#
directive|ifdef
name|S_IFIFO
name|hstat
operator|.
name|st_mode
operator||=
name|S_IFIFO
expr_stmt|;
endif|#
directive|endif
name|hstat
operator|.
name|st_rdev
operator|=
literal|0
expr_stmt|;
comment|/* FIXME, do we need this? */
goto|goto
name|check_node
goto|;
endif|#
directive|endif
name|check_node
label|:
comment|/* FIXME, deal with umask */
if|if
condition|(
name|do_stat
argument_list|(
operator|&
name|filestat
argument_list|)
condition|)
break|break;
if|if
condition|(
name|hstat
operator|.
name|st_rdev
operator|!=
name|filestat
operator|.
name|st_rdev
condition|)
block|{
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"%s: device numbers changed\n"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
name|different
operator|++
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|S_IFMT
if|if
condition|(
name|hstat
operator|.
name|st_mode
operator|!=
name|filestat
operator|.
name|st_mode
condition|)
else|#
directive|else
comment|/* POSIX lossage */
if|if
condition|(
operator|(
name|hstat
operator|.
name|st_mode
operator|&
literal|07777
operator|)
operator|!=
operator|(
name|filestat
operator|.
name|st_mode
operator|&
literal|07777
operator|)
condition|)
endif|#
directive|endif
block|{
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"%s: mode or device-type changed\n"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
name|different
operator|++
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|LF_DUMPDIR
case|:
name|data
operator|=
name|diff_dir
operator|=
name|get_dir_contents
argument_list|(
name|current_file_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
condition|)
block|{
name|wantbytes
argument_list|(
call|(
name|long
call|)
argument_list|(
name|hstat
operator|.
name|st_size
argument_list|)
argument_list|,
name|compare_dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
else|else
name|wantbytes
argument_list|(
call|(
name|long
call|)
argument_list|(
name|hstat
operator|.
name|st_size
argument_list|)
argument_list|,
name|no_op
argument_list|)
expr_stmt|;
comment|/* FALL THROUGH */
case|case
name|LF_DIR
case|:
comment|/* Check for trailing / */
name|namelen
operator|=
name|strlen
argument_list|(
name|current_file_name
argument_list|)
operator|-
literal|1
expr_stmt|;
name|really_dir
label|:
while|while
condition|(
name|namelen
operator|&&
name|current_file_name
index|[
name|namelen
index|]
operator|==
literal|'/'
condition|)
name|current_file_name
index|[
name|namelen
operator|--
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Zap / */
if|if
condition|(
name|do_stat
argument_list|(
operator|&
name|filestat
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|filestat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"%s is no longer a directory\n"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
name|different
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|filestat
operator|.
name|st_mode
operator|&
literal|07777
operator|)
operator|!=
operator|(
name|hstat
operator|.
name|st_mode
operator|&
literal|07777
operator|)
condition|)
name|sigh
argument_list|(
literal|"mode"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LF_VOLHDR
case|:
break|break;
case|case
name|LF_MULTIVOL
case|:
name|namelen
operator|=
name|strlen
argument_list|(
name|current_file_name
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|current_file_name
index|[
name|namelen
index|]
operator|==
literal|'/'
condition|)
goto|goto
name|really_dir
goto|;
if|if
condition|(
name|do_stat
argument_list|(
operator|&
name|filestat
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|filestat
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"%s: not a regular file\n"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
name|skip_file
argument_list|(
operator|(
name|long
operator|)
name|hstat
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|different
operator|++
expr_stmt|;
break|break;
block|}
name|filestat
operator|.
name|st_mode
operator|&=
literal|07777
expr_stmt|;
name|offset
operator|=
name|from_oct
argument_list|(
literal|1
operator|+
literal|12
argument_list|,
name|head
operator|->
name|header
operator|.
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|filestat
operator|.
name|st_size
operator|!=
name|hstat
operator|.
name|st_size
operator|+
name|offset
condition|)
block|{
name|sigh
argument_list|(
literal|"size"
argument_list|)
expr_stmt|;
name|skip_file
argument_list|(
operator|(
name|long
operator|)
name|hstat
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|different
operator|++
expr_stmt|;
break|break;
block|}
name|diff_fd
operator|=
name|open
argument_list|(
name|current_file_name
argument_list|,
name|O_NDELAY
operator||
name|O_RDONLY
operator||
name|O_BINARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff_fd
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"cannot open file %s"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
name|skip_file
argument_list|(
operator|(
name|long
operator|)
name|hstat
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|different
operator|++
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|lseek
argument_list|(
name|diff_fd
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|offset
condition|)
block|{
name|msg_perror
argument_list|(
literal|"cannot seek to %ld in file %s"
argument_list|,
name|offset
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
name|different
operator|++
expr_stmt|;
break|break;
block|}
name|wantbytes
argument_list|(
call|(
name|long
call|)
argument_list|(
name|hstat
operator|.
name|st_size
argument_list|)
argument_list|,
name|compare_chunk
argument_list|)
expr_stmt|;
name|check
operator|=
name|close
argument_list|(
name|diff_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|check
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"Error while closing %s"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* We don't need to save it any longer. */
name|saverec
argument_list|(
operator|(
expr|union
name|record
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* Unsave it */
block|}
end_function

begin_function
name|int
name|compare_chunk
parameter_list|(
name|bytes
parameter_list|,
name|buffer
parameter_list|)
name|long
name|bytes
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|read
argument_list|(
name|diff_fd
argument_list|,
name|diff_buf
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|bytes
condition|)
block|{
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
name|msg_perror
argument_list|(
literal|"can't read %s"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"%s: could only read %d of %ld bytes\n"
argument_list|,
name|current_file_name
argument_list|,
name|err
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
name|different
operator|++
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|bcmp
argument_list|(
name|buffer
argument_list|,
name|diff_buf
argument_list|,
name|bytes
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"%s: data differs\n"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
name|different
operator|++
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|compare_dir
parameter_list|(
name|bytes
parameter_list|,
name|buffer
parameter_list|)
name|long
name|bytes
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
if|if
condition|(
name|bcmp
argument_list|(
name|buffer
argument_list|,
name|diff_dir
argument_list|,
name|bytes
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"%s: data differs\n"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
name|different
operator|++
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|diff_dir
operator|+=
name|bytes
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Sigh about something that differs.  */
end_comment

begin_function
name|void
name|sigh
parameter_list|(
name|what
parameter_list|)
name|char
modifier|*
name|what
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"%s: %s differs\n"
argument_list|,
name|current_file_name
argument_list|,
name|what
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|verify_volume
parameter_list|()
block|{
name|int
name|status
decl_stmt|;
ifdef|#
directive|ifdef
name|MTIOCTOP
name|struct
name|mtop
name|t
decl_stmt|;
name|int
name|er
decl_stmt|;
endif|#
directive|endif
name|current_file_name
operator|=
name|NULL
expr_stmt|;
name|current_link_name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|diff_buf
condition|)
name|diff_init
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MTIOCTOP
name|t
operator|.
name|mt_op
operator|=
name|MTBSF
expr_stmt|;
name|t
operator|.
name|mt_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|er
operator|=
name|rmtioctl
argument_list|(
name|archive
argument_list|,
name|MTIOCTOP
argument_list|,
operator|&
name|t
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EIO
operator|||
operator|(
name|er
operator|=
name|rmtioctl
argument_list|(
name|archive
argument_list|,
name|MTIOCTOP
argument_list|,
operator|&
name|t
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|rmtlseek
argument_list|(
name|archive
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Lseek failed.  Try a different method */
name|msg_perror
argument_list|(
literal|"Couldn't rewind archive file for verify"
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|MTIOCTOP
block|}
block|}
endif|#
directive|endif
name|ar_reading
operator|=
literal|1
expr_stmt|;
name|now_verifying
operator|=
literal|1
expr_stmt|;
name|fl_read
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|status
operator|=
name|read_header
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|unsigned
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|n
operator|++
expr_stmt|;
name|status
operator|=
name|read_header
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|status
operator|==
literal|0
condition|)
do|;
name|msg
argument_list|(
literal|"VERIFY FAILURE: %d invalid header%s detected!"
argument_list|,
name|n
argument_list|,
name|n
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
literal|2
operator|||
name|status
operator|==
name|EOF
condition|)
break|break;
name|diff_archive
argument_list|()
expr_stmt|;
block|}
name|ar_reading
operator|=
literal|0
expr_stmt|;
name|now_verifying
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|do_stat
parameter_list|(
name|statp
parameter_list|)
name|struct
name|stat
modifier|*
name|statp
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|f_follow_links
condition|?
name|stat
argument_list|(
name|current_file_name
argument_list|,
name|statp
argument_list|)
else|:
name|lstat
argument_list|(
name|current_file_name
argument_list|,
name|statp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"%s: does not exist\n"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
block|}
else|else
name|msg_perror
argument_list|(
literal|"can't stat file %s"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
comment|/*		skip_file((long)hstat.st_size); 		different++;*/
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * JK  * Diff'ing a sparse file with its counterpart on the tar file is a  * bit of a different story than a normal file.  First, we must know  * what areas of the file to skip through, i.e., we need to contruct  * a sparsearray, which will hold all the information we need.  We must  * compare small amounts of data at a time as we find it.  */
end_comment

begin_function
name|void
name|diff_sparse_files
parameter_list|(
name|filesize
parameter_list|)
name|int
name|filesize
decl_stmt|;
block|{
name|int
name|sparse_ind
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|buf_size
init|=
name|RECORDSIZE
decl_stmt|;
name|union
name|record
modifier|*
name|datarec
decl_stmt|;
name|int
name|err
decl_stmt|;
name|long
name|numbytes
decl_stmt|;
comment|/*	int		amt_read = 0;*/
name|int
name|size
init|=
name|filesize
decl_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|ck_malloc
argument_list|(
name|buf_size
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|fill_in_sparse_array
argument_list|()
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|datarec
operator|=
name|findrec
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|sparsearray
index|[
name|sparse_ind
index|]
operator|.
name|numbytes
condition|)
break|break;
comment|/* 		 * 'numbytes' is nicer to write than 		 * 'sparsearray[sparse_ind].numbytes' all the time ... 		 */
name|numbytes
operator|=
name|sparsearray
index|[
name|sparse_ind
index|]
operator|.
name|numbytes
expr_stmt|;
name|lseek
argument_list|(
name|diff_fd
argument_list|,
name|sparsearray
index|[
name|sparse_ind
index|]
operator|.
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * take care to not run out of room in our buffer 		 */
while|while
condition|(
name|buf_size
operator|<
name|numbytes
condition|)
block|{
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|ck_realloc
argument_list|(
name|buf
argument_list|,
name|buf_size
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|buf_size
operator|*=
literal|2
expr_stmt|;
block|}
while|while
condition|(
name|numbytes
operator|>
name|RECORDSIZE
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|read
argument_list|(
name|diff_fd
argument_list|,
name|buf
argument_list|,
name|RECORDSIZE
argument_list|)
operator|)
operator|!=
name|RECORDSIZE
condition|)
block|{
if|if
condition|(
name|err
operator|<
literal|0
condition|)
name|msg_perror
argument_list|(
literal|"can't read %s"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"%s: could only read %d of %ld bytes\n"
argument_list|,
name|current_file_name
argument_list|,
name|err
argument_list|,
name|numbytes
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bcmp
argument_list|(
name|buf
argument_list|,
name|datarec
operator|->
name|charptr
argument_list|,
name|RECORDSIZE
argument_list|)
condition|)
block|{
name|different
operator|++
expr_stmt|;
break|break;
block|}
name|numbytes
operator|-=
name|err
expr_stmt|;
name|size
operator|-=
name|err
expr_stmt|;
name|userec
argument_list|(
name|datarec
argument_list|)
expr_stmt|;
name|datarec
operator|=
name|findrec
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|read
argument_list|(
name|diff_fd
argument_list|,
name|buf
argument_list|,
name|numbytes
argument_list|)
operator|)
operator|!=
name|numbytes
condition|)
block|{
if|if
condition|(
name|err
operator|<
literal|0
condition|)
name|msg_perror
argument_list|(
literal|"can't read %s"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"%s: could only read %d of %ld bytes\n"
argument_list|,
name|current_file_name
argument_list|,
name|err
argument_list|,
name|numbytes
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bcmp
argument_list|(
name|buf
argument_list|,
name|datarec
operator|->
name|charptr
argument_list|,
name|numbytes
argument_list|)
condition|)
block|{
name|different
operator|++
expr_stmt|;
break|break;
block|}
comment|/*		amt_read += numbytes; 		if (amt_read>= RECORDSIZE) { 			amt_read = 0; 			userec(datarec); 			datarec = findrec(); 		}*/
name|userec
argument_list|(
name|datarec
argument_list|)
expr_stmt|;
name|sparse_ind
operator|++
expr_stmt|;
name|size
operator|-=
name|numbytes
expr_stmt|;
block|}
comment|/* 	 * if the number of bytes read isn't the 	 * number of bytes supposedly in the file, 	 * they're different 	 */
comment|/*	if (amt_read != filesize) 		different++;*/
name|userec
argument_list|(
name|datarec
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sparsearray
argument_list|)
expr_stmt|;
if|if
condition|(
name|different
condition|)
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"%s: data differs\n"
argument_list|,
name|current_file_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * JK  * This routine should be used more often than it is ... look into  * that.  Anyhow, what it does is translate the sparse information  * on the header, and in any subsequent extended headers, into an  * array of structures with true numbers, as opposed to character  * strings.  It simply makes our life much easier, doing so many  * comparisong and such.  */
end_comment

begin_function
name|void
name|fill_in_sparse_array
parameter_list|()
block|{
name|int
name|ind
decl_stmt|;
comment|/* 	 * allocate space for our scratch space; it's initially 	 * 10 elements long, but can change in this routine if 	 * necessary 	 */
name|sp_array_size
operator|=
literal|10
expr_stmt|;
name|sparsearray
operator|=
operator|(
expr|struct
name|sp_array
operator|*
operator|)
name|ck_malloc
argument_list|(
name|sp_array_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sp_array
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * there are at most five of these structures in the header 	 * itself; read these in first 	 */
for|for
control|(
name|ind
operator|=
literal|0
init|;
name|ind
operator|<
name|SPARSE_IN_HDR
condition|;
name|ind
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|head
operator|->
name|header
operator|.
name|sp
index|[
name|ind
index|]
operator|.
name|numbytes
condition|)
break|break;
name|sparsearray
index|[
name|ind
index|]
operator|.
name|offset
operator|=
name|from_oct
argument_list|(
literal|1
operator|+
literal|12
argument_list|,
name|head
operator|->
name|header
operator|.
name|sp
index|[
name|ind
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
name|sparsearray
index|[
name|ind
index|]
operator|.
name|numbytes
operator|=
name|from_oct
argument_list|(
literal|1
operator|+
literal|12
argument_list|,
name|head
operator|->
name|header
operator|.
name|sp
index|[
name|ind
index|]
operator|.
name|numbytes
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * if the header's extended, we gotta read in exhdr's till 	 * we're done 	 */
if|if
condition|(
name|head
operator|->
name|header
operator|.
name|isextended
condition|)
block|{
comment|/* how far into the sparsearray we are 'so far' */
specifier|static
name|int
name|so_far_ind
init|=
name|SPARSE_IN_HDR
decl_stmt|;
name|union
name|record
modifier|*
name|exhdr
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|exhdr
operator|=
name|findrec
argument_list|()
expr_stmt|;
for|for
control|(
name|ind
operator|=
literal|0
init|;
name|ind
operator|<
name|SPARSE_EXT_HDR
condition|;
name|ind
operator|++
control|)
block|{
if|if
condition|(
name|ind
operator|+
name|so_far_ind
operator|>
name|sp_array_size
operator|-
literal|1
condition|)
block|{
comment|/*  				 * we just ran out of room in our 				 *  scratch area - realloc it  				 */
name|sparsearray
operator|=
operator|(
expr|struct
name|sp_array
operator|*
operator|)
name|ck_realloc
argument_list|(
name|sparsearray
argument_list|,
name|sp_array_size
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sp_array
argument_list|)
argument_list|)
expr_stmt|;
name|sp_array_size
operator|*=
literal|2
expr_stmt|;
block|}
comment|/* 			 * convert the character strings into longs 			 */
name|sparsearray
index|[
name|ind
operator|+
name|so_far_ind
index|]
operator|.
name|offset
operator|=
name|from_oct
argument_list|(
literal|1
operator|+
literal|12
argument_list|,
name|exhdr
operator|->
name|ext_hdr
operator|.
name|sp
index|[
name|ind
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
name|sparsearray
index|[
name|ind
operator|+
name|so_far_ind
index|]
operator|.
name|numbytes
operator|=
name|from_oct
argument_list|(
literal|1
operator|+
literal|12
argument_list|,
name|exhdr
operator|->
name|ext_hdr
operator|.
name|sp
index|[
name|ind
index|]
operator|.
name|numbytes
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * if this is the last extended header for this 		 * file, we can stop 		 */
if|if
condition|(
operator|!
name|exhdr
operator|->
name|ext_hdr
operator|.
name|isextended
condition|)
break|break;
else|else
block|{
name|so_far_ind
operator|+=
name|SPARSE_EXT_HDR
expr_stmt|;
name|userec
argument_list|(
name|exhdr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* be sure to skip past the last one  */
name|userec
argument_list|(
name|exhdr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

