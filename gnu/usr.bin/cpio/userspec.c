begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* userspec.c -- Parse a user and group string.    Copyright (C) 1989, 1990, 1991, 1992 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Written by David MacKenzie<djm@gnu.ai.mit.edu>.  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STDC_HEADERS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_STRING_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|index
end_ifndef

begin_define
define|#
directive|define
name|index
value|strchr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|STDC_HEADERS
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_POSIX_VERSION
end_ifndef

begin_function_decl
name|struct
name|passwd
modifier|*
name|getpwnam
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|group
modifier|*
name|getgrnam
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|group
modifier|*
name|getgrgid
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_POSIX_SOURCE
end_ifdef

begin_define
define|#
directive|define
name|endpwent
parameter_list|()
end_define

begin_define
define|#
directive|define
name|endgrent
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|isdigit
parameter_list|(
name|c
parameter_list|)
value|((c)>= '0'&& (c)<= '9')
end_define

begin_function_decl
name|char
modifier|*
name|strdup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isnumber
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Extract from NAME, which has the form "[user][:.][group]",    a USERNAME, UID U, GROUPNAME, and GID G.    Either user or group, or both, must be present.    If the group is omitted but the ":" or "." separator is given,    use the given user's login group.     USERNAME and GROUPNAME will be in newly malloc'd memory.    Either one might be NULL instead, indicating that it was not    given and the corresponding numeric ID was left unchanged.    Might write NULs into NAME.     Return NULL if successful, a static error message string if not.  */
end_comment

begin_function
name|char
modifier|*
name|parse_user_spec
parameter_list|(
name|name
parameter_list|,
name|uid
parameter_list|,
name|gid
parameter_list|,
name|username
parameter_list|,
name|groupname
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|uid_t
modifier|*
name|uid
decl_stmt|;
name|gid_t
modifier|*
name|gid
decl_stmt|;
name|char
modifier|*
modifier|*
name|username
decl_stmt|,
decl|*
modifier|*
name|groupname
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|char
modifier|*
name|tired
init|=
literal|"virtual memory exhausted"
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|use_login_group
init|=
literal|0
decl_stmt|;
operator|*
name|username
operator|=
operator|*
name|groupname
operator|=
name|NULL
expr_stmt|;
comment|/* Check whether a group is given.  */
name|cp
operator|=
name|index
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|index
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|cp
operator|==
name|name
operator|+
literal|1
condition|)
comment|/* Neither user nor group given, just "." or ":".  */
return|return
literal|"can not omit both user and group"
return|;
else|else
comment|/* "user.".  */
name|use_login_group
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Explicit group.  */
operator|*
name|groupname
operator|=
name|strdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|groupname
operator|==
name|NULL
condition|)
return|return
name|tired
return|;
name|grp
operator|=
name|getgrnam
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|grp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|isnumber
argument_list|(
name|cp
argument_list|)
condition|)
return|return
literal|"invalid group"
return|;
operator|*
name|gid
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
name|endgrent
argument_list|()
expr_stmt|;
comment|/* Save a file descriptor.  */
block|}
block|}
comment|/* Parse the user name, now that any group has been removed.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
comment|/* No user name was given, just a group.  */
return|return
name|NULL
return|;
operator|*
name|username
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|username
operator|==
name|NULL
condition|)
return|return
name|tired
return|;
name|pwd
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|isnumber
argument_list|(
name|name
argument_list|)
condition|)
return|return
literal|"invalid user"
return|;
if|if
condition|(
name|use_login_group
condition|)
return|return
literal|"cannot get the login group of a numeric UID"
return|;
operator|*
name|uid
operator|=
name|atoi
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|uid
operator|=
name|pwd
operator|->
name|pw_uid
expr_stmt|;
if|if
condition|(
name|use_login_group
condition|)
block|{
operator|*
name|gid
operator|=
name|pwd
operator|->
name|pw_gid
expr_stmt|;
name|grp
operator|=
name|getgrgid
argument_list|(
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|grp
operator|==
name|NULL
condition|)
block|{
operator|*
name|groupname
operator|=
name|malloc
argument_list|(
literal|15
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|groupname
operator|==
name|NULL
condition|)
return|return
name|tired
return|;
name|sprintf
argument_list|(
operator|*
name|groupname
argument_list|,
literal|"%u"
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|groupname
operator|=
name|strdup
argument_list|(
name|grp
operator|->
name|gr_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|groupname
operator|==
name|NULL
condition|)
return|return
name|tired
return|;
block|}
name|endgrent
argument_list|()
expr_stmt|;
block|}
block|}
name|endpwent
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_block

begin_comment
comment|/* Return nonzero if STR represents an unsigned decimal integer,    otherwise return 0. */
end_comment

begin_function
specifier|static
name|int
name|isnumber
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
for|for
control|(
init|;
operator|*
name|str
condition|;
name|str
operator|++
control|)
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|str
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

end_unit

