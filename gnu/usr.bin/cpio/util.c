begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* util.c - Several utility routines for cpio.    Copyright (C) 1990, 1991, 1992 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HPUX_CDF
end_ifdef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"system.h"
end_include

begin_include
include|#
directive|include
file|"cpiohdr.h"
end_include

begin_include
include|#
directive|include
file|"dstring.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_include
include|#
directive|include
file|"rmt.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__MSDOS__
end_ifndef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_MTIO_H
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IO_TRIOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/io/trioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|empty_output_buffer_swap
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hash_insert
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Write `output_size' bytes of `output_buffer' to file    descriptor OUT_DES and reset `output_size' and `out_buff'.  */
end_comment

begin_function
name|void
name|empty_output_buffer
parameter_list|(
name|out_des
parameter_list|)
name|int
name|out_des
decl_stmt|;
block|{
name|int
name|bytes_written
decl_stmt|;
ifdef|#
directive|ifdef
name|BROKEN_LONG_TAPE_DRIVER
specifier|static
name|long
name|output_bytes_before_lseek
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|swapping_halfwords
operator|||
name|swapping_bytes
condition|)
block|{
name|empty_output_buffer_swap
argument_list|(
name|out_des
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|BROKEN_LONG_TAPE_DRIVER
comment|/* Some tape drivers seem to have a signed internal seek pointer and      they lose if it overflows and becomes negative (e.g. when writing      tapes> 2Gb).  Doing an lseek (des, 0, SEEK_SET) seems to reset the      seek pointer and prevent it from overflowing.  */
if|if
condition|(
name|output_is_special
operator|&&
operator|(
name|output_bytes_before_lseek
operator|+=
name|output_size
operator|)
operator|<
literal|0L
condition|)
block|{
name|lseek
argument_list|(
name|out_des
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|output_bytes_before_lseek
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|bytes_written
operator|=
name|rmtwrite
argument_list|(
name|out_des
argument_list|,
name|output_buffer
argument_list|,
name|output_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_written
operator|!=
name|output_size
condition|)
block|{
name|int
name|rest_bytes_written
decl_stmt|;
name|int
name|rest_output_size
decl_stmt|;
if|if
condition|(
name|output_is_special
operator|&&
operator|(
name|bytes_written
operator|>=
literal|0
operator|||
operator|(
name|bytes_written
operator|<
literal|0
operator|&&
operator|(
name|errno
operator|==
name|ENOSPC
operator|||
name|errno
operator|==
name|EIO
operator|||
name|errno
operator|==
name|ENXIO
operator|)
operator|)
operator|)
condition|)
block|{
name|get_next_reel
argument_list|(
name|out_des
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_written
operator|>
literal|0
condition|)
name|rest_output_size
operator|=
name|output_size
operator|-
name|bytes_written
expr_stmt|;
else|else
name|rest_output_size
operator|=
name|output_size
expr_stmt|;
name|rest_bytes_written
operator|=
name|rmtwrite
argument_list|(
name|out_des
argument_list|,
name|output_buffer
argument_list|,
name|rest_output_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rest_bytes_written
operator|!=
name|rest_output_size
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
block|}
name|output_bytes
operator|+=
name|output_size
expr_stmt|;
name|out_buff
operator|=
name|output_buffer
expr_stmt|;
name|output_size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write `output_size' bytes of `output_buffer' to file    descriptor OUT_DES with byte and/or halfword swapping and reset    `output_size' and `out_buff'.  This routine should not be called    with `swapping_bytes' set unless the caller knows that the    file being written has an even number of bytes, and it should not be    called with `swapping_halfwords' set unless the caller knows    that the file being written has a length divisible by 4.  If either    of those restrictions are not met, bytes may be lost in the output    file.  OUT_DES must refer to a file that we are creating during    a process_copy_in, so we don't have to check for end of media    errors or be careful about only writing in blocks of `output_size'    bytes.  */
end_comment

begin_function
specifier|static
name|void
name|empty_output_buffer_swap
parameter_list|(
name|out_des
parameter_list|)
name|int
name|out_des
decl_stmt|;
block|{
comment|/* Since `output_size' might not be divisible by 4 or 2, we might      not be able to be able to swap all the bytes and halfwords in      `output_buffer' (e.g., if `output_size' is odd), so we might not be      able to write them all.  We will swap and write as many bytes as      we can, and save the rest in `left_overs' for the next time we are      called.  */
specifier|static
name|char
name|left_overs
index|[
literal|4
index|]
decl_stmt|;
specifier|static
name|int
name|left_over_bytes
init|=
literal|0
decl_stmt|;
name|int
name|bytes_written
decl_stmt|;
name|int
name|complete_halfwords
decl_stmt|;
name|int
name|complete_words
decl_stmt|;
name|int
name|extra_bytes
decl_stmt|;
name|output_bytes
operator|+=
name|output_size
expr_stmt|;
name|out_buff
operator|=
name|output_buffer
expr_stmt|;
if|if
condition|(
name|swapping_halfwords
condition|)
block|{
if|if
condition|(
name|left_over_bytes
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|output_size
operator|>
literal|0
operator|&&
name|left_over_bytes
operator|<
literal|4
condition|)
block|{
name|left_overs
index|[
name|left_over_bytes
operator|++
index|]
operator|=
operator|*
name|out_buff
operator|++
expr_stmt|;
operator|--
name|output_size
expr_stmt|;
block|}
if|if
condition|(
name|left_over_bytes
operator|<
literal|4
condition|)
block|{
name|out_buff
operator|=
name|output_buffer
expr_stmt|;
name|output_size
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|swahw_array
argument_list|(
name|left_overs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|swapping_bytes
condition|)
name|swab_array
argument_list|(
name|left_overs
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|bytes_written
operator|=
name|rmtwrite
argument_list|(
name|out_des
argument_list|,
name|left_overs
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_written
operator|!=
literal|4
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
name|left_over_bytes
operator|=
literal|0
expr_stmt|;
block|}
name|complete_words
operator|=
name|output_size
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|complete_words
operator|>
literal|0
condition|)
block|{
name|swahw_array
argument_list|(
name|out_buff
argument_list|,
name|complete_words
argument_list|)
expr_stmt|;
if|if
condition|(
name|swapping_bytes
condition|)
name|swab_array
argument_list|(
name|out_buff
argument_list|,
literal|2
operator|*
name|complete_words
argument_list|)
expr_stmt|;
name|bytes_written
operator|=
name|rmtwrite
argument_list|(
name|out_des
argument_list|,
name|out_buff
argument_list|,
literal|4
operator|*
name|complete_words
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_written
operator|!=
operator|(
literal|4
operator|*
name|complete_words
operator|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
block|}
name|out_buff
operator|+=
operator|(
literal|4
operator|*
name|complete_words
operator|)
expr_stmt|;
name|extra_bytes
operator|=
name|output_size
operator|%
literal|4
expr_stmt|;
while|while
condition|(
name|extra_bytes
operator|>
literal|0
condition|)
block|{
name|left_overs
index|[
name|left_over_bytes
operator|++
index|]
operator|=
operator|*
name|out_buff
operator|++
expr_stmt|;
operator|--
name|extra_bytes
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|left_over_bytes
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|output_size
operator|>
literal|0
operator|&&
name|left_over_bytes
operator|<
literal|2
condition|)
block|{
name|left_overs
index|[
name|left_over_bytes
operator|++
index|]
operator|=
operator|*
name|out_buff
operator|++
expr_stmt|;
operator|--
name|output_size
expr_stmt|;
block|}
if|if
condition|(
name|left_over_bytes
operator|<
literal|2
condition|)
block|{
name|out_buff
operator|=
name|output_buffer
expr_stmt|;
name|output_size
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|swab_array
argument_list|(
name|left_overs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bytes_written
operator|=
name|rmtwrite
argument_list|(
name|out_des
argument_list|,
name|left_overs
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_written
operator|!=
literal|2
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
name|left_over_bytes
operator|=
literal|0
expr_stmt|;
block|}
name|complete_halfwords
operator|=
name|output_size
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|complete_halfwords
operator|>
literal|0
condition|)
block|{
name|swab_array
argument_list|(
name|out_buff
argument_list|,
name|complete_halfwords
argument_list|)
expr_stmt|;
name|bytes_written
operator|=
name|rmtwrite
argument_list|(
name|out_des
argument_list|,
name|out_buff
argument_list|,
literal|2
operator|*
name|complete_halfwords
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_written
operator|!=
operator|(
literal|2
operator|*
name|complete_halfwords
operator|)
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
block|}
name|out_buff
operator|+=
operator|(
literal|2
operator|*
name|complete_halfwords
operator|)
expr_stmt|;
name|extra_bytes
operator|=
name|output_size
operator|%
literal|2
expr_stmt|;
while|while
condition|(
name|extra_bytes
operator|>
literal|0
condition|)
block|{
name|left_overs
index|[
name|left_over_bytes
operator|++
index|]
operator|=
operator|*
name|out_buff
operator|++
expr_stmt|;
operator|--
name|extra_bytes
expr_stmt|;
block|}
block|}
name|out_buff
operator|=
name|output_buffer
expr_stmt|;
name|output_size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Exchange the halfwords of each element of the array of COUNT longs    starting at PTR.  PTR does not have to be aligned at a word    boundary.  */
end_comment

begin_function
name|void
name|swahw_array
parameter_list|(
name|ptr
parameter_list|,
name|count
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|char
name|tmp
decl_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
operator|--
name|count
control|)
block|{
name|tmp
operator|=
operator|*
name|ptr
expr_stmt|;
operator|*
name|ptr
operator|=
operator|*
operator|(
name|ptr
operator|+
literal|2
operator|)
expr_stmt|;
operator|*
operator|(
name|ptr
operator|+
literal|2
operator|)
operator|=
name|tmp
expr_stmt|;
operator|++
name|ptr
expr_stmt|;
name|tmp
operator|=
operator|*
name|ptr
expr_stmt|;
operator|*
name|ptr
operator|=
operator|*
operator|(
name|ptr
operator|+
literal|2
operator|)
expr_stmt|;
operator|*
operator|(
name|ptr
operator|+
literal|2
operator|)
operator|=
name|tmp
expr_stmt|;
name|ptr
operator|+=
literal|3
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read at most NUM_BYTES or `io_block_size' bytes, whichever is smaller,    into the start of `input_buffer' from file descriptor IN_DES.    Set `input_size' to the number of bytes read and reset `in_buff'.    Exit with an error if end of file is reached.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BROKEN_LONG_TAPE_DRIVER
end_ifdef

begin_decl_stmt
specifier|static
name|long
name|input_bytes_before_lseek
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|fill_input_buffer
parameter_list|(
name|in_des
parameter_list|,
name|num_bytes
parameter_list|)
name|int
name|in_des
decl_stmt|;
name|int
name|num_bytes
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|BROKEN_LONG_TAPE_DRIVER
comment|/* Some tape drivers seem to have a signed internal seek pointer and      they lose if it overflows and becomes negative (e.g. when writing      tapes> 4Gb).  Doing an lseek (des, 0, SEEK_SET) seems to reset the      seek pointer and prevent it from overflowing.  */
if|if
condition|(
name|input_is_special
operator|&&
operator|(
name|input_bytes_before_lseek
operator|+=
name|num_bytes
operator|)
operator|<
literal|0L
condition|)
block|{
name|lseek
argument_list|(
name|in_des
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|input_bytes_before_lseek
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|in_buff
operator|=
name|input_buffer
expr_stmt|;
name|num_bytes
operator|=
operator|(
name|num_bytes
operator|<
name|io_block_size
operator|)
condition|?
name|num_bytes
else|:
name|io_block_size
expr_stmt|;
name|input_size
operator|=
name|rmtread
argument_list|(
name|in_des
argument_list|,
name|input_buffer
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_size
operator|==
literal|0
operator|&&
name|input_is_special
condition|)
block|{
name|get_next_reel
argument_list|(
name|in_des
argument_list|)
expr_stmt|;
name|input_size
operator|=
name|rmtread
argument_list|(
name|in_des
argument_list|,
name|input_buffer
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|input_size
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"read error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input_size
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|"premature end of file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|input_bytes
operator|+=
name|input_size
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy NUM_BYTES of buffer IN_BUF to `out_buff', which may be partly full.    When `out_buff' fills up, flush it to file descriptor OUT_DES.  */
end_comment

begin_function
name|void
name|copy_buf_out
parameter_list|(
name|in_buf
parameter_list|,
name|out_des
parameter_list|,
name|num_bytes
parameter_list|)
name|char
modifier|*
name|in_buf
decl_stmt|;
name|int
name|out_des
decl_stmt|;
name|long
name|num_bytes
decl_stmt|;
block|{
specifier|register
name|long
name|bytes_left
init|=
name|num_bytes
decl_stmt|;
comment|/* Bytes needing to be copied.  */
specifier|register
name|long
name|space_left
decl_stmt|;
comment|/* Room left in output buffer.  */
while|while
condition|(
name|bytes_left
operator|>
literal|0
condition|)
block|{
name|space_left
operator|=
name|io_block_size
operator|-
name|output_size
expr_stmt|;
if|if
condition|(
name|space_left
operator|==
literal|0
condition|)
name|empty_output_buffer
argument_list|(
name|out_des
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|bytes_left
operator|<
name|space_left
condition|)
name|space_left
operator|=
name|bytes_left
expr_stmt|;
name|bcopy
argument_list|(
name|in_buf
argument_list|,
name|out_buff
argument_list|,
operator|(
name|unsigned
operator|)
name|space_left
argument_list|)
expr_stmt|;
name|out_buff
operator|+=
name|space_left
expr_stmt|;
name|output_size
operator|+=
name|space_left
expr_stmt|;
name|in_buf
operator|+=
name|space_left
expr_stmt|;
name|bytes_left
operator|-=
name|space_left
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Copy NUM_BYTES of buffer `in_buff' into IN_BUF.    `in_buff' may be partly full.    When `in_buff' is exhausted, refill it from file descriptor IN_DES.  */
end_comment

begin_function
name|void
name|copy_in_buf
parameter_list|(
name|in_buf
parameter_list|,
name|in_des
parameter_list|,
name|num_bytes
parameter_list|)
name|char
modifier|*
name|in_buf
decl_stmt|;
name|int
name|in_des
decl_stmt|;
name|long
name|num_bytes
decl_stmt|;
block|{
specifier|register
name|long
name|bytes_left
init|=
name|num_bytes
decl_stmt|;
comment|/* Bytes needing to be copied.  */
specifier|register
name|long
name|space_left
decl_stmt|;
comment|/* Bytes to copy from input buffer.  */
while|while
condition|(
name|bytes_left
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|input_size
operator|==
literal|0
condition|)
name|fill_input_buffer
argument_list|(
name|in_des
argument_list|,
name|io_block_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_left
operator|<
name|input_size
condition|)
name|space_left
operator|=
name|bytes_left
expr_stmt|;
else|else
name|space_left
operator|=
name|input_size
expr_stmt|;
name|bcopy
argument_list|(
name|in_buff
argument_list|,
name|in_buf
argument_list|,
operator|(
name|unsigned
operator|)
name|space_left
argument_list|)
expr_stmt|;
name|in_buff
operator|+=
name|space_left
expr_stmt|;
name|in_buf
operator|+=
name|space_left
expr_stmt|;
name|input_size
operator|-=
name|space_left
expr_stmt|;
name|bytes_left
operator|-=
name|space_left
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Copy the the next NUM_BYTES bytes of `input_buffer' into PEEK_BUF.    If NUM_BYTES bytes are not available, read the next `io_block_size' bytes    into the end of `input_buffer' and update `input_size'.     Return the number of bytes copied into PEEK_BUF.    If the number of bytes returned is less than NUM_BYTES,    then EOF has been reached.  */
end_comment

begin_function
name|int
name|peek_in_buf
parameter_list|(
name|peek_buf
parameter_list|,
name|in_des
parameter_list|,
name|num_bytes
parameter_list|)
name|char
modifier|*
name|peek_buf
decl_stmt|;
name|int
name|in_des
decl_stmt|;
name|int
name|num_bytes
decl_stmt|;
block|{
name|long
name|tmp_input_size
decl_stmt|;
name|long
name|got_bytes
decl_stmt|;
name|char
modifier|*
name|append_buf
decl_stmt|;
ifdef|#
directive|ifdef
name|BROKEN_LONG_TAPE_DRIVER
comment|/* Some tape drivers seem to have a signed internal seek pointer and      they lose if it overflows and becomes negative (e.g. when writing      tapes> 4Gb).  Doing an lseek (des, 0, SEEK_SET) seems to reset the      seek pointer and prevent it from overflowing.  */
if|if
condition|(
name|input_is_special
operator|&&
operator|(
name|input_bytes_before_lseek
operator|+=
name|num_bytes
operator|)
operator|<
literal|0L
condition|)
block|{
name|lseek
argument_list|(
name|in_des
argument_list|,
literal|0L
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|input_bytes_before_lseek
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
name|input_size
operator|<
name|num_bytes
condition|)
block|{
name|append_buf
operator|=
name|in_buff
operator|+
name|input_size
expr_stmt|;
name|tmp_input_size
operator|=
name|rmtread
argument_list|(
name|in_des
argument_list|,
name|append_buf
argument_list|,
name|io_block_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_input_size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|input_is_special
condition|)
block|{
name|get_next_reel
argument_list|(
name|in_des
argument_list|)
expr_stmt|;
name|tmp_input_size
operator|=
name|rmtread
argument_list|(
name|in_des
argument_list|,
name|append_buf
argument_list|,
name|io_block_size
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|tmp_input_size
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"read error"
argument_list|)
expr_stmt|;
name|input_bytes
operator|+=
name|tmp_input_size
expr_stmt|;
name|input_size
operator|+=
name|tmp_input_size
expr_stmt|;
block|}
if|if
condition|(
name|num_bytes
operator|<=
name|input_size
condition|)
name|got_bytes
operator|=
name|num_bytes
expr_stmt|;
else|else
name|got_bytes
operator|=
name|input_size
expr_stmt|;
name|bcopy
argument_list|(
name|in_buff
argument_list|,
name|peek_buf
argument_list|,
operator|(
name|unsigned
operator|)
name|got_bytes
argument_list|)
expr_stmt|;
return|return
name|got_bytes
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Skip the next NUM_BYTES bytes of file descriptor IN_DES.  */
end_comment

begin_function
name|void
name|toss_input
parameter_list|(
name|in_des
parameter_list|,
name|num_bytes
parameter_list|)
name|int
name|in_des
decl_stmt|;
name|long
name|num_bytes
decl_stmt|;
block|{
specifier|register
name|long
name|bytes_left
init|=
name|num_bytes
decl_stmt|;
comment|/* Bytes needing to be copied.  */
specifier|register
name|long
name|space_left
decl_stmt|;
comment|/* Bytes to copy from input buffer.  */
while|while
condition|(
name|bytes_left
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|input_size
operator|==
literal|0
condition|)
name|fill_input_buffer
argument_list|(
name|in_des
argument_list|,
name|io_block_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_left
operator|<
name|input_size
condition|)
name|space_left
operator|=
name|bytes_left
expr_stmt|;
else|else
name|space_left
operator|=
name|input_size
expr_stmt|;
name|in_buff
operator|+=
name|space_left
expr_stmt|;
name|input_size
operator|-=
name|space_left
expr_stmt|;
name|bytes_left
operator|-=
name|space_left
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy a file using the input and output buffers, which may start out    partly full.  After the copy, the files are not closed nor the last    block flushed to output, and the input buffer may still be partly    full.  If `crc_i_flag' is set, add each byte to `crc'.    IN_DES is the file descriptor for input;    OUT_DES is the file descriptor for output;    NUM_BYTES is the number of bytes to copy.  */
end_comment

begin_function
name|void
name|copy_files
parameter_list|(
name|in_des
parameter_list|,
name|out_des
parameter_list|,
name|num_bytes
parameter_list|)
name|int
name|in_des
decl_stmt|;
name|int
name|out_des
decl_stmt|;
name|long
name|num_bytes
decl_stmt|;
block|{
name|long
name|size
decl_stmt|;
name|long
name|k
decl_stmt|;
while|while
condition|(
name|num_bytes
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|input_size
operator|==
literal|0
condition|)
name|fill_input_buffer
argument_list|(
name|in_des
argument_list|,
name|io_block_size
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|input_size
operator|<
name|num_bytes
operator|)
condition|?
name|input_size
else|:
name|num_bytes
expr_stmt|;
if|if
condition|(
name|crc_i_flag
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|size
condition|;
operator|++
name|k
control|)
name|crc
operator|+=
name|in_buff
index|[
name|k
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
name|copy_buf_out
argument_list|(
name|in_buff
argument_list|,
name|out_des
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|num_bytes
operator|-=
name|size
expr_stmt|;
name|input_size
operator|-=
name|size
expr_stmt|;
name|in_buff
operator|+=
name|size
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create all directories up to but not including the last part of NAME.    Do not destroy any nondirectories while creating directories.  */
end_comment

begin_function
name|void
name|create_all_directories
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|mode
decl_stmt|;
ifdef|#
directive|ifdef
name|HPUX_CDF
name|int
name|cdf
decl_stmt|;
endif|#
directive|endif
name|dir
operator|=
name|dirname
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|mode
operator|=
literal|0700
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUX_CDF
name|cdf
operator|=
name|islastparentcdf
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdf
condition|)
block|{
name|dir
index|[
name|strlen
argument_list|(
name|dir
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* remove final + */
name|mode
operator|=
literal|04700
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|dir
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"virtual memory exhausted"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
name|dir
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|make_path
argument_list|(
name|dir
argument_list|,
name|mode
argument_list|,
literal|0700
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prepare to append to an archive.  We have been in    process_copy_in, keeping track of the position where    the last header started in `last_header_start'.  Now we    have the starting position of the last header (the TRAILER!!!    header, or blank record for tar archives) and we want to start    writing (appending) over the last header.  The last header may    be in the middle of a block, so to keep the buffering in sync    we lseek back to the start of the block, read everything up    to but not including the last header, lseek back to the start    of the block, and then do a copy_buf_out of what we read.    Actually, we probably don't have to worry so much about keeping the    buffering perfect since you can only append to archives that    are disk files.  */
end_comment

begin_function
name|void
name|prepare_append
parameter_list|(
name|out_file_des
parameter_list|)
name|int
name|out_file_des
decl_stmt|;
block|{
name|int
name|start_of_header
decl_stmt|;
name|int
name|start_of_block
decl_stmt|;
name|int
name|useful_bytes_in_block
decl_stmt|;
name|char
modifier|*
name|tmp_buf
decl_stmt|;
name|start_of_header
operator|=
name|last_header_start
expr_stmt|;
comment|/* Figure out how many bytes we will rewrite, and where they start.  */
name|useful_bytes_in_block
operator|=
name|start_of_header
operator|%
name|io_block_size
expr_stmt|;
name|start_of_block
operator|=
name|start_of_header
operator|-
name|useful_bytes_in_block
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|out_file_des
argument_list|,
name|start_of_block
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot seek on output"
argument_list|)
expr_stmt|;
if|if
condition|(
name|useful_bytes_in_block
operator|>
literal|0
condition|)
block|{
name|tmp_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|useful_bytes_in_block
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|out_file_des
argument_list|,
name|tmp_buf
argument_list|,
name|useful_bytes_in_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|out_file_des
argument_list|,
name|start_of_block
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"cannot seek on output"
argument_list|)
expr_stmt|;
name|copy_buf_out
argument_list|(
name|tmp_buf
argument_list|,
name|out_file_des
argument_list|,
name|useful_bytes_in_block
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_buf
argument_list|)
expr_stmt|;
block|}
comment|/* We are done reading the archive, so clear these since they      will now be used for reading in files that we are appending      to the archive.  */
name|input_size
operator|=
literal|0
expr_stmt|;
name|input_bytes
operator|=
literal|0
expr_stmt|;
name|in_buff
operator|=
name|input_buffer
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Support for remembering inodes with multiple links.  Used in the    "copy in" and "copy pass" modes for making links instead of copying    the file.  */
end_comment

begin_struct
struct|struct
name|inode_val
block|{
name|unsigned
name|long
name|inode
decl_stmt|;
name|unsigned
name|long
name|major_num
decl_stmt|;
name|unsigned
name|long
name|minor_num
decl_stmt|;
name|char
modifier|*
name|file_name
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Inode hash table.  Allocated by first call to add_inode.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|inode_val
modifier|*
modifier|*
name|hash_table
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of current hash table.  Initial size is 47.  (47 = 2*22 + 3) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hash_size
init|=
literal|22
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of elements in current hash table.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hash_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Find the file name associated with NODE_NUM.  If there is no file    associated with NODE_NUM, return NULL.  */
end_comment

begin_function
name|char
modifier|*
name|find_inode_file
parameter_list|(
name|node_num
parameter_list|,
name|major_num
parameter_list|,
name|minor_num
parameter_list|)
name|unsigned
name|long
name|node_num
decl_stmt|;
name|unsigned
name|long
name|major_num
decl_stmt|;
name|unsigned
name|long
name|minor_num
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|__MSDOS__
name|int
name|start
decl_stmt|;
comment|/* Initial hash location.  */
name|int
name|temp
decl_stmt|;
comment|/* Rehash search variable.  */
if|if
condition|(
name|hash_table
operator|!=
name|NULL
condition|)
block|{
comment|/* Hash function is node number modulo the table size.  */
name|start
operator|=
name|node_num
operator|%
name|hash_size
expr_stmt|;
comment|/* Initial look into the table.  */
if|if
condition|(
name|hash_table
index|[
name|start
index|]
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|hash_table
index|[
name|start
index|]
operator|->
name|inode
operator|==
name|node_num
operator|&&
name|hash_table
index|[
name|start
index|]
operator|->
name|major_num
operator|==
name|major_num
operator|&&
name|hash_table
index|[
name|start
index|]
operator|->
name|minor_num
operator|==
name|minor_num
condition|)
return|return
name|hash_table
index|[
name|start
index|]
operator|->
name|file_name
return|;
comment|/* The home position is full with a different inode record. 	 Do a linear search terminated by a NULL pointer.  */
for|for
control|(
name|temp
operator|=
operator|(
name|start
operator|+
literal|1
operator|)
operator|%
name|hash_size
init|;
name|hash_table
index|[
name|temp
index|]
operator|!=
name|NULL
operator|&&
name|temp
operator|!=
name|start
condition|;
name|temp
operator|=
operator|(
name|temp
operator|+
literal|1
operator|)
operator|%
name|hash_size
control|)
block|{
if|if
condition|(
name|hash_table
index|[
name|temp
index|]
operator|->
name|inode
operator|==
name|node_num
operator|&&
name|hash_table
index|[
name|start
index|]
operator|->
name|major_num
operator|==
name|major_num
operator|&&
name|hash_table
index|[
name|start
index|]
operator|->
name|minor_num
operator|==
name|minor_num
condition|)
return|return
name|hash_table
index|[
name|temp
index|]
operator|->
name|file_name
return|;
block|}
block|}
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Associate FILE_NAME with the inode NODE_NUM.  (Insert into hash table.)  */
end_comment

begin_function
name|void
name|add_inode
parameter_list|(
name|node_num
parameter_list|,
name|file_name
parameter_list|,
name|major_num
parameter_list|,
name|minor_num
parameter_list|)
name|unsigned
name|long
name|node_num
decl_stmt|;
name|char
modifier|*
name|file_name
decl_stmt|;
name|unsigned
name|long
name|major_num
decl_stmt|;
name|unsigned
name|long
name|minor_num
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|__MSDOS__
name|struct
name|inode_val
modifier|*
name|temp
decl_stmt|;
comment|/* Create new inode record.  */
name|temp
operator|=
operator|(
expr|struct
name|inode_val
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|inode_val
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|inode
operator|=
name|node_num
expr_stmt|;
name|temp
operator|->
name|major_num
operator|=
name|major_num
expr_stmt|;
name|temp
operator|->
name|minor_num
operator|=
name|minor_num
expr_stmt|;
name|temp
operator|->
name|file_name
operator|=
name|xstrdup
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
comment|/* Do we have to increase the size of (or initially allocate)      the hash table?  */
if|if
condition|(
name|hash_num
operator|==
name|hash_size
operator|||
name|hash_table
operator|==
name|NULL
condition|)
block|{
name|struct
name|inode_val
modifier|*
modifier|*
name|old_table
decl_stmt|;
comment|/* Pointer to old table.  */
name|int
name|i
decl_stmt|;
comment|/* Index for re-insert loop.  */
comment|/* Save old table.  */
name|old_table
operator|=
name|hash_table
expr_stmt|;
if|if
condition|(
name|old_table
operator|==
name|NULL
condition|)
name|hash_num
operator|=
literal|0
expr_stmt|;
comment|/* Calculate new size of table and allocate it.          Sequence of table sizes is 47, 97, 197, 397, 797, 1597, 3197, 6397 ... 	 where 3197 and most of the sizes after 6397 are not prime.  The other 	 numbers listed are prime.  */
name|hash_size
operator|=
literal|2
operator|*
name|hash_size
operator|+
literal|3
expr_stmt|;
name|hash_table
operator|=
operator|(
expr|struct
name|inode_val
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|hash_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|inode_val
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|hash_table
argument_list|,
name|hash_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|inode_val
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Insert the values from the old table into the new table.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hash_num
condition|;
name|i
operator|++
control|)
name|hash_insert
argument_list|(
name|old_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_table
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|old_table
argument_list|)
expr_stmt|;
block|}
comment|/* Insert the new record and increment the count of elements in the       hash table.  */
name|hash_insert
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|hash_num
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* __MSDOS__ */
block|}
end_function

begin_comment
comment|/* Do the hash insert.  Used in normal inserts and resizing the hash    table.  It is guaranteed that there is room to insert the item.    NEW_VALUE is the pointer to the previously allocated inode, file    name association record.  */
end_comment

begin_function
specifier|static
name|void
name|hash_insert
parameter_list|(
name|new_value
parameter_list|)
name|struct
name|inode_val
modifier|*
name|new_value
decl_stmt|;
block|{
name|int
name|start
decl_stmt|;
comment|/* Home position for the value.  */
name|int
name|temp
decl_stmt|;
comment|/* Used for rehashing.  */
comment|/* Hash function is node number modulo the table size.  */
name|start
operator|=
name|new_value
operator|->
name|inode
operator|%
name|hash_size
expr_stmt|;
comment|/* Do the initial look into the table.  */
if|if
condition|(
name|hash_table
index|[
name|start
index|]
operator|==
name|NULL
condition|)
block|{
name|hash_table
index|[
name|start
index|]
operator|=
name|new_value
expr_stmt|;
return|return;
block|}
comment|/* If we get to here, the home position is full with a different inode      record.  Do a linear search for the first NULL pointer and insert      the new item there.  */
name|temp
operator|=
operator|(
name|start
operator|+
literal|1
operator|)
operator|%
name|hash_size
expr_stmt|;
while|while
condition|(
name|hash_table
index|[
name|temp
index|]
operator|!=
name|NULL
condition|)
name|temp
operator|=
operator|(
name|temp
operator|+
literal|1
operator|)
operator|%
name|hash_size
expr_stmt|;
comment|/* Insert at the NULL.  */
name|hash_table
index|[
name|temp
index|]
operator|=
name|new_value
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Open FILE in the mode specified by the command line options    and return an open file descriptor for it,    or -1 if it can't be opened.  */
end_comment

begin_function
name|int
name|open_archive
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|void
function_decl|(
modifier|*
name|copy_in
function_decl|)
parameter_list|()
function_decl|;
comment|/* Workaround for pcc bug.  */
name|copy_in
operator|=
name|process_copy_in
expr_stmt|;
if|if
condition|(
name|copy_function
operator|==
name|copy_in
condition|)
name|fd
operator|=
name|rmtopen
argument_list|(
name|file
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|append_flag
condition|)
name|fd
operator|=
name|rmtopen
argument_list|(
name|file
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_BINARY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
else|else
name|fd
operator|=
name|rmtopen
argument_list|(
name|file
argument_list|,
name|O_RDWR
operator||
name|O_BINARY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
block|}
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/* Attempt to rewind the tape drive on file descriptor TAPE_DES    and take it offline.  */
end_comment

begin_function
name|void
name|tape_offline
parameter_list|(
name|tape_des
parameter_list|)
name|int
name|tape_des
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|MTIOCTOP
argument_list|)
operator|&&
name|defined
argument_list|(
name|MTOFFL
argument_list|)
name|struct
name|mtop
name|control
decl_stmt|;
name|control
operator|.
name|mt_op
operator|=
name|MTOFFL
expr_stmt|;
name|control
operator|.
name|mt_count
operator|=
literal|1
expr_stmt|;
name|rmtioctl
argument_list|(
name|tape_des
argument_list|,
name|MTIOCTOP
argument_list|,
operator|&
name|control
argument_list|)
expr_stmt|;
comment|/* Don't care if it fails.  */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* The file on file descriptor TAPE_DES is assumed to be magnetic tape    (or floppy disk or other device) and the end of the medium    has been reached.  Ask the user for to mount a new "tape" to continue    the processing.  If the user specified the device name on the    command line (with the -I, -O, -F or --file options), then we can    automatically re-open the same device to use the next medium.  If the    user did not specify the device name, then we have to ask them which    device to use.  */
end_comment

begin_function
name|void
name|get_next_reel
parameter_list|(
name|tape_des
parameter_list|)
name|int
name|tape_des
decl_stmt|;
block|{
specifier|static
name|int
name|reel_number
init|=
literal|1
decl_stmt|;
name|FILE
modifier|*
name|tty_in
decl_stmt|;
comment|/* File for interacting with user.  */
name|FILE
modifier|*
name|tty_out
decl_stmt|;
comment|/* File for interacting with user.  */
name|int
name|old_tape_des
decl_stmt|;
name|char
modifier|*
name|next_archive_name
decl_stmt|;
name|dynamic_string
name|new_name
decl_stmt|;
name|char
modifier|*
name|str_res
decl_stmt|;
name|ds_init
argument_list|(
operator|&
name|new_name
argument_list|,
literal|128
argument_list|)
expr_stmt|;
comment|/* Open files for interactive communication.  */
name|tty_in
operator|=
name|fopen
argument_list|(
name|CONSOLE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_in
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
name|CONSOLE
argument_list|)
expr_stmt|;
name|tty_out
operator|=
name|fopen
argument_list|(
name|CONSOLE
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_out
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|2
argument_list|,
name|errno
argument_list|,
name|CONSOLE
argument_list|)
expr_stmt|;
name|old_tape_des
operator|=
name|tape_des
expr_stmt|;
name|tape_offline
argument_list|(
name|tape_des
argument_list|)
expr_stmt|;
name|rmtclose
argument_list|(
name|tape_des
argument_list|)
expr_stmt|;
comment|/* Give message and wait for carrage return.  User should hit carrage return      only after loading the next tape.  */
operator|++
name|reel_number
expr_stmt|;
if|if
condition|(
name|new_media_message
condition|)
name|fprintf
argument_list|(
name|tty_out
argument_list|,
literal|"%s"
argument_list|,
name|new_media_message
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|new_media_message_with_number
condition|)
name|fprintf
argument_list|(
name|tty_out
argument_list|,
literal|"%s%d%s"
argument_list|,
name|new_media_message_with_number
argument_list|,
name|reel_number
argument_list|,
name|new_media_message_after_number
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|archive_name
condition|)
name|fprintf
argument_list|(
name|tty_out
argument_list|,
literal|"Found end of volume.  Load next volume and press RETURN. "
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|tty_out
argument_list|,
literal|"Found end of volume.  To continue, type device/file name when ready.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|tty_out
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_name
condition|)
block|{
name|int
name|c
decl_stmt|;
do|do
name|c
operator|=
name|getc
argument_list|(
name|tty_in
argument_list|)
expr_stmt|;
do|while
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
do|;
name|tape_des
operator|=
name|open_archive
argument_list|(
name|archive_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tape_des
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|archive_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
if|if
condition|(
name|tape_des
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|tty_out
argument_list|,
literal|"To continue, type device/file name when ready.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|tty_out
argument_list|)
expr_stmt|;
block|}
name|str_res
operator|=
name|ds_fgets
argument_list|(
name|tty_in
argument_list|,
operator|&
name|new_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_res
operator|==
name|NULL
operator|||
name|str_res
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|next_archive_name
operator|=
name|str_res
expr_stmt|;
name|tape_des
operator|=
name|open_archive
argument_list|(
name|next_archive_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tape_des
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|next_archive_name
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|tape_des
operator|<
literal|0
condition|)
do|;
block|}
comment|/* We have to make sure that `tape_des' has not changed its value even      though we closed it and reopened it, since there are local      copies of it in other routines.  This works fine on Unix (even with      rmtread and rmtwrite) since open will always return the lowest      available file descriptor and we haven't closed any files (e.g.,      stdin, stdout or stderr) that were opened before we originally opened      the archive.  */
if|if
condition|(
name|tape_des
operator|!=
name|old_tape_des
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"internal error: tape descriptor changed from %d to %d"
argument_list|,
name|old_tape_des
argument_list|,
name|tape_des
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_name
operator|.
name|ds_string
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tty_in
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tty_out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If MESSAGE does not contain the string "%d", make `new_media_message'    a copy of MESSAGE.  If MESSAGES does contain the string "%d", make    `new_media_message_with_number' a copy of MESSAGE up to, but    not including, the string "%d", and make `new_media_message_after_number'    a copy of MESSAGE after the string "%d".  */
end_comment

begin_function
name|void
name|set_new_media_message
parameter_list|(
name|message
parameter_list|)
name|char
modifier|*
name|message
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|prev_was_percent
decl_stmt|;
name|p
operator|=
name|message
expr_stmt|;
name|prev_was_percent
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'d'
operator|&&
name|prev_was_percent
condition|)
break|break;
name|prev_was_percent
operator|=
operator|(
operator|*
name|p
operator|==
literal|'%'
operator|)
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|new_media_message
operator|=
name|xstrdup
argument_list|(
name|message
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|length
init|=
name|p
operator|-
name|message
operator|-
literal|1
decl_stmt|;
name|new_media_message_with_number
operator|=
name|xmalloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new_media_message_with_number
argument_list|,
name|message
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|new_media_message_with_number
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|new_media_message_after_number
operator|=
name|xmalloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new_media_message_after_number
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SYMLINK_USES_UMASK
end_ifdef

begin_comment
comment|/* Most machines always create symlinks with rwxrwxrwx protection,    but some (HP/UX 8.07; maybe DEC's OSF on MIPS, too?) use the    umask when creating symlinks, so if your umask is 022 you end    up with rwxr-xr-x symlinks (although HP/UX seems to completely    ignore the protection).  There doesn't seem to be any way to    manipulate the modes once the symlinks are created (e.g.    a hypothetical "lchmod"), so to create them with the right    modes we have to set the umask first.  */
end_comment

begin_function
name|int
name|umasked_symlink
parameter_list|(
name|name1
parameter_list|,
name|name2
parameter_list|,
name|mode
parameter_list|)
name|char
modifier|*
name|name1
decl_stmt|;
name|char
modifier|*
name|name2
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|int
name|old_umask
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|mode
operator|=
operator|~
operator|(
name|mode
operator|&
literal|0777
operator|)
operator|&
literal|0777
expr_stmt|;
name|old_umask
operator|=
name|umask
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|rc
operator|=
name|symlink
argument_list|(
name|name1
argument_list|,
name|name2
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|old_umask
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYMLINK_USES_UMASK */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__MSDOS__
end_ifdef

begin_function
name|int
name|chown
parameter_list|(
name|path
parameter_list|,
name|owner
parameter_list|,
name|group
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|owner
decl_stmt|,
name|group
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__TURBOC__
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_function
name|int
name|utime
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|struct
name|utimbuf
modifier|*
name|utb
parameter_list|)
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|struct
name|ftime
name|filetime
decl_stmt|;
name|time_t
name|when
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|utb
operator|==
literal|0
condition|)
name|when
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|when
operator|=
name|utb
operator|->
name|modtime
expr_stmt|;
name|fd
operator|=
name|_open
argument_list|(
name|filename
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|when
argument_list|)
expr_stmt|;
if|if
condition|(
name|tm
operator|->
name|tm_year
operator|<
literal|80
condition|)
name|filetime
operator|.
name|ft_year
operator|=
literal|0
expr_stmt|;
else|else
name|filetime
operator|.
name|ft_year
operator|=
name|tm
operator|->
name|tm_year
operator|-
literal|80
expr_stmt|;
name|filetime
operator|.
name|ft_month
operator|=
name|tm
operator|->
name|tm_mon
operator|+
literal|1
expr_stmt|;
name|filetime
operator|.
name|ft_day
operator|=
name|tm
operator|->
name|tm_mday
expr_stmt|;
if|if
condition|(
name|tm
operator|->
name|tm_hour
operator|<
literal|0
condition|)
name|filetime
operator|.
name|ft_hour
operator|=
literal|0
expr_stmt|;
else|else
name|filetime
operator|.
name|ft_hour
operator|=
name|tm
operator|->
name|tm_hour
expr_stmt|;
name|filetime
operator|.
name|ft_min
operator|=
name|tm
operator|->
name|tm_min
expr_stmt|;
name|filetime
operator|.
name|ft_tsec
operator|=
name|tm
operator|->
name|tm_sec
operator|/
literal|2
expr_stmt|;
name|status
operator|=
name|setftime
argument_list|(
name|fd
argument_list|,
operator|&
name|filetime
argument_list|)
expr_stmt|;
name|_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HPUX_CDF
end_ifdef

begin_comment
comment|/* When we create a cpio archive we mark CDF's by putting an extra `/'    after their component name so we can distinguish the CDF's when we    extract the archive (in case the "hidden" directory's files appear    in the archive before the directory itself).  E.g., in the path    "a/b+/c", if b+ is a CDF, we will write this path as "a/b+//c" in    the archive so when we extract the archive we will know that b+    is actually a CDF, and not an ordinary directory whose name happens    to end in `+'.  We also do the same thing internally in copypass.c.  */
end_comment

begin_comment
comment|/* Take an input pathname and check it for CDF's.  Insert an extra    `/' in the pathname after each "hidden" directory.  If we add    any `/'s, return a malloced string (which it will reuse for    later calls so our caller doesn't have to worry about freeing    the string) instead of the original input string.  */
end_comment

begin_function
name|char
modifier|*
name|add_cdf_double_slashes
parameter_list|(
name|input_name
parameter_list|)
name|char
modifier|*
name|input_name
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|ret_name
init|=
name|NULL
decl_stmt|;
comment|/* re-usuable return buffer (malloc'ed)  */
specifier|static
name|int
name|ret_size
init|=
operator|-
literal|1
decl_stmt|;
comment|/* size of return buffer.  */
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|n
decl_stmt|;
name|struct
name|stat
name|dir_stat
decl_stmt|;
comment|/*  Search for a `/' preceeded by a `+'.  */
for|for
control|(
name|p
operator|=
name|input_name
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'+'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'/'
operator|)
condition|)
break|break;
block|}
comment|/* If we didn't find a `/' preceeded by a `+' then there are      no CDF's in this pathname.  Return the original pathname.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
name|input_name
return|;
comment|/* There was a `/' preceeded by a `+' in the pathname.  If it is a CDF      then we will need to copy the input pathname to our return      buffer so we can insert the extra `/'s.  Since we can't tell      yet whether or not it is a CDF we will just always copy the      string to the return buffer.  First we have to make sure the      buffer is large enough to hold the string and any number of      extra `/'s we might add.  */
name|n
operator|=
literal|2
operator|*
operator|(
name|strlen
argument_list|(
name|input_name
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|ret_size
condition|)
block|{
if|if
condition|(
name|ret_size
operator|<
literal|0
condition|)
name|ret_name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
else|else
name|ret_name
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|ret_name
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|ret_size
operator|=
name|n
expr_stmt|;
block|}
comment|/* Clear the `/' after this component, so we can stat the pathname      up to and including this component.  */
operator|++
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|xstat
call|)
argument_list|(
name|input_name
argument_list|,
operator|&
name|dir_stat
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|input_name
argument_list|)
expr_stmt|;
return|return
name|input_name
return|;
block|}
comment|/* Now put back the `/' after this component and copy the pathname up to      and including this component and its trailing `/' to the return      buffer.  */
operator|*
name|p
operator|++
operator|=
literal|'/'
expr_stmt|;
name|strncpy
argument_list|(
name|ret_name
argument_list|,
name|input_name
argument_list|,
name|p
operator|-
name|input_name
argument_list|)
expr_stmt|;
name|q
operator|=
name|ret_name
operator|+
operator|(
name|p
operator|-
name|input_name
operator|)
expr_stmt|;
comment|/* If it was a CDF, add another `/'.  */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|dir_stat
operator|.
name|st_mode
argument_list|)
operator|&&
operator|(
name|dir_stat
operator|.
name|st_mode
operator|&
literal|04000
operator|)
condition|)
operator|*
name|q
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* Go through the rest of the input pathname, copying it to the      return buffer, and adding an extra `/' after each CDF.  */
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|p
operator|==
literal|'+'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'/'
operator|)
condition|)
block|{
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|xstat
call|)
argument_list|(
name|input_name
argument_list|,
operator|&
name|dir_stat
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|0
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|input_name
argument_list|)
expr_stmt|;
return|return
name|input_name
return|;
block|}
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|dir_stat
operator|.
name|st_mode
argument_list|)
operator|&&
operator|(
name|dir_stat
operator|.
name|st_mode
operator|&
literal|04000
operator|)
condition|)
operator|*
name|q
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ret_name
return|;
block|}
end_function

begin_comment
comment|/* Is the last parent directory (e.g., c in a/b/c/d) a CDF?  If the    directory name ends in `+' and is followed by 2 `/'s instead of 1    then it is.  This is only the case for cpio archives, but we don't    have to worry about tar because tar always has the directory before    its files (or else we lose).  */
end_comment

begin_macro
name|islastparentcdf
argument_list|(
argument|path
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|path
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|newpath
decl_stmt|;
name|char
modifier|*
name|slash
decl_stmt|;
name|int
name|slash_count
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* Length of result, not including NUL.  */
name|slash
operator|=
name|rindex
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
block|{
name|slash_count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|slash
operator|>
name|path
operator|&&
operator|*
name|slash
operator|==
literal|'/'
condition|)
block|{
operator|++
name|slash_count
expr_stmt|;
operator|--
name|slash
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|slash
operator|==
literal|'+'
operator|)
operator|&&
operator|(
name|slash_count
operator|>=
literal|2
operator|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

