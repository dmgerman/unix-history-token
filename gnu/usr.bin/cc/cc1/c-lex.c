begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Lexical analyzer for C and Objective C.    Copyright (C) 1987, 1988, 1989, 1992, 1994 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"input.h"
end_include

begin_include
include|#
directive|include
file|"c-lex.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"c-parse.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|errno
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The elements of `ridpointers' are identifier nodes    for the reserved type names and storage classes.    It is indexed by a RID_... value.  */
end_comment

begin_decl_stmt
name|tree
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cause the `yydebug' variable to be defined.  */
end_comment

begin_define
define|#
directive|define
name|YYDEBUG
value|1
end_define

begin_comment
comment|/* the declaration found for the last IDENTIFIER token read in.    yylex must look this up to detect typedefs, which get token type TYPENAME,    so it is left around in case the identifier is not a typedef but is    used in a context which makes it a reference to a variable.  */
end_comment

begin_decl_stmt
name|tree
name|lastiddecl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero enables objc features.  */
end_comment

begin_decl_stmt
name|int
name|doing_objc_thang
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|tree
name|is_class_name
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|yydebug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File used for outputting assembler code.  */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_TYPE_SIZE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|INT_TYPE_SIZE
end_ifdef

begin_define
define|#
directive|define
name|WCHAR_TYPE_SIZE
value|INT_TYPE_SIZE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|WCHAR_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of bytes in a wide character.  */
end_comment

begin_define
define|#
directive|define
name|WCHAR_BYTES
value|(WCHAR_TYPE_SIZE / BITS_PER_UNIT)
end_define

begin_decl_stmt
specifier|static
name|int
name|maxtoken
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current nominal length of token buffer.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|token_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to token buffer. 			   Actual allocated length is maxtoken + 2. 			   This is not static because objc-parse.y uses it.  */
end_comment

begin_comment
comment|/* Nonzero if end-of-file has been seen on input.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|end_of_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffered-back input character; faster than using ungetc.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nextchar
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|check_newline
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Do not insert generated code into the source, instead, include it.    This allows us to build gcc automatically even for targets that    need to add or modify the reserved keyword lists.  */
end_comment

begin_include
include|#
directive|include
file|"c-gperf.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Return something to represent absolute declarators containing a *.    TARGET is the absolute declarator that the * contains.    TYPE_QUALS is a list of modifiers such as const or volatile    to apply to the pointer type, represented as identifiers.     We return an INDIRECT_REF whose "contents" are TARGET    and whose type is the modifier list.  */
end_comment

begin_function
name|tree
name|make_pointer_declarator
parameter_list|(
name|type_quals
parameter_list|,
name|target
parameter_list|)
name|tree
name|type_quals
decl_stmt|,
name|target
decl_stmt|;
block|{
return|return
name|build1
argument_list|(
name|INDIRECT_REF
argument_list|,
name|type_quals
argument_list|,
name|target
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|forget_protocol_qualifiers
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|n
init|=
sizeof|sizeof
name|wordlist
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|resword
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|int
operator|)
name|wordlist
index|[
name|i
index|]
operator|.
name|rid
operator|>=
operator|(
name|int
operator|)
name|RID_IN
operator|&&
operator|(
name|int
operator|)
name|wordlist
index|[
name|i
index|]
operator|.
name|rid
operator|<=
operator|(
name|int
operator|)
name|RID_ONEWAY
condition|)
name|wordlist
index|[
name|i
index|]
operator|.
name|name
operator|=
literal|""
expr_stmt|;
block|}
end_function

begin_function
name|void
name|remember_protocol_qualifiers
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|n
init|=
sizeof|sizeof
name|wordlist
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|resword
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|wordlist
index|[
name|i
index|]
operator|.
name|rid
operator|==
name|RID_IN
condition|)
name|wordlist
index|[
name|i
index|]
operator|.
name|name
operator|=
literal|"in"
expr_stmt|;
elseif|else
if|if
condition|(
name|wordlist
index|[
name|i
index|]
operator|.
name|rid
operator|==
name|RID_OUT
condition|)
name|wordlist
index|[
name|i
index|]
operator|.
name|name
operator|=
literal|"out"
expr_stmt|;
elseif|else
if|if
condition|(
name|wordlist
index|[
name|i
index|]
operator|.
name|rid
operator|==
name|RID_INOUT
condition|)
name|wordlist
index|[
name|i
index|]
operator|.
name|name
operator|=
literal|"inout"
expr_stmt|;
elseif|else
if|if
condition|(
name|wordlist
index|[
name|i
index|]
operator|.
name|rid
operator|==
name|RID_BYCOPY
condition|)
name|wordlist
index|[
name|i
index|]
operator|.
name|name
operator|=
literal|"bycopy"
expr_stmt|;
elseif|else
if|if
condition|(
name|wordlist
index|[
name|i
index|]
operator|.
name|rid
operator|==
name|RID_ONEWAY
condition|)
name|wordlist
index|[
name|i
index|]
operator|.
name|name
operator|=
literal|"oneway"
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|init_lex
parameter_list|()
block|{
comment|/* Make identifier nodes long enough for the language-specific slots.  */
name|set_identifier_size
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_identifier
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start it at 0, because check_newline is called at the very beginning      and will increment it to 1.  */
name|lineno
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
comment|/* Change to the native locale for multibyte conversions.  */
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|maxtoken
operator|=
literal|40
expr_stmt|;
name|token_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|maxtoken
operator|+
literal|2
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
operator|=
name|get_identifier
argument_list|(
literal|"int"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"char"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOID
index|]
operator|=
name|get_identifier
argument_list|(
literal|"void"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FLOAT
index|]
operator|=
name|get_identifier
argument_list|(
literal|"float"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_DOUBLE
index|]
operator|=
name|get_identifier
argument_list|(
literal|"double"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SHORT
index|]
operator|=
name|get_identifier
argument_list|(
literal|"short"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_LONG
index|]
operator|=
name|get_identifier
argument_list|(
literal|"long"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_UNSIGNED
index|]
operator|=
name|get_identifier
argument_list|(
literal|"unsigned"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_SIGNED
index|]
operator|=
name|get_identifier
argument_list|(
literal|"signed"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INLINE
index|]
operator|=
name|get_identifier
argument_list|(
literal|"inline"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
operator|=
name|get_identifier
argument_list|(
literal|"const"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
operator|=
name|get_identifier
argument_list|(
literal|"volatile"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_AUTO
index|]
operator|=
name|get_identifier
argument_list|(
literal|"auto"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_STATIC
index|]
operator|=
name|get_identifier
argument_list|(
literal|"static"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_EXTERN
index|]
operator|=
name|get_identifier
argument_list|(
literal|"extern"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_TYPEDEF
index|]
operator|=
name|get_identifier
argument_list|(
literal|"typedef"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_REGISTER
index|]
operator|=
name|get_identifier
argument_list|(
literal|"register"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_ITERATOR
index|]
operator|=
name|get_identifier
argument_list|(
literal|"iterator"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_COMPLEX
index|]
operator|=
name|get_identifier
argument_list|(
literal|"complex"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_ID
index|]
operator|=
name|get_identifier
argument_list|(
literal|"id"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_IN
index|]
operator|=
name|get_identifier
argument_list|(
literal|"in"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_OUT
index|]
operator|=
name|get_identifier
argument_list|(
literal|"out"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INOUT
index|]
operator|=
name|get_identifier
argument_list|(
literal|"inout"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_BYCOPY
index|]
operator|=
name|get_identifier
argument_list|(
literal|"bycopy"
argument_list|)
expr_stmt|;
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_ONEWAY
index|]
operator|=
name|get_identifier
argument_list|(
literal|"oneway"
argument_list|)
expr_stmt|;
name|forget_protocol_qualifiers
argument_list|()
expr_stmt|;
comment|/* Some options inhibit certain reserved words.      Clear those words out of the hash table so they won't be recognized.  */
define|#
directive|define
name|UNSET_RESERVED_WORD
parameter_list|(
name|STRING
parameter_list|)
define|\
value|do { struct resword *s = is_reserved_word (STRING, sizeof (STRING) - 1); \        if (s) s->name = ""; } while (0)
if|if
condition|(
operator|!
name|doing_objc_thang
condition|)
name|UNSET_RESERVED_WORD
argument_list|(
literal|"id"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_traditional
condition|)
block|{
name|UNSET_RESERVED_WORD
argument_list|(
literal|"const"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"volatile"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"typeof"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"signed"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"inline"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"iterator"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"complex"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_no_asm
condition|)
block|{
name|UNSET_RESERVED_WORD
argument_list|(
literal|"asm"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"typeof"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"inline"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"iterator"
argument_list|)
expr_stmt|;
name|UNSET_RESERVED_WORD
argument_list|(
literal|"complex"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|reinit_parse_for_function
parameter_list|()
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* Function used when yydebug is set, to print a token in more detail.  */
end_comment

begin_function
name|void
name|yyprint
parameter_list|(
name|file
parameter_list|,
name|yychar
parameter_list|,
name|yylval
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|int
name|yychar
decl_stmt|;
name|YYSTYPE
name|yylval
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
switch|switch
condition|(
name|yychar
condition|)
block|{
case|case
name|IDENTIFIER
case|:
case|case
name|TYPENAME
case|:
case|case
name|OBJECTNAME
case|:
name|t
operator|=
name|yylval
operator|.
name|ttype
expr_stmt|;
if|if
condition|(
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONSTANT
case|:
name|t
operator|=
name|yylval
operator|.
name|ttype
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|==
literal|64
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|!=
name|HOST_BITS_PER_INT
literal|" 0x%lx%016lx"
argument_list|,
else|#
directive|else
literal|" 0x%x%016x"
argument_list|,
endif|#
directive|endif
else|#
directive|else
if|#
directive|if
name|HOST_BITS_PER_WIDE_INT
operator|!=
name|HOST_BITS_PER_INT
literal|" 0x%lx%08lx"
argument_list|,
else|#
directive|else
literal|" 0x%x%08x"
argument_list|,
endif|#
directive|endif
endif|#
directive|endif
name|TREE_INT_CST_HIGH
argument_list|(
name|t
argument_list|)
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If C is not whitespace, return C.    Otherwise skip whitespace and return first nonwhite char read.  */
end_comment

begin_function
specifier|static
name|int
name|skip_white_space
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
specifier|static
name|int
name|newline_warning
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
comment|/* We don't recognize comments here, because 	     cpp output can include / and * consecutively as operators. 	     Also, there's no need, since cpp removes all comments.  */
case|case
literal|'\n'
case|:
name|c
operator|=
name|check_newline
argument_list|()
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\v'
case|:
case|case
literal|'\b'
case|:
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
comment|/* ANSI C says the effects of a carriage return in a source file 	     are undefined.  */
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|newline_warning
condition|)
block|{
name|warning
argument_list|(
literal|"carriage return in source file"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"(we only warn about the first carriage return)"
argument_list|)
expr_stmt|;
name|newline_warning
operator|=
literal|1
expr_stmt|;
block|}
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
else|else
name|error
argument_list|(
literal|"stray '\\' in program"
argument_list|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|c
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Skips all of the white space at the current location in the input file.    Must use and reset nextchar if it has the next character.  */
end_comment

begin_function
name|void
name|position_after_white_space
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|nextchar
operator|!=
operator|-
literal|1
condition|)
name|c
operator|=
name|nextchar
operator|,
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|skip_white_space
argument_list|(
name|c
argument_list|)
argument_list|,
name|finput
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make the token buffer longer, preserving the data in it.    P should point to just beyond the last valid character in the old buffer.    The value we return is a pointer to the new buffer    at a place corresponding to P.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|extend_token_buffer
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|offset
init|=
name|p
operator|-
name|token_buffer
decl_stmt|;
name|maxtoken
operator|=
name|maxtoken
operator|*
literal|2
operator|+
literal|10
expr_stmt|;
name|token_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|token_buffer
argument_list|,
name|maxtoken
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
name|token_buffer
operator|+
name|offset
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* At the beginning of a line, increment the line number    and process any #-directive on this line.    If the line is a #-directive, read the entire line and return a newline.    Otherwise, return the line's first non-whitespace character.  */
end_comment

begin_function
name|int
name|check_newline
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|token
decl_stmt|;
name|lineno
operator|++
expr_stmt|;
comment|/* Read first nonwhite char on the line.  */
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'#'
condition|)
block|{
comment|/* If not #, return it so caller will use it.  */
return|return
name|c
return|;
block|}
comment|/* Read first nonwhite char after the `#'.  */
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
comment|/* If a letter follows, then if the word here is `line', skip      it and ignore it; otherwise, ignore the line, with an error      if the word isn't `pragma', `ident', `define', or `undef'.  */
if|if
condition|(
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'p'
condition|)
block|{
if|if
condition|(
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'r'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'a'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'g'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'m'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'a'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HANDLE_SYSV_PRAGMA
return|return
name|handle_sysv_pragma
argument_list|(
name|finput
argument_list|,
name|c
argument_list|)
return|;
else|#
directive|else
comment|/* !HANDLE_SYSV_PRAGMA */
ifdef|#
directive|ifdef
name|HANDLE_PRAGMA
name|HANDLE_PRAGMA
argument_list|(
name|finput
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HANDLE_PRAGMA */
goto|goto
name|skipline
goto|;
endif|#
directive|endif
comment|/* !HANDLE_SYSV_PRAGMA */
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'d'
condition|)
block|{
if|if
condition|(
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'e'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'f'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'i'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'n'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'e'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
operator|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|)
operator|&&
operator|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|)
condition|)
name|dwarfout_define
argument_list|(
name|lineno
argument_list|,
name|get_directive_line
argument_list|(
name|finput
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DWARF_DEBUGGING_INFO */
goto|goto
name|skipline
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'u'
condition|)
block|{
if|if
condition|(
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'n'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'d'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'e'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'f'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
operator|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|)
operator|&&
operator|(
name|write_symbols
operator|==
name|DWARF_DEBUG
operator|)
condition|)
name|dwarfout_undef
argument_list|(
name|lineno
argument_list|,
name|get_directive_line
argument_list|(
name|finput
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DWARF_DEBUGGING_INFO */
goto|goto
name|skipline
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'l'
condition|)
block|{
if|if
condition|(
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'i'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'n'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'e'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
goto|goto
name|linenum
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'i'
condition|)
block|{
if|if
condition|(
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'d'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'e'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'n'
operator|&&
name|getc
argument_list|(
name|finput
argument_list|)
operator|==
literal|'t'
operator|&&
operator|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
block|{
comment|/* #ident.  The pedantic warning is now in cccp.c.  */
comment|/* Here we have just seen `#ident '. 		 A string constant should follow.  */
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
comment|/* If no argument, ignore the line.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
name|c
return|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|token
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
operator|||
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"invalid #ident"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
if|if
condition|(
operator|!
name|flag_no_ident
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_IDENT
name|ASM_OUTPUT_IDENT
argument_list|(
name|asm_out_file
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Skip the rest of this line.  */
goto|goto
name|skipline
goto|;
block|}
block|}
name|error
argument_list|(
literal|"undefined or invalid # directive"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
name|linenum
label|:
comment|/* Here we have either `#line' or `#<nonletter>'.      In either case, it should be a line number; a digit should follow.  */
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
comment|/* If the # is the only nonwhite char on the line,      just ignore it.  Check the new newline.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
name|c
return|;
comment|/* Something follows the #; read a token.  */
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|token
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|==
name|CONSTANT
operator|&&
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|int
name|old_lineno
init|=
name|lineno
decl_stmt|;
name|int
name|used_up
init|=
literal|0
decl_stmt|;
comment|/* subtract one, because it is the following line that 	 gets the specified number */
name|int
name|l
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|-
literal|1
decl_stmt|;
comment|/* Is this the last nonwhite stuff on the line?  */
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* No more: store the line number and check following line.  */
name|lineno
operator|=
name|l
expr_stmt|;
return|return
name|c
return|;
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
comment|/* More follows: it must be a string constant (filename).  */
comment|/* Read the string constant.  */
name|token
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
name|STRING
operator|||
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|!=
name|STRING_CST
condition|)
block|{
name|error
argument_list|(
literal|"invalid #line"
argument_list|)
expr_stmt|;
goto|goto
name|skipline
goto|;
block|}
name|input_filename
operator|=
operator|(
name|char
operator|*
operator|)
name|permalloc
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|input_filename
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|l
expr_stmt|;
comment|/* Each change of file name 	 reinitializes whether we are now in a system header.  */
name|in_system_header
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|main_input_filename
operator|==
literal|0
condition|)
name|main_input_filename
operator|=
name|input_filename
expr_stmt|;
comment|/* Is this the last nonwhite stuff on the line?  */
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* Update the name in the top element of input_file_stack.  */
if|if
condition|(
name|input_file_stack
condition|)
name|input_file_stack
operator|->
name|name
operator|=
name|input_filename
expr_stmt|;
return|return
name|c
return|;
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|token
operator|=
name|yylex
argument_list|()
expr_stmt|;
name|used_up
operator|=
literal|0
expr_stmt|;
comment|/* `1' after file name means entering new file. 	 `2' after file name means just left a file.  */
if|if
condition|(
name|token
operator|==
name|CONSTANT
operator|&&
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* Pushing to a new file.  */
name|struct
name|file_stack
modifier|*
name|p
init|=
operator|(
expr|struct
name|file_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_stack
argument_list|)
argument_list|)
decl_stmt|;
name|input_file_stack
operator|->
name|line
operator|=
name|old_lineno
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|input_file_stack
expr_stmt|;
name|p
operator|->
name|name
operator|=
name|input_filename
expr_stmt|;
name|input_file_stack
operator|=
name|p
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|&&
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|dwarfout_start_new_source_file
argument_list|(
name|input_filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DWARF_DEBUGGING_INFO */
name|used_up
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_INT_CST_LOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
literal|2
condition|)
block|{
comment|/* Popping out of a file.  */
if|if
condition|(
name|input_file_stack
operator|->
name|next
condition|)
block|{
name|struct
name|file_stack
modifier|*
name|p
init|=
name|input_file_stack
decl_stmt|;
name|input_file_stack
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DWARF_DEBUGGING_INFO
if|if
condition|(
name|debug_info_level
operator|==
name|DINFO_LEVEL_VERBOSE
operator|&&
name|write_symbols
operator|==
name|DWARF_DEBUG
condition|)
name|dwarfout_resume_previous_source_file
argument_list|(
name|input_file_stack
operator|->
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DWARF_DEBUGGING_INFO */
block|}
else|else
name|error
argument_list|(
literal|"#-lines for entering and leaving files don't match"
argument_list|)
expr_stmt|;
name|used_up
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Now that we've pushed or popped the input stack, 	 update the name in the top element.  */
if|if
condition|(
name|input_file_stack
condition|)
name|input_file_stack
operator|->
name|name
operator|=
name|input_filename
expr_stmt|;
comment|/* If we have handled a `1' or a `2', 	 see if there is another number to read.  */
if|if
condition|(
name|used_up
condition|)
block|{
comment|/* Is this the last nonwhite stuff on the line?  */
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
name|c
return|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|token
operator|=
name|yylex
argument_list|()
expr_stmt|;
name|used_up
operator|=
literal|0
expr_stmt|;
block|}
comment|/* `3' after file name means this is a system header file.  */
if|if
condition|(
name|token
operator|==
name|CONSTANT
operator|&&
name|TREE_CODE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
name|INTEGER_CST
operator|&&
name|TREE_INT_CST_LOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|==
literal|3
condition|)
name|in_system_header
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"invalid #-line"
argument_list|)
expr_stmt|;
comment|/* skip the rest of this line.  */
name|skipline
label|:
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
name|c
return|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_SYSV_PRAGMA
end_ifdef

begin_comment
comment|/* Handle a #pragma directive.  INPUT is the current input stream,    and C is a character to reread.  Processes the entire input line    and returns a character for the caller to reread: either \n or EOF.  */
end_comment

begin_comment
comment|/* This function has to be in this file, in order to get at    the token types.  */
end_comment

begin_function
name|int
name|handle_sysv_pragma
parameter_list|(
name|input
parameter_list|,
name|c
parameter_list|)
name|FILE
modifier|*
name|input
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|c
operator|=
name|getc
argument_list|(
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
name|EOF
condition|)
block|{
name|handle_pragma_token
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|input
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yylex
argument_list|()
condition|)
block|{
case|case
name|IDENTIFIER
case|:
case|case
name|TYPENAME
case|:
case|case
name|STRING
case|:
case|case
name|CONSTANT
case|:
name|handle_pragma_token
argument_list|(
name|token_buffer
argument_list|,
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
break|break;
default|default:
name|handle_pragma_token
argument_list|(
name|token_buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nextchar
operator|>=
literal|0
condition|)
name|c
operator|=
name|nextchar
operator|,
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|c
operator|=
name|getc
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_SYSV_PRAGMA */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|ENDFILE
value|-1
end_define

begin_comment
comment|/* token that represents end-of-file */
end_comment

begin_comment
comment|/* Read an escape sequence, returning its equivalent as a character,    or store 1 in *ignore_ptr if it is backslash-newline.  */
end_comment

begin_function
specifier|static
name|int
name|readescape
parameter_list|(
name|ignore_ptr
parameter_list|)
name|int
modifier|*
name|ignore_ptr
decl_stmt|;
block|{
specifier|register
name|int
name|c
init|=
name|getc
argument_list|(
name|finput
argument_list|)
decl_stmt|;
specifier|register
name|int
name|code
decl_stmt|;
specifier|register
name|unsigned
name|count
decl_stmt|;
name|unsigned
name|firstdig
init|=
literal|0
decl_stmt|;
name|int
name|nonnull
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'x'
case|:
if|if
condition|(
name|warn_traditional
condition|)
name|warning
argument_list|(
literal|"the meaning of `\\x' varies with -traditional"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_traditional
condition|)
return|return
name|c
return|;
name|code
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|nonnull
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
operator|)
operator|&&
operator|!
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
operator|)
operator|&&
operator|!
operator|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
break|break;
block|}
name|code
operator|*=
literal|16
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
name|code
operator|+=
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
name|code
operator|+=
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|code
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|code
operator|!=
literal|0
operator|||
name|count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|firstdig
operator|=
name|code
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|nonnull
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nonnull
condition|)
name|error
argument_list|(
literal|"\\x used with no following hex digits"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|count
operator|==
literal|0
condition|)
comment|/* Digits are all 0's.  Ok.  */
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|4
operator|>=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|||
operator|(
name|count
operator|>
literal|1
operator|&&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|-
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|4
operator|)
operator|)
operator|<=
name|firstdig
operator|)
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"hex escape out of range"
argument_list|)
expr_stmt|;
return|return
name|code
return|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
name|code
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|<=
literal|'7'
operator|)
operator|&&
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|count
operator|++
operator|<
literal|3
operator|)
condition|)
block|{
name|code
operator|=
operator|(
name|code
operator|*
literal|8
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
return|return
name|code
return|;
case|case
literal|'\\'
case|:
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
return|return
name|c
return|;
case|case
literal|'\n'
case|:
name|lineno
operator|++
expr_stmt|;
operator|*
name|ignore_ptr
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'n'
case|:
return|return
name|TARGET_NEWLINE
return|;
case|case
literal|'t'
case|:
return|return
name|TARGET_TAB
return|;
case|case
literal|'r'
case|:
return|return
name|TARGET_CR
return|;
case|case
literal|'f'
case|:
return|return
name|TARGET_FF
return|;
case|case
literal|'b'
case|:
return|return
name|TARGET_BS
return|;
case|case
literal|'a'
case|:
if|if
condition|(
name|warn_traditional
condition|)
name|warning
argument_list|(
literal|"the meaning of `\\a' varies with -traditional"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_traditional
condition|)
return|return
name|c
return|;
return|return
name|TARGET_BELL
return|;
case|case
literal|'v'
case|:
if|#
directive|if
literal|0
comment|/* Vertical tab is present in common usage compilers.  */
block|if (flag_traditional) 	return c;
endif|#
directive|endif
return|return
name|TARGET_VT
return|;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"non-ANSI-standard escape sequence, `\\%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
literal|033
return|;
case|case
literal|'?'
case|:
return|return
name|c
return|;
comment|/* `\(', etc, are used at beginning of line to avoid confusing Emacs.  */
case|case
literal|'('
case|:
case|case
literal|'{'
case|:
case|case
literal|'['
case|:
comment|/* `\%' is used to prevent SCCS from getting confused.  */
case|case
literal|'%'
case|:
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"non-ANSI escape sequence `\\%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
if|if
condition|(
name|c
operator|>=
literal|040
operator|&&
name|c
operator|<
literal|0177
condition|)
name|pedwarn
argument_list|(
literal|"unknown escape sequence `\\%c'"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"unknown escape sequence: `\\' followed by char code 0x%x"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|yyerror
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|string
argument_list|)
expr_stmt|;
comment|/* We can't print string and character constants well      because the token_buffer contains the result of processing escapes.  */
if|if
condition|(
name|end_of_file
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" at end of input"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token_buffer
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" at null character"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token_buffer
index|[
literal|0
index|]
operator|==
literal|'"'
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" before string constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token_buffer
index|[
literal|0
index|]
operator|==
literal|'\''
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" before character constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token_buffer
index|[
literal|0
index|]
operator|<
literal|040
operator|||
operator|(
name|unsigned
name|char
operator|)
name|token_buffer
index|[
literal|0
index|]
operator|>=
literal|0177
condition|)
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|" before character 0%o"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|token_buffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|buf
argument_list|,
literal|" before `%s'"
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|buf
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct try_type {   tree *node_var;   char unsigned_flag;   char long_flag;   char long_long_flag; };  struct try_type type_sequence[] = {   {&integer_type_node, 0, 0, 0},   {&unsigned_type_node, 1, 0, 0},   {&long_integer_type_node, 0, 1, 0},   {&long_unsigned_type_node, 1, 1, 0},   {&long_long_integer_type_node, 0, 1, 1},   {&long_long_unsigned_type_node, 1, 1, 1} };
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_function
name|int
name|yylex
parameter_list|()
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|value
decl_stmt|;
name|int
name|wide_flag
init|=
literal|0
decl_stmt|;
name|int
name|objc_flag
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nextchar
operator|>=
literal|0
condition|)
name|c
operator|=
name|nextchar
operator|,
name|nextchar
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
comment|/* Effectively do c = skip_white_space (c)      but do it faster in the usual cases.  */
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\f'
case|:
case|case
literal|'\v'
case|:
case|case
literal|'\b'
case|:
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
comment|/* Call skip_white_space so we can warn if appropriate.  */
case|case
literal|'\n'
case|:
case|case
literal|'/'
case|:
case|case
literal|'\\'
case|:
name|c
operator|=
name|skip_white_space
argument_list|(
name|c
argument_list|)
expr_stmt|;
default|default:
goto|goto
name|found_nonwhite
goto|;
block|}
name|found_nonwhite
label|:
name|token_buffer
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/*  yylloc.first_line = lineno; */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
name|end_of_file
operator|=
literal|1
expr_stmt|;
name|token_buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|ENDFILE
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
if|if
condition|(
name|dollars_in_ident
condition|)
goto|goto
name|letter
goto|;
return|return
literal|'$'
return|;
case|case
literal|'L'
case|:
comment|/* Capital L may start a wide-string or wide-character constant.  */
block|{
specifier|register
name|int
name|c
init|=
name|getc
argument_list|(
name|finput
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
block|{
name|wide_flag
operator|=
literal|1
expr_stmt|;
goto|goto
name|char_constant
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|wide_flag
operator|=
literal|1
expr_stmt|;
goto|goto
name|string_constant
goto|;
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
block|}
goto|goto
name|letter
goto|;
case|case
literal|'@'
case|:
if|if
condition|(
operator|!
name|doing_objc_thang
condition|)
block|{
name|value
operator|=
name|c
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* '@' may start a constant string object.  */
specifier|register
name|int
name|c
init|=
name|getc
argument_list|(
name|finput
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|objc_flag
operator|=
literal|1
expr_stmt|;
goto|goto
name|string_constant
goto|;
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
comment|/* Fall through to treat '@' as the start of an indentifier.  */
block|}
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'_'
case|:
name|letter
label|:
name|p
operator|=
name|token_buffer
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'_'
operator|||
name|c
operator|==
literal|'$'
operator|||
name|c
operator|==
literal|'@'
condition|)
block|{
comment|/* Make sure this char really belongs in an identifier.  */
if|if
condition|(
name|c
operator|==
literal|'@'
operator|&&
operator|!
name|doing_objc_thang
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'$'
operator|&&
operator|!
name|dollars_in_ident
condition|)
break|break;
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|nextchar
operator|=
name|c
expr_stmt|;
name|value
operator|=
name|IDENTIFIER
expr_stmt|;
name|yylval
operator|.
name|itype
operator|=
literal|0
expr_stmt|;
comment|/* Try to recognize a keyword.  Uses minimum-perfect hash function */
block|{
specifier|register
name|struct
name|resword
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|ptr
operator|=
name|is_reserved_word
argument_list|(
name|token_buffer
argument_list|,
name|p
operator|-
name|token_buffer
argument_list|)
condition|)
block|{
if|if
condition|(
name|ptr
operator|->
name|rid
condition|)
name|yylval
operator|.
name|ttype
operator|=
name|ridpointers
index|[
operator|(
name|int
operator|)
name|ptr
operator|->
name|rid
index|]
expr_stmt|;
name|value
operator|=
operator|(
name|int
operator|)
name|ptr
operator|->
name|token
expr_stmt|;
comment|/* Only return OBJECTNAME if it is a typedef.  */
if|if
condition|(
name|doing_objc_thang
operator|&&
name|value
operator|==
name|OBJECTNAME
condition|)
block|{
name|lastiddecl
operator|=
name|lookup_name
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastiddecl
operator|==
name|NULL_TREE
operator|||
name|TREE_CODE
argument_list|(
name|lastiddecl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
name|value
operator|=
name|IDENTIFIER
expr_stmt|;
block|}
comment|/* Even if we decided to recognize asm, still perhaps warn.  */
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|value
operator|==
name|ASM_KEYWORD
operator|||
name|value
operator|==
name|TYPEOF
operator|||
name|ptr
operator|->
name|rid
operator|==
name|RID_INLINE
operator|)
operator|&&
name|token_buffer
index|[
literal|0
index|]
operator|!=
literal|'_'
condition|)
name|pedwarn
argument_list|(
literal|"ANSI does not permit the keyword `%s'"
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we did not find a keyword, look for an identifier 	 (or a typename).  */
if|if
condition|(
name|value
operator|==
name|IDENTIFIER
condition|)
block|{
if|if
condition|(
name|token_buffer
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
name|error
argument_list|(
literal|"invalid identifier `%s'"
argument_list|,
name|token_buffer
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|get_identifier
argument_list|(
name|token_buffer
argument_list|)
expr_stmt|;
name|lastiddecl
operator|=
name|lookup_name
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastiddecl
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|lastiddecl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
name|value
operator|=
name|TYPENAME
expr_stmt|;
comment|/* A user-invisible read-only initialized variable 	     should be replaced by its value. 	     We handle only strings since that's the only case used in C.  */
elseif|else
if|if
condition|(
name|lastiddecl
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|lastiddecl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|DECL_IGNORED_P
argument_list|(
name|lastiddecl
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|lastiddecl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|lastiddecl
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|lastiddecl
argument_list|)
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|tree
name|stringval
init|=
name|DECL_INITIAL
argument_list|(
name|lastiddecl
argument_list|)
decl_stmt|;
comment|/* Copy the string value so that we won't clobber anything 		 if we put something in the TREE_CHAIN of this one.  */
name|yylval
operator|.
name|ttype
operator|=
name|build_string
argument_list|(
name|TREE_STRING_LENGTH
argument_list|(
name|stringval
argument_list|)
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|stringval
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|STRING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|doing_objc_thang
condition|)
block|{
name|tree
name|objc_interface_decl
init|=
name|is_class_name
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
decl_stmt|;
if|if
condition|(
name|objc_interface_decl
condition|)
block|{
name|value
operator|=
name|CLASSNAME
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|objc_interface_decl
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'.'
case|:
block|{
name|int
name|base
init|=
literal|10
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|largest_digit
init|=
literal|0
decl_stmt|;
name|int
name|numdigits
init|=
literal|0
decl_stmt|;
comment|/* for multi-precision arithmetic, 	   we actually store only HOST_BITS_PER_CHAR bits in each part. 	   The number of parts is chosen so as to be sufficient to hold 	   the enough bits to fit into the two HOST_WIDE_INTs that contain 	   the integer value (this is always at least as many bits as are 	   in a target `long long' value, but may be wider).  */
define|#
directive|define
name|TOTAL_PARTS
value|((HOST_BITS_PER_WIDE_INT / HOST_BITS_PER_CHAR) * 2 + 2)
name|int
name|parts
index|[
name|TOTAL_PARTS
index|]
decl_stmt|;
name|int
name|overflow
init|=
literal|0
decl_stmt|;
enum|enum
name|anon1
block|{
name|NOT_FLOAT
block|,
name|AFTER_POINT
block|,
name|TOO_MANY_POINTS
block|}
name|floatflag
init|=
name|NOT_FLOAT
enum|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|TOTAL_PARTS
condition|;
name|count
operator|++
control|)
name|parts
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|token_buffer
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'0'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'x'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'X'
operator|)
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* Leading 0 forces octal unless the 0 is the only digit.  */
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|base
operator|=
literal|8
expr_stmt|;
name|numdigits
operator|++
expr_stmt|;
block|}
else|else
name|numdigits
operator|++
expr_stmt|;
block|}
comment|/* Read all the digits-and-decimal-points.  */
while|while
condition|(
name|c
operator|==
literal|'.'
operator|||
operator|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'l'
operator|&&
name|c
operator|!=
literal|'L'
operator|&&
name|c
operator|!=
literal|'u'
operator|&&
name|c
operator|!=
literal|'U'
operator|&&
name|c
operator|!=
literal|'i'
operator|&&
name|c
operator|!=
literal|'I'
operator|&&
name|c
operator|!=
literal|'j'
operator|&&
name|c
operator|!=
literal|'J'
operator|&&
operator|(
name|floatflag
operator|==
name|NOT_FLOAT
operator|||
operator|(
operator|(
name|c
operator|!=
literal|'f'
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'F'
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|base
operator|==
literal|16
condition|)
name|error
argument_list|(
literal|"floating constant may not be in radix 16"
argument_list|)
expr_stmt|;
if|if
condition|(
name|floatflag
operator|==
name|TOO_MANY_POINTS
condition|)
comment|/* We have already emitted an error.  Don't need another.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|floatflag
operator|==
name|AFTER_POINT
condition|)
block|{
name|error
argument_list|(
literal|"malformed floating constant"
argument_list|)
expr_stmt|;
name|floatflag
operator|=
name|TOO_MANY_POINTS
expr_stmt|;
comment|/* Avoid another error from atof by forcing all characters 		       from here on to be ignored.  */
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|floatflag
operator|=
name|AFTER_POINT
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
comment|/* Accept '.' as the start of a floating-point number 		   only when it is followed by a digit. 		   Otherwise, unread the following non-digit 		   and use the '.' as a structural token.  */
if|if
condition|(
name|p
operator|==
name|token_buffer
operator|+
literal|2
operator|&&
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
name|ELLIPSIS
return|;
block|}
name|error
argument_list|(
literal|"parse error at `..'"
argument_list|)
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|value
operator|=
literal|'.'
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
comment|/* It is not a decimal point. 		   It should be a digit (perhaps a hex digit).  */
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base
operator|<=
literal|10
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
condition|)
block|{
name|base
operator|=
literal|10
expr_stmt|;
name|floatflag
operator|=
name|AFTER_POINT
expr_stmt|;
break|break;
comment|/* start of exponent */
block|}
name|error
argument_list|(
literal|"nondigits in number and not hexadecimal"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
condition|)
block|{
name|c
operator|=
name|c
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|c
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>=
name|largest_digit
condition|)
name|largest_digit
operator|=
name|c
expr_stmt|;
name|numdigits
operator|++
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|TOTAL_PARTS
condition|;
name|count
operator|++
control|)
block|{
name|parts
index|[
name|count
index|]
operator|*=
name|base
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
name|parts
index|[
name|count
index|]
operator|+=
operator|(
name|parts
index|[
name|count
operator|-
literal|1
index|]
operator|>>
name|HOST_BITS_PER_CHAR
operator|)
expr_stmt|;
name|parts
index|[
name|count
operator|-
literal|1
index|]
operator|&=
operator|(
literal|1
operator|<<
name|HOST_BITS_PER_CHAR
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|parts
index|[
literal|0
index|]
operator|+=
name|c
expr_stmt|;
block|}
comment|/* If the extra highest-order part ever gets anything in it, 		   the number is certainly too big.  */
if|if
condition|(
name|parts
index|[
name|TOTAL_PARTS
operator|-
literal|1
index|]
operator|!=
literal|0
condition|)
name|overflow
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|numdigits
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"numeric constant with no digits"
argument_list|)
expr_stmt|;
if|if
condition|(
name|largest_digit
operator|>=
name|base
condition|)
name|error
argument_list|(
literal|"numeric constant contains digits beyond the radix"
argument_list|)
expr_stmt|;
comment|/* Remove terminating char from the token buffer and delimit the string */
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|floatflag
operator|!=
name|NOT_FLOAT
condition|)
block|{
name|tree
name|type
init|=
name|double_type_node
decl_stmt|;
name|int
name|garbage_chars
init|=
literal|0
decl_stmt|,
name|exceeds_double
init|=
literal|0
decl_stmt|;
name|int
name|imag
init|=
literal|0
decl_stmt|;
name|REAL_VALUE_TYPE
name|value
decl_stmt|;
name|jmp_buf
name|handler
decl_stmt|;
comment|/* Read explicit exponent if any, and put it in tokenbuf.  */
if|if
condition|(
operator|(
name|c
operator|==
literal|'e'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'E'
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'+'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'-'
operator|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|error
argument_list|(
literal|"floating constant exponent has no digits"
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* Convert string to a double, checking for overflow.  */
if|if
condition|(
name|setjmp
argument_list|(
name|handler
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"floating constant out of range"
argument_list|)
expr_stmt|;
name|value
operator|=
name|dconst0
expr_stmt|;
block|}
else|else
block|{
name|int
name|fflag
init|=
literal|0
decl_stmt|,
name|lflag
init|=
literal|0
decl_stmt|;
comment|/* Copy token_buffer now, while it has just the number 		   and not the suffixes; once we add `f' or `i', 		   REAL_VALUE_ATOF may not work any more.  */
name|char
modifier|*
name|copy
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
name|token_buffer
operator|+
literal|1
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|token_buffer
argument_list|,
name|copy
argument_list|,
name|p
operator|-
name|token_buffer
operator|+
literal|1
argument_list|)
expr_stmt|;
name|set_float_handler
argument_list|(
name|handler
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|lose
init|=
literal|0
decl_stmt|;
comment|/* Read the suffixes to choose a data type.  */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
if|if
condition|(
name|fflag
condition|)
name|error
argument_list|(
literal|"more than one `f' in numeric constant"
argument_list|)
expr_stmt|;
name|fflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
if|if
condition|(
name|lflag
condition|)
name|error
argument_list|(
literal|"more than one `l' in numeric constant"
argument_list|)
expr_stmt|;
name|lflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'I'
case|:
if|if
condition|(
name|imag
condition|)
name|error
argument_list|(
literal|"more than one `i' or `j' in numeric constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids imaginary numeric constants"
argument_list|)
expr_stmt|;
name|imag
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|lose
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|lose
condition|)
break|break;
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
comment|/* The second argument, machine_mode, of REAL_VALUE_ATOF 		   tells the desired precision of the binary result 		   of decimal-to-binary conversion.  */
if|if
condition|(
name|fflag
condition|)
block|{
if|if
condition|(
name|lflag
condition|)
name|error
argument_list|(
literal|"both `f' and `l' in floating constant"
argument_list|)
expr_stmt|;
name|type
operator|=
name|float_type_node
expr_stmt|;
name|value
operator|=
name|REAL_VALUE_ATOF
argument_list|(
name|copy
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
operator|&&
name|REAL_VALUE_ISINF
argument_list|(
name|value
argument_list|)
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"floating point number exceeds range of `float'"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lflag
condition|)
block|{
name|type
operator|=
name|long_double_type_node
expr_stmt|;
name|value
operator|=
name|REAL_VALUE_ATOF
argument_list|(
name|copy
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
operator|&&
name|REAL_VALUE_ISINF
argument_list|(
name|value
argument_list|)
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"floating point number exceeds range of `long double'"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|REAL_VALUE_ATOF
argument_list|(
name|copy
argument_list|,
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
operator|&&
name|REAL_VALUE_ISINF
argument_list|(
name|value
argument_list|)
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"floating point number exceeds range of `double'"
argument_list|)
expr_stmt|;
block|}
name|set_float_handler
argument_list|(
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ERANGE
if|if
condition|(
name|errno
operator|==
name|ERANGE
operator|&&
operator|!
name|flag_traditional
operator|&&
name|pedantic
condition|)
block|{
comment|/* ERANGE is also reported for underflow,   		   so test the value to distinguish overflow from that.  */
if|if
condition|(
name|TARGET_FLOAT_FORMAT
operator|!=
name|IEEE_FLOAT_FORMAT
operator|&&
operator|(
name|REAL_VALUES_LESS
argument_list|(
name|dconst1
argument_list|,
name|value
argument_list|)
operator|||
name|REAL_VALUES_LESS
argument_list|(
name|value
argument_list|,
name|dconstm1
argument_list|)
operator|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"floating point number exceeds range of `double'"
argument_list|)
expr_stmt|;
name|exceeds_double
operator|=
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|garbage_chars
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'_'
operator|||
operator|(
operator|!
name|flag_traditional
operator|&&
operator|(
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'e'
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'E'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
name|garbage_chars
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|garbage_chars
operator|>
literal|0
condition|)
name|error
argument_list|(
literal|"garbage at end of number"
argument_list|)
expr_stmt|;
comment|/* If the result is not a number, assume it must have been 	       due to some error message above, so silently convert 	       it to a zero.  */
if|if
condition|(
name|REAL_VALUE_ISNAN
argument_list|(
name|value
argument_list|)
condition|)
name|value
operator|=
name|dconst0
expr_stmt|;
comment|/* Create a node with determined type and value.  */
if|if
condition|(
name|imag
condition|)
name|yylval
operator|.
name|ttype
operator|=
name|build_complex
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|integer_zero_node
argument_list|)
argument_list|,
name|build_real
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|yylval
operator|.
name|ttype
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tree
name|traditional_type
decl_stmt|,
name|ansi_type
decl_stmt|,
name|type
decl_stmt|;
name|HOST_WIDE_INT
name|high
decl_stmt|,
name|low
decl_stmt|;
name|int
name|spec_unsigned
init|=
literal|0
decl_stmt|;
name|int
name|spec_long
init|=
literal|0
decl_stmt|;
name|int
name|spec_long_long
init|=
literal|0
decl_stmt|;
name|int
name|spec_imag
init|=
literal|0
decl_stmt|;
name|int
name|bytes
decl_stmt|,
name|warn
decl_stmt|,
name|i
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'u'
operator|||
name|c
operator|==
literal|'U'
condition|)
block|{
if|if
condition|(
name|spec_unsigned
condition|)
name|error
argument_list|(
literal|"two `u's in integer constant"
argument_list|)
expr_stmt|;
name|spec_unsigned
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'l'
operator|||
name|c
operator|==
literal|'L'
condition|)
block|{
if|if
condition|(
name|spec_long
condition|)
block|{
if|if
condition|(
name|spec_long_long
condition|)
name|error
argument_list|(
literal|"three `l's in integer constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids long long integer constants"
argument_list|)
expr_stmt|;
name|spec_long_long
operator|=
literal|1
expr_stmt|;
block|}
name|spec_long
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'i'
operator|||
name|c
operator|==
literal|'j'
operator|||
name|c
operator|==
literal|'I'
operator|||
name|c
operator|==
literal|'J'
condition|)
block|{
if|if
condition|(
name|spec_imag
condition|)
name|error
argument_list|(
literal|"more than one `i' or `j' in numeric constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids imaginary numeric constants"
argument_list|)
expr_stmt|;
name|spec_imag
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'_'
operator|||
operator|(
operator|!
name|flag_traditional
operator|&&
operator|(
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'e'
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'E'
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"garbage at end of number"
argument_list|)
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'.'
operator|||
name|c
operator|==
literal|'_'
operator|||
operator|(
operator|!
name|flag_traditional
operator|&&
operator|(
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'e'
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'E'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|p
operator|>=
name|token_buffer
operator|+
name|maxtoken
operator|-
literal|3
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
name|ungetc
argument_list|(
name|c
argument_list|,
name|finput
argument_list|)
expr_stmt|;
comment|/* If the constant is not long long and it won't fit in an 	       unsigned long, or if the constant is long long and won't fit 	       in an unsigned long long, then warn that the constant is out 	       of range.  */
comment|/* ??? This assumes that long long and long integer types are 	       a multiple of 8 bits.  This better than the original code 	       though which assumed that long was exactly 32 bits and long 	       long was exactly 64 bits.  */
if|if
condition|(
name|spec_long_long
condition|)
name|bytes
operator|=
name|TYPE_PRECISION
argument_list|(
name|long_long_integer_type_node
argument_list|)
operator|/
literal|8
expr_stmt|;
else|else
name|bytes
operator|=
name|TYPE_PRECISION
argument_list|(
name|long_integer_type_node
argument_list|)
operator|/
literal|8
expr_stmt|;
name|warn
operator|=
name|overflow
expr_stmt|;
for|for
control|(
name|i
operator|=
name|bytes
init|;
name|i
operator|<
name|TOTAL_PARTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|parts
index|[
name|i
index|]
condition|)
name|warn
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|warn
condition|)
name|pedwarn
argument_list|(
literal|"integer constant out of range"
argument_list|)
expr_stmt|;
comment|/* This is simplified by the fact that our constant 	       is always positive.  */
name|high
operator|=
name|low
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|/
name|HOST_BITS_PER_CHAR
condition|;
name|i
operator|++
control|)
block|{
name|high
operator||=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|parts
index|[
name|i
operator|+
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|/
name|HOST_BITS_PER_CHAR
operator|)
index|]
operator|<<
operator|(
name|i
operator|*
name|HOST_BITS_PER_CHAR
operator|)
operator|)
expr_stmt|;
name|low
operator||=
operator|(
name|HOST_WIDE_INT
operator|)
name|parts
index|[
name|i
index|]
operator|<<
operator|(
name|i
operator|*
name|HOST_BITS_PER_CHAR
operator|)
expr_stmt|;
block|}
name|yylval
operator|.
name|ttype
operator|=
name|build_int_2
argument_list|(
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|long_long_unsigned_type_node
expr_stmt|;
comment|/* If warn_traditional, calculate both the ANSI type and the 	       traditional type, then see if they disagree. 	       Otherwise, calculate only the type for the dialect in use.  */
if|if
condition|(
name|warn_traditional
operator|||
name|flag_traditional
condition|)
block|{
comment|/* Calculate the traditional type.  */
comment|/* Traditionally, any constant is signed; 		   but if unsigned is specified explicitly, obey that. 		   Use the smallest size with the right number of bits, 		   except for one special case with decimal constants.  */
if|if
condition|(
operator|!
name|spec_long
operator|&&
name|base
operator|!=
literal|10
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|unsigned_type_node
argument_list|)
condition|)
name|traditional_type
operator|=
operator|(
name|spec_unsigned
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
operator|)
expr_stmt|;
comment|/* A decimal constant must be long 		   if it does not fit in type int. 		   I think this is independent of whether 		   the constant is signed.  */
elseif|else
if|if
condition|(
operator|!
name|spec_long
operator|&&
name|base
operator|==
literal|10
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|integer_type_node
argument_list|)
condition|)
name|traditional_type
operator|=
operator|(
name|spec_unsigned
condition|?
name|unsigned_type_node
else|:
name|integer_type_node
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spec_long_long
condition|)
name|traditional_type
operator|=
operator|(
name|spec_unsigned
condition|?
name|long_unsigned_type_node
else|:
name|long_integer_type_node
operator|)
expr_stmt|;
else|else
name|traditional_type
operator|=
operator|(
name|spec_unsigned
condition|?
name|long_long_unsigned_type_node
else|:
name|long_long_integer_type_node
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|warn_traditional
operator|||
operator|!
name|flag_traditional
condition|)
block|{
comment|/* Calculate the ANSI type.  */
if|if
condition|(
operator|!
name|spec_long
operator|&&
operator|!
name|spec_unsigned
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|integer_type_node
argument_list|)
condition|)
name|ansi_type
operator|=
name|integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spec_long
operator|&&
operator|(
name|base
operator|!=
literal|10
operator|||
name|spec_unsigned
operator|)
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|unsigned_type_node
argument_list|)
condition|)
name|ansi_type
operator|=
name|unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spec_unsigned
operator|&&
operator|!
name|spec_long_long
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|long_integer_type_node
argument_list|)
condition|)
name|ansi_type
operator|=
name|long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spec_long_long
condition|)
name|ansi_type
operator|=
name|long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spec_unsigned
comment|/* Verify value does not overflow into sign bit.  */
operator|&&
name|TREE_INT_CST_HIGH
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|>=
literal|0
operator|&&
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|long_long_integer_type_node
argument_list|)
condition|)
name|ansi_type
operator|=
name|long_long_integer_type_node
expr_stmt|;
else|else
name|ansi_type
operator|=
name|long_long_unsigned_type_node
expr_stmt|;
block|}
name|type
operator|=
name|flag_traditional
condition|?
name|traditional_type
else|:
name|ansi_type
expr_stmt|;
if|if
condition|(
name|warn_traditional
operator|&&
name|traditional_type
operator|!=
name|ansi_type
condition|)
block|{
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|traditional_type
argument_list|)
operator|!=
name|TYPE_PRECISION
argument_list|(
name|ansi_type
argument_list|)
condition|)
name|warning
argument_list|(
literal|"width of integer constant changes with -traditional"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|traditional_type
argument_list|)
operator|!=
name|TREE_UNSIGNED
argument_list|(
name|ansi_type
argument_list|)
condition|)
name|warning
argument_list|(
literal|"integer constant is unsigned in ANSI C, signed with -traditional"
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"width of integer constant may change on other systems with -traditional"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|flag_traditional
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|type
argument_list|)
operator|&&
operator|!
name|warn
condition|)
name|pedwarn
argument_list|(
literal|"integer constant out of range"
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
literal|10
operator|&&
operator|!
name|spec_unsigned
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|warning
argument_list|(
literal|"decimal constant is so large that it is unsigned"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec_imag
condition|)
block|{
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|yylval
operator|.
name|ttype
operator|=
name|build_complex
argument_list|(
name|integer_zero_node
argument_list|,
name|convert
argument_list|(
name|integer_type_node
argument_list|,
name|yylval
operator|.
name|ttype
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"complex integer constant is too wide for `complex int'"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag_traditional
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|,
name|type
argument_list|)
condition|)
comment|/* The traditional constant 0x80000000 is signed 		 but doesn't fit in the range of int. 		 This will change it to -0x80000000, which does fit.  */
block|{
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|yylval
operator|.
name|ttype
operator|=
name|convert
argument_list|(
name|type
argument_list|,
name|yylval
operator|.
name|ttype
argument_list|)
expr_stmt|;
name|TREE_OVERFLOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|TREE_CONSTANT_OVERFLOW
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|type
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
name|value
operator|=
name|CONSTANT
expr_stmt|;
break|break;
block|}
case|case
literal|'\''
case|:
name|char_constant
label|:
block|{
specifier|register
name|int
name|result
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|num_chars
init|=
literal|0
decl_stmt|;
name|unsigned
name|width
init|=
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
decl_stmt|;
name|int
name|max_chars
decl_stmt|;
if|if
condition|(
name|wide_flag
condition|)
block|{
name|width
operator|=
name|WCHAR_TYPE_SIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|max_chars
operator|=
name|MB_CUR_MAX
expr_stmt|;
else|#
directive|else
name|max_chars
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|max_chars
operator|=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|/
name|width
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tryagain
label|:
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\''
operator|||
name|c
operator|==
name|EOF
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|int
name|ignore
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|readescape
argument_list|(
operator|&
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignore
condition|)
goto|goto
name|tryagain
goto|;
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_INT
operator|&&
operator|(
name|unsigned
operator|)
name|c
operator|>=
operator|(
literal|1
operator|<<
name|width
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"escape sequence out of range for character"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAP_CHARACTER
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|MAP_CHARACTER
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids newline in character constant"
argument_list|)
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MAP_CHARACTER
else|else
name|c
operator|=
name|MAP_CHARACTER
argument_list|(
name|c
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|num_chars
operator|++
expr_stmt|;
if|if
condition|(
name|num_chars
operator|>
name|maxtoken
operator|-
literal|4
condition|)
name|extend_token_buffer
argument_list|(
name|token_buffer
argument_list|)
expr_stmt|;
name|token_buffer
index|[
name|num_chars
index|]
operator|=
name|c
expr_stmt|;
comment|/* Merge character into result; ignore excess chars.  */
if|if
condition|(
name|num_chars
operator|<
name|max_chars
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|width
operator|<
name|HOST_BITS_PER_INT
condition|)
name|result
operator|=
operator|(
name|result
operator|<<
name|width
operator|)
operator||
operator|(
name|c
operator|&
operator|(
operator|(
literal|1
operator|<<
name|width
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
else|else
name|result
operator|=
name|c
expr_stmt|;
block|}
block|}
name|token_buffer
index|[
name|num_chars
operator|+
literal|1
index|]
operator|=
literal|'\''
expr_stmt|;
name|token_buffer
index|[
name|num_chars
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\''
condition|)
name|error
argument_list|(
literal|"malformatted character constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num_chars
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"empty character constant"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|num_chars
operator|>
name|max_chars
condition|)
block|{
name|num_chars
operator|=
name|max_chars
expr_stmt|;
name|error
argument_list|(
literal|"character constant too long"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num_chars
operator|!=
literal|1
operator|&&
operator|!
name|flag_traditional
condition|)
name|warning
argument_list|(
literal|"multi-character character constant"
argument_list|)
expr_stmt|;
comment|/* If char type is signed, sign-extend the constant.  */
if|if
condition|(
operator|!
name|wide_flag
condition|)
block|{
name|int
name|num_bits
init|=
name|num_chars
operator|*
name|width
decl_stmt|;
if|if
condition|(
name|num_bits
operator|==
literal|0
condition|)
comment|/* We already got an error; avoid invalid shift.  */
name|yylval
operator|.
name|ttype
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|char_type_node
argument_list|)
operator|||
operator|(
operator|(
name|result
operator|>>
operator|(
name|num_bits
operator|-
literal|1
operator|)
operator|)
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|yylval
operator|.
name|ttype
operator|=
name|build_int_2
argument_list|(
name|result
operator|&
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|~
literal|0
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|num_bits
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|yylval
operator|.
name|ttype
operator|=
name|build_int_2
argument_list|(
name|result
operator||
operator|~
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|~
literal|0
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|num_bits
operator|)
operator|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
comment|/* Set the initial shift state and convert the next sequence.  */
name|result
operator|=
literal|0
expr_stmt|;
comment|/* In all locales L'\0' is zero and mbtowc will return zero, 	       so don't use it.  */
if|if
condition|(
name|num_chars
operator|>
literal|1
operator|||
operator|(
name|num_chars
operator|==
literal|1
operator|&&
name|token_buffer
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|wchar_t
name|wc
decl_stmt|;
operator|(
name|void
operator|)
name|mbtowc
argument_list|(
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|token_buffer
operator|+
literal|1
argument_list|,
name|num_chars
argument_list|)
operator|==
name|num_chars
condition|)
name|result
operator|=
name|wc
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"Ignoring invalid multibyte character"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|yylval
operator|.
name|ttype
operator|=
name|build_int_2
argument_list|(
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|wchar_type_node
expr_stmt|;
block|}
name|value
operator|=
name|CONSTANT
expr_stmt|;
break|break;
block|}
case|case
literal|'"'
case|:
name|string_constant
label|:
block|{
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
name|p
operator|=
name|token_buffer
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|'"'
operator|&&
name|c
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
name|int
name|ignore
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|readescape
argument_list|(
operator|&
name|ignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignore
condition|)
goto|goto
name|skipnewline
goto|;
if|if
condition|(
operator|!
name|wide_flag
operator|&&
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
operator|<
name|HOST_BITS_PER_INT
operator|&&
name|c
operator|>=
operator|(
literal|1
operator|<<
name|TYPE_PRECISION
argument_list|(
name|char_type_node
argument_list|)
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"escape sequence out of range for character"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids newline in string constant"
argument_list|)
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|token_buffer
operator|+
name|maxtoken
condition|)
name|p
operator|=
name|extend_token_buffer
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|skipnewline
label|:
name|c
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* We have read the entire constant. 	   Construct a STRING_CST for the result.  */
if|if
condition|(
name|wide_flag
condition|)
block|{
comment|/* If this is a L"..." wide-string, convert the multibyte string 	       to a wide character string.  */
name|char
modifier|*
name|widep
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|p
operator|-
name|token_buffer
operator|)
operator|*
name|WCHAR_BYTES
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|MULTIBYTE_CHARS
name|len
operator|=
name|mbstowcs
argument_list|(
operator|(
name|wchar_t
operator|*
operator|)
name|widep
argument_list|,
name|token_buffer
operator|+
literal|1
argument_list|,
name|p
operator|-
name|token_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>=
operator|(
name|p
operator|-
name|token_buffer
operator|)
condition|)
block|{
name|warning
argument_list|(
literal|"Ignoring invalid multibyte string"
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
name|bzero
argument_list|(
name|widep
operator|+
operator|(
name|len
operator|*
name|WCHAR_BYTES
operator|)
argument_list|,
name|WCHAR_BYTES
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
union|union
block|{
name|long
name|l
decl_stmt|;
name|char
name|c
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
decl_stmt|;
block|}
name|u
union|;
name|int
name|big_endian
decl_stmt|;
name|char
modifier|*
name|wp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
comment|/* Determine whether host is little or big endian.  */
name|u
operator|.
name|l
operator|=
literal|1
expr_stmt|;
name|big_endian
operator|=
name|u
operator|.
name|c
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|wp
operator|=
name|widep
operator|+
operator|(
name|big_endian
condition|?
name|WCHAR_BYTES
operator|-
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|widep
argument_list|,
operator|(
name|p
operator|-
name|token_buffer
operator|)
operator|*
name|WCHAR_BYTES
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|token_buffer
operator|+
literal|1
init|;
name|cp
operator|<
name|p
condition|;
name|cp
operator|++
control|)
operator|*
name|wp
operator|=
operator|*
name|cp
operator|,
name|wp
operator|+=
name|WCHAR_BYTES
expr_stmt|;
name|len
operator|=
name|p
operator|-
name|token_buffer
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|yylval
operator|.
name|ttype
operator|=
name|build_string
argument_list|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
name|WCHAR_BYTES
argument_list|,
name|widep
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|wchar_array_type_node
expr_stmt|;
name|value
operator|=
name|STRING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|objc_flag
condition|)
block|{
specifier|extern
name|tree
name|build_objc_string
parameter_list|()
function_decl|;
comment|/* Return an Objective-C @"..." constant string object.  */
name|yylval
operator|.
name|ttype
operator|=
name|build_objc_string
argument_list|(
name|p
operator|-
name|token_buffer
argument_list|,
name|token_buffer
operator|+
literal|1
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|char_array_type_node
expr_stmt|;
name|value
operator|=
name|OBJC_STRING
expr_stmt|;
block|}
else|else
block|{
name|yylval
operator|.
name|ttype
operator|=
name|build_string
argument_list|(
name|p
operator|-
name|token_buffer
argument_list|,
name|token_buffer
operator|+
literal|1
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|yylval
operator|.
name|ttype
argument_list|)
operator|=
name|char_array_type_node
expr_stmt|;
name|value
operator|=
name|STRING
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'"'
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
literal|'&'
case|:
case|case
literal|'|'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'*'
case|:
case|case
literal|'/'
case|:
case|case
literal|'%'
case|:
case|case
literal|'^'
case|:
case|case
literal|'!'
case|:
case|case
literal|'='
case|:
block|{
specifier|register
name|int
name|c1
decl_stmt|;
name|combine
label|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'+'
case|:
name|yylval
operator|.
name|code
operator|=
name|PLUS_EXPR
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|yylval
operator|.
name|code
operator|=
name|MINUS_EXPR
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
name|yylval
operator|.
name|code
operator|=
name|BIT_AND_EXPR
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
name|yylval
operator|.
name|code
operator|=
name|BIT_IOR_EXPR
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|yylval
operator|.
name|code
operator|=
name|MULT_EXPR
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|yylval
operator|.
name|code
operator|=
name|TRUNC_DIV_EXPR
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|yylval
operator|.
name|code
operator|=
name|TRUNC_MOD_EXPR
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|yylval
operator|.
name|code
operator|=
name|BIT_XOR_EXPR
expr_stmt|;
break|break;
case|case
name|LSHIFT
case|:
name|yylval
operator|.
name|code
operator|=
name|LSHIFT_EXPR
expr_stmt|;
break|break;
case|case
name|RSHIFT
case|:
name|yylval
operator|.
name|code
operator|=
name|RSHIFT_EXPR
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|yylval
operator|.
name|code
operator|=
name|LT_EXPR
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|yylval
operator|.
name|code
operator|=
name|GT_EXPR
expr_stmt|;
break|break;
block|}
name|token_buffer
index|[
literal|1
index|]
operator|=
name|c1
operator|=
name|getc
argument_list|(
name|finput
argument_list|)
expr_stmt|;
name|token_buffer
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'='
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'<'
case|:
name|value
operator|=
name|ARITHCOMPARE
expr_stmt|;
name|yylval
operator|.
name|code
operator|=
name|LE_EXPR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'>'
case|:
name|value
operator|=
name|ARITHCOMPARE
expr_stmt|;
name|yylval
operator|.
name|code
operator|=
name|GE_EXPR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'!'
case|:
name|value
operator|=
name|EQCOMPARE
expr_stmt|;
name|yylval
operator|.
name|code
operator|=
name|NE_EXPR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'='
case|:
name|value
operator|=
name|EQCOMPARE
expr_stmt|;
name|yylval
operator|.
name|code
operator|=
name|EQ_EXPR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|value
operator|=
name|ASSIGN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|c1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'+'
case|:
name|value
operator|=
name|PLUSPLUS
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'-'
case|:
name|value
operator|=
name|MINUSMINUS
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'&'
case|:
name|value
operator|=
name|ANDAND
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'|'
case|:
name|value
operator|=
name|OROR
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|'<'
case|:
name|c
operator|=
name|LSHIFT
expr_stmt|;
goto|goto
name|combine
goto|;
case|case
literal|'>'
case|:
name|c
operator|=
name|RSHIFT
expr_stmt|;
goto|goto
name|combine
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|c1
operator|==
literal|'>'
operator|)
condition|)
block|{
name|value
operator|=
name|POINTSAT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|ungetc
argument_list|(
name|c1
argument_list|,
name|finput
argument_list|)
expr_stmt|;
name|token_buffer
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'<'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'>'
operator|)
condition|)
name|value
operator|=
name|ARITHCOMPARE
expr_stmt|;
else|else
name|value
operator|=
name|c
expr_stmt|;
goto|goto
name|done
goto|;
block|}
case|case
literal|0
case|:
comment|/* Don't make yyparse think this is eof.  */
name|value
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|value
operator|=
name|c
expr_stmt|;
block|}
name|done
label|:
comment|/*  yylloc.last_line = lineno; */
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* Sets the value of the 'yydebug' variable to VALUE.    This is a function so we don't have to have YYDEBUG defined    in order to build the compiler.  */
end_comment

begin_function
name|void
name|set_yydebug
parameter_list|(
name|value
parameter_list|)
name|int
name|value
decl_stmt|;
block|{
if|#
directive|if
name|YYDEBUG
operator|!=
literal|0
name|yydebug
operator|=
name|value
expr_stmt|;
else|#
directive|else
name|warning
argument_list|(
literal|"YYDEBUG not defined."
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

