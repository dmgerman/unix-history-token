begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Process declarations and variables for C compiler.    Copyright (C) 1988, 1992, 1993, 1994 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* Process declarations and symbol lookup for C front end.    Also constructs types; the standard scalar types at initialization,    and structure, union, array and enum types when they are declared.  */
end_comment

begin_comment
comment|/* ??? not all decl nodes are given the most useful possible    line numbers.  For example, the CONST_DECLs for enum values.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"c-tree.h"
end_include

begin_include
include|#
directive|include
file|"c-lex.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* In grokdeclarator, distinguish syntactic contexts of declarators.  */
end_comment

begin_enum
enum|enum
name|decl_context
block|{
name|NORMAL
block|,
comment|/* Ordinary declaration */
name|FUNCDEF
block|,
comment|/* Function definition */
name|PARM
block|,
comment|/* Declaration of parm before function body */
name|FIELD
block|,
comment|/* Declaration inside struct or union */
name|BITFIELD
block|,
comment|/* Likewise but with specified width */
name|TYPENAME
block|}
enum|;
end_enum

begin_comment
comment|/* Typename (inside cast or sizeof)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CHAR_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|CHAR_TYPE_SIZE
value|BITS_PER_UNIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SHORT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|SHORT_TYPE_SIZE
value|(BITS_PER_UNIT * MIN ((UNITS_PER_WORD + 1) / 2, 2))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|INT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_LONG_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_LONG_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_UNSIGNED
end_ifndef

begin_define
define|#
directive|define
name|WCHAR_UNSIGNED
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FLOAT_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|FLOAT_TYPE_SIZE
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DOUBLE_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|DOUBLE_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_DOUBLE_TYPE_SIZE
end_ifndef

begin_define
define|#
directive|define
name|LONG_DOUBLE_TYPE_SIZE
value|(BITS_PER_WORD * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We let tm.h override the types used here, to handle trivial differences    such as the choice of unsigned int or long unsigned int for size_t.    When machines start needing nontrivial differences in the size type,    it would be best to do something here to figure out automatically    from other information what type to use.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIZE_TYPE
end_ifndef

begin_define
define|#
directive|define
name|SIZE_TYPE
value|"long unsigned int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PTRDIFF_TYPE
end_ifndef

begin_define
define|#
directive|define
name|PTRDIFF_TYPE
value|"long int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_TYPE
end_ifndef

begin_define
define|#
directive|define
name|WCHAR_TYPE
value|"int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* a node which has tree code ERROR_MARK, and whose type is itself.    All erroneous expressions are replaced with this node.  All functions    that accept nodes as arguments should avoid generating error messages    if this node is one of the arguments, since it is undesirable to get    multiple error messages from one error in the input.  */
end_comment

begin_decl_stmt
name|tree
name|error_mark_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* INTEGER_TYPE and REAL_TYPE nodes for the standard data types */
end_comment

begin_decl_stmt
name|tree
name|short_integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_long_integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|short_unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_long_unsigned_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|ptrdiff_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_char_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|signed_char_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|char_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|wchar_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|signed_wchar_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_wchar_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|float_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|double_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|long_double_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|complex_integer_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|complex_float_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|complex_double_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|complex_long_double_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|intQI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|intHI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|intSI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|intDI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_intQI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_intHI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_intSI_type_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|unsigned_intDI_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a VOID_TYPE node.  */
end_comment

begin_decl_stmt
name|tree
name|void_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nodes for types `void *' and `const void *'.  */
end_comment

begin_decl_stmt
name|tree
name|ptr_type_node
decl_stmt|,
name|const_ptr_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nodes for types `char *' and `const char *'.  */
end_comment

begin_decl_stmt
name|tree
name|string_type_node
decl_stmt|,
name|const_string_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type `char[SOMENUMBER]'.    Used when an array of char is needed and the size is irrelevant.  */
end_comment

begin_decl_stmt
name|tree
name|char_array_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type `int[SOMENUMBER]' or something like it.    Used when an array of int needed and the size is irrelevant.  */
end_comment

begin_decl_stmt
name|tree
name|int_array_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type `wchar_t[SOMENUMBER]' or something like it.    Used when a wide string literal is created.  */
end_comment

begin_decl_stmt
name|tree
name|wchar_array_type_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type `int ()' -- used for implicit declaration of functions.  */
end_comment

begin_decl_stmt
name|tree
name|default_function_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* function types `double (double)' and `double (double, double)', etc.  */
end_comment

begin_decl_stmt
name|tree
name|double_ftype_double
decl_stmt|,
name|double_ftype_double_double
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|int_ftype_int
decl_stmt|,
name|long_ftype_long
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function type `void (void *, void *, int)' and similar ones */
end_comment

begin_decl_stmt
name|tree
name|void_ftype_ptr_ptr_int
decl_stmt|,
name|int_ftype_ptr_ptr_int
decl_stmt|,
name|void_ftype_ptr_int_int
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function type `char *(char *, char *)' and similar ones */
end_comment

begin_decl_stmt
name|tree
name|string_ftype_ptr_ptr
decl_stmt|,
name|int_ftype_string_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function type `int (const void *, const void *, size_t)' */
end_comment

begin_decl_stmt
name|tree
name|int_ftype_cptr_cptr_sizet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Two expressions that are constants with value zero.    The first is of type `int', the second of type `void *'.  */
end_comment

begin_decl_stmt
name|tree
name|integer_zero_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tree
name|null_pointer_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A node for the integer constant 1.  */
end_comment

begin_decl_stmt
name|tree
name|integer_one_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we have seen an invalid cross reference    to a struct, union, or enum, but not yet printed the message.  */
end_comment

begin_decl_stmt
name|tree
name|pending_invalid_xref
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File and line to appear in the eventual error message.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|pending_invalid_xref_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pending_invalid_xref_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* While defining an enum type, this is 1 plus the last enumerator    constant value.  Note that will do not have to save this or `enum_overflow'    around nested function definition since such a definition could only    occur in an enum value expression and we don't use these variables in    that case.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|enum_next_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that there was overflow computing enum_next_value.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|enum_overflow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parsing a function declarator leaves a list of parameter names    or a chain or parameter decls here.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|last_function_parms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parsing a function declarator leaves here a chain of structure    and enum types declared in the parmlist.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|last_function_parm_tags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* After parsing the declarator that starts a function definition,    `start_function' puts here the list of parameter names or chain of decls.    `store_parm_decls' finds it here.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|current_function_parms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, for last_function_parm_tags.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|current_function_parm_tags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Similar, for the file and line that the prototype came from if this is    an old-style definition.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|current_function_prototype_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_function_prototype_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list (chain of TREE_LIST nodes) of all LABEL_DECLs in the function    that have names.  Here so we can clear out their names' definitions    at the end of the function.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|named_labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A list of LABEL_DECLs from outer contexts that are currently shadowed.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|shadowed_labels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero when store_parm_decls is called indicates a varargs function.    Value not meaningful after store_parm_decls.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|c_function_varargs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The FUNCTION_DECL for the function currently being compiled,    or 0 if between functions.  */
end_comment

begin_decl_stmt
name|tree
name|current_function_decl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, set to 1 if    a return statement that specifies a return value is seen.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_value
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 0 at beginning of a function definition, set to 1 if    a return statement with no argument is seen.  */
end_comment

begin_decl_stmt
name|int
name|current_function_returns_null
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to nonzero by `grokdeclarator' for a function    whose return type is defaulted, if warnings for this are desired.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warn_about_return_type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero when starting a function declared `extern inline'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_extern_inline
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* For each binding contour we allocate a binding_level structure  * which records the names defined in that contour.  * Contours include:  *  0) the global one  *  1) one for each function definition,  *     where internal declarations of the parameters appear.  *  2) one for each compound statement,  *     to record its declarations.  *  * The current meaning of a name can be found by searching the levels from  * the current one out to the global one.  */
end_comment

begin_comment
comment|/* Note that the information in the `names' component of the global contour    is duplicated in the IDENTIFIER_GLOBAL_VALUEs of all identifiers.  */
end_comment

begin_struct
struct|struct
name|binding_level
block|{
comment|/* A chain of _DECL nodes for all variables, constants, functions,        and typedef types.  These are in the reverse of the order supplied.      */
name|tree
name|names
decl_stmt|;
comment|/* A list of structure, union and enum definitions,      * for looking up tag names.      * It is a chain of TREE_LIST nodes, each of whose TREE_PURPOSE is a name,      * or NULL_TREE; and whose TREE_VALUE is a RECORD_TYPE, UNION_TYPE,      * or ENUMERAL_TYPE node.      */
name|tree
name|tags
decl_stmt|;
comment|/* For each level, a list of shadowed outer-level local definitions        to be restored when this level is popped.        Each link is a TREE_LIST whose TREE_PURPOSE is an identifier and        whose TREE_VALUE is its old definition (a kind of ..._DECL node).  */
name|tree
name|shadowed
decl_stmt|;
comment|/* For each level (except not the global one),        a chain of BLOCK nodes for all the levels        that were entered and exited one level down.  */
name|tree
name|blocks
decl_stmt|;
comment|/* The BLOCK node for this level, if one has been preallocated.        If 0, the BLOCK is allocated (if needed) when the level is popped.  */
name|tree
name|this_block
decl_stmt|;
comment|/* The binding level which this one is contained in (inherits from).  */
name|struct
name|binding_level
modifier|*
name|level_chain
decl_stmt|;
comment|/* Nonzero for the level that holds the parameters of a function.  */
name|char
name|parm_flag
decl_stmt|;
comment|/* Nonzero if this level "doesn't exist" for tags.  */
name|char
name|tag_transparent
decl_stmt|;
comment|/* Nonzero if sublevels of this level "don't exist" for tags.        This is set in the parm level of a function definition        while reading the function body, so that the outermost block        of the function body will be tag-transparent.  */
name|char
name|subblocks_tag_transparent
decl_stmt|;
comment|/* Nonzero means make a BLOCK for this level regardless of all else.  */
name|char
name|keep
decl_stmt|;
comment|/* Nonzero means make a BLOCK if this level has any subblocks.  */
name|char
name|keep_if_subblocks
decl_stmt|;
comment|/* Number of decls in `names' that have incomplete         structure or union types.  */
name|int
name|n_incomplete
decl_stmt|;
comment|/* A list of decls giving the (reversed) specified order of parms,        not including any forward-decls in the parmlist.        This is so we can put the parms in proper order for assign_parms.  */
name|tree
name|parm_order
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NULL_BINDING_LEVEL
value|(struct binding_level *) NULL
end_define

begin_comment
comment|/* The binding level currently in effect.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|current_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A chain of binding_level structures awaiting reuse.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|free_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The outermost binding level, for names of file scope.    This is created when the compiler is started and exists    through the entire run.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|global_binding_level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Binding level structures are initialized by copying this one.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
name|clear_binding_level
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL_BINDING_LEVEL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means unconditionally make a BLOCK for the next level pushed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|keep_next_level_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means make a BLOCK for the next level pushed    if it has subblocks.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|keep_next_if_subblocks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The chain of outer levels of label scopes.    This uses the same data structure used for binding levels,    but it works differently: each link in the chain records    saved values of named_labels and shadowed_labels for    a label binding level outside the current one.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|binding_level
modifier|*
name|label_level_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|tree
name|grokparms
argument_list|()
decl_stmt|,
name|grokdeclarator
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|tree
name|pushdecl
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|tree
name|builtin_function
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|shadow_tag_warned
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_tag
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|tree
name|lookup_tag_reverse
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|tree
name|lookup_name_current_level
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|redeclaration_error_message
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|layout_array_type
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* C-specific option variables.  */
end_comment

begin_comment
comment|/* Nonzero means allow type mismatches in conditional expressions;    just make their values `void'.   */
end_comment

begin_decl_stmt
name|int
name|flag_cond_mismatch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give `double' the same size as `float'.  */
end_comment

begin_decl_stmt
name|int
name|flag_short_double
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't recognize the keyword `asm'.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_asm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't recognize any builtin functions.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_builtin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't recognize the non-ANSI builtin functions.    -ansi sets this.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_nonansi_builtin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means do some things the same way PCC does.  */
end_comment

begin_decl_stmt
name|int
name|flag_traditional
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to allow single precision math even if we're generally    being traditional. */
end_comment

begin_decl_stmt
name|int
name|flag_allow_single_precision
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means to treat bitfields as signed unless they say `unsigned'.  */
end_comment

begin_decl_stmt
name|int
name|flag_signed_bitfields
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|explicit_flag_signed_bitfields
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means handle `#ident' directives.  0 means ignore them.  */
end_comment

begin_decl_stmt
name|int
name|flag_no_ident
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about implicit declarations.  */
end_comment

begin_decl_stmt
name|int
name|warn_implicit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give string constants the type `const char *'    to get extra warnings from them.  These warnings will be too numerous    to be useful, except in thoroughly ANSIfied programs.  */
end_comment

begin_decl_stmt
name|int
name|warn_write_strings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about pointer casts that can drop a type qualifier    from the pointer target type.  */
end_comment

begin_decl_stmt
name|int
name|warn_cast_qual
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn when casting a function call to a type that does    not match the return type (e.g. (float)sqrt() or (anything*)malloc()    when there is no previous declaration of sqrt or malloc.  */
end_comment

begin_decl_stmt
name|int
name|warn_bad_function_cast
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about traditional constructs whose meanings changed in ANSI C.  */
end_comment

begin_decl_stmt
name|int
name|warn_traditional
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about sizeof(function) or addition/subtraction    of function pointers.  */
end_comment

begin_decl_stmt
name|int
name|warn_pointer_arith
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn for non-prototype function decls    or non-prototyped defs without previous prototype.  */
end_comment

begin_decl_stmt
name|int
name|warn_strict_prototypes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn for any global function def    without separate previous prototype decl.  */
end_comment

begin_decl_stmt
name|int
name|warn_missing_prototypes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn for any global function def    without separate previous decl.  */
end_comment

begin_decl_stmt
name|int
name|warn_missing_declarations
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about multiple (redundant) decls for the same single    variable or function.  */
end_comment

begin_decl_stmt
name|int
name|warn_redundant_decls
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn about extern declarations of objects not at    file-scope level and about *all* declarations of functions (whether    extern or static) not at file-scope level.  Note that we exclude    implicit function declarations.  To get warnings about those, use    -Wimplicit.  */
end_comment

begin_decl_stmt
name|int
name|warn_nested_externs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about *printf or *scanf format/argument anomalies. */
end_comment

begin_decl_stmt
name|int
name|warn_format
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn about a subscript that has type char.  */
end_comment

begin_decl_stmt
name|int
name|warn_char_subscripts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if a type conversion is done that might have confusing results.  */
end_comment

begin_decl_stmt
name|int
name|warn_conversion
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if adding () is suggested.  */
end_comment

begin_decl_stmt
name|int
name|warn_parentheses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Warn if initializer is not completely bracketed.  */
end_comment

begin_decl_stmt
name|int
name|warn_missing_braces
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means `$' can be in an identifier.    See cccp.c for reasons why this breaks some obscure ANSI C programs.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DOLLARS_IN_IDENTIFIERS
end_ifndef

begin_define
define|#
directive|define
name|DOLLARS_IN_IDENTIFIERS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|dollars_in_ident
init|=
name|DOLLARS_IN_IDENTIFIERS
operator|>
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Decode the string P as a language-specific option for C.    Return 1 if it is recognized (and handle it);    return 0 if not recognized.  */
end_comment

begin_function
name|int
name|c_decode_option
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-ftraditional"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-traditional"
argument_list|)
condition|)
block|{
name|flag_traditional
operator|=
literal|1
expr_stmt|;
name|flag_writable_strings
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|DOLLARS_IN_IDENTIFIERS
operator|>
literal|0
name|dollars_in_ident
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fallow-single-precision"
argument_list|)
condition|)
name|flag_allow_single_precision
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fnotraditional"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fno-traditional"
argument_list|)
condition|)
block|{
name|flag_traditional
operator|=
literal|0
expr_stmt|;
name|flag_writable_strings
operator|=
literal|0
expr_stmt|;
name|dollars_in_ident
operator|=
name|DOLLARS_IN_IDENTIFIERS
operator|>
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fdollars-in-identifiers"
argument_list|)
condition|)
block|{
if|#
directive|if
name|DOLLARS_IN_IDENTIFIERS
operator|>
literal|0
name|dollars_in_ident
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fno-dollars-in-identifiers"
argument_list|)
condition|)
name|dollars_in_ident
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fsigned-char"
argument_list|)
condition|)
name|flag_signed_char
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-funsigned-char"
argument_list|)
condition|)
name|flag_signed_char
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fno-signed-char"
argument_list|)
condition|)
name|flag_signed_char
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fno-unsigned-char"
argument_list|)
condition|)
name|flag_signed_char
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fsigned-bitfields"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fno-unsigned-bitfields"
argument_list|)
condition|)
block|{
name|flag_signed_bitfields
operator|=
literal|1
expr_stmt|;
name|explicit_flag_signed_bitfields
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-funsigned-bitfields"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fno-signed-bitfields"
argument_list|)
condition|)
block|{
name|flag_signed_bitfields
operator|=
literal|0
expr_stmt|;
name|explicit_flag_signed_bitfields
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fshort-enums"
argument_list|)
condition|)
name|flag_short_enums
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fno-short-enums"
argument_list|)
condition|)
name|flag_short_enums
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fcond-mismatch"
argument_list|)
condition|)
name|flag_cond_mismatch
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fno-cond-mismatch"
argument_list|)
condition|)
name|flag_cond_mismatch
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fshort-double"
argument_list|)
condition|)
name|flag_short_double
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fno-short-double"
argument_list|)
condition|)
name|flag_short_double
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fasm"
argument_list|)
condition|)
name|flag_no_asm
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fno-asm"
argument_list|)
condition|)
name|flag_no_asm
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fbuiltin"
argument_list|)
condition|)
name|flag_no_builtin
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fno-builtin"
argument_list|)
condition|)
name|flag_no_builtin
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fno-ident"
argument_list|)
condition|)
name|flag_no_ident
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-fident"
argument_list|)
condition|)
name|flag_no_ident
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-ansi"
argument_list|)
condition|)
name|flag_no_asm
operator|=
literal|1
operator|,
name|flag_no_nonansi_builtin
operator|=
literal|1
operator|,
name|dollars_in_ident
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wimplicit"
argument_list|)
condition|)
name|warn_implicit
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-implicit"
argument_list|)
condition|)
name|warn_implicit
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wwrite-strings"
argument_list|)
condition|)
name|warn_write_strings
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-write-strings"
argument_list|)
condition|)
name|warn_write_strings
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wcast-qual"
argument_list|)
condition|)
name|warn_cast_qual
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-cast-qual"
argument_list|)
condition|)
name|warn_cast_qual
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wbad-function-cast"
argument_list|)
condition|)
name|warn_bad_function_cast
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-bad-function-cast"
argument_list|)
condition|)
name|warn_bad_function_cast
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wpointer-arith"
argument_list|)
condition|)
name|warn_pointer_arith
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-pointer-arith"
argument_list|)
condition|)
name|warn_pointer_arith
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wstrict-prototypes"
argument_list|)
condition|)
name|warn_strict_prototypes
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-strict-prototypes"
argument_list|)
condition|)
name|warn_strict_prototypes
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wmissing-prototypes"
argument_list|)
condition|)
name|warn_missing_prototypes
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-missing-prototypes"
argument_list|)
condition|)
name|warn_missing_prototypes
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wmissing-declarations"
argument_list|)
condition|)
name|warn_missing_declarations
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-missing-declarations"
argument_list|)
condition|)
name|warn_missing_declarations
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wredundant-decls"
argument_list|)
condition|)
name|warn_redundant_decls
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-redundant-decls"
argument_list|)
condition|)
name|warn_redundant_decls
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wnested-externs"
argument_list|)
condition|)
name|warn_nested_externs
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-nested-externs"
argument_list|)
condition|)
name|warn_nested_externs
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wtraditional"
argument_list|)
condition|)
name|warn_traditional
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-traditional"
argument_list|)
condition|)
name|warn_traditional
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wformat"
argument_list|)
condition|)
name|warn_format
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-format"
argument_list|)
condition|)
name|warn_format
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wchar-subscripts"
argument_list|)
condition|)
name|warn_char_subscripts
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-char-subscripts"
argument_list|)
condition|)
name|warn_char_subscripts
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wconversion"
argument_list|)
condition|)
name|warn_conversion
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-conversion"
argument_list|)
condition|)
name|warn_conversion
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wparentheses"
argument_list|)
condition|)
name|warn_parentheses
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-parentheses"
argument_list|)
condition|)
name|warn_parentheses
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wreturn-type"
argument_list|)
condition|)
name|warn_return_type
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-return-type"
argument_list|)
condition|)
name|warn_return_type
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wcomment"
argument_list|)
condition|)
empty_stmt|;
comment|/* cpp handles this one.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-comment"
argument_list|)
condition|)
empty_stmt|;
comment|/* cpp handles this one.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wcomments"
argument_list|)
condition|)
empty_stmt|;
comment|/* cpp handles this one.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-comments"
argument_list|)
condition|)
empty_stmt|;
comment|/* cpp handles this one.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wtrigraphs"
argument_list|)
condition|)
empty_stmt|;
comment|/* cpp handles this one.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-trigraphs"
argument_list|)
condition|)
empty_stmt|;
comment|/* cpp handles this one.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wimport"
argument_list|)
condition|)
empty_stmt|;
comment|/* cpp handles this one.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-import"
argument_list|)
condition|)
empty_stmt|;
comment|/* cpp handles this one.  */
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wmissing-braces"
argument_list|)
condition|)
name|warn_missing_braces
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wno-missing-braces"
argument_list|)
condition|)
name|warn_missing_braces
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-Wall"
argument_list|)
condition|)
block|{
name|extra_warnings
operator|=
literal|1
expr_stmt|;
comment|/* We save the value of warn_uninitialized, since if they put 	 -Wuninitialized on the command line, we need to generate a 	 warning about not using it without also specifying -O.  */
if|if
condition|(
name|warn_uninitialized
operator|!=
literal|1
condition|)
name|warn_uninitialized
operator|=
literal|2
expr_stmt|;
name|warn_implicit
operator|=
literal|1
expr_stmt|;
name|warn_return_type
operator|=
literal|1
expr_stmt|;
name|warn_unused
operator|=
literal|1
expr_stmt|;
name|warn_switch
operator|=
literal|1
expr_stmt|;
name|warn_format
operator|=
literal|1
expr_stmt|;
name|warn_char_subscripts
operator|=
literal|1
expr_stmt|;
name|warn_parentheses
operator|=
literal|1
expr_stmt|;
name|warn_missing_braces
operator|=
literal|1
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Hooks for print_node.  */
end_comment

begin_function
name|void
name|print_lang_decl
parameter_list|(
name|file
parameter_list|,
name|node
parameter_list|,
name|indent
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|tree
name|node
decl_stmt|;
name|int
name|indent
decl_stmt|;
block|{ }
end_function

begin_function
name|void
name|print_lang_type
parameter_list|(
name|file
parameter_list|,
name|node
parameter_list|,
name|indent
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|tree
name|node
decl_stmt|;
name|int
name|indent
decl_stmt|;
block|{ }
end_function

begin_function
name|void
name|print_lang_identifier
parameter_list|(
name|file
parameter_list|,
name|node
parameter_list|,
name|indent
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|tree
name|node
decl_stmt|;
name|int
name|indent
decl_stmt|;
block|{
name|print_node
argument_list|(
name|file
argument_list|,
literal|"global"
argument_list|,
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"local"
argument_list|,
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"label"
argument_list|,
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"implicit"
argument_list|,
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"error locus"
argument_list|,
name|IDENTIFIER_ERROR_LOCUS
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
name|print_node
argument_list|(
name|file
argument_list|,
literal|"limbo value"
argument_list|,
name|IDENTIFIER_LIMBO_VALUE
argument_list|(
name|node
argument_list|)
argument_list|,
name|indent
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Hook called at end of compilation to assume 1 elt    for a top-level array decl that wasn't complete before.  */
end_comment

begin_function
name|void
name|finish_incomplete_decl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|&&
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|complete_array_type
argument_list|(
name|type
argument_list|,
name|NULL_TREE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a new `struct binding_level'.  */
end_comment

begin_function
specifier|static
name|struct
name|binding_level
modifier|*
name|make_binding_level
parameter_list|()
block|{
comment|/* NOSTRICT */
return|return
operator|(
expr|struct
name|binding_level
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|binding_level
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Nonzero if we are currently in the global binding level.  */
end_comment

begin_function
name|int
name|global_bindings_p
parameter_list|()
block|{
return|return
name|current_binding_level
operator|==
name|global_binding_level
return|;
block|}
end_function

begin_function
name|void
name|keep_next_level
parameter_list|()
block|{
name|keep_next_level_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Nonzero if the current level needs to have a BLOCK made.  */
end_comment

begin_function
name|int
name|kept_level_p
parameter_list|()
block|{
return|return
operator|(
operator|(
name|current_binding_level
operator|->
name|keep_if_subblocks
operator|&&
name|current_binding_level
operator|->
name|blocks
operator|!=
literal|0
operator|)
operator|||
name|current_binding_level
operator|->
name|keep
operator|||
name|current_binding_level
operator|->
name|names
operator|!=
literal|0
operator|||
operator|(
name|current_binding_level
operator|->
name|tags
operator|!=
literal|0
operator|&&
operator|!
name|current_binding_level
operator|->
name|tag_transparent
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Identify this binding level as a level of parameters.    DEFINITION_FLAG is 1 for a definition, 0 for a declaration.    But it turns out there is no way to pass the right value for    DEFINITION_FLAG, so we ignore it.  */
end_comment

begin_function
name|void
name|declare_parm_level
parameter_list|(
name|definition_flag
parameter_list|)
name|int
name|definition_flag
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|parm_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Nonzero if currently making parm declarations.  */
end_comment

begin_function
name|int
name|in_parm_level_p
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|parm_flag
return|;
block|}
end_function

begin_comment
comment|/* Enter a new binding level.    If TAG_TRANSPARENT is nonzero, do so only for the name space of variables,    not for that of tags.  */
end_comment

begin_function
name|void
name|pushlevel
parameter_list|(
name|tag_transparent
parameter_list|)
name|int
name|tag_transparent
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|newlevel
init|=
name|NULL_BINDING_LEVEL
decl_stmt|;
comment|/* If this is the top level of a function,      just make sure that NAMED_LABELS is 0.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
name|named_labels
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Reuse or create a struct for this binding level.  */
if|if
condition|(
name|free_binding_level
condition|)
block|{
name|newlevel
operator|=
name|free_binding_level
expr_stmt|;
name|free_binding_level
operator|=
name|free_binding_level
operator|->
name|level_chain
expr_stmt|;
block|}
else|else
block|{
name|newlevel
operator|=
name|make_binding_level
argument_list|()
expr_stmt|;
block|}
comment|/* Add this level to the front of the chain (stack) of levels that      are active.  */
operator|*
name|newlevel
operator|=
name|clear_binding_level
expr_stmt|;
name|newlevel
operator|->
name|tag_transparent
operator|=
operator|(
name|tag_transparent
operator|||
operator|(
name|current_binding_level
condition|?
name|current_binding_level
operator|->
name|subblocks_tag_transparent
else|:
literal|0
operator|)
operator|)
expr_stmt|;
name|newlevel
operator|->
name|level_chain
operator|=
name|current_binding_level
expr_stmt|;
name|current_binding_level
operator|=
name|newlevel
expr_stmt|;
name|newlevel
operator|->
name|keep
operator|=
name|keep_next_level_flag
expr_stmt|;
name|keep_next_level_flag
operator|=
literal|0
expr_stmt|;
name|newlevel
operator|->
name|keep_if_subblocks
operator|=
name|keep_next_if_subblocks
expr_stmt|;
name|keep_next_if_subblocks
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Exit a binding level.    Pop the level off, and restore the state of the identifier-decl mappings    that were in effect when this level was entered.     If KEEP is nonzero, this level had explicit declarations, so    and create a "block" (a BLOCK node) for the level    to record its declarations and subblocks for symbol table output.     If FUNCTIONBODY is nonzero, this level is the body of a function,    so create a block as if KEEP were set and also clear out all    label names.     If REVERSE is nonzero, reverse the order of decls before putting    them into the BLOCK.  */
end_comment

begin_function
name|tree
name|poplevel
parameter_list|(
name|keep
parameter_list|,
name|reverse
parameter_list|,
name|functionbody
parameter_list|)
name|int
name|keep
decl_stmt|;
name|int
name|reverse
decl_stmt|;
name|int
name|functionbody
decl_stmt|;
block|{
specifier|register
name|tree
name|link
decl_stmt|;
comment|/* The chain of decls was accumulated in reverse order.      Put it into forward order, just for cleanliness.  */
name|tree
name|decls
decl_stmt|;
name|tree
name|tags
init|=
name|current_binding_level
operator|->
name|tags
decl_stmt|;
name|tree
name|subblocks
init|=
name|current_binding_level
operator|->
name|blocks
decl_stmt|;
name|tree
name|block
init|=
literal|0
decl_stmt|;
name|tree
name|decl
decl_stmt|;
name|int
name|block_previously_created
decl_stmt|;
name|keep
operator||=
name|current_binding_level
operator|->
name|keep
expr_stmt|;
comment|/* This warning is turned off because it causes warnings for      declarations like `extern struct foo *x'.  */
if|#
directive|if
literal|0
comment|/* Warn about incomplete structure types in this level.  */
block|for (link = tags; link; link = TREE_CHAIN (link))     if (TYPE_SIZE (TREE_VALUE (link)) == 0)       { 	tree type = TREE_VALUE (link); 	char *errmsg; 	switch (TREE_CODE (type)) 	  { 	  case RECORD_TYPE: 	    errmsg = "`struct %s' incomplete in scope ending here"; 	    break; 	  case UNION_TYPE: 	    errmsg = "`union %s' incomplete in scope ending here"; 	    break; 	  case ENUMERAL_TYPE: 	    errmsg = "`enum %s' incomplete in scope ending here"; 	    break; 	  } 	if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE) 	  error (errmsg, IDENTIFIER_POINTER (TYPE_NAME (type))); 	else
comment|/* If this type has a typedef-name, the TYPE_NAME is a TYPE_DECL.  */
block|error (errmsg, IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))));       }
endif|#
directive|endif
comment|/* 0 */
comment|/* Get the decls in the order they were written.      Usually current_binding_level->names is in reverse order.      But parameter decls were previously put in forward order.  */
if|if
condition|(
name|reverse
condition|)
name|current_binding_level
operator|->
name|names
operator|=
name|decls
operator|=
name|nreverse
argument_list|(
name|current_binding_level
operator|->
name|names
argument_list|)
expr_stmt|;
else|else
name|decls
operator|=
name|current_binding_level
operator|->
name|names
expr_stmt|;
comment|/* Output any nested inline functions within this block      if they weren't already output.  */
for|for
control|(
name|decl
operator|=
name|decls
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If this decl was copied from a file-scope decl 	   on account of a block-scope extern decl, 	   propagate TREE_ADDRESSABLE to the file-scope decl.  */
if|if
condition|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|push_function_context
argument_list|()
expr_stmt|;
name|output_inline_function
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pop_function_context
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If there were any declarations or structure tags in that level,      or if this level is a function body,      create a BLOCK to record them for the life of this function.  */
name|block
operator|=
literal|0
expr_stmt|;
name|block_previously_created
operator|=
operator|(
name|current_binding_level
operator|->
name|this_block
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|block_previously_created
condition|)
name|block
operator|=
name|current_binding_level
operator|->
name|this_block
expr_stmt|;
elseif|else
if|if
condition|(
name|keep
operator|||
name|functionbody
operator|||
operator|(
name|current_binding_level
operator|->
name|keep_if_subblocks
operator|&&
name|subblocks
operator|!=
literal|0
operator|)
condition|)
name|block
operator|=
name|make_node
argument_list|(
name|BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|!=
literal|0
condition|)
block|{
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|decls
expr_stmt|;
name|BLOCK_TYPE_TAGS
argument_list|(
name|block
argument_list|)
operator|=
name|tags
expr_stmt|;
name|BLOCK_SUBBLOCKS
argument_list|(
name|block
argument_list|)
operator|=
name|subblocks
expr_stmt|;
name|remember_end_note
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
comment|/* In each subblock, record that this is its superior.  */
for|for
control|(
name|link
operator|=
name|subblocks
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|BLOCK_SUPERCONTEXT
argument_list|(
name|link
argument_list|)
operator|=
name|block
expr_stmt|;
comment|/* Clear out the meanings of the local variables of this level.  */
for|for
control|(
name|link
operator|=
name|decls
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* If the ident. was used or addressed via a local extern decl, 	     don't forget that fact.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|link
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_USED
argument_list|(
name|link
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|link
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Restore all name-meanings of the outer levels      that were shadowed by this level.  */
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
comment|/* If the level being exited is the top level of a function,      check over all the labels, and clear out the current      (function local) meanings of their names.  */
if|if
condition|(
name|functionbody
condition|)
block|{
comment|/* If this is the top level block of a function, 	 the vars are the function's parameters. 	 Don't leave them in the BLOCK because they are 	 found in the FUNCTION_DECL instead.  */
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Clear out the definitions of all label names, 	 since their scopes end here, 	 and add them to BLOCK_VARS.  */
for|for
control|(
name|link
operator|=
name|named_labels
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
specifier|register
name|tree
name|label
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|label
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|label
argument_list|,
literal|"label `%s' used but not defined"
argument_list|)
expr_stmt|;
comment|/* Avoid crashing later.  */
name|define_label
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|DECL_NAME
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|warn_unused
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|label
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|label
argument_list|,
literal|"label `%s' defined but not used"
argument_list|)
expr_stmt|;
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|label
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Put the labels into the "variables" of the 	     top-level block, so debugger can see them.  */
name|TREE_CHAIN
argument_list|(
name|label
argument_list|)
operator|=
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
expr_stmt|;
name|BLOCK_VARS
argument_list|(
name|block
argument_list|)
operator|=
name|label
expr_stmt|;
block|}
block|}
comment|/* Pop the current level, and free the structure for reuse.  */
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
init|=
name|current_binding_level
decl_stmt|;
name|current_binding_level
operator|=
name|current_binding_level
operator|->
name|level_chain
expr_stmt|;
name|level
operator|->
name|level_chain
operator|=
name|free_binding_level
expr_stmt|;
name|free_binding_level
operator|=
name|level
expr_stmt|;
block|}
comment|/* Dispose of the block that we just made inside some higher level.  */
if|if
condition|(
name|functionbody
condition|)
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|block
expr_stmt|;
elseif|else
if|if
condition|(
name|block
condition|)
block|{
if|if
condition|(
operator|!
name|block_previously_created
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
comment|/* If we did not make a block for the level just exited,      any blocks made for inner levels      (since they cannot be recorded as subblocks in that level)      must be carried forward so they will later become subblocks      of something else.  */
elseif|else
if|if
condition|(
name|subblocks
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|subblocks
argument_list|)
expr_stmt|;
comment|/* Set the TYPE_CONTEXTs for all of the tagged types belonging to this      binding contour so that they point to the appropriate construct, i.e.      either to the current FUNCTION_DECL node, or else to the BLOCK node      we just constructed.       Note that for tagged types whose scope is just the formal parameter      list for some function type specification, we can't properly set      their TYPE_CONTEXTs here, because we don't have a pointer to the      appropriate FUNCTION_TYPE node readily available to us.  For those      cases, the TYPE_CONTEXTs of the relevant tagged type nodes get set      in `grokdeclarator' as soon as we have created the FUNCTION_TYPE      node which will represent the "scope" for these "parameter list local"      tagged types.   */
if|if
condition|(
name|functionbody
condition|)
for|for
control|(
name|link
operator|=
name|tags
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|TYPE_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
elseif|else
if|if
condition|(
name|block
condition|)
for|for
control|(
name|link
operator|=
name|tags
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|TYPE_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|block
condition|)
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|block
return|;
block|}
end_function

begin_comment
comment|/* Delete the node BLOCK from the current binding level.    This is used for the block inside a stmt expr ({...})    so that the block can be reinserted where appropriate.  */
end_comment

begin_function
name|void
name|delete_block
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|->
name|blocks
operator|==
name|block
condition|)
name|current_binding_level
operator|->
name|blocks
operator|=
name|TREE_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|current_binding_level
operator|->
name|blocks
init|;
name|t
condition|;
control|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
name|block
condition|)
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|block
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|TREE_CHAIN
argument_list|(
name|block
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* Clear TREE_USED which is always set by poplevel.      The flag is set again if insert_block is called.  */
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert BLOCK at the end of the list of subblocks of the    current binding level.  This is used when a BIND_EXPR is expanded,    to handle the BLOCK node inside the BIND_EXPR.  */
end_comment

begin_function
name|void
name|insert_block
parameter_list|(
name|block
parameter_list|)
name|tree
name|block
decl_stmt|;
block|{
name|TREE_USED
argument_list|(
name|block
argument_list|)
operator|=
literal|1
expr_stmt|;
name|current_binding_level
operator|->
name|blocks
operator|=
name|chainon
argument_list|(
name|current_binding_level
operator|->
name|blocks
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the BLOCK node for the innermost scope    (the one we are currently in).  */
end_comment

begin_function
name|void
name|set_block
parameter_list|(
name|block
parameter_list|)
specifier|register
name|tree
name|block
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|this_block
operator|=
name|block
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|push_label_level
parameter_list|()
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|newlevel
decl_stmt|;
comment|/* Reuse or create a struct for this binding level.  */
if|if
condition|(
name|free_binding_level
condition|)
block|{
name|newlevel
operator|=
name|free_binding_level
expr_stmt|;
name|free_binding_level
operator|=
name|free_binding_level
operator|->
name|level_chain
expr_stmt|;
block|}
else|else
block|{
name|newlevel
operator|=
name|make_binding_level
argument_list|()
expr_stmt|;
block|}
comment|/* Add this level to the front of the chain (stack) of label levels.  */
name|newlevel
operator|->
name|level_chain
operator|=
name|label_level_chain
expr_stmt|;
name|label_level_chain
operator|=
name|newlevel
expr_stmt|;
name|newlevel
operator|->
name|names
operator|=
name|named_labels
expr_stmt|;
name|newlevel
operator|->
name|shadowed
operator|=
name|shadowed_labels
expr_stmt|;
name|named_labels
operator|=
literal|0
expr_stmt|;
name|shadowed_labels
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_label_level
parameter_list|()
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
init|=
name|label_level_chain
decl_stmt|;
name|tree
name|link
decl_stmt|,
name|prev
decl_stmt|;
comment|/* Clear out the definitions of the declared labels in this level.      Leave in the list any ordinary, non-declared labels.  */
for|for
control|(
name|link
operator|=
name|named_labels
operator|,
name|prev
operator|=
literal|0
init|;
name|link
condition|;
control|)
block|{
if|if
condition|(
name|C_DECLARED_LABEL_FLAG
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|DECL_SOURCE_LINE
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
literal|"label `%s' used but not defined"
argument_list|)
expr_stmt|;
comment|/* Avoid crashing later.  */
name|define_label
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|warn_unused
operator|&&
operator|!
name|TREE_USED
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
literal|"label `%s' defined but not used"
argument_list|)
expr_stmt|;
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Delete this element from the list.  */
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|TREE_CHAIN
argument_list|(
name|prev
argument_list|)
operator|=
name|link
expr_stmt|;
else|else
name|named_labels
operator|=
name|link
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|link
expr_stmt|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Bring back all the labels that were shadowed.  */
for|for
control|(
name|link
operator|=
name|shadowed_labels
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|named_labels
operator|=
name|chainon
argument_list|(
name|named_labels
argument_list|,
name|level
operator|->
name|names
argument_list|)
expr_stmt|;
name|shadowed_labels
operator|=
name|level
operator|->
name|shadowed
expr_stmt|;
comment|/* Pop the current level, and free the structure for reuse.  */
name|label_level_chain
operator|=
name|label_level_chain
operator|->
name|level_chain
expr_stmt|;
name|level
operator|->
name|level_chain
operator|=
name|free_binding_level
expr_stmt|;
name|free_binding_level
operator|=
name|level
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Push a definition or a declaration of struct, union or enum tag "name".    "type" should be the type node.    We assume that the tag "name" is not already defined.     Note that the definition may really be just a forward reference.    In that case, the TYPE_SIZE will be zero.  */
end_comment

begin_function
name|void
name|pushtag
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
name|tree
name|name
decl_stmt|,
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|b
decl_stmt|;
comment|/* Find the proper binding level for this type tag.  */
for|for
control|(
name|b
operator|=
name|current_binding_level
init|;
name|b
operator|->
name|tag_transparent
condition|;
name|b
operator|=
name|b
operator|->
name|level_chain
control|)
continue|continue;
if|if
condition|(
name|name
condition|)
block|{
comment|/* Record the identifier as the type's name if it has none.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|name
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|==
name|global_binding_level
condition|)
name|b
operator|->
name|tags
operator|=
name|perm_tree_cons
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|b
operator|->
name|tags
argument_list|)
expr_stmt|;
else|else
name|b
operator|->
name|tags
operator|=
name|saveable_tree_cons
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|b
operator|->
name|tags
argument_list|)
expr_stmt|;
comment|/* Create a fake NULL-named TYPE_DECL node whose TREE_TYPE will be the      tagged type we just added to the current binding level.  This fake      NULL-named TYPE_DECL node helps dwarfout.c to know when it needs      to output a representation of a tagged type, and it also gives      us a convenient place to record the "scope start" address for the      tagged type.  */
name|TYPE_STUB_DECL
argument_list|(
name|type
argument_list|)
operator|=
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle when a new declaration NEWDECL    has the same name as an old one OLDDECL    in the same binding contour.    Prints an error message if appropriate.     If safely possible, alter OLDDECL to look like NEWDECL, and return 1.    Otherwise, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|duplicate_decls
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|)
specifier|register
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
block|{
name|int
name|types_match
init|=
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|new_is_definition
init|=
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
literal|0
operator|)
decl_stmt|;
name|tree
name|oldtype
init|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|tree
name|newtype
init|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
decl_stmt|;
name|char
modifier|*
name|errmsg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newtype
argument_list|)
operator|==
name|ERROR_MARK
operator|||
name|TREE_CODE
argument_list|(
name|oldtype
argument_list|)
operator|==
name|ERROR_MARK
condition|)
name|types_match
operator|=
literal|0
expr_stmt|;
comment|/* New decl is completely inconsistent with the old one =>      tell caller to replace the old one.      This is always an error except in the case of shadowing a builtin.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
operator|||
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
block|{
comment|/* If you declare a built-in or predefined function name as static, 	     the old definition is overridden, 	     but optionally warn this was a bad choice of name.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|warn_shadow
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"shadowing built-in function `%s'"
argument_list|)
expr_stmt|;
else|else
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"shadowing library function `%s'"
argument_list|)
expr_stmt|;
block|}
comment|/* Likewise, if the built-in is not ansi, then programs can 	     override it even globally without an error.  */
elseif|else
if|if
condition|(
operator|!
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"library function `%s' declared as non-function"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|olddecl
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"built-in function `%s' declared as non-function"
argument_list|)
expr_stmt|;
else|else
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"built-in function `%s' declared as non-function"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"`%s' redeclared as different kind of symbol"
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"previous declaration of `%s'"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* For real parm decl following a forward decl,      return 1 so old decl will be reused.  */
if|if
condition|(
name|types_match
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|TREE_ASM_WRITTEN
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* The new declaration is the same kind of object as the old one.      The declarations may partially match.  Print warnings if they don't      match enough.  Ultimately, copy most of the information from the new      decl to the old one, and keep using the old one.  */
if|if
condition|(
name|flag_traditional
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|DECL_NAME
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|==
name|olddecl
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
literal|0
condition|)
comment|/* If -traditional, avoid error for redeclaring fcn        after implicit decl.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
comment|/* A function declaration for a built-in function.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
comment|/* If you declare a built-in function name as static, the 	     built-in definition is overridden, 	     but optionally warn this was a bad choice of name.  */
if|if
condition|(
name|warn_shadow
condition|)
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"shadowing built-in function `%s'"
argument_list|)
expr_stmt|;
comment|/* Discard the old built-in function.  */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
comment|/* Accept the return type of the new declaration if same modes.  */
name|tree
name|oldreturntype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|newreturntype
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|oldreturntype
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|newreturntype
argument_list|)
condition|)
block|{
comment|/* Function types may be shared, so we can't just modify 		 the return type of olddecl's function type.  */
name|tree
name|newtype
init|=
name|build_function_type
argument_list|(
name|newreturntype
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|types_match
operator|=
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|newtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|types_match
condition|)
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|newtype
expr_stmt|;
block|}
comment|/* Accept harmless mismatch in first argument type also. 	     This is for ffs.  */
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|TYPE_MODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_MODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Function types may be shared, so we can't just modify 		 the return type of olddecl's function type.  */
name|tree
name|newtype
init|=
name|build_function_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|TREE_CHAIN
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|types_match
operator|=
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|,
name|newtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|types_match
condition|)
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|newtype
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
comment|/* If types don't match for a built-in, throw away the built-in.  */
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"conflicting types for built-in function `%s'"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_SOURCE_LINE
argument_list|(
name|olddecl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* A function declaration for a predeclared function 	 that isn't actually built in.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
comment|/* If you declare it as static, the 	     default definition is overridden.  */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|types_match
condition|)
block|{
comment|/* If the types don't match, preserve volatility indication. 	     Later on, we will discard everything else about the 	     default declaration.  */
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
operator||=
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Permit char *foo () to match void *foo (...) if not pedantic,      if one of them came from a system header file.  */
elseif|else
if|if
condition|(
operator|!
name|types_match
operator|&&
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newtype
argument_list|)
argument_list|)
operator|==
name|POINTER_TYPE
operator|&&
operator|(
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|olddecl
argument_list|)
operator|||
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newtype
argument_list|)
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
operator|==
literal|0
operator|&&
name|self_promoting_args_p
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
argument_list|)
operator|==
name|char_type_node
operator|)
operator|||
operator|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|newtype
argument_list|)
argument_list|)
operator|==
name|char_type_node
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
operator|==
literal|0
operator|&&
name|self_promoting_args_p
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
argument_list|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"conflicting types for `%s'"
argument_list|)
expr_stmt|;
comment|/* Make sure we keep void * as ret type, not char *.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|newtype
operator|=
name|oldtype
expr_stmt|;
comment|/* Set DECL_IN_SYSTEM_HEADER, so that if we see another declaration 	 we will come back here again.  */
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|types_match
comment|/* Permit char *foo (int, ...); followed by char *foo (); 	      if not pedantic.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|pedantic
comment|/* Return types must still match.  */
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|newtype
argument_list|)
argument_list|)
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"conflicting types for `%s'"
argument_list|)
expr_stmt|;
comment|/* Check for function type mismatch 	 involving an empty arglist vs a nonempty one.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldtype
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|newtype
argument_list|)
argument_list|)
operator|&&
operator|(
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Classify the problem further.  */
specifier|register
name|tree
name|t
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
name|t
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|!=
name|void_type_node
condition|)
block|{
name|error
argument_list|(
literal|"A parameter list with an ellipsis can't match"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"an empty parameter name list declaration."
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|float_type_node
operator|||
name|C_PROMOTING_INTEGER_TYPE_P
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"An argument type that has a default promotion"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"can't match an empty parameter name list declaration."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|error_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"previous declaration of `%s'"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errmsg
operator|=
name|redeclaration_error_message
argument_list|(
name|newdecl
argument_list|,
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
condition|)
block|{
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|olddecl
argument_list|,
operator|(
operator|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|current_binding_level
operator|==
name|global_binding_level
operator|)
condition|?
literal|"`%s' previously defined here"
else|:
literal|"`%s' previously declared here"
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|register
name|tree
name|type
decl_stmt|,
name|parm
decl_stmt|;
specifier|register
name|int
name|nargs
decl_stmt|;
comment|/* Prototype decl follows defn w/o prototype.  */
for|for
control|(
name|parm
operator|=
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|oldtype
argument_list|)
operator|,
name|type
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|newtype
argument_list|)
operator|,
name|nargs
operator|=
literal|1
init|;
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|,
name|type
operator|=
name|TREE_CHAIN
argument_list|(
name|type
argument_list|)
operator|,
name|nargs
operator|++
control|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|errmsg
operator|=
literal|"prototype for `%s' follows and number of arguments"
expr_stmt|;
break|break;
block|}
comment|/* Type for passing arg must be consistent 		 with that declared for the arg.  */
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
comment|/* If -traditional, allow `unsigned int' instead of `int' 		     in the prototype.  */
operator|&&
operator|(
operator|!
operator|(
name|flag_traditional
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|integer_type_node
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|unsigned_type_node
operator|)
operator|)
condition|)
block|{
name|errmsg
operator|=
literal|"prototype for `%s' follows and argument %d"
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|errmsg
condition|)
block|{
name|error_with_decl
argument_list|(
name|newdecl
argument_list|,
name|errmsg
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"doesn't match non-prototype definition here"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"prototype for `%s' follows"
argument_list|)
expr_stmt|;
name|warning_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"non-prototype definition here"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Warn about mismatches in various flags.  */
else|else
block|{
comment|/* Warn if function is now inline 	     but was previously declared not inline and has been called.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|DECL_INLINE
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|TREE_USED
argument_list|(
name|olddecl
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"`%s' declared inline after being called"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|DECL_INLINE
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
condition|)
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"`%s' declared inline after its definition"
argument_list|)
expr_stmt|;
comment|/* If pedantic, warn when static declaration follows a non-static 	     declaration.  Otherwise, do so only for functions.  */
if|if
condition|(
operator|(
name|pedantic
operator|||
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"static declaration for `%s' follows non-static"
argument_list|)
expr_stmt|;
comment|/* Warn when const declaration follows a non-const 	     declaration, but not for functions.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
operator|!
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"const declaration for `%s' follows non-const"
argument_list|)
expr_stmt|;
comment|/* These bits are logically part of the type, for variables. 	     But not for functions 	     (where qualifiers are not valid ANSI anyway).  */
elseif|else
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
operator|(
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|||
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|)
condition|)
name|pedwarn_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"type qualifiers for `%s' conflict with previous decl"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Optionally warn about more than one declaration for the same name.  */
if|if
condition|(
name|errmsg
operator|==
literal|0
operator|&&
name|warn_redundant_decls
operator|&&
name|DECL_SOURCE_LINE
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
comment|/* Dont warn about a function declaration 	 followed by a definition.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
literal|0
operator|)
comment|/* Don't warn about extern decl followed by (tentative) definition.  */
operator|&&
operator|!
operator|(
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|)
condition|)
block|{
name|warning_with_decl
argument_list|(
name|newdecl
argument_list|,
literal|"redundant redeclaration of `%s' in same scope"
argument_list|)
expr_stmt|;
name|warning_with_decl
argument_list|(
name|olddecl
argument_list|,
literal|"previous declaration of `%s'"
argument_list|)
expr_stmt|;
block|}
comment|/* Copy all the DECL_... slots specified in the new decl      except for any that we copy here from the old type.       Past this point, we don't change OLDTYPE and NEWTYPE      even if we change the types of NEWDECL and OLDDECL.  */
if|if
condition|(
name|types_match
condition|)
block|{
comment|/* Make sure we put the new type in the same obstack as the old ones. 	 If the old types are not both in the same obstack, use the permanent 	 one.  */
if|if
condition|(
name|TYPE_OBSTACK
argument_list|(
name|oldtype
argument_list|)
operator|==
name|TYPE_OBSTACK
argument_list|(
name|newtype
argument_list|)
condition|)
name|push_obstacks
argument_list|(
name|TYPE_OBSTACK
argument_list|(
name|oldtype
argument_list|)
argument_list|,
name|TYPE_OBSTACK
argument_list|(
name|oldtype
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
block|}
comment|/* Merge the data types specified in the two decls.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|||
operator|!
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|common_type
argument_list|(
name|newtype
argument_list|,
name|oldtype
argument_list|)
expr_stmt|;
comment|/* Lay the type out, unless already done.  */
if|if
condition|(
name|oldtype
operator|!=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|TYPE_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|!=
name|CONST_DECL
condition|)
name|layout_decl
argument_list|(
name|newdecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Since the type is OLDDECL's, make OLDDECL's size go with.  */
name|DECL_SIZE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SIZE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
if|if
condition|(
name|DECL_ALIGN
argument_list|(
name|olddecl
argument_list|)
operator|>
name|DECL_ALIGN
argument_list|(
name|newdecl
argument_list|)
condition|)
name|DECL_ALIGN
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ALIGN
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Keep the old rtl since we can safely use it.  */
name|DECL_RTL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_RTL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Merge the type qualifiers.  */
if|if
condition|(
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
condition|)
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|VAR_DECL
condition|)
name|make_var_volatile
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
comment|/* Keep source location of definition rather than declaration.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DECL_SOURCE_LINE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the unused-warning information.  */
if|if
condition|(
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|olddecl
argument_list|)
condition|)
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|newdecl
argument_list|)
condition|)
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Merge the initialization information.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Merge the section attribute.          We want to issue an error if the sections conflict but that must be 	 done later in decl_attributes since we are called before attributes 	 are assigned.  */
if|if
condition|(
name|DECL_SECTION_NAME
argument_list|(
name|newdecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|DECL_SECTION_NAME
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SECTION_NAME
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
comment|/* If cannot merge, then use the new type and qualifiers,      and don't preserve the old rtl.  */
else|else
block|{
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_READONLY
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_READONLY
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_THIS_VOLATILE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_SIDE_EFFECTS
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
comment|/* Merge the storage class information.  */
comment|/* For functions, static overrides non-static.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|&=
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* This is since we don't automatically 	 copy the attributes of NEWDECL into OLDDECL.  */
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
comment|/* If this clears `static', clear it in the identifier too.  */
if|if
condition|(
operator|!
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|DECL_NAME
argument_list|(
name|olddecl
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
condition|)
block|{
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* An extern decl does not override previous storage class.  */
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TREE_STATIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_STATIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
block|}
comment|/* If either decl says `inline', this fn is inline,      unless its definition was passed already.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_INLINE
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INLINE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
comment|/* Get rid of any built-in function if new arg types don't match it      or if we have a function definition.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|(
operator|!
name|types_match
operator|||
name|new_is_definition
operator|)
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
expr_stmt|;
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If redeclaring a builtin function, and not a definition,      it stays built in.      Also preserve various other info from the definition.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|new_is_definition
condition|)
block|{
if|if
condition|(
name|DECL_BUILT_IN
argument_list|(
name|olddecl
argument_list|)
condition|)
block|{
name|DECL_BUILT_IN
argument_list|(
name|newdecl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FUNCTION_CODE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_FUNCTION_CODE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
else|else
name|DECL_FRAME_SIZE
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_FRAME_SIZE
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_RESULT
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_SAVED_INSNS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_SAVED_INSNS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|newdecl
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|olddecl
argument_list|)
expr_stmt|;
block|}
comment|/* Copy most of the decl-specific fields of NEWDECL into OLDDECL.      But preserve OLDdECL's DECL_UID.  */
block|{
specifier|register
name|unsigned
name|olddecl_uid
init|=
name|DECL_UID
argument_list|(
name|olddecl
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newdecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|olddecl
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tree_decl
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|tree_common
argument_list|)
argument_list|)
expr_stmt|;
name|DECL_UID
argument_list|(
name|olddecl
argument_list|)
operator|=
name|olddecl_uid
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Record a decl-node X as belonging to the current lexical scope.    Check for errors (such as an incompatible declaration for the same    name already seen in the same scope).     Returns either X or an old decl for the same name.    If an old decl is returned, it may have been smashed    to agree with what X says.  */
end_comment

begin_function
name|tree
name|pushdecl
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
specifier|register
name|tree
name|name
init|=
name|DECL_NAME
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
comment|/* A local extern declaration for a function doesn't constitute nesting.      A local auto declaration does, since it's a forward decl      for a nested function coming later.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
condition|)
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|warn_nested_externs
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|b
operator|!=
name|global_binding_level
operator|&&
name|x
operator|!=
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
comment|/* Don't print error messages for __FUNCTION__ and __PRETTY_FUNCTION__ */
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|x
argument_list|)
condition|)
name|warning
argument_list|(
literal|"nested extern declaration of `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
comment|/* Don't type check externs here when -traditional.  This is so that 	 code with conflicting declarations inside blocks will get warnings 	 not errors.  X11 for instance depends on this.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|flag_traditional
condition|)
name|t
operator|=
name|lookup_name_current_level_global
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|lookup_name_current_level
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
literal|0
operator|&&
name|t
operator|==
name|error_mark_node
condition|)
comment|/* error_mark_node is 0 for a while during initialization!  */
block|{
name|t
operator|=
literal|0
expr_stmt|;
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"`%s' used prior to declaration"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|!=
literal|0
condition|)
block|{
name|file
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|line
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|!=
literal|0
operator|&&
name|duplicate_decls
argument_list|(
name|x
argument_list|,
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
comment|/* Don't allow more than one "real" duplicate 		 of a forward parm decl.  */
name|TREE_ASM_WRITTEN
argument_list|(
name|t
argument_list|)
operator|=
name|TREE_ASM_WRITTEN
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
comment|/* If this decl is `static' and an implicit decl was seen previously, 	     warn.  But don't complain if -traditional, 	     since traditional compilers don't complain.  */
if|if
condition|(
operator|!
name|flag_traditional
operator|&&
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
comment|/* We used to warn also for explicit extern followed by static, 		 but sometimes you need to do it that way.  */
operator|&&
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|pedwarn
argument_list|(
literal|"`%s' was declared implicitly `extern' and later `static'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|pedwarn_with_file_and_line
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|"previous declaration of `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a global decl, and there exists a conflicting local 	     decl in a parent block, then we can't return as yet, because we 	     need to register this decl in the current binding block.  */
if|if
condition|(
operator|!
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|||
operator|!
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|||
name|lookup_name
argument_list|(
name|name
argument_list|)
operator|==
name|t
condition|)
return|return
name|t
return|;
block|}
comment|/* If we are processing a typedef statement, generate a whole new 	 ..._TYPE node (which will be just an variant of the existing 	 ..._TYPE node with identical properties) and then install the 	 TYPE_DECL node generated to represent the typedef name as the 	 TYPE_NAME of this brand new (duplicate) ..._TYPE node.  	 The whole point here is to end up with a situation where each 	 and every ..._TYPE node the compiler creates will be uniquely 	 associated with AT MOST one node representing a typedef name. 	 This way, even though the compiler substitutes corresponding 	 ..._TYPE nodes for TYPE_DECL (i.e. "typedef name") nodes very 	 early on, later parts of the compiler can always do the reverse 	 translation and get back the corresponding typedef name.  For 	 example, given:  		typedef struct S MY_TYPE; 		MY_TYPE object;  	 Later parts of the compiler might only know that `object' was of 	 type `struct S' if if were not for code just below.  With this 	 code however, later parts of the compiler see something like:  		struct S' == struct S 		typedef struct S' MY_TYPE; 		struct S' object;  	 And they can then deduce (from the node for type struct S') that 	 the original object declaration was:  		MY_TYPE object;  	 Being able to do this is important for proper support of protoize, 	 and also for generating precise symbolic debugging information 	 which takes full account of the programmer's (typedef) vocabulary.           Obviously, we don't want to generate a duplicate ..._TYPE node if 	 the TYPE_DECL node that we are now processing really represents a 	 standard built-in type.           Since all standard types are effectively declared at line zero          in the source file, we can easily check to see if we are working          on a standard type by checking the current value of lineno.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|DECL_SOURCE_LINE
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
name|tree
name|tt
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|tt
operator|=
name|build_type_copy
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|tt
argument_list|)
operator|=
name|x
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|tt
expr_stmt|;
block|}
block|}
comment|/* Multiple external decls of the same identifier ought to match. 	 Check against both global declarations (when traditional) and out of 	 scope (limbo) block level declarations.  	 We get warnings about inline functions where they are defined. 	 Avoid duplicate warnings where they are used.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_INLINE
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|flag_traditional
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|DECL_EXTERNAL
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|||
name|TREE_PUBLIC
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
operator|)
condition|)
name|decl
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_LIMBO_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
condition|)
comment|/* Decls in limbo are always extern, so no need to check that.  */
name|decl
operator|=
name|IDENTIFIER_LIMBO_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|decl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|decl
operator|&&
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
comment|/* If old decl is built-in, we already warned if we should.  */
operator|&&
operator|!
name|DECL_BUILT_IN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|pedwarn_with_decl
argument_list|(
name|x
argument_list|,
literal|"type mismatch with previous external decl"
argument_list|)
expr_stmt|;
name|pedwarn_with_decl
argument_list|(
name|decl
argument_list|,
literal|"previous external decl of `%s'"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If a function has had an implicit declaration, and then is defined, 	 make sure they are compatible.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|warning_with_decl
argument_list|(
name|x
argument_list|,
literal|"type mismatch with previous implicit declaration"
argument_list|)
expr_stmt|;
name|warning_with_decl
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"previous implicit declaration of `%s'"
argument_list|)
expr_stmt|;
block|}
comment|/* In PCC-compatibility mode, extern decls of vars with no current decl 	 take effect at top level no matter where they are.  */
if|if
condition|(
name|flag_traditional
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|lookup_name
argument_list|(
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* But don't do this if the type contains temporary nodes.  */
while|while
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
break|break;
if|if
condition|(
operator|!
name|TREE_PERMANENT
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|warning_with_decl
argument_list|(
name|x
argument_list|,
literal|"type of external `%s' is not global"
argument_list|)
expr_stmt|;
comment|/* By exiting the loop early, we leave TYPE nonzero, 		     and thus prevent globalization of the decl.  */
break|break;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
comment|/* The types might not be truly local, 		   but the list of arg types certainly is temporary. 		   Since prototypes are nontraditional, 		   ok not to do the traditional thing.  */
break|break;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
literal|0
condition|)
name|b
operator|=
name|global_binding_level
expr_stmt|;
block|}
comment|/* This name is new in its binding level. 	 Install the new declaration and return it.  */
if|if
condition|(
name|b
operator|==
name|global_binding_level
condition|)
block|{
comment|/* Install a global value.  */
comment|/* If the first global decl has external linkage, 	     warn if we later see static one.  */
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|x
expr_stmt|;
comment|/* We no longer care about any previous block level declarations.  */
name|IDENTIFIER_LIMBO_VALUE
argument_list|(
name|name
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Don't forget if the function was used via an implicit decl.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_USED
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
name|TREE_USED
argument_list|(
name|x
argument_list|)
operator|=
literal|1
operator|,
name|TREE_USED
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Don't forget if its address was taken in that way.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|&&
name|TREE_ADDRESSABLE
argument_list|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Warn about mismatches against previous implicit decl.  */
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
comment|/* If this real decl matches the implicit, don't complain.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
operator|==
name|integer_type_node
operator|)
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"`%s' was previously implicitly declared to return `int'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this decl is `static' and an `extern' was seen previously, 	     that is erroneous.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
comment|/* Okay to redeclare an ANSI built-in as static.  */
if|if
condition|(
name|t
operator|!=
literal|0
operator|&&
name|DECL_BUILT_IN
argument_list|(
name|t
argument_list|)
condition|)
empty_stmt|;
comment|/* Okay to declare a non-ANSI built-in as anything.  */
elseif|else
if|if
condition|(
name|t
operator|!=
literal|0
operator|&&
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|t
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|name
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"`%s' was declared implicitly `extern' and later `static'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"`%s' was declared `extern' and later `static'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Here to install a non-global value.  */
name|tree
name|oldlocal
init|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|tree
name|oldglobal
init|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|x
expr_stmt|;
comment|/* If this is an extern function declaration, see if we 	     have a global definition or declaration for the function.  */
if|if
condition|(
name|oldlocal
operator|==
literal|0
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
operator|!
name|DECL_INLINE
argument_list|(
name|x
argument_list|)
operator|&&
name|oldglobal
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|TREE_CODE
argument_list|(
name|oldglobal
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* We have one.  Their types must agree.  */
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|,
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
condition|)
name|pedwarn_with_decl
argument_list|(
name|x
argument_list|,
literal|"extern declaration of `%s' doesn't match global one"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Inner extern decl is inline if global one is. 		     Copy enough to really inline it.  */
if|if
condition|(
name|DECL_INLINE
argument_list|(
name|oldglobal
argument_list|)
condition|)
block|{
name|DECL_INLINE
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_INLINE
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
operator|(
name|current_function_decl
operator|==
name|oldglobal
condition|?
literal|0
else|:
name|DECL_INITIAL
argument_list|(
name|oldglobal
argument_list|)
operator|)
expr_stmt|;
name|DECL_SAVED_INSNS
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_SAVED_INSNS
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_FRAME_SIZE
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_FRAME_SIZE
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_RESULT
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_RESULT
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|TREE_ASM_WRITTEN
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_ASM_WRITTEN
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_ABSTRACT_ORIGIN
argument_list|(
name|x
argument_list|)
operator|=
name|oldglobal
expr_stmt|;
block|}
comment|/* Inner extern decl is built-in if global one is.  */
if|if
condition|(
name|DECL_BUILT_IN
argument_list|(
name|oldglobal
argument_list|)
condition|)
block|{
name|DECL_BUILT_IN
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_BUILT_IN
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
name|DECL_FUNCTION_CODE
argument_list|(
name|x
argument_list|)
operator|=
name|DECL_FUNCTION_CODE
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
block|}
comment|/* Keep the arg types from a file-scope fcn defn.  */
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|oldglobal
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|oldglobal
argument_list|)
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|oldglobal
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* This case is probably sometimes the right thing to do.  */
comment|/* If we have a local external declaration, 	     then any file-scope declaration should not 	     have been static.  */
block|if (oldlocal == 0&& oldglobal != 0&& !TREE_PUBLIC (oldglobal)&& DECL_EXTERNAL (x)&& TREE_PUBLIC (x)) 	    warning ("`%s' locally external but globally static", 		     IDENTIFIER_POINTER (name));
endif|#
directive|endif
comment|/* If we have a local external declaration, 	     and no file-scope declaration has yet been seen, 	     then if we later have a file-scope decl it must not be static.  */
if|if
condition|(
name|oldlocal
operator|==
literal|0
operator|&&
name|oldglobal
operator|==
literal|0
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_PUBLIC
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|name
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Save this decl, so that we can do type checking against 		 other decls after it falls out of scope.  		 Only save it once.  This prevents temporary decls created in 		 expand_inline_function from being used here, since this 		 will have been set when the inline function was parsed. 		 It also helps give slightly better warnings.  */
if|if
condition|(
name|IDENTIFIER_LIMBO_VALUE
argument_list|(
name|name
argument_list|)
operator|==
literal|0
condition|)
name|IDENTIFIER_LIMBO_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
comment|/* Warn if shadowing an argument at the top level of the body.  */
if|if
condition|(
name|oldlocal
operator|!=
literal|0
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
comment|/* This warning doesn't apply to the parms of a nested fcn.  */
operator|&&
operator|!
name|current_binding_level
operator|->
name|parm_flag
comment|/* Check that this is one level down from the parms.  */
operator|&&
name|current_binding_level
operator|->
name|level_chain
operator|->
name|parm_flag
comment|/* Check that the decl being shadowed 		 comes from the parm level, one level up.  */
operator|&&
name|chain_member
argument_list|(
name|oldlocal
argument_list|,
name|current_binding_level
operator|->
name|level_chain
operator|->
name|names
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|pedwarn
argument_list|(
literal|"declaration of `%s' shadows a parameter"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"declaration of `%s' shadows a symbol from the parameter list"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Maybe warn if shadowing something else.  */
elseif|else
if|if
condition|(
name|warn_shadow
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|x
argument_list|)
comment|/* No shadow warnings for internally generated vars.  */
operator|&&
name|DECL_SOURCE_LINE
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
comment|/* No shadow warnings for vars made for inlining.  */
operator|&&
operator|!
name|DECL_FROM_INLINE
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|char
modifier|*
name|warnstring
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PARM_DECL
operator|&&
name|current_binding_level
operator|->
name|level_chain
operator|->
name|parm_flag
condition|)
comment|/* Don't warn about the parm names in function declarator 		   within a function declarator. 		   It would be nice to avoid warning in any function 		   declarator in a declaration, as opposed to a definition, 		   but there is no way to tell it's not a definition.  */
empty_stmt|;
elseif|else
if|if
condition|(
name|oldlocal
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|oldlocal
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|warnstring
operator|=
literal|"declaration of `%s' shadows a parameter"
expr_stmt|;
elseif|else
if|if
condition|(
name|oldlocal
operator|!=
literal|0
condition|)
name|warnstring
operator|=
literal|"declaration of `%s' shadows previous local"
expr_stmt|;
elseif|else
if|if
condition|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
name|error_mark_node
condition|)
name|warnstring
operator|=
literal|"declaration of `%s' shadows global declaration"
expr_stmt|;
if|if
condition|(
name|warnstring
condition|)
name|warning
argument_list|(
name|warnstring
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If storing a local value, there may already be one (inherited). 	     If so, record it for restoration when this binding level ends.  */
if|if
condition|(
name|oldlocal
operator|!=
literal|0
condition|)
name|b
operator|->
name|shadowed
operator|=
name|tree_cons
argument_list|(
name|name
argument_list|,
name|oldlocal
argument_list|,
name|b
operator|->
name|shadowed
argument_list|)
expr_stmt|;
block|}
comment|/* Keep count of variables in this level with incomplete type.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
operator|++
name|b
operator|->
name|n_incomplete
expr_stmt|;
block|}
comment|/* Put decls on list in reverse order.      We will reverse them later if necessary.  */
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|b
operator|->
name|names
expr_stmt|;
name|b
operator|->
name|names
operator|=
name|x
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Like pushdecl, only it places X in GLOBAL_BINDING_LEVEL, if appropriate.  */
end_comment

begin_function
name|tree
name|pushdecl_top_level
parameter_list|(
name|x
parameter_list|)
name|tree
name|x
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
specifier|register
name|struct
name|binding_level
modifier|*
name|b
init|=
name|current_binding_level
decl_stmt|;
name|current_binding_level
operator|=
name|global_binding_level
expr_stmt|;
name|t
operator|=
name|pushdecl
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|current_binding_level
operator|=
name|b
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate an implicit declaration for identifier FUNCTIONID    as a function of type int ().  Print a warning if appropriate.  */
end_comment

begin_function
name|tree
name|implicitly_declare
parameter_list|(
name|functionid
parameter_list|)
name|tree
name|functionid
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
name|int
name|traditional_warning
init|=
literal|0
decl_stmt|;
comment|/* Only one "implicit declaration" warning per identifier.  */
name|int
name|implicit_warning
decl_stmt|;
comment|/* Save the decl permanently so we can warn if definition follows.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* We used to reuse an old implicit decl here,      but this loses with inline functions because it can clobber      the saved decl chains.  */
comment|/*  if (IDENTIFIER_IMPLICIT_DECL (functionid) != 0)     decl = IDENTIFIER_IMPLICIT_DECL (functionid);   else  */
name|decl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|functionid
argument_list|,
name|default_function_type
argument_list|)
expr_stmt|;
comment|/* Warn of implicit decl following explicit local extern decl.      This is probably a program designed for traditional C.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|functionid
argument_list|)
operator|&&
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|functionid
argument_list|)
operator|==
literal|0
condition|)
name|traditional_warning
operator|=
literal|1
expr_stmt|;
comment|/* Warn once of an implicit declaration.  */
name|implicit_warning
operator|=
operator|(
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|functionid
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record that we have an implicit decl and this is it.  */
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|functionid
argument_list|)
operator|=
name|decl
expr_stmt|;
comment|/* ANSI standard says implicit declarations are in the innermost block.      So we record the decl in the standard fashion.      If flag_traditional is set, pushdecl does it top-level.  */
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* This is a no-op in c-lang.c or something real in objc-actions.c.  */
name|maybe_objc_check_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_implicit
operator|&&
name|implicit_warning
condition|)
name|warning
argument_list|(
literal|"implicit declaration of function `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|functionid
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_traditional
operator|&&
name|traditional_warning
condition|)
name|warning
argument_list|(
literal|"function `%s' was previously declared within a block"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|functionid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write a record describing this implicit function declaration to the      prototypes file (if requested).  */
name|gen_aux_info_record
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Return zero if the declaration NEWDECL is valid    when the declaration OLDDECL (assumed to be for the same name)    has already been seen.    Otherwise return an error message format string with a %s    where the identifier should go.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|redeclaration_error_message
parameter_list|(
name|newdecl
parameter_list|,
name|olddecl
parameter_list|)
name|tree
name|newdecl
decl_stmt|,
name|olddecl
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
if|if
condition|(
name|flag_traditional
operator|&&
name|TREE_TYPE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|"redefinition of `%s'"
return|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|newdecl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
comment|/* Declarations of functions can insist on internal linkage 	 but they can't be inconsistent with internal linkage, 	 so there can be no error on that account. 	 However defining the same name twice is no good.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
literal|0
comment|/* However, defining once as extern inline and a second 	     time in another way is ok.  */
operator|&&
operator|!
operator|(
name|DECL_INLINE
argument_list|(
name|olddecl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
operator|(
name|DECL_INLINE
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|)
operator|)
condition|)
return|return
literal|"redefinition of `%s'"
return|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
comment|/* Objects declared at top level:  */
comment|/* If at least one is a reference, it's ok.  */
if|if
condition|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|||
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Reject two definitions.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|olddecl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|newdecl
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|"redefinition of `%s'"
return|;
comment|/* Now we have two tentative defs, or one tentative and one real def.  */
comment|/* Insist that the linkage match.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|olddecl
argument_list|)
operator|!=
name|TREE_PUBLIC
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return
literal|"conflicting declarations of `%s'"
return|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|current_binding_level
operator|->
name|parm_flag
operator|&&
name|TREE_ASM_WRITTEN
argument_list|(
name|olddecl
argument_list|)
operator|&&
operator|!
name|TREE_ASM_WRITTEN
argument_list|(
name|newdecl
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
comment|/* Newdecl has block scope.  If olddecl has block scope also, then 	 reject two definitions, and reject a definition together with an 	 external reference.  Otherwise, it is OK, because newdecl must 	 be an extern reference to olddecl.  */
if|if
condition|(
operator|!
operator|(
name|DECL_EXTERNAL
argument_list|(
name|newdecl
argument_list|)
operator|&&
name|DECL_EXTERNAL
argument_list|(
name|olddecl
argument_list|)
operator|)
operator|&&
name|DECL_CONTEXT
argument_list|(
name|newdecl
argument_list|)
operator|==
name|DECL_CONTEXT
argument_list|(
name|olddecl
argument_list|)
condition|)
return|return
literal|"redeclaration of `%s'"
return|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the LABEL_DECL corresponding to identifier ID as a label.    Create one if none exists so far for the current function.    This function is called for both label definitions and label references.  */
end_comment

begin_function
name|tree
name|lookup_label
parameter_list|(
name|id
parameter_list|)
name|tree
name|id
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
init|=
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|current_function_decl
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"label %s referenced outside of any function"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Use a label already defined or ref'd with this name.  */
if|if
condition|(
name|decl
operator|!=
literal|0
condition|)
block|{
comment|/* But not if it is inherited and wasn't declared to be inheritable.  */
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|current_function_decl
operator|&&
operator|!
name|C_DECLARED_LABEL_FLAG
argument_list|(
name|decl
argument_list|)
condition|)
return|return
name|shadow_label
argument_list|(
name|id
argument_list|)
return|;
return|return
name|decl
return|;
block|}
name|decl
operator|=
name|build_decl
argument_list|(
name|LABEL_DECL
argument_list|,
name|id
argument_list|,
name|void_type_node
argument_list|)
expr_stmt|;
comment|/* Make sure every label has an rtx.  */
name|label_rtx
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* A label not explicitly declared must be local to where it's ref'd.  */
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|=
name|current_function_decl
expr_stmt|;
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
operator|=
name|VOIDmode
expr_stmt|;
comment|/* Say where one reference is to the label,      for the sake of the error if it is not defined.  */
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|=
name|lineno
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
operator|=
name|input_filename
expr_stmt|;
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|id
argument_list|)
operator|=
name|decl
expr_stmt|;
name|named_labels
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|named_labels
argument_list|)
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_comment
comment|/* Make a label named NAME in the current function,    shadowing silently any that may be inherited from containing functions    or containing scopes.     Note that valid use, if the label being shadowed    comes from another scope in the same function,    requires calling declare_nonlocal_label right away.  */
end_comment

begin_function
name|tree
name|shadow_label
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
init|=
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl
operator|!=
literal|0
condition|)
block|{
specifier|register
name|tree
name|dup
decl_stmt|;
comment|/* Check to make sure that the label hasn't already been declared 	 at this label scope */
for|for
control|(
name|dup
operator|=
name|named_labels
init|;
name|dup
condition|;
name|dup
operator|=
name|TREE_CHAIN
argument_list|(
name|dup
argument_list|)
control|)
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|dup
argument_list|)
operator|==
name|decl
condition|)
block|{
name|error
argument_list|(
literal|"duplicate label declaration `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|TREE_VALUE
argument_list|(
name|dup
argument_list|)
argument_list|,
literal|"this is a previous declaration"
argument_list|)
expr_stmt|;
comment|/* Just use the previous declaration.  */
return|return
name|lookup_label
argument_list|(
name|name
argument_list|)
return|;
block|}
name|shadowed_labels
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|shadowed_labels
argument_list|)
expr_stmt|;
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
name|decl
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|lookup_label
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Define a label, specifying the location in the source file.    Return the LABEL_DECL node for the label, if the definition is valid.    Otherwise return 0.  */
end_comment

begin_function
name|tree
name|define_label
parameter_list|(
name|filename
parameter_list|,
name|line
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|lookup_label
argument_list|(
name|name
argument_list|)
decl_stmt|;
comment|/* If label with this name is known from an outer context, shadow it.  */
if|if
condition|(
name|decl
operator|!=
literal|0
operator|&&
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
name|current_function_decl
condition|)
block|{
name|shadowed_labels
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|shadowed_labels
argument_list|)
expr_stmt|;
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|name
argument_list|)
operator|=
literal|0
expr_stmt|;
name|decl
operator|=
name|lookup_label
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"duplicate label `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* Mark label as having been defined.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* Say where in the source.  */
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
operator|=
name|filename
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
operator|=
name|line
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the list of declarations of the current level.    Note that this list is in reverse order unless/until    you nreverse it; and when you do nreverse it, you must    store the result back using `storedecls' or you will lose.  */
end_comment

begin_function
name|tree
name|getdecls
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|names
return|;
block|}
end_function

begin_comment
comment|/* Return the list of type-tags (for structs, etc) of the current level.  */
end_comment

begin_function
name|tree
name|gettags
parameter_list|()
block|{
return|return
name|current_binding_level
operator|->
name|tags
return|;
block|}
end_function

begin_comment
comment|/* Store the list of declarations of the current level.    This is done for the parameter declarations of a function being defined,    after they are modified in the light of any missing parameters.  */
end_comment

begin_function
specifier|static
name|void
name|storedecls
parameter_list|(
name|decls
parameter_list|)
name|tree
name|decls
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|names
operator|=
name|decls
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similarly, store the list of tags of the current level.  */
end_comment

begin_function
specifier|static
name|void
name|storetags
parameter_list|(
name|tags
parameter_list|)
name|tree
name|tags
decl_stmt|;
block|{
name|current_binding_level
operator|->
name|tags
operator|=
name|tags
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given NAME, an IDENTIFIER_NODE,    return the structure (or union or enum) definition for that name.    Searches binding levels from BINDING_LEVEL up to the global level.    If THISLEVEL_ONLY is nonzero, searches only the specified context    (but skips any tag-transparent contexts to find one that is    meaningful for tags).    CODE says which kind of type the caller wants;    it is RECORD_TYPE or UNION_TYPE or ENUMERAL_TYPE.    If the wrong kind of type is found, an error is reported.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_tag
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|,
name|binding_level
parameter_list|,
name|thislevel_only
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|binding_level
decl_stmt|;
name|tree
name|name
decl_stmt|;
name|int
name|thislevel_only
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
for|for
control|(
name|level
operator|=
name|binding_level
init|;
name|level
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
specifier|register
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|level
operator|->
name|tags
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
operator|==
name|name
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
argument_list|)
operator|!=
name|code
condition|)
block|{
comment|/* Definition isn't the kind we were looking for.  */
name|pending_invalid_xref
operator|=
name|name
expr_stmt|;
name|pending_invalid_xref_file
operator|=
name|input_filename
expr_stmt|;
name|pending_invalid_xref_line
operator|=
name|lineno
expr_stmt|;
block|}
return|return
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|thislevel_only
operator|&&
operator|!
name|level
operator|->
name|tag_transparent
condition|)
return|return
name|NULL_TREE
return|;
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Print an error message now    for a recent invalid struct, union or enum cross reference.    We don't print them immediately because they are not invalid    when used in the `struct foo;' construct for shadowing.  */
end_comment

begin_function
name|void
name|pending_xref_error
parameter_list|()
block|{
if|if
condition|(
name|pending_invalid_xref
operator|!=
literal|0
condition|)
name|error_with_file_and_line
argument_list|(
name|pending_invalid_xref_file
argument_list|,
name|pending_invalid_xref_line
argument_list|,
literal|"`%s' defined as wrong kind of tag"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|pending_invalid_xref
argument_list|)
argument_list|)
expr_stmt|;
name|pending_invalid_xref
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a type, find the tag that was defined for it and return the tag name.    Otherwise return 0.  */
end_comment

begin_function
specifier|static
name|tree
name|lookup_tag_reverse
parameter_list|(
name|type
parameter_list|)
name|tree
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|binding_level
modifier|*
name|level
decl_stmt|;
for|for
control|(
name|level
operator|=
name|current_binding_level
init|;
name|level
condition|;
name|level
operator|=
name|level
operator|->
name|level_chain
control|)
block|{
specifier|register
name|tree
name|tail
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|level
operator|->
name|tags
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|tail
argument_list|)
operator|==
name|type
condition|)
return|return
name|TREE_PURPOSE
argument_list|(
name|tail
argument_list|)
return|;
block|}
block|}
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look up NAME in the current binding level and its superiors    in the namespace of variables, functions and typedefs.    Return a ..._DECL node of some kind representing its definition,    or return 0 if it is undefined.  */
end_comment

begin_function
name|tree
name|lookup_name
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|val
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
operator|&&
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
condition|)
name|val
operator|=
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Similar to `lookup_name' but look only at current binding level.  */
end_comment

begin_function
name|tree
name|lookup_name_current_level
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|t
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
return|return
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
return|;
if|if
condition|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|t
operator|=
name|current_binding_level
operator|->
name|names
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|name
condition|)
break|break;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Similar to `lookup_name_current_level' but also look at the global binding    level.  */
end_comment

begin_function
name|tree
name|lookup_name_current_level_global
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|t
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
return|return
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
return|;
if|if
condition|(
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
condition|)
for|for
control|(
name|t
operator|=
name|current_binding_level
operator|->
name|names
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|t
argument_list|)
operator|==
name|name
condition|)
break|break;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
name|t
operator|=
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the predefined scalar types of C,    and some nodes representing standard constants (0, 1, (void *)0).    Initialize the global binding level.    Make definitions for built-in primitive functions.  */
end_comment

begin_function
name|void
name|init_decl_processing
parameter_list|()
block|{
specifier|register
name|tree
name|endlink
decl_stmt|;
comment|/* Either char* or void*.  */
name|tree
name|traditional_ptr_type_node
decl_stmt|;
comment|/* Data types of memcpy and strlen.  */
name|tree
name|memcpy_ftype
decl_stmt|,
name|strlen_ftype
decl_stmt|;
name|tree
name|void_ftype_any
decl_stmt|;
name|int
name|wchar_type_size
decl_stmt|;
name|tree
name|temp
decl_stmt|;
name|tree
name|array_domain_type
decl_stmt|;
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
name|named_labels
operator|=
name|NULL
expr_stmt|;
name|current_binding_level
operator|=
name|NULL_BINDING_LEVEL
expr_stmt|;
name|free_binding_level
operator|=
name|NULL_BINDING_LEVEL
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* make the binding_level structure for global names */
name|global_binding_level
operator|=
name|current_binding_level
expr_stmt|;
comment|/* Define `int' and `char' first so that dbx will output them first.  */
name|integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|INT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
argument_list|,
name|integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Define `char', which is like either `signed char' or `unsigned char'      but not the same as either.  */
name|char_type_node
operator|=
operator|(
name|flag_signed_char
condition|?
name|make_signed_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
else|:
name|make_unsigned_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
operator|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"char"
argument_list|)
argument_list|,
name|char_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|long_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"long int"
argument_list|)
argument_list|,
name|long_integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|INT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"unsigned int"
argument_list|)
argument_list|,
name|unsigned_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|long_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"long unsigned int"
argument_list|)
argument_list|,
name|long_unsigned_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|long_long_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|LONG_LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"long long int"
argument_list|)
argument_list|,
name|long_long_integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|long_long_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|LONG_LONG_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"long long unsigned int"
argument_list|)
argument_list|,
name|long_long_unsigned_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* `unsigned long' is the standard type for sizeof.      Traditionally, use a signed type.      Note that stddef.h uses `unsigned long',      and this must agree, even of long and int are the same size.  */
name|sizetype
operator|=
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|get_identifier
argument_list|(
name|SIZE_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_traditional
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|sizetype
argument_list|)
condition|)
name|sizetype
operator|=
name|signed_type
argument_list|(
name|sizetype
argument_list|)
expr_stmt|;
name|ptrdiff_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|get_identifier
argument_list|(
name|PTRDIFF_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|char_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|unsigned_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|long_unsigned_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|long_integer_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|long_long_integer_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|long_long_unsigned_type_node
argument_list|)
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|error_mark_node
operator|=
name|make_node
argument_list|(
name|ERROR_MARK
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|error_mark_node
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|short_integer_type_node
operator|=
name|make_signed_type
argument_list|(
name|SHORT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"short int"
argument_list|)
argument_list|,
name|short_integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|short_unsigned_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|SHORT_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"short unsigned int"
argument_list|)
argument_list|,
name|short_unsigned_type_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Define both `signed char' and `unsigned char'.  */
name|signed_char_type_node
operator|=
name|make_signed_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"signed char"
argument_list|)
argument_list|,
name|signed_char_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_char_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|CHAR_TYPE_SIZE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"unsigned char"
argument_list|)
argument_list|,
name|unsigned_char_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|intQI_type_node
operator|=
name|make_signed_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intQI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|intHI_type_node
operator|=
name|make_signed_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intHI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|intSI_type_node
operator|=
name|make_signed_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intSI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|intDI_type_node
operator|=
name|make_signed_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|DImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|intDI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_intQI_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|QImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intQI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_intHI_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|HImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intHI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_intSI_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|SImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intSI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|unsigned_intDI_type_node
operator|=
name|make_unsigned_type
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|DImode
argument_list|)
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|unsigned_intDI_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|float_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|float_type_node
argument_list|)
operator|=
name|FLOAT_TYPE_SIZE
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_FLOAT
index|]
argument_list|,
name|float_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|float_type_node
argument_list|)
expr_stmt|;
name|double_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_short_double
condition|)
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|=
name|FLOAT_TYPE_SIZE
expr_stmt|;
else|else
name|TYPE_PRECISION
argument_list|(
name|double_type_node
argument_list|)
operator|=
name|DOUBLE_TYPE_SIZE
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_DOUBLE
index|]
argument_list|,
name|double_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|double_type_node
argument_list|)
expr_stmt|;
name|long_double_type_node
operator|=
name|make_node
argument_list|(
name|REAL_TYPE
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|long_double_type_node
argument_list|)
operator|=
name|LONG_DOUBLE_TYPE_SIZE
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"long double"
argument_list|)
argument_list|,
name|long_double_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|long_double_type_node
argument_list|)
expr_stmt|;
name|complex_integer_type_node
operator|=
name|make_node
argument_list|(
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex int"
argument_list|)
argument_list|,
name|complex_integer_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|complex_integer_type_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|layout_type
argument_list|(
name|complex_integer_type_node
argument_list|)
expr_stmt|;
name|complex_float_type_node
operator|=
name|make_node
argument_list|(
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex float"
argument_list|)
argument_list|,
name|complex_float_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|complex_float_type_node
argument_list|)
operator|=
name|float_type_node
expr_stmt|;
name|layout_type
argument_list|(
name|complex_float_type_node
argument_list|)
expr_stmt|;
name|complex_double_type_node
operator|=
name|make_node
argument_list|(
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex double"
argument_list|)
argument_list|,
name|complex_double_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|complex_double_type_node
argument_list|)
operator|=
name|double_type_node
expr_stmt|;
name|layout_type
argument_list|(
name|complex_double_type_node
argument_list|)
expr_stmt|;
name|complex_long_double_type_node
operator|=
name|make_node
argument_list|(
name|COMPLEX_TYPE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|get_identifier
argument_list|(
literal|"complex long double"
argument_list|)
argument_list|,
name|complex_long_double_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|complex_long_double_type_node
argument_list|)
operator|=
name|long_double_type_node
expr_stmt|;
name|layout_type
argument_list|(
name|complex_long_double_type_node
argument_list|)
expr_stmt|;
name|wchar_type_node
operator|=
name|TREE_TYPE
argument_list|(
name|IDENTIFIER_GLOBAL_VALUE
argument_list|(
name|get_identifier
argument_list|(
name|WCHAR_TYPE
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|wchar_type_size
operator|=
name|TYPE_PRECISION
argument_list|(
name|wchar_type_node
argument_list|)
expr_stmt|;
name|signed_wchar_type_node
operator|=
name|signed_type
argument_list|(
name|wchar_type_node
argument_list|)
expr_stmt|;
name|unsigned_wchar_type_node
operator|=
name|unsigned_type
argument_list|(
name|wchar_type_node
argument_list|)
expr_stmt|;
name|integer_zero_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|integer_zero_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|integer_one_node
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|integer_one_node
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|size_zero_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|size_zero_node
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|size_one_node
operator|=
name|build_int_2
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|size_one_node
argument_list|)
operator|=
name|sizetype
expr_stmt|;
name|void_type_node
operator|=
name|make_node
argument_list|(
name|VOID_TYPE
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOID
index|]
argument_list|,
name|void_type_node
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
comment|/* Uses integer_zero_node */
comment|/* We are not going to have real types in C with less than byte alignment,      so we might as well not have any types that claim to have it.  */
name|TYPE_ALIGN
argument_list|(
name|void_type_node
argument_list|)
operator|=
name|BITS_PER_UNIT
expr_stmt|;
name|null_pointer_node
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|null_pointer_node
argument_list|)
argument_list|)
expr_stmt|;
name|string_type_node
operator|=
name|build_pointer_type
argument_list|(
name|char_type_node
argument_list|)
expr_stmt|;
name|const_string_type_node
operator|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|char_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a type to be the domain of a few array types      whose domains don't really matter.      200 is small enough that it always fits in size_t      and large enough that it can hold most function names for the      initializations of __FUNCTION__ and __PRETTY_FUNCTION__.  */
name|array_domain_type
operator|=
name|build_index_type
argument_list|(
name|build_int_2
argument_list|(
literal|200
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* make a type for arrays of characters.      With luck nothing will ever really depend on the length of this      array type.  */
name|char_array_type_node
operator|=
name|build_array_type
argument_list|(
name|char_type_node
argument_list|,
name|array_domain_type
argument_list|)
expr_stmt|;
comment|/* Likewise for arrays of ints.  */
name|int_array_type_node
operator|=
name|build_array_type
argument_list|(
name|integer_type_node
argument_list|,
name|array_domain_type
argument_list|)
expr_stmt|;
comment|/* This is for wide string constants.  */
name|wchar_array_type_node
operator|=
name|build_array_type
argument_list|(
name|wchar_type_node
argument_list|,
name|array_domain_type
argument_list|)
expr_stmt|;
name|default_function_type
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|void_type_node
argument_list|)
expr_stmt|;
name|const_ptr_type_node
operator|=
name|build_pointer_type
argument_list|(
name|build_type_variant
argument_list|(
name|void_type_node
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|endlink
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|void_ftype_any
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|double_ftype_double
operator|=
name|build_function_type
argument_list|(
name|double_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|double_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
expr_stmt|;
name|double_ftype_double_double
operator|=
name|build_function_type
argument_list|(
name|double_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|double_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|double_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|int_ftype_int
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
expr_stmt|;
name|long_ftype_long
operator|=
name|build_function_type
argument_list|(
name|long_integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|long_integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
expr_stmt|;
name|void_ftype_ptr_ptr_int
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|int_ftype_cptr_cptr_sizet
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|void_ftype_ptr_int_int
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|string_ftype_ptr_ptr
comment|/* strcpy prototype */
operator|=
name|build_function_type
argument_list|(
name|string_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|string_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|int_ftype_string_string
comment|/* strcmp prototype */
operator|=
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strlen_ftype
comment|/* strlen prototype */
operator|=
name|build_function_type
argument_list|(
name|flag_traditional
condition|?
name|integer_type_node
else|:
name|sizetype
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_string_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
expr_stmt|;
name|traditional_ptr_type_node
operator|=
operator|(
name|flag_traditional
condition|?
name|string_type_node
else|:
name|ptr_type_node
operator|)
expr_stmt|;
name|memcpy_ftype
comment|/* memcpy prototype */
operator|=
name|build_function_type
argument_list|(
name|traditional_ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|const_ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_constant_p"
argument_list|,
name|int_ftype_int
argument_list|,
name|BUILT_IN_CONSTANT_P
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_return_address"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|unsigned_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|,
name|BUILT_IN_RETURN_ADDRESS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_frame_address"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|unsigned_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|,
name|BUILT_IN_FRAME_ADDRESS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_alloca"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|,
name|BUILT_IN_ALLOCA
argument_list|,
literal|"alloca"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_ffs"
argument_list|,
name|int_ftype_int
argument_list|,
name|BUILT_IN_FFS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Define alloca, ffs as builtins.      Declare _exit just to mark it as volatile.  */
if|if
condition|(
operator|!
name|flag_no_builtin
operator|&&
operator|!
name|flag_no_nonansi_builtin
condition|)
block|{
name|temp
operator|=
name|builtin_function
argument_list|(
literal|"alloca"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|,
name|BUILT_IN_ALLOCA
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Suppress error if redefined as a non-function.  */
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|builtin_function
argument_list|(
literal|"ffs"
argument_list|,
name|int_ftype_int
argument_list|,
name|BUILT_IN_FFS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Suppress error if redefined as a non-function.  */
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|builtin_function
argument_list|(
literal|"_exit"
argument_list|,
name|void_ftype_any
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Suppress error if redefined as a non-function.  */
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|builtin_function
argument_list|(
literal|"__builtin_abs"
argument_list|,
name|int_ftype_int
argument_list|,
name|BUILT_IN_ABS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_fabs"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_FABS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_labs"
argument_list|,
name|long_ftype_long
argument_list|,
name|BUILT_IN_LABS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_saveregs"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|BUILT_IN_SAVEREGS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* EXPAND_BUILTIN_VARARGS is obsolete.  */
if|#
directive|if
literal|0
block|builtin_function ("__builtin_varargs", 		    build_function_type (ptr_type_node, 					 tree_cons (NULL_TREE, 						    integer_type_node, 						    endlink)), 		    BUILT_IN_VARARGS, NULL_PTR);
endif|#
directive|endif
name|builtin_function
argument_list|(
literal|"__builtin_classify_type"
argument_list|,
name|default_function_type
argument_list|,
name|BUILT_IN_CLASSIFY_TYPE
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_next_arg"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|BUILT_IN_NEXT_ARG
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_args_info"
argument_list|,
name|build_function_type
argument_list|(
name|integer_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|integer_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|,
name|BUILT_IN_ARGS_INFO
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Untyped call and return.  */
name|builtin_function
argument_list|(
literal|"__builtin_apply_args"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|,
name|BUILT_IN_APPLY_ARGS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|temp
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|build_pointer_type
argument_list|(
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|sizetype
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_apply"
argument_list|,
name|build_function_type
argument_list|(
name|ptr_type_node
argument_list|,
name|temp
argument_list|)
argument_list|,
name|BUILT_IN_APPLY
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_return"
argument_list|,
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|ptr_type_node
argument_list|,
name|endlink
argument_list|)
argument_list|)
argument_list|,
name|BUILT_IN_RETURN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Currently under experimentation.  */
name|builtin_function
argument_list|(
literal|"__builtin_memcpy"
argument_list|,
name|memcpy_ftype
argument_list|,
name|BUILT_IN_MEMCPY
argument_list|,
literal|"memcpy"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_memcmp"
argument_list|,
name|int_ftype_cptr_cptr_sizet
argument_list|,
name|BUILT_IN_MEMCMP
argument_list|,
literal|"memcmp"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_strcmp"
argument_list|,
name|int_ftype_string_string
argument_list|,
name|BUILT_IN_STRCMP
argument_list|,
literal|"strcmp"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_strcpy"
argument_list|,
name|string_ftype_ptr_ptr
argument_list|,
name|BUILT_IN_STRCPY
argument_list|,
literal|"strcpy"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_strlen"
argument_list|,
name|strlen_ftype
argument_list|,
name|BUILT_IN_STRLEN
argument_list|,
literal|"strlen"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_fsqrt"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_FSQRT
argument_list|,
literal|"sqrt"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_sin"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_SIN
argument_list|,
literal|"sin"
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"__builtin_cos"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_COS
argument_list|,
literal|"cos"
argument_list|)
expr_stmt|;
comment|/* In an ANSI C program, it is okay to supply built-in meanings      for these functions, since applications cannot validly use them      with any other meaning.      However, honor the -fno-builtin option.  */
if|if
condition|(
operator|!
name|flag_no_builtin
condition|)
block|{
name|builtin_function
argument_list|(
literal|"abs"
argument_list|,
name|int_ftype_int
argument_list|,
name|BUILT_IN_ABS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"fabs"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_FABS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"labs"
argument_list|,
name|long_ftype_long
argument_list|,
name|BUILT_IN_LABS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"memcpy"
argument_list|,
name|memcpy_ftype
argument_list|,
name|BUILT_IN_MEMCPY
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"memcmp"
argument_list|,
name|int_ftype_cptr_cptr_sizet
argument_list|,
name|BUILT_IN_MEMCMP
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"strcmp"
argument_list|,
name|int_ftype_string_string
argument_list|,
name|BUILT_IN_STRCMP
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"strcpy"
argument_list|,
name|string_ftype_ptr_ptr
argument_list|,
name|BUILT_IN_STRCPY
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"strlen"
argument_list|,
name|strlen_ftype
argument_list|,
name|BUILT_IN_STRLEN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"sqrt"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_FSQRT
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"sin"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_SIN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|builtin_function
argument_list|(
literal|"cos"
argument_list|,
name|double_ftype_double
argument_list|,
name|BUILT_IN_COS
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
comment|/* Declare these functions volatile 	 to avoid spurious "control drops through" warnings.  */
comment|/* Don't specify the argument types, to avoid errors 	 from certain code which isn't valid in ANSI but which exists.  */
name|temp
operator|=
name|builtin_function
argument_list|(
literal|"abort"
argument_list|,
name|void_ftype_any
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|builtin_function
argument_list|(
literal|"exit"
argument_list|,
name|void_ftype_any
argument_list|,
name|NOT_BUILT_IN
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_SIDE_EFFECTS
argument_list|(
name|temp
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Support for these has not been written in either expand_builtin      or build_function_call.  */
block|builtin_function ("__builtin_div", default_ftype, BUILT_IN_DIV, NULL_PTR);   builtin_function ("__builtin_ldiv", default_ftype, BUILT_IN_LDIV, NULL_PTR);   builtin_function ("__builtin_ffloor", double_ftype_double, BUILT_IN_FFLOOR, 		    NULL_PTR);   builtin_function ("__builtin_fceil", double_ftype_double, BUILT_IN_FCEIL, 		    NULL_PTR);   builtin_function ("__builtin_fmod", double_ftype_double_double, 		    BUILT_IN_FMOD, NULL_PTR);   builtin_function ("__builtin_frem", double_ftype_double_double, 		    BUILT_IN_FREM, NULL_PTR);   builtin_function ("__builtin_memset", ptr_ftype_ptr_int_int, 		    BUILT_IN_MEMSET, NULL_PTR);   builtin_function ("__builtin_getexp", double_ftype_double, BUILT_IN_GETEXP, 		    NULL_PTR);   builtin_function ("__builtin_getman", double_ftype_double, BUILT_IN_GETMAN, 		    NULL_PTR);
endif|#
directive|endif
comment|/* Create the global bindings for __FUNCTION__ and __PRETTY_FUNCTION__.  */
name|declare_function_name
argument_list|()
expr_stmt|;
name|start_identifier_warnings
argument_list|()
expr_stmt|;
comment|/* Prepare to check format strings against argument lists.  */
name|init_function_format_info
argument_list|()
expr_stmt|;
name|init_iterators
argument_list|()
expr_stmt|;
name|incomplete_decl_finalize_hook
operator|=
name|finish_incomplete_decl
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a definition for a builtin function named NAME and whose data type    is TYPE.  TYPE should be a function type with argument types.    FUNCTION_CODE tells later passes how to compile calls to this function.    See tree.h for its possible values.     If LIBRARY_NAME is nonzero, use that for DECL_ASSEMBLER_NAME,    the name to be called if we can't opencode the function.  */
end_comment

begin_function
name|tree
name|builtin_function
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|,
name|function_code
parameter_list|,
name|library_name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|enum
name|built_in_function
name|function_code
decl_stmt|;
name|char
modifier|*
name|library_name
decl_stmt|;
block|{
name|tree
name|decl
init|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|get_identifier
argument_list|(
name|name
argument_list|)
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* If -traditional, permit redefining a builtin function any way you like.      (Though really, if the program redefines these functions,      it probably won't work right unless compiled with -fno-builtin.)  */
if|if
condition|(
name|flag_traditional
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
condition|)
name|DECL_BUILT_IN_NONANSI
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|library_name
condition|)
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|get_identifier
argument_list|(
name|library_name
argument_list|)
expr_stmt|;
name|make_decl_rtl
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|function_code
operator|!=
name|NOT_BUILT_IN
condition|)
block|{
name|DECL_BUILT_IN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_FUNCTION_CODE
argument_list|(
name|decl
argument_list|)
operator|=
name|function_code
expr_stmt|;
block|}
comment|/* Warn if a function in the namespace for users      is used without an occasion to consider it declared.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'_'
operator|||
name|name
index|[
literal|1
index|]
operator|!=
literal|'_'
condition|)
name|C_DECL_ANTICIPATED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|decl
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Called when a declaration is seen that contains no names to declare.    If its type is a reference to a structure, union or enum inherited    from a containing scope, shadow that tag name for the current scope    with a forward reference.    If its type defines a new named structure or union    or defines an enum, it is valid but we need not do anything here.    Otherwise, it is an error.  */
end_comment

begin_function
name|void
name|shadow_tag
parameter_list|(
name|declspecs
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
block|{
name|shadow_tag_warned
argument_list|(
name|declspecs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|shadow_tag_warned
parameter_list|(
name|declspecs
parameter_list|,
name|warned
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
name|int
name|warned
decl_stmt|;
comment|/* 1 => we have done a pedwarn.  2 => we have done a warning, but 	no pedwarn.  */
block|{
name|int
name|found_tag
init|=
literal|0
decl_stmt|;
specifier|register
name|tree
name|link
decl_stmt|;
name|pending_invalid_xref
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|link
operator|=
name|declspecs
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
block|{
specifier|register
name|tree
name|value
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|RECORD_TYPE
operator|||
name|code
operator|==
name|UNION_TYPE
operator|||
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
comment|/* Used to test also that TYPE_SIZE (value) != 0. 	   That caused warning for `struct foo;' at top level in the file.  */
block|{
specifier|register
name|tree
name|name
init|=
name|lookup_tag_reverse
argument_list|(
name|value
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|t
decl_stmt|;
name|found_tag
operator|++
expr_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|warned
operator|!=
literal|1
operator|&&
name|code
operator|!=
name|ENUMERAL_TYPE
condition|)
comment|/* Empty unnamed enum OK */
block|{
name|pedwarn
argument_list|(
literal|"unnamed struct/union that defines no instances"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|t
operator|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|current_binding_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|warned
condition|)
block|{
name|warning
argument_list|(
literal|"useless keyword or type name in empty declaration"
argument_list|)
expr_stmt|;
name|warned
operator|=
literal|2
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|found_tag
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"two types specified in one empty declaration"
argument_list|)
expr_stmt|;
if|if
condition|(
name|warned
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|found_tag
operator|==
literal|0
condition|)
name|pedwarn
argument_list|(
literal|"empty declaration"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode a "typename", such as "int **", returning a ..._TYPE node.  */
end_comment

begin_function
name|tree
name|groktypename
parameter_list|(
name|typename
parameter_list|)
name|tree
name|typename
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|typename
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
name|typename
return|;
return|return
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|typename
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|typename
argument_list|)
argument_list|,
name|TYPENAME
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a PARM_DECL node for a given pair of specs and declarator.  */
end_comment

begin_function
name|tree
name|groktypename_in_parm_context
parameter_list|(
name|typename
parameter_list|)
name|tree
name|typename
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|typename
argument_list|)
operator|!=
name|TREE_LIST
condition|)
return|return
name|typename
return|;
return|return
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|typename
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|typename
argument_list|)
argument_list|,
name|PARM
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Decode a declarator in an ordinary declaration or data definition.    This is called as soon as the type information and variable name    have been parsed, before parsing the initializer if any.    Here we create the ..._DECL node, fill in its type,    and put it on the list of decls for the current context.    The ..._DECL node is returned as the value.     Exception: for arrays where the length is not specified,    the type is left null, to be filled in by `finish_decl'.     Function definitions do not come here; they go to start_function    instead.  However, external and forward declarations of functions    do go through here.  Structure field declarations are done by    grokfield and not through here.  */
end_comment

begin_comment
comment|/* Set this to zero to debug not using the temporary obstack    to parse initializers.  */
end_comment

begin_decl_stmt
name|int
name|debug_temp_inits
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|tree
name|start_decl
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|initialized
parameter_list|)
name|tree
name|declarator
decl_stmt|,
name|declspecs
decl_stmt|;
name|int
name|initialized
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
init|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|NORMAL
argument_list|,
name|initialized
argument_list|)
decl_stmt|;
specifier|register
name|tree
name|tem
decl_stmt|;
name|int
name|init_written
init|=
name|initialized
decl_stmt|;
comment|/* The corresponding pop_obstacks is in finish_decl.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
if|if
condition|(
name|initialized
condition|)
comment|/* Is it valid for this decl to have an initializer at all?        If not, set INITIALIZED to zero, which will indirectly        tell `finish_decl' to ignore the initializer once it is parsed.  */
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|TYPE_DECL
case|:
comment|/* typedef foo = bar  means give foo the same type as bar. 	   We haven't parsed bar yet, so `finish_decl' will fix that up. 	   Any other case of an initialization in a TYPE_DECL is an error.  */
if|if
condition|(
name|pedantic
operator|||
name|list_length
argument_list|(
name|declspecs
argument_list|)
operator|>
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"typedef `%s' is initialized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|FUNCTION_DECL
case|:
name|error
argument_list|(
literal|"function `%s' is initialized like a variable"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PARM_DECL
case|:
comment|/* DECL_INITIAL in a PARM_DECL is really DECL_ARG_TYPE.  */
name|error
argument_list|(
literal|"parameter `%s' is initialized"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* Don't allow initializations for incomplete types 	   except for arrays which might be completed by the initialization.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* A complete type is ok if size is fixed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|C_DECL_VARIABLE_SIZE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"variable-sized object may not be initialized"
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"variable `%s' has initializer but incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"elements of array `%s' have incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|initialized
condition|)
block|{
if|#
directive|if
literal|0
comment|/* Seems redundant with grokdeclarator.  */
block|if (current_binding_level != global_binding_level&& DECL_EXTERNAL (decl)&& TREE_CODE (decl) != FUNCTION_DECL) 	warning ("declaration of `%s' has `extern' and is initialized", 		 IDENTIFIER_POINTER (DECL_NAME (decl)));
endif|#
directive|endif
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Tell `pushdecl' this is an initialized decl 	 even though we don't yet have the initializer expression. 	 Also tell `finish_decl' it may store the real initializer.  */
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* If this is a function declaration, write a record describing it to the      prototypes file (if requested).  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|gen_aux_info_record
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* Add this decl to the current binding level.      TEM may equal DECL or it may be a previous decl of the same name.  */
name|tem
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* For C and Obective-C, we by default put things in .common when      possible.  */
name|DECL_COMMON
argument_list|(
name|tem
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* For a local variable, define the RTL now.  */
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
comment|/* But not if this is a duplicate decl 	 and we preserved the rtl from the previous one 	 (which may or may not happen).  */
operator|&&
name|DECL_RTL
argument_list|(
name|tem
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|expand_decl
argument_list|(
name|tem
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|tem
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|DECL_INITIAL
argument_list|(
name|tem
argument_list|)
operator|!=
literal|0
condition|)
name|expand_decl
argument_list|(
name|tem
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init_written
condition|)
block|{
comment|/* When parsing and digesting the initializer, 	 use temporary storage.  Do this even if we will ignore the value.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
operator|&&
name|debug_temp_inits
condition|)
name|temporary_allocation
argument_list|()
expr_stmt|;
block|}
return|return
name|tem
return|;
block|}
end_function

begin_comment
comment|/* Finish processing of a declaration;    install its initial value.    If the length of an array type is not known before,    it must be determined now, from the initial value, or it is an error.  */
end_comment

begin_function
name|void
name|finish_decl
parameter_list|(
name|decl
parameter_list|,
name|init
parameter_list|,
name|asmspec_tree
parameter_list|)
name|tree
name|decl
decl_stmt|,
name|init
decl_stmt|;
name|tree
name|asmspec_tree
decl_stmt|;
block|{
specifier|register
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|was_incomplete
init|=
operator|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
name|int
name|temporary
init|=
name|allocation_temporary_p
argument_list|()
decl_stmt|;
name|char
modifier|*
name|asmspec
init|=
literal|0
decl_stmt|;
comment|/* If a name was specified, get the string.   */
if|if
condition|(
name|asmspec_tree
condition|)
name|asmspec
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|asmspec_tree
argument_list|)
expr_stmt|;
comment|/* If `start_decl' didn't like having an initialization, ignore it now.  */
if|if
condition|(
name|init
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|init
operator|=
literal|0
expr_stmt|;
comment|/* Don't crash if parm is initialized.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
name|init
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ITERATOR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
name|init
operator|==
literal|0
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"iterator has no initial value"
argument_list|)
expr_stmt|;
else|else
name|init
operator|=
name|save_expr
argument_list|(
name|init
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
name|store_init_value
argument_list|(
name|decl
argument_list|,
name|init
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* typedef foo = bar; store the type of bar as the type of foo.  */
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|init
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|init
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Pop back to the obstack that is current for this binding level.      This is because MAXINDEX, rtl, etc. to be made below      must go in the permanent obstack.  But don't discard the      temporary data yet.  */
name|pop_obstacks
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* pop_obstacks was near the end; this is what was here.  */
block|if (current_binding_level == global_binding_level&& temporary)     end_temporary_allocation ();
endif|#
directive|endif
comment|/* Deduce size of array from initialization, if not already known */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|int
name|do_default
init|=
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
comment|/* Even if pedantic, an external linkage array 	      may have incomplete type at first.  */
condition|?
name|pedantic
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
else|:
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
decl_stmt|;
name|int
name|failure
init|=
name|complete_array_type
argument_list|(
name|type
argument_list|,
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|do_default
argument_list|)
decl_stmt|;
comment|/* Get the completed type made by complete_array_type.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|failure
operator|==
literal|1
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"initializer fails to determine size of `%s'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|failure
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|do_default
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"array size missing in `%s'"
argument_list|)
expr_stmt|;
comment|/* If a `static' var's size isn't known, 	     make it extern as well as static, so it does not get 	     allocated. 	     If it is not `static', then do not mark extern; 	     finish_incomplete_decl will give it a default size 	     and it will get allocated.  */
elseif|else
if|if
condition|(
operator|!
name|pedantic
operator|&&
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* TYPE_MAX_VALUE is always one less than the number of elements 	 in the array, because we start counting at zero.  Therefore, 	 warn only if the value is less than zero.  */
if|if
condition|(
name|pedantic
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
operator|&&
name|tree_int_cst_sgn
argument_list|(
name|TYPE_MAX_VALUE
argument_list|(
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"zero or negative size array `%s'"
argument_list|)
expr_stmt|;
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
condition|)
block|{
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
condition|?
comment|/* A static variable with an incomplete type 		   is an error if it is initialized. 		   Also if it is not file scope. 		   Otherwise, let it through, but if it is not `extern' 		   then it may cause an error message later.  */
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|||
name|current_binding_level
operator|!=
name|global_binding_level
operator|)
else|:
comment|/* An automatic variable with an incomplete type 		   is an error.  */
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"storage size of `%s' isn't known"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|||
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|constant_expression_warning
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"storage size of `%s' isn't constant"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this is a function and an assembler name is specified, it isn't      builtin any more.  Also reset DECL_RTL so we can give it its new      name.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|asmspec
condition|)
block|{
name|DECL_BUILT_IN
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Output the assembler code and/or RTL code for variables and functions,      unless the type is an undefined structure or union.      If not, it will get done when the type is completed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
block|{
if|if
condition|(
operator|(
name|flag_traditional
operator|||
name|TREE_PERMANENT
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|allocation_temporary_p
argument_list|()
condition|)
block|{
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* This is a no-op in c-lang.c or something real in objc-actions.c.  */
name|maybe_objc_check_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|current_binding_level
operator|==
name|global_binding_level
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a no-op in c-lang.c or something real in objc-actions.c.  */
name|maybe_objc_check_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|asmspec
argument_list|,
name|current_binding_level
operator|==
name|global_binding_level
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
condition|)
block|{
comment|/* Recompute the RTL of a local array now 	     if it used to be an incomplete type.  */
if|if
condition|(
name|was_incomplete
operator|&&
operator|!
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
comment|/* If we used it already as memory, it must stay in memory.  */
name|TREE_ADDRESSABLE
argument_list|(
name|decl
argument_list|)
operator|=
name|TREE_USED
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* If it's still incomplete now, no init will save it.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Compute and store the initial value.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|expand_decl_init
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
comment|/* This is a no-op in c-lang.c or something real in objc-actions.c.  */
name|maybe_objc_check_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
name|current_binding_level
operator|==
name|global_binding_level
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* ??? After 2.3, test (init != 0) instead of TREE_CODE.  */
comment|/* This test used to include TREE_PERMANENT, however, we have the same      problem with initializers at the function level.  Such initializers get      saved until the end of the function on the momentary_obstack.  */
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|)
operator|&&
name|temporary
comment|/* DECL_INITIAL is not defined in PARM_DECLs, since it shares 	 space with DECL_ARG_TYPE.  */
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
condition|)
block|{
comment|/* We need to remember that this array HAD an initialization, 	 but discard the actual temporary nodes, 	 since we can't have a permanent node keep pointing to them.  */
comment|/* We make an exception for inline functions, since it's 	 normal for a local extern redeclaration of an inline function 	 to have a copy of the top-level decl's DECL_INLINE.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* If this is a const variable, then preserve the 	     initializer instead of discarding it so that we can optimize 	     references to it.  */
comment|/* This test used to include TREE_STATIC, but this won't be set 	     for function level initializers.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|||
name|ITERATOR_P
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|preserve_initializer
argument_list|()
expr_stmt|;
comment|/* Hack?  Set the permanent bit for something that is permanent, 		 but not on the permenent obstack, so as to convince 		 output_constant_def to make its rtl on the permanent 		 obstack.  */
name|TREE_PERMANENT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* The initializer and DECL must have the same (or equivalent 		 types), but if the initializer is a STRING_CST, its type 		 might not be on the right obstack, so copy the type 		 of DECL.  */
name|TREE_TYPE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
else|else
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
comment|/* If requested, warn about definitions of large data objects.  */
if|if
condition|(
name|warn_larger_than
operator|&&
operator|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
operator|)
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|decl_size
init|=
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|decl_size
operator|&&
name|TREE_CODE
argument_list|(
name|decl_size
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|unsigned
name|units
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|decl_size
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
if|if
condition|(
name|units
operator|>
name|larger_than_size
condition|)
name|warning_with_decl
argument_list|(
name|decl
argument_list|,
literal|"size of `%s' is %u bytes"
argument_list|,
name|units
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* Resume permanent allocation, if not within a function.  */
comment|/* The corresponding push_obstacks_nochange is in start_decl,      and in push_parm_decl and in grokfield.  */
block|pop_obstacks ();
endif|#
directive|endif
comment|/* If we have gone back from temporary to permanent allocation,      actually free the temporary space that we no longer need.  */
if|if
condition|(
name|temporary
operator|&&
operator|!
name|allocation_temporary_p
argument_list|()
condition|)
name|permanent_allocation
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* At the end of a declaration, throw away any variable type sizes      of types defined inside that declaration.  There is no use      computing them in the following function definition.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|get_pending_sizes
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If DECL has a cleanup, build and return that cleanup here.    This is a callback called by expand_expr.  */
end_comment

begin_function
name|tree
name|maybe_build_cleanup
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
comment|/* There are no cleanups in C.  */
return|return
name|NULL_TREE
return|;
block|}
end_function

begin_comment
comment|/* Given a parsed parameter declaration,    decode it into a PARM_DECL and push that on the current binding level.    Also, for the sake of forward parm decls,    record the given order of parms in `parm_order'.  */
end_comment

begin_function
name|void
name|push_parm_decl
parameter_list|(
name|parm
parameter_list|)
name|tree
name|parm
decl_stmt|;
block|{
name|tree
name|decl
decl_stmt|;
name|int
name|old_immediate_size_expand
init|=
name|immediate_size_expand
decl_stmt|;
comment|/* Don't try computing parm sizes now -- wait till fn is called.  */
name|immediate_size_expand
operator|=
literal|0
expr_stmt|;
comment|/* The corresponding pop_obstacks is in finish_decl.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|decl
operator|=
name|grokdeclarator
argument_list|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|PARM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (DECL_NAME (decl))     {       tree olddecl;       olddecl = lookup_name (DECL_NAME (decl));       if (pedantic&& olddecl != 0&& TREE_CODE (olddecl) == TYPE_DECL) 	pedwarn_with_decl (decl, "ANSI C forbids parameter `%s' shadowing typedef");     }
endif|#
directive|endif
name|decl
operator|=
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|immediate_size_expand
operator|=
name|old_immediate_size_expand
expr_stmt|;
name|current_binding_level
operator|->
name|parm_order
operator|=
name|tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|decl
argument_list|,
name|current_binding_level
operator|->
name|parm_order
argument_list|)
expr_stmt|;
comment|/* Add this decl to the current binding level.  */
name|finish_decl
argument_list|(
name|decl
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear the given order of parms in `parm_order'.    Used at start of parm list,    and also at semicolon terminating forward decls.  */
end_comment

begin_function
name|void
name|clear_parm_order
parameter_list|()
block|{
name|current_binding_level
operator|->
name|parm_order
operator|=
name|NULL_TREE
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make TYPE a complete type based on INITIAL_VALUE.    Return 0 if successful, 1 if INITIAL_VALUE can't be deciphered,    2 if there was no information (in which case assume 1 if DO_DEFAULT).  */
end_comment

begin_function
name|int
name|complete_array_type
parameter_list|(
name|type
parameter_list|,
name|initial_value
parameter_list|,
name|do_default
parameter_list|)
name|tree
name|type
decl_stmt|;
name|tree
name|initial_value
decl_stmt|;
name|int
name|do_default
decl_stmt|;
block|{
specifier|register
name|tree
name|maxindex
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|value
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|initial_value
condition|)
block|{
comment|/* Note MAXINDEX  is really the maximum index, 	 one less than the size.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|int
name|eltsize
init|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|initial_value
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|maxindex
operator|=
name|build_int_2
argument_list|(
operator|(
name|TREE_STRING_LENGTH
argument_list|(
name|initial_value
argument_list|)
operator|/
name|eltsize
operator|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|initial_value
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|tree
name|elts
init|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|initial_value
argument_list|)
decl_stmt|;
name|maxindex
operator|=
name|size_binop
argument_list|(
name|MINUS_EXPR
argument_list|,
name|integer_zero_node
argument_list|,
name|size_one_node
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|elts
condition|;
name|elts
operator|=
name|TREE_CHAIN
argument_list|(
name|elts
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|elts
argument_list|)
condition|)
name|maxindex
operator|=
name|TREE_PURPOSE
argument_list|(
name|elts
argument_list|)
expr_stmt|;
else|else
name|maxindex
operator|=
name|size_binop
argument_list|(
name|PLUS_EXPR
argument_list|,
name|maxindex
argument_list|,
name|size_one_node
argument_list|)
expr_stmt|;
block|}
name|maxindex
operator|=
name|copy_node
argument_list|(
name|maxindex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Make an error message unless that happened already.  */
if|if
condition|(
name|initial_value
operator|!=
name|error_mark_node
condition|)
name|value
operator|=
literal|1
expr_stmt|;
comment|/* Prevent further error messages.  */
name|maxindex
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|maxindex
condition|)
block|{
if|if
condition|(
name|do_default
condition|)
name|maxindex
operator|=
name|build_int_2
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|maxindex
condition|)
block|{
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|=
name|build_index_type
argument_list|(
name|maxindex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TREE_TYPE
argument_list|(
name|maxindex
argument_list|)
condition|)
name|TREE_TYPE
argument_list|(
name|maxindex
argument_list|)
operator|=
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* I took out this change 	 together with the change in build_array_type. --rms  */
block|change_main_variant (type, 			   build_array_type (TREE_TYPE (type), 					     TYPE_DOMAIN (type)));
endif|#
directive|endif
block|}
comment|/* Lay out the type now that we can get the real answer.  */
name|layout_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given declspecs and a declarator,    determine the name and type of the object declared    and construct a ..._DECL node for it.    (In one case we can return a ..._TYPE node instead.     For invalid input we sometimes return 0.)     DECLSPECS is a chain of tree_list nodes whose value fields     are the storage classes and type specifiers.     DECL_CONTEXT says which syntactic context this declaration is in:      NORMAL for most contexts.  Make a VAR_DECL or FUNCTION_DECL or TYPE_DECL.      FUNCDEF for a function definition.  Like NORMAL but a few different       error messages in each case.  Return value may be zero meaning       this definition is too screwy to try to parse.      PARM for a parameter declaration (either within a function prototype       or before a function body).  Make a PARM_DECL, or return void_type_node.      TYPENAME if for a typename (in a cast or sizeof).       Don't make a DECL node; just return the ..._TYPE node.      FIELD for a struct or union field; make a FIELD_DECL.      BITFIELD for a field with specified width.    INITIALIZED is 1 if the decl has an initializer.     In the TYPENAME case, DECLARATOR is really an absolute declarator.    It may also be so in the PARM case, for a prototype where the    argument type is specified but not the name.     This function is where the complicated C meanings of `static'    and `extern' are interpreted.  */
end_comment

begin_function
specifier|static
name|tree
name|grokdeclarator
parameter_list|(
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|decl_context
parameter_list|,
name|initialized
parameter_list|)
name|tree
name|declspecs
decl_stmt|;
name|tree
name|declarator
decl_stmt|;
name|enum
name|decl_context
name|decl_context
decl_stmt|;
name|int
name|initialized
decl_stmt|;
block|{
name|int
name|specbits
init|=
literal|0
decl_stmt|;
name|tree
name|spec
decl_stmt|;
name|tree
name|type
init|=
name|NULL_TREE
decl_stmt|;
name|int
name|longlong
init|=
literal|0
decl_stmt|;
name|int
name|constp
decl_stmt|;
name|int
name|volatilep
decl_stmt|;
name|int
name|inlinep
decl_stmt|;
name|int
name|explicit_int
init|=
literal|0
decl_stmt|;
name|int
name|explicit_char
init|=
literal|0
decl_stmt|;
name|int
name|defaulted_int
init|=
literal|0
decl_stmt|;
name|tree
name|typedef_decl
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|tree
name|typedef_type
init|=
literal|0
decl_stmt|;
name|int
name|funcdef_flag
init|=
literal|0
decl_stmt|;
name|enum
name|tree_code
name|innermost_code
init|=
name|ERROR_MARK
decl_stmt|;
name|int
name|bitfield
init|=
literal|0
decl_stmt|;
name|int
name|size_varies
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|BITFIELD
condition|)
name|bitfield
operator|=
literal|1
operator|,
name|decl_context
operator|=
name|FIELD
expr_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|FUNCDEF
condition|)
name|funcdef_flag
operator|=
literal|1
operator|,
name|decl_context
operator|=
name|NORMAL
expr_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag_traditional
operator|&&
name|allocation_temporary_p
argument_list|()
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* Look inside a declarator for the name being declared      and get it as a string, for an error message.  */
block|{
specifier|register
name|tree
name|decl
init|=
name|declarator
decl_stmt|;
name|name
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|decl
condition|)
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
case|case
name|ARRAY_REF
case|:
case|case
name|INDIRECT_REF
case|:
case|case
name|CALL_EXPR
case|:
name|innermost_code
operator|=
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
name|TREE_OPERAND
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IDENTIFIER_NODE
case|:
name|name
operator|=
name|IDENTIFIER_POINTER
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|decl
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|name
operator|=
literal|"type name"
expr_stmt|;
block|}
comment|/* A function definition's declarator must have the form of      a function declarator.  */
if|if
condition|(
name|funcdef_flag
operator|&&
name|innermost_code
operator|!=
name|CALL_EXPR
condition|)
return|return
literal|0
return|;
comment|/* Anything declared one level down from the top level      must be one of the parameters of a function      (because the body is at least two levels down).  */
comment|/* If this looks like a function definition, make it one,      even if it occurs where parms are expected.      Then store_parm_decls will reject it and not use it as a parm.  */
if|if
condition|(
name|decl_context
operator|==
name|NORMAL
operator|&&
operator|!
name|funcdef_flag
operator|&&
name|current_binding_level
operator|->
name|level_chain
operator|==
name|global_binding_level
condition|)
name|decl_context
operator|=
name|PARM
expr_stmt|;
comment|/* Look through the decl specs and record which ones appear.      Some typespecs are defined as built-in typenames.      Others, the ones that are modifiers of other types,      are represented by bits in SPECBITS: set the bits for      the modifiers that appear.  Storage class keywords are also in SPECBITS.       If there is a typedef name or a type, store the type in TYPE.      This includes builtin typedefs such as `int'.       Set EXPLICIT_INT or EXPLICIT_CHAR if the type is `int' or `char'      and did not come from a user typedef.       Set LONGLONG if `long' is mentioned twice.  */
for|for
control|(
name|spec
operator|=
name|declspecs
init|;
name|spec
condition|;
name|spec
operator|=
name|TREE_CHAIN
argument_list|(
name|spec
argument_list|)
control|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|tree
name|id
init|=
name|TREE_VALUE
argument_list|(
name|spec
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_INT
index|]
condition|)
name|explicit_int
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CHAR
index|]
condition|)
name|explicit_char
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|RID_FIRST_MODIFIER
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|RID_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ridpointers
index|[
name|i
index|]
operator|==
name|id
condition|)
block|{
if|if
condition|(
name|i
operator|==
operator|(
name|int
operator|)
name|RID_LONG
operator|&&
name|specbits
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|longlong
condition|)
name|error
argument_list|(
literal|"`long long long' is too long for GCC"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|in_system_header
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C does not support `long long'"
argument_list|)
expr_stmt|;
name|longlong
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|specbits
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
if|if
condition|(
name|type
condition|)
name|error
argument_list|(
literal|"two or more data types in declaration of `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Actual typedefs come to us as TYPE_DECL nodes.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|TYPE_DECL
condition|)
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|typedef_decl
operator|=
name|id
expr_stmt|;
block|}
comment|/* Built-in types come as identifiers.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
specifier|register
name|tree
name|t
init|=
name|lookup_name
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|error_mark_node
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|!
name|t
operator|||
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
name|error
argument_list|(
literal|"`%s' fails to be a typedef or built in type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|typedef_decl
operator|=
name|t
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|id
argument_list|)
operator|!=
name|ERROR_MARK
condition|)
name|type
operator|=
name|id
expr_stmt|;
name|found
label|:
block|{}
block|}
name|typedef_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|type
condition|)
name|size_varies
operator|=
name|C_TYPE_VARIABLE_SIZE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* No type at all: default to `int', and set DEFAULTED_INT      because it was not a user-defined typedef.  */
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|funcdef_flag
operator|&&
name|warn_return_type
operator|&&
operator|!
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|)
operator|)
operator|)
condition|)
name|warn_about_return_type
operator|=
literal|1
expr_stmt|;
name|defaulted_int
operator|=
literal|1
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Now process the modifiers that were specified      and check for invalid combinations.  */
comment|/* Long double is a special combination.  */
if|if
condition|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|double_type_node
condition|)
block|{
name|specbits
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
expr_stmt|;
name|type
operator|=
name|long_double_type_node
expr_stmt|;
block|}
comment|/* Check all other uses of type modifiers.  */
if|if
condition|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|)
condition|)
block|{
name|int
name|ok
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
name|error
argument_list|(
literal|"long, short, signed or unsigned invalid for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator|&&
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
condition|)
name|error
argument_list|(
literal|"long and short specified together for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator|||
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator|)
operator|&&
name|explicit_char
condition|)
name|error
argument_list|(
literal|"long or short specified with char for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator|||
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|REAL_TYPE
condition|)
name|error
argument_list|(
literal|"long or short specified with floating type for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|&&
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|)
condition|)
name|error
argument_list|(
literal|"signed and unsigned given together for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|explicit_int
operator|&&
operator|!
name|defaulted_int
operator|&&
operator|!
name|explicit_char
operator|&&
name|pedantic
condition|)
block|{
name|pedwarn
argument_list|(
literal|"long, short, signed or unsigned used invalidly for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_pedantic_errors
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Discard the type modifiers if they are invalid.  */
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|specbits
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|)
expr_stmt|;
name|longlong
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_COMPLEX
operator|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"complex invalid for `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|specbits
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_COMPLEX
operator|)
expr_stmt|;
block|}
comment|/* Decide whether an integer type is signed or not.      Optionally treat bitfields as signed by default.  */
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
comment|/* Traditionally, all bitfields are unsigned.  */
operator|||
operator|(
name|bitfield
operator|&&
name|flag_traditional
operator|&&
operator|(
operator|!
name|explicit_flag_signed_bitfields
operator|||
operator|!
name|flag_signed_bitfields
operator|)
operator|)
operator|||
operator|(
name|bitfield
operator|&&
operator|!
name|flag_signed_bitfields
operator|&&
operator|(
name|explicit_int
operator|||
name|defaulted_int
operator|||
name|explicit_char
comment|/* A typedef for plain `int' without `signed' 		 can be controlled just like plain `int'.  */
operator|||
operator|!
operator|(
name|typedef_decl
operator|!=
literal|0
operator|&&
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|typedef_decl
argument_list|)
operator|)
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ENUMERAL_TYPE
operator|&&
operator|!
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|longlong
condition|)
name|type
operator|=
name|long_long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
condition|)
name|type
operator|=
name|long_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
condition|)
name|type
operator|=
name|short_unsigned_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|char_type_node
condition|)
name|type
operator|=
name|unsigned_char_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|typedef_decl
condition|)
name|type
operator|=
name|unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
name|unsigned_type_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|&&
name|type
operator|==
name|char_type_node
condition|)
name|type
operator|=
name|signed_char_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|longlong
condition|)
name|type
operator|=
name|long_long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
condition|)
name|type
operator|=
name|long_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
condition|)
name|type
operator|=
name|short_integer_type_node
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_COMPLEX
condition|)
block|{
comment|/* If we just have "complex", it is equivalent to 	 "complex double", but if any modifiers at all are specified it is 	 the complex form of TYPE.  E.g, "complex short" is 	 "complex short int".  */
if|if
condition|(
name|defaulted_int
operator|&&
operator|!
name|longlong
operator|&&
operator|!
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_LONG
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SHORT
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_UNSIGNED
operator|)
operator|)
operator|)
condition|)
name|type
operator|=
name|complex_double_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|integer_type_node
condition|)
name|type
operator|=
name|complex_integer_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|float_type_node
condition|)
name|type
operator|=
name|complex_float_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|double_type_node
condition|)
name|type
operator|=
name|complex_double_type_node
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|long_double_type_node
condition|)
name|type
operator|=
name|complex_long_double_type_node
expr_stmt|;
else|else
name|type
operator|=
name|build_complex_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Set CONSTP if this declaration is `const', whether by      explicit specification or via a typedef.      Likewise for VOLATILEP.  */
name|constp
operator|=
operator|!
operator|!
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_CONST
operator|)
operator|+
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|volatilep
operator|=
operator|!
operator|!
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_VOLATILE
operator|)
operator|+
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|inlinep
operator|=
operator|!
operator|!
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_INLINE
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|constp
operator|>
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `const'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatilep
operator|>
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `volatile'"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flag_gen_aux_info
operator|&&
operator|(
name|TYPE_READONLY
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
operator|)
condition|)
name|type
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Warn if two storage classes are given. Default to `auto'.  */
block|{
name|int
name|nclasses
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
condition|)
name|nclasses
operator|++
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_ITERATOR
condition|)
name|nclasses
operator|++
expr_stmt|;
comment|/* Warn about storage classes that are invalid for certain        kinds of declarations (parameters, typenames, etc.).  */
if|if
condition|(
name|nclasses
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"multiple storage classes in declaration of `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|funcdef_flag
operator|&&
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|&&
operator|(
name|pedantic
operator|||
name|current_binding_level
operator|==
name|global_binding_level
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"function definition declared `auto'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
condition|)
name|error
argument_list|(
literal|"function definition declared `register'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
condition|)
name|error
argument_list|(
literal|"function definition declared `typedef'"
argument_list|)
expr_stmt|;
name|specbits
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|!=
name|NORMAL
operator|&&
name|nclasses
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|decl_context
operator|==
name|PARM
operator|&&
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
condition|)
empty_stmt|;
else|else
block|{
name|error
argument_list|(
operator|(
name|decl_context
operator|==
name|FIELD
condition|?
literal|"storage class specified for structure field `%s'"
else|:
operator|(
name|decl_context
operator|==
name|PARM
condition|?
literal|"storage class specified for parameter `%s'"
else|:
literal|"storage class specified for typename"
operator|)
operator|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|specbits
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|&&
name|initialized
operator|&&
operator|!
name|funcdef_flag
condition|)
block|{
comment|/* `extern' with initialization is invalid if not at top level.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|warning
argument_list|(
literal|"`%s' initialized and declared `extern'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"`%s' has both `extern' and initializer"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|&&
name|funcdef_flag
operator|&&
name|current_binding_level
operator|!=
name|global_binding_level
condition|)
name|error
argument_list|(
literal|"nested function `%s' declared `extern'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
operator|&&
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
condition|)
name|error
argument_list|(
literal|"top-level declaration of `%s' specifies `auto'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_ITERATOR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
name|error
argument_list|(
literal|"iterator `%s' has derived type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_ITERATOR
operator|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|INTEGER_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"iterator `%s' has noninteger type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
comment|/* Now figure out the structure of the declarator proper.      Descend through it, creating more complex types, until we reach      the declared identifier (or NULL_TREE, in an absolute declarator).  */
while|while
condition|(
name|declarator
operator|&&
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|!=
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
block|{
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Each level of DECLARATOR is either an ARRAY_REF (for ...[..]), 	 an INDIRECT_REF (for *...), 	 a CALL_EXPR (for ...(...)), 	 an identifier (for the name being declared) 	 or a null pointer (for the place in an absolute declarator 	 where the name was omitted). 	 For the last two cases, we have just exited the loop.  	 At this point, TYPE is the type of elements of an array, 	 or for a function to return, or for a pointer to point to. 	 After this sequence of ifs, TYPE is the type of the 	 array or function or pointer, and DECLARATOR has had its 	 outermost layer removed.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
specifier|register
name|tree
name|itype
init|=
name|NULL_TREE
decl_stmt|;
specifier|register
name|tree
name|size
init|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* An uninitialized decl with `extern' is a reference.  */
name|int
name|extern_ref
init|=
operator|!
name|initialized
operator|&&
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
operator|)
decl_stmt|;
comment|/* The index is a signed object `sizetype' bits wide.  */
name|tree
name|index_type
init|=
name|signed_type
argument_list|(
name|sizetype
argument_list|)
decl_stmt|;
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check for some types that there cannot be arrays of.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|error
argument_list|(
literal|"declaration of `%s' as array of voids"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"declaration of `%s' as array of functions"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
name|error_mark_node
condition|)
name|type
operator|=
name|error_mark_node
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
continue|continue;
comment|/* If this is a block level extern, it must live past the end 	     of the function so that we can check it against other extern 	     declarations (IDENTIFIER_LIMBO_VALUE).  */
if|if
condition|(
name|extern_ref
operator|&&
name|allocation_temporary_p
argument_list|()
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* If size was specified, set ITYPE to a range-type for that size. 	     Otherwise, ITYPE remains null.  finish_decl may figure it out 	     from an initial value.  */
if|if
condition|(
name|size
condition|)
block|{
comment|/* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */
name|STRIP_TYPE_NOPS
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|size
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"size of array `%s' has non-integer type"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
name|integer_zerop
argument_list|(
name|size
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids zero-size array `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|constant_expression_warning
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|size
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"size of array `%s' is negative"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|size
operator|=
name|integer_one_node
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Make sure the array size remains visibly nonconstant 		     even if it is (eg) a const variable with known value.  */
name|size_varies
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pedantic
condition|)
block|{
if|if
condition|(
name|TREE_CONSTANT
argument_list|(
name|size
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids array `%s' whose size can't be evaluated"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|pedwarn
argument_list|(
literal|"ANSI C forbids variable-size array `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Convert size to index_type, so that if it is a variable 		 the computations will be done in the proper mode.  */
name|itype
operator|=
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|index_type
argument_list|,
name|convert
argument_list|(
name|index_type
argument_list|,
name|size
argument_list|)
argument_list|,
name|convert
argument_list|(
name|index_type
argument_list|,
name|size_one_node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_varies
condition|)
name|itype
operator|=
name|variable_size
argument_list|(
name|itype
argument_list|)
expr_stmt|;
name|itype
operator|=
name|build_index_type
argument_list|(
name|itype
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* This had bad results for pointers to arrays, as in 	 union incomplete (*foo)[4];  */
comment|/* Complain about arrays of incomplete types, except in typedefs.  */
block|if (TYPE_SIZE (type) == 0
comment|/* Avoid multiple warnings for nested array types.  */
block|&& TREE_CODE (type) != ARRAY_TYPE&& !(specbits& (1<< (int) RID_TYPEDEF))&& !C_TYPE_BEING_DEFINED (type)) 	    warning ("array type has incomplete element type");
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* We shouldn't have a function type here at all! 	  Functions aren't allowed as array elements.  */
block|if (pedantic&& TREE_CODE (type) == FUNCTION_TYPE&& (constp || volatilep)) 	    pedwarn ("ANSI C forbids const or volatile function types");
endif|#
directive|endif
comment|/* Build the array type itself, then merge any constancy or 	     volatility into the target type.  We must do it in this order 	     to ensure that the TYPE_MAIN_VARIANT field of the array type 	     is set correctly.  */
name|type
operator|=
name|build_array_type
argument_list|(
name|type
argument_list|,
name|itype
argument_list|)
expr_stmt|;
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
name|type
operator|=
name|c_build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* don't clear these; leave them set so that the array type 	   or the variable is itself const or volatile.  */
block|constp = 0; 	  volatilep = 0;
endif|#
directive|endif
if|if
condition|(
name|size_varies
condition|)
name|C_TYPE_VARIABLE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|CALL_EXPR
condition|)
block|{
name|int
name|extern_ref
init|=
operator|(
operator|!
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator|)
operator|||
name|current_binding_level
operator|==
name|global_binding_level
operator|)
decl_stmt|;
name|tree
name|arg_types
decl_stmt|;
comment|/* Declaring a function type. 	     Make sure we have a valid type for the function to return.  */
if|if
condition|(
name|type
operator|==
name|error_mark_node
condition|)
continue|continue;
name|size_varies
operator|=
literal|0
expr_stmt|;
comment|/* Warn about some types functions can't return.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"`%s' declared as function returning a function"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"`%s' declared as function returning an array"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|TRADITIONAL_RETURN_FLOAT
comment|/* Traditionally, declaring return type float means double.  */
if|if
condition|(
name|flag_traditional
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|float_type_node
condition|)
name|type
operator|=
name|double_type_node
expr_stmt|;
endif|#
directive|endif
comment|/* TRADITIONAL_RETURN_FLOAT */
comment|/* If this is a block level extern, it must live past the end 	     of the function so that we can check it against other extern 	     declarations (IDENTIFIER_LIMBO_VALUE).  */
if|if
condition|(
name|extern_ref
operator|&&
name|allocation_temporary_p
argument_list|()
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* Construct the function type and go to the next 	     inner layer of declarator.  */
name|arg_types
operator|=
name|grokparms
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|1
argument_list|)
argument_list|,
name|funcdef_flag
comment|/* Say it's a definition 				    only for the CALL_EXPR 				    closest to the identifier.  */
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This seems to be false.  We turn off temporary allocation 	 above in this function if -traditional. 	 And this code caused inconsistent results with prototypes: 	 callers would ignore them, and pass arguments wrong.  */
comment|/* Omit the arg types if -traditional, since the arg types 	     and the list links might not be permanent.  */
block|type = build_function_type (type, 				      flag_traditional  				      ? NULL_TREE : arg_types);
endif|#
directive|endif
comment|/* ANSI seems to say that `const int foo ();' 	     does not make the function foo const.  */
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
name|type
operator|=
name|c_build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
name|constp
operator|=
literal|0
expr_stmt|;
name|volatilep
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|build_function_type
argument_list|(
name|type
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the TYPE_CONTEXTs for each tagged type which is local to 	     the formal parameter list of this FUNCTION_TYPE to point to 	     the FUNCTION_TYPE node itself.  */
block|{
specifier|register
name|tree
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|current_function_parm_tags
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|TYPE_CONTEXT
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|declarator
argument_list|)
operator|==
name|INDIRECT_REF
condition|)
block|{
comment|/* Merge any constancy or volatility into the target type 	     for the pointer.  */
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
operator|(
name|constp
operator|||
name|volatilep
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids const or volatile function types"
argument_list|)
expr_stmt|;
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
name|type
operator|=
name|c_build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
name|constp
operator|=
literal|0
expr_stmt|;
name|volatilep
operator|=
literal|0
expr_stmt|;
name|size_varies
operator|=
literal|0
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Process a list of type modifier keywords 	     (such as const or volatile) that were given inside the `*'.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|declarator
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|typemodlist
decl_stmt|;
name|int
name|erred
init|=
literal|0
decl_stmt|;
for|for
control|(
name|typemodlist
operator|=
name|TREE_TYPE
argument_list|(
name|declarator
argument_list|)
init|;
name|typemodlist
condition|;
name|typemodlist
operator|=
name|TREE_CHAIN
argument_list|(
name|typemodlist
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|typemodlist
argument_list|)
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_CONST
index|]
condition|)
name|constp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|typemodlist
argument_list|)
operator|==
name|ridpointers
index|[
operator|(
name|int
operator|)
name|RID_VOLATILE
index|]
condition|)
name|volatilep
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|erred
condition|)
block|{
name|erred
operator|=
literal|1
expr_stmt|;
name|error
argument_list|(
literal|"invalid type modifier within pointer declarator"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|constp
operator|>
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `const'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatilep
operator|>
literal|1
condition|)
name|pedwarn
argument_list|(
literal|"duplicate `volatile'"
argument_list|)
expr_stmt|;
block|}
name|declarator
operator|=
name|TREE_OPERAND
argument_list|(
name|declarator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Now TYPE has the actual type.  */
comment|/* If this is declaring a typedef name, return a TYPE_DECL.  */
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_TYPEDEF
operator|)
condition|)
block|{
name|tree
name|decl
decl_stmt|;
comment|/* Note that the grammar rejects storage classes 	 in typenames, fields or parameters */
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
operator|(
name|constp
operator|||
name|volatilep
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids const or volatile function types"
argument_list|)
expr_stmt|;
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
name|type
operator|=
name|c_build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|TYPE_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_SIGNED
operator|)
operator|)
operator|||
operator|(
name|typedef_decl
operator|&&
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|typedef_decl
argument_list|)
operator|)
condition|)
name|C_TYPEDEF_EXPLICITLY_SIGNED
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|decl
return|;
block|}
comment|/* Detect the case of an array type of unspecified size      which came, as such, direct from a typedef name.      We must copy the type, so that each identifier gets      a distinct type, so that each identifier's size can be      controlled separately by its own initializer.  */
if|if
condition|(
name|type
operator|!=
literal|0
operator|&&
name|typedef_type
operator|!=
literal|0
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|typedef_type
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|build_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_varies
condition|)
name|C_TYPE_VARIABLE_SIZE
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If this is a type name (such as, in a cast or sizeof),      compute the type and return it now.  */
if|if
condition|(
name|decl_context
operator|==
name|TYPENAME
condition|)
block|{
comment|/* Note that the grammar rejects storage classes 	 in typenames, fields or parameters */
if|if
condition|(
name|pedantic
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
operator|(
name|constp
operator|||
name|volatilep
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids const or volatile function types"
argument_list|)
expr_stmt|;
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
name|type
operator|=
name|c_build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|type
return|;
block|}
comment|/* Aside from typedefs and type names (handle above),      `void' at top level (not within pointer)      is allowed only in public variables.      We don't complain about parms either, but that is because      a better error message can be made later.  */
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|==
name|void_type_node
operator|&&
name|decl_context
operator|!=
name|PARM
operator|&&
operator|!
operator|(
operator|(
name|decl_context
operator|!=
name|FIELD
operator|&&
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|FUNCTION_TYPE
operator|)
operator|&&
operator|(
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
operator|)
operator|||
operator|(
name|current_binding_level
operator|==
name|global_binding_level
operator|&&
operator|!
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"variable or field `%s' declared void"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* Now create the decl, which may be a VAR_DECL, a PARM_DECL      or a FUNCTION_DECL, depending on DECL_CONTEXT and TYPE.  */
block|{
specifier|register
name|tree
name|decl
decl_stmt|;
if|if
condition|(
name|decl_context
operator|==
name|PARM
condition|)
block|{
name|tree
name|type_as_written
init|=
name|type
decl_stmt|;
name|tree
name|main_type
decl_stmt|;
comment|/* A parameter declared as an array of T is really a pointer to T. 	   One declared as a function is really a pointer to a function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
comment|/* Transfer const-ness of array into that of type pointed to.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
name|type
operator|=
name|c_build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|volatilep
operator|=
name|constp
operator|=
literal|0
expr_stmt|;
name|size_varies
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|constp
operator|||
name|volatilep
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids const or volatile function types"
argument_list|)
expr_stmt|;
if|if
condition|(
name|constp
operator|||
name|volatilep
condition|)
name|type
operator|=
name|c_build_type_variant
argument_list|(
name|type
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|volatilep
operator|=
name|constp
operator|=
literal|0
expr_stmt|;
block|}
name|decl
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_varies
condition|)
name|C_DECL_VARIABLE_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Compute the type actually passed in the parmlist, 	   for the case where there is no prototype. 	   (For example, shorts and chars are passed as ints.) 	   When there is a prototype, this is overridden later.  */
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
name|main_type
operator|=
operator|(
name|type
operator|==
name|error_mark_node
condition|?
name|error_mark_node
else|:
name|TYPE_MAIN_VARIANT
argument_list|(
name|type
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|main_type
operator|==
name|float_type_node
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|double_type_node
expr_stmt|;
comment|/* Don't use TYPE_PRECISION to decide whether to promote, 	   because we should convert short if it's the same size as int, 	   but we should not convert long if it's the same size as int.  */
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|main_type
argument_list|)
operator|!=
name|ERROR_MARK
operator|&&
name|C_PROMOTING_INTEGER_TYPE_P
argument_list|(
name|main_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|unsigned_type_node
expr_stmt|;
else|else
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
block|}
name|DECL_ARG_TYPE_AS_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
name|type_as_written
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|decl_context
operator|==
name|FIELD
condition|)
block|{
comment|/* Structure field.  It may not be a function.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
name|error
argument_list|(
literal|"field `%s' declared as a function"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|build_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|ERROR_MARK
operator|&&
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"field `%s' has incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Move type qualifiers down to element of an array.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|(
name|constp
operator|||
name|volatilep
operator|)
condition|)
block|{
name|type
operator|=
name|build_array_type
argument_list|(
name|c_build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Leave the field const or volatile as well.  */
block|constp = volatilep = 0;
endif|#
directive|endif
block|}
name|decl
operator|=
name|build_decl
argument_list|(
name|FIELD_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_varies
condition|)
name|C_DECL_VARIABLE_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|FUNCTION_TYPE
condition|)
block|{
comment|/* Every function declaration is "external" 	   except for those which are inside a function body 	   in which `auto' is used. 	   That is a case not specified by ANSI C, 	   and we use it for forward declarations for nested functions.  */
name|int
name|extern_ref
init|=
operator|(
operator|!
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator|)
operator|||
name|current_binding_level
operator|==
name|global_binding_level
operator|)
decl_stmt|;
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator|&&
operator|(
name|pedantic
operator|||
name|current_binding_level
operator|==
name|global_binding_level
operator|)
condition|)
name|pedwarn
argument_list|(
literal|"invalid storage class for function `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
condition|)
name|error
argument_list|(
literal|"invalid storage class for function `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Function declaration not at top level. 	   Storage classes other than `extern' are not allowed 	   and `extern' makes no difference.  */
if|if
condition|(
name|current_binding_level
operator|!=
name|global_binding_level
operator|&&
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_INLINE
operator|)
operator|)
operator|)
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"invalid storage class for function `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a block level extern, it must live past the end 	   of the function so that we can check it against other 	   extern declarations (IDENTIFIER_LIMBO_VALUE).  */
if|if
condition|(
name|extern_ref
operator|&&
name|allocation_temporary_p
argument_list|()
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|FUNCTION_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
operator|(
name|constp
operator|||
name|volatilep
operator|)
operator|&&
operator|!
name|DECL_IN_SYSTEM_HEADER
argument_list|(
name|decl
argument_list|)
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids const or volatile functions"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volatilep
operator|&&
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
name|warning
argument_list|(
literal|"`noreturn' function returns non-void value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|extern_ref
condition|)
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record absence of global scope for `static' or `auto'.  */
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_AUTO
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* Record presence of `inline', if it is reasonable.  */
if|if
condition|(
name|inlinep
condition|)
block|{
name|tree
name|last
init|=
name|tree_last
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|declarator
argument_list|)
argument_list|,
literal|"main"
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cannot inline function `main'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|last
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|last
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
condition|)
name|warning
argument_list|(
literal|"inline declaration ignored for function with `...'"
argument_list|)
expr_stmt|;
else|else
comment|/* Assume that otherwise the function can be inlined.  */
name|DECL_INLINE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
condition|)
name|current_extern_inline
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* It's a variable.  */
comment|/* An uninitialized decl with `extern' is a reference.  */
name|int
name|extern_ref
init|=
operator|!
name|initialized
operator|&&
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_EXTERN
operator|)
operator|)
decl_stmt|;
comment|/* Move type qualifiers down to element of an array.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ARRAY_TYPE
operator|&&
operator|(
name|constp
operator|||
name|volatilep
operator|)
condition|)
block|{
name|type
operator|=
name|build_array_type
argument_list|(
name|c_build_type_variant
argument_list|(
name|TREE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|constp
argument_list|,
name|volatilep
argument_list|)
argument_list|,
name|TYPE_DOMAIN
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Leave the variable const or volatile as well.  */
block|constp = volatilep = 0;
endif|#
directive|endif
block|}
comment|/* If this is a block level extern, it must live past the end 	   of the function so that we can check it against other 	   extern declarations (IDENTIFIER_LIMBO_VALUE).  */
if|if
condition|(
name|extern_ref
operator|&&
name|allocation_temporary_p
argument_list|()
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|VAR_DECL
argument_list|,
name|declarator
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_varies
condition|)
name|C_DECL_VARIABLE_SIZE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|inlinep
condition|)
name|pedwarn_with_decl
argument_list|(
name|decl
argument_list|,
literal|"variable `%s' declared `inline'"
argument_list|)
expr_stmt|;
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|=
name|extern_ref
expr_stmt|;
comment|/* At top level, the presence of a `static' or `register' storage 	   class specifier, or the absence of all storage class specifiers 	   makes this declaration a definition (perhaps tentative).  Also, 	   the absence of both `static' and `register' makes it public.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
block|{
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
operator|(
name|specbits
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator||
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
operator|)
operator|)
expr_stmt|;
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|!
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
comment|/* Not at top level, only `static' makes a static definition.  */
else|else
block|{
name|TREE_STATIC
argument_list|(
name|decl
argument_list|)
operator|=
operator|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_STATIC
operator|)
operator|)
operator|!=
literal|0
expr_stmt|;
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|=
name|DECL_EXTERNAL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|specbits
operator|&
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_ITERATOR
condition|)
name|ITERATOR_P
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Record `register' declaration for warnings on&        and in case doing stupid register allocation.  */
if|if
condition|(
name|specbits
operator|&
operator|(
literal|1
operator|<<
operator|(
name|int
operator|)
name|RID_REGISTER
operator|)
condition|)
name|DECL_REGISTER
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Record constancy and volatility.  */
if|if
condition|(
name|constp
condition|)
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|volatilep
condition|)
block|{
name|TREE_SIDE_EFFECTS
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If a type has volatile components, it should be stored in memory.        Otherwise, the fact that those components are volatile        will be ignored, and would even crash the compiler.  */
if|if
condition|(
name|C_TYPE_FIELDS_VOLATILE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
name|mark_addressable
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|decl
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Decode the parameter-list info for a function type or function definition.    The argument is the value returned by `get_parm_info' (or made in parse.y    if there is an identifier list instead of a parameter decl list).    These two functions are separate because when a function returns    or receives functions then each is called multiple times but the order    of calls is different.  The last call to `grokparms' is always the one    that contains the formal parameter names of a function definition.     Store in `last_function_parms' a chain of the decls of parms.    Also store in `last_function_parm_tags' a chain of the struct, union,    and enum tags declared among the parms.     Return a list of arg types to use in the FUNCTION_TYPE for this function.     FUNCDEF_FLAG is nonzero for a function definition, 0 for    a mere declaration.  A nonempty identifier-list gets an error message    when FUNCDEF_FLAG is zero.  */
end_comment

begin_function
specifier|static
name|tree
name|grokparms
parameter_list|(
name|parms_info
parameter_list|,
name|funcdef_flag
parameter_list|)
name|tree
name|parms_info
decl_stmt|;
name|int
name|funcdef_flag
decl_stmt|;
block|{
name|tree
name|first_parm
init|=
name|TREE_CHAIN
argument_list|(
name|parms_info
argument_list|)
decl_stmt|;
name|last_function_parms
operator|=
name|TREE_PURPOSE
argument_list|(
name|parms_info
argument_list|)
expr_stmt|;
name|last_function_parm_tags
operator|=
name|TREE_VALUE
argument_list|(
name|parms_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|warn_strict_prototypes
operator|&&
name|first_parm
operator|==
literal|0
operator|&&
operator|!
name|funcdef_flag
operator|&&
operator|!
name|in_system_header
condition|)
name|warning
argument_list|(
literal|"function declaration isn't a prototype"
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_parm
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|first_parm
argument_list|)
argument_list|)
operator|==
name|IDENTIFIER_NODE
condition|)
block|{
if|if
condition|(
operator|!
name|funcdef_flag
condition|)
name|pedwarn
argument_list|(
literal|"parameter names (without types) in function declaration"
argument_list|)
expr_stmt|;
name|last_function_parms
operator|=
name|first_parm
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|tree
name|parm
decl_stmt|;
name|tree
name|typelt
decl_stmt|;
comment|/* We no longer test FUNCDEF_FLAG. 	 If the arg types are incomplete in a declaration, 	 they must include undefined tags. 	 These tags can never be defined in the scope of the declaration, 	 so the types can never be completed, 	 and no call can be compiled successfully.  */
if|#
directive|if
literal|0
comment|/* In a fcn definition, arg types must be complete.  */
block|if (funcdef_flag)
endif|#
directive|endif
for|for
control|(
name|parm
operator|=
name|last_function_parms
operator|,
name|typelt
operator|=
name|first_parm
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
comment|/* Skip over any enumeration constants declared here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
comment|/* Barf if the parameter itself has an incomplete type.  */
name|tree
name|type
init|=
name|TREE_VALUE
argument_list|(
name|typelt
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|funcdef_flag
operator|&&
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"parameter `%s' has incomplete type"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"parameter has incomplete type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|funcdef_flag
condition|)
block|{
name|TREE_VALUE
argument_list|(
name|typelt
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* This has been replaced by parm_tags_warning 	  which uses a more accurate criterion for what to warn about.  */
block|else 		{
comment|/* Now warn if is a pointer to an incomplete type.  */
block|while (TREE_CODE (type) == POINTER_TYPE 			 || TREE_CODE (type) == REFERENCE_TYPE) 		    type = TREE_TYPE (type); 		  type = TYPE_MAIN_VARIANT (type); 		  if (TYPE_SIZE (type) == 0) 		    { 		      if (DECL_NAME (parm) != 0) 			warning ("parameter `%s' points to incomplete type", 				 IDENTIFIER_POINTER (DECL_NAME (parm))); 		      else 			warning ("parameter points to incomplete type"); 		    } 		}
endif|#
directive|endif
name|typelt
operator|=
name|TREE_CHAIN
argument_list|(
name|typelt
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate the list of types the way we allocate a type.  */
if|if
condition|(
name|first_parm
operator|&&
operator|!
name|TREE_PERMANENT
argument_list|(
name|first_parm
argument_list|)
condition|)
block|{
comment|/* Construct a copy of the list of types 	     on the saveable obstack.  */
name|tree
name|result
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|typelt
operator|=
name|first_parm
init|;
name|typelt
condition|;
name|typelt
operator|=
name|TREE_CHAIN
argument_list|(
name|typelt
argument_list|)
control|)
name|result
operator|=
name|saveable_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_VALUE
argument_list|(
name|typelt
argument_list|)
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
name|nreverse
argument_list|(
name|result
argument_list|)
return|;
block|}
else|else
comment|/* The list we have is permanent already.  */
return|return
name|first_parm
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return a tree_list node with info on a parameter list just parsed.    The TREE_PURPOSE is a chain of decls of those parms.    The TREE_VALUE is a list of structure, union and enum tags defined.    The TREE_CHAIN is a list of argument types to go in the FUNCTION_TYPE.    This tree_list node is later fed to `grokparms'.     VOID_AT_END nonzero means append `void' to the end of the type-list.    Zero means the parmlist ended with an ellipsis so don't append `void'.  */
end_comment

begin_function
name|tree
name|get_parm_info
parameter_list|(
name|void_at_end
parameter_list|)
name|int
name|void_at_end
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|,
name|t
decl_stmt|;
specifier|register
name|tree
name|types
init|=
literal|0
decl_stmt|;
name|int
name|erred
init|=
literal|0
decl_stmt|;
name|tree
name|tags
init|=
name|gettags
argument_list|()
decl_stmt|;
name|tree
name|parms
init|=
name|getdecls
argument_list|()
decl_stmt|;
name|tree
name|new_parms
init|=
literal|0
decl_stmt|;
name|tree
name|order
init|=
name|current_binding_level
operator|->
name|parm_order
decl_stmt|;
comment|/* Just `void' (and no ellipsis) is special.  There are really no parms.  */
if|if
condition|(
name|void_at_end
operator|&&
name|parms
operator|!=
literal|0
operator|&&
name|TREE_CHAIN
argument_list|(
name|parms
argument_list|)
operator|==
literal|0
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parms
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|&&
name|DECL_NAME
argument_list|(
name|parms
argument_list|)
operator|==
literal|0
condition|)
block|{
name|parms
operator|=
name|NULL_TREE
expr_stmt|;
name|storedecls
argument_list|(
name|NULL_TREE
argument_list|)
expr_stmt|;
return|return
name|saveable_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|,
name|saveable_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
return|;
block|}
comment|/* Extract enumerator values and other non-parms declared with the parms.      Likewise any forward parm decls that didn't have real parm decls.  */
for|for
control|(
name|decl
operator|=
name|parms
init|;
name|decl
condition|;
control|)
block|{
name|tree
name|next
init|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|PARM_DECL
condition|)
block|{
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|new_parms
expr_stmt|;
name|new_parms
operator|=
name|decl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"parameter `%s' has just a forward declaration"
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
operator|=
name|new_parms
expr_stmt|;
name|new_parms
operator|=
name|decl
expr_stmt|;
block|}
name|decl
operator|=
name|next
expr_stmt|;
block|}
comment|/* Put the parm decls back in the order they were in in the parm list.  */
for|for
control|(
name|t
operator|=
name|order
init|;
name|t
condition|;
name|t
operator|=
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
condition|)
name|TREE_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|TREE_CHAIN
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|TREE_VALUE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|new_parms
operator|=
name|chainon
argument_list|(
name|order
condition|?
name|nreverse
argument_list|(
name|TREE_VALUE
argument_list|(
name|order
argument_list|)
argument_list|)
else|:
literal|0
argument_list|,
name|new_parms
argument_list|)
expr_stmt|;
comment|/* Store the parmlist in the binding level since the old one      is no longer a valid list.  (We have changed the chain pointers.)  */
name|storedecls
argument_list|(
name|new_parms
argument_list|)
expr_stmt|;
for|for
control|(
name|decl
operator|=
name|new_parms
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
comment|/* There may also be declarations for enumerators if an enumeration        type is declared among the parms.  Ignore them here.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
comment|/* Since there is a prototype, 	   args are passed in their declared types.  */
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|type
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_PROTOTYPES
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|decl
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
endif|#
directive|endif
name|types
operator|=
name|saveable_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|types
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|types
argument_list|)
argument_list|)
operator|==
name|void_type_node
operator|&&
operator|!
name|erred
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"`void' in parameter list must be the entire list"
argument_list|)
expr_stmt|;
name|erred
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|void_at_end
condition|)
return|return
name|saveable_tree_cons
argument_list|(
name|new_parms
argument_list|,
name|tags
argument_list|,
name|nreverse
argument_list|(
name|saveable_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|,
name|types
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|saveable_tree_cons
argument_list|(
name|new_parms
argument_list|,
name|tags
argument_list|,
name|nreverse
argument_list|(
name|types
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* At end of parameter list, warn about any struct, union or enum tags    defined within.  Do so because these types cannot ever become complete.  */
end_comment

begin_function
name|void
name|parmlist_tags_warning
parameter_list|()
block|{
name|tree
name|elt
decl_stmt|;
specifier|static
name|int
name|already
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|current_binding_level
operator|->
name|tags
init|;
name|elt
condition|;
name|elt
operator|=
name|TREE_CHAIN
argument_list|(
name|elt
argument_list|)
control|)
block|{
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_VALUE
argument_list|(
name|elt
argument_list|)
argument_list|)
decl_stmt|;
comment|/* An anonymous union parm type is meaningful as a GNU extension. 	 So don't warn for that.  */
if|if
condition|(
name|code
operator|==
name|UNION_TYPE
operator|&&
operator|!
name|pedantic
condition|)
continue|continue;
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"`%s %s' declared inside parameter list"
argument_list|,
operator|(
name|code
operator|==
name|RECORD_TYPE
condition|?
literal|"struct"
else|:
name|code
operator|==
name|UNION_TYPE
condition|?
literal|"union"
else|:
literal|"enum"
operator|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|elt
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"anonymous %s declared inside parameter list"
argument_list|,
operator|(
name|code
operator|==
name|RECORD_TYPE
condition|?
literal|"struct"
else|:
name|code
operator|==
name|UNION_TYPE
condition|?
literal|"union"
else|:
literal|"enum"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|already
condition|)
block|{
name|warning
argument_list|(
literal|"its scope is only this definition or declaration,"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"which is probably not what you want."
argument_list|)
expr_stmt|;
name|already
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the struct, enum or union (CODE says which) with tag NAME.    Define the tag as a forward-reference if it is not defined.  */
end_comment

begin_function
name|tree
name|xref_tag
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
name|int
name|temporary
init|=
name|allocation_temporary_p
argument_list|()
decl_stmt|;
comment|/* If a cross reference is requested, look up the type      already defined for this tag and return it.  */
specifier|register
name|tree
name|ref
init|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|current_binding_level
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Even if this is the wrong type of tag, return what we found.      There will be an error message anyway, from pending_xref_error.      If we create an empty xref just for an invalid use of the type,      the main result is to create lots of superfluous error messages.  */
if|if
condition|(
name|ref
condition|)
return|return
name|ref
return|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
operator|&&
name|temporary
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
comment|/* If no such tag is yet defined, create a forward-reference node      and record it as the "definition".      When a real declaration of this type is found,      the forward-reference will be altered into a real type.  */
name|ref
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|ENUMERAL_TYPE
condition|)
block|{
comment|/* (In ANSI, Enums can be referred to only if already defined.)  */
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids forward references to `enum' types"
argument_list|)
expr_stmt|;
comment|/* Give the type a default layout like unsigned int 	 to avoid crashing if it does not get defined.  */
name|TYPE_MODE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|ref
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|unsigned_type_node
argument_list|)
expr_stmt|;
block|}
name|pushtag
argument_list|(
name|name
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Make sure that the tag NAME is defined *in the current binding level*    at least as a forward reference.    CODE says which kind of tag NAME ought to be.     We also do a push_obstacks_nochange    whose matching pop is in finish_struct.  */
end_comment

begin_function
name|tree
name|start_struct
parameter_list|(
name|code
parameter_list|,
name|name
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
name|tree
name|name
decl_stmt|;
block|{
comment|/* If there is already a tag defined at this binding level      (as a forward reference), just return it.  */
specifier|register
name|tree
name|ref
init|=
literal|0
decl_stmt|;
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|name
operator|!=
literal|0
condition|)
name|ref
operator|=
name|lookup_tag
argument_list|(
name|code
argument_list|,
name|name
argument_list|,
name|current_binding_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ref
operator|&&
name|TREE_CODE
argument_list|(
name|ref
argument_list|)
operator|==
name|code
condition|)
block|{
name|C_TYPE_BEING_DEFINED
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_FIELDS
argument_list|(
name|ref
argument_list|)
condition|)
name|error
argument_list|(
operator|(
name|code
operator|==
name|UNION_TYPE
condition|?
literal|"redefinition of `union %s'"
else|:
literal|"redefinition of `struct %s'"
operator|)
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
comment|/* Otherwise create a forward-reference just so the tag is in scope.  */
name|ref
operator|=
name|make_node
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|C_TYPE_BEING_DEFINED
argument_list|(
name|ref
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_comment
comment|/* Process the specs, declarator (NULL if omitted) and width (NULL if omitted)    of a structure component, returning a FIELD_DECL node.    WIDTH is non-NULL for bit fields only, and is an INTEGER_CST node.     This is done during the parsing of the struct declaration.    The FIELD_DECL nodes are chained together and the lot of them    are ultimately passed to `build_struct' to make the RECORD_TYPE node.  */
end_comment

begin_function
name|tree
name|grokfield
parameter_list|(
name|filename
parameter_list|,
name|line
parameter_list|,
name|declarator
parameter_list|,
name|declspecs
parameter_list|,
name|width
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|line
decl_stmt|;
name|tree
name|declarator
decl_stmt|,
name|declspecs
decl_stmt|,
name|width
decl_stmt|;
block|{
name|tree
name|value
decl_stmt|;
comment|/* The corresponding pop_obstacks is in finish_decl.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
name|value
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|width
condition|?
name|BITFIELD
else|:
name|FIELD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|finish_decl
argument_list|(
name|value
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|value
argument_list|)
operator|=
name|width
expr_stmt|;
name|maybe_objc_check_decl
argument_list|(
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Function to help qsort sort FIELD_DECLs by name order.  */
end_comment

begin_function
specifier|static
name|int
name|field_decl_cmp
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
name|tree
modifier|*
name|x
decl_stmt|,
decl|*
name|y
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|long
operator|)
name|DECL_NAME
argument_list|(
operator|*
name|x
argument_list|)
operator|-
operator|(
name|long
operator|)
name|DECL_NAME
argument_list|(
operator|*
name|y
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* Fill in the fields of a RECORD_TYPE or UNION_TYPE node, T.    FIELDLIST is a chain of FIELD_DECL nodes for the fields.     We also do a pop_obstacks to match the push in start_struct.  */
end_comment

begin_function
name|tree
name|finish_struct
parameter_list|(
name|t
parameter_list|,
name|fieldlist
parameter_list|)
specifier|register
name|tree
name|t
decl_stmt|,
name|fieldlist
decl_stmt|;
block|{
specifier|register
name|tree
name|x
decl_stmt|;
name|int
name|old_momentary
decl_stmt|;
name|int
name|toplevel
init|=
name|global_binding_level
operator|==
name|current_binding_level
decl_stmt|;
comment|/* If this type was previously laid out as a forward reference,      make sure we lay it out again.  */
name|TYPE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Nameless union parm types are useful as GCC extension.  */
if|if
condition|(
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
operator|&&
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|pedantic
condition|)
comment|/* Otherwise, warn about any struct or union def. in parmlist.  */
if|if
condition|(
name|in_parm_level_p
argument_list|()
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|?
literal|"union defined inside parms"
else|:
literal|"structure defined inside parms"
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|flag_traditional
condition|)
name|warning
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|?
literal|"union defined inside parms"
else|:
literal|"structure defined inside parms"
operator|)
argument_list|)
expr_stmt|;
block|}
name|old_momentary
operator|=
name|suspend_momentary
argument_list|()
expr_stmt|;
if|if
condition|(
name|fieldlist
operator|==
literal|0
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
operator|(
name|TREE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|UNION_TYPE
condition|?
literal|"union has no members"
else|:
literal|"structure has no members"
operator|)
argument_list|)
expr_stmt|;
comment|/* Install struct as DECL_CONTEXT of each field decl.      Also process specified field sizes.      Set DECL_FIELD_SIZE to the specified size, or 0 if none specified.      The specified size is found in the DECL_INITIAL.      Store 0 there, except for ": 0" fields (so we can find them      and delete them, below).  */
for|for
control|(
name|x
operator|=
name|fieldlist
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
name|DECL_CONTEXT
argument_list|(
name|x
argument_list|)
operator|=
name|t
expr_stmt|;
name|DECL_FIELD_SIZE
argument_list|(
name|x
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* If any field is const, the structure type is pseudo-const.  */
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|x
argument_list|)
condition|)
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* A field that is pseudo-const makes the structure likewise.  */
name|tree
name|t1
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|t1
operator|=
name|TREE_TYPE
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|UNION_TYPE
operator|)
operator|&&
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t1
argument_list|)
condition|)
name|C_TYPE_FIELDS_READONLY
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Any field that is volatile means variables of this type must be 	 treated in some ways as volatile.  */
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|x
argument_list|)
condition|)
name|C_TYPE_FIELDS_VOLATILE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Any field of nominal variable size implies structure is too.  */
if|if
condition|(
name|C_DECL_VARIABLE_SIZE
argument_list|(
name|x
argument_list|)
condition|)
name|C_TYPE_VARIABLE_SIZE
argument_list|(
name|t
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Detect invalid nested redefinition.  */
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|==
name|t
condition|)
name|error
argument_list|(
literal|"nested redefinition of `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Detect invalid bit-field size.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
condition|)
name|STRIP_NOPS
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|constant_expression_warning
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"bit-field `%s' width not an integer constant"
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Detect invalid bit-field type.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|INTEGER_TYPE
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"bit-field `%s' has invalid type"
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|&&
name|pedantic
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
name|unsigned_type_node
comment|/* Accept an enum that's equivalent to int or unsigned int.  */
operator|&&
operator|!
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|&&
operator|(
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
operator|)
condition|)
name|pedwarn_with_decl
argument_list|(
name|x
argument_list|,
literal|"bit-field `%s' type invalid in ANSI C"
argument_list|)
expr_stmt|;
comment|/* Detect and ignore out of range field width.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|width
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tree_int_cst_sgn
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"negative width in bit-field `%s'"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_INT_CST_HIGH
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|width
operator|>
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|pedwarn_with_decl
argument_list|(
name|x
argument_list|,
literal|"width of `%s' exceeds its type"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|width
operator|==
literal|0
operator|&&
name|DECL_NAME
argument_list|(
name|x
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|x
argument_list|,
literal|"zero width for bit-field `%s'"
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Process valid field width.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
condition|)
block|{
specifier|register
name|int
name|width
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|DECL_FIELD_SIZE
argument_list|(
name|x
argument_list|)
operator|=
name|width
expr_stmt|;
name|DECL_BIT_FIELD
argument_list|(
name|x
argument_list|)
operator|=
literal|1
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|x
argument_list|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|width
operator|==
literal|0
condition|)
block|{
comment|/* field size 0 => force desired amount of alignment.  */
ifdef|#
directive|ifdef
name|EMPTY_FIELD_BOUNDARY
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|,
name|EMPTY_FIELD_BOUNDARY
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PCC_BITFIELD_TYPE_MATTERS
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|!=
name|error_mark_node
condition|)
block|{
name|int
name|min_align
init|=
operator|(
name|DECL_PACKED
argument_list|(
name|x
argument_list|)
condition|?
name|BITS_PER_UNIT
else|:
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|)
decl_stmt|;
comment|/* Non-bit-fields are aligned for their type, except packed 	     fields which require only BITS_PER_UNIT alignment.  */
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
operator|=
name|MAX
argument_list|(
name|DECL_ALIGN
argument_list|(
name|x
argument_list|)
argument_list|,
name|min_align
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now DECL_INITIAL is null on all members.  */
comment|/* Delete all duplicate fields from the fieldlist */
for|for
control|(
name|x
operator|=
name|fieldlist
init|;
name|x
operator|&&
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
condition|;
control|)
comment|/* Anonymous fields aren't duplicates.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|tree
name|y
init|=
name|fieldlist
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|y
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|y
operator|==
name|x
condition|)
break|break;
name|y
operator|=
name|TREE_CHAIN
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_NAME
argument_list|(
name|y
argument_list|)
operator|==
name|DECL_NAME
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
block|{
name|error_with_decl
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|,
literal|"duplicate member `%s'"
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* Now we have the nearly final fieldlist.  Record it,      then lay out the structure or union (including the fields).  */
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|fieldlist
expr_stmt|;
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Delete all zero-width bit-fields from the front of the fieldlist */
while|while
condition|(
name|fieldlist
operator|&&
name|DECL_INITIAL
argument_list|(
name|fieldlist
argument_list|)
condition|)
name|fieldlist
operator|=
name|TREE_CHAIN
argument_list|(
name|fieldlist
argument_list|)
expr_stmt|;
comment|/* Delete all such members from the rest of the fieldlist */
for|for
control|(
name|x
operator|=
name|fieldlist
init|;
name|x
condition|;
control|)
block|{
if|if
condition|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|&&
name|DECL_INITIAL
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
condition|)
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|TREE_CHAIN
argument_list|(
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
comment|/*  Now we have the truly final field list.       Store it in this type and in the variants.  */
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|fieldlist
expr_stmt|;
comment|/* If there are lots of fields, sort so we can look through them fast.      We arbitrarily consider 16 or more elts to be "a lot".  */
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|x
operator|=
name|fieldlist
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
block|{
if|if
condition|(
name|len
operator|>
literal|15
condition|)
break|break;
name|len
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|15
condition|)
block|{
name|tree
modifier|*
name|field_array
decl_stmt|;
name|char
modifier|*
name|space
decl_stmt|;
name|len
operator|+=
name|list_length
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* Use the same allocation policy here that make_node uses, to 	   ensure that this lives as long as the rest of the struct decl. 	   All decls in an inline function need to be saved.  */
if|if
condition|(
name|allocation_temporary_p
argument_list|()
condition|)
name|space
operator|=
name|savealloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
operator|+
name|len
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|space
operator|=
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lang_type
argument_list|)
operator|+
name|len
operator|*
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|=
operator|(
expr|struct
name|lang_type
operator|*
operator|)
name|space
expr_stmt|;
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|field_array
operator|=
operator|&
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
operator|->
name|elts
index|[
literal|0
index|]
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
name|fieldlist
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
name|field_array
index|[
name|len
operator|++
index|]
operator|=
name|x
expr_stmt|;
name|qsort
argument_list|(
name|field_array
argument_list|,
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|tree
argument_list|)
argument_list|,
name|field_decl_cmp
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|x
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|t
argument_list|)
init|;
name|x
condition|;
name|x
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|x
argument_list|)
control|)
block|{
name|TYPE_FIELDS
argument_list|(
name|x
argument_list|)
operator|=
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_LANG_SPECIFIC
argument_list|(
name|x
argument_list|)
operator|=
name|TYPE_LANG_SPECIFIC
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|x
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* Promote each bit-field's type to int if it is narrower than that.  */
for|for
control|(
name|x
operator|=
name|fieldlist
init|;
name|x
condition|;
name|x
operator|=
name|TREE_CHAIN
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|DECL_BIT_FIELD
argument_list|(
name|x
argument_list|)
operator|&&
operator|(
name|C_PROMOTING_INTEGER_TYPE_P
argument_list|(
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
argument_list|)
operator|||
name|DECL_FIELD_SIZE
argument_list|(
name|x
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
condition|)
block|{
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
decl_stmt|;
comment|/* Preserve unsignedness if traditional 	   or if not really getting any wider.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|flag_traditional
operator|||
operator|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|&&
name|DECL_FIELD_SIZE
argument_list|(
name|x
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
operator|)
condition|)
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|unsigned_type_node
expr_stmt|;
else|else
name|TREE_TYPE
argument_list|(
name|x
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
block|}
comment|/* If this structure or union completes the type of any previous      variable declaration, lay it out and output its rtl.  */
if|if
condition|(
name|current_binding_level
operator|->
name|n_incomplete
operator|!=
literal|0
condition|)
block|{
name|tree
name|decl
decl_stmt|;
for|for
control|(
name|decl
operator|=
name|current_binding_level
operator|->
name|names
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
block|{
if|if
condition|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
operator|==
name|t
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|!=
name|TYPE_DECL
condition|)
block|{
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This is a no-op in c-lang.c or something real in objc-actions.c.  */
name|maybe_objc_check_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
name|rest_of_decl_compilation
argument_list|(
name|decl
argument_list|,
name|NULL_PTR
argument_list|,
name|toplevel
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toplevel
condition|)
name|expand_decl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
operator|--
name|current_binding_level
operator|->
name|n_incomplete
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
block|{
name|tree
name|element
init|=
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|element
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|element
operator|=
name|TREE_TYPE
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|element
operator|==
name|t
condition|)
name|layout_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|resume_momentary
argument_list|(
name|old_momentary
argument_list|)
expr_stmt|;
comment|/* Finish debugging output for this type.  */
name|rest_of_type_compilation
argument_list|(
name|t
argument_list|,
name|toplevel
argument_list|)
expr_stmt|;
comment|/* The matching push is in start_struct.  */
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Lay out the type T, and its element type, and so on.  */
end_comment

begin_function
specifier|static
name|void
name|layout_array_type
parameter_list|(
name|t
parameter_list|)
name|tree
name|t
decl_stmt|;
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
condition|)
name|layout_array_type
argument_list|(
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|layout_type
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Begin compiling the definition of an enumeration type.    NAME is its name (or null if anonymous).    Returns the type object, as yet incomplete.    Also records info about it so that build_enumerator    may be used to declare the individual values as they are read.  */
end_comment

begin_function
name|tree
name|start_enum
parameter_list|(
name|name
parameter_list|)
name|tree
name|name
decl_stmt|;
block|{
specifier|register
name|tree
name|enumtype
init|=
literal|0
decl_stmt|;
comment|/* If this is the real definition for a previous forward reference,      fill in the contents in the same object that used to be the      forward reference.  */
if|if
condition|(
name|name
operator|!=
literal|0
condition|)
name|enumtype
operator|=
name|lookup_tag
argument_list|(
name|ENUMERAL_TYPE
argument_list|,
name|name
argument_list|,
name|current_binding_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* The corresponding pop_obstacks is in finish_enum.  */
name|push_obstacks_nochange
argument_list|()
expr_stmt|;
comment|/* If these symbols and types are global, make them permanent.  */
if|if
condition|(
name|current_binding_level
operator|==
name|global_binding_level
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
if|if
condition|(
name|enumtype
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|enumtype
argument_list|)
operator|!=
name|ENUMERAL_TYPE
condition|)
block|{
name|enumtype
operator|=
name|make_node
argument_list|(
name|ENUMERAL_TYPE
argument_list|)
expr_stmt|;
name|pushtag
argument_list|(
name|name
argument_list|,
name|enumtype
argument_list|)
expr_stmt|;
block|}
name|C_TYPE_BEING_DEFINED
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* This enum is a named one that has been declared already.  */
name|error
argument_list|(
literal|"redeclaration of `enum %s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Completely replace its old definition. 	 The old enumerators remain defined, however.  */
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|enum_next_value
operator|=
name|integer_zero_node
expr_stmt|;
name|enum_overflow
operator|=
literal|0
expr_stmt|;
return|return
name|enumtype
return|;
block|}
end_function

begin_comment
comment|/* After processing and defining all the values of an enumeration type,    install their decls in the enumeration type and finish it off.    ENUMTYPE is the type object and VALUES a list of decl-value pairs.    Returns ENUMTYPE.  */
end_comment

begin_function
name|tree
name|finish_enum
parameter_list|(
name|enumtype
parameter_list|,
name|values
parameter_list|)
specifier|register
name|tree
name|enumtype
decl_stmt|,
name|values
decl_stmt|;
block|{
specifier|register
name|tree
name|pair
decl_stmt|,
name|tem
decl_stmt|;
name|tree
name|minnode
init|=
literal|0
decl_stmt|,
name|maxnode
init|=
literal|0
decl_stmt|;
name|int
name|lowprec
decl_stmt|,
name|highprec
decl_stmt|,
name|precision
decl_stmt|;
name|int
name|toplevel
init|=
name|global_binding_level
operator|==
name|current_binding_level
decl_stmt|;
if|if
condition|(
name|in_parm_level_p
argument_list|()
condition|)
name|warning
argument_list|(
literal|"enum defined inside parms"
argument_list|)
expr_stmt|;
comment|/* Calculate the maximum value of any enumerator in this type.  */
if|if
condition|(
name|values
operator|==
name|error_mark_node
condition|)
name|minnode
operator|=
name|maxnode
operator|=
name|integer_zero_node
expr_stmt|;
else|else
for|for
control|(
name|pair
operator|=
name|values
init|;
name|pair
condition|;
name|pair
operator|=
name|TREE_CHAIN
argument_list|(
name|pair
argument_list|)
control|)
block|{
name|tree
name|value
init|=
name|TREE_VALUE
argument_list|(
name|pair
argument_list|)
decl_stmt|;
if|if
condition|(
name|pair
operator|==
name|values
condition|)
name|minnode
operator|=
name|maxnode
operator|=
name|TREE_VALUE
argument_list|(
name|pair
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|maxnode
argument_list|,
name|value
argument_list|)
condition|)
name|maxnode
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|tree_int_cst_lt
argument_list|(
name|value
argument_list|,
name|minnode
argument_list|)
condition|)
name|minnode
operator|=
name|value
expr_stmt|;
block|}
block|}
name|TYPE_MIN_VALUE
argument_list|(
name|enumtype
argument_list|)
operator|=
name|minnode
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|enumtype
argument_list|)
operator|=
name|maxnode
expr_stmt|;
comment|/* An enum can have some negative values; then it is signed.  */
name|TREE_UNSIGNED
argument_list|(
name|enumtype
argument_list|)
operator|=
name|tree_int_cst_sgn
argument_list|(
name|minnode
argument_list|)
operator|>=
literal|0
expr_stmt|;
comment|/* Determine the precision this type needs.  */
name|lowprec
operator|=
name|min_precision
argument_list|(
name|minnode
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|enumtype
argument_list|)
argument_list|)
expr_stmt|;
name|highprec
operator|=
name|min_precision
argument_list|(
name|maxnode
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|enumtype
argument_list|)
argument_list|)
expr_stmt|;
name|precision
operator|=
name|MAX
argument_list|(
name|lowprec
argument_list|,
name|highprec
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_short_enums
operator|||
name|precision
operator|>
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
comment|/* Use the width of the narrowest normal C type which is wide enough.  */
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|type_for_size
argument_list|(
name|precision
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
operator|=
literal|0
expr_stmt|;
name|layout_type
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|values
operator|!=
name|error_mark_node
condition|)
block|{
comment|/* Change the type of the enumerators to be the enum type. 	 Formerly this was done only for enums that fit in an int, 	 but the comment said it was done only for enums wider than int. 	 It seems necessary to do this for wide enums, 	 and best not to change what's done for ordinary narrower ones.  */
for|for
control|(
name|pair
operator|=
name|values
init|;
name|pair
condition|;
name|pair
operator|=
name|TREE_CHAIN
argument_list|(
name|pair
argument_list|)
control|)
block|{
name|TREE_TYPE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|pair
argument_list|)
argument_list|)
operator|=
name|enumtype
expr_stmt|;
name|DECL_SIZE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|pair
argument_list|)
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|pair
argument_list|)
argument_list|)
operator|!=
name|FUNCTION_DECL
condition|)
name|DECL_ALIGN
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|pair
argument_list|)
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
block|}
comment|/* Replace the decl nodes in VALUES with their names.  */
for|for
control|(
name|pair
operator|=
name|values
init|;
name|pair
condition|;
name|pair
operator|=
name|TREE_CHAIN
argument_list|(
name|pair
argument_list|)
control|)
name|TREE_PURPOSE
argument_list|(
name|pair
argument_list|)
operator|=
name|DECL_NAME
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
operator|=
name|values
expr_stmt|;
block|}
comment|/* Fix up all variant types of this enum type.  */
for|for
control|(
name|tem
operator|=
name|TYPE_MAIN_VARIANT
argument_list|(
name|enumtype
argument_list|)
init|;
name|tem
condition|;
name|tem
operator|=
name|TYPE_NEXT_VARIANT
argument_list|(
name|tem
argument_list|)
control|)
block|{
name|TYPE_VALUES
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_VALUES
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MIN_VALUE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_MIN_VALUE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MAX_VALUE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_MAX_VALUE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_SIZE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_SIZE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_MODE
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_MODE
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_PRECISION
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_PRECISION
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TYPE_ALIGN
argument_list|(
name|tem
argument_list|)
operator|=
name|TYPE_ALIGN
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
name|TREE_UNSIGNED
argument_list|(
name|tem
argument_list|)
operator|=
name|TREE_UNSIGNED
argument_list|(
name|enumtype
argument_list|)
expr_stmt|;
block|}
comment|/* Finish debugging output for this type.  */
name|rest_of_type_compilation
argument_list|(
name|enumtype
argument_list|,
name|toplevel
argument_list|)
expr_stmt|;
comment|/* This matches a push in start_enum.  */
name|pop_obstacks
argument_list|()
expr_stmt|;
return|return
name|enumtype
return|;
block|}
end_function

begin_comment
comment|/* Build and install a CONST_DECL for one value of the    current enumeration type (one that was begun with start_enum).    Return a tree-list containing the CONST_DECL and its value.    Assignment of sequential values by default is handled here.  */
end_comment

begin_function
name|tree
name|build_enumerator
parameter_list|(
name|name
parameter_list|,
name|value
parameter_list|)
name|tree
name|name
decl_stmt|,
name|value
decl_stmt|;
block|{
specifier|register
name|tree
name|decl
decl_stmt|,
name|type
decl_stmt|;
comment|/* Validate and default VALUE.  */
comment|/* Remove no-op casts from the value.  */
if|if
condition|(
name|value
condition|)
name|STRIP_TYPE_NOPS
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|value
operator|=
name|default_conversion
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|constant_expression_warning
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"enumerator value for `%s' not integer constant"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Default based on previous value.  */
comment|/* It should no longer be possible to have NON_LVALUE_EXPR      in the default.  */
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
name|value
operator|=
name|enum_next_value
expr_stmt|;
if|if
condition|(
name|enum_overflow
condition|)
name|error
argument_list|(
literal|"overflow in enumeration values"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|int_fits_type_p
argument_list|(
name|value
argument_list|,
name|integer_type_node
argument_list|)
condition|)
block|{
name|pedwarn
argument_list|(
literal|"ANSI C restricts enumerator values to range of `int'"
argument_list|)
expr_stmt|;
name|value
operator|=
name|integer_zero_node
expr_stmt|;
block|}
comment|/* Set basis for default for next value.  */
name|enum_next_value
operator|=
name|build_binary_op
argument_list|(
name|PLUS_EXPR
argument_list|,
name|value
argument_list|,
name|integer_one_node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|enum_overflow
operator|=
name|tree_int_cst_lt
argument_list|(
name|enum_next_value
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Now create a declaration for the enum value name.  */
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|type
operator|=
name|type_for_size
argument_list|(
name|MAX
argument_list|(
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
argument_list|)
argument_list|,
operator|(
operator|(
name|flag_traditional
operator|||
name|TYPE_PRECISION
argument_list|(
name|type
argument_list|)
operator|>=
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
operator|&&
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|decl
operator|=
name|build_decl
argument_list|(
name|CONST_DECL
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
name|value
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|value
argument_list|)
operator|=
name|type
expr_stmt|;
name|pushdecl
argument_list|(
name|decl
argument_list|)
expr_stmt|;
return|return
name|saveable_tree_cons
argument_list|(
name|decl
argument_list|,
name|value
argument_list|,
name|NULL_TREE
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the FUNCTION_DECL for a function definition.    DECLSPECS and DECLARATOR are the parts of the declaration;    they describe the function's name and the type it returns,    but twisted together in a fashion that parallels the syntax of C.     This function creates a binding context for the function body    as well as setting up the FUNCTION_DECL in current_function_decl.     Returns 1 on success.  If the DECLARATOR is not suitable for a function    (it defines a datum instead), we return 0, which tells    yyparse to report a parse error.     NESTED is nonzero for a function nested within another function.  */
end_comment

begin_function
name|int
name|start_function
parameter_list|(
name|declspecs
parameter_list|,
name|declarator
parameter_list|,
name|nested
parameter_list|)
name|tree
name|declarator
decl_stmt|,
name|declspecs
decl_stmt|;
name|int
name|nested
decl_stmt|;
block|{
name|tree
name|decl1
decl_stmt|,
name|old_decl
decl_stmt|;
name|tree
name|restype
decl_stmt|;
name|int
name|old_immediate_size_expand
init|=
name|immediate_size_expand
decl_stmt|;
name|current_function_returns_value
operator|=
literal|0
expr_stmt|;
comment|/* Assume, until we see it does. */
name|current_function_returns_null
operator|=
literal|0
expr_stmt|;
name|warn_about_return_type
operator|=
literal|0
expr_stmt|;
name|current_extern_inline
operator|=
literal|0
expr_stmt|;
name|c_function_varargs
operator|=
literal|0
expr_stmt|;
name|named_labels
operator|=
literal|0
expr_stmt|;
name|shadowed_labels
operator|=
literal|0
expr_stmt|;
comment|/* Don't expand any sizes in the return type of the function.  */
name|immediate_size_expand
operator|=
literal|0
expr_stmt|;
name|decl1
operator|=
name|grokdeclarator
argument_list|(
name|declarator
argument_list|,
name|declspecs
argument_list|,
name|FUNCDEF
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If the declarator is not suitable for a function definition,      cause a syntax error.  */
if|if
condition|(
name|decl1
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|announce_function
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"return-type is an incomplete type"
argument_list|)
expr_stmt|;
comment|/* Make it return void instead.  */
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|build_function_type
argument_list|(
name|void_type_node
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|warn_about_return_type
condition|)
name|warning
argument_list|(
literal|"return-type defaults to `int'"
argument_list|)
expr_stmt|;
comment|/* Save the parm names or decls from this function's declarator      where store_parm_decls will find them.  */
name|current_function_parms
operator|=
name|last_function_parms
expr_stmt|;
name|current_function_parm_tags
operator|=
name|last_function_parm_tags
expr_stmt|;
comment|/* Make the init_value nonzero so pushdecl knows this is not tentative.      error_mark_node is replaced below (in poplevel) with the BLOCK.  */
name|DECL_INITIAL
argument_list|(
name|decl1
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
comment|/* If this definition isn't a prototype and we had a prototype declaration      before, copy the arg type info from that prototype.      But not if what we had before was a builtin function.  */
name|old_decl
operator|=
name|lookup_name_current_level
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_decl
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_decl
argument_list|)
argument_list|)
operator|==
name|FUNCTION_TYPE
operator|&&
operator|!
name|DECL_BUILT_IN
argument_list|(
name|old_decl
argument_list|)
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_decl
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|old_decl
argument_list|)
expr_stmt|;
name|current_function_prototype_file
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|old_decl
argument_list|)
expr_stmt|;
name|current_function_prototype_line
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|old_decl
argument_list|)
expr_stmt|;
block|}
comment|/* If there is no explicit declaration, look for any out-of-scope implicit      declarations.  */
if|if
condition|(
name|old_decl
operator|==
literal|0
condition|)
name|old_decl
operator|=
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Optionally warn of old-fashioned def with no previous prototype.  */
if|if
condition|(
name|warn_strict_prototypes
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl1
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|!
operator|(
name|old_decl
operator|!=
literal|0
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_decl
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|warning
argument_list|(
literal|"function declaration isn't a prototype"
argument_list|)
expr_stmt|;
comment|/* Optionally warn of any global def with no previous prototype.  */
elseif|else
if|if
condition|(
name|warn_missing_prototypes
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
operator|&&
operator|!
operator|(
name|old_decl
operator|!=
literal|0
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_decl
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
name|strcmp
argument_list|(
literal|"main"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl1
argument_list|,
literal|"no previous prototype for `%s'"
argument_list|)
expr_stmt|;
comment|/* Optionally warn of any def with no previous prototype      if the function has already been used.  */
elseif|else
if|if
condition|(
name|warn_missing_prototypes
operator|&&
name|old_decl
operator|!=
literal|0
operator|&&
name|TREE_USED
argument_list|(
name|old_decl
argument_list|)
operator|&&
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|old_decl
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|warning_with_decl
argument_list|(
name|decl1
argument_list|,
literal|"`%s' was used with no prototype before its definition"
argument_list|)
expr_stmt|;
comment|/* Optionally warn of any global def with no previous declaration.  */
elseif|else
if|if
condition|(
name|warn_missing_declarations
operator|&&
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
operator|&&
name|old_decl
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
literal|"main"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl1
argument_list|,
literal|"no previous declaration for `%s'"
argument_list|)
expr_stmt|;
comment|/* Optionally warn of any def with no previous declaration      if the function has already been used.  */
elseif|else
if|if
condition|(
name|warn_missing_declarations
operator|&&
name|old_decl
operator|!=
literal|0
operator|&&
name|TREE_USED
argument_list|(
name|old_decl
argument_list|)
operator|&&
name|old_decl
operator|==
name|IDENTIFIER_IMPLICIT_DECL
argument_list|(
name|DECL_NAME
argument_list|(
name|decl1
argument_list|)
argument_list|)
condition|)
name|warning_with_decl
argument_list|(
name|decl1
argument_list|,
literal|"`%s' was used with no declaration before its definition"
argument_list|)
expr_stmt|;
comment|/* This is a definition, not a reference.      So normally clear DECL_EXTERNAL.      However, `extern inline' acts like a declaration      except for defining how to inline.  So set DECL_EXTERNAL in that case.  */
name|DECL_EXTERNAL
argument_list|(
name|decl1
argument_list|)
operator|=
name|current_extern_inline
expr_stmt|;
comment|/* This function exists in static storage.      (This does not mean `static' in the C sense!)  */
name|TREE_STATIC
argument_list|(
name|decl1
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* A nested function is not global.  */
if|if
condition|(
name|current_function_decl
operator|!=
literal|0
condition|)
name|TREE_PUBLIC
argument_list|(
name|decl1
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Record the decl so that the function name is defined.      If we already have a decl for this name, and it is a FUNCTION_DECL,      use the old decl.  */
name|current_function_decl
operator|=
name|pushdecl
argument_list|(
name|decl1
argument_list|)
expr_stmt|;
name|pushlevel
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|declare_parm_level
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|subblocks_tag_transparent
operator|=
literal|1
expr_stmt|;
name|make_function_rtl
argument_list|(
name|current_function_decl
argument_list|)
expr_stmt|;
name|restype
operator|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Promote the value to int before returning it.  */
if|if
condition|(
name|C_PROMOTING_INTEGER_TYPE_P
argument_list|(
name|restype
argument_list|)
condition|)
block|{
comment|/* It retains unsignedness if traditional 	 or if not really getting wider.  */
if|if
condition|(
name|TREE_UNSIGNED
argument_list|(
name|restype
argument_list|)
operator|&&
operator|(
name|flag_traditional
operator|||
operator|(
name|TYPE_PRECISION
argument_list|(
name|restype
argument_list|)
operator|==
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
operator|)
operator|)
condition|)
name|restype
operator|=
name|unsigned_type_node
expr_stmt|;
else|else
name|restype
operator|=
name|integer_type_node
expr_stmt|;
block|}
name|DECL_RESULT
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|build_decl
argument_list|(
name|RESULT_DECL
argument_list|,
name|NULL_TREE
argument_list|,
name|restype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nested
condition|)
comment|/* Allocate further tree nodes temporarily during compilation        of this function only.  */
name|temporary_allocation
argument_list|()
expr_stmt|;
comment|/* If this fcn was already referenced via a block-scope `extern' decl      (or an implicit decl), propagate certain information about the usage.  */
if|if
condition|(
name|TREE_ADDRESSABLE
argument_list|(
name|DECL_ASSEMBLER_NAME
argument_list|(
name|current_function_decl
argument_list|)
argument_list|)
condition|)
name|TREE_ADDRESSABLE
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|1
expr_stmt|;
name|immediate_size_expand
operator|=
name|old_immediate_size_expand
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Record that this function is going to be a varargs function.    This is called before store_parm_decls, which is too early    to call mark_varargs directly.  */
end_comment

begin_function
name|void
name|c_mark_varargs
parameter_list|()
block|{
name|c_function_varargs
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store the parameter declarations into the current function declaration.    This is called after parsing the parameter declarations, before    digesting the body of the function.     For an old-style definition, modify the function's type    to specify at least the number of arguments.  */
end_comment

begin_function
name|void
name|store_parm_decls
parameter_list|()
block|{
specifier|register
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
specifier|register
name|tree
name|parm
decl_stmt|;
comment|/* This is either a chain of PARM_DECLs (if a prototype was used)      or a list of IDENTIFIER_NODEs (for an old-fashioned C definition).  */
name|tree
name|specparms
init|=
name|current_function_parms
decl_stmt|;
comment|/* This is a list of types declared among parms in a prototype.  */
name|tree
name|parmtags
init|=
name|current_function_parm_tags
decl_stmt|;
comment|/* This is a chain of PARM_DECLs from old-style parm declarations.  */
specifier|register
name|tree
name|parmdecls
init|=
name|getdecls
argument_list|()
decl_stmt|;
comment|/* This is a chain of any other decls that came in among the parm      declarations.  If a parm is declared with  enum {foo, bar} x;      then CONST_DECLs for foo and bar are put here.  */
name|tree
name|nonparms
init|=
literal|0
decl_stmt|;
comment|/* Nonzero if this definition is written with a prototype.  */
name|int
name|prototype
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|specparms
operator|!=
literal|0
operator|&&
name|TREE_CODE
argument_list|(
name|specparms
argument_list|)
operator|!=
name|TREE_LIST
condition|)
block|{
comment|/* This case is when the function was defined with an ANSI prototype. 	 The parms already have decls, so we need not do anything here 	 except record them as in effect 	 and complain if any redundant old-style parm decls were written.  */
specifier|register
name|tree
name|next
decl_stmt|;
name|tree
name|others
init|=
literal|0
decl_stmt|;
name|prototype
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|parmdecls
operator|!=
literal|0
condition|)
block|{
name|tree
name|decl
decl_stmt|,
name|link
decl_stmt|;
name|error_with_decl
argument_list|(
name|fndecl
argument_list|,
literal|"parm types given both in parmlist and separately"
argument_list|)
expr_stmt|;
comment|/* Get rid of the erroneous decls; don't keep them on 	     the list of parms, since they might not be PARM_DECLs.  */
for|for
control|(
name|decl
operator|=
name|current_binding_level
operator|->
name|names
init|;
name|decl
condition|;
name|decl
operator|=
name|TREE_CHAIN
argument_list|(
name|decl
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|link
operator|=
name|current_binding_level
operator|->
name|shadowed
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|IDENTIFIER_LOCAL_VALUE
argument_list|(
name|TREE_PURPOSE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
name|current_binding_level
operator|->
name|names
operator|=
literal|0
expr_stmt|;
name|current_binding_level
operator|->
name|shadowed
operator|=
literal|0
expr_stmt|;
block|}
name|specparms
operator|=
name|nreverse
argument_list|(
name|specparms
argument_list|)
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|specparms
init|;
name|parm
condition|;
name|parm
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|==
literal|0
condition|)
name|error_with_decl
argument_list|(
name|parm
argument_list|,
literal|"parameter name omitted"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|error_with_decl
argument_list|(
name|parm
argument_list|,
literal|"parameter `%s' declared void"
argument_list|)
expr_stmt|;
comment|/* Change the type to error_mark_node so this parameter 		     will be ignored by assign_parms.  */
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
name|pushdecl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If we find an enum constant or a type tag, 		 put it aside for the moment.  */
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
literal|0
expr_stmt|;
name|others
operator|=
name|chainon
argument_list|(
name|others
argument_list|,
name|parm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get the decls in their original chain order 	 and record in the function.  */
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|getdecls
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* If this function takes a variable number of arguments, 	 add a phony parameter to the end of the parm list, 	 to represent the position of the first unnamed argument.  */
block|if (TREE_VALUE (tree_last (TYPE_ARG_TYPES (TREE_TYPE (fndecl)))) 	  != void_type_node) 	{ 	  tree dummy = build_decl (PARM_DECL, NULL_TREE, void_type_node);
comment|/* Let's hope the address of the unnamed parm 	     won't depend on its type.  */
block|TREE_TYPE (dummy) = integer_type_node; 	  DECL_ARG_TYPE (dummy) = integer_type_node; 	  DECL_ARGUMENTS (fndecl) 	    = chainon (DECL_ARGUMENTS (fndecl), dummy); 	}
endif|#
directive|endif
comment|/* Now pushdecl the enum constants.  */
for|for
control|(
name|parm
operator|=
name|others
init|;
name|parm
condition|;
name|parm
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|!=
name|PARM_DECL
condition|)
name|pushdecl
argument_list|(
name|parm
argument_list|)
expr_stmt|;
block|}
name|storetags
argument_list|(
name|chainon
argument_list|(
name|parmtags
argument_list|,
name|gettags
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* SPECPARMS is an identifier list--a chain of TREE_LIST nodes 	 each with a parm name as the TREE_VALUE.  	 PARMDECLS is a chain of declarations for parameters. 	 Warning! It can also contain CONST_DECLs which are not parameters 	 but are names of enumerators of any enum types 	 declared among the parameters.  	 First match each formal parameter name with its declaration. 	 Associate decls with the names and store the decls 	 into the TREE_PURPOSE slots.  */
for|for
control|(
name|parm
operator|=
name|parmdecls
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
name|DECL_RESULT
argument_list|(
name|parm
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|specparms
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
specifier|register
name|tree
name|tail
decl_stmt|,
name|found
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|fndecl
argument_list|,
literal|"parameter name missing from parameter list"
argument_list|)
expr_stmt|;
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* See if any of the parmdecls specifies this parm by name. 	     Ignore any enumerator decls.  */
for|for
control|(
name|tail
operator|=
name|parmdecls
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|tail
argument_list|)
operator|==
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|tail
argument_list|)
operator|==
name|PARM_DECL
condition|)
block|{
name|found
operator|=
name|tail
expr_stmt|;
break|break;
block|}
comment|/* If declaration already marked, we have a duplicate name. 	     Complain, and don't use this decl twice.   */
if|if
condition|(
name|found
operator|&&
name|DECL_RESULT
argument_list|(
name|found
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|found
argument_list|,
literal|"multiple parameters named `%s'"
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If the declaration says "void", complain and ignore it.  */
if|if
condition|(
name|found
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|found
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|error_with_decl
argument_list|(
name|found
argument_list|,
literal|"parameter `%s' declared void"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|found
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|found
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|layout_decl
argument_list|(
name|found
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Traditionally, a parm declared float is actually a double.  */
if|if
condition|(
name|found
operator|&&
name|flag_traditional
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|found
argument_list|)
argument_list|)
operator|==
name|float_type_node
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|found
argument_list|)
operator|=
name|double_type_node
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|found
argument_list|)
operator|=
name|double_type_node
expr_stmt|;
name|layout_decl
argument_list|(
name|found
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If no declaration found, default to int.  */
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|found
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|found
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|found
argument_list|)
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|found
argument_list|)
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_warnings
condition|)
name|warning_with_decl
argument_list|(
name|found
argument_list|,
literal|"type of `%s' defaults to `int'"
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|found
argument_list|)
expr_stmt|;
block|}
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
operator|=
name|found
expr_stmt|;
comment|/* Mark this decl as "already found" -- see test, above. 	     It is safe to use DECL_RESULT for this 	     since it is not used in PARM_DECLs or CONST_DECLs.  */
name|DECL_RESULT
argument_list|(
name|found
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Put anything which is on the parmdecls chain and which is 	 not a PARM_DECL onto the list NONPARMS.  (The types of 	 non-parm things which might appear on the list include 	 enumerators and NULL-named TYPE_DECL nodes.) Complain about 	 any actual PARM_DECLs not matched with any names.  */
name|nonparms
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|parmdecls
init|;
name|parm
condition|;
control|)
block|{
name|tree
name|next
init|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|parm
argument_list|)
operator|!=
name|PARM_DECL
condition|)
name|nonparms
operator|=
name|chainon
argument_list|(
name|nonparms
argument_list|,
name|parm
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Complain about args with incomplete types.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|parm
argument_list|,
literal|"parameter `%s' has incomplete type"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|DECL_RESULT
argument_list|(
name|parm
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|parm
argument_list|,
literal|"declaration for parameter `%s' but no such parameter"
argument_list|)
expr_stmt|;
comment|/* Pretend the parameter was not missing. 		     This gets us to a standard state and minimizes 		     further error messages.  */
name|specparms
operator|=
name|chainon
argument_list|(
name|specparms
argument_list|,
name|tree_cons
argument_list|(
name|parm
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|parm
operator|=
name|next
expr_stmt|;
block|}
comment|/* Chain the declarations together in the order of the list of names.  */
comment|/* Store that chain in the function decl, replacing the list of names.  */
name|parm
operator|=
name|specparms
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|{
specifier|register
name|tree
name|last
decl_stmt|;
for|for
control|(
name|last
operator|=
literal|0
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
if|if
condition|(
name|last
operator|==
literal|0
condition|)
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|last
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* If there was a previous prototype, 	 set the DECL_ARG_TYPE of each argument according to 	 the type previously specified, and report any mismatches.  */
if|if
condition|(
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|type
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|,
name|type
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
init|;
name|parm
operator|||
operator|(
name|type
operator|&&
operator|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|void_type_node
operator|)
operator|)
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|,
name|type
operator|=
name|TREE_CHAIN
argument_list|(
name|type
argument_list|)
control|)
block|{
if|if
condition|(
name|parm
operator|==
literal|0
operator|||
name|type
operator|==
literal|0
operator|||
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|error
argument_list|(
literal|"number of arguments doesn't match prototype"
argument_list|)
expr_stmt|;
name|error_with_file_and_line
argument_list|(
name|current_function_prototype_file
argument_list|,
name|current_function_prototype_line
argument_list|,
literal|"prototype declaration"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Type for passing arg must be consistent 		 with that declared for the arg.  */
if|if
condition|(
operator|!
name|comptypes
argument_list|(
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Adjust argument to match prototype.  E.g. a previous 			 `int foo(float);' prototype causes 			 `int foo(x) float x; {...}' to be treated like 			 `int foo(float x) {...}'.  This is particularly 			 useful for argument types like uid_t.  */
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROMOTE_PROTOTYPES
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|INTEGER_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|ENUMERAL_TYPE
operator|)
operator|&&
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|<
name|TYPE_PRECISION
argument_list|(
name|integer_type_node
argument_list|)
condition|)
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pedantic
condition|)
block|{
name|pedwarn
argument_list|(
literal|"promoted argument `%s' doesn't match prototype"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|warning_with_file_and_line
argument_list|(
name|current_function_prototype_file
argument_list|,
name|current_function_prototype_line
argument_list|,
literal|"prototype declaration"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If -traditional, allow `int' argument to match 		     `unsigned' prototype.  */
elseif|else
if|if
condition|(
operator|!
operator|(
name|flag_traditional
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|integer_type_node
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_VALUE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|unsigned_type_node
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"argument `%s' doesn't match prototype"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|error_with_file_and_line
argument_list|(
name|current_function_prototype_file
argument_list|,
name|current_function_prototype_line
argument_list|,
literal|"prototype declaration"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Otherwise, create a prototype that would match.  */
else|else
block|{
name|tree
name|actual
init|=
literal|0
decl_stmt|,
name|last
init|=
literal|0
decl_stmt|,
name|type
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
name|type
operator|=
name|perm_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|DECL_ARG_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|type
expr_stmt|;
else|else
name|actual
operator|=
name|type
expr_stmt|;
name|last
operator|=
name|type
expr_stmt|;
block|}
name|type
operator|=
name|perm_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|,
name|NULL_TREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
condition|)
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|type
expr_stmt|;
else|else
name|actual
operator|=
name|type
expr_stmt|;
comment|/* We are going to assign a new value for the TYPE_ACTUAL_ARG_TYPES 	     of the type of this function, but we need to avoid having this 	     affect the types of other similarly-typed functions, so we must 	     first force the generation of an identical (but separate) type 	     node for the relevant function type.  The new node we create 	     will be a variant of the main variant of the original function 	     type.  */
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
operator|=
name|build_type_copy
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_ACTUAL_ARG_TYPES
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|actual
expr_stmt|;
block|}
comment|/* Now store the final chain of decls for the arguments 	 as the decl-chain of the current lexical scope. 	 Put the enumerators in as well, at the front so that 	 DECL_ARGUMENTS is not modified.  */
name|storedecls
argument_list|(
name|chainon
argument_list|(
name|nonparms
argument_list|,
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure the binding level for the top of the function body      gets a BLOCK if there are any in the function.      Otherwise, the dbx output is wrong.  */
name|keep_next_if_subblocks
operator|=
literal|1
expr_stmt|;
comment|/* ??? This might be an improvement,      but needs to be thought about some more.  */
if|#
directive|if
literal|0
block|keep_next_level_flag = 1;
endif|#
directive|endif
comment|/* Write a record describing this function definition to the prototypes      file (if requested).  */
name|gen_aux_info_record
argument_list|(
name|fndecl
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|prototype
argument_list|)
expr_stmt|;
comment|/* Initialize the RTL code for the function.  */
name|init_function_start
argument_list|(
name|fndecl
argument_list|,
name|input_filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
comment|/* If this is a varargs function, inform function.c.  */
if|if
condition|(
name|c_function_varargs
condition|)
name|mark_varargs
argument_list|()
expr_stmt|;
comment|/* Declare __FUNCTION__ and __PRETTY_FUNCTION__ for this function.  */
name|declare_function_name
argument_list|()
expr_stmt|;
comment|/* Set up parameters and prepare for return, for the function.  */
name|expand_function_start
argument_list|(
name|fndecl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If this function is `main', emit a call to `__main'      to run global initializers, etc.  */
if|if
condition|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
literal|"main"
argument_list|)
operator|==
literal|0
operator|&&
name|DECL_CONTEXT
argument_list|(
name|fndecl
argument_list|)
operator|==
name|NULL_TREE
condition|)
name|expand_main_function
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* SPECPARMS is an identifier list--a chain of TREE_LIST nodes    each with a parm name as the TREE_VALUE.  A null pointer as TREE_VALUE    stands for an ellipsis in the identifier list.     PARMLIST is the data returned by get_parm_info for the    parmlist that follows the semicolon.     We return a value of the same sort that get_parm_info returns,    except that it describes the combination of identifiers and parmlist.  */
end_comment

begin_function
name|tree
name|combine_parm_decls
parameter_list|(
name|specparms
parameter_list|,
name|parmlist
parameter_list|,
name|void_at_end
parameter_list|)
name|tree
name|specparms
decl_stmt|,
name|parmlist
decl_stmt|;
name|int
name|void_at_end
decl_stmt|;
block|{
specifier|register
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
specifier|register
name|tree
name|parm
decl_stmt|;
name|tree
name|parmdecls
init|=
name|TREE_PURPOSE
argument_list|(
name|parmlist
argument_list|)
decl_stmt|;
comment|/* This is a chain of any other decls that came in among the parm      declarations.  They were separated already by get_parm_info,      so we just need to keep them separate.  */
name|tree
name|nonparms
init|=
name|TREE_VALUE
argument_list|(
name|parmlist
argument_list|)
decl_stmt|;
name|tree
name|types
init|=
literal|0
decl_stmt|;
for|for
control|(
name|parm
operator|=
name|parmdecls
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
name|DECL_RESULT
argument_list|(
name|parm
argument_list|)
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|parm
operator|=
name|specparms
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
block|{
specifier|register
name|tree
name|tail
decl_stmt|,
name|found
init|=
name|NULL
decl_stmt|;
comment|/* See if any of the parmdecls specifies this parm by name.  */
for|for
control|(
name|tail
operator|=
name|parmdecls
init|;
name|tail
condition|;
name|tail
operator|=
name|TREE_CHAIN
argument_list|(
name|tail
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|tail
argument_list|)
operator|==
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
name|found
operator|=
name|tail
expr_stmt|;
break|break;
block|}
comment|/* If declaration already marked, we have a duplicate name. 	 Complain, and don't use this decl twice.   */
if|if
condition|(
name|found
operator|&&
name|DECL_RESULT
argument_list|(
name|found
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|found
argument_list|,
literal|"multiple parameters named `%s'"
argument_list|)
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If the declaration says "void", complain and ignore it.  */
if|if
condition|(
name|found
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|found
argument_list|)
argument_list|)
operator|==
name|void_type_node
condition|)
block|{
name|error_with_decl
argument_list|(
name|found
argument_list|,
literal|"parameter `%s' declared void"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|found
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|found
argument_list|)
operator|=
name|integer_type_node
expr_stmt|;
name|layout_decl
argument_list|(
name|found
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Traditionally, a parm declared float is actually a double.  */
if|if
condition|(
name|found
operator|&&
name|flag_traditional
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|found
argument_list|)
argument_list|)
operator|==
name|float_type_node
condition|)
block|{
name|TREE_TYPE
argument_list|(
name|found
argument_list|)
operator|=
name|double_type_node
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|found
argument_list|)
operator|=
name|double_type_node
expr_stmt|;
name|layout_decl
argument_list|(
name|found
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If no declaration found, default to int.  */
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|found
operator|=
name|build_decl
argument_list|(
name|PARM_DECL
argument_list|,
name|TREE_VALUE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|integer_type_node
argument_list|)
expr_stmt|;
name|DECL_ARG_TYPE
argument_list|(
name|found
argument_list|)
operator|=
name|TREE_TYPE
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|DECL_SOURCE_LINE
argument_list|(
name|found
argument_list|)
operator|=
name|DECL_SOURCE_LINE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|DECL_SOURCE_FILE
argument_list|(
name|found
argument_list|)
operator|=
name|DECL_SOURCE_FILE
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|error_with_decl
argument_list|(
name|found
argument_list|,
literal|"type of parameter `%s' is not declared"
argument_list|)
expr_stmt|;
name|pushdecl
argument_list|(
name|found
argument_list|)
expr_stmt|;
block|}
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
operator|=
name|found
expr_stmt|;
comment|/* Mark this decl as "already found" -- see test, above. 	 It is safe to use DECL_RESULT for this 	 since it is not used in PARM_DECLs or CONST_DECLs.  */
name|DECL_RESULT
argument_list|(
name|found
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
comment|/* Complain about any actual PARM_DECLs not matched with any names.  */
for|for
control|(
name|parm
operator|=
name|parmdecls
init|;
name|parm
condition|;
control|)
block|{
name|tree
name|next
init|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
decl_stmt|;
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Complain about args with incomplete types.  */
if|if
condition|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|parm
argument_list|,
literal|"parameter `%s' has incomplete type"
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
block|}
if|if
condition|(
name|DECL_RESULT
argument_list|(
name|parm
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_decl
argument_list|(
name|parm
argument_list|,
literal|"declaration for parameter `%s' but no such parameter"
argument_list|)
expr_stmt|;
comment|/* Pretend the parameter was not missing. 	     This gets us to a standard state and minimizes 	     further error messages.  */
name|specparms
operator|=
name|chainon
argument_list|(
name|specparms
argument_list|,
name|tree_cons
argument_list|(
name|parm
argument_list|,
name|NULL_TREE
argument_list|,
name|NULL_TREE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|parm
operator|=
name|next
expr_stmt|;
block|}
comment|/* Chain the declarations together in the order of the list of names.      At the same time, build up a list of their types, in reverse order.  */
name|parm
operator|=
name|specparms
expr_stmt|;
name|parmdecls
operator|=
literal|0
expr_stmt|;
block|{
specifier|register
name|tree
name|last
decl_stmt|;
for|for
control|(
name|last
operator|=
literal|0
init|;
name|parm
condition|;
name|parm
operator|=
name|TREE_CHAIN
argument_list|(
name|parm
argument_list|)
control|)
if|if
condition|(
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
if|if
condition|(
name|last
operator|==
literal|0
condition|)
name|parmdecls
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
else|else
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|last
operator|=
name|TREE_PURPOSE
argument_list|(
name|parm
argument_list|)
expr_stmt|;
name|TREE_CHAIN
argument_list|(
name|last
argument_list|)
operator|=
literal|0
expr_stmt|;
name|types
operator|=
name|saveable_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|TREE_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|types
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|void_at_end
condition|)
return|return
name|saveable_tree_cons
argument_list|(
name|parmdecls
argument_list|,
name|nonparms
argument_list|,
name|nreverse
argument_list|(
name|saveable_tree_cons
argument_list|(
name|NULL_TREE
argument_list|,
name|void_type_node
argument_list|,
name|types
argument_list|)
argument_list|)
argument_list|)
return|;
return|return
name|saveable_tree_cons
argument_list|(
name|parmdecls
argument_list|,
name|nonparms
argument_list|,
name|nreverse
argument_list|(
name|types
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Finish up a function declaration and compile that function    all the way to assembler language output.  The free the storage    for the function definition.     This is called after parsing the body of the function definition.     NESTED is nonzero if the function being finished is nested in another.  */
end_comment

begin_function
name|void
name|finish_function
parameter_list|(
name|nested
parameter_list|)
name|int
name|nested
decl_stmt|;
block|{
specifier|register
name|tree
name|fndecl
init|=
name|current_function_decl
decl_stmt|;
comment|/*  TREE_READONLY (fndecl) = 1;     This caused&foo to be of type ptr-to-const-function     which then got a warning when stored in a ptr-to-function variable.  */
name|poplevel
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BLOCK_SUPERCONTEXT
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|fndecl
expr_stmt|;
comment|/* Must mark the RESULT_DECL as being in this function.  */
name|DECL_CONTEXT
argument_list|(
name|DECL_RESULT
argument_list|(
name|fndecl
argument_list|)
argument_list|)
operator|=
name|fndecl
expr_stmt|;
comment|/* Obey `register' declarations if `setjmp' is called in this fn.  */
if|if
condition|(
name|flag_traditional
operator|&&
name|current_function_calls_setjmp
condition|)
block|{
name|setjmp_protect
argument_list|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
argument_list|)
expr_stmt|;
name|setjmp_protect_args
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEFAULT_MAIN_RETURN
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|,
literal|"main"
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|integer_type_node
condition|)
name|warning_with_decl
argument_list|(
name|fndecl
argument_list|,
literal|"return type of `%s' is not `int'"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Make it so that `main' always returns success by default.  */
name|DEFAULT_MAIN_RETURN
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Generate rtl for function exit.  */
name|expand_function_end
argument_list|(
name|input_filename
argument_list|,
name|lineno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* So we can tell if jump_optimize sets it to 1.  */
name|can_reach_end
operator|=
literal|0
expr_stmt|;
comment|/* Run the optimizers and output the assembler code for this function.  */
name|rest_of_compilation
argument_list|(
name|fndecl
argument_list|)
expr_stmt|;
name|current_function_returns_null
operator||=
name|can_reach_end
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|current_function_returns_null
condition|)
name|warning
argument_list|(
literal|"`noreturn' function does return"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warn_return_type
operator|&&
name|can_reach_end
operator|&&
name|TYPE_MAIN_VARIANT
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|void_type_node
condition|)
comment|/* If this function returns non-void and control can drop through,        complain.  */
name|warning
argument_list|(
literal|"control reaches end of non-void function"
argument_list|)
expr_stmt|;
comment|/* With just -W, complain only if function returns both with      and without a value.  */
elseif|else
if|if
condition|(
name|extra_warnings
operator|&&
name|current_function_returns_value
operator|&&
name|current_function_returns_null
condition|)
name|warning
argument_list|(
literal|"this function may return with or without a value"
argument_list|)
expr_stmt|;
comment|/* If requested, warn about function definitions where the function will      return a value (usually of some struct or union type) which itself will      take up a lot of stack space.  */
if|if
condition|(
name|warn_larger_than
operator|&&
operator|!
name|DECL_EXTERNAL
argument_list|(
name|fndecl
argument_list|)
operator|&&
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
condition|)
block|{
specifier|register
name|tree
name|ret_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|fndecl
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret_type
condition|)
block|{
specifier|register
name|tree
name|ret_type_size
init|=
name|TYPE_SIZE
argument_list|(
name|ret_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|ret_type_size
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
name|unsigned
name|units
init|=
name|TREE_INT_CST_LOW
argument_list|(
name|ret_type_size
argument_list|)
operator|/
name|BITS_PER_UNIT
decl_stmt|;
if|if
condition|(
name|units
operator|>
name|larger_than_size
condition|)
name|warning_with_decl
argument_list|(
name|fndecl
argument_list|,
literal|"size of return value of `%s' is %u bytes"
argument_list|,
name|units
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Free all the tree nodes making up this function.  */
comment|/* Switch back to allocating nodes permanently      until we start another function.  */
if|if
condition|(
operator|!
name|nested
condition|)
name|permanent_allocation
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|fndecl
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|nested
condition|)
block|{
comment|/* Stop pointing to the local nodes about to be freed.  */
comment|/* But DECL_INITIAL must remain nonzero so we know this 	 was an actual function definition.  */
comment|/* For a nested function, this is done in pop_c_function_context.  */
comment|/* If rest_of_compilation set this to 0, leave it 0.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|!=
literal|0
condition|)
name|DECL_INITIAL
argument_list|(
name|fndecl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|fndecl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nested
condition|)
block|{
comment|/* Let the error reporting routines know that we're outside a 	 function.  For a nested function, this value is used in 	 pop_c_function_context and then reset via pop_function_context.  */
name|current_function_decl
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Save and restore the variables in this file and elsewhere    that keep track of the progress of compilation of the current function.    Used for nested functions.  */
end_comment

begin_struct
struct|struct
name|c_function
block|{
name|struct
name|c_function
modifier|*
name|next
decl_stmt|;
name|tree
name|named_labels
decl_stmt|;
name|tree
name|shadowed_labels
decl_stmt|;
name|int
name|returns_value
decl_stmt|;
name|int
name|returns_null
decl_stmt|;
name|int
name|warn_about_return_type
decl_stmt|;
name|int
name|extern_inline
decl_stmt|;
name|struct
name|binding_level
modifier|*
name|binding_level
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|c_function
modifier|*
name|c_function_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save and reinitialize the variables    used during compilation of a C function.  */
end_comment

begin_function
name|void
name|push_c_function_context
parameter_list|()
block|{
name|struct
name|c_function
modifier|*
name|p
init|=
operator|(
expr|struct
name|c_function
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|c_function
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C forbids nested functions"
argument_list|)
expr_stmt|;
name|push_function_context
argument_list|()
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|c_function_chain
expr_stmt|;
name|c_function_chain
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|named_labels
operator|=
name|named_labels
expr_stmt|;
name|p
operator|->
name|shadowed_labels
operator|=
name|shadowed_labels
expr_stmt|;
name|p
operator|->
name|returns_value
operator|=
name|current_function_returns_value
expr_stmt|;
name|p
operator|->
name|returns_null
operator|=
name|current_function_returns_null
expr_stmt|;
name|p
operator|->
name|warn_about_return_type
operator|=
name|warn_about_return_type
expr_stmt|;
name|p
operator|->
name|extern_inline
operator|=
name|current_extern_inline
expr_stmt|;
name|p
operator|->
name|binding_level
operator|=
name|current_binding_level
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restore the variables used during compilation of a C function.  */
end_comment

begin_function
name|void
name|pop_c_function_context
parameter_list|()
block|{
name|struct
name|c_function
modifier|*
name|p
init|=
name|c_function_chain
decl_stmt|;
name|tree
name|link
decl_stmt|;
comment|/* Bring back all the labels that were shadowed.  */
for|for
control|(
name|link
operator|=
name|shadowed_labels
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|IDENTIFIER_LABEL_VALUE
argument_list|(
name|DECL_NAME
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
argument_list|)
operator|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_SAVED_INSNS
argument_list|(
name|current_function_decl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Stop pointing to the local nodes about to be freed.  */
comment|/* But DECL_INITIAL must remain nonzero so we know this 	 was an actual function definition.  */
name|DECL_INITIAL
argument_list|(
name|current_function_decl
argument_list|)
operator|=
name|error_mark_node
expr_stmt|;
name|DECL_ARGUMENTS
argument_list|(
name|current_function_decl
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|pop_function_context
argument_list|()
expr_stmt|;
name|c_function_chain
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|named_labels
operator|=
name|p
operator|->
name|named_labels
expr_stmt|;
name|shadowed_labels
operator|=
name|p
operator|->
name|shadowed_labels
expr_stmt|;
name|current_function_returns_value
operator|=
name|p
operator|->
name|returns_value
expr_stmt|;
name|current_function_returns_null
operator|=
name|p
operator|->
name|returns_null
expr_stmt|;
name|warn_about_return_type
operator|=
name|p
operator|->
name|warn_about_return_type
expr_stmt|;
name|current_extern_inline
operator|=
name|p
operator|->
name|extern_inline
expr_stmt|;
name|current_binding_level
operator|=
name|p
operator|->
name|binding_level
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* integrate_decl_tree calls this function, but since we don't use the    DECL_LANG_SPECIFIC field, this is a no-op.  */
end_comment

begin_function
name|void
name|copy_lang_decl
parameter_list|(
name|node
parameter_list|)
name|tree
name|node
decl_stmt|;
block|{ }
end_function

end_unit

