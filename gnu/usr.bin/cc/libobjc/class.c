begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GNU Objective C Runtime class related functions    Copyright (C) 1993 Free Software Foundation, Inc.  Author: Kresten Krab Thorup, Dennis Glatting  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the    terms of the GNU General Public License as published by the Free Software    Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more    details.  You should have received a copy of the GNU General Public License along with    GNU CC; see the file COPYING.  If not, write to the Free Software    Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with files compiled with    GCC to produce an executable, this does not cause the resulting executable    to be covered by the GNU General Public License. This exception does not    however invalidate any other reasons why the executable file might be    covered by the GNU General Public License.  */
end_comment

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_comment
comment|/* the kitchen sink */
end_comment

begin_comment
comment|/* The table of classname->class.  Used for objc_lookup_class and friends */
end_comment

begin_decl_stmt
specifier|static
name|cache_ptr
name|__objc_class_hash
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is a hook which is called by objc_get_class and     objc_lookup_class if the runtime is not able to find the class.    This may e.g. try to load in the class using dynamic loading */
end_comment

begin_function_decl
name|Class
modifier|*
function_decl|(
modifier|*
name|_objc_lookup_class
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
init|=
literal|0
function_decl|;
end_function_decl

begin_comment
comment|/* True when class links has been resolved */
end_comment

begin_decl_stmt
name|BOOL
name|__objc_class_links_resolved
init|=
name|NO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initial number of buckets size of class hash table. */
end_comment

begin_define
define|#
directive|define
name|CLASS_HASH_SIZE
value|32
end_define

begin_function
name|void
name|__objc_init_class_tables
parameter_list|()
block|{
comment|/* Allocate the class hash table */
if|if
condition|(
name|__objc_class_hash
condition|)
return|return;
name|__objc_class_hash
operator|=
name|hash_new
argument_list|(
name|CLASS_HASH_SIZE
argument_list|,
operator|(
name|hash_func_type
operator|)
name|hash_string
argument_list|,
operator|(
name|compare_func_type
operator|)
name|compare_strings
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function adds a class to the class hash table, and assigns the     class a number, unless it's already known */
end_comment

begin_function
name|void
name|__objc_add_class_to_hash
parameter_list|(
name|Class
modifier|*
name|class
parameter_list|)
block|{
name|Class
modifier|*
name|h_class
decl_stmt|;
comment|/* make sure the table is there */
name|assert
argument_list|(
name|__objc_class_hash
argument_list|)
expr_stmt|;
comment|/* make sure it's not a meta class */
name|assert
argument_list|(
name|CLS_ISCLASS
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check to see if the class is already in the hash table.  */
name|h_class
operator|=
name|hash_value_for_key
argument_list|(
name|__objc_class_hash
argument_list|,
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h_class
condition|)
block|{
comment|/* The class isn't in the hash table.  Add the class and assign a class          number.  */
specifier|static
name|unsigned
name|int
name|class_number
init|=
literal|1
decl_stmt|;
name|CLS_SETNUMBER
argument_list|(
name|class
argument_list|,
name|class_number
argument_list|)
expr_stmt|;
name|CLS_SETNUMBER
argument_list|(
name|class
operator|->
name|class_pointer
argument_list|,
name|class_number
argument_list|)
expr_stmt|;
operator|++
name|class_number
expr_stmt|;
name|hash_add
argument_list|(
operator|&
name|__objc_class_hash
argument_list|,
name|class
operator|->
name|name
argument_list|,
name|class
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get the class object for the class named NAME.  If NAME does not    identify a known class, the hook _objc_lookup_class is called.  If    this fails, nil is returned */
end_comment

begin_function
name|Class
modifier|*
name|objc_lookup_class
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|Class
modifier|*
name|class
decl_stmt|;
comment|/* Make sure the class hash table exists.  */
name|assert
argument_list|(
name|__objc_class_hash
argument_list|)
expr_stmt|;
name|class
operator|=
name|hash_value_for_key
argument_list|(
name|__objc_class_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
condition|)
return|return
name|class
return|;
if|if
condition|(
name|_objc_lookup_class
condition|)
return|return
call|(
modifier|*
name|_objc_lookup_class
call|)
argument_list|(
name|name
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get the class object for the class named NAME.  If NAME does not    identify a known class, the hook _objc_lookup_class is called.  If    this fails,  an error message is issued and the system aborts */
end_comment

begin_function
name|Class
modifier|*
name|objc_get_class
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|Class
modifier|*
name|class
decl_stmt|;
comment|/* Make sure the class hash table exists.  */
name|assert
argument_list|(
name|__objc_class_hash
argument_list|)
expr_stmt|;
name|class
operator|=
name|hash_value_for_key
argument_list|(
name|__objc_class_hash
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
condition|)
return|return
name|class
return|;
if|if
condition|(
name|_objc_lookup_class
condition|)
name|class
operator|=
call|(
modifier|*
name|_objc_lookup_class
call|)
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
condition|)
return|return
name|class
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"objc runtime: cannot find class %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resolve super/subclass links for all classes.  The only thing we     can be sure of is that the class_pointer for class objects point     to the right meta class objects */
end_comment

begin_function
name|void
name|__objc_resolve_class_links
parameter_list|()
block|{
name|node_ptr
name|node
decl_stmt|;
name|Class
modifier|*
name|object_class
init|=
name|objc_get_class
argument_list|(
literal|"Object"
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|object_class
argument_list|)
expr_stmt|;
comment|/* Assign subclass links */
for|for
control|(
name|node
operator|=
name|hash_next
argument_list|(
name|__objc_class_hash
argument_list|,
name|NULL
argument_list|)
init|;
name|node
condition|;
name|node
operator|=
name|hash_next
argument_list|(
name|__objc_class_hash
argument_list|,
name|node
argument_list|)
control|)
block|{
name|Class
modifier|*
name|class1
init|=
name|node
operator|->
name|value
decl_stmt|;
comment|/* Make sure we have what we think we have.  */
name|assert
argument_list|(
name|CLS_ISCLASS
argument_list|(
name|class1
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CLS_ISMETA
argument_list|(
name|class1
operator|->
name|class_pointer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The class_pointer of all meta classes point to Object's meta class. */
name|class1
operator|->
name|class_pointer
operator|->
name|class_pointer
operator|=
name|object_class
operator|->
name|class_pointer
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|CLS_ISRESOLV
argument_list|(
name|class1
argument_list|)
operator|)
condition|)
block|{
name|CLS_SETRESOLV
argument_list|(
name|class1
argument_list|)
expr_stmt|;
name|CLS_SETRESOLV
argument_list|(
name|class1
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|class1
operator|->
name|super_class
condition|)
block|{
name|Class
modifier|*
name|a_super_class
init|=
name|objc_get_class
argument_list|(
operator|(
name|char
operator|*
operator|)
name|class1
operator|->
name|super_class
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|a_super_class
argument_list|)
expr_stmt|;
name|DEBUG_PRINTF
argument_list|(
literal|"making class connections for: %s\n"
argument_list|,
name|class1
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* assign subclass links for superclass */
name|class1
operator|->
name|sibling_class
operator|=
name|a_super_class
operator|->
name|subclass_list
expr_stmt|;
name|a_super_class
operator|->
name|subclass_list
operator|=
name|class1
expr_stmt|;
comment|/* Assign subclass links for meta class of superclass */
if|if
condition|(
name|a_super_class
operator|->
name|class_pointer
condition|)
block|{
name|class1
operator|->
name|class_pointer
operator|->
name|sibling_class
operator|=
name|a_super_class
operator|->
name|class_pointer
operator|->
name|subclass_list
expr_stmt|;
name|a_super_class
operator|->
name|class_pointer
operator|->
name|subclass_list
operator|=
name|class1
operator|->
name|class_pointer
expr_stmt|;
block|}
block|}
else|else
comment|/* a root class, make its meta object */
comment|/* be a subclass of Object */
block|{
name|class1
operator|->
name|class_pointer
operator|->
name|sibling_class
operator|=
name|object_class
operator|->
name|subclass_list
expr_stmt|;
name|object_class
operator|->
name|subclass_list
operator|=
name|class1
operator|->
name|class_pointer
expr_stmt|;
block|}
block|}
block|}
comment|/* Assign superclass links */
for|for
control|(
name|node
operator|=
name|hash_next
argument_list|(
name|__objc_class_hash
argument_list|,
name|NULL
argument_list|)
init|;
name|node
condition|;
name|node
operator|=
name|hash_next
argument_list|(
name|__objc_class_hash
argument_list|,
name|node
argument_list|)
control|)
block|{
name|Class
modifier|*
name|class1
init|=
name|node
operator|->
name|value
decl_stmt|;
name|Class
modifier|*
name|sub_class
decl_stmt|;
for|for
control|(
name|sub_class
operator|=
name|class1
operator|->
name|subclass_list
init|;
name|sub_class
condition|;
name|sub_class
operator|=
name|sub_class
operator|->
name|sibling_class
control|)
block|{
name|sub_class
operator|->
name|super_class
operator|=
name|class1
expr_stmt|;
if|if
condition|(
name|CLS_ISCLASS
argument_list|(
name|sub_class
argument_list|)
condition|)
name|sub_class
operator|->
name|class_pointer
operator|->
name|super_class
operator|=
name|class1
operator|->
name|class_pointer
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This is a incomplete implementation of posing.   This function does the    bulk of the work but does not initialize the class method caches.  That is    a run-time specific operation.  I implement posing by hiding SUPER_CLASS, creating new class and meta class    structures, initializing it with IMPOSTOR, and changing it such that it is    identified as SUPER_CLASS. SUPER_CLASS remains in the hierarchy but is    inaccessible by the means. The class hierarchy is then re arranged such    that all of the subclasses of SUPER_CLASS now inherit from the new class    structures -- except the impostor itself. The only dramatic effect on the    application is that subclasses of SUPER_CLASS cannot do a [ ....    super_class ] and expect their real super class. */
end_comment

begin_function
name|Class
modifier|*
name|class_pose_as
parameter_list|(
name|Class
modifier|*
name|impostor
parameter_list|,
name|Class
modifier|*
name|super_class
parameter_list|)
block|{
name|Class
modifier|*
name|new_class
init|=
operator|(
name|Class
operator|*
operator|)
name|__objc_xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|Class
argument_list|)
argument_list|)
decl_stmt|;
name|MetaClass
modifier|*
name|new_meta_class
init|=
operator|(
name|MetaClass
operator|*
operator|)
name|__objc_xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|MetaClass
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|new_name
init|=
operator|(
name|char
operator|*
operator|)
name|__objc_xmalloc
argument_list|(
operator|(
name|size_t
operator|)
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|super_class
operator|->
name|name
argument_list|)
operator|+
literal|12
argument_list|)
decl_stmt|;
comment|/* We must know the state of the hierachy.  Do initial setup if needed */
if|if
condition|(
operator|!
name|CLS_ISRESOLV
argument_list|(
name|impostor
argument_list|)
condition|)
name|__objc_resolve_class_links
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|new_class
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|new_meta_class
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|new_name
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CLS_ISCLASS
argument_list|(
name|impostor
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CLS_ISCLASS
argument_list|(
name|super_class
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|impostor
operator|->
name|instance_size
operator|==
name|super_class
operator|->
name|instance_size
argument_list|)
expr_stmt|;
comment|/* Create the impostor class.  */
name|new_class
operator|->
name|class_pointer
operator|=
name|new_meta_class
expr_stmt|;
name|new_class
operator|->
name|super_class
operator|=
name|super_class
expr_stmt|;
name|new_class
operator|->
name|name
operator|=
name|super_class
operator|->
name|name
expr_stmt|;
name|new_class
operator|->
name|version
operator|=
name|super_class
operator|->
name|version
expr_stmt|;
name|new_class
operator|->
name|info
operator|=
name|super_class
operator|->
name|info
expr_stmt|;
name|new_class
operator|->
name|instance_size
operator|=
name|super_class
operator|->
name|instance_size
expr_stmt|;
name|new_class
operator|->
name|ivars
operator|=
name|super_class
operator|->
name|ivars
expr_stmt|;
name|new_class
operator|->
name|methods
operator|=
name|impostor
operator|->
name|methods
expr_stmt|;
name|new_class
operator|->
name|dtable
operator|=
name|impostor
operator|->
name|dtable
expr_stmt|;
comment|/* Create the impostor meta class.  */
name|new_meta_class
operator|->
name|class_pointer
operator|=
name|super_class
operator|->
name|class_pointer
operator|->
name|class_pointer
expr_stmt|;
name|new_meta_class
operator|->
name|super_class
operator|=
name|super_class
operator|->
name|class_pointer
operator|->
name|super_class
expr_stmt|;
name|new_meta_class
operator|->
name|name
operator|=
name|super_class
operator|->
name|class_pointer
operator|->
name|name
expr_stmt|;
name|new_meta_class
operator|->
name|version
operator|=
name|super_class
operator|->
name|class_pointer
operator|->
name|version
expr_stmt|;
name|new_meta_class
operator|->
name|info
operator|=
name|super_class
operator|->
name|class_pointer
operator|->
name|info
expr_stmt|;
name|new_meta_class
operator|->
name|instance_size
operator|=
name|super_class
operator|->
name|class_pointer
operator|->
name|instance_size
expr_stmt|;
name|new_meta_class
operator|->
name|ivars
operator|=
name|super_class
operator|->
name|class_pointer
operator|->
name|ivars
expr_stmt|;
name|new_meta_class
operator|->
name|methods
operator|=
name|impostor
operator|->
name|class_pointer
operator|->
name|methods
expr_stmt|;
name|new_meta_class
operator|->
name|dtable
operator|=
name|impostor
operator|->
name|class_pointer
operator|->
name|dtable
expr_stmt|;
comment|/* Now change super/subclass links of all related classes.  This is rather      complex, since we have both super_class link, and subclass_list for the      involved classes. */
block|{
name|Class
modifier|*
modifier|*
name|classpp
decl_stmt|;
name|MetaClass
modifier|*
modifier|*
name|metaclasspp
decl_stmt|;
comment|/* Remove impostor from subclass list of super_class */
for|for
control|(
name|classpp
operator|=
operator|&
operator|(
name|super_class
operator|->
name|subclass_list
operator|)
init|;
operator|*
name|classpp
condition|;
name|classpp
operator|=
operator|&
operator|(
operator|(
operator|*
name|classpp
operator|)
operator|->
name|sibling_class
operator|)
control|)
block|{
if|if
condition|(
operator|*
name|classpp
operator|==
name|impostor
condition|)
operator|*
name|classpp
operator|=
operator|(
operator|*
name|classpp
operator|)
operator|->
name|sibling_class
expr_stmt|;
if|if
condition|(
operator|*
name|classpp
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* Do the same for the meta classes */
for|for
control|(
name|metaclasspp
operator|=
operator|&
operator|(
name|super_class
operator|->
name|class_pointer
operator|->
name|subclass_list
operator|)
init|;
operator|*
name|metaclasspp
condition|;
name|metaclasspp
operator|=
operator|&
operator|(
operator|(
operator|*
name|metaclasspp
operator|)
operator|->
name|sibling_class
operator|)
control|)
block|{
if|if
condition|(
operator|*
name|metaclasspp
operator|==
name|impostor
operator|->
name|class_pointer
condition|)
operator|*
name|metaclasspp
operator|=
operator|(
operator|*
name|metaclasspp
operator|)
operator|->
name|sibling_class
expr_stmt|;
if|if
condition|(
operator|*
name|metaclasspp
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* From the loop above, classpp now points to the sibling_class entry */
comment|/* of the last element in the list of subclasses for super_class */
comment|/* Append the subclass list of impostor to the subclass list of */
comment|/* superclass, and excange those two and set subclass of */
comment|/* super_class to be impostor only */
operator|*
name|classpp
operator|=
name|impostor
operator|->
name|subclass_list
expr_stmt|;
name|new_class
operator|->
name|subclass_list
operator|=
name|super_class
operator|->
name|subclass_list
expr_stmt|;
name|super_class
operator|->
name|subclass_list
operator|=
name|new_class
expr_stmt|;
name|new_class
operator|->
name|sibling_class
operator|=
literal|0
expr_stmt|;
comment|/* Do the same thing for the meta classes */
operator|*
name|metaclasspp
operator|=
name|impostor
operator|->
name|class_pointer
operator|->
name|subclass_list
expr_stmt|;
name|new_meta_class
operator|->
name|subclass_list
operator|=
name|super_class
operator|->
name|class_pointer
operator|->
name|subclass_list
expr_stmt|;
name|super_class
operator|->
name|class_pointer
operator|->
name|subclass_list
operator|=
name|new_meta_class
expr_stmt|;
name|new_meta_class
operator|->
name|sibling_class
operator|=
literal|0
expr_stmt|;
comment|/* Update superclass links for all subclasses of new_class */
for|for
control|(
name|classpp
operator|=
operator|&
operator|(
name|new_class
operator|->
name|subclass_list
operator|)
init|;
operator|*
name|classpp
condition|;
name|classpp
operator|=
operator|&
operator|(
operator|(
operator|*
name|classpp
operator|)
operator|->
name|sibling_class
operator|)
control|)
operator|(
operator|*
name|classpp
operator|)
operator|->
name|super_class
operator|=
name|new_class
expr_stmt|;
for|for
control|(
name|metaclasspp
operator|=
operator|&
operator|(
name|new_meta_class
operator|->
name|subclass_list
operator|)
init|;
operator|*
name|metaclasspp
condition|;
name|metaclasspp
operator|=
operator|&
operator|(
operator|(
operator|*
name|metaclasspp
operator|)
operator|->
name|sibling_class
operator|)
control|)
operator|(
operator|*
name|metaclasspp
operator|)
operator|->
name|super_class
operator|=
name|new_meta_class
expr_stmt|;
block|}
comment|/* Delete the class from the hash table, change its name so that it can no      longer be found, then place it back into the hash table using its new      name.      Don't worry about the class number.  It is already assigned.      memory is lost with the hash key.) */
name|hash_remove
argument_list|(
name|__objc_class_hash
argument_list|,
name|super_class
operator|->
name|name
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|new_name
argument_list|,
literal|"%s*"
argument_list|,
name|super_class
operator|->
name|name
argument_list|)
expr_stmt|;
name|super_class
operator|->
name|name
operator|=
name|new_name
expr_stmt|;
name|super_class
operator|->
name|class_pointer
operator|->
name|name
operator|=
name|new_name
expr_stmt|;
name|hash_add
argument_list|(
operator|&
name|__objc_class_hash
argument_list|,
name|super_class
operator|->
name|name
argument_list|,
name|super_class
argument_list|)
expr_stmt|;
comment|/* Place the impostor class in class hash table and assign it a class      number.  */
name|__objc_add_class_to_hash
argument_list|(
name|new_class
argument_list|)
expr_stmt|;
comment|/* Now update dispatch tables for new_class and it's subclasses */
name|__objc_update_dispatch_table_for_class
argument_list|(
operator|(
name|Class
operator|*
operator|)
name|new_meta_class
argument_list|)
expr_stmt|;
name|__objc_update_dispatch_table_for_class
argument_list|(
name|new_class
argument_list|)
expr_stmt|;
return|return
name|new_class
return|;
block|}
end_function

end_unit

