begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GNU Objective C Runtime message lookup     Copyright (C) 1993 Free Software Foundation, Inc.  Author: Kresten Krab Thorup  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the    terms of the GNU General Public License as published by the Free Software    Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS    FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more    details.  You should have received a copy of the GNU General Public License along with    GNU CC; see the file COPYING.  If not, write to the Free Software    Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* As a special exception, if you link this library with files compiled with    GCC to produce an executable, this does not cause the resulting executable    to be covered by the GNU General Public License. This exception does not    however invalidate any other reasons why the executable file might be    covered by the GNU General Public License.  */
end_comment

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_include
include|#
directive|include
file|"sarray.h"
end_include

begin_comment
comment|/* The uninstalled dispatch table */
end_comment

begin_decl_stmt
name|struct
name|sarray
modifier|*
name|__objc_uninstalled_dtable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Send +initialize to class */
end_comment

begin_function_decl
specifier|static
name|void
name|__objc_send_initialize
parameter_list|(
name|Class
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__objc_install_dispatch_table_for_class
parameter_list|(
name|Class
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Forward declare some functions */
end_comment

begin_function_decl
specifier|static
name|void
name|__objc_init_install_dtable
parameter_list|(
name|id
parameter_list|,
name|SEL
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|id
name|__objc_missing_method
parameter_list|(
name|id
parameter_list|,
name|SEL
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Method_t
name|search_for_method_in_hierarchy
parameter_list|(
name|Class
modifier|*
name|class
parameter_list|,
name|SEL
name|sel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Method_t
name|search_for_method_in_list
parameter_list|(
name|MethodList_t
name|list
parameter_list|,
name|SEL
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|id
name|nil_method
parameter_list|(
name|id
parameter_list|,
name|SEL
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|id
name|nil_method
parameter_list|(
name|id
name|receiver
parameter_list|,
name|SEL
name|op
parameter_list|,
modifier|...
parameter_list|)
block|{
return|return
name|receiver
return|;
block|}
end_function

begin_comment
comment|/* Given a class and selector, return the selector's implementation.  */
end_comment

begin_function
name|__inline__
name|IMP
name|get_imp
parameter_list|(
name|Class
modifier|*
name|class
parameter_list|,
name|SEL
name|sel
parameter_list|)
block|{
name|void
modifier|*
name|res
init|=
name|sarray_get
argument_list|(
name|class
operator|->
name|dtable
argument_list|,
operator|(
name|size_t
operator|)
name|sel
argument_list|)
decl_stmt|;
if|if
condition|(
name|res
operator|==
name|__objc_init_install_dtable
condition|)
name|__objc_install_dispatch_table_for_class
argument_list|(
name|class
argument_list|)
expr_stmt|;
return|return
name|sarray_get
argument_list|(
name|class
operator|->
name|dtable
argument_list|,
operator|(
name|size_t
operator|)
name|sel
argument_list|)
return|;
block|}
end_function

begin_function
name|__inline__
name|BOOL
name|__objc_responds_to
parameter_list|(
name|id
name|object
parameter_list|,
name|SEL
name|sel
parameter_list|)
block|{
return|return
name|get_imp
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|,
name|sel
argument_list|)
operator|!=
name|__objc_missing_method
return|;
block|}
end_function

begin_comment
comment|/* This is the lookup function.  All entries in the table are either a     valid method *or* one of `__objc_missing_method' which calls    forward:: etc, or `__objc_init_install_dtable' which installs the    real dtable */
end_comment

begin_function
name|__inline__
name|IMP
name|objc_msg_lookup
parameter_list|(
name|id
name|receiver
parameter_list|,
name|SEL
name|op
parameter_list|)
block|{
if|if
condition|(
name|receiver
condition|)
return|return
name|sarray_get
argument_list|(
name|receiver
operator|->
name|class_pointer
operator|->
name|dtable
argument_list|,
operator|(
name|sidx
operator|)
name|op
argument_list|)
return|;
else|else
return|return
name|nil_method
return|;
block|}
end_function

begin_function
name|IMP
name|objc_msg_lookup_super
parameter_list|(
name|Super_t
name|super
parameter_list|,
name|SEL
name|sel
parameter_list|)
block|{
if|if
condition|(
name|super
operator|->
name|self
condition|)
return|return
name|get_imp
argument_list|(
name|super
operator|->
name|class
argument_list|,
name|sel
argument_list|)
return|;
else|else
return|return
name|nil_method
return|;
block|}
end_function

begin_function
name|retval_t
name|objc_msg_sendv
parameter_list|(
name|id
name|object
parameter_list|,
name|SEL
name|op
parameter_list|,
name|size_t
name|frame_size
parameter_list|,
name|arglist_t
name|arg_frame
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__objc_frame_receiver
name|__objc_frame_receiver
argument_list|(
name|arg_frame
argument_list|)
operator|=
name|object
expr_stmt|;
name|__objc_frame_selector
argument_list|(
name|arg_frame
argument_list|)
operator|=
name|op
expr_stmt|;
return|return
name|__builtin_apply
argument_list|(
operator|(
name|apply_t
operator|)
name|get_imp
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|,
name|op
argument_list|)
argument_list|,
name|arg_frame
argument_list|,
name|frame_size
argument_list|)
return|;
else|#
directive|else
warning|#
directive|warning
warning|performv:: will not work
call|(
modifier|*
name|_objc_error
call|)
argument_list|(
name|object
argument_list|,
literal|"objc_msg_sendv (performv::) not supported\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|__objc_init_dispatch_tables
parameter_list|()
block|{
name|__objc_uninstalled_dtable
operator|=
name|sarray_new
argument_list|(
literal|200
argument_list|,
name|__objc_init_install_dtable
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This one is a bit hairy.  This function is installed in the     premature dispatch table, and thus called once for each class,    namely when the very first message is send to it.  */
end_comment

begin_function
specifier|static
name|void
name|__objc_init_install_dtable
parameter_list|(
name|id
name|receiver
parameter_list|,
name|SEL
name|op
parameter_list|)
block|{
name|__label__
name|allready_initialized
decl_stmt|;
name|IMP
name|imp
decl_stmt|;
name|void
modifier|*
name|args
decl_stmt|;
name|void
modifier|*
name|result
decl_stmt|;
comment|/* This may happen, if the programmer has taken the address of a       method before the dtable was initialized... too bad for him! */
if|if
condition|(
name|receiver
operator|->
name|class_pointer
operator|->
name|dtable
operator|!=
name|__objc_uninstalled_dtable
condition|)
goto|goto
name|allready_initialized
goto|;
if|if
condition|(
name|CLS_ISCLASS
argument_list|(
name|receiver
operator|->
name|class_pointer
argument_list|)
condition|)
block|{
comment|/* receiver is an ordinary object */
name|assert
argument_list|(
name|CLS_ISCLASS
argument_list|(
name|receiver
operator|->
name|class_pointer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* install instance methods table */
name|__objc_install_dispatch_table_for_class
argument_list|(
name|receiver
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
comment|/* call +initialize -- this will in turn install the factory  	 dispatch table if not already done :-) */
name|__objc_send_initialize
argument_list|(
name|receiver
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* receiver is a class object */
name|assert
argument_list|(
name|CLS_ISCLASS
argument_list|(
operator|(
name|Class
operator|*
operator|)
name|receiver
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CLS_ISMETA
argument_list|(
name|receiver
operator|->
name|class_pointer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Install real dtable for factory methods */
name|__objc_install_dispatch_table_for_class
argument_list|(
name|receiver
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|!=
name|sel_get_uid
argument_list|(
literal|"initialize"
argument_list|)
condition|)
name|__objc_send_initialize
argument_list|(
operator|(
name|Class
operator|*
operator|)
name|receiver
argument_list|)
expr_stmt|;
else|else
name|CLS_SETINITIALIZED
argument_list|(
operator|(
name|Class
operator|*
operator|)
name|receiver
argument_list|)
expr_stmt|;
block|}
name|allready_initialized
label|:
comment|/* Get real method for this in newly installed dtable */
name|imp
operator|=
name|get_imp
argument_list|(
name|receiver
operator|->
name|class_pointer
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|args
operator|=
name|__builtin_apply_args
argument_list|()
expr_stmt|;
name|result
operator|=
name|__builtin_apply
argument_list|(
operator|(
name|apply_t
operator|)
name|imp
argument_list|,
name|args
argument_list|,
literal|96
argument_list|)
expr_stmt|;
name|__builtin_return
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Install dummy table for class which causes the first message to    that class (or instances hereof) to be initialized properly */
end_comment

begin_function
name|void
name|__objc_install_premature_dtable
parameter_list|(
name|Class
modifier|*
name|class
parameter_list|)
block|{
name|assert
argument_list|(
name|__objc_uninstalled_dtable
argument_list|)
expr_stmt|;
name|class
operator|->
name|dtable
operator|=
name|__objc_uninstalled_dtable
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Send +initialize to class if not already done */
end_comment

begin_function
specifier|static
name|void
name|__objc_send_initialize
parameter_list|(
name|Class
modifier|*
name|class
parameter_list|)
block|{
name|Method_t
name|m
decl_stmt|;
comment|/* This *must* be a class object */
name|assert
argument_list|(
name|CLS_ISCLASS
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|CLS_ISMETA
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CLS_ISINITIALIZED
argument_list|(
name|class
argument_list|)
condition|)
block|{
name|CLS_SETINITIALIZED
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|CLS_SETINITIALIZED
argument_list|(
name|class
operator|->
name|class_pointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|->
name|super_class
condition|)
name|__objc_send_initialize
argument_list|(
name|class
operator|->
name|super_class
argument_list|)
expr_stmt|;
block|{
name|MethodList_t
name|method_list
init|=
name|class
operator|->
name|class_pointer
operator|->
name|methods
decl_stmt|;
name|SEL
name|op
init|=
name|sel_register_name
argument_list|(
literal|"initialize"
argument_list|)
decl_stmt|;
comment|/* If not found then we'll search the list.  */
while|while
condition|(
name|method_list
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Search the method list.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|method_list
operator|->
name|method_count
condition|;
operator|++
name|i
control|)
block|{
name|Method_t
name|method
init|=
operator|&
name|method_list
operator|->
name|method_list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|method
operator|->
name|method_name
operator|==
name|op
condition|)
call|(
modifier|*
name|method
operator|->
name|method_imp
call|)
argument_list|(
operator|(
name|id
operator|)
name|class
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* The method wasn't found.  Follow the link to the next list of 	       methods.  */
name|method_list
operator|=
name|method_list
operator|->
name|method_next
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|__objc_install_dispatch_table_for_class
parameter_list|(
name|Class
modifier|*
name|class
parameter_list|)
block|{
name|Class
modifier|*
name|super
decl_stmt|;
name|MethodList_t
name|mlist
decl_stmt|;
name|int
name|counter
decl_stmt|;
comment|/* If the class has not yet had it's class links resolved, we must       re-compute all class links */
if|if
condition|(
operator|!
name|CLS_ISRESOLV
argument_list|(
name|class
argument_list|)
condition|)
name|__objc_resolve_class_links
argument_list|()
expr_stmt|;
name|super
operator|=
name|class
operator|->
name|super_class
expr_stmt|;
if|if
condition|(
name|super
operator|!=
literal|0
operator|&&
operator|(
name|super
operator|->
name|dtable
operator|==
name|__objc_uninstalled_dtable
operator|)
condition|)
name|__objc_install_dispatch_table_for_class
argument_list|(
name|super
argument_list|)
expr_stmt|;
comment|/* Allocate dtable if nessecary */
if|if
condition|(
name|super
operator|==
literal|0
condition|)
block|{
name|class
operator|->
name|dtable
operator|=
name|sarray_new
argument_list|(
name|__objc_selector_max_index
argument_list|,
name|__objc_missing_method
argument_list|)
expr_stmt|;
block|}
else|else
name|class
operator|->
name|dtable
operator|=
name|sarray_lazy_copy
argument_list|(
name|super
operator|->
name|dtable
argument_list|)
expr_stmt|;
for|for
control|(
name|mlist
operator|=
name|class
operator|->
name|methods
init|;
name|mlist
condition|;
name|mlist
operator|=
name|mlist
operator|->
name|method_next
control|)
block|{
name|counter
operator|=
name|mlist
operator|->
name|method_count
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|counter
operator|>=
literal|0
condition|)
block|{
name|Method_t
name|method
init|=
operator|&
operator|(
name|mlist
operator|->
name|method_list
index|[
name|counter
index|]
operator|)
decl_stmt|;
name|sarray_at_put
argument_list|(
name|class
operator|->
name|dtable
argument_list|,
operator|(
name|sidx
operator|)
name|method
operator|->
name|method_name
argument_list|,
name|method
operator|->
name|method_imp
argument_list|)
expr_stmt|;
name|counter
operator|-=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|__objc_update_dispatch_table_for_class
parameter_list|(
name|Class
modifier|*
name|class
parameter_list|)
block|{
name|Class
modifier|*
name|next
decl_stmt|;
name|struct
name|sarray
modifier|*
name|save
decl_stmt|;
comment|/* not yet installed -- skip it */
if|if
condition|(
name|class
operator|->
name|dtable
operator|==
name|__objc_uninstalled_dtable
condition|)
return|return;
name|save
operator|=
name|class
operator|->
name|dtable
expr_stmt|;
name|__objc_install_premature_dtable
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|sarray_free
argument_list|(
name|save
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|->
name|subclass_list
condition|)
comment|/* Traverse subclasses */
for|for
control|(
name|next
operator|=
name|class
operator|->
name|subclass_list
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|sibling_class
control|)
name|__objc_update_dispatch_table_for_class
argument_list|(
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function adds a method list to a class.  This function is    typically called by another function specific to the run-time.  As    such this function does not worry about thread safe issued.     This one is only called for categories. Class objects have their    methods installed rightaway, and their selectors are made into    SEL's by the function __objc_register_selectors_from_class. */
end_comment

begin_function
name|void
name|class_add_method_list
parameter_list|(
name|Class
modifier|*
name|class
parameter_list|,
name|MethodList_t
name|list
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|SEL
name|initialize_sel
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|initialize_sel
condition|)
name|initialize_sel
operator|=
name|sel_register_name
argument_list|(
literal|"initialize"
argument_list|)
expr_stmt|;
comment|/* Passing of a linked list is not allowed.  Do multiple calls.  */
name|assert
argument_list|(
operator|!
name|list
operator|->
name|method_next
argument_list|)
expr_stmt|;
comment|/* Check for duplicates.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|method_count
condition|;
operator|++
name|i
control|)
block|{
name|Method_t
name|method
init|=
operator|&
name|list
operator|->
name|method_list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|method
operator|->
name|method_name
condition|)
comment|/* Sometimes these are NULL */
block|{
comment|/* This is where selector names are transmogriffed to SEL's */
name|method
operator|->
name|method_name
operator|=
name|sel_register_name
argument_list|(
operator|(
name|char
operator|*
operator|)
name|method
operator|->
name|method_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|search_for_method_in_list
argument_list|(
name|class
operator|->
name|methods
argument_list|,
name|method
operator|->
name|method_name
argument_list|)
operator|&&
name|method
operator|->
name|method_name
operator|!=
name|initialize_sel
condition|)
block|{
comment|/* Duplication. Print a error message an change the method name 		 to NULL. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"attempt to add a existing method: %s\n"
argument_list|,
name|sel_get_name
argument_list|(
name|method
operator|->
name|method_name
argument_list|)
argument_list|)
expr_stmt|;
name|method
operator|->
name|method_name
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* Add the methods to the class's method list.  */
name|list
operator|->
name|method_next
operator|=
name|class
operator|->
name|methods
expr_stmt|;
name|class
operator|->
name|methods
operator|=
name|list
expr_stmt|;
block|}
end_function

begin_function
name|Method_t
name|class_get_instance_method
parameter_list|(
name|Class
modifier|*
name|class
parameter_list|,
name|SEL
name|op
parameter_list|)
block|{
return|return
name|search_for_method_in_hierarchy
argument_list|(
name|class
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function

begin_function
name|Method_t
name|class_get_class_method
parameter_list|(
name|MetaClass
modifier|*
name|class
parameter_list|,
name|SEL
name|op
parameter_list|)
block|{
return|return
name|search_for_method_in_hierarchy
argument_list|(
name|class
argument_list|,
name|op
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Search for a method starting from the current class up its hierarchy.    Return a pointer to the method's method structure if found.  NULL    otherwise. */
end_comment

begin_function
specifier|static
name|Method_t
name|search_for_method_in_hierarchy
parameter_list|(
name|Class
modifier|*
name|cls
parameter_list|,
name|SEL
name|sel
parameter_list|)
block|{
name|Method_t
name|method
init|=
name|NULL
decl_stmt|;
name|Class
modifier|*
name|class
decl_stmt|;
if|if
condition|(
operator|!
name|sel_is_mapped
argument_list|(
name|sel
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Scan the method list of the class.  If the method isn't found in the      list then step to its super class. */
for|for
control|(
name|class
operator|=
name|cls
init|;
operator|(
operator|(
operator|!
name|method
operator|)
operator|&&
name|class
operator|)
condition|;
name|class
operator|=
name|class
operator|->
name|super_class
control|)
name|method
operator|=
name|search_for_method_in_list
argument_list|(
name|class
operator|->
name|methods
argument_list|,
name|sel
argument_list|)
expr_stmt|;
return|return
name|method
return|;
block|}
end_function

begin_comment
comment|/* Given a linked list of method and a method's name.  Search for the named    method's method structure.  Return a pointer to the method's method    structure if found.  NULL otherwise. */
end_comment

begin_function
specifier|static
name|Method_t
name|search_for_method_in_list
parameter_list|(
name|MethodList_t
name|list
parameter_list|,
name|SEL
name|op
parameter_list|)
block|{
name|MethodList_t
name|method_list
init|=
name|list
decl_stmt|;
if|if
condition|(
operator|!
name|sel_is_mapped
argument_list|(
name|op
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* If not found then we'll search the list.  */
while|while
condition|(
name|method_list
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Search the method list.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|method_list
operator|->
name|method_count
condition|;
operator|++
name|i
control|)
block|{
name|Method_t
name|method
init|=
operator|&
name|method_list
operator|->
name|method_list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|method
operator|->
name|method_name
condition|)
if|if
condition|(
name|method
operator|->
name|method_name
operator|==
name|op
condition|)
return|return
name|method
return|;
block|}
comment|/* The method wasn't found.  Follow the link to the next list of          methods.  */
name|method_list
operator|=
name|method_list
operator|->
name|method_next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* This fuction is installed in the dispatch table for all methods which are    not implemented.  Thus, it is called when a selector is not recognized. */
end_comment

begin_function
specifier|static
name|id
name|__objc_missing_method
parameter_list|(
name|id
name|object
parameter_list|,
name|SEL
name|sel
parameter_list|,
modifier|...
parameter_list|)
block|{
name|IMP
name|imp
decl_stmt|;
name|SEL
name|frwd_sel
decl_stmt|;
name|SEL
name|err_sel
decl_stmt|;
comment|/* first try if the object understands forward:: */
name|frwd_sel
operator|=
name|sel_get_uid
argument_list|(
literal|"forward::"
argument_list|)
expr_stmt|;
name|imp
operator|=
name|get_imp
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|,
name|frwd_sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|imp
operator|!=
name|__objc_missing_method
condition|)
block|{
name|void
modifier|*
name|result
decl_stmt|,
modifier|*
name|args
init|=
name|__builtin_apply_args
argument_list|()
decl_stmt|;
name|result
operator|=
call|(
modifier|*
name|imp
call|)
argument_list|(
name|object
argument_list|,
name|frwd_sel
argument_list|,
name|sel
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|__builtin_return
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
comment|/* If the object recognizes the doesNotRecognize: method then we're going      to send it. */
name|err_sel
operator|=
name|sel_get_uid
argument_list|(
literal|"doesNotRecognize:"
argument_list|)
expr_stmt|;
name|imp
operator|=
name|get_imp
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|,
name|err_sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|imp
operator|!=
name|__objc_missing_method
condition|)
block|{
return|return
call|(
modifier|*
name|imp
call|)
argument_list|(
name|object
argument_list|,
name|err_sel
argument_list|,
name|sel
argument_list|)
return|;
block|}
comment|/* The object doesn't recognize the method.  Check for responding to      error:.  If it does then sent it. */
block|{
name|char
name|msg
index|[
literal|256
operator|+
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sel_get_name
argument_list|(
name|sel
argument_list|)
argument_list|)
operator|+
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|object
operator|->
name|class_pointer
operator|->
name|name
argument_list|)
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"(%s) %s does not recognize %s"
argument_list|,
operator|(
name|CLS_ISMETA
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|)
condition|?
literal|"class"
else|:
literal|"instance"
operator|)
argument_list|,
name|object
operator|->
name|class_pointer
operator|->
name|name
argument_list|,
name|sel_get_name
argument_list|(
name|sel
argument_list|)
argument_list|)
expr_stmt|;
name|err_sel
operator|=
name|sel_get_uid
argument_list|(
literal|"error:"
argument_list|)
expr_stmt|;
name|imp
operator|=
name|get_imp
argument_list|(
name|object
operator|->
name|class_pointer
argument_list|,
name|err_sel
argument_list|)
expr_stmt|;
if|if
condition|(
name|imp
operator|!=
name|__objc_missing_method
condition|)
return|return
call|(
modifier|*
name|imp
call|)
argument_list|(
name|object
argument_list|,
name|sel_get_uid
argument_list|(
literal|"error:"
argument_list|)
argument_list|,
name|msg
argument_list|)
return|;
comment|/* The object doesn't respond to doesNotRecognize: or error:;  Therefore,        a default action is taken. */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fatal: %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|__objc_print_dtable_stats
parameter_list|()
block|{
name|int
name|total
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"memory usage: (%s)\n"
argument_list|,
ifdef|#
directive|ifdef
name|OBJC_SPARSE2
literal|"2-level sparse arrays"
else|#
directive|else
literal|"3-level sparse arrays"
endif|#
directive|endif
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"arrays: %d = %d bytes\n"
argument_list|,
name|narrays
argument_list|,
name|narrays
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sarray
argument_list|)
argument_list|)
expr_stmt|;
name|total
operator|+=
name|narrays
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sarray
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"buckets: %d = %d bytes\n"
argument_list|,
name|nbuckets
argument_list|,
name|nbuckets
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
argument_list|)
argument_list|)
expr_stmt|;
name|total
operator|+=
name|nbuckets
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sbucket
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"idxtables: %d = %d bytes\n"
argument_list|,
name|idxsize
argument_list|,
name|idxsize
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|total
operator|+=
name|idxsize
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-----------------------------------\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"total: %d bytes\n"
argument_list|,
name|total
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"===================================\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

