begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* C Compatible Compiler Preprocessor (CCCP)    Copyright (C) 1986, 87, 89, 92, 93, 1994 Free Software Foundation, Inc.    Written by Paul Rubin, June 1986    Adapted to ANSI C, Richard Stallman, Jan 1987  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_escape
end_escape

begin_typedef
typedef|typedef
name|unsigned
name|char
name|U_CHAR
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|EMACS
end_ifdef

begin_define
define|#
directive|define
name|NO_SHORTNAMES
end_define

begin_include
include|#
directive|include
file|"../src/config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|open
end_ifdef

begin_undef
undef|#
directive|undef
name|open
end_undef

begin_undef
undef|#
directive|undef
name|read
end_undef

begin_undef
undef|#
directive|undef
name|write
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* open */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EMACS */
end_comment

begin_comment
comment|/* The macro EMACS is defined when cpp is distributed as part of Emacs,    for the sake of machines with limited C compilers.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EMACS
end_ifndef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not EMACS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STANDARD_INCLUDE_DIR
end_ifndef

begin_define
define|#
directive|define
name|STANDARD_INCLUDE_DIR
value|"/usr/include"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LOCAL_INCLUDE_DIR
end_ifndef

begin_define
define|#
directive|define
name|LOCAL_INCLUDE_DIR
value|"/usr/local/include"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* We can't get ptrdiff_t, so I arranged not to need PTR_INT_TYPE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|PTR_INT_TYPE
value|ptrdiff_t
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PTR_INT_TYPE
value|long
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_include
include|#
directive|include
file|"pcp.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|STDC_VALUE
end_ifndef

begin_define
define|#
directive|define
name|STDC_VALUE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* By default, colon separates directories in a path.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PATH_SEPARATOR
end_ifndef

begin_define
define|#
directive|define
name|PATH_SEPARATOR
value|':'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* In case config.h defines these.  */
end_comment

begin_undef
undef|#
directive|undef
name|bcopy
end_undef

begin_undef
undef|#
directive|undef
name|bzero
end_undef

begin_undef
undef|#
directive|undef
name|bcmp
end_undef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|USG
end_ifndef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_comment
comment|/* for __DATE__ and __TIME__ */
end_comment

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not VMS */
end_comment

begin_comment
comment|/* This defines "errno" properly for VMS, and gives us EACCES. */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* VMS-specific definitions */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<descrip.h>
end_include

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_comment
comment|/* Open arg for Read/Only  */
end_comment

begin_define
define|#
directive|define
name|O_WRONLY
value|1
end_define

begin_comment
comment|/* Open arg for Write/Only */
end_comment

begin_define
define|#
directive|define
name|read
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
value|VMS_read (fd,buf,size)
end_define

begin_define
define|#
directive|define
name|write
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
value|VMS_write (fd,buf,size)
end_define

begin_define
define|#
directive|define
name|open
parameter_list|(
name|fname
parameter_list|,
name|mode
parameter_list|,
name|prot
parameter_list|)
value|VMS_open (fname,mode,prot)
end_define

begin_define
define|#
directive|define
name|fopen
parameter_list|(
name|fname
parameter_list|,
name|mode
parameter_list|)
value|VMS_fopen (fname,mode)
end_define

begin_define
define|#
directive|define
name|freopen
parameter_list|(
name|fname
parameter_list|,
name|mode
parameter_list|,
name|ofile
parameter_list|)
value|VMS_freopen (fname,mode,ofile)
end_define

begin_define
define|#
directive|define
name|strncat
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|cnt
parameter_list|)
value|VMS_strncat (dst,src,cnt)
end_define

begin_function_decl
specifier|static
name|char
modifier|*
name|VMS_strncat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|VMS_read
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|VMS_write
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|VMS_open
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FILE
modifier|*
name|VMS_fopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FILE
modifier|*
name|VMS_freopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hack_vms_include_specification
parameter_list|()
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
label|:
literal|16
operator|,
operator|:
literal|16
operator|,
operator|:
literal|16
expr_stmt|;
block|}
name|vms_ino_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ino_t
value|vms_ino_t
end_define

begin_define
define|#
directive|define
name|INCLUDE_LEN_FUDGE
value|10
end_define

begin_comment
comment|/* leave room for VMS syntax conversion */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|BSTRING
end_define

begin_comment
comment|/* VMS/GCC supplies the bstring routines */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __GNUC__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_undef
undef|#
directive|undef
name|MAX
end_undef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|((X)< (Y) ? (X) : (Y))
end_define

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
value|((X)> (Y) ? (X) : (Y))
end_define

begin_comment
comment|/* Find the largest host integer type and set its size and type.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_BITS_PER_WIDE_INT
end_ifndef

begin_if
if|#
directive|if
name|HOST_BITS_PER_LONG
operator|>
name|HOST_BITS_PER_INT
end_if

begin_define
define|#
directive|define
name|HOST_BITS_PER_WIDE_INT
value|HOST_BITS_PER_LONG
end_define

begin_define
define|#
directive|define
name|HOST_WIDE_INT
value|long
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HOST_BITS_PER_WIDE_INT
value|HOST_BITS_PER_INT
end_define

begin_define
define|#
directive|define
name|HOST_WIDE_INT
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISREG
end_ifndef

begin_define
define|#
directive|define
name|S_ISREG
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFREG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISDIR
end_ifndef

begin_define
define|#
directive|define
name|S_ISDIR
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFDIR)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define a generic NULL if one hasn't already been defined.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|GENERIC_PTR
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_PROTOTYPES
argument_list|)
condition|?
name|USE_PROTOTYPES
expr|:
name|defined
argument_list|(
name|__STDC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|GENERIC_PTR
value|void *
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|GENERIC_PTR
value|char *
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NULL_PTR
end_ifndef

begin_define
define|#
directive|define
name|NULL_PTR
value|((GENERIC_PTR)0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INCLUDE_LEN_FUDGE
end_ifndef

begin_define
define|#
directive|define
name|INCLUDE_LEN_FUDGE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_function_decl
name|char
modifier|*
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|warning
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* External declarations.  */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|fdopen
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STRERROR
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|bsd4_4
argument_list|)
operator|||
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
specifier|const
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* HAVE_STERRROR */
end_comment

begin_function_decl
name|char
modifier|*
name|strerror
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* VMS */
end_comment

begin_function_decl
name|char
modifier|*
name|strerror
parameter_list|(
name|int
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|int
name|parse_escape
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|HOST_WIDE_INT
name|parse_c_expression
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|errno
end_ifndef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_struct_decl
struct_decl|struct
name|directive
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|file_buf
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|arglist
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|argdata
struct_decl|;
end_struct_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|BSTRING
end_ifndef

begin_function_decl
name|void
name|bcopy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bzero
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bcmp
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* These functions are declared to return int instead of void since they    are going to be placed in a table and some old compilers have trouble with    pointers to functions returning void.  */
end_comment

begin_function_decl
specifier|static
name|int
name|do_define
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_line
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_include
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_undef
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_pragma
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_ident
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_if
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_xifdef
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_else
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_elif
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_endif
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_sccs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_once
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_assert
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_unassert
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_warning
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_import
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|append_include_chain
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|deps_output
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_undef
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_definition
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_assertion
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|path_include
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initialize_builtins
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initialize_char_syntax
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_arg_n
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_defn_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_macro
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trigraph_pcp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rescan
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|finclude
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|validate_else
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|comp_def_part
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|error_from_errno
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|error_with_line
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pedwarn
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pedwarn_with_line
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pedwarn_with_file_and_line
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fatal
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fancy_abort
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pfatal_with_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|perror_with_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pipe_closed
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_containing_files
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lookup_import
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|redundant_include_p
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|is_system_include
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|struct
name|file_name_map
modifier|*
name|read_name_map
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|read_filename_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|open_include_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_preconditions
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcfinclude
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcstring_used
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|write_output
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_macro_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_defs
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_token_lists
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HOST_WIDE_INT
name|eval_if_expression
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|discard_comments
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|change_newlines
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|line_for_error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hashf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|file_size_and_mode
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|arglist
modifier|*
name|read_token_list
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_token_list
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|hashnode
modifier|*
name|install
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|hashnode
modifier|*
name|lookup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|assertion_hashnode
modifier|*
name|assertion_install
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|assertion_hashnode
modifier|*
name|assertion_lookup
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|xrealloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|xcalloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|savestring
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_assertion
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|macroexpand
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_all_macros
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|conditional_skip
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|skip_if_group
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_line_command
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Last arg to output_line_command.  */
end_comment

begin_enum
enum|enum
name|file_change_code
block|{
name|same_file
block|,
name|enter_file
block|,
name|leave_file
block|}
enum|;
end_enum

begin_function_decl
specifier|static
name|int
name|grow_outbuf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|handle_directive
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|memory_full
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|U_CHAR
modifier|*
name|macarg1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|macarg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|U_CHAR
modifier|*
name|skip_to_end_of_comment
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|U_CHAR
modifier|*
name|skip_quoted_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|U_CHAR
modifier|*
name|skip_paren_group
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|quote_string
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|check_precompiled
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* static struct macrodef create_definition ();	[moved below] */
end_comment

begin_function_decl
specifier|static
name|void
name|dump_single_macro
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_dots
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|FAILURE_EXIT_CODE
end_ifndef

begin_define
define|#
directive|define
name|FAILURE_EXIT_CODE
value|33
end_define

begin_comment
comment|/* gnu cc command understands this */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SUCCESS_EXIT_CODE
end_ifndef

begin_define
define|#
directive|define
name|SUCCESS_EXIT_CODE
value|0
end_define

begin_comment
comment|/* 0 means success on Unix.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Name under which this program was invoked.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means use extra default include directories for C++.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cplusplus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means handle cplusplus style comments */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cplusplus_comments
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means handle #import, for objective C.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|objc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means this is an assembly file, and allow    unknown directives, which could be comments.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lang_asm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current maximum length of directory names in the search path    for include files.  (Altered as we get more of them.)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_include_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means turn NOTREACHED into #pragma NOTREACHED etc */
end_comment

begin_decl_stmt
specifier|static
name|int
name|for_lint
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means copy comments into the output file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|put_out_comments
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't process the ANSI trigraph sequences.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_trigraphs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means print the names of included files rather than    the preprocessed output.  1 means just the #include "...",    2 means #include<...> as well.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_deps
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if missing .h files in -M output are assumed to be generated    files and not errors.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_deps_missing_files
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means print names of header files (-H).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_include_names
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't output line number information.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_line_commands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means output the text in failing conditionals,    inside #failed ... #endfailed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|output_conditionals
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* dump_only means inhibit output of the preprocessed text              and instead output the definitions of all user-defined              macros in a form suitable for use as input to cccp.    dump_names means pass #define and the macro name through to output.    dump_definitions means pass the whole definition (plus #define) through */
end_comment

begin_enum
specifier|static
enum|enum
block|{
name|dump_none
block|,
name|dump_only
block|,
name|dump_names
block|,
name|dump_definitions
block|}
name|dump_macros
init|=
name|dump_none
enum|;
end_enum

begin_comment
comment|/* Nonzero means pass all #define and #undef directives which we actually    process through to the output stream.  This feature is used primarily    to allow cc1 to record the #defines and #undefs for the sake of    debuggers which understand about preprocessor macros, but it may    also be useful with -E to figure out how symbols are defined, and    where they are defined.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug_output
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero indicates special processing used by the pcp program.  The    special effects of this mode are:             Inhibit all macro expansion, except those inside #if directives.       Process #define directives normally, and output their contents       to the output file.       Output preconditions to pcp_outfile indicating all the relevant      preconditions for use of this file in a later cpp run. */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|pcp_outfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means we are inside an IF during a -pcp run.  In this mode    macro expansion is done, and preconditions are output for all macro    uses requiring them. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pcp_inside_if
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means never to include precompiled files.    This is 1 since there's no way now to make precompiled files,    so it's not worth testing for them.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_precomp
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give all the error messages the ANSI standard requires.  */
end_comment

begin_decl_stmt
name|int
name|pedantic
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means try to make failure to fit ANSI C an error.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pedantic_errors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't print warning messages.  -w.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|inhibit_warnings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn if slash-star appears in a comment.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warn_comments
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn if a macro argument is (or would be)    stringified with -traditional.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warn_stringify
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn if there are any trigraphs.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warn_trigraphs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn if #import is used.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warn_import
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means turn warnings into errors.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|warnings_are_errors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means try to imitate old fashioned non-ANSI preprocessor.  */
end_comment

begin_decl_stmt
name|int
name|traditional
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero causes output not to be done,    but directives such as #define that have side effects    are still obeyed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means this file was included with a -imacros or -include    command line and should not be recorded as an include file.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|no_record_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means that we have finished processing the command line options.    This flag is used to decide whether or not to issue certain errors    and/or warnings.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|done_initializing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Line where a newline was first seen in a string constant.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|multiline_string_line
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* I/O buffer structure.    The `fname' field is nonzero for source files and #include files    and for the dummy text used for -D and -U.    It is zero for rescanning results of macro expansion    and for expanding macro arguments.  */
end_comment

begin_define
define|#
directive|define
name|INPUT_STACK_MAX
value|400
end_define

begin_struct
specifier|static
struct|struct
name|file_buf
block|{
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* Filename specified with #line command.  */
name|char
modifier|*
name|nominal_fname
decl_stmt|;
comment|/* Record where in the search path this file was found.      For #include_next.  */
name|struct
name|file_name_list
modifier|*
name|dir
decl_stmt|;
name|int
name|lineno
decl_stmt|;
name|int
name|length
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|bufp
decl_stmt|;
comment|/* Macro that this level is the expansion of.      Included so that we can reenable the macro      at the end of this level.  */
name|struct
name|hashnode
modifier|*
name|macro
decl_stmt|;
comment|/* Value of if_stack at start of this file.      Used to prohibit unmatched #endif (etc) in an include file.  */
name|struct
name|if_stack
modifier|*
name|if_stack
decl_stmt|;
comment|/* Object to be freed at end of input at this level.  */
name|U_CHAR
modifier|*
name|free_ptr
decl_stmt|;
comment|/* True if this is a header file included using<FILENAME>.  */
name|char
name|system_header_p
decl_stmt|;
block|}
name|instack
index|[
name|INPUT_STACK_MAX
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|last_error_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Incremented each time we print it.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|input_file_stack_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Incremented when the status changes.  */
end_comment

begin_comment
comment|/* Current nesting level of input sources.    `instack[indepth]' is the level currently being read.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|indepth
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CHECK_DEPTH
parameter_list|(
name|code
parameter_list|)
define|\
value|if (indepth>= (INPUT_STACK_MAX - 1))					\     {									\       error_with_line (line_for_error (instack[indepth].lineno),	\ 		       "macro or `#include' recursion too deep");	\       code;								\     }
end_define

begin_comment
comment|/* Current depth in #include directives that use<...>.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|system_include_depth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|struct
name|file_buf
name|FILE_BUF
typedef|;
end_typedef

begin_comment
comment|/* The output buffer.  Its LENGTH field is the amount of room allocated    for the buffer, not the number of chars actually present.  To get    that, subtract outbuf.buf from outbuf.bufp. */
end_comment

begin_define
define|#
directive|define
name|OUTBUF_SIZE
value|10
end_define

begin_comment
comment|/* initial size of output buffer */
end_comment

begin_decl_stmt
specifier|static
name|FILE_BUF
name|outbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Grow output buffer OBUF points at    so it can hold at least NEEDED more chars.  */
end_comment

begin_define
define|#
directive|define
name|check_expand
parameter_list|(
name|OBUF
parameter_list|,
name|NEEDED
parameter_list|)
define|\
value|(((OBUF)->length - ((OBUF)->bufp - (OBUF)->buf)<= (NEEDED))   \    ? grow_outbuf ((OBUF), (NEEDED)) : 0)
end_define

begin_struct
struct|struct
name|file_name_list
block|{
name|struct
name|file_name_list
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* If the following is nonzero, it is a macro name.        Don't include the file again if that macro is defined.  */
name|U_CHAR
modifier|*
name|control_macro
decl_stmt|;
comment|/* If the following is nonzero, it is a C-language system include        directory.  */
name|int
name|c_system_include_path
decl_stmt|;
comment|/* Mapping of file names for this directory.  */
name|struct
name|file_name_map
modifier|*
name|name_map
decl_stmt|;
comment|/* Non-zero if name_map is valid.  */
name|int
name|got_name_map
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* #include "file" looks in source file dir, then stack. */
end_comment

begin_comment
comment|/* #include<file> just looks in the stack. */
end_comment

begin_comment
comment|/* -I directories are added to the end, then the defaults are added. */
end_comment

begin_comment
comment|/* The */
end_comment

begin_struct
specifier|static
struct|struct
name|default_include
block|{
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* The name of the directory.  */
name|int
name|cplusplus
decl_stmt|;
comment|/* Only look here if we're compiling C++.  */
name|int
name|cxx_aware
decl_stmt|;
comment|/* Includes in this directory don't need to 				   be wrapped in extern "C" when compiling 				   C++.  */
block|}
name|include_defaults_array
index|[]
ifdef|#
directive|ifdef
name|INCLUDE_DEFAULTS
init|=
name|INCLUDE_DEFAULTS
struct|;
end_struct

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|=
block|{
comment|/* Pick up GNU C++ specific include files.  */
block|{
name|GPLUSPLUS_INCLUDE_DIR
block|,
literal|1
block|,
literal|1
block|}
block|,
ifdef|#
directive|ifdef
name|CROSS_COMPILE
comment|/* This is the dir for fixincludes.  Put it just before        the files that we fix.  */
block|{
name|GCC_INCLUDE_DIR
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* For cross-compilation, this dir name is generated        automatically in Makefile.in.  */
block|{
name|CROSS_INCLUDE_DIR
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* This is another place that the target system's headers might be.  */
block|{
name|TOOL_INCLUDE_DIR
block|,
literal|0
block|,
literal|0
block|}
block|,
else|#
directive|else
comment|/* not CROSS_COMPILE */
comment|/* This should be /usr/local/include and should come before        the fixincludes-fixed header files.  */
block|{
name|LOCAL_INCLUDE_DIR
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* This is here ahead of GCC_INCLUDE_DIR because assert.h goes here.        Likewise, behind LOCAL_INCLUDE_DIR, where glibc puts its assert.h.  */
block|{
name|TOOL_INCLUDE_DIR
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* This is the dir for fixincludes.  Put it just before        the files that we fix.  */
block|{
name|GCC_INCLUDE_DIR
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Some systems have an extra dir of include files.  */
ifdef|#
directive|ifdef
name|SYSTEM_INCLUDE_DIR
block|{
name|SYSTEM_INCLUDE_DIR
block|,
literal|0
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
name|STANDARD_INCLUDE_DIR
block|,
literal|0
block|,
literal|0
block|}
block|,
endif|#
directive|endif
comment|/* not CROSS_COMPILE */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* no INCLUDE_DEFAULTS */
end_comment

begin_comment
comment|/* The code looks at the defaults through this pointer, rather than through    the constant structure above.  This pointer gets changed if an environment    variable specifies other defaults.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|default_include
modifier|*
name|include_defaults
init|=
name|include_defaults_array
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|file_name_list
modifier|*
name|include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First dir to search */
end_comment

begin_comment
comment|/* First dir to search for<file> */
end_comment

begin_comment
comment|/* This is the first element to use for #include<...>.    If it is 0, use the entire chain for such includes.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|file_name_list
modifier|*
name|first_bracket_include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the first element in the chain that corresponds to    a directory of system header files.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|file_name_list
modifier|*
name|first_system_include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|file_name_list
modifier|*
name|last_include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last in chain */
end_comment

begin_comment
comment|/* Chain of include directories to put at the end of the other chain.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|file_name_list
modifier|*
name|after_include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|file_name_list
modifier|*
name|last_after_include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last in chain */
end_comment

begin_comment
comment|/* Chain to put at the start of the system include files.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|file_name_list
modifier|*
name|before_system
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|file_name_list
modifier|*
name|last_before_system
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last in chain */
end_comment

begin_comment
comment|/* List of included files that contained #pragma once.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|file_name_list
modifier|*
name|dont_repeat_files
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of other included files.    If ->control_macro if nonzero, the file had a #ifndef    around the entire contents, and ->control_macro gives the macro name.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|file_name_list
modifier|*
name|all_include_files
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Directory prefix that should replace `/usr' in the standard    include file directories.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|include_prefix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global list of strings read in from precompiled files.  This list    is kept in the order the strings are read in, with new strings being    added at the end through stringlist_tailp.  We use this list to output    the strings at the end of the run.  */
end_comment

begin_decl_stmt
specifier|static
name|STRINGDEF
modifier|*
name|stringlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|STRINGDEF
modifier|*
modifier|*
name|stringlist_tailp
init|=
operator|&
name|stringlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure returned by create_definition */
end_comment

begin_typedef
typedef|typedef
name|struct
name|macrodef
name|MACRODEF
typedef|;
end_typedef

begin_struct
struct|struct
name|macrodef
block|{
name|struct
name|definition
modifier|*
name|defn
decl_stmt|;
name|U_CHAR
modifier|*
name|symnam
decl_stmt|;
name|int
name|symlen
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|struct
name|macrodef
name|create_definition
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Structure allocated for every #define.  For a simple replacement    such as    	#define foo bar ,    nargs = -1, the `pattern' list is null, and the expansion is just    the replacement text.  Nargs = 0 means a functionlike macro with no args,    e.g.,        #define getchar() getc (stdin) .    When there are args, the expansion is the replacement text with the    args squashed out, and the reflist is a list describing how to    build the output from the input: e.g., "3 chars, then the 1st arg,    then 9 chars, then the 3rd arg, then 0 chars, then the 2nd arg".    The chars here come from the expansion.  Whatever is left of the    expansion after the last arg-occurrence is copied after that arg.    Note that the reflist can be arbitrarily long---    its length depends on the number of times the arguments appear in    the replacement text, not how many args there are.  Example:    #define f(x) x+x+x+x+x+x+x would have replacement text "++++++" and    pattern list      { (0, 1), (1, 1), (1, 1), ..., (1, 1), NULL }    where (x, y) means (nchars, argno). */
end_comment

begin_typedef
typedef|typedef
name|struct
name|definition
name|DEFINITION
typedef|;
end_typedef

begin_struct
struct|struct
name|definition
block|{
name|int
name|nargs
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* length of expansion string */
name|int
name|predefined
decl_stmt|;
comment|/* True if the macro was builtin or */
comment|/* came from the command line */
name|U_CHAR
modifier|*
name|expansion
decl_stmt|;
name|int
name|line
decl_stmt|;
comment|/* Line number of definition */
name|char
modifier|*
name|file
decl_stmt|;
comment|/* File of definition */
name|char
name|rest_args
decl_stmt|;
comment|/* Nonzero if last arg. absorbs the rest */
struct|struct
name|reflist
block|{
name|struct
name|reflist
modifier|*
name|next
decl_stmt|;
name|char
name|stringify
decl_stmt|;
comment|/* nonzero if this arg was preceded by a 				   # operator. */
name|char
name|raw_before
decl_stmt|;
comment|/* Nonzero if a ## operator before arg. */
name|char
name|raw_after
decl_stmt|;
comment|/* Nonzero if a ## operator after arg. */
name|char
name|rest_args
decl_stmt|;
comment|/* Nonzero if this arg. absorbs the rest */
name|int
name|nchars
decl_stmt|;
comment|/* Number of literal chars to copy before 				   this arg occurrence.  */
name|int
name|argno
decl_stmt|;
comment|/* Number of arg to substitute (origin-0) */
block|}
modifier|*
name|pattern
struct|;
union|union
block|{
comment|/* Names of macro args, concatenated in reverse order        with comma-space between them.        The only use of this is that we warn on redefinition        if this differs between the old and new definitions.  */
name|U_CHAR
modifier|*
name|argnames
decl_stmt|;
block|}
name|args
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* different kinds of things that can appear in the value field    of a hash node.  Actually, this may be useless now. */
end_comment

begin_union
union|union
name|hashval
block|{
name|int
name|ival
decl_stmt|;
name|char
modifier|*
name|cpval
decl_stmt|;
name|DEFINITION
modifier|*
name|defn
decl_stmt|;
name|KEYDEF
modifier|*
name|keydef
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/*  * special extension string that can be added to the last macro argument to   * allow it to absorb the "rest" of the arguments when expanded.  Ex:  * 		#define wow(a, b...)		process (b, a, b)  *		{ wow (1, 2, 3); }	->	{ process (2, 3, 1, 2, 3); }  *		{ wow (one, two); }	->	{ process (two, one, two); }  * if this "rest_arg" is used with the concat token '##' and if it is not  * supplied then the token attached to with ## will not be outputted.  Ex:  * 		#define wow (a, b...)		process (b ## , a, ## b)  *		{ wow (1, 2); }		->	{ process (2, 1, 2); }  *		{ wow (one); }		->	{ process (one); {  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rest_extension
index|[]
init|=
literal|"..."
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|REST_EXTENSION_LENGTH
value|(sizeof (rest_extension) - 1)
end_define

begin_comment
comment|/* The structure of a node in the hash table.  The hash table    has entries for all tokens defined by #define commands (type T_MACRO),    plus some special tokens like __LINE__ (these each have their own    type, and the appropriate code is run when that type of node is seen.    It does not contain control words like "#define", which are recognized    by a separate piece of code. */
end_comment

begin_comment
comment|/* different flavors of hash nodes --- also used in keyword table */
end_comment

begin_enum
enum|enum
name|node_type
block|{
name|T_DEFINE
init|=
literal|1
block|,
comment|/* the `#define' keyword */
name|T_INCLUDE
block|,
comment|/* the `#include' keyword */
name|T_INCLUDE_NEXT
block|,
comment|/* the `#include_next' keyword */
name|T_IMPORT
block|,
comment|/* the `#import' keyword */
name|T_IFDEF
block|,
comment|/* the `#ifdef' keyword */
name|T_IFNDEF
block|,
comment|/* the `#ifndef' keyword */
name|T_IF
block|,
comment|/* the `#if' keyword */
name|T_ELSE
block|,
comment|/* `#else' */
name|T_PRAGMA
block|,
comment|/* `#pragma' */
name|T_ELIF
block|,
comment|/* `#elif' */
name|T_UNDEF
block|,
comment|/* `#undef' */
name|T_LINE
block|,
comment|/* `#line' */
name|T_ERROR
block|,
comment|/* `#error' */
name|T_WARNING
block|,
comment|/* `#warning' */
name|T_ENDIF
block|,
comment|/* `#endif' */
name|T_SCCS
block|,
comment|/* `#sccs', used on system V.  */
name|T_IDENT
block|,
comment|/* `#ident', used on system V.  */
name|T_ASSERT
block|,
comment|/* `#assert', taken from system V.  */
name|T_UNASSERT
block|,
comment|/* `#unassert', taken from system V.  */
name|T_SPECLINE
block|,
comment|/* special symbol `__LINE__' */
name|T_DATE
block|,
comment|/* `__DATE__' */
name|T_FILE
block|,
comment|/* `__FILE__' */
name|T_BASE_FILE
block|,
comment|/* `__BASE_FILE__' */
name|T_INCLUDE_LEVEL
block|,
comment|/* `__INCLUDE_LEVEL__' */
name|T_VERSION
block|,
comment|/* `__VERSION__' */
name|T_SIZE_TYPE
block|,
comment|/* `__SIZE_TYPE__' */
name|T_PTRDIFF_TYPE
block|,
comment|/* `__PTRDIFF_TYPE__' */
name|T_WCHAR_TYPE
block|,
comment|/* `__WCHAR_TYPE__' */
name|T_USER_LABEL_PREFIX_TYPE
block|,
comment|/* `__USER_LABEL_PREFIX__' */
name|T_REGISTER_PREFIX_TYPE
block|,
comment|/* `__REGISTER_PREFIX__' */
name|T_TIME
block|,
comment|/* `__TIME__' */
name|T_CONST
block|,
comment|/* Constant value, used by `__STDC__' */
name|T_MACRO
block|,
comment|/* macro defined by `#define' */
name|T_DISABLED
block|,
comment|/* macro temporarily turned off for rescan */
name|T_SPEC_DEFINED
block|,
comment|/* special `defined' macro for use in #if statements */
name|T_PCSTRING
block|,
comment|/* precompiled string (hashval is KEYDEF *) */
name|T_UNUSED
comment|/* Used for something not defined.  */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|hashnode
block|{
name|struct
name|hashnode
modifier|*
name|next
decl_stmt|;
comment|/* double links for easy deletion */
name|struct
name|hashnode
modifier|*
name|prev
decl_stmt|;
name|struct
name|hashnode
modifier|*
modifier|*
name|bucket_hdr
decl_stmt|;
comment|/* also, a back pointer to this node's hash 				   chain is kept, in case the node is the head 				   of the chain and gets deleted. */
name|enum
name|node_type
name|type
decl_stmt|;
comment|/* type of special token */
name|int
name|length
decl_stmt|;
comment|/* length of token, for quick comparison */
name|U_CHAR
modifier|*
name|name
decl_stmt|;
comment|/* the actual name */
name|union
name|hashval
name|value
decl_stmt|;
comment|/* pointer to expansion, or whatever */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|hashnode
name|HASHNODE
typedef|;
end_typedef

begin_comment
comment|/* Some definitions for the hash table.  The hash function MUST be    computed as shown in hashf () below.  That is because the rescan    loop computes the hash value `on the fly' for most tokens,    in order to avoid the overhead of a lot of procedure calls to    the hashf () function.  Hashf () only exists for the sake of    politeness, for use when speed isn't so important. */
end_comment

begin_define
define|#
directive|define
name|HASHSIZE
value|1403
end_define

begin_decl_stmt
specifier|static
name|HASHNODE
modifier|*
name|hashtab
index|[
name|HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HASHSTEP
parameter_list|(
name|old
parameter_list|,
name|c
parameter_list|)
value|((old<< 2) + c)
end_define

begin_define
define|#
directive|define
name|MAKE_POS
parameter_list|(
name|v
parameter_list|)
value|(v& 0x7fffffff)
end_define

begin_comment
comment|/* make number positive */
end_comment

begin_comment
comment|/* Symbols to predefine.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CPP_PREDEFINES
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|predefs
init|=
name|CPP_PREDEFINES
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
modifier|*
name|predefs
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* We let tm.h override the types used here, to handle trivial differences    such as the choice of unsigned int or long unsigned int for size_t.    When machines start needing nontrivial differences in the size type,    it would be best to do something here to figure out automatically    from other information what type to use.  */
end_comment

begin_comment
comment|/* The string value for __SIZE_TYPE__.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIZE_TYPE
end_ifndef

begin_define
define|#
directive|define
name|SIZE_TYPE
value|"long unsigned int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The string value for __PTRDIFF_TYPE__.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PTRDIFF_TYPE
end_ifndef

begin_define
define|#
directive|define
name|PTRDIFF_TYPE
value|"long int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The string value for __WCHAR_TYPE__.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WCHAR_TYPE
end_ifndef

begin_define
define|#
directive|define
name|WCHAR_TYPE
value|"int"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|wchar_type
init|=
name|WCHAR_TYPE
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|WCHAR_TYPE
end_undef

begin_comment
comment|/* The string value for __USER_LABEL_PREFIX__ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USER_LABEL_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|USER_LABEL_PREFIX
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The string value for __REGISTER_PREFIX__ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|REGISTER_PREFIX
end_ifndef

begin_define
define|#
directive|define
name|REGISTER_PREFIX
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* In the definition of a #assert name, this structure forms    a list of the individual values asserted.    Each value is itself a list of "tokens".    These are strings that are compared by name.  */
end_comment

begin_struct
struct|struct
name|tokenlist_list
block|{
name|struct
name|tokenlist_list
modifier|*
name|next
decl_stmt|;
name|struct
name|arglist
modifier|*
name|tokens
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|assertion_hashnode
block|{
name|struct
name|assertion_hashnode
modifier|*
name|next
decl_stmt|;
comment|/* double links for easy deletion */
name|struct
name|assertion_hashnode
modifier|*
name|prev
decl_stmt|;
comment|/* also, a back pointer to this node's hash      chain is kept, in case the node is the head      of the chain and gets deleted. */
name|struct
name|assertion_hashnode
modifier|*
modifier|*
name|bucket_hdr
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* length of token, for quick comparison */
name|U_CHAR
modifier|*
name|name
decl_stmt|;
comment|/* the actual name */
comment|/* List of token-sequences.  */
name|struct
name|tokenlist_list
modifier|*
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|assertion_hashnode
name|ASSERTION_HASHNODE
typedef|;
end_typedef

begin_comment
comment|/* Some definitions for the hash table.  The hash function MUST be    computed as shown in hashf below.  That is because the rescan    loop computes the hash value `on the fly' for most tokens,    in order to avoid the overhead of a lot of procedure calls to    the hashf function.  hashf only exists for the sake of    politeness, for use when speed isn't so important. */
end_comment

begin_define
define|#
directive|define
name|ASSERTION_HASHSIZE
value|37
end_define

begin_decl_stmt
specifier|static
name|ASSERTION_HASHNODE
modifier|*
name|assertion_hashtab
index|[
name|ASSERTION_HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means inhibit macroexpansion of what seem to be    assertion tests, in rescan.  For #if.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|assertions_flag
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* `struct directive' defines one #-directive, including how to handle it.  */
end_comment

begin_struct
struct|struct
name|directive
block|{
name|int
name|length
decl_stmt|;
comment|/* Length of name */
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
comment|/* Function to handle directive */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of directive */
name|enum
name|node_type
name|type
decl_stmt|;
comment|/* Code which describes which directive. */
name|char
name|angle_brackets
decl_stmt|;
comment|/* Nonzero =><...> is special.  */
name|char
name|traditional_comments
decl_stmt|;
comment|/* Nonzero: keep comments if -traditional.  */
name|char
name|pass_thru
decl_stmt|;
comment|/* Copy preprocessed directive to output file.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Here is the actual list of #-directives, most-often-used first.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|directive
name|directive_table
index|[]
init|=
block|{
block|{
literal|6
block|,
name|do_define
block|,
literal|"define"
block|,
name|T_DEFINE
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|2
block|,
name|do_if
block|,
literal|"if"
block|,
name|T_IF
block|}
block|,
block|{
literal|5
block|,
name|do_xifdef
block|,
literal|"ifdef"
block|,
name|T_IFDEF
block|}
block|,
block|{
literal|6
block|,
name|do_xifdef
block|,
literal|"ifndef"
block|,
name|T_IFNDEF
block|}
block|,
block|{
literal|5
block|,
name|do_endif
block|,
literal|"endif"
block|,
name|T_ENDIF
block|}
block|,
block|{
literal|4
block|,
name|do_else
block|,
literal|"else"
block|,
name|T_ELSE
block|}
block|,
block|{
literal|4
block|,
name|do_elif
block|,
literal|"elif"
block|,
name|T_ELIF
block|}
block|,
block|{
literal|4
block|,
name|do_line
block|,
literal|"line"
block|,
name|T_LINE
block|}
block|,
block|{
literal|7
block|,
name|do_include
block|,
literal|"include"
block|,
name|T_INCLUDE
block|,
literal|1
block|}
block|,
block|{
literal|12
block|,
name|do_include
block|,
literal|"include_next"
block|,
name|T_INCLUDE_NEXT
block|,
literal|1
block|}
block|,
block|{
literal|6
block|,
name|do_include
block|,
literal|"import"
block|,
name|T_IMPORT
block|,
literal|1
block|}
block|,
block|{
literal|5
block|,
name|do_undef
block|,
literal|"undef"
block|,
name|T_UNDEF
block|}
block|,
block|{
literal|5
block|,
name|do_error
block|,
literal|"error"
block|,
name|T_ERROR
block|}
block|,
block|{
literal|7
block|,
name|do_warning
block|,
literal|"warning"
block|,
name|T_WARNING
block|}
block|,
ifdef|#
directive|ifdef
name|SCCS_DIRECTIVE
block|{
literal|4
block|,
name|do_sccs
block|,
literal|"sccs"
block|,
name|T_SCCS
block|}
block|,
endif|#
directive|endif
block|{
literal|6
block|,
name|do_pragma
block|,
literal|"pragma"
block|,
name|T_PRAGMA
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|5
block|,
name|do_ident
block|,
literal|"ident"
block|,
name|T_IDENT
block|}
block|,
block|{
literal|6
block|,
name|do_assert
block|,
literal|"assert"
block|,
name|T_ASSERT
block|}
block|,
block|{
literal|8
block|,
name|do_unassert
block|,
literal|"unassert"
block|,
name|T_UNASSERT
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|""
block|,
name|T_UNUSED
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When a directive handler is called,    this points to the # that started the directive.  */
end_comment

begin_decl_stmt
name|U_CHAR
modifier|*
name|directive_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table to tell if char can be part of a C identifier. */
end_comment

begin_decl_stmt
name|U_CHAR
name|is_idchar
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table to tell if char can be first char of a c identifier. */
end_comment

begin_decl_stmt
name|U_CHAR
name|is_idstart
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table to tell if c is horizontal space.  */
end_comment

begin_decl_stmt
name|U_CHAR
name|is_hor_space
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table to tell if c is horizontal or vertical space.  */
end_comment

begin_decl_stmt
specifier|static
name|U_CHAR
name|is_space
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SKIP_WHITE_SPACE
parameter_list|(
name|p
parameter_list|)
value|do { while (is_hor_space[*p]) p++; } while (0)
end_define

begin_define
define|#
directive|define
name|SKIP_ALL_WHITE_SPACE
parameter_list|(
name|p
parameter_list|)
value|do { while (is_space[*p]) p++; } while (0)
end_define

begin_decl_stmt
specifier|static
name|int
name|errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Error counter for exit code */
end_comment

begin_comment
comment|/* Name of output file, for error messages.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|out_fname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Zero means dollar signs are punctuation.    -$ stores 0; -traditional may store 1.  Default is 1 for VMS, 0 otherwise.    This must be 0 for correct processing of this ANSI C program: 	#define foo(a) #a 	#define lose(b) foo (b) 	#define test$ 	lose (test)	*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|dollars_in_ident
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|DOLLARS_IN_IDENTIFIERS
end_ifndef

begin_define
define|#
directive|define
name|DOLLARS_IN_IDENTIFIERS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|FILE_BUF
name|expand_to_temp_buffer
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|DEFINITION
modifier|*
name|collect_expansion
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Stack of conditionals currently in progress    (including both successful and failing conditionals).  */
end_comment

begin_struct
struct|struct
name|if_stack
block|{
name|struct
name|if_stack
modifier|*
name|next
decl_stmt|;
comment|/* for chaining to the next stack frame */
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* copied from input when frame is made */
name|int
name|lineno
decl_stmt|;
comment|/* similarly */
name|int
name|if_succeeded
decl_stmt|;
comment|/* true if a leg of this if-group 				    has been passed through rescan */
name|U_CHAR
modifier|*
name|control_macro
decl_stmt|;
comment|/* For #ifndef at start of file, 				   this is the macro name tested.  */
name|enum
name|node_type
name|type
decl_stmt|;
comment|/* type of last directive seen in this group */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|if_stack
name|IF_STACK_FRAME
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|IF_STACK_FRAME
modifier|*
name|if_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer of -M output.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|deps_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes allocated in above.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|deps_allocated_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes used.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|deps_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes since the last newline.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|deps_column
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means -I- has been seen,    so don't look for #include "foo" the source-file directory.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ignore_srcdir
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Read LEN bytes at PTR from descriptor DESC, for file FILENAME,    retrying if necessary.  Return a negative value if an error occurs,    otherwise return the actual number of bytes read,    which must be LEN unless end-of-file was reached.  */
end_comment

begin_function
specifier|static
name|int
name|safe_read
parameter_list|(
name|desc
parameter_list|,
name|ptr
parameter_list|,
name|len
parameter_list|)
name|int
name|desc
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|left
init|=
name|len
decl_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
name|int
name|nchars
init|=
name|read
argument_list|(
name|desc
argument_list|,
name|ptr
argument_list|,
name|left
argument_list|)
decl_stmt|;
if|if
condition|(
name|nchars
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|EINTR
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
endif|#
directive|endif
return|return
name|nchars
return|;
block|}
if|if
condition|(
name|nchars
operator|==
literal|0
condition|)
break|break;
name|ptr
operator|+=
name|nchars
expr_stmt|;
name|left
operator|-=
name|nchars
expr_stmt|;
block|}
return|return
name|len
operator|-
name|left
return|;
block|}
end_function

begin_comment
comment|/* Write LEN bytes at PTR to descriptor DESC,    retrying if necessary, and treating any real error as fatal.  */
end_comment

begin_function
specifier|static
name|void
name|safe_write
parameter_list|(
name|desc
parameter_list|,
name|ptr
parameter_list|,
name|len
parameter_list|)
name|int
name|desc
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|int
name|written
init|=
name|write
argument_list|(
name|desc
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|written
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|EINTR
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
endif|#
directive|endif
name|pfatal_with_name
argument_list|(
name|out_fname
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|+=
name|written
expr_stmt|;
name|len
operator|-=
name|written
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|st_mode
decl_stmt|;
name|long
name|st_size
decl_stmt|;
name|char
modifier|*
name|in_fname
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|f
decl_stmt|,
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
modifier|*
name|pend_files
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|pend_defs
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|pend_undefs
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|pend_assertions
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|pend_includes
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Record the option used with each element of pend_assertions.      This is preparation for supporting more than one option for making      an assertion.  */
name|char
modifier|*
modifier|*
name|pend_assertion_options
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|inhibit_predefs
init|=
literal|0
decl_stmt|;
name|int
name|no_standard_includes
init|=
literal|0
decl_stmt|;
name|int
name|no_standard_cplusplus_includes
init|=
literal|0
decl_stmt|;
name|int
name|missing_newline
init|=
literal|0
decl_stmt|;
comment|/* Non-0 means don't output the preprocessed program.  */
name|int
name|inhibit_output
init|=
literal|0
decl_stmt|;
comment|/* Non-0 means -v, so print the full set of include dirs.  */
name|int
name|verbose
init|=
literal|0
decl_stmt|;
comment|/* File name which deps are being written to.      This is 0 if deps are being written to stdout.  */
name|char
modifier|*
name|deps_file
init|=
literal|0
decl_stmt|;
comment|/* Fopen file mode to open deps_file with.  */
name|char
modifier|*
name|deps_mode
init|=
literal|"a"
decl_stmt|;
comment|/* Stream on which to print the dependency information.  */
name|FILE
modifier|*
name|deps_stream
init|=
literal|0
decl_stmt|;
comment|/* Target-name to write with the dependency information.  */
name|char
modifier|*
name|deps_target
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|RLIMIT_STACK
comment|/* Get rid of any avoidable limit on stack size.  */
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
comment|/* Set the stack limit huge so that alloca (particularly stringtab      * in dbxread.c) does not fail. */
name|getrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
name|rlim
operator|.
name|rlim_max
expr_stmt|;
name|setrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RLIMIT_STACK defined */
ifdef|#
directive|ifdef
name|SIGPIPE
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pipe_closed
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|=
name|argv
index|[
literal|0
index|]
operator|+
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|argv
index|[
literal|0
index|]
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
ifdef|#
directive|ifdef
name|DIR_SEPARATOR
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
name|DIR_SEPARATOR
endif|#
directive|endif
condition|)
operator|--
name|p
expr_stmt|;
name|progname
operator|=
name|p
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
block|{
comment|/* Remove directories from PROGNAME.  */
name|char
modifier|*
name|s
decl_stmt|;
name|progname
operator|=
name|savestring
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|rindex
argument_list|(
name|progname
argument_list|,
literal|']'
argument_list|)
operator|)
condition|)
name|s
operator|=
name|rindex
argument_list|(
name|progname
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|strcpy
argument_list|(
name|progname
argument_list|,
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|=
name|rindex
argument_list|(
name|progname
argument_list|,
literal|'.'
argument_list|)
condition|)
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
name|in_fname
operator|=
name|NULL
expr_stmt|;
name|out_fname
operator|=
name|NULL
expr_stmt|;
comment|/* Initialize is_idchar to allow $.  */
name|dollars_in_ident
operator|=
literal|1
expr_stmt|;
name|initialize_char_syntax
argument_list|()
expr_stmt|;
name|dollars_in_ident
operator|=
name|DOLLARS_IN_IDENTIFIERS
operator|>
literal|0
expr_stmt|;
name|no_line_commands
operator|=
literal|0
expr_stmt|;
name|no_trigraphs
operator|=
literal|1
expr_stmt|;
name|dump_macros
operator|=
name|dump_none
expr_stmt|;
name|no_output
operator|=
literal|0
expr_stmt|;
name|cplusplus
operator|=
literal|0
expr_stmt|;
name|cplusplus_comments
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pend_files
argument_list|,
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pend_defs
argument_list|,
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pend_undefs
argument_list|,
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pend_assertions
argument_list|,
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pend_includes
argument_list|,
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Process switches and find input file name.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
if|if
condition|(
name|out_fname
operator|!=
name|NULL
condition|)
name|fatal
argument_list|(
literal|"Usage: %s [switches] input output"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|in_fname
operator|!=
name|NULL
condition|)
name|out_fname
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
else|else
name|in_fname
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'i'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-include"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Filename missing after `-include' option"
argument_list|)
expr_stmt|;
else|else
name|pend_includes
index|[
name|i
index|]
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
operator|,
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-imacros"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Filename missing after `-imacros' option"
argument_list|)
expr_stmt|;
else|else
name|pend_files
index|[
name|i
index|]
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
operator|,
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-iprefix"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Filename missing after `-iprefix' option"
argument_list|)
expr_stmt|;
else|else
name|include_prefix
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-ifoutput"
argument_list|)
condition|)
block|{
name|output_conditionals
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-isystem"
argument_list|)
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Filename missing after `-isystem' option"
argument_list|)
expr_stmt|;
name|dirtmp
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|dirtmp
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|dirtmp
operator|->
name|c_system_include_path
operator|=
literal|1
expr_stmt|;
name|dirtmp
operator|->
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dirtmp
operator|->
name|fname
argument_list|,
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|got_name_map
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|before_system
operator|==
literal|0
condition|)
name|before_system
operator|=
name|dirtmp
expr_stmt|;
else|else
name|last_before_system
operator|->
name|next
operator|=
name|dirtmp
expr_stmt|;
name|last_before_system
operator|=
name|dirtmp
expr_stmt|;
comment|/* Tail follows the last one */
block|}
comment|/* Add directory to end of path for includes, 	   with the default prefix at the front of its name.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-iwithprefix"
argument_list|)
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
if|if
condition|(
name|include_prefix
operator|!=
literal|0
condition|)
name|prefix
operator|=
name|include_prefix
expr_stmt|;
else|else
block|{
name|prefix
operator|=
name|savestring
argument_list|(
name|GCC_INCLUDE_DIR
argument_list|)
expr_stmt|;
comment|/* Remove the `include' from /usr/local/lib/gcc.../include.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|prefix
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|-
literal|8
argument_list|,
literal|"/include"
argument_list|)
condition|)
name|prefix
index|[
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|-
literal|7
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|dirtmp
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* New one goes on the end */
name|dirtmp
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|dirtmp
operator|->
name|c_system_include_path
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Directory name missing after `-iwithprefix' option"
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dirtmp
operator|->
name|fname
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dirtmp
operator|->
name|fname
argument_list|,
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|got_name_map
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|after_include
operator|==
literal|0
condition|)
name|after_include
operator|=
name|dirtmp
expr_stmt|;
else|else
name|last_after_include
operator|->
name|next
operator|=
name|dirtmp
expr_stmt|;
name|last_after_include
operator|=
name|dirtmp
expr_stmt|;
comment|/* Tail follows the last one */
block|}
comment|/* Add directory to main path for includes, 	   with the default prefix at the front of its name.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-iwithprefixbefore"
argument_list|)
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
if|if
condition|(
name|include_prefix
operator|!=
literal|0
condition|)
name|prefix
operator|=
name|include_prefix
expr_stmt|;
else|else
block|{
name|prefix
operator|=
name|savestring
argument_list|(
name|GCC_INCLUDE_DIR
argument_list|)
expr_stmt|;
comment|/* Remove the `include' from /usr/local/lib/gcc.../include.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|prefix
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|-
literal|8
argument_list|,
literal|"/include"
argument_list|)
condition|)
name|prefix
index|[
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|-
literal|7
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|dirtmp
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* New one goes on the end */
name|dirtmp
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|dirtmp
operator|->
name|c_system_include_path
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Directory name missing after `-iwithprefixbefore' option"
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dirtmp
operator|->
name|fname
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dirtmp
operator|->
name|fname
argument_list|,
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|got_name_map
operator|=
literal|0
expr_stmt|;
name|append_include_chain
argument_list|(
name|dirtmp
argument_list|,
name|dirtmp
argument_list|)
expr_stmt|;
block|}
comment|/* Add directory to end of path for includes.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-idirafter"
argument_list|)
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
name|dirtmp
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* New one goes on the end */
name|dirtmp
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|dirtmp
operator|->
name|c_system_include_path
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Directory name missing after `-idirafter' option"
argument_list|)
expr_stmt|;
else|else
name|dirtmp
operator|->
name|fname
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
name|dirtmp
operator|->
name|got_name_map
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|after_include
operator|==
literal|0
condition|)
name|after_include
operator|=
name|dirtmp
expr_stmt|;
else|else
name|last_after_include
operator|->
name|next
operator|=
name|dirtmp
expr_stmt|;
name|last_after_include
operator|=
name|dirtmp
expr_stmt|;
comment|/* Tail follows the last one */
block|}
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|out_fname
operator|!=
name|NULL
condition|)
name|fatal
argument_list|(
literal|"Output filename specified twice"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Filename missing after -o option"
argument_list|)
expr_stmt|;
name|out_fname
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|out_fname
argument_list|,
literal|"-"
argument_list|)
condition|)
name|out_fname
operator|=
literal|""
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-pedantic"
argument_list|)
condition|)
name|pedantic
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-pedantic-errors"
argument_list|)
condition|)
block|{
name|pedantic
operator|=
literal|1
expr_stmt|;
name|pedantic_errors
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-pcp"
argument_list|)
condition|)
block|{
name|char
modifier|*
name|pcp_fname
decl_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Filename missing after -pcp option"
argument_list|)
expr_stmt|;
name|pcp_fname
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
name|pcp_outfile
operator|=
operator|(
operator|(
name|pcp_fname
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|pcp_fname
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
condition|?
name|fopen
argument_list|(
name|pcp_fname
argument_list|,
literal|"w"
argument_list|)
else|:
name|fdopen
argument_list|(
name|dup
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
argument_list|,
literal|"w"
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|pcp_outfile
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|pcp_fname
argument_list|)
expr_stmt|;
name|no_precomp
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-traditional"
argument_list|)
condition|)
block|{
name|traditional
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dollars_in_ident
operator|>
literal|0
condition|)
name|dollars_in_ident
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-trigraphs"
argument_list|)
condition|)
block|{
name|no_trigraphs
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-c"
argument_list|)
condition|)
name|cplusplus
operator|=
literal|0
operator|,
name|cplusplus_comments
operator|=
literal|0
operator|,
name|objc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-c++"
argument_list|)
condition|)
name|cplusplus
operator|=
literal|1
operator|,
name|cplusplus_comments
operator|=
literal|1
operator|,
name|objc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-c-c++-comments"
argument_list|)
condition|)
name|cplusplus
operator|=
literal|0
operator|,
name|cplusplus_comments
operator|=
literal|1
operator|,
name|objc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-objc"
argument_list|)
condition|)
name|objc
operator|=
literal|1
operator|,
name|cplusplus
operator|=
literal|0
operator|,
name|cplusplus_comments
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-objc++"
argument_list|)
condition|)
name|objc
operator|=
literal|1
operator|,
name|cplusplus
operator|=
literal|1
operator|,
name|cplusplus_comments
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang-asm"
argument_list|)
condition|)
name|lang_asm
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lint"
argument_list|)
condition|)
name|for_lint
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|cplusplus
operator|=
literal|1
operator|,
name|cplusplus_comments
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|inhibit_warnings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wtrigraphs"
argument_list|)
condition|)
name|warn_trigraphs
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-trigraphs"
argument_list|)
condition|)
name|warn_trigraphs
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wcomment"
argument_list|)
condition|)
name|warn_comments
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-comment"
argument_list|)
condition|)
name|warn_comments
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wcomments"
argument_list|)
condition|)
name|warn_comments
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-comments"
argument_list|)
condition|)
name|warn_comments
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wtraditional"
argument_list|)
condition|)
name|warn_stringify
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-traditional"
argument_list|)
condition|)
name|warn_stringify
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wimport"
argument_list|)
condition|)
name|warn_import
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-import"
argument_list|)
condition|)
name|warn_import
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Werror"
argument_list|)
condition|)
name|warnings_are_errors
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wno-error"
argument_list|)
condition|)
name|warnings_are_errors
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wall"
argument_list|)
condition|)
block|{
name|warn_trigraphs
operator|=
literal|1
expr_stmt|;
name|warn_comments
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'M'
case|:
comment|/* The style of the choices here is a bit mixed. 	   The chosen scheme is a hybrid of keeping all options in one string 	   and specifying each option in a separate argument: 	   -M|-MM|-MD file|-MMD file [-MG].  An alternative is: 	   -M|-MM|-MD file|-MMD file|-MG|-MMG; or more concisely: 	   -M[M][G][D file].  This is awkward to handle in specs, and is not 	   as extensible.  */
comment|/* ??? -MG must be specified in addition to one of -M or -MM. 	   This can be relaxed in the future without breaking anything. 	   The converse isn't true.  */
comment|/* -MG isn't valid with -MD or -MMD.  This is checked for later.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MG"
argument_list|)
condition|)
block|{
name|print_deps_missing_files
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-M"
argument_list|)
condition|)
name|print_deps
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MM"
argument_list|)
condition|)
name|print_deps
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MD"
argument_list|)
condition|)
name|print_deps
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MMD"
argument_list|)
condition|)
name|print_deps
operator|=
literal|1
expr_stmt|;
comment|/* For -MD and -MMD options, write deps on file named by next arg.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MD"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MMD"
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Filename missing after %s option"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|deps_file
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
name|deps_mode
operator|=
literal|"w"
expr_stmt|;
block|}
else|else
block|{
comment|/* For -M and -MM, write deps on standard output 	     and suppress the usual output.  */
name|deps_stream
operator|=
name|stdout
expr_stmt|;
name|inhibit_output
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
block|{
name|char
modifier|*
name|p
init|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
decl_stmt|;
name|char
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|p
operator|++
condition|)
block|{
comment|/* Arg to -d specifies what parts of macros to dump */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'M'
case|:
name|dump_macros
operator|=
name|dump_only
expr_stmt|;
name|no_output
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|dump_macros
operator|=
name|dump_names
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|dump_macros
operator|=
name|dump_definitions
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|==
literal|'3'
condition|)
name|debug_output
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GNU CPP version %s"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_VERSION
name|TARGET_VERSION
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|print_include_names
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|pend_defs
index|[
name|i
index|]
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Macro name missing after -D option"
argument_list|)
expr_stmt|;
else|else
name|i
operator|++
operator|,
name|pend_defs
index|[
name|i
index|]
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|p
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Assertion missing after -A option"
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
comment|/* -A- eliminates all predefined macros and assertions. 	       Let's include also any that were specified earlier 	       on the command line.  That way we can get rid of any 	       that were passed automatically in from GCC.  */
name|int
name|j
decl_stmt|;
name|inhibit_predefs
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|pend_defs
index|[
name|j
index|]
operator|=
name|pend_assertions
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|pend_assertions
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
name|pend_assertion_options
index|[
name|i
index|]
operator|=
literal|"-A"
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'U'
case|:
comment|/* JF #undef something */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|pend_undefs
index|[
name|i
index|]
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Macro name missing after -U option"
argument_list|)
expr_stmt|;
else|else
name|pend_undefs
index|[
name|i
index|]
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
operator|,
name|i
operator|++
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|put_out_comments
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* -E comes from cc -E; ignore it.  */
break|break;
case|case
literal|'P'
case|:
name|no_line_commands
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
comment|/* Don't include $ in identifiers.  */
name|dollars_in_ident
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Add directory to path for includes.  */
block|{
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
if|if
condition|(
operator|!
name|ignore_srcdir
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
literal|2
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|ignore_srcdir
operator|=
literal|1
expr_stmt|;
comment|/* Don't use any preceding -I directories for #include<...>.  */
name|first_bracket_include
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|dirtmp
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* New one goes on the end */
name|dirtmp
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|dirtmp
operator|->
name|c_system_include_path
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|dirtmp
operator|->
name|fname
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Directory name missing after -I option"
argument_list|)
expr_stmt|;
else|else
name|dirtmp
operator|->
name|fname
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
name|dirtmp
operator|->
name|got_name_map
operator|=
literal|0
expr_stmt|;
name|append_include_chain
argument_list|(
name|dirtmp
argument_list|,
name|dirtmp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-nostdinc"
argument_list|)
condition|)
comment|/* -nostdinc causes no default include directories. 	     You must specify all include-file directories with -I.  */
name|no_standard_includes
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-nostdinc++"
argument_list|)
condition|)
comment|/* -nostdinc++ causes no default C++-specific include directories. */
name|no_standard_cplusplus_includes
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-noprecomp"
argument_list|)
condition|)
name|no_precomp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Sun compiler passes undocumented switch "-undef". 	   Let's assume it means to inhibit the predefined symbols.  */
name|inhibit_predefs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
comment|/* JF handle '-' as file name meaning stdin or stdout */
if|if
condition|(
name|in_fname
operator|==
name|NULL
condition|)
block|{
name|in_fname
operator|=
literal|""
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|out_fname
operator|==
name|NULL
condition|)
block|{
name|out_fname
operator|=
literal|""
expr_stmt|;
break|break;
block|}
comment|/* else fall through into error */
default|default:
name|fatal
argument_list|(
literal|"Invalid option `%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Add dirs from CPATH after dirs from -I.  */
comment|/* There seems to be confusion about what CPATH should do,      so for the moment it is not documented.  */
comment|/* Some people say that CPATH should replace the standard include dirs,      but that seems pointless: it comes before them, so it overrides them      anyway.  */
ifdef|#
directive|ifdef
name|WINNT
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"Include"
argument_list|)
expr_stmt|;
else|#
directive|else
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"CPATH"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|!=
literal|0
operator|&&
operator|!
name|no_standard_includes
condition|)
name|path_include
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Now that dollars_in_ident is known, initialize is_idchar.  */
name|initialize_char_syntax
argument_list|()
expr_stmt|;
comment|/* Initialize output buffer */
name|outbuf
operator|.
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|OUTBUF_SIZE
argument_list|)
expr_stmt|;
name|outbuf
operator|.
name|bufp
operator|=
name|outbuf
operator|.
name|buf
expr_stmt|;
name|outbuf
operator|.
name|length
operator|=
name|OUTBUF_SIZE
expr_stmt|;
comment|/* Do partial setup of input buffer for the sake of generating      early #line directives (when -g is in effect).  */
name|fp
operator|=
operator|&
name|instack
index|[
operator|++
name|indepth
index|]
expr_stmt|;
if|if
condition|(
name|in_fname
operator|==
name|NULL
condition|)
name|in_fname
operator|=
literal|""
expr_stmt|;
name|fp
operator|->
name|nominal_fname
operator|=
name|fp
operator|->
name|fname
operator|=
name|in_fname
expr_stmt|;
name|fp
operator|->
name|lineno
operator|=
literal|0
expr_stmt|;
comment|/* In C++, wchar_t is a distinct basic type, and we can expect      __wchar_t to be defined by cc1plus.  */
if|if
condition|(
name|cplusplus
condition|)
name|wchar_type
operator|=
literal|"__wchar_t"
expr_stmt|;
comment|/* Install __LINE__, etc.  Must follow initialize_char_syntax      and option processing.  */
name|initialize_builtins
argument_list|(
name|fp
argument_list|,
operator|&
name|outbuf
argument_list|)
expr_stmt|;
comment|/* Do standard #defines and assertions      that identify system and machine type.  */
if|if
condition|(
operator|!
name|inhibit_predefs
condition|)
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|predefs
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|predefs
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Handle -D options.  */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'D'
condition|)
block|{
name|q
operator|=
operator|&
name|p
index|[
literal|2
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug_output
condition|)
name|output_line_command
argument_list|(
name|fp
argument_list|,
operator|&
name|outbuf
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|make_definition
argument_list|(
name|q
argument_list|,
operator|&
name|outbuf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'A'
condition|)
block|{
comment|/* Handle -A options (assertions).  */
name|char
modifier|*
name|assertion
decl_stmt|;
name|char
modifier|*
name|past_name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|char
modifier|*
name|past_value
decl_stmt|;
name|char
modifier|*
name|termination
decl_stmt|;
name|int
name|save_char
decl_stmt|;
name|assertion
operator|=
operator|&
name|p
index|[
literal|2
index|]
expr_stmt|;
name|past_name
operator|=
name|assertion
expr_stmt|;
comment|/* Locate end of name.  */
while|while
condition|(
operator|*
name|past_name
operator|&&
operator|*
name|past_name
operator|!=
literal|' '
operator|&&
operator|*
name|past_name
operator|!=
literal|'\t'
operator|&&
operator|*
name|past_name
operator|!=
literal|'('
condition|)
name|past_name
operator|++
expr_stmt|;
comment|/* Locate `(' at start of value.  */
name|value
operator|=
name|past_name
expr_stmt|;
while|while
condition|(
operator|*
name|value
operator|&&
operator|(
operator|*
name|value
operator|==
literal|' '
operator|||
operator|*
name|value
operator|==
literal|'\t'
operator|)
condition|)
name|value
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|value
operator|++
operator|!=
literal|'('
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
operator|*
name|value
operator|&&
operator|(
operator|*
name|value
operator|==
literal|' '
operator|||
operator|*
name|value
operator|==
literal|'\t'
operator|)
condition|)
name|value
operator|++
expr_stmt|;
name|past_value
operator|=
name|value
expr_stmt|;
comment|/* Locate end of value.  */
while|while
condition|(
operator|*
name|past_value
operator|&&
operator|*
name|past_value
operator|!=
literal|' '
operator|&&
operator|*
name|past_value
operator|!=
literal|'\t'
operator|&&
operator|*
name|past_value
operator|!=
literal|')'
condition|)
name|past_value
operator|++
expr_stmt|;
name|termination
operator|=
name|past_value
expr_stmt|;
while|while
condition|(
operator|*
name|termination
operator|&&
operator|(
operator|*
name|termination
operator|==
literal|' '
operator|||
operator|*
name|termination
operator|==
literal|'\t'
operator|)
condition|)
name|termination
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|termination
operator|++
operator|!=
literal|')'
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|termination
operator|&&
operator|*
name|termination
operator|!=
literal|' '
operator|&&
operator|*
name|termination
operator|!=
literal|'\t'
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Temporarily null-terminate the value.  */
name|save_char
operator|=
operator|*
name|termination
expr_stmt|;
operator|*
name|termination
operator|=
literal|'\0'
expr_stmt|;
comment|/* Install the assertion.  */
name|make_assertion
argument_list|(
literal|"-A"
argument_list|,
name|assertion
argument_list|)
expr_stmt|;
operator|*
name|termination
operator|=
operator|(
name|char
operator|)
name|save_char
expr_stmt|;
name|p
operator|=
name|termination
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
block|}
else|else
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|/* Now handle the command line options.  */
comment|/* Do -U's, -D's and -A's in the order they were seen.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pend_undefs
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|debug_output
condition|)
name|output_line_command
argument_list|(
name|fp
argument_list|,
operator|&
name|outbuf
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|make_undef
argument_list|(
name|pend_undefs
index|[
name|i
index|]
argument_list|,
operator|&
name|outbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pend_defs
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|debug_output
condition|)
name|output_line_command
argument_list|(
name|fp
argument_list|,
operator|&
name|outbuf
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|make_definition
argument_list|(
name|pend_defs
index|[
name|i
index|]
argument_list|,
operator|&
name|outbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pend_assertions
index|[
name|i
index|]
condition|)
name|make_assertion
argument_list|(
name|pend_assertion_options
index|[
name|i
index|]
argument_list|,
name|pend_assertions
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|done_initializing
operator|=
literal|1
expr_stmt|;
block|{
comment|/* read the appropriate environment variable and if it exists        replace include_defaults with the listed path. */
name|char
modifier|*
name|epath
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
operator|(
name|objc
operator|<<
literal|1
operator|)
operator|+
name|cplusplus
condition|)
block|{
case|case
literal|0
case|:
name|epath
operator|=
name|getenv
argument_list|(
literal|"C_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|epath
operator|=
name|getenv
argument_list|(
literal|"CPLUS_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|epath
operator|=
name|getenv
argument_list|(
literal|"OBJC_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|epath
operator|=
name|getenv
argument_list|(
literal|"OBJCPLUS_INCLUDE_PATH"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If the environment var for this language is set,        add to the default list of include directories.  */
if|if
condition|(
name|epath
condition|)
block|{
name|char
modifier|*
name|nstore
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|epath
argument_list|)
operator|+
literal|2
argument_list|)
decl_stmt|;
name|int
name|num_dirs
decl_stmt|;
name|char
modifier|*
name|startp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
for|for
control|(
name|num_dirs
operator|=
literal|1
operator|,
name|startp
operator|=
name|epath
init|;
operator|*
name|startp
condition|;
name|startp
operator|++
control|)
if|if
condition|(
operator|*
name|startp
operator|==
name|PATH_SEPARATOR
condition|)
name|num_dirs
operator|++
expr_stmt|;
name|include_defaults
operator|=
operator|(
expr|struct
name|default_include
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|num_dirs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|default_include
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|include_defaults_array
argument_list|)
argument_list|)
expr_stmt|;
name|startp
operator|=
name|endp
operator|=
name|epath
expr_stmt|;
name|num_dirs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Handle cases like c:/usr/lib:d:/gcc/lib */
if|if
condition|(
operator|(
operator|*
name|endp
operator|==
name|PATH_SEPARATOR
if|#
directive|if
literal|0
comment|/* Obsolete, now that we use semicolons as the path separator.  */
ifdef|#
directive|ifdef
name|__MSDOS__
expr|&& (endp-startp != 1 || !isalpha (*startp))
endif|#
directive|endif
endif|#
directive|endif
operator|)
operator|||
operator|*
name|endp
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|nstore
argument_list|,
name|startp
argument_list|,
name|endp
operator|-
name|startp
argument_list|)
expr_stmt|;
if|if
condition|(
name|endp
operator|==
name|startp
condition|)
name|strcpy
argument_list|(
name|nstore
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
else|else
name|nstore
index|[
name|endp
operator|-
name|startp
index|]
operator|=
literal|'\0'
expr_stmt|;
name|include_defaults
index|[
name|num_dirs
index|]
operator|.
name|fname
operator|=
name|savestring
argument_list|(
name|nstore
argument_list|)
expr_stmt|;
name|include_defaults
index|[
name|num_dirs
index|]
operator|.
name|cplusplus
operator|=
name|cplusplus
expr_stmt|;
name|include_defaults
index|[
name|num_dirs
index|]
operator|.
name|cxx_aware
operator|=
literal|1
expr_stmt|;
name|num_dirs
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|==
literal|'\0'
condition|)
break|break;
name|endp
operator|=
name|startp
operator|=
name|endp
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|endp
operator|++
expr_stmt|;
block|}
comment|/* Put the usual defaults back in at the end.  */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|include_defaults_array
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|include_defaults
index|[
name|num_dirs
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|include_defaults_array
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|append_include_chain
argument_list|(
name|before_system
argument_list|,
name|last_before_system
argument_list|)
expr_stmt|;
name|first_system_include
operator|=
name|before_system
expr_stmt|;
comment|/* Unless -fnostdinc,      tack on the standard include file dirs to the specified list */
if|if
condition|(
operator|!
name|no_standard_includes
condition|)
block|{
name|struct
name|default_include
modifier|*
name|p
init|=
name|include_defaults
decl_stmt|;
name|char
modifier|*
name|specd_prefix
init|=
name|include_prefix
decl_stmt|;
name|char
modifier|*
name|default_prefix
init|=
name|savestring
argument_list|(
name|GCC_INCLUDE_DIR
argument_list|)
decl_stmt|;
name|int
name|default_len
init|=
literal|0
decl_stmt|;
comment|/* Remove the `include' from /usr/local/lib/gcc.../include.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|default_prefix
operator|+
name|strlen
argument_list|(
name|default_prefix
argument_list|)
operator|-
literal|8
argument_list|,
literal|"/include"
argument_list|)
condition|)
block|{
name|default_len
operator|=
name|strlen
argument_list|(
name|default_prefix
argument_list|)
operator|-
literal|7
expr_stmt|;
name|default_prefix
index|[
name|default_len
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Search "translated" versions of GNU directories.        These have /usr/local/lib/gcc... replaced by specd_prefix.  */
if|if
condition|(
name|specd_prefix
operator|!=
literal|0
operator|&&
name|default_len
operator|!=
literal|0
condition|)
for|for
control|(
name|p
operator|=
name|include_defaults
init|;
name|p
operator|->
name|fname
condition|;
name|p
operator|++
control|)
block|{
comment|/* Some standard dirs are only for C++.  */
if|if
condition|(
operator|!
name|p
operator|->
name|cplusplus
operator|||
operator|(
name|cplusplus
operator|&&
operator|!
name|no_standard_cplusplus_includes
operator|)
condition|)
block|{
comment|/* Does this dir start with the prefix?  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
operator|->
name|fname
argument_list|,
name|default_prefix
argument_list|,
name|default_len
argument_list|)
condition|)
block|{
comment|/* Yes; change prefix and add to search list.  */
name|struct
name|file_name_list
modifier|*
name|new
init|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|this_len
init|=
name|strlen
argument_list|(
name|specd_prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|p
operator|->
name|fname
argument_list|)
operator|-
name|default_len
decl_stmt|;
name|char
modifier|*
name|str
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|this_len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|str
argument_list|,
name|specd_prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|str
argument_list|,
name|p
operator|->
name|fname
operator|+
name|default_len
argument_list|)
expr_stmt|;
name|new
operator|->
name|fname
operator|=
name|str
expr_stmt|;
name|new
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|c_system_include_path
operator|=
operator|!
name|p
operator|->
name|cxx_aware
expr_stmt|;
name|new
operator|->
name|got_name_map
operator|=
literal|0
expr_stmt|;
name|append_include_chain
argument_list|(
name|new
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_system_include
operator|==
literal|0
condition|)
name|first_system_include
operator|=
name|new
expr_stmt|;
block|}
block|}
block|}
comment|/* Search ordinary names for GNU include directories.  */
for|for
control|(
name|p
operator|=
name|include_defaults
init|;
name|p
operator|->
name|fname
condition|;
name|p
operator|++
control|)
block|{
comment|/* Some standard dirs are only for C++.  */
if|if
condition|(
operator|!
name|p
operator|->
name|cplusplus
operator|||
operator|(
name|cplusplus
operator|&&
operator|!
name|no_standard_cplusplus_includes
operator|)
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|new
init|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|c_system_include_path
operator|=
operator|!
name|p
operator|->
name|cxx_aware
expr_stmt|;
name|new
operator|->
name|fname
operator|=
name|p
operator|->
name|fname
expr_stmt|;
name|new
operator|->
name|got_name_map
operator|=
literal|0
expr_stmt|;
name|append_include_chain
argument_list|(
name|new
argument_list|,
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_system_include
operator|==
literal|0
condition|)
name|first_system_include
operator|=
name|new
expr_stmt|;
block|}
block|}
block|}
comment|/* Tack the after_include chain at the end of the include chain.  */
name|append_include_chain
argument_list|(
name|after_include
argument_list|,
name|last_after_include
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_system_include
operator|==
literal|0
condition|)
name|first_system_include
operator|=
name|after_include
expr_stmt|;
comment|/* With -v, print the list of dirs to search.  */
if|if
condition|(
name|verbose
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|p
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"#include \"...\" search starts here:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|include
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|==
name|first_bracket_include
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"#include<...> search starts here:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s\n"
argument_list|,
name|p
operator|->
name|fname
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"End of search list.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Scan the -imacros files before the main input.      Much like #including them, but with no_output set      so that only their macro definitions matter.  */
name|no_output
operator|++
expr_stmt|;
name|no_record_file
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pend_files
index|[
name|i
index|]
condition|)
block|{
name|int
name|fd
init|=
name|open
argument_list|(
name|pend_files
index|[
name|i
index|]
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|pend_files
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|FAILURE_EXIT_CODE
return|;
block|}
name|finclude
argument_list|(
name|fd
argument_list|,
name|pend_files
index|[
name|i
index|]
argument_list|,
operator|&
name|outbuf
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
name|no_output
operator|--
expr_stmt|;
name|no_record_file
operator|--
expr_stmt|;
comment|/* Copy the entire contents of the main input file into      the stacked input buffer previously allocated for it.  */
comment|/* JF check for stdin */
if|if
condition|(
name|in_fname
operator|==
name|NULL
operator|||
operator|*
name|in_fname
operator|==
literal|0
condition|)
block|{
name|in_fname
operator|=
literal|""
expr_stmt|;
name|f
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|in_fname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|perror
goto|;
comment|/* -MG doesn't select the form of output and must be specified with one of      -M or -MM.  -MG doesn't make sense with -MD or -MMD since they don't      inhibit compilation.  */
if|if
condition|(
name|print_deps_missing_files
operator|&&
operator|(
name|print_deps
operator|==
literal|0
operator|||
operator|!
name|inhibit_output
operator|)
condition|)
name|fatal
argument_list|(
literal|"-MG must be specified with one of -M or -MM"
argument_list|)
expr_stmt|;
comment|/* Either of two environment variables can specify output of deps.      Its value is either "OUTPUT_FILE" or "OUTPUT_FILE DEPS_TARGET",      where OUTPUT_FILE is the file to write deps info to      and DEPS_TARGET is the target to mention in the deps.  */
if|if
condition|(
name|print_deps
operator|==
literal|0
operator|&&
operator|(
name|getenv
argument_list|(
literal|"SUNPRO_DEPENDENCIES"
argument_list|)
operator|!=
literal|0
operator|||
name|getenv
argument_list|(
literal|"DEPENDENCIES_OUTPUT"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|char
modifier|*
name|spec
init|=
name|getenv
argument_list|(
literal|"DEPENDENCIES_OUTPUT"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|output_file
decl_stmt|;
if|if
condition|(
name|spec
operator|==
literal|0
condition|)
block|{
name|spec
operator|=
name|getenv
argument_list|(
literal|"SUNPRO_DEPENDENCIES"
argument_list|)
expr_stmt|;
name|print_deps
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|print_deps
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|spec
expr_stmt|;
comment|/* Find the space before the DEPS_TARGET, if there is one.  */
comment|/* This should use index.  (mrs) */
while|while
condition|(
operator|*
name|s
operator|!=
literal|0
operator|&&
operator|*
name|s
operator|!=
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|0
condition|)
block|{
name|deps_target
operator|=
name|s
operator|+
literal|1
expr_stmt|;
name|output_file
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|s
operator|-
name|spec
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|spec
argument_list|,
name|output_file
argument_list|,
name|s
operator|-
name|spec
argument_list|)
expr_stmt|;
name|output_file
index|[
name|s
operator|-
name|spec
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|deps_target
operator|=
literal|0
expr_stmt|;
name|output_file
operator|=
name|spec
expr_stmt|;
block|}
name|deps_file
operator|=
name|output_file
expr_stmt|;
name|deps_mode
operator|=
literal|"a"
expr_stmt|;
block|}
comment|/* For -M, print the expected object file name      as the target of this Make-rule.  */
if|if
condition|(
name|print_deps
condition|)
block|{
name|deps_allocated_size
operator|=
literal|200
expr_stmt|;
name|deps_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|deps_allocated_size
argument_list|)
expr_stmt|;
name|deps_buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|deps_size
operator|=
literal|0
expr_stmt|;
name|deps_column
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|deps_target
condition|)
block|{
name|deps_output
argument_list|(
name|deps_target
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|in_fname
operator|==
literal|0
condition|)
block|{
name|deps_output
argument_list|(
literal|"-"
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Discard all directory prefixes from filename.  */
if|if
condition|(
operator|(
name|q
operator|=
name|rindex
argument_list|(
name|in_fname
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
ifdef|#
directive|ifdef
name|DIR_SEPARATOR
operator|&&
operator|(
name|q
operator|=
name|rindex
argument_list|(
name|in_fname
argument_list|,
name|DIR_SEPARATOR
argument_list|)
operator|)
operator|!=
name|NULL
endif|#
directive|endif
condition|)
operator|++
name|q
expr_stmt|;
else|else
name|q
operator|=
name|in_fname
expr_stmt|;
comment|/* Copy remainder to mungable area.  */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|q
argument_list|)
operator|+
literal|8
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* Output P, but remove known suffixes.  */
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|>=
literal|2
operator|&&
name|p
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'.'
operator|&&
name|index
argument_list|(
literal|"cCsSm"
argument_list|,
name|p
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|q
operator|=
name|p
operator|+
operator|(
name|len
operator|-
literal|2
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>=
literal|3
operator|&&
name|p
index|[
name|len
operator|-
literal|3
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'c'
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'c'
condition|)
name|q
operator|=
name|p
operator|+
operator|(
name|len
operator|-
literal|3
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>=
literal|4
operator|&&
name|p
index|[
name|len
operator|-
literal|4
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
name|len
operator|-
literal|3
index|]
operator|==
literal|'c'
operator|&&
name|p
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'x'
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'x'
condition|)
name|q
operator|=
name|p
operator|+
operator|(
name|len
operator|-
literal|4
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|>=
literal|4
operator|&&
name|p
index|[
name|len
operator|-
literal|4
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
name|len
operator|-
literal|3
index|]
operator|==
literal|'c'
operator|&&
name|p
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'p'
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'p'
condition|)
name|q
operator|=
name|p
operator|+
operator|(
name|len
operator|-
literal|4
operator|)
expr_stmt|;
comment|/* Supply our own suffix.  */
ifndef|#
directive|ifndef
name|VMS
name|strcpy
argument_list|(
name|q
argument_list|,
literal|".o"
argument_list|)
expr_stmt|;
else|#
directive|else
name|strcpy
argument_list|(
name|q
argument_list|,
literal|".obj"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|deps_output
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|deps_output
argument_list|(
name|in_fname
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
name|file_size_and_mode
argument_list|(
name|f
argument_list|,
operator|&
name|st_mode
argument_list|,
operator|&
name|st_size
argument_list|)
expr_stmt|;
name|fp
operator|->
name|nominal_fname
operator|=
name|fp
operator|->
name|fname
operator|=
name|in_fname
expr_stmt|;
name|fp
operator|->
name|lineno
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|system_header_p
operator|=
literal|0
expr_stmt|;
comment|/* JF all this is mine about reading pipes and ttys */
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|st_mode
argument_list|)
condition|)
block|{
comment|/* Read input from a file that is not a normal disk file.        We cannot preallocate a buffer with the correct size,        so we must read in the file a piece at the time and make it bigger.  */
name|int
name|size
decl_stmt|;
name|int
name|bsize
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|bsize
operator|=
literal|2000
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|bsize
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cnt
operator|=
name|safe_read
argument_list|(
name|f
argument_list|,
name|fp
operator|->
name|buf
operator|+
name|size
argument_list|,
name|bsize
operator|-
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
goto|goto
name|perror
goto|;
comment|/* error! */
name|size
operator|+=
name|cnt
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|bsize
condition|)
break|break;
comment|/* End of file */
name|bsize
operator|*=
literal|2
expr_stmt|;
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|fp
operator|->
name|buf
argument_list|,
name|bsize
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|fp
operator|->
name|length
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
comment|/* Read a file whose size we can determine in advance.        For the sake of VMS, st_size is just an upper bound.  */
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|st_size
operator|+
literal|2
argument_list|)
expr_stmt|;
name|fp
operator|->
name|length
operator|=
name|safe_read
argument_list|(
name|f
argument_list|,
name|fp
operator|->
name|buf
argument_list|,
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|length
operator|<
literal|0
condition|)
goto|goto
name|perror
goto|;
block|}
name|fp
operator|->
name|bufp
operator|=
name|fp
operator|->
name|buf
expr_stmt|;
name|fp
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
comment|/* Make sure data ends with a newline.  And put a null after it.  */
if|if
condition|(
operator|(
name|fp
operator|->
name|length
operator|>
literal|0
operator|&&
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
operator|-
literal|1
index|]
operator|!=
literal|'\n'
operator|)
comment|/* Backslash-newline at end is not good enough.  */
operator|||
operator|(
name|fp
operator|->
name|length
operator|>
literal|1
operator|&&
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
operator|-
literal|2
index|]
operator|==
literal|'\\'
operator|)
condition|)
block|{
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|missing_newline
operator|=
literal|1
expr_stmt|;
block|}
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Unless inhibited, convert trigraphs in the input.  */
if|if
condition|(
operator|!
name|no_trigraphs
condition|)
name|trigraph_pcp
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Now that we know the input file is valid, open the output.  */
if|if
condition|(
operator|!
name|out_fname
operator|||
operator|!
name|strcmp
argument_list|(
name|out_fname
argument_list|,
literal|""
argument_list|)
condition|)
name|out_fname
operator|=
literal|"stdout"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|freopen
argument_list|(
name|out_fname
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
condition|)
name|pfatal_with_name
argument_list|(
name|out_fname
argument_list|)
expr_stmt|;
name|output_line_command
argument_list|(
name|fp
argument_list|,
operator|&
name|outbuf
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
comment|/* Scan the -include files before the main input.  */
name|no_record_file
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pend_includes
index|[
name|i
index|]
condition|)
block|{
name|int
name|fd
init|=
name|open
argument_list|(
name|pend_includes
index|[
name|i
index|]
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|pend_includes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|FAILURE_EXIT_CODE
return|;
block|}
name|finclude
argument_list|(
name|fd
argument_list|,
name|pend_includes
index|[
name|i
index|]
argument_list|,
operator|&
name|outbuf
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
block|}
name|no_record_file
operator|--
expr_stmt|;
comment|/* Scan the input, processing macros and directives.  */
name|rescan
argument_list|(
operator|&
name|outbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|missing_newline
condition|)
name|fp
operator|->
name|lineno
operator|--
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|missing_newline
condition|)
name|pedwarn
argument_list|(
literal|"file does not end in newline"
argument_list|)
expr_stmt|;
comment|/* Now we have processed the entire input      Write whichever kind of output has been requested.  */
if|if
condition|(
name|dump_macros
operator|==
name|dump_only
condition|)
name|dump_all_macros
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|inhibit_output
condition|)
block|{
name|write_output
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|print_deps
condition|)
block|{
comment|/* Don't actually write the deps file if compilation has failed.  */
if|if
condition|(
name|errors
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|deps_file
operator|&&
operator|!
operator|(
name|deps_stream
operator|=
name|fopen
argument_list|(
name|deps_file
argument_list|,
name|deps_mode
argument_list|)
operator|)
condition|)
name|pfatal_with_name
argument_list|(
name|deps_file
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|deps_buffer
argument_list|,
name|deps_stream
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|deps_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|deps_file
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|deps_stream
argument_list|)
operator|||
name|fclose
argument_list|(
name|deps_stream
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"I/O error on output"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|pcp_outfile
operator|&&
name|pcp_outfile
operator|!=
name|stdout
operator|&&
operator|(
name|ferror
argument_list|(
name|pcp_outfile
argument_list|)
operator|||
name|fclose
argument_list|(
name|pcp_outfile
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|fatal
argument_list|(
literal|"I/O error on `-pcp' output"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|fclose
argument_list|(
name|stdout
argument_list|)
operator|!=
literal|0
condition|)
name|fatal
argument_list|(
literal|"I/O error on output"
argument_list|)
expr_stmt|;
if|if
condition|(
name|errors
condition|)
name|exit
argument_list|(
name|FAILURE_EXIT_CODE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
name|perror
label|:
name|pfatal_with_name
argument_list|(
name|in_fname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a colon-separated list of file names PATH,    add all the names to the search path for include files.  */
end_comment

begin_function
specifier|static
name|void
name|path_include
parameter_list|(
name|path
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|path
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|q
init|=
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
comment|/* Find the end of this name.  */
while|while
condition|(
operator|*
name|q
operator|!=
literal|0
operator|&&
operator|*
name|q
operator|!=
name|PATH_SEPARATOR
condition|)
name|q
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|q
condition|)
block|{
comment|/* An empty name in the path stands for the current directory.  */
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise use the directory that is named.  */
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|q
operator|-
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|p
argument_list|,
name|name
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
name|name
index|[
name|q
operator|-
name|p
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|dirtmp
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* New one goes on the end */
name|dirtmp
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|dirtmp
operator|->
name|c_system_include_path
operator|=
literal|0
expr_stmt|;
name|dirtmp
operator|->
name|fname
operator|=
name|name
expr_stmt|;
name|dirtmp
operator|->
name|got_name_map
operator|=
literal|0
expr_stmt|;
name|append_include_chain
argument_list|(
name|dirtmp
argument_list|,
name|dirtmp
argument_list|)
expr_stmt|;
comment|/* Advance past this name.  */
name|p
operator|=
name|q
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
break|break;
comment|/* Skip the colon.  */
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the address of the first character in S that equals C.    S is an array of length N, possibly containing '\0's, and followed by '\0'.    Return 0 if there is no such character.  Assume that C itself is not '\0'.    If we knew we could use memchr, we could just invoke memchr (S, C, N),    but unfortunately memchr isn't autoconfigured yet.  */
end_comment

begin_function
specifier|static
name|U_CHAR
modifier|*
name|index0
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|,
name|n
parameter_list|)
name|U_CHAR
modifier|*
name|s
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|q
init|=
name|index
argument_list|(
name|s
argument_list|,
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
condition|)
return|return
operator|(
name|U_CHAR
operator|*
operator|)
name|q
return|;
else|else
block|{
name|int
name|l
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|==
name|n
condition|)
return|return
literal|0
return|;
name|l
operator|++
expr_stmt|;
name|s
operator|+=
name|l
expr_stmt|;
name|n
operator|-=
name|l
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pre-C-Preprocessor to translate ANSI trigraph idiocy in BUF    before main CCCP processing.  Name `pcp' is also in honor of the    drugs the trigraph designers must have been on.     Using an extra pass through the buffer takes a little extra time,    but is infinitely less hairy than trying to handle trigraphs inside    strings, etc. everywhere, and also makes sure that trigraphs are    only translated in the top level of processing. */
end_comment

begin_function
specifier|static
name|void
name|trigraph_pcp
parameter_list|(
name|buf
parameter_list|)
name|FILE_BUF
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|U_CHAR
name|c
decl_stmt|,
modifier|*
name|fptr
decl_stmt|,
modifier|*
name|bptr
decl_stmt|,
modifier|*
name|sptr
decl_stmt|,
modifier|*
name|lptr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|fptr
operator|=
name|bptr
operator|=
name|sptr
operator|=
name|buf
operator|->
name|buf
expr_stmt|;
name|lptr
operator|=
name|fptr
operator|+
name|buf
operator|->
name|length
expr_stmt|;
while|while
condition|(
operator|(
name|sptr
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|index0
argument_list|(
name|sptr
argument_list|,
literal|'?'
argument_list|,
name|lptr
operator|-
name|sptr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|sptr
operator|!=
literal|'?'
condition|)
continue|continue;
switch|switch
condition|(
operator|*
operator|++
name|sptr
condition|)
block|{
case|case
literal|'='
case|:
name|c
operator|=
literal|'#'
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|c
operator|=
literal|'['
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|c
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|c
operator|=
literal|']'
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|c
operator|=
literal|'^'
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|c
operator|=
literal|'{'
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|c
operator|=
literal|'|'
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|c
operator|=
literal|'}'
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|c
operator|=
literal|'~'
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|sptr
operator|--
expr_stmt|;
continue|continue;
default|default:
continue|continue;
block|}
name|len
operator|=
name|sptr
operator|-
name|fptr
operator|-
literal|2
expr_stmt|;
comment|/* BSD doc says bcopy () works right for overlapping strings.  In ANSI        C, this will be memmove (). */
if|if
condition|(
name|bptr
operator|!=
name|fptr
operator|&&
name|len
operator|>
literal|0
condition|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fptr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bptr
operator|+=
name|len
expr_stmt|;
operator|*
name|bptr
operator|++
operator|=
name|c
expr_stmt|;
name|fptr
operator|=
operator|++
name|sptr
expr_stmt|;
block|}
name|len
operator|=
name|buf
operator|->
name|length
operator|-
operator|(
name|fptr
operator|-
name|buf
operator|->
name|buf
operator|)
expr_stmt|;
if|if
condition|(
name|bptr
operator|!=
name|fptr
operator|&&
name|len
operator|>
literal|0
condition|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fptr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
operator|->
name|length
operator|-=
name|fptr
operator|-
name|bptr
expr_stmt|;
name|buf
operator|->
name|buf
index|[
name|buf
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|warn_trigraphs
operator|&&
name|fptr
operator|!=
name|bptr
condition|)
name|warning
argument_list|(
literal|"%d trigraph(s) encountered"
argument_list|,
operator|(
name|fptr
operator|-
name|bptr
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Move all backslash-newline pairs out of embarrassing places.    Exchange all such pairs following BP    with any potentially-embarrassing characters that follow them.    Potentially-embarrassing characters are / and *    (because a backslash-newline inside a comment delimiter    would cause it not to be recognized).  */
end_comment

begin_function
specifier|static
name|void
name|newline_fix
parameter_list|(
name|bp
parameter_list|)
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|p
init|=
name|bp
decl_stmt|;
comment|/* First count the backslash-newline pairs here.  */
while|while
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* What follows the backslash-newlines is not embarrassing.  */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'/'
operator|&&
operator|*
name|p
operator|!=
literal|'*'
condition|)
return|return;
comment|/* Copy all potentially embarrassing characters      that follow the backslash-newline pairs      down to where the pairs originally started.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|'*'
operator|||
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* Now write the same number of pairs after the embarrassing chars.  */
while|while
condition|(
name|bp
operator|<
name|p
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Like newline_fix but for use within a directive-name.    Move any backslash-newlines up past any following symbol constituents.  */
end_comment

begin_function
specifier|static
name|void
name|name_newline_fix
parameter_list|(
name|bp
parameter_list|)
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|p
init|=
name|bp
decl_stmt|;
comment|/* First count the backslash-newline pairs here.  */
while|while
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* What follows the backslash-newlines is not embarrassing.  */
if|if
condition|(
operator|!
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
return|return;
comment|/* Copy all potentially embarrassing characters      that follow the backslash-newline pairs      down to where the pairs originally started.  */
while|while
condition|(
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* Now write the same number of pairs after the embarrassing chars.  */
while|while
condition|(
name|bp
operator|<
name|p
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Look for lint commands in comments.     When we come in here, ibp points into a comment.  Limit is as one expects.    scan within the comment -- it should start, after lwsp, with a lint command.    If so that command is returned as a (constant) string.     Upon return, any arg will be pointed to with argstart and will be    arglen long.  Note that we don't parse that arg since it will just    be printed out again. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_lintcmd
parameter_list|(
name|ibp
parameter_list|,
name|limit
parameter_list|,
name|argstart
parameter_list|,
name|arglen
parameter_list|,
name|cmdlen
parameter_list|)
specifier|register
name|U_CHAR
modifier|*
name|ibp
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
name|U_CHAR
modifier|*
modifier|*
name|argstart
decl_stmt|;
comment|/* point to command arg */
name|int
modifier|*
name|arglen
decl_stmt|,
decl|*
name|cmdlen
decl_stmt|;
end_function

begin_comment
comment|/* how long they are */
end_comment

begin_block
block|{
name|long
name|linsize
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|numptr
decl_stmt|;
comment|/* temp for arg parsing */
operator|*
name|arglen
operator|=
literal|0
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibp
operator|>=
name|limit
condition|)
return|return
name|NULL
return|;
name|linsize
operator|=
name|limit
operator|-
name|ibp
expr_stmt|;
comment|/* Oh, I wish C had lexical functions... hell, I'll just open-code the set */
if|if
condition|(
operator|(
name|linsize
operator|>=
literal|10
operator|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|ibp
argument_list|,
literal|"NOTREACHED"
argument_list|,
literal|10
argument_list|)
condition|)
block|{
operator|*
name|cmdlen
operator|=
literal|10
expr_stmt|;
return|return
literal|"NOTREACHED"
return|;
block|}
if|if
condition|(
operator|(
name|linsize
operator|>=
literal|8
operator|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|ibp
argument_list|,
literal|"ARGSUSED"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
operator|*
name|cmdlen
operator|=
literal|8
expr_stmt|;
return|return
literal|"ARGSUSED"
return|;
block|}
if|if
condition|(
operator|(
name|linsize
operator|>=
literal|11
operator|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|ibp
argument_list|,
literal|"LINTLIBRARY"
argument_list|,
literal|11
argument_list|)
condition|)
block|{
operator|*
name|cmdlen
operator|=
literal|11
expr_stmt|;
return|return
literal|"LINTLIBRARY"
return|;
block|}
if|if
condition|(
operator|(
name|linsize
operator|>=
literal|7
operator|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|ibp
argument_list|,
literal|"VARARGS"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
operator|*
name|cmdlen
operator|=
literal|7
expr_stmt|;
name|ibp
operator|+=
literal|7
expr_stmt|;
name|linsize
operator|-=
literal|7
expr_stmt|;
if|if
condition|(
operator|(
name|linsize
operator|==
literal|0
operator|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|*
name|ibp
argument_list|)
condition|)
return|return
literal|"VARARGS"
return|;
comment|/* OK, read a number */
for|for
control|(
name|numptr
operator|=
operator|*
name|argstart
operator|=
name|ibp
init|;
operator|(
name|numptr
operator|<
name|limit
operator|)
operator|&&
name|isdigit
argument_list|(
operator|*
name|numptr
argument_list|)
condition|;
name|numptr
operator|++
control|)
empty_stmt|;
operator|*
name|arglen
operator|=
name|numptr
operator|-
operator|*
name|argstart
expr_stmt|;
return|return
literal|"VARARGS"
return|;
block|}
return|return
name|NULL
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * The main loop of the program.  *  * Read characters from the input stack, transferring them to the  * output buffer OP.  *  * Macros are expanded and push levels on the input stack.  * At the end of such a level it is popped off and we keep reading.  * At the end of any other kind of level, we return.  * #-directives are handled, except within macros.  *  * If OUTPUT_MARKS is nonzero, keep Newline markers found in the input  * and insert them when appropriate.  This is set while scanning macro  * arguments before substitution.  It is zero when scanning for final output.  *   There are three types of Newline markers:  *   * Newline -  follows a macro name that was not expanded  *     because it appeared inside an expansion of the same macro.  *     This marker prevents future expansion of that identifier.  *     When the input is rescanned into the final output, these are deleted.  *     These are also deleted by ## concatenation.  *   * Newline Space (or Newline and any other whitespace character)  *     stands for a place that tokens must be separated or whitespace  *     is otherwise desirable, but where the ANSI standard specifies there  *     is no whitespace.  This marker turns into a Space (or whichever other  *     whitespace char appears in the marker) in the final output,  *     but it turns into nothing in an argument that is stringified with #.  *     Such stringified arguments are the only place where the ANSI standard  *     specifies with precision that whitespace may not appear.  *  * During this function, IP->bufp is kept cached in IBP for speed of access.  * Likewise, OP->bufp is kept in OBP.  Before calling a subroutine  * IBP, IP and OBP must be copied back to memory.  IP and IBP are  * copied back with the RECACHE macro.  OBP must be copied back from OP->bufp  * explicitly, and before RECACHE, since RECACHE uses OBP.  */
end_comment

begin_function
specifier|static
name|void
name|rescan
parameter_list|(
name|op
parameter_list|,
name|output_marks
parameter_list|)
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
name|int
name|output_marks
decl_stmt|;
block|{
comment|/* Character being scanned in main loop.  */
specifier|register
name|U_CHAR
name|c
decl_stmt|;
comment|/* Length of pending accumulated identifier.  */
specifier|register
name|int
name|ident_length
init|=
literal|0
decl_stmt|;
comment|/* Hash code of pending accumulated identifier.  */
specifier|register
name|int
name|hash
init|=
literal|0
decl_stmt|;
comment|/* Current input level (&instack[indepth]).  */
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
comment|/* Pointer for scanning input.  */
specifier|register
name|U_CHAR
modifier|*
name|ibp
decl_stmt|;
comment|/* Pointer to end of input.  End of scan is controlled by LIMIT.  */
specifier|register
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
comment|/* Pointer for storing output.  */
specifier|register
name|U_CHAR
modifier|*
name|obp
decl_stmt|;
comment|/* REDO_CHAR is nonzero if we are processing an identifier      after backing up over the terminating character.      Sometimes we process an identifier without backing up over      the terminating character, if the terminating character      is not special.  Backing up is done so that the terminating character      will be dispatched on again once the identifier is dealt with.  */
name|int
name|redo_char
init|=
literal|0
decl_stmt|;
comment|/* 1 if within an identifier inside of which a concatenation      marker (Newline -) has been seen.  */
name|int
name|concatenated
init|=
literal|0
decl_stmt|;
comment|/* While scanning a comment or a string constant,      this records the line it started on, for error messages.  */
name|int
name|start_line
decl_stmt|;
comment|/* Record position of last `real' newline.  */
name|U_CHAR
modifier|*
name|beg_of_line
decl_stmt|;
comment|/* Pop the innermost input stack level, assuming it is a macro expansion.  */
define|#
directive|define
name|POPMACRO
define|\
value|do { ip->macro->type = T_MACRO;		\      if (ip->free_ptr) free (ip->free_ptr);	\      --indepth; } while (0)
comment|/* Reload `rescan's local variables that describe the current    level of the input stack.  */
define|#
directive|define
name|RECACHE
define|\
value|do { ip =&instack[indepth];		\      ibp = ip->bufp;			\      limit = ip->buf + ip->length;	\      op->bufp = obp;			\      check_expand (op, limit - ibp);	\      beg_of_line = 0;			\      obp = op->bufp; } while (0)
if|if
condition|(
name|no_output
operator|&&
name|instack
index|[
name|indepth
index|]
operator|.
name|fname
operator|!=
literal|0
condition|)
name|skip_if_group
argument_list|(
operator|&
name|instack
index|[
name|indepth
index|]
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|obp
operator|=
name|op
operator|->
name|bufp
expr_stmt|;
name|RECACHE
expr_stmt|;
name|beg_of_line
operator|=
name|ibp
expr_stmt|;
comment|/* Our caller must always put a null after the end of      the input at each input stack level.  */
if|if
condition|(
operator|*
name|limit
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
operator|&&
operator|!
name|ip
operator|->
name|macro
condition|)
block|{
comment|/* At the top level, always merge lines ending with backslash-newline, 	   even in middle of identifier.  But do not merge lines in a macro, 	   since backslash might be followed by a newline-space marker.  */
operator|++
name|ibp
expr_stmt|;
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
operator|--
name|obp
expr_stmt|;
comment|/* remove backslash from obuf */
break|break;
block|}
comment|/* If ANSI, backslash is just another character outside a string.  */
if|if
condition|(
operator|!
name|traditional
condition|)
goto|goto
name|randomchar
goto|;
comment|/* Otherwise, backslash suppresses specialness of following char, 	 so copy it here to prevent the switch from seeing it. 	 But first get any pending identifier processed.  */
if|if
condition|(
name|ident_length
operator|>
literal|0
condition|)
goto|goto
name|specialchar
goto|;
if|if
condition|(
name|ibp
operator|<
name|limit
condition|)
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
if|if
condition|(
name|assertions_flag
condition|)
block|{
comment|/* Copy #foo (bar lose) without macro expansion.  */
name|SKIP_WHITE_SPACE
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|ibp
index|]
condition|)
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'('
condition|)
block|{
name|ip
operator|->
name|bufp
operator|=
name|ibp
expr_stmt|;
name|skip_paren_group
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ibp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|obp
argument_list|,
name|ip
operator|->
name|bufp
operator|-
name|ibp
argument_list|)
expr_stmt|;
name|obp
operator|+=
name|ip
operator|->
name|bufp
operator|-
name|ibp
expr_stmt|;
name|ibp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
block|}
block|}
comment|/* If this is expanding a macro definition, don't recognize 	 preprocessor directives.  */
if|if
condition|(
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
goto|goto
name|randomchar
goto|;
comment|/* If this is expand_into_temp_buffer, recognize them 	 only after an actual newline at this level, 	 not at the beginning of the input level.  */
if|if
condition|(
name|ip
operator|->
name|fname
operator|==
literal|0
operator|&&
name|beg_of_line
operator|==
name|ip
operator|->
name|buf
condition|)
goto|goto
name|randomchar
goto|;
if|if
condition|(
name|ident_length
condition|)
goto|goto
name|specialchar
goto|;
comment|/* # keyword: a # must be first nonblank char on the line */
if|if
condition|(
name|beg_of_line
operator|==
literal|0
condition|)
goto|goto
name|randomchar
goto|;
block|{
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
comment|/* Scan from start of line, skipping whitespace, comments 	   and backslash-newlines, and see if we reach this #. 	   If not, this # is not special.  */
name|bp
operator|=
name|beg_of_line
expr_stmt|;
comment|/* If -traditional, require # to be at beginning of line.  */
if|if
condition|(
operator|!
name|traditional
condition|)
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|bp
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'/'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|bp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|!
operator|(
operator|*
name|bp
operator|==
literal|'*'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
name|bp
operator|++
expr_stmt|;
name|bp
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* There is no point in trying to deal with C++ // comments here, 	       because if there is one, then this # must be part of the 	       comment and we would never reach here.  */
else|else
break|break;
block|}
if|if
condition|(
name|bp
operator|+
literal|1
operator|!=
name|ibp
condition|)
goto|goto
name|randomchar
goto|;
block|}
comment|/* This # can start a directive.  */
operator|--
name|obp
expr_stmt|;
comment|/* Don't copy the '#' */
name|ip
operator|->
name|bufp
operator|=
name|ibp
expr_stmt|;
name|op
operator|->
name|bufp
operator|=
name|obp
expr_stmt|;
if|if
condition|(
operator|!
name|handle_directive
argument_list|(
name|ip
argument_list|,
name|op
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Not a known directive: treat it as ordinary text. 	   IP, OP, IBP, etc. have not been changed.  */
if|if
condition|(
name|no_output
operator|&&
name|instack
index|[
name|indepth
index|]
operator|.
name|fname
condition|)
block|{
comment|/* If not generating expanded output, 	     what we do with ordinary text is skip it. 	     Discard everything until next # directive.  */
name|skip_if_group
argument_list|(
operator|&
name|instack
index|[
name|indepth
index|]
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RECACHE
expr_stmt|;
name|beg_of_line
operator|=
name|ibp
expr_stmt|;
break|break;
block|}
operator|++
name|obp
expr_stmt|;
comment|/* Copy the '#' after all */
comment|/* Don't expand an identifier that could be a macro directive. 	   (Section 3.8.3 of the ANSI C standard)			*/
name|SKIP_WHITE_SPACE
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_idstart
index|[
operator|*
name|ibp
index|]
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|ibp
index|]
condition|)
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
block|}
goto|goto
name|randomchar
goto|;
block|}
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* A # directive has been successfully processed.  */
comment|/* If not generating expanded output, ignore everything until 	 next # directive.  */
if|if
condition|(
name|no_output
operator|&&
name|instack
index|[
name|indepth
index|]
operator|.
name|fname
condition|)
name|skip_if_group
argument_list|(
operator|&
name|instack
index|[
name|indepth
index|]
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obp
operator|=
name|op
operator|->
name|bufp
expr_stmt|;
name|RECACHE
expr_stmt|;
name|beg_of_line
operator|=
name|ibp
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
comment|/* skip quoted string */
case|case
literal|'\''
case|:
comment|/* A single quoted string is treated like a double -- some 	 programs (e.g., troff) are perverse this way */
if|if
condition|(
name|ident_length
condition|)
goto|goto
name|specialchar
goto|;
name|start_line
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
comment|/* Skip ahead to a matching quote.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|ibp
operator|>=
name|limit
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
block|{
comment|/* try harder: this string crosses a macro expansion boundary. 	       This can happen naturally if -traditional. 	       Otherwise, only -D can make a macro with an unmatched quote.  */
name|POPMACRO
expr_stmt|;
name|RECACHE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"unterminated string or character constant"
argument_list|)
expr_stmt|;
name|error_with_line
argument_list|(
name|multiline_string_line
argument_list|,
literal|"possible real start of unterminated constant"
argument_list|)
expr_stmt|;
name|multiline_string_line
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
expr_stmt|;
switch|switch
condition|(
operator|*
name|ibp
operator|++
condition|)
block|{
case|case
literal|'\n'
case|:
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
comment|/* Traditionally, end of line ends a string constant with no error. 	     So exit the loop and record the new line.  */
if|if
condition|(
name|traditional
condition|)
block|{
name|beg_of_line
operator|=
name|ibp
expr_stmt|;
goto|goto
name|while2end
goto|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
block|{
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"unterminated character constant"
argument_list|)
expr_stmt|;
goto|goto
name|while2end
goto|;
block|}
if|if
condition|(
name|pedantic
operator|&&
name|multiline_string_line
operator|==
literal|0
condition|)
block|{
name|pedwarn_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"string constant runs past end of line"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|multiline_string_line
operator|==
literal|0
condition|)
name|multiline_string_line
operator|=
name|ip
operator|->
name|lineno
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
name|ibp
operator|>=
name|limit
condition|)
break|break;
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
block|{
comment|/* Backslash newline is replaced by nothing at all, 	       but keep the line counts correct.  */
operator|--
name|obp
expr_stmt|;
operator|++
name|ibp
expr_stmt|;
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
block|}
else|else
block|{
comment|/* ANSI stupidly requires that in \\ the second \ 	       is *not* prevented from combining with a newline.  */
while|while
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|ibp
operator|+=
literal|2
expr_stmt|;
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
block|}
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\"'
case|:
case|case
literal|'\''
case|:
if|if
condition|(
name|ibp
index|[
operator|-
literal|1
index|]
operator|==
name|c
condition|)
goto|goto
name|while2end
goto|;
break|break;
block|}
block|}
name|while2end
label|:
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ibp
operator|!=
literal|'*'
operator|&&
operator|!
operator|(
name|cplusplus_comments
operator|&&
operator|*
name|ibp
operator|==
literal|'/'
operator|)
condition|)
goto|goto
name|randomchar
goto|;
if|if
condition|(
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
goto|goto
name|randomchar
goto|;
if|if
condition|(
name|ident_length
condition|)
goto|goto
name|specialchar
goto|;
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'/'
condition|)
block|{
comment|/* C++ style comment... */
name|start_line
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
operator|--
name|ibp
expr_stmt|;
comment|/* Back over the slash */
operator|--
name|obp
expr_stmt|;
comment|/* Comments are equivalent to spaces. */
if|if
condition|(
operator|!
name|put_out_comments
condition|)
operator|*
name|obp
operator|++
operator|=
literal|' '
expr_stmt|;
else|else
block|{
comment|/* must fake up a comment here */
operator|*
name|obp
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
block|{
name|U_CHAR
modifier|*
name|before_bp
init|=
name|ibp
operator|+
literal|2
decl_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|ibp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
operator|&&
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|put_out_comments
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|before_bp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|obp
argument_list|,
name|ibp
operator|-
name|before_bp
argument_list|)
expr_stmt|;
name|obp
operator|+=
name|ibp
operator|-
name|before_bp
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
comment|/* Copy the newline into the output buffer, in order to 		   avoid the pain of a #line every time a multiline comment 		   is seen.  */
if|if
condition|(
operator|!
name|put_out_comments
condition|)
operator|*
name|obp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
block|}
name|ibp
operator|++
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
comment|/* Ordinary C comment.  Skip it, optionally copying it to output.  */
name|start_line
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
operator|++
name|ibp
expr_stmt|;
comment|/* Skip the star. */
comment|/* If this cpp is for lint, we peek inside the comments: */
if|if
condition|(
name|for_lint
condition|)
block|{
name|U_CHAR
modifier|*
name|argbp
decl_stmt|;
name|int
name|cmdlen
decl_stmt|,
name|arglen
decl_stmt|;
name|char
modifier|*
name|lintcmd
init|=
name|get_lintcmd
argument_list|(
name|ibp
argument_list|,
name|limit
argument_list|,
operator|&
name|argbp
argument_list|,
operator|&
name|arglen
argument_list|,
operator|&
name|cmdlen
argument_list|)
decl_stmt|;
if|if
condition|(
name|lintcmd
operator|!=
name|NULL
condition|)
block|{
name|op
operator|->
name|bufp
operator|=
name|obp
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|cmdlen
operator|+
name|arglen
operator|+
literal|14
argument_list|)
expr_stmt|;
name|obp
operator|=
name|op
operator|->
name|bufp
expr_stmt|;
comment|/* I believe it is always safe to emit this newline: */
name|obp
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
name|bcopy
argument_list|(
literal|"#pragma lint "
argument_list|,
operator|(
name|char
operator|*
operator|)
name|obp
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|obp
operator|+=
literal|13
expr_stmt|;
name|bcopy
argument_list|(
name|lintcmd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|obp
argument_list|,
name|cmdlen
argument_list|)
expr_stmt|;
name|obp
operator|+=
name|cmdlen
expr_stmt|;
if|if
condition|(
name|arglen
operator|!=
literal|0
condition|)
block|{
operator|*
operator|(
name|obp
operator|++
operator|)
operator|=
literal|' '
expr_stmt|;
name|bcopy
argument_list|(
name|argbp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|obp
argument_list|,
name|arglen
argument_list|)
expr_stmt|;
name|obp
operator|+=
name|arglen
expr_stmt|;
block|}
comment|/* OK, now bring us back to the state we were in before we entered 	     this branch.  We need #line because the #pragma's newline always 	     messes up the line count.  */
name|op
operator|->
name|bufp
operator|=
name|obp
expr_stmt|;
name|output_line_command
argument_list|(
name|ip
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|limit
operator|-
name|ibp
operator|+
literal|2
argument_list|)
expr_stmt|;
name|obp
operator|=
name|op
operator|->
name|bufp
expr_stmt|;
operator|*
operator|(
name|obp
operator|++
operator|)
operator|=
literal|'/'
expr_stmt|;
block|}
block|}
comment|/* Comments are equivalent to spaces. 	 Note that we already output the slash; we might not want it. 	 For -traditional, a comment is equivalent to nothing.  */
if|if
condition|(
operator|!
name|put_out_comments
condition|)
block|{
if|if
condition|(
name|traditional
condition|)
name|obp
operator|--
expr_stmt|;
else|else
name|obp
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
block|}
else|else
operator|*
name|obp
operator|++
operator|=
literal|'*'
expr_stmt|;
block|{
name|U_CHAR
modifier|*
name|before_bp
init|=
name|ibp
decl_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
switch|switch
condition|(
operator|*
name|ibp
operator|++
condition|)
block|{
case|case
literal|'/'
case|:
if|if
condition|(
name|warn_comments
operator|&&
name|ibp
operator|<
name|limit
operator|&&
operator|*
name|ibp
operator|==
literal|'*'
condition|)
name|warning
argument_list|(
literal|"`/*' within comment"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibp
operator|>=
name|limit
operator|||
operator|*
name|ibp
operator|==
literal|'/'
condition|)
goto|goto
name|comment_end
goto|;
break|break;
case|case
literal|'\n'
case|:
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
comment|/* Copy the newline into the output buffer, in order to 	       avoid the pain of a #line every time a multiline comment 	       is seen.  */
if|if
condition|(
operator|!
name|put_out_comments
condition|)
operator|*
name|obp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
block|}
block|}
name|comment_end
label|:
if|if
condition|(
name|ibp
operator|>=
name|limit
condition|)
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"unterminated comment"
argument_list|)
expr_stmt|;
else|else
block|{
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
name|put_out_comments
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|before_bp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|obp
argument_list|,
name|ibp
operator|-
name|before_bp
argument_list|)
expr_stmt|;
name|obp
operator|+=
name|ibp
operator|-
name|before_bp
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|'$'
case|:
if|if
condition|(
operator|!
name|dollars_in_ident
condition|)
goto|goto
name|randomchar
goto|;
goto|goto
name|letter
goto|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* If digit is not part of identifier, it starts a number, 	 which means that following letters are not an identifier. 	 "0x5" does not refer to an identifier "x5". 	 So copy all alphanumerics that follow without accumulating 	 as an identifier.  Periods also, for sake of "3.e7".  */
if|if
condition|(
name|ident_length
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
while|while
condition|(
name|ibp
operator|<
name|limit
operator|&&
name|ibp
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
name|ibp
operator|+=
literal|2
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|is_idchar
index|[
name|c
index|]
operator|&&
name|c
operator|!=
literal|'.'
condition|)
block|{
operator|--
name|ibp
expr_stmt|;
break|break;
block|}
operator|*
name|obp
operator|++
operator|=
name|c
expr_stmt|;
comment|/* A sign can be part of a preprocessing number 	     if it follows an e.  */
if|if
condition|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
condition|)
block|{
while|while
condition|(
name|ibp
operator|<
name|limit
operator|&&
name|ibp
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
name|ibp
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|ibp
operator|<
name|limit
operator|&&
operator|(
operator|*
name|ibp
operator|==
literal|'+'
operator|||
operator|*
name|ibp
operator|==
literal|'-'
operator|)
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
comment|/* But traditional C does not let the token go past the sign.  */
if|if
condition|(
name|traditional
condition|)
break|break;
block|}
block|}
block|}
break|break;
block|}
comment|/* fall through */
case|case
literal|'_'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
name|letter
label|:
name|ident_length
operator|++
expr_stmt|;
comment|/* Compute step of hash function, to avoid a proc call on every token */
name|hash
operator|=
name|HASHSTEP
argument_list|(
name|hash
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
if|if
condition|(
name|ip
operator|->
name|fname
operator|==
literal|0
operator|&&
operator|*
name|ibp
operator|==
literal|'-'
condition|)
block|{
comment|/* Newline - inhibits expansion of preceding token. 	   If expanding a macro arg, we keep the newline -. 	   In final output, it is deleted. 	   We recognize Newline - in macro bodies and macro args.  */
if|if
condition|(
operator|!
name|concatenated
condition|)
block|{
name|ident_length
operator|=
literal|0
expr_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
block|}
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|output_marks
condition|)
block|{
name|obp
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* If expanding a macro arg, keep the newline -.  */
operator|*
name|obp
operator|++
operator|=
literal|'-'
expr_stmt|;
block|}
break|break;
block|}
comment|/* If reprocessing a macro expansion, newline is a special marker.  */
elseif|else
if|if
condition|(
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
block|{
comment|/* Newline White is a "funny space" to separate tokens that are 	   supposed to be separate but without space between. 	   Here White means any whitespace character. 	   Newline - marks a recursive macro use that is not 	   supposed to be expandable.  */
if|if
condition|(
name|is_space
index|[
operator|*
name|ibp
index|]
condition|)
block|{
comment|/* Newline Space does not prevent expansion of preceding token 	     so expand the preceding token and then come back.  */
if|if
condition|(
name|ident_length
operator|>
literal|0
condition|)
goto|goto
name|specialchar
goto|;
comment|/* If generating final output, newline space makes a space.  */
if|if
condition|(
operator|!
name|output_marks
condition|)
block|{
name|obp
index|[
operator|-
literal|1
index|]
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
comment|/* And Newline Newline makes a newline, so count it.  */
if|if
condition|(
name|obp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|op
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* If expanding a macro arg, keep the newline space. 	       If the arg gets stringified, newline space makes nothing.  */
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Newline followed by something random?  */
break|break;
block|}
comment|/* If there is a pending identifier, handle it and come back here.  */
if|if
condition|(
name|ident_length
operator|>
literal|0
condition|)
goto|goto
name|specialchar
goto|;
name|beg_of_line
operator|=
name|ibp
expr_stmt|;
comment|/* Update the line counts and output a #line if necessary.  */
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|lineno
operator|!=
name|op
operator|->
name|lineno
condition|)
block|{
name|op
operator|->
name|bufp
operator|=
name|obp
expr_stmt|;
name|output_line_command
argument_list|(
name|ip
argument_list|,
name|op
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|limit
operator|-
name|ibp
argument_list|)
expr_stmt|;
name|obp
operator|=
name|op
operator|->
name|bufp
expr_stmt|;
block|}
break|break;
comment|/* Come here either after (1) a null character that is part of the input 	 or (2) at the end of the input, because there is a null there.  */
case|case
literal|0
case|:
if|if
condition|(
name|ibp
operator|<=
name|limit
condition|)
comment|/* Our input really contains a null character.  */
goto|goto
name|randomchar
goto|;
comment|/* At end of a macro-expansion level, pop it and read next level.  */
if|if
condition|(
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
block|{
name|obp
operator|--
expr_stmt|;
name|ibp
operator|--
expr_stmt|;
comment|/* If traditional, and we have an identifier that ends here, 	   process it now, so we get the right error for recursion.  */
if|if
condition|(
name|traditional
operator|&&
name|ident_length
operator|&&
operator|!
name|is_idchar
index|[
operator|*
name|instack
index|[
name|indepth
operator|-
literal|1
index|]
operator|.
name|bufp
index|]
condition|)
block|{
name|redo_char
operator|=
literal|1
expr_stmt|;
goto|goto
name|randomchar
goto|;
block|}
name|POPMACRO
expr_stmt|;
name|RECACHE
expr_stmt|;
break|break;
block|}
comment|/* If we don't have a pending identifier, 	 return at end of input.  */
if|if
condition|(
name|ident_length
operator|==
literal|0
condition|)
block|{
name|obp
operator|--
expr_stmt|;
name|ibp
operator|--
expr_stmt|;
name|op
operator|->
name|bufp
operator|=
name|obp
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|ibp
expr_stmt|;
goto|goto
name|ending
goto|;
block|}
comment|/* If we do have a pending identifier, just consider this null 	 a special character and arrange to dispatch on it again. 	 The second time, IDENT_LENGTH will be zero so we will return.  */
comment|/* Fall through */
name|specialchar
label|:
comment|/* Handle the case of a character such as /, ', " or null 	 seen following an identifier.  Back over it so that 	 after the identifier is processed the special char 	 will be dispatched on again.  */
name|ibp
operator|--
expr_stmt|;
name|obp
operator|--
expr_stmt|;
name|redo_char
operator|=
literal|1
expr_stmt|;
default|default:
name|randomchar
label|:
if|if
condition|(
name|ident_length
operator|>
literal|0
condition|)
block|{
specifier|register
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
comment|/* We have just seen an identifier end.  If it's a macro, expand it.  	   IDENT_LENGTH is the length of the identifier 	   and HASH is its hash code.  	   The identifier has already been copied to the output, 	   so if it is a macro we must remove it.  	   If REDO_CHAR is 0, the char that terminated the identifier 	   has been skipped in the output and the input. 	   OBP-IDENT_LENGTH-1 points to the identifier. 	   If the identifier is a macro, we must back over the terminator.  	   If REDO_CHAR is 1, the terminating char has already been 	   backed over.  OBP-IDENT_LENGTH points to the identifier.  */
if|if
condition|(
operator|!
name|pcp_outfile
operator|||
name|pcp_inside_if
condition|)
block|{
name|startagain
label|:
for|for
control|(
name|hp
operator|=
name|hashtab
index|[
name|MAKE_POS
argument_list|(
name|hash
argument_list|)
operator|%
name|HASHSIZE
index|]
init|;
name|hp
operator|!=
name|NULL
condition|;
name|hp
operator|=
name|hp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|hp
operator|->
name|length
operator|==
name|ident_length
condition|)
block|{
name|int
name|obufp_before_macroname
decl_stmt|;
name|int
name|op_lineno_before_macroname
decl_stmt|;
specifier|register
name|int
name|i
init|=
name|ident_length
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p
init|=
name|hp
operator|->
name|name
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|q
init|=
name|obp
operator|-
name|i
decl_stmt|;
name|int
name|disabled
decl_stmt|;
if|if
condition|(
operator|!
name|redo_char
condition|)
name|q
operator|--
expr_stmt|;
do|do
block|{
comment|/* All this to avoid a strncmp () */
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|q
operator|++
condition|)
goto|goto
name|hashcollision
goto|;
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
comment|/* We found a use of a macro name. 		 see if the context shows it is a macro call.  */
comment|/* Back up over terminating character if not already done.  */
if|if
condition|(
operator|!
name|redo_char
condition|)
block|{
name|ibp
operator|--
expr_stmt|;
name|obp
operator|--
expr_stmt|;
block|}
comment|/* Save this as a displacement from the beginning of the output 		 buffer.  We can not save this as a position in the output 		 buffer, because it may get realloc'ed by RECACHE.  */
name|obufp_before_macroname
operator|=
operator|(
name|obp
operator|-
name|op
operator|->
name|buf
operator|)
operator|-
name|ident_length
expr_stmt|;
name|op_lineno_before_macroname
operator|=
name|op
operator|->
name|lineno
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_PCSTRING
condition|)
block|{
name|pcstring_used
argument_list|(
name|hp
argument_list|)
expr_stmt|;
comment|/* Mark the definition of this key 				       as needed, ensuring that it 				       will be output.  */
break|break;
comment|/* Exit loop, since the key cannot have a 				   definition any longer.  */
block|}
comment|/* Record whether the macro is disabled.  */
name|disabled
operator|=
name|hp
operator|->
name|type
operator|==
name|T_DISABLED
expr_stmt|;
comment|/* This looks like a macro ref, but if the macro was disabled, 		 just copy its name and put in a marker if requested.  */
if|if
condition|(
name|disabled
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This error check caught useful cases such as 		   #define foo(x,y) bar (x (y,0), y) 		   foo (foo, baz)  */
block|if (traditional) 		  error ("recursive use of macro `%s'", hp->name);
endif|#
directive|endif
if|if
condition|(
name|output_marks
condition|)
block|{
name|check_expand
argument_list|(
name|op
argument_list|,
name|limit
operator|-
name|ibp
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
literal|'-'
expr_stmt|;
block|}
break|break;
block|}
comment|/* If macro wants an arglist, verify that a '(' follows. 		 first skip all whitespace, copying it to the output 		 after the macro name.  Then, if there is no '(', 		 decide this is not a macro call and leave things that way.  */
if|if
condition|(
operator|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
operator|||
name|hp
operator|->
name|type
operator|==
name|T_DISABLED
operator|)
operator|&&
name|hp
operator|->
name|value
operator|.
name|defn
operator|->
name|nargs
operator|>=
literal|0
condition|)
block|{
name|U_CHAR
modifier|*
name|old_ibp
init|=
name|ibp
decl_stmt|;
name|U_CHAR
modifier|*
name|old_obp
init|=
name|obp
decl_stmt|;
name|int
name|old_iln
init|=
name|ip
operator|->
name|lineno
decl_stmt|;
name|int
name|old_oln
init|=
name|op
operator|->
name|lineno
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Scan forward over whitespace, copying it to the output.  */
if|if
condition|(
name|ibp
operator|==
name|limit
operator|&&
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
block|{
name|POPMACRO
expr_stmt|;
name|RECACHE
expr_stmt|;
name|old_ibp
operator|=
name|ibp
expr_stmt|;
name|old_obp
operator|=
name|obp
expr_stmt|;
name|old_iln
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
name|old_oln
operator|=
name|op
operator|->
name|lineno
expr_stmt|;
block|}
comment|/* A comment: copy it unchanged or discard it.  */
elseif|else
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'/'
operator|&&
name|ibp
operator|+
literal|1
operator|!=
name|limit
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|put_out_comments
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
literal|'*'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|ibp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|ibp
operator|+
literal|1
operator|!=
name|limit
operator|&&
operator|!
operator|(
name|ibp
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
comment|/* We need not worry about newline-marks, 			   since they are never found in comments.  */
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
block|{
comment|/* Newline in a file.  Count it.  */
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
block|}
if|if
condition|(
name|put_out_comments
condition|)
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
else|else
name|ibp
operator|++
expr_stmt|;
block|}
name|ibp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|put_out_comments
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
literal|'*'
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|is_space
index|[
operator|*
name|ibp
index|]
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
name|ibp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|macro
operator|==
literal|0
condition|)
block|{
comment|/* Newline in a file.  Count it.  */
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|output_marks
condition|)
block|{
comment|/* A newline mark, and we don't want marks 			     in the output.  If it is newline-hyphen, 			     discard it entirely.  Otherwise, it is 			     newline-whitechar, so keep the whitechar.  */
name|obp
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'-'
condition|)
name|ibp
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* A newline mark; copy both chars to the output.  */
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
break|break;
block|}
if|if
condition|(
operator|*
name|ibp
operator|!=
literal|'('
condition|)
block|{
comment|/* It isn't a macro call. 		       Put back the space that we just skipped.  */
name|ibp
operator|=
name|old_ibp
expr_stmt|;
name|obp
operator|=
name|old_obp
expr_stmt|;
name|ip
operator|->
name|lineno
operator|=
name|old_iln
expr_stmt|;
name|op
operator|->
name|lineno
operator|=
name|old_oln
expr_stmt|;
comment|/* Exit the for loop.  */
break|break;
block|}
block|}
comment|/* This is now known to be a macro call. 		 Discard the macro name from the output, 		 along with any following whitespace just copied, 		 but preserve newlines if not outputting marks since this 		 is more likely to do the right thing with line numbers.  */
name|obp
operator|=
name|op
operator|->
name|buf
operator|+
name|obufp_before_macroname
expr_stmt|;
if|if
condition|(
name|output_marks
condition|)
name|op
operator|->
name|lineno
operator|=
name|op_lineno_before_macroname
expr_stmt|;
else|else
block|{
name|int
name|newlines
init|=
name|op
operator|->
name|lineno
operator|-
name|op_lineno_before_macroname
decl_stmt|;
while|while
condition|(
literal|0
operator|<
name|newlines
operator|--
condition|)
operator|*
name|obp
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
comment|/* Prevent accidental token-pasting with a character 		 before the macro call.  */
if|if
condition|(
operator|!
name|traditional
operator|&&
name|obp
operator|!=
name|op
operator|->
name|buf
operator|&&
operator|(
name|obp
index|[
operator|-
literal|1
index|]
operator|==
literal|'-'
operator|||
name|obp
index|[
literal|1
index|]
operator|==
literal|'+'
operator|||
name|obp
index|[
literal|1
index|]
operator|==
literal|'&'
operator|||
name|obp
index|[
operator|-
literal|1
index|]
operator|==
literal|'|'
operator|||
name|obp
index|[
literal|1
index|]
operator|==
literal|'<'
operator|||
name|obp
index|[
literal|1
index|]
operator|==
literal|'>'
operator|)
condition|)
block|{
comment|/* If we are expanding a macro arg, make a newline marker 		   to separate the tokens.  If we are making real output, 		   a plain space will do.  */
if|if
condition|(
name|output_marks
condition|)
operator|*
name|obp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
comment|/* Expand the macro, reading arguments as needed, 		 and push the expansion on the input stack.  */
name|ip
operator|->
name|bufp
operator|=
name|ibp
expr_stmt|;
name|op
operator|->
name|bufp
operator|=
name|obp
expr_stmt|;
name|macroexpand
argument_list|(
name|hp
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/* Reexamine input stack, since macroexpand has pushed 		 a new level on it.  */
name|obp
operator|=
name|op
operator|->
name|bufp
expr_stmt|;
name|RECACHE
expr_stmt|;
break|break;
block|}
name|hashcollision
label|:
empty_stmt|;
block|}
comment|/* End hash-table-search loop */
block|}
name|ident_length
operator|=
name|hash
operator|=
literal|0
expr_stmt|;
comment|/* Stop collecting identifier */
name|redo_char
operator|=
literal|0
expr_stmt|;
name|concatenated
operator|=
literal|0
expr_stmt|;
block|}
comment|/* End if (ident_length> 0) */
block|}
comment|/* End switch */
block|}
comment|/* End per-char loop */
comment|/* Come here to return -- but first give an error message      if there was an unterminated successful conditional.  */
name|ending
label|:
if|if
condition|(
name|if_stack
operator|!=
name|ip
operator|->
name|if_stack
condition|)
block|{
name|char
modifier|*
name|str
init|=
literal|"unknown"
decl_stmt|;
switch|switch
condition|(
name|if_stack
operator|->
name|type
condition|)
block|{
case|case
name|T_IF
case|:
name|str
operator|=
literal|"if"
expr_stmt|;
break|break;
case|case
name|T_IFDEF
case|:
name|str
operator|=
literal|"ifdef"
expr_stmt|;
break|break;
case|case
name|T_IFNDEF
case|:
name|str
operator|=
literal|"ifndef"
expr_stmt|;
break|break;
case|case
name|T_ELSE
case|:
name|str
operator|=
literal|"else"
expr_stmt|;
break|break;
case|case
name|T_ELIF
case|:
name|str
operator|=
literal|"elif"
expr_stmt|;
break|break;
block|}
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|if_stack
operator|->
name|lineno
argument_list|)
argument_list|,
literal|"unterminated `#%s' conditional"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|if_stack
operator|=
name|ip
operator|->
name|if_stack
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Rescan a string into a temporary buffer and return the result  * as a FILE_BUF.  Note this function returns a struct, not a pointer.  *  * OUTPUT_MARKS nonzero means keep Newline markers found in the input  * and insert such markers when appropriate.  See `rescan' for details.  * OUTPUT_MARKS is 1 for macroexpanding a macro argument separately  * before substitution; it is 0 for other uses.  */
end_comment

begin_function
specifier|static
name|FILE_BUF
name|expand_to_temp_buffer
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|output_marks
parameter_list|,
name|assertions
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|output_marks
decl_stmt|,
name|assertions
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|FILE_BUF
name|obuf
decl_stmt|;
name|int
name|length
init|=
name|limit
operator|-
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|buf1
decl_stmt|;
name|int
name|odepth
init|=
name|indepth
decl_stmt|;
name|int
name|save_assertions_flag
init|=
name|assertions_flag
decl_stmt|;
name|assertions_flag
operator|=
name|assertions
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Set up the input on the input stack.  */
name|buf1
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|p1
init|=
name|buf
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p2
init|=
name|buf1
decl_stmt|;
while|while
condition|(
name|p1
operator|!=
name|limit
condition|)
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
block|}
name|buf1
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Set up to receive the output.  */
name|obuf
operator|.
name|length
operator|=
name|length
operator|*
literal|2
operator|+
literal|100
expr_stmt|;
comment|/* Usually enough.  Why be stingy?  */
name|obuf
operator|.
name|bufp
operator|=
name|obuf
operator|.
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|obuf
operator|.
name|length
argument_list|)
expr_stmt|;
name|obuf
operator|.
name|fname
operator|=
literal|0
expr_stmt|;
name|obuf
operator|.
name|macro
operator|=
literal|0
expr_stmt|;
name|obuf
operator|.
name|free_ptr
operator|=
literal|0
expr_stmt|;
name|CHECK_DEPTH
argument_list|(
argument|{return obuf;}
argument_list|)
empty_stmt|;
operator|++
name|indepth
expr_stmt|;
name|ip
operator|=
operator|&
name|instack
index|[
name|indepth
index|]
expr_stmt|;
name|ip
operator|->
name|fname
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|nominal_fname
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|system_header_p
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|macro
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|free_ptr
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|length
operator|=
name|length
expr_stmt|;
name|ip
operator|->
name|buf
operator|=
name|ip
operator|->
name|bufp
operator|=
name|buf1
expr_stmt|;
name|ip
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
name|ip
operator|->
name|lineno
operator|=
name|obuf
operator|.
name|lineno
operator|=
literal|1
expr_stmt|;
comment|/* Scan the input, create the output.  */
name|rescan
argument_list|(
operator|&
name|obuf
argument_list|,
name|output_marks
argument_list|)
expr_stmt|;
comment|/* Pop input stack to original state.  */
operator|--
name|indepth
expr_stmt|;
if|if
condition|(
name|indepth
operator|!=
name|odepth
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Record the output.  */
name|obuf
operator|.
name|length
operator|=
name|obuf
operator|.
name|bufp
operator|-
name|obuf
operator|.
name|buf
expr_stmt|;
name|assertions_flag
operator|=
name|save_assertions_flag
expr_stmt|;
return|return
name|obuf
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Process a # directive.  Expects IP->bufp to point after the '#', as in  * `#define foo bar'.  Passes to the command handler  * (do_define, do_include, etc.): the addresses of the 1st and  * last chars of the command (starting immediately after the #  * keyword), plus op and the keyword table pointer.  If the command  * contains comments it is copied into a temporary buffer sans comments  * and the temporary buffer is passed to the command handler instead.  * Likewise for backslash-newlines.  *  * Returns nonzero if this was a known # directive.  * Otherwise, returns zero, without advancing the input pointer.  */
end_comment

begin_function
specifier|static
name|int
name|handle_directive
parameter_list|(
name|ip
parameter_list|,
name|op
parameter_list|)
name|FILE_BUF
modifier|*
name|ip
decl_stmt|,
decl|*
name|op
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|directive
modifier|*
name|kt
decl_stmt|;
specifier|register
name|int
name|ident_length
decl_stmt|;
name|U_CHAR
modifier|*
name|resume_p
decl_stmt|;
comment|/* Nonzero means we must copy the entire command      to get rid of comments or backslash-newlines.  */
name|int
name|copy_command
init|=
literal|0
decl_stmt|;
name|U_CHAR
modifier|*
name|ident
decl_stmt|,
modifier|*
name|after_ident
decl_stmt|;
name|bp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
comment|/* Record where the directive started.  do_xifdef needs this.  */
name|directive_start
operator|=
name|bp
operator|-
literal|1
expr_stmt|;
comment|/* Skip whitespace and \-newline.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|bp
operator|==
literal|'\f'
operator|||
operator|*
name|bp
operator|==
literal|'\v'
operator|)
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"%s in preprocessing directive"
argument_list|,
operator|*
name|bp
operator|==
literal|'\f'
condition|?
literal|"formfeed"
else|:
literal|"vertical tab"
argument_list|)
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'/'
operator|&&
operator|(
name|bp
index|[
literal|1
index|]
operator|==
literal|'*'
operator|||
operator|(
name|cplusplus_comments
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
operator|)
condition|)
block|{
name|ip
operator|->
name|bufp
operator|=
name|bp
operator|+
literal|2
expr_stmt|;
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
operator|&
name|ip
operator|->
name|lineno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|bp
operator|+=
literal|2
expr_stmt|;
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* Now find end of directive name.      If we encounter a backslash-newline, exchange it with any following      symbol-constituents so that we end up with a contiguous name.  */
name|cp
operator|=
name|bp
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|is_idchar
index|[
operator|*
name|cp
index|]
condition|)
name|cp
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|name_newline_fix
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_idchar
index|[
operator|*
name|cp
index|]
condition|)
name|cp
operator|++
expr_stmt|;
else|else
break|break;
block|}
block|}
name|ident_length
operator|=
name|cp
operator|-
name|bp
expr_stmt|;
name|ident
operator|=
name|bp
expr_stmt|;
name|after_ident
operator|=
name|cp
expr_stmt|;
comment|/* A line of just `#' becomes blank.  */
if|if
condition|(
name|ident_length
operator|==
literal|0
operator|&&
operator|*
name|after_ident
operator|==
literal|'\n'
condition|)
block|{
name|ip
operator|->
name|bufp
operator|=
name|after_ident
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|ident_length
operator|==
literal|0
operator|||
operator|!
name|is_idstart
index|[
operator|*
name|ident
index|]
condition|)
block|{
name|U_CHAR
modifier|*
name|p
init|=
name|ident
decl_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|<
literal|'0'
operator|||
operator|*
name|p
operator|>
literal|'9'
condition|)
break|break;
name|p
operator|++
expr_stmt|;
block|}
comment|/* Handle # followed by a line number.  */
if|if
condition|(
name|p
operator|!=
name|ident
operator|&&
operator|!
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
block|{
specifier|static
name|struct
name|directive
name|line_directive_table
index|[]
init|=
block|{
block|{
literal|4
block|,
name|do_line
block|,
literal|"line"
block|,
name|T_LINE
block|}
block|,       }
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"`#' followed by integer"
argument_list|)
expr_stmt|;
name|after_ident
operator|=
name|ident
expr_stmt|;
name|kt
operator|=
name|line_directive_table
expr_stmt|;
goto|goto
name|old_linenum
goto|;
block|}
comment|/* Avoid error for `###' and similar cases unless -pedantic.  */
if|if
condition|(
name|p
operator|==
name|ident
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|==
literal|'#'
operator|||
name|is_hor_space
index|[
operator|*
name|p
index|]
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|lang_asm
condition|)
name|warning
argument_list|(
literal|"invalid preprocessor directive"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|!
name|lang_asm
condition|)
name|error
argument_list|(
literal|"invalid preprocessor directive name"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*    * Decode the keyword and call the appropriate expansion    * routine, after moving the input pointer up to the next line.    */
for|for
control|(
name|kt
operator|=
name|directive_table
init|;
name|kt
operator|->
name|length
operator|>
literal|0
condition|;
name|kt
operator|++
control|)
block|{
if|if
condition|(
name|kt
operator|->
name|length
operator|==
name|ident_length
operator|&&
operator|!
name|strncmp
argument_list|(
name|kt
operator|->
name|name
argument_list|,
name|ident
argument_list|,
name|ident_length
argument_list|)
condition|)
block|{
specifier|register
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
name|int
name|unterminated
decl_stmt|;
name|int
name|junk
decl_stmt|;
name|int
modifier|*
name|already_output
decl_stmt|;
comment|/* Nonzero means do not delete comments within the directive. 	 #define needs this when -traditional.  */
name|int
name|keep_comments
decl_stmt|;
name|old_linenum
label|:
name|limit
operator|=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
expr_stmt|;
name|unterminated
operator|=
literal|0
expr_stmt|;
name|already_output
operator|=
literal|0
expr_stmt|;
name|keep_comments
operator|=
name|traditional
operator|&&
name|kt
operator|->
name|traditional_comments
expr_stmt|;
comment|/* #import is defined only in Objective C, or when on the NeXT.  */
if|if
condition|(
name|kt
operator|->
name|type
operator|==
name|T_IMPORT
operator|&&
operator|!
operator|(
name|objc
operator|||
name|lookup
argument_list|(
literal|"__NeXT__"
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
condition|)
break|break;
comment|/* Find the end of this command (first newline not backslashed 	 and not in a string or comment). 	 Set COPY_COMMAND if the command must be copied 	 (it contains a backslash-newline or a comment).  */
name|buf
operator|=
name|bp
operator|=
name|after_ident
expr_stmt|;
while|while
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
specifier|register
name|U_CHAR
name|c
init|=
operator|*
name|bp
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
block|{
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
name|copy_command
operator|=
literal|1
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|traditional
condition|)
name|bp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
name|bp
operator|=
name|skip_quoted_string
argument_list|(
name|bp
operator|-
literal|1
argument_list|,
name|limit
argument_list|,
name|ip
operator|->
name|lineno
argument_list|,
operator|&
name|ip
operator|->
name|lineno
argument_list|,
operator|&
name|copy_command
argument_list|,
operator|&
name|unterminated
argument_list|)
expr_stmt|;
comment|/* Don't bother calling the directive if we already got an error 	     message due to unterminated string.  Skip everything and pretend 	     we called the directive.  */
if|if
condition|(
name|unterminated
condition|)
block|{
if|if
condition|(
name|traditional
condition|)
block|{
comment|/* Traditional preprocessing permits unterminated strings.  */
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
goto|goto
name|endloop1
goto|;
block|}
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
return|return
literal|1
return|;
block|}
break|break;
comment|/*<...> is special for #include.  */
case|case
literal|'<'
case|:
if|if
condition|(
operator|!
name|kt
operator|->
name|angle_brackets
condition|)
break|break;
while|while
condition|(
name|bp
operator|<
name|limit
operator|&&
operator|*
name|bp
operator|!=
literal|'>'
operator|&&
operator|*
name|bp
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
name|copy_command
operator|=
literal|1
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
name|bp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'*'
operator|||
operator|(
name|cplusplus_comments
operator|&&
operator|*
name|bp
operator|==
literal|'/'
operator|)
condition|)
block|{
name|U_CHAR
modifier|*
name|obp
init|=
name|bp
operator|-
literal|1
decl_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|bp
operator|+
literal|1
expr_stmt|;
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
operator|&
name|ip
operator|->
name|lineno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
comment|/* No need to copy the command because of a comment at the end; 	       just don't include the comment in the directive.  */
if|if
condition|(
name|bp
operator|==
name|limit
operator|||
operator|*
name|bp
operator|==
literal|'\n'
condition|)
block|{
name|bp
operator|=
name|obp
expr_stmt|;
goto|goto
name|endloop1
goto|;
block|}
comment|/* Don't remove the comments if -traditional.  */
if|if
condition|(
operator|!
name|keep_comments
condition|)
name|copy_command
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\f'
case|:
case|case
literal|'\v'
case|:
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"%s in preprocessing directive"
argument_list|,
name|c
operator|==
literal|'\f'
condition|?
literal|"formfeed"
else|:
literal|"vertical tab"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
operator|--
name|bp
expr_stmt|;
comment|/* Point to the newline */
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
goto|goto
name|endloop1
goto|;
block|}
block|}
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
name|endloop1
label|:
name|resume_p
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
comment|/* BP is the end of the directive. 	 RESUME_P is the next interesting data after the directive. 	 A comment may come between.  */
comment|/* If a directive should be copied through, and -E was given, 	 pass it through before removing comments.  */
if|if
condition|(
operator|!
name|no_output
operator|&&
name|kt
operator|->
name|pass_thru
operator|&&
name|put_out_comments
condition|)
block|{
name|int
name|len
decl_stmt|;
comment|/* Output directive name.  */
name|check_expand
argument_list|(
name|op
argument_list|,
name|kt
operator|->
name|length
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Make sure # is at the start of a line */
if|if
condition|(
name|op
operator|->
name|bufp
operator|>
name|op
operator|->
name|buf
operator|&&
name|op
operator|->
name|bufp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|op
operator|->
name|lineno
operator|++
expr_stmt|;
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'#'
expr_stmt|;
name|bcopy
argument_list|(
name|kt
operator|->
name|name
argument_list|,
name|op
operator|->
name|bufp
argument_list|,
name|kt
operator|->
name|length
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|kt
operator|->
name|length
expr_stmt|;
comment|/* Output arguments.  */
name|len
operator|=
operator|(
name|bp
operator|-
name|buf
operator|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
comment|/* Take account of any (escaped) newlines just output.  */
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
if|if
condition|(
name|buf
index|[
name|len
index|]
operator|==
literal|'\n'
condition|)
name|op
operator|->
name|lineno
operator|++
expr_stmt|;
name|already_output
operator|=
operator|&
name|junk
expr_stmt|;
block|}
comment|/* Don't we need a newline or #line? */
if|if
condition|(
name|copy_command
condition|)
block|{
specifier|register
name|U_CHAR
modifier|*
name|xp
init|=
name|buf
decl_stmt|;
comment|/* Need to copy entire command into temp buffer before dispatching */
name|cp
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|bp
operator|-
name|buf
operator|+
literal|5
argument_list|)
expr_stmt|;
comment|/* room for cmd plus 						  some slop */
name|buf
operator|=
name|cp
expr_stmt|;
comment|/* Copy to the new buffer, deleting comments 	   and backslash-newlines (and whitespace surrounding the latter).  */
while|while
condition|(
name|xp
operator|<
name|bp
condition|)
block|{
specifier|register
name|U_CHAR
name|c
init|=
operator|*
name|xp
operator|++
decl_stmt|;
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|abort
argument_list|()
expr_stmt|;
comment|/* A bare newline should never part of the line.  */
break|break;
comment|/*<...> is special for #include.  */
case|case
literal|'<'
case|:
if|if
condition|(
operator|!
name|kt
operator|->
name|angle_brackets
condition|)
break|break;
while|while
condition|(
name|xp
operator|<
name|bp
operator|&&
name|c
operator|!=
literal|'>'
condition|)
block|{
name|c
operator|=
operator|*
name|xp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|xp
operator|<
name|bp
operator|&&
operator|*
name|xp
operator|==
literal|'\n'
condition|)
name|xp
operator|++
expr_stmt|;
else|else
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
block|}
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
name|xp
operator|==
literal|'\n'
condition|)
block|{
name|xp
operator|++
expr_stmt|;
name|cp
operator|--
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|buf
operator|&&
name|is_space
index|[
name|cp
index|[
operator|-
literal|1
index|]
index|]
condition|)
block|{
while|while
condition|(
name|cp
operator|!=
name|buf
operator|&&
name|is_space
index|[
name|cp
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|cp
operator|--
expr_stmt|;
name|cp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|xp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_space
index|[
operator|*
name|xp
index|]
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
operator|*
name|xp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|xp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|cp
operator|++
operator|=
operator|*
name|xp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp1
init|=
name|skip_quoted_string
argument_list|(
name|xp
operator|-
literal|1
argument_list|,
name|bp
argument_list|,
name|ip
operator|->
name|lineno
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|)
decl_stmt|;
while|while
condition|(
name|xp
operator|!=
name|bp1
condition|)
if|if
condition|(
operator|*
name|xp
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|xp
operator|!=
literal|'\n'
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\\'
expr_stmt|;
else|else
name|xp
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|cp
operator|++
operator|=
operator|*
name|xp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
name|xp
operator|==
literal|'*'
operator|||
operator|(
name|cplusplus_comments
operator|&&
operator|*
name|xp
operator|==
literal|'/'
operator|)
condition|)
block|{
name|ip
operator|->
name|bufp
operator|=
name|xp
operator|+
literal|1
expr_stmt|;
comment|/* If we already copied the command through, 		 already_output != 0 prevents outputting comment now.  */
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
name|already_output
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep_comments
condition|)
while|while
condition|(
name|xp
operator|!=
name|ip
operator|->
name|bufp
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|xp
operator|++
expr_stmt|;
comment|/* Delete or replace the slash.  */
elseif|else
if|if
condition|(
name|traditional
condition|)
name|cp
operator|--
expr_stmt|;
else|else
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|xp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
block|}
block|}
block|}
comment|/* Null-terminate the copy.  */
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|cp
operator|=
name|bp
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|resume_p
expr_stmt|;
comment|/* Some directives should be written out for cc1 to process, 	 just as if they were not defined.  And sometimes we're copying 	 definitions through.  */
if|if
condition|(
operator|!
name|no_output
operator|&&
name|already_output
operator|==
literal|0
operator|&&
operator|(
name|kt
operator|->
name|pass_thru
operator|||
operator|(
name|kt
operator|->
name|type
operator|==
name|T_DEFINE
operator|&&
operator|(
name|dump_macros
operator|==
name|dump_names
operator|||
name|dump_macros
operator|==
name|dump_definitions
operator|)
operator|)
operator|)
condition|)
block|{
name|int
name|len
decl_stmt|;
comment|/* Output directive name.  */
name|check_expand
argument_list|(
name|op
argument_list|,
name|kt
operator|->
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'#'
expr_stmt|;
name|bcopy
argument_list|(
name|kt
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
name|kt
operator|->
name|length
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|kt
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|kt
operator|->
name|pass_thru
operator|||
name|dump_macros
operator|==
name|dump_definitions
condition|)
block|{
comment|/* Output arguments.  */
name|len
operator|=
operator|(
name|cp
operator|-
name|buf
operator|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kt
operator|->
name|type
operator|==
name|T_DEFINE
operator|&&
name|dump_macros
operator|==
name|dump_names
condition|)
block|{
name|U_CHAR
modifier|*
name|xp
init|=
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|yp
decl_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|xp
argument_list|)
expr_stmt|;
name|yp
operator|=
name|xp
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|xp
index|]
condition|)
name|xp
operator|++
expr_stmt|;
name|len
operator|=
operator|(
name|xp
operator|-
name|yp
operator|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|' '
expr_stmt|;
name|bcopy
argument_list|(
name|yp
argument_list|,
name|op
operator|->
name|bufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
block|}
block|}
comment|/* Don't we need a newline or #line? */
comment|/* Call the appropriate command handler.  buf now points to 	 either the appropriate place in the input buffer, or to 	 the temp buffer if it was necessary to make one.  cp 	 points to the first char after the contents of the (possibly 	 copied) command, in either case. */
call|(
modifier|*
name|kt
operator|->
name|func
call|)
argument_list|(
name|buf
argument_list|,
name|cp
argument_list|,
name|op
argument_list|,
name|kt
argument_list|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|ip
operator|->
name|length
operator|-
operator|(
name|ip
operator|->
name|bufp
operator|-
name|ip
operator|->
name|buf
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* It is deliberate that we don't warn about undefined directives.      That is the responsibility of cc1.  */
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_function
specifier|static
name|struct
name|tm
modifier|*
name|timestamp
parameter_list|()
block|{
specifier|static
name|struct
name|tm
modifier|*
name|timebuf
decl_stmt|;
if|if
condition|(
operator|!
name|timebuf
condition|)
block|{
name|time_t
name|t
init|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
decl_stmt|;
name|timebuf
operator|=
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
return|return
name|timebuf
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|monthnames
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|, 			    }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * expand things like __FILE__.  Place the expansion into the output  * buffer *without* rescanning.  */
end_comment

begin_function
specifier|static
name|void
name|special_symbol
parameter_list|(
name|hp
parameter_list|,
name|op
parameter_list|)
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|int
name|true_indepth
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|struct
name|tm
modifier|*
name|timebuf
decl_stmt|;
name|int
name|paren
init|=
literal|0
decl_stmt|;
comment|/* For special `defined' keyword */
if|if
condition|(
name|pcp_outfile
operator|&&
name|pcp_inside_if
operator|&&
name|hp
operator|->
name|type
operator|!=
name|T_SPEC_DEFINED
operator|&&
name|hp
operator|->
name|type
operator|!=
name|T_CONST
condition|)
name|error
argument_list|(
literal|"Predefined macro `%s' used inside `#if' during precompilation"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"cccp error: not in any file?!"
argument_list|)
expr_stmt|;
return|return;
comment|/* the show must go on */
block|}
switch|switch
condition|(
name|hp
operator|->
name|type
condition|)
block|{
case|case
name|T_FILE
case|:
case|case
name|T_BASE_FILE
case|:
block|{
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_FILE
condition|)
name|string
operator|=
name|ip
operator|->
name|nominal_fname
expr_stmt|;
else|else
name|string
operator|=
name|instack
index|[
literal|0
index|]
operator|.
name|nominal_fname
expr_stmt|;
if|if
condition|(
name|string
condition|)
block|{
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|3
operator|+
literal|4
operator|*
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|quote_string
argument_list|(
name|buf
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
else|else
name|buf
operator|=
literal|"\"\""
expr_stmt|;
break|break;
block|}
case|case
name|T_INCLUDE_LEVEL
case|:
name|true_indepth
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
name|true_indepth
operator|++
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|8
argument_list|)
expr_stmt|;
comment|/* Eight bytes ought to be more than enough */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|true_indepth
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_VERSION
case|:
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|3
operator|+
name|strlen
argument_list|(
name|version_string
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\"%s\""
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NO_BUILTIN_SIZE_TYPE
case|case
name|T_SIZE_TYPE
case|:
name|buf
operator|=
name|SIZE_TYPE
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_BUILTIN_PTRDIFF_TYPE
case|case
name|T_PTRDIFF_TYPE
case|:
name|buf
operator|=
name|PTRDIFF_TYPE
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|T_WCHAR_TYPE
case|:
name|buf
operator|=
name|wchar_type
expr_stmt|;
break|break;
case|case
name|T_USER_LABEL_PREFIX_TYPE
case|:
name|buf
operator|=
name|USER_LABEL_PREFIX
expr_stmt|;
break|break;
case|case
name|T_REGISTER_PREFIX_TYPE
case|:
name|buf
operator|=
name|REGISTER_PREFIX
expr_stmt|;
break|break;
case|case
name|T_CONST
case|:
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|hp
operator|->
name|value
operator|.
name|ival
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcp_inside_if
operator|&&
name|pcp_outfile
condition|)
comment|/* Output a precondition for this macro use */
name|fprintf
argument_list|(
name|pcp_outfile
argument_list|,
literal|"#define %s %d\n"
argument_list|,
name|hp
operator|->
name|name
argument_list|,
name|hp
operator|->
name|value
operator|.
name|ival
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SPECLINE
case|:
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_DATE
case|:
case|case
name|T_TIME
case|:
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|timebuf
operator|=
name|timestamp
argument_list|()
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_DATE
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\"%s %2d %4d\""
argument_list|,
name|monthnames
index|[
name|timebuf
operator|->
name|tm_mon
index|]
argument_list|,
name|timebuf
operator|->
name|tm_mday
argument_list|,
name|timebuf
operator|->
name|tm_year
operator|+
literal|1900
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\"%02d:%02d:%02d\""
argument_list|,
name|timebuf
operator|->
name|tm_hour
argument_list|,
name|timebuf
operator|->
name|tm_min
argument_list|,
name|timebuf
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SPEC_DEFINED
case|:
name|buf
operator|=
literal|" 0 "
expr_stmt|;
comment|/* Assume symbol is not defined */
name|ip
operator|=
operator|&
name|instack
index|[
name|indepth
index|]
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|ip
operator|->
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ip
operator|->
name|bufp
operator|==
literal|'('
condition|)
block|{
name|paren
operator|++
expr_stmt|;
name|ip
operator|->
name|bufp
operator|++
expr_stmt|;
comment|/* Skip over the paren */
name|SKIP_WHITE_SPACE
argument_list|(
name|ip
operator|->
name|bufp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|ip
operator|->
name|bufp
index|]
condition|)
goto|goto
name|oops
goto|;
if|if
condition|(
name|hp
operator|=
name|lookup
argument_list|(
name|ip
operator|->
name|bufp
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|pcp_outfile
operator|&&
name|pcp_inside_if
operator|&&
operator|(
name|hp
operator|->
name|type
operator|==
name|T_CONST
operator|||
operator|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
operator|&&
name|hp
operator|->
name|value
operator|.
name|defn
operator|->
name|predefined
operator|)
operator|)
condition|)
comment|/* Output a precondition for this macro use. */
name|fprintf
argument_list|(
name|pcp_outfile
argument_list|,
literal|"#define %s\n"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
name|buf
operator|=
literal|" 1 "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pcp_outfile
operator|&&
name|pcp_inside_if
condition|)
block|{
comment|/* Output a precondition for this macro use */
name|U_CHAR
modifier|*
name|cp
init|=
name|ip
operator|->
name|bufp
decl_stmt|;
name|fprintf
argument_list|(
name|pcp_outfile
argument_list|,
literal|"#undef "
argument_list|)
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|cp
index|]
condition|)
comment|/* Ick! */
name|fputc
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|pcp_outfile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|pcp_outfile
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|is_idchar
index|[
operator|*
name|ip
operator|->
name|bufp
index|]
condition|)
operator|++
name|ip
operator|->
name|bufp
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|ip
operator|->
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|paren
condition|)
block|{
if|if
condition|(
operator|*
name|ip
operator|->
name|bufp
operator|!=
literal|')'
condition|)
goto|goto
name|oops
goto|;
operator|++
name|ip
operator|->
name|bufp
expr_stmt|;
block|}
break|break;
name|oops
label|:
name|error
argument_list|(
literal|"`defined' without an identifier"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"cccp error: invalid special hash type"
argument_list|)
expr_stmt|;
comment|/* time for gdb */
name|abort
argument_list|()
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Routines to handle #directives */
end_comment

begin_comment
comment|/* Handle #include and #import.    This function expects to see "fname" or<fname> on the input.  */
end_comment

begin_function
specifier|static
name|int
name|do_include
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|importing
init|=
operator|(
name|keyword
operator|->
name|type
operator|==
name|T_IMPORT
operator|)
decl_stmt|;
name|int
name|skip_dirs
init|=
operator|(
name|keyword
operator|->
name|type
operator|==
name|T_INCLUDE_NEXT
operator|)
decl_stmt|;
specifier|static
name|int
name|import_warning
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* Dynamically allocated fname buffer */
name|char
modifier|*
name|pcftry
decl_stmt|;
name|char
modifier|*
name|pcfname
decl_stmt|;
name|U_CHAR
modifier|*
name|fbeg
decl_stmt|,
modifier|*
name|fend
decl_stmt|;
comment|/* Beginning and end of fname */
name|struct
name|file_name_list
modifier|*
name|search_start
init|=
name|include
decl_stmt|;
comment|/* Chain of dirs to search */
name|struct
name|file_name_list
name|dsp
index|[
literal|1
index|]
decl_stmt|;
comment|/* First in chain, if #include "..." */
name|struct
name|file_name_list
modifier|*
name|searchptr
init|=
literal|0
decl_stmt|;
name|int
name|flen
decl_stmt|;
name|int
name|f
decl_stmt|;
comment|/* file number */
name|int
name|retried
init|=
literal|0
decl_stmt|;
comment|/* Have already tried macro 				   expanding the include line*/
name|FILE_BUF
name|trybuf
decl_stmt|;
comment|/* It got expanded into here */
name|int
name|angle_brackets
init|=
literal|0
decl_stmt|;
comment|/* 0 for "...", 1 for<...> */
name|int
name|pcf
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|pcfbuf
decl_stmt|;
name|int
name|pcfbuflimit
decl_stmt|;
name|int
name|pcfnum
decl_stmt|;
name|f
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* JF we iz paranoid! */
if|if
condition|(
name|importing
operator|&&
name|warn_import
operator|&&
operator|!
name|inhibit_warnings
operator|&&
operator|!
name|instack
index|[
name|indepth
index|]
operator|.
name|system_header_p
operator|&&
operator|!
name|import_warning
condition|)
block|{
name|import_warning
operator|=
literal|1
expr_stmt|;
name|warning
argument_list|(
literal|"using `#import' is not recommended"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"The fact that a certain header file need not be processed more than once\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"should be indicated in the header file, not where it is used.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"The best way to do this is with a conditional of this form:\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  #ifndef _FOO_H_INCLUDED\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  #define _FOO_H_INCLUDED\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  ...<real contents of file> ...\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  #endif /* Not _FOO_H_INCLUDED */\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Then users can use `#include' any number of times.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GNU C automatically avoids processing the file more than once\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"when it is equipped with such a conditional.\n"
argument_list|)
expr_stmt|;
block|}
name|get_filename
label|:
name|fbeg
operator|=
name|buf
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|fbeg
argument_list|)
expr_stmt|;
comment|/* Discard trailing whitespace so we can easily see      if we have parsed all the significant chars we were given.  */
while|while
condition|(
name|limit
operator|!=
name|fbeg
operator|&&
name|is_hor_space
index|[
name|limit
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|limit
operator|--
expr_stmt|;
switch|switch
condition|(
operator|*
name|fbeg
operator|++
condition|)
block|{
case|case
literal|'\"'
case|:
block|{
name|FILE_BUF
modifier|*
name|fp
decl_stmt|;
comment|/* Copy the operand text, concatenating the strings.  */
block|{
name|U_CHAR
modifier|*
name|fin
init|=
name|fbeg
decl_stmt|;
name|fbeg
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|limit
operator|-
name|fbeg
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fend
operator|=
name|fbeg
expr_stmt|;
while|while
condition|(
name|fin
operator|!=
name|limit
condition|)
block|{
while|while
condition|(
name|fin
operator|!=
name|limit
operator|&&
operator|*
name|fin
operator|!=
literal|'\"'
condition|)
operator|*
name|fend
operator|++
operator|=
operator|*
name|fin
operator|++
expr_stmt|;
name|fin
operator|++
expr_stmt|;
if|if
condition|(
name|fin
operator|==
name|limit
condition|)
break|break;
comment|/* If not at the end, there had better be another string.  */
comment|/* Skip just horiz space, and don't go past limit.  */
while|while
condition|(
name|fin
operator|!=
name|limit
operator|&&
name|is_hor_space
index|[
operator|*
name|fin
index|]
condition|)
name|fin
operator|++
expr_stmt|;
if|if
condition|(
name|fin
operator|!=
name|limit
operator|&&
operator|*
name|fin
operator|==
literal|'\"'
condition|)
name|fin
operator|++
expr_stmt|;
else|else
goto|goto
name|fail
goto|;
block|}
block|}
operator|*
name|fend
operator|=
literal|0
expr_stmt|;
comment|/* We have "filename".  Figure out directory this source 	 file is coming from and put it on the front of the list. */
comment|/* If -I- was specified, don't search current dir, only spec'd ones. */
if|if
condition|(
name|ignore_srcdir
condition|)
break|break;
for|for
control|(
name|fp
operator|=
operator|&
name|instack
index|[
name|indepth
index|]
init|;
name|fp
operator|>=
name|instack
condition|;
name|fp
operator|--
control|)
block|{
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|,
modifier|*
name|nam
decl_stmt|;
if|if
condition|(
operator|(
name|nam
operator|=
name|fp
operator|->
name|nominal_fname
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Found a named file.  Figure out dir of the file, 	       and put it in front of the search list.  */
name|dsp
index|[
literal|0
index|]
operator|.
name|next
operator|=
name|search_start
expr_stmt|;
name|search_start
operator|=
name|dsp
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
name|ep
operator|=
name|rindex
argument_list|(
name|nam
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* VMS */
name|ep
operator|=
name|rindex
argument_list|(
name|nam
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
name|ep
operator|=
name|rindex
argument_list|(
name|nam
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
name|ep
operator|=
name|rindex
argument_list|(
name|nam
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
name|ep
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
block|{
name|n
operator|=
name|ep
operator|-
name|nam
expr_stmt|;
name|dsp
index|[
literal|0
index|]
operator|.
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|dsp
index|[
literal|0
index|]
operator|.
name|fname
argument_list|,
name|nam
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dsp
index|[
literal|0
index|]
operator|.
name|fname
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|n
operator|+
name|INCLUDE_LEN_FUDGE
operator|>
name|max_include_len
condition|)
name|max_include_len
operator|=
name|n
operator|+
name|INCLUDE_LEN_FUDGE
expr_stmt|;
block|}
else|else
block|{
name|dsp
index|[
literal|0
index|]
operator|.
name|fname
operator|=
literal|0
expr_stmt|;
comment|/* Current directory */
block|}
name|dsp
index|[
literal|0
index|]
operator|.
name|got_name_map
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
case|case
literal|'<'
case|:
name|fend
operator|=
name|fbeg
expr_stmt|;
while|while
condition|(
name|fend
operator|!=
name|limit
operator|&&
operator|*
name|fend
operator|!=
literal|'>'
condition|)
name|fend
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fend
operator|==
literal|'>'
operator|&&
name|fend
operator|+
literal|1
operator|==
name|limit
condition|)
block|{
name|angle_brackets
operator|=
literal|1
expr_stmt|;
comment|/* If -I-, start with the first -I dir after the -I-.  */
if|if
condition|(
name|first_bracket_include
condition|)
name|search_start
operator|=
name|first_bracket_include
expr_stmt|;
break|break;
block|}
goto|goto
name|fail
goto|;
default|default:
ifdef|#
directive|ifdef
name|VMS
comment|/*      * Support '#include xyz' like VAX-C to allow for easy use of all the      * decwindow include files. It defaults to '#include<xyz.h>' (so the      * code from case '<' is repeated here) and generates a warning.      */
if|if
condition|(
name|isalpha
argument_list|(
operator|*
operator|(
operator|--
name|fbeg
operator|)
argument_list|)
condition|)
block|{
name|fend
operator|=
name|fbeg
expr_stmt|;
while|while
condition|(
name|fend
operator|!=
name|limit
operator|&&
operator|(
operator|!
name|isspace
argument_list|(
operator|*
name|fend
argument_list|)
operator|)
condition|)
name|fend
operator|++
expr_stmt|;
name|warning
argument_list|(
literal|"VAX-C-style include specification found, use '#include<filename.h>' !"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fend
operator|==
name|limit
condition|)
block|{
name|angle_brackets
operator|=
literal|1
expr_stmt|;
comment|/* If -I-, start with the first -I dir after the -I-.  */
if|if
condition|(
name|first_bracket_include
condition|)
name|search_start
operator|=
name|first_bracket_include
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
name|fail
label|:
if|if
condition|(
name|retried
condition|)
block|{
name|error
argument_list|(
literal|"`#%s' expects \"FILENAME\" or<FILENAME>"
argument_list|,
name|keyword
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|trybuf
operator|=
name|expand_to_temp_buffer
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|trybuf
operator|.
name|bufp
operator|-
name|trybuf
operator|.
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|trybuf
operator|.
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|trybuf
operator|.
name|bufp
operator|-
name|trybuf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|limit
operator|=
name|buf
operator|+
operator|(
name|trybuf
operator|.
name|bufp
operator|-
name|trybuf
operator|.
name|buf
operator|)
expr_stmt|;
name|free
argument_list|(
name|trybuf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|retried
operator|++
expr_stmt|;
goto|goto
name|get_filename
goto|;
block|}
block|}
comment|/* For #include_next, skip in the search path      past the dir in which the containing file was found.  */
if|if
condition|(
name|skip_dirs
condition|)
block|{
name|FILE_BUF
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|fp
operator|=
operator|&
name|instack
index|[
name|indepth
index|]
init|;
name|fp
operator|>=
name|instack
condition|;
name|fp
operator|--
control|)
if|if
condition|(
name|fp
operator|->
name|fname
operator|!=
name|NULL
condition|)
block|{
comment|/* fp->dir is null if the containing file was specified 	   with an absolute file name.  In that case, don't skip anything.  */
if|if
condition|(
name|fp
operator|->
name|dir
condition|)
name|search_start
operator|=
name|fp
operator|->
name|dir
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
name|flen
operator|=
name|fend
operator|-
name|fbeg
expr_stmt|;
if|if
condition|(
name|flen
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"empty file name in `#%s'"
argument_list|,
name|keyword
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Allocate this permanently, because it gets stored in the definitions      of macros.  */
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|max_include_len
operator|+
name|flen
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* + 2 above for slash and terminating null.  */
comment|/* + 2 added for '.h' on VMS (to support '#include filename') */
comment|/* If specified file name is absolute, just open it.  */
if|if
condition|(
operator|*
name|fbeg
operator|==
literal|'/'
condition|)
block|{
name|strncpy
argument_list|(
name|fname
argument_list|,
name|fbeg
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|fname
index|[
name|flen
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|redundant_include_p
argument_list|(
name|fname
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|importing
condition|)
name|f
operator|=
name|lookup_import
argument_list|(
name|fname
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
else|else
name|f
operator|=
name|open_include_file
argument_list|(
name|fname
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
operator|-
literal|2
condition|)
return|return
literal|0
return|;
comment|/* Already included this file */
block|}
else|else
block|{
comment|/* Search directory path, trying to open the file.        Copy each filename tried into FNAME.  */
for|for
control|(
name|searchptr
operator|=
name|search_start
init|;
name|searchptr
condition|;
name|searchptr
operator|=
name|searchptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|searchptr
operator|->
name|fname
condition|)
block|{
comment|/* The empty string in a search path is ignored. 	   This makes it possible to turn off entirely 	   a standard piece of the list.  */
if|if
condition|(
name|searchptr
operator|->
name|fname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
continue|continue;
name|strcpy
argument_list|(
name|fname
argument_list|,
name|searchptr
operator|->
name|fname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|fname
index|[
name|strlen
argument_list|(
name|fname
argument_list|)
operator|+
name|flen
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fname
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|strncat
argument_list|(
name|fname
argument_list|,
name|fbeg
argument_list|,
name|flen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
comment|/* Change this 1/2 Unix 1/2 VMS file specification into a          full VMS file specification */
if|if
condition|(
name|searchptr
operator|->
name|fname
operator|&&
operator|(
name|searchptr
operator|->
name|fname
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* Fix up the filename */
name|hack_vms_include_specification
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a normal VMS filespec, so use it unchanged.  */
name|strncpy
argument_list|(
name|fname
argument_list|,
name|fbeg
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|fname
index|[
name|flen
index|]
operator|=
literal|0
expr_stmt|;
comment|/* if it's '#include filename', add the missing .h */
if|if
condition|(
name|index
argument_list|(
name|fname
argument_list|,
literal|'.'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|strcat
argument_list|(
name|fname
argument_list|,
literal|".h"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* VMS */
if|if
condition|(
name|importing
condition|)
name|f
operator|=
name|lookup_import
argument_list|(
name|fname
argument_list|,
name|searchptr
argument_list|)
expr_stmt|;
else|else
name|f
operator|=
name|open_include_file
argument_list|(
name|fname
argument_list|,
name|searchptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
operator|-
literal|2
condition|)
return|return
literal|0
return|;
comment|/* Already included this file */
ifdef|#
directive|ifdef
name|EACCES
elseif|else
if|if
condition|(
name|f
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EACCES
condition|)
name|warning
argument_list|(
literal|"Header file %s exists, but is not readable"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|redundant_include_p
argument_list|(
name|fname
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|f
operator|<
literal|0
condition|)
block|{
comment|/* A file that was not found.  */
name|strncpy
argument_list|(
name|fname
argument_list|,
name|fbeg
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|fname
index|[
name|flen
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If generating dependencies and -MG was specified, we assume missing        files are leaf files, living in the same directory as the source file        or other similar place; these missing files may be generated from        other files and may not exist yet (eg: y.tab.h).  */
if|if
condition|(
name|print_deps_missing_files
operator|&&
name|print_deps
operator|>
operator|(
name|angle_brackets
operator|||
operator|(
name|system_include_depth
operator|>
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* If it was requested as a system header file, 	   then assume it belongs in the first place to look for such.  */
if|if
condition|(
name|angle_brackets
condition|)
block|{
for|for
control|(
name|searchptr
operator|=
name|search_start
init|;
name|searchptr
condition|;
name|searchptr
operator|=
name|searchptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|searchptr
operator|->
name|fname
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|searchptr
operator|->
name|fname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
continue|continue;
name|p
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|searchptr
operator|->
name|fname
argument_list|)
operator|+
name|strlen
argument_list|(
name|fname
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|searchptr
operator|->
name|fname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|deps_output
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* Otherwise, omit the directory, as if the file existed 	       in the directory with the source.  */
name|deps_output
argument_list|(
name|fname
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If -M was specified, and this header file won't be added to the        dependency list, then don't count this as an error, because we can        still produce correct output.  Otherwise, we can't produce correct        output, because there may be dependencies we need inside the missing        file, and we don't know what directory this missing file exists in.  */
elseif|else
if|if
condition|(
name|print_deps
operator|&&
operator|(
name|print_deps
operator|<=
operator|(
name|angle_brackets
operator|||
operator|(
name|system_include_depth
operator|>
literal|0
operator|)
operator|)
operator|)
condition|)
name|warning
argument_list|(
literal|"No include path in which to find %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|search_start
condition|)
name|error_from_errno
argument_list|(
name|fname
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"No include path in which to find %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|stat
name|stat_f
decl_stmt|;
comment|/* Check to see if this include file is a once-only include file.        If so, give up.  */
name|struct
name|file_name_list
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|dont_repeat_files
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ptr
operator|->
name|fname
argument_list|,
name|fname
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* This file was once'd. */
block|}
block|}
for|for
control|(
name|ptr
operator|=
name|all_include_files
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ptr
operator|->
name|fname
argument_list|,
name|fname
argument_list|)
condition|)
break|break;
comment|/* This file was included before. */
block|}
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
block|{
comment|/* This is the first time for this file.  */
comment|/* Add it to list of files included.  */
name|ptr
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|c_system_include_path
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|next
operator|=
name|all_include_files
expr_stmt|;
name|all_include_files
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|->
name|fname
operator|=
name|savestring
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|got_name_map
operator|=
literal|0
expr_stmt|;
comment|/* For -M, add this file to the dependencies.  */
if|if
condition|(
name|print_deps
operator|>
operator|(
name|angle_brackets
operator|||
operator|(
name|system_include_depth
operator|>
literal|0
operator|)
operator|)
condition|)
name|deps_output
argument_list|(
name|fname
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
comment|/* Handle -H option.  */
if|if
condition|(
name|print_include_names
condition|)
block|{
name|output_dots
argument_list|(
name|stderr
argument_list|,
name|indepth
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|angle_brackets
condition|)
name|system_include_depth
operator|++
expr_stmt|;
comment|/* Actually process the file.  */
name|add_import
argument_list|(
name|f
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* Record file on "seen" list for #import. */
name|pcftry
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|fname
argument_list|)
operator|+
literal|30
argument_list|)
expr_stmt|;
name|pcfbuf
operator|=
literal|0
expr_stmt|;
name|pcfnum
operator|=
literal|0
expr_stmt|;
name|fstat
argument_list|(
name|f
argument_list|,
operator|&
name|stat_f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_precomp
condition|)
do|do
block|{
name|sprintf
argument_list|(
name|pcftry
argument_list|,
literal|"%s%d"
argument_list|,
name|fname
argument_list|,
name|pcfnum
operator|++
argument_list|)
expr_stmt|;
name|pcf
operator|=
name|open
argument_list|(
name|pcftry
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcf
operator|!=
operator|-
literal|1
condition|)
block|{
name|struct
name|stat
name|s
decl_stmt|;
name|fstat
argument_list|(
name|pcf
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|stat_f
operator|.
name|st_ino
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|s
operator|.
name|st_ino
argument_list|,
sizeof|sizeof
argument_list|(
name|s
operator|.
name|st_ino
argument_list|)
argument_list|)
operator|||
name|stat_f
operator|.
name|st_dev
operator|!=
name|s
operator|.
name|st_dev
condition|)
block|{
name|pcfbuf
operator|=
name|check_precompiled
argument_list|(
name|pcf
argument_list|,
name|fname
argument_list|,
operator|&
name|pcfbuflimit
argument_list|)
expr_stmt|;
comment|/* Don't need it any more.  */
name|close
argument_list|(
name|pcf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Don't need it at all.  */
name|close
argument_list|(
name|pcf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|pcf
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|pcfbuf
condition|)
do|;
comment|/* Actually process the file */
if|if
condition|(
name|pcfbuf
condition|)
block|{
name|pcfname
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|pcftry
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|pcfname
argument_list|,
name|pcftry
argument_list|)
expr_stmt|;
name|pcfinclude
argument_list|(
name|pcfbuf
argument_list|,
name|pcfbuflimit
argument_list|,
name|fname
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
else|else
name|finclude
argument_list|(
name|f
argument_list|,
name|fname
argument_list|,
name|op
argument_list|,
name|is_system_include
argument_list|(
name|fname
argument_list|)
argument_list|,
name|searchptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|angle_brackets
condition|)
name|system_include_depth
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Return nonzero if there is no need to include file NAME    because it has already been included and it contains a conditional    to make a repeated include do nothing.  */
end_comment

begin_function
specifier|static
name|int
name|redundant_include_p
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|file_name_list
modifier|*
name|l
init|=
name|all_include_files
decl_stmt|;
for|for
control|(
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|l
operator|->
name|fname
argument_list|)
operator|&&
name|l
operator|->
name|control_macro
operator|&&
name|lookup
argument_list|(
name|l
operator|->
name|control_macro
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the given FILENAME is an absolute pathname which    designates a file within one of the known "system" include file    directories.  We assume here that if the given FILENAME looks like    it is the name of a file which resides either directly in a "system"    include file directory, or within any subdirectory thereof, then the    given file must be a "system" include file.  This function tells us    if we should suppress pedantic errors/warnings for the given FILENAME.     The value is 2 if the file is a C-language system header file    for which C++ should (on most systems) assume `extern "C"'.  */
end_comment

begin_function
specifier|static
name|int
name|is_system_include
parameter_list|(
name|filename
parameter_list|)
specifier|register
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|struct
name|file_name_list
modifier|*
name|searchptr
decl_stmt|;
for|for
control|(
name|searchptr
operator|=
name|first_system_include
init|;
name|searchptr
condition|;
name|searchptr
operator|=
name|searchptr
operator|->
name|next
control|)
if|if
condition|(
name|searchptr
operator|->
name|fname
condition|)
block|{
specifier|register
name|char
modifier|*
name|sys_dir
init|=
name|searchptr
operator|->
name|fname
decl_stmt|;
specifier|register
name|unsigned
name|length
init|=
name|strlen
argument_list|(
name|sys_dir
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|sys_dir
argument_list|,
name|filename
argument_list|,
name|length
argument_list|)
operator|&&
name|filename
index|[
name|length
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|searchptr
operator|->
name|c_system_include_path
condition|)
return|return
literal|2
return|;
else|else
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The file_name_map structure holds a mapping of file names for a    particular directory.  This mapping is read from the file named    FILE_NAME_MAP_FILE in that directory.  Such a file can be used to    map filenames on a file system with severe filename restrictions,    such as DOS.  The format of the file name map file is just a series    of lines with two tokens on each line.  The first token is the name    to map, and the second token is the actual name to use.  */
end_comment

begin_struct
struct|struct
name|file_name_map
block|{
name|struct
name|file_name_map
modifier|*
name|map_next
decl_stmt|;
name|char
modifier|*
name|map_from
decl_stmt|;
name|char
modifier|*
name|map_to
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|FILE_NAME_MAP_FILE
value|"header.gcc"
end_define

begin_comment
comment|/* Read a space delimited string of unlimited length from a stdio    file.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_filename_string
parameter_list|(
name|ch
parameter_list|,
name|f
parameter_list|)
name|int
name|ch
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|char
modifier|*
name|alloc
decl_stmt|,
modifier|*
name|set
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
literal|20
expr_stmt|;
name|set
operator|=
name|alloc
operator|=
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_space
index|[
name|ch
index|]
condition|)
block|{
operator|*
name|set
operator|++
operator|=
name|ch
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
operator|!
name|is_space
index|[
name|ch
index|]
condition|)
block|{
if|if
condition|(
name|set
operator|-
name|alloc
operator|==
name|len
condition|)
block|{
name|len
operator|*=
literal|2
expr_stmt|;
name|alloc
operator|=
name|xrealloc
argument_list|(
name|alloc
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|set
operator|=
name|alloc
operator|+
name|len
operator|/
literal|2
expr_stmt|;
block|}
operator|*
name|set
operator|++
operator|=
name|ch
expr_stmt|;
block|}
block|}
operator|*
name|set
operator|=
literal|'\0'
expr_stmt|;
name|ungetc
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
name|alloc
return|;
block|}
end_function

begin_comment
comment|/* Read the file name map file for DIRNAME.  */
end_comment

begin_function
specifier|static
name|struct
name|file_name_map
modifier|*
name|read_name_map
parameter_list|(
name|dirname
parameter_list|)
name|char
modifier|*
name|dirname
decl_stmt|;
block|{
comment|/* This structure holds a linked list of file name maps, one per      directory.  */
struct|struct
name|file_name_map_list
block|{
name|struct
name|file_name_map_list
modifier|*
name|map_list_next
decl_stmt|;
name|char
modifier|*
name|map_list_name
decl_stmt|;
name|struct
name|file_name_map
modifier|*
name|map_list_map
decl_stmt|;
block|}
struct|;
specifier|static
name|struct
name|file_name_map_list
modifier|*
name|map_list
decl_stmt|;
specifier|register
name|struct
name|file_name_map_list
modifier|*
name|map_list_ptr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
for|for
control|(
name|map_list_ptr
operator|=
name|map_list
init|;
name|map_list_ptr
condition|;
name|map_list_ptr
operator|=
name|map_list_ptr
operator|->
name|map_list_next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|map_list_ptr
operator|->
name|map_list_name
argument_list|,
name|dirname
argument_list|)
condition|)
return|return
name|map_list_ptr
operator|->
name|map_list_map
return|;
name|map_list_ptr
operator|=
operator|(
operator|(
expr|struct
name|file_name_map_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_map_list
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|map_list_ptr
operator|->
name|map_list_name
operator|=
name|savestring
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|map_list_ptr
operator|->
name|map_list_map
operator|=
name|NULL
expr_stmt|;
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|dirname
argument_list|)
operator|+
name|strlen
argument_list|(
name|FILE_NAME_MAP_FILE
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dirname
condition|)
name|strcat
argument_list|(
name|name
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|name
argument_list|,
name|FILE_NAME_MAP_FILE
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
name|map_list_ptr
operator|->
name|map_list_map
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|int
name|ch
decl_stmt|;
name|int
name|dirlen
init|=
name|strlen
argument_list|(
name|dirname
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
name|struct
name|file_name_map
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|is_space
index|[
name|ch
index|]
condition|)
continue|continue;
name|from
operator|=
name|read_filename_string
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|is_hor_space
index|[
name|ch
index|]
condition|)
empty_stmt|;
name|to
operator|=
name|read_filename_string
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
operator|(
expr|struct
name|file_name_map
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_map
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|ptr
operator|->
name|map_from
operator|=
name|from
expr_stmt|;
comment|/* Make the real filename absolute.  */
if|if
condition|(
operator|*
name|to
operator|==
literal|'/'
condition|)
name|ptr
operator|->
name|map_to
operator|=
name|to
expr_stmt|;
else|else
block|{
name|ptr
operator|->
name|map_to
operator|=
name|xmalloc
argument_list|(
name|dirlen
operator|+
name|strlen
argument_list|(
name|to
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ptr
operator|->
name|map_to
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|map_to
index|[
name|dirlen
index|]
operator|=
literal|'/'
expr_stmt|;
name|strcpy
argument_list|(
name|ptr
operator|->
name|map_to
operator|+
name|dirlen
operator|+
literal|1
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|->
name|map_next
operator|=
name|map_list_ptr
operator|->
name|map_list_map
expr_stmt|;
name|map_list_ptr
operator|->
name|map_list_map
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
break|break;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|map_list_ptr
operator|->
name|map_list_next
operator|=
name|map_list
expr_stmt|;
name|map_list
operator|=
name|map_list_ptr
expr_stmt|;
return|return
name|map_list_ptr
operator|->
name|map_list_map
return|;
block|}
end_function

begin_comment
comment|/* Try to open include file FILENAME.  SEARCHPTR is the directory    being tried from the include file search path.  This function maps    filenames on file systems based on information read by    read_name_map.  */
end_comment

begin_function
specifier|static
name|int
name|open_include_file
parameter_list|(
name|filename
parameter_list|,
name|searchptr
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|searchptr
decl_stmt|;
block|{
specifier|register
name|struct
name|file_name_map
modifier|*
name|map
decl_stmt|;
specifier|register
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|dir
decl_stmt|;
if|#
directive|if
literal|0
block|if (searchptr&& ! searchptr->got_name_map)     {       searchptr->name_map = read_name_map (searchptr->fname 					   ? searchptr->fname : ".");       searchptr->got_name_map = 1;     }
comment|/* First check the mapping for the directory we are using.  */
block|if (searchptr&& searchptr->name_map)     {       from = filename;       if (searchptr->fname) 	from += strlen (searchptr->fname) + 1;       for (map = searchptr->name_map; map; map = map->map_next) 	{ 	  if (! strcmp (map->map_from, from)) 	    {
comment|/* Found a match.  */
block|return open (map->map_to, O_RDONLY, 0666); 	    } 	}     }
endif|#
directive|endif
comment|/* Try to find a mapping file for the particular directory we are      looking in.  Thus #include<sys/types.h> will look up sys/types.h      in /usr/include/header.gcc and look up types.h in      /usr/include/sys/header.gcc.  */
name|p
operator|=
name|rindex
argument_list|(
name|filename
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|filename
expr_stmt|;
if|if
condition|(
name|searchptr
operator|&&
name|searchptr
operator|->
name|fname
operator|&&
name|strlen
argument_list|(
name|searchptr
operator|->
name|fname
argument_list|)
operator|==
name|p
operator|-
name|filename
operator|&&
operator|!
name|strncmp
argument_list|(
name|searchptr
operator|->
name|fname
argument_list|,
name|filename
argument_list|,
name|p
operator|-
name|filename
argument_list|)
condition|)
block|{
comment|/* FILENAME is in SEARCHPTR, which we've already checked.  */
return|return
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
return|;
block|}
if|if
condition|(
name|p
operator|==
name|filename
condition|)
block|{
name|dir
operator|=
literal|"."
expr_stmt|;
name|from
operator|=
name|filename
expr_stmt|;
block|}
else|else
block|{
name|dir
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
name|filename
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|filename
argument_list|,
name|dir
argument_list|,
name|p
operator|-
name|filename
argument_list|)
expr_stmt|;
name|dir
index|[
name|p
operator|-
name|filename
index|]
operator|=
literal|'\0'
expr_stmt|;
name|from
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|for (map = read_name_map (dir); map; map = map->map_next)     if (! strcmp (map->map_from, from))       return open (map->map_to, O_RDONLY, 0666);
endif|#
directive|endif
return|return
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process the contents of include file FNAME, already open on descriptor F,    with output to OP.    SYSTEM_HEADER_P is 1 if this file resides in any one of the known    "system" include directories (as decided by the `is_system_include'    function above).    DIRPTR is the link in the dir path through which this file was found,    or 0 if the file name was absolute.  */
end_comment

begin_function
specifier|static
name|void
name|finclude
parameter_list|(
name|f
parameter_list|,
name|fname
parameter_list|,
name|op
parameter_list|,
name|system_header_p
parameter_list|,
name|dirptr
parameter_list|)
name|int
name|f
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
name|int
name|system_header_p
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|dirptr
decl_stmt|;
block|{
name|int
name|st_mode
decl_stmt|;
name|long
name|st_size
decl_stmt|;
name|long
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|fp
decl_stmt|;
comment|/* For input stack frame */
name|int
name|missing_newline
init|=
literal|0
decl_stmt|;
name|CHECK_DEPTH
argument_list|(
argument|return;
argument_list|)
empty_stmt|;
if|if
condition|(
name|file_size_and_mode
argument_list|(
name|f
argument_list|,
operator|&
name|st_mode
argument_list|,
operator|&
name|st_size
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
name|fp
operator|=
operator|&
name|instack
index|[
name|indepth
operator|+
literal|1
index|]
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
name|FILE_BUF
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|nominal_fname
operator|=
name|fp
operator|->
name|fname
operator|=
name|fname
expr_stmt|;
name|fp
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|lineno
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
name|fp
operator|->
name|system_header_p
operator|=
name|system_header_p
expr_stmt|;
name|fp
operator|->
name|dir
operator|=
name|dirptr
expr_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|st_mode
argument_list|)
condition|)
block|{
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|st_size
operator|+
literal|2
argument_list|)
expr_stmt|;
name|fp
operator|->
name|bufp
operator|=
name|fp
operator|->
name|buf
expr_stmt|;
comment|/* Read the file contents, knowing that st_size is an upper bound        on the number of bytes we can read.  */
name|fp
operator|->
name|length
operator|=
name|safe_read
argument_list|(
name|f
argument_list|,
name|fp
operator|->
name|buf
argument_list|,
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|length
operator|<
literal|0
condition|)
goto|goto
name|nope
goto|;
block|}
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st_mode
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"directory `%s' specified in #include"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Cannot count its file size before reading.        First read the entire file into heap and        copy them into buffer on stack. */
name|int
name|bsize
init|=
literal|2000
decl_stmt|;
name|st_size
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|bsize
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|safe_read
argument_list|(
name|f
argument_list|,
name|fp
operator|->
name|buf
operator|+
name|st_size
argument_list|,
name|bsize
operator|-
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
goto|goto
name|nope
goto|;
comment|/* error! */
name|st_size
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|st_size
operator|!=
name|bsize
condition|)
break|break;
comment|/* End of file */
name|bsize
operator|*=
literal|2
expr_stmt|;
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|fp
operator|->
name|buf
argument_list|,
name|bsize
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|fp
operator|->
name|bufp
operator|=
name|fp
operator|->
name|buf
expr_stmt|;
name|fp
operator|->
name|length
operator|=
name|st_size
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fp
operator|->
name|length
operator|>
literal|0
operator|&&
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
operator|-
literal|1
index|]
operator|!=
literal|'\n'
operator|)
comment|/* Backslash-newline at end is not good enough.  */
operator|||
operator|(
name|fp
operator|->
name|length
operator|>
literal|1
operator|&&
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
operator|-
literal|2
index|]
operator|==
literal|'\\'
operator|)
condition|)
block|{
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|missing_newline
operator|=
literal|1
expr_stmt|;
block|}
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Close descriptor now, so nesting does not use lots of descriptors.  */
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Must do this before calling trigraph_pcp, so that the correct file name      will be printed in warning messages.  */
name|indepth
operator|++
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|no_trigraphs
condition|)
name|trigraph_pcp
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|output_line_command
argument_list|(
name|fp
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|enter_file
argument_list|)
expr_stmt|;
name|rescan
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|missing_newline
condition|)
name|fp
operator|->
name|lineno
operator|--
expr_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|missing_newline
condition|)
name|pedwarn
argument_list|(
literal|"file does not end in newline"
argument_list|)
expr_stmt|;
name|indepth
operator|--
expr_stmt|;
name|input_file_stack_tick
operator|++
expr_stmt|;
name|output_line_command
argument_list|(
operator|&
name|instack
index|[
name|indepth
index|]
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|leave_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fp
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return;
name|nope
label|:
name|perror_with_name
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fp
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record that inclusion of the file named FILE    should be controlled by the macro named MACRO_NAME.    This means that trying to include the file again    will do something if that macro is defined.  */
end_comment

begin_function
specifier|static
name|void
name|record_control_macro
parameter_list|(
name|file
parameter_list|,
name|macro_name
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|U_CHAR
modifier|*
name|macro_name
decl_stmt|;
block|{
name|struct
name|file_name_list
modifier|*
name|new
decl_stmt|;
for|for
control|(
name|new
operator|=
name|all_include_files
init|;
name|new
condition|;
name|new
operator|=
name|new
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|new
operator|->
name|fname
argument_list|,
name|file
argument_list|)
condition|)
block|{
name|new
operator|->
name|control_macro
operator|=
name|macro_name
expr_stmt|;
return|return;
block|}
block|}
comment|/* If the file is not in all_include_files, something's wrong.  */
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Maintain and search list of included files, for #import.  */
end_comment

begin_define
define|#
directive|define
name|IMPORT_HASH_SIZE
value|31
end_define

begin_struct
struct|struct
name|import_file
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|ino_t
name|inode
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
name|struct
name|import_file
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Hash table of files already included with #include or #import.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|import_file
modifier|*
name|import_hash_table
index|[
name|IMPORT_HASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash a file name for import_hash_table.  */
end_comment

begin_function
specifier|static
name|int
name|import_hash
parameter_list|(
name|f
parameter_list|)
name|char
modifier|*
name|f
decl_stmt|;
block|{
name|int
name|val
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|f
condition|)
name|val
operator|+=
operator|*
name|f
operator|++
expr_stmt|;
return|return
operator|(
name|val
operator|%
name|IMPORT_HASH_SIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Search for file FILENAME in import_hash_table.    Return -2 if found, either a matching name or a matching inode.    Otherwise, open the file and return a file descriptor if successful    or -1 if unsuccessful.  */
end_comment

begin_function
specifier|static
name|int
name|lookup_import
parameter_list|(
name|filename
parameter_list|,
name|searchptr
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|file_name_list
modifier|*
name|searchptr
decl_stmt|;
block|{
name|struct
name|import_file
modifier|*
name|i
decl_stmt|;
name|int
name|h
decl_stmt|;
name|int
name|hashval
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|hashval
operator|=
name|import_hash
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Attempt to find file in list of already included files */
name|i
operator|=
name|import_hash_table
index|[
name|hashval
index|]
expr_stmt|;
while|while
condition|(
name|i
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|filename
argument_list|,
name|i
operator|->
name|name
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
comment|/* return found */
name|i
operator|=
name|i
operator|->
name|next
expr_stmt|;
block|}
comment|/* Open it and try a match on inode/dev */
name|fd
operator|=
name|open_include_file
argument_list|(
name|filename
argument_list|,
name|searchptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
name|fd
return|;
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
for|for
control|(
name|h
operator|=
literal|0
init|;
name|h
operator|<
name|IMPORT_HASH_SIZE
condition|;
name|h
operator|++
control|)
block|{
name|i
operator|=
name|import_hash_table
index|[
name|h
index|]
expr_stmt|;
while|while
condition|(
name|i
condition|)
block|{
comment|/* Compare the inode and the device. 	 Supposedly on some systems the inode is not a scalar.  */
if|if
condition|(
operator|!
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|i
operator|->
name|inode
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sb
operator|.
name|st_ino
argument_list|,
sizeof|sizeof
argument_list|(
name|sb
operator|.
name|st_ino
argument_list|)
argument_list|)
operator|&&
name|i
operator|->
name|dev
operator|==
name|sb
operator|.
name|st_dev
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
comment|/* return found */
block|}
name|i
operator|=
name|i
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return
name|fd
return|;
comment|/* Not found, return open file */
block|}
end_function

begin_comment
comment|/* Add the file FNAME, open on descriptor FD, to import_hash_table.  */
end_comment

begin_function
specifier|static
name|void
name|add_import
parameter_list|(
name|fd
parameter_list|,
name|fname
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
block|{
name|struct
name|import_file
modifier|*
name|i
decl_stmt|;
name|int
name|hashval
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|hashval
operator|=
name|import_hash
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
expr|struct
name|import_file
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|import_file
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|fname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|i
operator|->
name|name
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sb
operator|.
name|st_ino
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|i
operator|->
name|inode
argument_list|,
sizeof|sizeof
argument_list|(
name|sb
operator|.
name|st_ino
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|->
name|dev
operator|=
name|sb
operator|.
name|st_dev
expr_stmt|;
name|i
operator|->
name|next
operator|=
name|import_hash_table
index|[
name|hashval
index|]
expr_stmt|;
name|import_hash_table
index|[
name|hashval
index|]
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Load the specified precompiled header into core, and verify its    preconditions.  PCF indicates the file descriptor to read, which must    be a regular file.  FNAME indicates the file name of the original     header.  *LIMIT will be set to an address one past the end of the file.    If the preconditions of the file are not satisfied, the buffer is     freed and we return 0.  If the preconditions are satisfied, return    the address of the buffer following the preconditions.  The buffer, in    this case, should never be freed because various pieces of it will    be referred to until all precompiled strings are output at the end of    the run. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|check_precompiled
parameter_list|(
name|pcf
parameter_list|,
name|fname
parameter_list|,
name|limit
parameter_list|)
name|int
name|pcf
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
modifier|*
name|limit
decl_stmt|;
block|{
name|int
name|st_mode
decl_stmt|;
name|long
name|st_size
decl_stmt|;
name|int
name|length
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|pcp_outfile
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|file_size_and_mode
argument_list|(
name|pcf
argument_list|,
operator|&
name|st_mode
argument_list|,
operator|&
name|st_size
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|st_mode
argument_list|)
condition|)
block|{
name|buf
operator|=
name|xmalloc
argument_list|(
name|st_size
operator|+
literal|2
argument_list|)
expr_stmt|;
name|length
operator|=
name|safe_read
argument_list|(
name|pcf
argument_list|,
name|buf
argument_list|,
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
goto|goto
name|nope
goto|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
operator|&&
name|buf
index|[
name|length
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|buf
index|[
name|length
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|buf
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|limit
operator|=
name|buf
operator|+
name|length
expr_stmt|;
comment|/* File is in core.  Check the preconditions. */
if|if
condition|(
operator|!
name|check_preconditions
argument_list|(
name|buf
argument_list|)
condition|)
goto|goto
name|nope
goto|;
for|for
control|(
name|cp
operator|=
name|buf
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
empty_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_PCP
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Using preinclude %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|cp
operator|+
literal|1
return|;
name|nope
label|:
ifdef|#
directive|ifdef
name|DEBUG_PCP
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot use preinclude %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* PREC (null terminated) points to the preconditions of a    precompiled header.  These are a series of #define and #undef    lines which must match the current contents of the hash    table.  */
end_comment

begin_function
specifier|static
name|int
name|check_preconditions
parameter_list|(
name|prec
parameter_list|)
name|char
modifier|*
name|prec
decl_stmt|;
block|{
name|MACRODEF
name|mdef
decl_stmt|;
name|char
modifier|*
name|lineend
decl_stmt|;
while|while
condition|(
operator|*
name|prec
condition|)
block|{
name|lineend
operator|=
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|prec
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|prec
operator|++
operator|!=
literal|'#'
condition|)
block|{
name|error
argument_list|(
literal|"Bad format encountered while reading precompiled file"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|prec
argument_list|,
literal|"define"
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|prec
operator|+=
literal|6
expr_stmt|;
name|mdef
operator|=
name|create_definition
argument_list|(
name|prec
argument_list|,
name|lineend
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdef
operator|.
name|defn
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|hp
operator|=
name|lookup
argument_list|(
name|mdef
operator|.
name|symnam
argument_list|,
name|mdef
operator|.
name|symlen
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|hp
operator|->
name|type
operator|!=
name|T_MACRO
operator|&&
name|hp
operator|->
name|type
operator|!=
name|T_CONST
operator|)
operator|||
operator|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
operator|&&
operator|!
name|compare_defs
argument_list|(
name|mdef
operator|.
name|defn
argument_list|,
name|hp
operator|->
name|value
operator|.
name|defn
argument_list|)
operator|&&
operator|(
name|mdef
operator|.
name|defn
operator|->
name|length
operator|!=
literal|2
operator|||
name|mdef
operator|.
name|defn
operator|->
name|expansion
index|[
literal|0
index|]
operator|!=
literal|'\n'
operator|||
name|mdef
operator|.
name|defn
operator|->
name|expansion
index|[
literal|1
index|]
operator|!=
literal|' '
operator|)
operator|)
condition|)
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|prec
argument_list|,
literal|"undef"
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|prec
operator|+=
literal|5
expr_stmt|;
while|while
condition|(
name|is_hor_space
index|[
operator|(
name|U_CHAR
operator|)
operator|*
name|prec
index|]
condition|)
name|prec
operator|++
expr_stmt|;
name|name
operator|=
name|prec
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|(
name|U_CHAR
operator|)
operator|*
name|prec
index|]
condition|)
name|prec
operator|++
expr_stmt|;
name|len
operator|=
name|prec
operator|-
name|name
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Bad format encountered while reading precompiled file"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|prec
operator|=
name|lineend
operator|+
literal|1
expr_stmt|;
block|}
comment|/* They all passed successfully */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Process the main body of a precompiled file.  BUF points to the    string section of the file, following the preconditions.  LIMIT is one    character past the end.  NAME is the name of the file being read    in.  OP is the main output buffer */
end_comment

begin_function
specifier|static
name|void
name|pcfinclude
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|name
parameter_list|,
name|op
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|,
modifier|*
name|name
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE_BUF
name|tmpbuf
decl_stmt|;
name|int
name|nstrings
decl_stmt|;
name|U_CHAR
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
comment|/* First in the file comes 4 bytes indicating the number of strings, */
comment|/* in network byte order. (MSB first).  */
name|nstrings
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|nstrings
operator|=
operator|(
name|nstrings
operator|<<
literal|8
operator|)
operator||
operator|*
name|cp
operator|++
expr_stmt|;
name|nstrings
operator|=
operator|(
name|nstrings
operator|<<
literal|8
operator|)
operator||
operator|*
name|cp
operator|++
expr_stmt|;
name|nstrings
operator|=
operator|(
name|nstrings
operator|<<
literal|8
operator|)
operator||
operator|*
name|cp
operator|++
expr_stmt|;
comment|/* Looping over each string... */
while|while
condition|(
name|nstrings
operator|--
condition|)
block|{
name|U_CHAR
modifier|*
name|string_start
decl_stmt|;
name|U_CHAR
modifier|*
name|endofthiskey
decl_stmt|;
name|STRINGDEF
modifier|*
name|str
decl_stmt|;
name|int
name|nkeys
decl_stmt|;
comment|/* Each string starts with a STRINGDEF structure (str), followed */
comment|/* by the text of the string (string_start) */
comment|/* First skip to a longword boundary */
comment|/* ??? Why a 4-byte boundary?  On all machines? */
comment|/* NOTE: This works correctly even if HOST_WIDE_INT        is narrower than a pointer.        Do not try risky measures here to get another type to use!        Do not include stddef.h--it will fail!  */
if|if
condition|(
operator|(
name|HOST_WIDE_INT
operator|)
name|cp
operator|&
literal|3
condition|)
name|cp
operator|+=
literal|4
operator|-
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
name|cp
operator|&
literal|3
operator|)
expr_stmt|;
comment|/* Now get the string. */
name|str
operator|=
operator|(
name|STRINGDEF
operator|*
operator|)
name|cp
expr_stmt|;
name|string_start
operator|=
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|STRINGDEF
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
comment|/* skip the string */
empty_stmt|;
comment|/* We need to macro expand the string here to ensure that the        proper definition environment is in place.  If it were only        expanded when we find out it is needed, macros necessary for        its proper expansion might have had their definitions changed. */
name|tmpbuf
operator|=
name|expand_to_temp_buffer
argument_list|(
name|string_start
argument_list|,
name|cp
operator|++
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Lineno is already set in the precompiled file */
name|str
operator|->
name|contents
operator|=
name|tmpbuf
operator|.
name|buf
expr_stmt|;
name|str
operator|->
name|len
operator|=
name|tmpbuf
operator|.
name|length
expr_stmt|;
name|str
operator|->
name|writeflag
operator|=
literal|0
expr_stmt|;
name|str
operator|->
name|filename
operator|=
name|name
expr_stmt|;
name|str
operator|->
name|output_mark
operator|=
name|outbuf
operator|.
name|bufp
operator|-
name|outbuf
operator|.
name|buf
expr_stmt|;
name|str
operator|->
name|chain
operator|=
literal|0
expr_stmt|;
operator|*
name|stringlist_tailp
operator|=
name|str
expr_stmt|;
name|stringlist_tailp
operator|=
operator|&
name|str
operator|->
name|chain
expr_stmt|;
comment|/* Next comes a fourbyte number indicating the number of keys */
comment|/* for this string. */
name|nkeys
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|nkeys
operator|=
operator|(
name|nkeys
operator|<<
literal|8
operator|)
operator||
operator|*
name|cp
operator|++
expr_stmt|;
name|nkeys
operator|=
operator|(
name|nkeys
operator|<<
literal|8
operator|)
operator||
operator|*
name|cp
operator|++
expr_stmt|;
name|nkeys
operator|=
operator|(
name|nkeys
operator|<<
literal|8
operator|)
operator||
operator|*
name|cp
operator|++
expr_stmt|;
comment|/* If this number is -1, then the string is mandatory. */
if|if
condition|(
name|nkeys
operator|==
operator|-
literal|1
condition|)
name|str
operator|->
name|writeflag
operator|=
literal|1
expr_stmt|;
else|else
comment|/* Otherwise, for each key, */
for|for
control|(
init|;
name|nkeys
operator|--
condition|;
name|free
argument_list|(
name|tmpbuf
operator|.
name|buf
argument_list|)
operator|,
name|cp
operator|=
name|endofthiskey
operator|+
literal|1
control|)
block|{
name|KEYDEF
modifier|*
name|kp
init|=
operator|(
name|KEYDEF
operator|*
operator|)
name|cp
decl_stmt|;
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
comment|/* It starts with a KEYDEF structure */
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|KEYDEF
argument_list|)
expr_stmt|;
comment|/* Find the end of the key.  At the end of this for loop we 	   advance CP to the start of the next key using this variable. */
name|endofthiskey
operator|=
name|cp
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|kp
operator|->
name|str
operator|=
name|str
expr_stmt|;
comment|/* Expand the key, and enter it into the hash table. */
name|tmpbuf
operator|=
name|expand_to_temp_buffer
argument_list|(
name|cp
argument_list|,
name|endofthiskey
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmpbuf
operator|.
name|bufp
operator|=
name|tmpbuf
operator|.
name|buf
expr_stmt|;
while|while
condition|(
name|is_hor_space
index|[
operator|*
name|tmpbuf
operator|.
name|bufp
index|]
condition|)
name|tmpbuf
operator|.
name|bufp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|tmpbuf
operator|.
name|bufp
index|]
operator|||
name|tmpbuf
operator|.
name|bufp
operator|==
name|tmpbuf
operator|.
name|buf
operator|+
name|tmpbuf
operator|.
name|length
condition|)
block|{
name|str
operator|->
name|writeflag
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|hp
operator|=
name|lookup
argument_list|(
name|tmpbuf
operator|.
name|bufp
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|kp
operator|->
name|chain
operator|=
literal|0
expr_stmt|;
name|install
argument_list|(
name|tmpbuf
operator|.
name|bufp
argument_list|,
operator|-
literal|1
argument_list|,
name|T_PCSTRING
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|kp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_PCSTRING
condition|)
block|{
name|kp
operator|->
name|chain
operator|=
name|hp
operator|->
name|value
operator|.
name|keydef
expr_stmt|;
name|hp
operator|->
name|value
operator|.
name|keydef
operator|=
name|kp
expr_stmt|;
block|}
else|else
name|str
operator|->
name|writeflag
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* This output_line_command serves to switch us back to the current      input file in case some of these strings get output (which will       result in line commands for the header file being output). */
name|output_line_command
argument_list|(
operator|&
name|instack
index|[
name|indepth
index|]
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|enter_file
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Called from rescan when it hits a key for strings.  Mark them all */
end_comment

begin_comment
comment|/* used and clean up. */
end_comment

begin_function
specifier|static
name|void
name|pcstring_used
parameter_list|(
name|hp
parameter_list|)
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
block|{
name|KEYDEF
modifier|*
name|kp
decl_stmt|;
for|for
control|(
name|kp
operator|=
name|hp
operator|->
name|value
operator|.
name|keydef
init|;
name|kp
condition|;
name|kp
operator|=
name|kp
operator|->
name|chain
control|)
name|kp
operator|->
name|str
operator|->
name|writeflag
operator|=
literal|1
expr_stmt|;
name|delete_macro
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write the output, interspersing precompiled strings in their */
end_comment

begin_comment
comment|/* appropriate places. */
end_comment

begin_function
specifier|static
name|void
name|write_output
parameter_list|()
block|{
name|STRINGDEF
modifier|*
name|next_string
decl_stmt|;
name|U_CHAR
modifier|*
name|cur_buf_loc
decl_stmt|;
name|int
name|line_command_len
init|=
literal|80
decl_stmt|;
name|char
modifier|*
name|line_command
init|=
name|xmalloc
argument_list|(
name|line_command_len
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* In each run through the loop, either cur_buf_loc == */
comment|/* next_string_loc, in which case we print a series of strings, or */
comment|/* it is less than next_string_loc, in which case we write some of */
comment|/* the buffer. */
name|cur_buf_loc
operator|=
name|outbuf
operator|.
name|buf
expr_stmt|;
name|next_string
operator|=
name|stringlist
expr_stmt|;
while|while
condition|(
name|cur_buf_loc
operator|<
name|outbuf
operator|.
name|bufp
operator|||
name|next_string
condition|)
block|{
if|if
condition|(
name|next_string
operator|&&
name|cur_buf_loc
operator|-
name|outbuf
operator|.
name|buf
operator|==
name|next_string
operator|->
name|output_mark
condition|)
block|{
if|if
condition|(
name|next_string
operator|->
name|writeflag
condition|)
block|{
name|len
operator|=
literal|4
operator|*
name|strlen
argument_list|(
name|next_string
operator|->
name|filename
argument_list|)
operator|+
literal|32
expr_stmt|;
while|while
condition|(
name|len
operator|>
name|line_command_len
condition|)
name|line_command
operator|=
name|xrealloc
argument_list|(
name|line_command
argument_list|,
name|line_command_len
operator|*=
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line_command
argument_list|,
literal|"\n# %d "
argument_list|,
name|next_string
operator|->
name|lineno
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|quote_string
argument_list|(
name|line_command
operator|+
name|strlen
argument_list|(
name|line_command
argument_list|)
argument_list|,
name|next_string
operator|->
name|filename
argument_list|)
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|safe_write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|line_command
argument_list|,
name|strlen
argument_list|(
name|line_command
argument_list|)
argument_list|)
expr_stmt|;
name|safe_write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|next_string
operator|->
name|contents
argument_list|,
name|next_string
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
name|next_string
operator|=
name|next_string
operator|->
name|chain
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
operator|(
name|next_string
condition|?
operator|(
name|next_string
operator|->
name|output_mark
operator|-
operator|(
name|cur_buf_loc
operator|-
name|outbuf
operator|.
name|buf
operator|)
operator|)
else|:
name|outbuf
operator|.
name|bufp
operator|-
name|cur_buf_loc
operator|)
expr_stmt|;
name|safe_write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|cur_buf_loc
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cur_buf_loc
operator|+=
name|len
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|line_command
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pass a directive through to the output file.    BUF points to the contents of the directive, as a contiguous string.    LIMIT points to the first character past the end of the directive.    KEYWORD is the keyword-table entry for the directive.  */
end_comment

begin_function
specifier|static
name|void
name|pass_thru_directive
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|keyword_length
init|=
name|keyword
operator|->
name|length
decl_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
literal|1
operator|+
name|keyword_length
operator|+
operator|(
name|limit
operator|-
name|buf
operator|)
argument_list|)
expr_stmt|;
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'#'
expr_stmt|;
name|bcopy
argument_list|(
name|keyword
operator|->
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
name|keyword_length
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|keyword_length
expr_stmt|;
if|if
condition|(
name|limit
operator|!=
name|buf
operator|&&
name|buf
index|[
literal|0
index|]
operator|!=
literal|' '
condition|)
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|' '
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
name|limit
operator|-
name|buf
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
operator|(
name|limit
operator|-
name|buf
operator|)
expr_stmt|;
if|#
directive|if
literal|0
block|*op->bufp++ = '\n';
comment|/* Count the line we have just made in the output,      to get in sync properly.  */
block|op->lineno++;
endif|#
directive|endif
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* The arglist structure is built by do_define to tell    collect_definition where the argument names begin.  That    is, for a define like "#define f(x,y,z) foo+x-bar*y", the arglist    would contain pointers to the strings x, y, and z.    Collect_definition would then build a DEFINITION node,    with reflist nodes pointing to the places x, y, and z had    appeared.  So the arglist is just convenience data passed    between these two routines.  It is not kept around after    the current #define has been processed and entered into the    hash table. */
end_comment

begin_struct
struct|struct
name|arglist
block|{
name|struct
name|arglist
modifier|*
name|next
decl_stmt|;
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|argno
decl_stmt|;
name|char
name|rest_args
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Create a DEFINITION node from a #define directive.  Arguments are     as for do_define. */
end_comment

begin_function
specifier|static
name|MACRODEF
name|create_definition
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
comment|/* temp ptr into input buffer */
name|U_CHAR
modifier|*
name|symname
decl_stmt|;
comment|/* remember where symbol name starts */
name|int
name|sym_length
decl_stmt|;
comment|/* and how long it is */
name|int
name|line
init|=
name|instack
index|[
name|indepth
index|]
operator|.
name|lineno
decl_stmt|;
name|char
modifier|*
name|file
init|=
name|instack
index|[
name|indepth
index|]
operator|.
name|nominal_fname
decl_stmt|;
name|int
name|rest_args
init|=
literal|0
decl_stmt|;
name|DEFINITION
modifier|*
name|defn
decl_stmt|;
name|int
name|arglengths
init|=
literal|0
decl_stmt|;
comment|/* Accumulate lengths of arg names 				   plus number of args.  */
name|MACRODEF
name|mdef
decl_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
name|symname
operator|=
name|bp
expr_stmt|;
comment|/* remember where it starts */
name|sym_length
operator|=
name|check_macro_name
argument_list|(
name|bp
argument_list|,
literal|"macro"
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|sym_length
expr_stmt|;
comment|/* Lossage will occur if identifiers or control keywords are broken      across lines using backslash.  This is not the right place to take      care of that. */
if|if
condition|(
operator|*
name|bp
operator|==
literal|'('
condition|)
block|{
name|struct
name|arglist
modifier|*
name|arg_ptrs
init|=
name|NULL
decl_stmt|;
name|int
name|argno
init|=
literal|0
decl_stmt|;
name|bp
operator|++
expr_stmt|;
comment|/* skip '(' */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* Loop over macro argument names.  */
while|while
condition|(
operator|*
name|bp
operator|!=
literal|')'
condition|)
block|{
name|struct
name|arglist
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
expr|struct
name|arglist
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|bp
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|arg_ptrs
expr_stmt|;
name|temp
operator|->
name|argno
operator|=
name|argno
operator|++
expr_stmt|;
name|temp
operator|->
name|rest_args
operator|=
literal|0
expr_stmt|;
name|arg_ptrs
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|rest_args
condition|)
name|pedwarn
argument_list|(
literal|"another parameter follows `%s'"
argument_list|,
name|rest_extension
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|bp
index|]
condition|)
name|pedwarn
argument_list|(
literal|"invalid character in macro parameter name"
argument_list|)
expr_stmt|;
comment|/* Find the end of the arg name.  */
while|while
condition|(
name|is_idchar
index|[
operator|*
name|bp
index|]
condition|)
block|{
name|bp
operator|++
expr_stmt|;
comment|/* do we have a "special" rest-args extension here? */
if|if
condition|(
name|limit
operator|-
name|bp
operator|>
name|REST_EXTENSION_LENGTH
operator|&&
name|strncmp
argument_list|(
name|rest_extension
argument_list|,
name|bp
argument_list|,
name|REST_EXTENSION_LENGTH
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rest_args
operator|=
literal|1
expr_stmt|;
name|temp
operator|->
name|rest_args
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|temp
operator|->
name|length
operator|=
name|bp
operator|-
name|temp
operator|->
name|name
expr_stmt|;
if|if
condition|(
name|rest_args
operator|==
literal|1
condition|)
name|bp
operator|+=
name|REST_EXTENSION_LENGTH
expr_stmt|;
name|arglengths
operator|+=
name|temp
operator|->
name|length
operator|+
literal|2
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|length
operator|==
literal|0
operator|||
operator|(
operator|*
name|bp
operator|!=
literal|','
operator|&&
operator|*
name|bp
operator|!=
literal|')'
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"badly punctuated parameter list in `#define'"
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|','
condition|)
block|{
name|bp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|>=
name|limit
condition|)
block|{
name|error
argument_list|(
literal|"unterminated parameter list in `#define'"
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
block|{
name|struct
name|arglist
modifier|*
name|otemp
decl_stmt|;
for|for
control|(
name|otemp
operator|=
name|temp
operator|->
name|next
init|;
name|otemp
operator|!=
name|NULL
condition|;
name|otemp
operator|=
name|otemp
operator|->
name|next
control|)
if|if
condition|(
name|temp
operator|->
name|length
operator|==
name|otemp
operator|->
name|length
operator|&&
name|strncmp
argument_list|(
name|temp
operator|->
name|name
argument_list|,
name|otemp
operator|->
name|name
argument_list|,
name|temp
operator|->
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|name
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|temp
operator|->
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|name
argument_list|,
name|temp
operator|->
name|name
argument_list|,
name|temp
operator|->
name|length
argument_list|)
expr_stmt|;
name|name
index|[
name|temp
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
argument_list|(
literal|"duplicate argument name `%s' in `#define'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
block|}
block|}
operator|++
name|bp
expr_stmt|;
comment|/* skip paren */
comment|/* Skip spaces and tabs if any.  */
while|while
condition|(
name|bp
operator|<
name|limit
operator|&&
operator|(
operator|*
name|bp
operator|==
literal|' '
operator|||
operator|*
name|bp
operator|==
literal|'\t'
operator|)
condition|)
operator|++
name|bp
expr_stmt|;
comment|/* now everything from bp before limit is the definition. */
name|defn
operator|=
name|collect_expansion
argument_list|(
name|bp
argument_list|,
name|limit
argument_list|,
name|argno
argument_list|,
name|arg_ptrs
argument_list|)
expr_stmt|;
name|defn
operator|->
name|rest_args
operator|=
name|rest_args
expr_stmt|;
comment|/* Now set defn->args.argnames to the result of concatenating        the argument names in reverse order        with comma-space between them.  */
name|defn
operator|->
name|args
operator|.
name|argnames
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|arglengths
operator|+
literal|1
argument_list|)
expr_stmt|;
block|{
name|struct
name|arglist
modifier|*
name|temp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|arg_ptrs
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
block|{
name|bcopy
argument_list|(
name|temp
operator|->
name|name
argument_list|,
operator|&
name|defn
operator|->
name|args
operator|.
name|argnames
index|[
name|i
index|]
argument_list|,
name|temp
operator|->
name|length
argument_list|)
expr_stmt|;
name|i
operator|+=
name|temp
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|next
operator|!=
literal|0
condition|)
block|{
name|defn
operator|->
name|args
operator|.
name|argnames
index|[
name|i
operator|++
index|]
operator|=
literal|','
expr_stmt|;
name|defn
operator|->
name|args
operator|.
name|argnames
index|[
name|i
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
block|}
name|defn
operator|->
name|args
operator|.
name|argnames
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Simple expansion or empty definition.  */
if|if
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
switch|switch
condition|(
operator|*
name|bp
condition|)
block|{
case|case
literal|'\t'
case|:
case|case
literal|' '
case|:
case|case
literal|'\r'
case|:
comment|/* Skip spaces and tabs.  */
while|while
condition|(
operator|++
name|bp
operator|<
name|limit
operator|&&
operator|(
operator|*
name|bp
operator|==
literal|' '
operator|||
operator|*
name|bp
operator|==
literal|'\t'
operator|||
operator|*
name|bp
operator|==
literal|'\r'
operator|)
condition|)
continue|continue;
break|break;
case|case
literal|'!'
case|:
case|case
literal|'"'
case|:
case|case
literal|'#'
case|:
case|case
literal|'%'
case|:
case|case
literal|'&'
case|:
case|case
literal|'\''
case|:
case|case
literal|')'
case|:
case|case
literal|'*'
case|:
case|case
literal|'+'
case|:
case|case
literal|','
case|:
case|case
literal|'-'
case|:
case|case
literal|'.'
case|:
case|case
literal|'/'
case|:
case|case
literal|':'
case|:
case|case
literal|';'
case|:
case|case
literal|'<'
case|:
case|case
literal|'='
case|:
case|case
literal|'>'
case|:
case|case
literal|'?'
case|:
case|case
literal|'['
case|:
case|case
literal|'\\'
case|:
case|case
literal|']'
case|:
case|case
literal|'^'
case|:
case|case
literal|'{'
case|:
case|case
literal|'|'
case|:
case|case
literal|'}'
case|:
case|case
literal|'~'
case|:
name|warning
argument_list|(
literal|"missing white space after `#define %.*s'"
argument_list|,
name|sym_length
argument_list|,
name|symname
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pedwarn
argument_list|(
literal|"missing white space after `#define %.*s'"
argument_list|,
name|sym_length
argument_list|,
name|symname
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Now everything from bp before limit is the definition. */
name|defn
operator|=
name|collect_expansion
argument_list|(
name|bp
argument_list|,
name|limit
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
name|defn
operator|->
name|args
operator|.
name|argnames
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
literal|""
expr_stmt|;
block|}
name|defn
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|defn
operator|->
name|file
operator|=
name|file
expr_stmt|;
comment|/* OP is null if this is a predefinition */
name|defn
operator|->
name|predefined
operator|=
operator|!
name|op
expr_stmt|;
name|mdef
operator|.
name|defn
operator|=
name|defn
expr_stmt|;
name|mdef
operator|.
name|symnam
operator|=
name|symname
expr_stmt|;
name|mdef
operator|.
name|symlen
operator|=
name|sym_length
expr_stmt|;
return|return
name|mdef
return|;
name|nope
label|:
name|mdef
operator|.
name|defn
operator|=
literal|0
expr_stmt|;
return|return
name|mdef
return|;
block|}
end_block

begin_comment
comment|/* Process a #define command. BUF points to the contents of the #define command, as a contiguous string. LIMIT points to the first character past the end of the definition. KEYWORD is the keyword-table entry for #define.  */
end_comment

begin_function
specifier|static
name|int
name|do_define
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|hashcode
decl_stmt|;
name|MACRODEF
name|mdef
decl_stmt|;
comment|/* If this is a precompiler run (with -pcp) pass thru #define commands.  */
if|if
condition|(
name|pcp_outfile
operator|&&
name|op
condition|)
name|pass_thru_directive
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
name|op
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
name|mdef
operator|=
name|create_definition
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdef
operator|.
name|defn
operator|==
literal|0
condition|)
goto|goto
name|nope
goto|;
name|hashcode
operator|=
name|hashf
argument_list|(
name|mdef
operator|.
name|symnam
argument_list|,
name|mdef
operator|.
name|symlen
argument_list|,
name|HASHSIZE
argument_list|)
expr_stmt|;
block|{
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
operator|(
name|hp
operator|=
name|lookup
argument_list|(
name|mdef
operator|.
name|symnam
argument_list|,
name|mdef
operator|.
name|symlen
argument_list|,
name|hashcode
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|ok
init|=
literal|0
decl_stmt|;
comment|/* Redefining a precompiled key is ok.  */
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_PCSTRING
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
comment|/* Redefining a macro is ok if the definitions are the same.  */
elseif|else
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
condition|)
name|ok
operator|=
operator|!
name|compare_defs
argument_list|(
name|mdef
operator|.
name|defn
argument_list|,
name|hp
operator|->
name|value
operator|.
name|defn
argument_list|)
expr_stmt|;
comment|/* Redefining a constant is ok with -D.  */
elseif|else
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_CONST
condition|)
name|ok
operator|=
operator|!
name|done_initializing
expr_stmt|;
comment|/* Print the warning if it's not ok.  */
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|U_CHAR
modifier|*
name|msg
decl_stmt|;
comment|/* what pain... */
comment|/* If we are passing through #define and #undef directives, do 	   that for this re-definition now.  */
if|if
condition|(
name|debug_output
operator|&&
name|op
condition|)
name|pass_thru_directive
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
name|op
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
name|msg
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|mdef
operator|.
name|symlen
operator|+
literal|22
argument_list|)
expr_stmt|;
operator|*
name|msg
operator|=
literal|'`'
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mdef
operator|.
name|symnam
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|msg
operator|+
literal|1
operator|)
argument_list|,
name|mdef
operator|.
name|symlen
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|msg
operator|+
name|mdef
operator|.
name|symlen
operator|+
literal|1
operator|)
argument_list|,
literal|"' redefined"
argument_list|)
expr_stmt|;
name|pedwarn
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
condition|)
name|pedwarn_with_file_and_line
argument_list|(
name|hp
operator|->
name|value
operator|.
name|defn
operator|->
name|file
argument_list|,
name|hp
operator|->
name|value
operator|.
name|defn
operator|->
name|line
argument_list|,
literal|"this is the location of the previous definition"
argument_list|)
expr_stmt|;
block|}
comment|/* Replace the old definition.  */
name|hp
operator|->
name|type
operator|=
name|T_MACRO
expr_stmt|;
name|hp
operator|->
name|value
operator|.
name|defn
operator|=
name|mdef
operator|.
name|defn
expr_stmt|;
block|}
else|else
block|{
comment|/* If we are passing through #define and #undef directives, do 	 that for this new definition now.  */
if|if
condition|(
name|debug_output
operator|&&
name|op
condition|)
name|pass_thru_directive
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
name|op
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
name|install
argument_list|(
name|mdef
operator|.
name|symnam
argument_list|,
name|mdef
operator|.
name|symlen
argument_list|,
name|T_MACRO
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mdef
operator|.
name|defn
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
name|nope
label|:
return|return
literal|1
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Check a purported macro name SYMNAME, and yield its length.    USAGE is the kind of name this is intended for.  */
end_comment

begin_function
specifier|static
name|int
name|check_macro_name
parameter_list|(
name|symname
parameter_list|,
name|usage
parameter_list|)
name|U_CHAR
modifier|*
name|symname
decl_stmt|;
name|char
modifier|*
name|usage
decl_stmt|;
block|{
name|U_CHAR
modifier|*
name|p
decl_stmt|;
name|int
name|sym_length
decl_stmt|;
for|for
control|(
name|p
operator|=
name|symname
init|;
name|is_idchar
index|[
operator|*
name|p
index|]
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|sym_length
operator|=
name|p
operator|-
name|symname
expr_stmt|;
if|if
condition|(
name|sym_length
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"invalid %s name"
argument_list|,
name|usage
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|symname
index|]
condition|)
block|{
name|U_CHAR
modifier|*
name|msg
decl_stmt|;
comment|/* what pain... */
name|msg
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|sym_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|symname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
name|sym_length
argument_list|)
expr_stmt|;
name|msg
index|[
name|sym_length
index|]
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"invalid %s name `%s'"
argument_list|,
name|usage
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|symname
argument_list|,
literal|"defined"
argument_list|,
literal|7
argument_list|)
operator|&&
name|sym_length
operator|==
literal|7
condition|)
name|error
argument_list|(
literal|"invalid %s name `defined'"
argument_list|,
name|usage
argument_list|)
expr_stmt|;
block|}
return|return
name|sym_length
return|;
block|}
end_function

begin_comment
comment|/*  * return zero if two DEFINITIONs are isomorphic  */
end_comment

begin_function
specifier|static
name|int
name|compare_defs
parameter_list|(
name|d1
parameter_list|,
name|d2
parameter_list|)
name|DEFINITION
modifier|*
name|d1
decl_stmt|,
decl|*
name|d2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|struct
name|reflist
modifier|*
name|a1
decl_stmt|,
modifier|*
name|a2
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p1
init|=
name|d1
operator|->
name|expansion
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p2
init|=
name|d2
operator|->
name|expansion
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|d1
operator|->
name|nargs
operator|!=
name|d2
operator|->
name|nargs
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|d1
operator|->
name|args
operator|.
name|argnames
argument_list|,
operator|(
name|char
operator|*
operator|)
name|d2
operator|->
name|args
operator|.
name|argnames
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|a1
operator|=
name|d1
operator|->
name|pattern
operator|,
name|a2
operator|=
name|d2
operator|->
name|pattern
init|;
name|a1
operator|&&
name|a2
condition|;
name|a1
operator|=
name|a1
operator|->
name|next
operator|,
name|a2
operator|=
name|a2
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|a1
operator|->
name|nchars
operator|==
name|a2
operator|->
name|nchars
operator|&&
operator|!
name|strncmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|a1
operator|->
name|nchars
argument_list|)
operator|)
operator|||
operator|!
name|comp_def_part
argument_list|(
name|first
argument_list|,
name|p1
argument_list|,
name|a1
operator|->
name|nchars
argument_list|,
name|p2
argument_list|,
name|a2
operator|->
name|nchars
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
name|a1
operator|->
name|argno
operator|!=
name|a2
operator|->
name|argno
operator|||
name|a1
operator|->
name|stringify
operator|!=
name|a2
operator|->
name|stringify
operator|||
name|a1
operator|->
name|raw_before
operator|!=
name|a2
operator|->
name|raw_before
operator|||
name|a1
operator|->
name|raw_after
operator|!=
name|a2
operator|->
name|raw_after
condition|)
return|return
literal|1
return|;
name|first
operator|=
literal|0
expr_stmt|;
name|p1
operator|+=
name|a1
operator|->
name|nchars
expr_stmt|;
name|p2
operator|+=
name|a2
operator|->
name|nchars
expr_stmt|;
block|}
if|if
condition|(
name|a1
operator|!=
name|a2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|comp_def_part
argument_list|(
name|first
argument_list|,
name|p1
argument_list|,
name|d1
operator|->
name|length
operator|-
operator|(
name|p1
operator|-
name|d1
operator|->
name|expansion
operator|)
argument_list|,
name|p2
argument_list|,
name|d2
operator|->
name|length
operator|-
operator|(
name|p2
operator|-
name|d2
operator|->
name|expansion
operator|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Return 1 if two parts of two macro definitions are effectively different.    One of the parts starts at BEG1 and has LEN1 chars;    the other has LEN2 chars at BEG2.    Any sequence of whitespace matches any other sequence of whitespace.    FIRST means these parts are the first of a macro definition;     so ignore leading whitespace entirely.    LAST means these parts are the last of a macro definition;     so ignore trailing whitespace entirely.  */
end_comment

begin_function
specifier|static
name|int
name|comp_def_part
parameter_list|(
name|first
parameter_list|,
name|beg1
parameter_list|,
name|len1
parameter_list|,
name|beg2
parameter_list|,
name|len2
parameter_list|,
name|last
parameter_list|)
name|int
name|first
decl_stmt|;
name|U_CHAR
modifier|*
name|beg1
decl_stmt|,
decl|*
name|beg2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|len1
decl_stmt|,
name|len2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|last
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|U_CHAR
modifier|*
name|end1
init|=
name|beg1
operator|+
name|len1
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|end2
init|=
name|beg2
operator|+
name|len2
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|is_space
index|[
operator|*
name|beg1
index|]
condition|)
name|beg1
operator|++
expr_stmt|;
while|while
condition|(
name|beg2
operator|!=
name|end2
operator|&&
name|is_space
index|[
operator|*
name|beg2
index|]
condition|)
name|beg2
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|last
condition|)
block|{
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|is_space
index|[
name|end1
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|end1
operator|--
expr_stmt|;
while|while
condition|(
name|beg2
operator|!=
name|end2
operator|&&
name|is_space
index|[
name|end2
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|end2
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|beg2
operator|!=
name|end2
condition|)
block|{
if|if
condition|(
name|is_space
index|[
operator|*
name|beg1
index|]
operator|&&
name|is_space
index|[
operator|*
name|beg2
index|]
condition|)
block|{
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|is_space
index|[
operator|*
name|beg1
index|]
condition|)
name|beg1
operator|++
expr_stmt|;
while|while
condition|(
name|beg2
operator|!=
name|end2
operator|&&
name|is_space
index|[
operator|*
name|beg2
index|]
condition|)
name|beg2
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|beg1
operator|==
operator|*
name|beg2
condition|)
block|{
name|beg1
operator|++
expr_stmt|;
name|beg2
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
operator|(
name|beg1
operator|!=
name|end1
operator|)
operator|||
operator|(
name|beg2
operator|!=
name|end2
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Read a replacement list for a macro with parameters.    Build the DEFINITION structure.    Reads characters of text starting at BUF until END.    ARGLIST specifies the formal parameters to look for    in the text of the definition; NARGS is the number of args    in that list, or -1 for a macro name that wants no argument list.    MACRONAME is the macro name itself (so we can avoid recursive expansion)    and NAMELEN is its length in characters.     Note that comments and backslash-newlines have already been deleted from the argument.  */
end_comment

begin_comment
comment|/* Leading and trailing Space, Tab, etc. are converted to markers    Newline Space, Newline Tab, etc.    Newline Space makes a space in the final output    but is discarded if stringified.  (Newline Tab is similar but    makes a Tab instead.)     If there is no trailing whitespace, a Newline Space is added at the end    to prevent concatenation that would be contrary to the standard.  */
end_comment

begin_function
specifier|static
name|DEFINITION
modifier|*
name|collect_expansion
parameter_list|(
name|buf
parameter_list|,
name|end
parameter_list|,
name|nargs
parameter_list|,
name|arglist
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|end
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|nargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|arglist
modifier|*
name|arglist
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|DEFINITION
modifier|*
name|defn
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p
decl_stmt|,
modifier|*
name|limit
decl_stmt|,
modifier|*
name|lastp
decl_stmt|,
modifier|*
name|exp_p
decl_stmt|;
name|struct
name|reflist
modifier|*
name|endpat
init|=
name|NULL
decl_stmt|;
comment|/* Pointer to first nonspace after last ## seen.  */
name|U_CHAR
modifier|*
name|concat
init|=
literal|0
decl_stmt|;
comment|/* Pointer to first nonspace after last single-# seen.  */
name|U_CHAR
modifier|*
name|stringify
init|=
literal|0
decl_stmt|;
name|int
name|maxsize
decl_stmt|;
name|int
name|expected_delimiter
init|=
literal|'\0'
decl_stmt|;
comment|/* Scan thru the replacement list, ignoring comments and quoted      strings, picking up on the macro calls.  It does a linear search      thru the arg list on every potential symbol.  Profiling might say      that something smarter should happen. */
if|if
condition|(
name|end
operator|<
name|buf
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Find the beginning of the trailing whitespace.  */
comment|/* Find end of leading whitespace.  */
name|limit
operator|=
name|end
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|limit
operator|&&
name|is_space
index|[
name|limit
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|limit
operator|--
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|limit
operator|&&
name|is_space
index|[
operator|*
name|p
index|]
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Allocate space for the text in the macro definition.      Leading and trailing whitespace chars need 2 bytes each.      Each other input char may or may not need 1 byte,      so this is an upper bound.      The extra 2 are for invented trailing newline-marker and final null.  */
name|maxsize
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|DEFINITION
argument_list|)
operator|+
literal|2
operator|*
operator|(
name|end
operator|-
name|limit
operator|)
operator|+
literal|2
operator|*
operator|(
name|p
operator|-
name|buf
operator|)
operator|+
operator|(
name|limit
operator|-
name|p
operator|)
operator|+
literal|3
operator|)
expr_stmt|;
name|defn
operator|=
operator|(
name|DEFINITION
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|maxsize
argument_list|)
expr_stmt|;
name|defn
operator|->
name|nargs
operator|=
name|nargs
expr_stmt|;
name|exp_p
operator|=
name|defn
operator|->
name|expansion
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|defn
operator|+
sizeof|sizeof
argument_list|(
name|DEFINITION
argument_list|)
expr_stmt|;
name|lastp
operator|=
name|exp_p
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
comment|/* Convert leading whitespace to Newline-markers.  */
while|while
condition|(
name|p
operator|<
name|limit
operator|&&
name|is_space
index|[
operator|*
name|p
index|]
condition|)
block|{
operator|*
name|exp_p
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|limit
operator|-
name|p
operator|>=
literal|2
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'#'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'#'
condition|)
block|{
name|error
argument_list|(
literal|"`##' at start of macro definition"
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Process the main body of the definition.  */
while|while
condition|(
name|p
operator|<
name|limit
condition|)
block|{
name|int
name|skipped_arg
init|=
literal|0
decl_stmt|;
specifier|register
name|U_CHAR
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
operator|*
name|exp_p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
if|if
condition|(
name|expected_delimiter
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|expected_delimiter
condition|)
name|expected_delimiter
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|expected_delimiter
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
name|p
operator|<
name|limit
operator|&&
name|expected_delimiter
condition|)
block|{
comment|/* In a string, backslash goes through 	     and makes next char ordinary.  */
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'#'
case|:
comment|/* # is ordinary inside a string.  */
if|if
condition|(
name|expected_delimiter
condition|)
break|break;
if|if
condition|(
name|p
operator|<
name|limit
operator|&&
operator|*
name|p
operator|==
literal|'#'
condition|)
block|{
comment|/* ##: concatenate preceding and following tokens.  */
comment|/* Take out the first #, discard preceding whitespace.  */
name|exp_p
operator|--
expr_stmt|;
while|while
condition|(
name|exp_p
operator|>
name|lastp
operator|&&
name|is_hor_space
index|[
name|exp_p
index|[
operator|-
literal|1
index|]
index|]
condition|)
operator|--
name|exp_p
expr_stmt|;
comment|/* Skip the second #.  */
name|p
operator|++
expr_stmt|;
comment|/* Discard following whitespace.  */
name|SKIP_WHITE_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|concat
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|limit
condition|)
name|error
argument_list|(
literal|"`##' at end of macro definition"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nargs
operator|>=
literal|0
condition|)
block|{
comment|/* Single #: stringify following argument ref. 	     Don't leave the # in the expansion.  */
name|exp_p
operator|--
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|limit
operator|||
operator|!
name|is_idstart
index|[
operator|*
name|p
index|]
condition|)
name|error
argument_list|(
literal|"`#' operator is not followed by a macro argument name"
argument_list|)
expr_stmt|;
else|else
name|stringify
operator|=
name|p
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
block|{
comment|/* In -traditional mode, recognize arguments inside strings and 	 and character constants, and ignore special properties of #. 	 Arguments inside strings are considered "stringified", but no 	 extra quote marks are supplied.  */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
if|if
condition|(
name|expected_delimiter
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|expected_delimiter
condition|)
name|expected_delimiter
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|expected_delimiter
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* Backslash quotes delimiters and itself, but not macro args.  */
if|if
condition|(
name|expected_delimiter
operator|!=
literal|0
operator|&&
name|p
operator|<
name|limit
operator|&&
operator|(
operator|*
name|p
operator|==
name|expected_delimiter
operator|||
operator|*
name|p
operator|==
literal|'\\'
operator|)
condition|)
block|{
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|expected_delimiter
operator|!=
literal|'\0'
condition|)
comment|/* No comments inside strings.  */
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
block|{
comment|/* If we find a comment that wasn't removed by handle_directive, 	     this must be -traditional.  So replace the comment with 	     nothing at all.  */
name|exp_p
operator|--
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|limit
operator|&&
operator|!
operator|(
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'*'
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Mark this as a concatenation-point, as if it had been ##.  */
block|concat = p;
endif|#
directive|endif
block|}
break|break;
block|}
block|}
comment|/* Handle the start of a symbol.  */
if|if
condition|(
name|is_idchar
index|[
name|c
index|]
operator|&&
name|nargs
operator|>
literal|0
condition|)
block|{
name|U_CHAR
modifier|*
name|id_beg
init|=
name|p
operator|-
literal|1
decl_stmt|;
name|int
name|id_len
decl_stmt|;
operator|--
name|exp_p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|limit
operator|&&
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
name|p
operator|++
expr_stmt|;
name|id_len
operator|=
name|p
operator|-
name|id_beg
expr_stmt|;
if|if
condition|(
name|is_idstart
index|[
name|c
index|]
condition|)
block|{
specifier|register
name|struct
name|arglist
modifier|*
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|arglist
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|next
control|)
block|{
name|struct
name|reflist
modifier|*
name|tpat
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|c
operator|&&
name|arg
operator|->
name|length
operator|==
name|id_len
operator|&&
name|strncmp
argument_list|(
name|arg
operator|->
name|name
argument_list|,
name|id_beg
argument_list|,
name|id_len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|expected_delimiter
operator|&&
name|warn_stringify
condition|)
block|{
if|if
condition|(
name|traditional
condition|)
block|{
name|warning
argument_list|(
literal|"macro argument `%.*s' is stringified."
argument_list|,
name|id_len
argument_list|,
name|arg
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"macro arg `%.*s' would be stringified with -traditional."
argument_list|,
name|id_len
argument_list|,
name|arg
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If ANSI, don't actually substitute inside a string.  */
if|if
condition|(
operator|!
name|traditional
operator|&&
name|expected_delimiter
condition|)
break|break;
comment|/* make a pat node for this arg and append it to the end of 	       the pat list */
name|tpat
operator|=
operator|(
expr|struct
name|reflist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|reflist
argument_list|)
argument_list|)
expr_stmt|;
name|tpat
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|tpat
operator|->
name|raw_before
operator|=
name|concat
operator|==
name|id_beg
expr_stmt|;
name|tpat
operator|->
name|raw_after
operator|=
literal|0
expr_stmt|;
name|tpat
operator|->
name|rest_args
operator|=
name|arg
operator|->
name|rest_args
expr_stmt|;
name|tpat
operator|->
name|stringify
operator|=
operator|(
name|traditional
condition|?
name|expected_delimiter
operator|!=
literal|'\0'
else|:
name|stringify
operator|==
name|id_beg
operator|)
expr_stmt|;
if|if
condition|(
name|endpat
operator|==
name|NULL
condition|)
name|defn
operator|->
name|pattern
operator|=
name|tpat
expr_stmt|;
else|else
name|endpat
operator|->
name|next
operator|=
name|tpat
expr_stmt|;
name|endpat
operator|=
name|tpat
expr_stmt|;
name|tpat
operator|->
name|argno
operator|=
name|arg
operator|->
name|argno
expr_stmt|;
name|tpat
operator|->
name|nchars
operator|=
name|exp_p
operator|-
name|lastp
expr_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|p1
init|=
name|p
decl_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|+
literal|2
operator|<=
name|limit
operator|&&
name|p1
index|[
literal|0
index|]
operator|==
literal|'#'
operator|&&
name|p1
index|[
literal|1
index|]
operator|==
literal|'#'
condition|)
name|tpat
operator|->
name|raw_after
operator|=
literal|1
expr_stmt|;
block|}
name|lastp
operator|=
name|exp_p
expr_stmt|;
comment|/* place to start copying from next time */
name|skipped_arg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If this was not a macro arg, copy it into the expansion.  */
if|if
condition|(
operator|!
name|skipped_arg
condition|)
block|{
specifier|register
name|U_CHAR
modifier|*
name|lim1
init|=
name|p
decl_stmt|;
name|p
operator|=
name|id_beg
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|lim1
condition|)
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|stringify
operator|==
name|id_beg
condition|)
name|error
argument_list|(
literal|"`#' operator should be followed by a macro argument name"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|traditional
operator|&&
name|expected_delimiter
operator|==
literal|0
condition|)
block|{
comment|/* There is no trailing whitespace, so invent some in ANSI mode.        But not if "inside a string" (which in ANSI mode        happens only for -D option).  */
operator|*
name|exp_p
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|exp_p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
operator|*
name|exp_p
operator|=
literal|'\0'
expr_stmt|;
name|defn
operator|->
name|length
operator|=
name|exp_p
operator|-
name|defn
operator|->
name|expansion
expr_stmt|;
comment|/* Crash now if we overrun the allocated size.  */
if|if
condition|(
name|defn
operator|->
name|length
operator|+
literal|1
operator|>
name|maxsize
condition|)
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This isn't worth the time it takes.  */
comment|/* give back excess storage */
block|defn->expansion = (U_CHAR *) xrealloc (defn->expansion, defn->length + 1);
endif|#
directive|endif
return|return
name|defn
return|;
block|}
end_block

begin_escape
end_escape

begin_function
specifier|static
name|int
name|do_assert
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
comment|/* temp ptr into input buffer */
name|U_CHAR
modifier|*
name|symname
decl_stmt|;
comment|/* remember where symbol name starts */
name|int
name|sym_length
decl_stmt|;
comment|/* and how long it is */
name|struct
name|arglist
modifier|*
name|tokens
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|done_initializing
operator|&&
operator|!
name|instack
index|[
name|indepth
index|]
operator|.
name|system_header_p
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C does not allow `#assert'"
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
name|symname
operator|=
name|bp
expr_stmt|;
comment|/* remember where it starts */
name|sym_length
operator|=
name|check_macro_name
argument_list|(
name|bp
argument_list|,
literal|"assertion"
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|sym_length
expr_stmt|;
comment|/* #define doesn't do this, but we should.  */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* Lossage will occur if identifiers or control tokens are broken      across lines using backslash.  This is not the right place to take      care of that. */
if|if
condition|(
operator|*
name|bp
operator|!=
literal|'('
condition|)
block|{
name|error
argument_list|(
literal|"missing token-sequence in `#assert'"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|{
name|int
name|error_flag
init|=
literal|0
decl_stmt|;
name|bp
operator|++
expr_stmt|;
comment|/* skip '(' */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|tokens
operator|=
name|read_token_list
argument_list|(
operator|&
name|bp
argument_list|,
name|limit
argument_list|,
operator|&
name|error_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_flag
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|tokens
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"empty token-sequence in `#assert'"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|++
name|bp
expr_stmt|;
comment|/* skip paren */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* If this name isn't already an assertion name, make it one.      Error if it was already in use in some other way.  */
block|{
name|ASSERTION_HASHNODE
modifier|*
name|hp
decl_stmt|;
name|int
name|hashcode
init|=
name|hashf
argument_list|(
name|symname
argument_list|,
name|sym_length
argument_list|,
name|ASSERTION_HASHSIZE
argument_list|)
decl_stmt|;
name|struct
name|tokenlist_list
modifier|*
name|value
init|=
operator|(
expr|struct
name|tokenlist_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tokenlist_list
argument_list|)
argument_list|)
decl_stmt|;
name|hp
operator|=
name|assertion_lookup
argument_list|(
name|symname
argument_list|,
name|sym_length
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sym_length
operator|==
literal|7
operator|&&
operator|!
name|strncmp
argument_list|(
name|symname
argument_list|,
literal|"defined"
argument_list|,
name|sym_length
argument_list|)
condition|)
name|error
argument_list|(
literal|"`defined' redefined as assertion"
argument_list|)
expr_stmt|;
name|hp
operator|=
name|assertion_install
argument_list|(
name|symname
argument_list|,
name|sym_length
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
block|}
comment|/* Add the spec'd token-sequence to the list of such.  */
name|value
operator|->
name|tokens
operator|=
name|tokens
expr_stmt|;
name|value
operator|->
name|next
operator|=
name|hp
operator|->
name|value
expr_stmt|;
name|hp
operator|->
name|value
operator|=
name|value
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_function
specifier|static
name|int
name|do_unassert
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
comment|/* temp ptr into input buffer */
name|U_CHAR
modifier|*
name|symname
decl_stmt|;
comment|/* remember where symbol name starts */
name|int
name|sym_length
decl_stmt|;
comment|/* and how long it is */
name|struct
name|arglist
modifier|*
name|tokens
init|=
name|NULL
decl_stmt|;
name|int
name|tokens_specified
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|done_initializing
operator|&&
operator|!
name|instack
index|[
name|indepth
index|]
operator|.
name|system_header_p
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C does not allow `#unassert'"
argument_list|)
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
name|symname
operator|=
name|bp
expr_stmt|;
comment|/* remember where it starts */
name|sym_length
operator|=
name|check_macro_name
argument_list|(
name|bp
argument_list|,
literal|"assertion"
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|sym_length
expr_stmt|;
comment|/* #define doesn't do this, but we should.  */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* Lossage will occur if identifiers or control tokens are broken      across lines using backslash.  This is not the right place to take      care of that. */
if|if
condition|(
operator|*
name|bp
operator|==
literal|'('
condition|)
block|{
name|int
name|error_flag
init|=
literal|0
decl_stmt|;
name|bp
operator|++
expr_stmt|;
comment|/* skip '(' */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|tokens
operator|=
name|read_token_list
argument_list|(
operator|&
name|bp
argument_list|,
name|limit
argument_list|,
operator|&
name|error_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_flag
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|tokens
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"empty token list in `#unassert'"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|tokens_specified
operator|=
literal|1
expr_stmt|;
operator|++
name|bp
expr_stmt|;
comment|/* skip paren */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|{
name|ASSERTION_HASHNODE
modifier|*
name|hp
decl_stmt|;
name|int
name|hashcode
init|=
name|hashf
argument_list|(
name|symname
argument_list|,
name|sym_length
argument_list|,
name|ASSERTION_HASHSIZE
argument_list|)
decl_stmt|;
name|struct
name|tokenlist_list
modifier|*
name|tail
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|hp
operator|=
name|assertion_lookup
argument_list|(
name|symname
argument_list|,
name|sym_length
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* If no token list was specified, then eliminate this assertion        entirely.  */
if|if
condition|(
operator|!
name|tokens_specified
condition|)
block|{
name|struct
name|tokenlist_list
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|tail
operator|=
name|hp
operator|->
name|value
init|;
name|tail
condition|;
name|tail
operator|=
name|next
control|)
block|{
name|next
operator|=
name|tail
operator|->
name|next
expr_stmt|;
name|free_token_list
argument_list|(
name|tail
operator|->
name|tokens
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
name|delete_assertion
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If a list of tokens was given, then delete any matching list.  */
name|tail
operator|=
name|hp
operator|->
name|value
expr_stmt|;
name|prev
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tail
condition|)
block|{
name|struct
name|tokenlist_list
modifier|*
name|next
init|=
name|tail
operator|->
name|next
decl_stmt|;
if|if
condition|(
name|compare_token_lists
argument_list|(
name|tail
operator|->
name|tokens
argument_list|,
name|tokens
argument_list|)
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|next
expr_stmt|;
else|else
name|hp
operator|->
name|value
operator|=
name|tail
operator|->
name|next
expr_stmt|;
name|free_token_list
argument_list|(
name|tail
operator|->
name|tokens
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tail
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|tail
expr_stmt|;
block|}
name|tail
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Test whether there is an assertion named NAME    and optionally whether it has an asserted token list TOKENS.    NAME is not null terminated; its length is SYM_LENGTH.    If TOKENS_SPECIFIED is 0, then don't check for any token list.  */
end_comment

begin_function
name|int
name|check_assertion
parameter_list|(
name|name
parameter_list|,
name|sym_length
parameter_list|,
name|tokens_specified
parameter_list|,
name|tokens
parameter_list|)
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|sym_length
decl_stmt|;
name|int
name|tokens_specified
decl_stmt|;
name|struct
name|arglist
modifier|*
name|tokens
decl_stmt|;
block|{
name|ASSERTION_HASHNODE
modifier|*
name|hp
decl_stmt|;
name|int
name|hashcode
init|=
name|hashf
argument_list|(
name|name
argument_list|,
name|sym_length
argument_list|,
name|ASSERTION_HASHSIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|instack
index|[
name|indepth
index|]
operator|.
name|system_header_p
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C does not allow testing assertions"
argument_list|)
expr_stmt|;
name|hp
operator|=
name|assertion_lookup
argument_list|(
name|name
argument_list|,
name|sym_length
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
comment|/* It is not an assertion; just return false.  */
return|return
literal|0
return|;
comment|/* If no token list was specified, then value is 1.  */
if|if
condition|(
operator|!
name|tokens_specified
condition|)
return|return
literal|1
return|;
block|{
name|struct
name|tokenlist_list
modifier|*
name|tail
decl_stmt|;
name|tail
operator|=
name|hp
operator|->
name|value
expr_stmt|;
comment|/* If a list of tokens was given,        then succeed if the assertion records a matching list.  */
while|while
condition|(
name|tail
condition|)
block|{
if|if
condition|(
name|compare_token_lists
argument_list|(
name|tail
operator|->
name|tokens
argument_list|,
name|tokens
argument_list|)
condition|)
return|return
literal|1
return|;
name|tail
operator|=
name|tail
operator|->
name|next
expr_stmt|;
block|}
comment|/* Fail if the assertion has no matching list.  */
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Compare two lists of tokens for equality including order of tokens.  */
end_comment

begin_function
specifier|static
name|int
name|compare_token_lists
parameter_list|(
name|l1
parameter_list|,
name|l2
parameter_list|)
name|struct
name|arglist
modifier|*
name|l1
decl_stmt|,
decl|*
name|l2
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
name|l1
operator|&&
name|l2
condition|)
block|{
if|if
condition|(
name|l1
operator|->
name|length
operator|!=
name|l2
operator|->
name|length
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|l1
operator|->
name|name
argument_list|,
name|l2
operator|->
name|name
argument_list|,
name|l1
operator|->
name|length
argument_list|)
condition|)
return|return
literal|0
return|;
name|l1
operator|=
name|l1
operator|->
name|next
expr_stmt|;
name|l2
operator|=
name|l2
operator|->
name|next
expr_stmt|;
block|}
comment|/* Succeed if both lists end at the same time.  */
return|return
name|l1
operator|==
name|l2
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Read a space-separated list of tokens ending in a close parenthesis.    Return a list of strings, in the order they were written.    (In case of error, return 0 and store -1 in *ERROR_FLAG.)    Parse the text starting at *BPP, and update *BPP.    Don't parse beyond LIMIT.  */
end_comment

begin_function
specifier|static
name|struct
name|arglist
modifier|*
name|read_token_list
parameter_list|(
name|bpp
parameter_list|,
name|limit
parameter_list|,
name|error_flag
parameter_list|)
name|U_CHAR
modifier|*
modifier|*
name|bpp
decl_stmt|;
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
name|int
modifier|*
name|error_flag
decl_stmt|;
block|{
name|struct
name|arglist
modifier|*
name|token_ptrs
init|=
literal|0
decl_stmt|;
name|U_CHAR
modifier|*
name|bp
init|=
operator|*
name|bpp
decl_stmt|;
name|int
name|depth
init|=
literal|1
decl_stmt|;
operator|*
name|error_flag
operator|=
literal|0
expr_stmt|;
comment|/* Loop over the assertion value tokens.  */
while|while
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
name|struct
name|arglist
modifier|*
name|temp
decl_stmt|;
name|int
name|eofp
init|=
literal|0
decl_stmt|;
name|U_CHAR
modifier|*
name|beg
init|=
name|bp
decl_stmt|;
comment|/* Find the end of the token.  */
if|if
condition|(
operator|*
name|bp
operator|==
literal|'('
condition|)
block|{
name|bp
operator|++
expr_stmt|;
name|depth
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|')'
condition|)
block|{
name|depth
operator|--
expr_stmt|;
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
break|break;
name|bp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'"'
operator|||
operator|*
name|bp
operator|==
literal|'\''
condition|)
name|bp
operator|=
name|skip_quoted_string
argument_list|(
name|bp
argument_list|,
name|limit
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
operator|&
name|eofp
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
operator|!
name|is_hor_space
index|[
operator|*
name|bp
index|]
operator|&&
operator|*
name|bp
operator|!=
literal|'('
operator|&&
operator|*
name|bp
operator|!=
literal|')'
operator|&&
operator|*
name|bp
operator|!=
literal|'"'
operator|&&
operator|*
name|bp
operator|!=
literal|'\''
operator|&&
name|bp
operator|!=
name|limit
condition|)
name|bp
operator|++
expr_stmt|;
name|temp
operator|=
operator|(
expr|struct
name|arglist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|name
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|bp
operator|-
name|beg
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|beg
argument_list|,
operator|(
name|char
operator|*
operator|)
name|temp
operator|->
name|name
argument_list|,
name|bp
operator|-
name|beg
argument_list|)
expr_stmt|;
name|temp
operator|->
name|name
index|[
name|bp
operator|-
name|beg
index|]
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|token_ptrs
expr_stmt|;
name|token_ptrs
operator|=
name|temp
expr_stmt|;
name|temp
operator|->
name|length
operator|=
name|bp
operator|-
name|beg
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|>=
name|limit
condition|)
block|{
name|error
argument_list|(
literal|"unterminated token sequence in `#assert' or `#unassert'"
argument_list|)
expr_stmt|;
operator|*
name|error_flag
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
comment|/* We accumulated the names in reverse order.      Now reverse them to get the proper order.  */
block|{
specifier|register
name|struct
name|arglist
modifier|*
name|prev
init|=
literal|0
decl_stmt|,
modifier|*
name|this
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|this
operator|=
name|token_ptrs
init|;
name|this
condition|;
name|this
operator|=
name|next
control|)
block|{
name|next
operator|=
name|this
operator|->
name|next
expr_stmt|;
name|this
operator|->
name|next
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|this
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|free_token_list
parameter_list|(
name|tokens
parameter_list|)
name|struct
name|arglist
modifier|*
name|tokens
decl_stmt|;
block|{
while|while
condition|(
name|tokens
condition|)
block|{
name|struct
name|arglist
modifier|*
name|next
init|=
name|tokens
operator|->
name|next
decl_stmt|;
name|free
argument_list|(
name|tokens
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tokens
argument_list|)
expr_stmt|;
name|tokens
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Install a name in the assertion hash table.  *  * If LEN is>= 0, it is the length of the name.  * Otherwise, compute the length by scanning the entire name.  *  * If HASH is>= 0, it is the precomputed hash code.  * Otherwise, compute the hash code.  */
end_comment

begin_function
specifier|static
name|ASSERTION_HASHNODE
modifier|*
name|assertion_install
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|hash
parameter_list|)
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|hash
decl_stmt|;
block|{
specifier|register
name|ASSERTION_HASHNODE
modifier|*
name|hp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|bucket
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|i
operator|=
sizeof|sizeof
argument_list|(
name|ASSERTION_HASHNODE
argument_list|)
operator|+
name|len
operator|+
literal|1
expr_stmt|;
name|hp
operator|=
operator|(
name|ASSERTION_HASHNODE
operator|*
operator|)
name|xmalloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|hash
expr_stmt|;
name|hp
operator|->
name|bucket_hdr
operator|=
operator|&
name|assertion_hashtab
index|[
name|bucket
index|]
expr_stmt|;
name|hp
operator|->
name|next
operator|=
name|assertion_hashtab
index|[
name|bucket
index|]
expr_stmt|;
name|assertion_hashtab
index|[
name|bucket
index|]
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|next
operator|->
name|prev
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|length
operator|=
name|len
expr_stmt|;
name|hp
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|name
operator|=
operator|(
operator|(
name|U_CHAR
operator|*
operator|)
name|hp
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|ASSERTION_HASHNODE
argument_list|)
expr_stmt|;
name|p
operator|=
name|hp
operator|->
name|name
expr_stmt|;
name|q
operator|=
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
name|hp
operator|->
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|hp
return|;
block|}
end_function

begin_comment
comment|/*  * find the most recent hash node for name name (ending with first  * non-identifier char) installed by install  *  * If LEN is>= 0, it is the length of the name.  * Otherwise, compute the length by scanning the entire name.  *  * If HASH is>= 0, it is the precomputed hash code.  * Otherwise, compute the hash code.  */
end_comment

begin_function
specifier|static
name|ASSERTION_HASHNODE
modifier|*
name|assertion_lookup
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|hash
parameter_list|)
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|hash
decl_stmt|;
block|{
specifier|register
name|ASSERTION_HASHNODE
modifier|*
name|bucket
decl_stmt|;
name|bucket
operator|=
name|assertion_hashtab
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|bucket
condition|)
block|{
if|if
condition|(
name|bucket
operator|->
name|length
operator|==
name|len
operator|&&
name|strncmp
argument_list|(
name|bucket
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|bucket
return|;
name|bucket
operator|=
name|bucket
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_assertion
parameter_list|(
name|hp
parameter_list|)
name|ASSERTION_HASHNODE
modifier|*
name|hp
decl_stmt|;
block|{
if|if
condition|(
name|hp
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|prev
operator|->
name|next
operator|=
name|hp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|next
operator|->
name|prev
operator|=
name|hp
operator|->
name|prev
expr_stmt|;
comment|/* make sure that the bucket chain header that      the deleted guy was on points to the right thing afterwards. */
if|if
condition|(
name|hp
operator|==
operator|*
name|hp
operator|->
name|bucket_hdr
condition|)
operator|*
name|hp
operator|->
name|bucket_hdr
operator|=
name|hp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * interpret #line command.  Remembers previously seen fnames  * in its very own hash table.  */
end_comment

begin_define
define|#
directive|define
name|FNAME_HASHSIZE
value|37
end_define

begin_function
specifier|static
name|int
name|do_line
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
name|FILE_BUF
name|tem
decl_stmt|;
name|int
name|new_lineno
decl_stmt|;
name|enum
name|file_change_code
name|file_change
init|=
name|same_file
decl_stmt|;
comment|/* Expand any macros.  */
name|tem
operator|=
name|expand_to_temp_buffer
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Point to macroexpanded line, which is null-terminated now.  */
name|bp
operator|=
name|tem
operator|.
name|buf
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid format `#line' command"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* The Newline at the end of this line remains to be processed.      To put the next line at the specified line number,      we must store a line number now that is one less.  */
name|new_lineno
operator|=
name|atoi
argument_list|(
name|bp
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* NEW_LINENO is one less than the actual line number here.  */
if|if
condition|(
name|pedantic
operator|&&
name|new_lineno
operator|<
literal|0
condition|)
name|pedwarn
argument_list|(
literal|"line number out of range in `#line' command"
argument_list|)
expr_stmt|;
comment|/* skip over the line number.  */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
name|bp
operator|++
expr_stmt|;
if|#
directive|if
literal|0
comment|/* #line 10"foo.c" is supposed to be allowed.  */
block|if (*bp&& !is_space[*bp]) {     error ("invalid format `#line' command");     return;   }
endif|#
directive|endif
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\"'
condition|)
block|{
specifier|static
name|HASHNODE
modifier|*
name|fname_table
index|[
name|FNAME_HASHSIZE
index|]
decl_stmt|;
name|HASHNODE
modifier|*
name|hp
decl_stmt|,
modifier|*
modifier|*
name|hash_bucket
decl_stmt|;
name|U_CHAR
modifier|*
name|fname
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|fname_length
decl_stmt|;
name|fname
operator|=
operator|++
name|bp
expr_stmt|;
comment|/* Turn the file name, which is a character string literal,        into a null-terminated string.  Do this in place.  */
name|p
operator|=
name|bp
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
operator|*
name|bp
operator|++
operator|)
condition|)
block|{
case|case
literal|'\0'
case|:
name|error
argument_list|(
literal|"invalid format `#line' command"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'\\'
case|:
block|{
name|char
modifier|*
name|bpc
init|=
operator|(
name|char
operator|*
operator|)
name|bp
decl_stmt|;
name|int
name|c
init|=
name|parse_escape
argument_list|(
operator|&
name|bpc
argument_list|)
decl_stmt|;
name|bp
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|bpc
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|p
operator|--
expr_stmt|;
else|else
name|p
index|[
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
block|}
break|break;
case|case
literal|'\"'
case|:
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
goto|goto
name|fname_done
goto|;
block|}
name|fname_done
label|:
name|fname_length
operator|=
name|p
operator|-
name|fname
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"garbage at end of `#line' command"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'1'
condition|)
name|file_change
operator|=
name|enter_file
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'2'
condition|)
name|file_change
operator|=
name|leave_file
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'3'
condition|)
name|ip
operator|->
name|system_header_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'4'
condition|)
name|ip
operator|->
name|system_header_p
operator|=
literal|2
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"invalid format `#line' command"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'3'
condition|)
block|{
name|ip
operator|->
name|system_header_p
operator|=
literal|1
expr_stmt|;
name|bp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|'4'
condition|)
block|{
name|ip
operator|->
name|system_header_p
operator|=
literal|2
expr_stmt|;
name|bp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|bp
condition|)
block|{
name|error
argument_list|(
literal|"invalid format `#line' command"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|hash_bucket
operator|=
operator|&
name|fname_table
index|[
name|hashf
argument_list|(
name|fname
argument_list|,
name|fname_length
argument_list|,
name|FNAME_HASHSIZE
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|hp
operator|=
operator|*
name|hash_bucket
init|;
name|hp
operator|!=
name|NULL
condition|;
name|hp
operator|=
name|hp
operator|->
name|next
control|)
if|if
condition|(
name|hp
operator|->
name|length
operator|==
name|fname_length
operator|&&
name|strncmp
argument_list|(
name|hp
operator|->
name|value
operator|.
name|cpval
argument_list|,
name|fname
argument_list|,
name|fname_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ip
operator|->
name|nominal_fname
operator|=
name|hp
operator|->
name|value
operator|.
name|cpval
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|hp
operator|==
literal|0
condition|)
block|{
comment|/* Didn't find it; cons up a new one.  */
name|hp
operator|=
operator|(
name|HASHNODE
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
operator|+
name|fname_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|hp
operator|->
name|next
operator|=
operator|*
name|hash_bucket
expr_stmt|;
operator|*
name|hash_bucket
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|length
operator|=
name|fname_length
expr_stmt|;
name|ip
operator|->
name|nominal_fname
operator|=
name|hp
operator|->
name|value
operator|.
name|cpval
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|hp
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fname
argument_list|,
name|hp
operator|->
name|value
operator|.
name|cpval
argument_list|,
name|fname_length
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|bp
condition|)
block|{
name|error
argument_list|(
literal|"invalid format `#line' command"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ip
operator|->
name|lineno
operator|=
name|new_lineno
expr_stmt|;
name|output_line_command
argument_list|(
name|ip
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|file_change
argument_list|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|ip
operator|->
name|length
operator|-
operator|(
name|ip
operator|->
name|bufp
operator|-
name|ip
operator|->
name|buf
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * remove the definition of a symbol from the symbol table.  * according to un*x /lib/cpp, it is not an error to undef  * something that has no definitions, so it isn't one here either.  */
end_comment

begin_function
specifier|static
name|int
name|do_undef
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|sym_length
decl_stmt|;
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|U_CHAR
modifier|*
name|orig_buf
init|=
name|buf
decl_stmt|;
comment|/* If this is a precompiler run (with -pcp) pass thru #undef commands.  */
if|if
condition|(
name|pcp_outfile
operator|&&
name|op
condition|)
name|pass_thru_directive
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
name|op
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sym_length
operator|=
name|check_macro_name
argument_list|(
name|buf
argument_list|,
literal|"macro"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|hp
operator|=
name|lookup
argument_list|(
name|buf
argument_list|,
name|sym_length
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* If we are generating additional info for debugging (with -g) we        need to pass through all effective #undef commands.  */
if|if
condition|(
name|debug_output
operator|&&
name|op
condition|)
name|pass_thru_directive
argument_list|(
name|orig_buf
argument_list|,
name|limit
argument_list|,
name|op
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|!=
name|T_MACRO
condition|)
name|warning
argument_list|(
literal|"undefining `%s'"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
name|delete_macro
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pedantic
condition|)
block|{
name|buf
operator|+=
name|sym_length
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|limit
condition|)
name|pedwarn
argument_list|(
literal|"garbage after `#undef' directive"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Report an error detected by the program we are processing.  * Use the text of the line in the error message.  * (We use error because it prints the filename& line#.)  */
end_comment

begin_function
specifier|static
name|int
name|do_error
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|length
init|=
name|limit
operator|-
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|copy
init|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|copy
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|copy
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"#error %s"
argument_list|,
name|copy
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Report a warning detected by the program we are processing.  * Use the text of the line in the warning message, then continue.  * (We use error because it prints the filename& line#.)  */
end_comment

begin_function
specifier|static
name|int
name|do_warning
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|length
init|=
name|limit
operator|-
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|copy
init|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|copy
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|copy
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"#warning %s"
argument_list|,
name|copy
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Remember the name of the current file being read from so that we can    avoid ever including it again.  */
end_comment

begin_function
specifier|static
name|int
name|do_once
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|dont_repeat_files
expr_stmt|;
name|dont_repeat_files
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|fname
operator|=
name|savestring
argument_list|(
name|ip
operator|->
name|fname
argument_list|)
expr_stmt|;
name|new
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|got_name_map
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|c_system_include_path
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* #ident has already been copied to the output file, so just ignore it.  */
end_comment

begin_function
specifier|static
name|int
name|do_ident
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_block
block|{
name|FILE_BUF
name|trybuf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
init|=
operator|&
name|outbuf
decl_stmt|;
comment|/* Allow #ident in system headers, since that's not user's fault.  */
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|instack
index|[
name|indepth
index|]
operator|.
name|system_header_p
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C does not allow `#ident'"
argument_list|)
expr_stmt|;
name|trybuf
operator|=
name|expand_to_temp_buffer
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|trybuf
operator|.
name|bufp
operator|-
name|trybuf
operator|.
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|trybuf
operator|.
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|trybuf
operator|.
name|bufp
operator|-
name|trybuf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|limit
operator|=
name|buf
operator|+
operator|(
name|trybuf
operator|.
name|bufp
operator|-
name|trybuf
operator|.
name|buf
operator|)
expr_stmt|;
name|len
operator|=
operator|(
name|limit
operator|-
name|buf
operator|)
expr_stmt|;
name|free
argument_list|(
name|trybuf
operator|.
name|buf
argument_list|)
expr_stmt|;
comment|/* Output directive name.  */
name|check_expand
argument_list|(
name|op
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
literal|"#ident "
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
literal|7
expr_stmt|;
comment|/* Output the expanded argument line.  */
name|check_expand
argument_list|(
name|op
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* #pragma and its argument line have already been copied to the output file.    Just check for some recognized pragmas that need validation here.  */
end_comment

begin_function
specifier|static
name|int
name|do_pragma
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_block
block|{
while|while
condition|(
operator|*
name|buf
operator|==
literal|' '
operator|||
operator|*
name|buf
operator|==
literal|'\t'
condition|)
name|buf
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"once"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
comment|/* Allow #pragma once in system headers, since that's not the user's        fault.  */
if|if
condition|(
operator|!
name|instack
index|[
name|indepth
index|]
operator|.
name|system_header_p
condition|)
name|warning
argument_list|(
literal|"`#pragma once' is obsolete"
argument_list|)
expr_stmt|;
name|do_once
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"implementation"
argument_list|,
literal|14
argument_list|)
condition|)
block|{
comment|/* Be quiet about `#pragma implementation' for a file only if it hasn't        been included yet.  */
name|struct
name|file_name_list
modifier|*
name|ptr
decl_stmt|;
name|U_CHAR
modifier|*
name|p
init|=
name|buf
operator|+
literal|14
decl_stmt|,
modifier|*
name|fname
decl_stmt|,
modifier|*
name|inc_fname
decl_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|!=
literal|'\"'
condition|)
return|return
literal|0
return|;
name|fname
operator|=
name|p
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|index
argument_list|(
name|fname
argument_list|,
literal|'\"'
argument_list|)
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|all_include_files
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
name|inc_fname
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|rindex
argument_list|(
name|ptr
operator|->
name|fname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|inc_fname
operator|=
name|inc_fname
condition|?
name|inc_fname
operator|+
literal|1
else|:
operator|(
name|U_CHAR
operator|*
operator|)
name|ptr
operator|->
name|fname
expr_stmt|;
if|if
condition|(
name|inc_fname
operator|&&
operator|!
name|strcmp
argument_list|(
name|inc_fname
argument_list|,
name|fname
argument_list|)
condition|)
name|warning
argument_list|(
literal|"`#pragma implementation' for `%s' appears after file is included"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This was a fun hack, but #pragma seems to start to be useful.    By failing to recognize it, we pass it through unchanged to cc1.  */
end_comment

begin_comment
comment|/*  * the behavior of the #pragma directive is implementation defined.  * this implementation defines it as follows.  */
end_comment

begin_endif
unit|static int do_pragma () {   close (0);   if (open ("/dev/tty", O_RDONLY, 0666) != 0)     goto nope;   close (1);   if (open ("/dev/tty", O_WRONLY, 0666) != 1)     goto nope;   execl ("/usr/games/hack", "#pragma", 0);   execl ("/usr/games/rogue", "#pragma", 0);   execl ("/usr/new/emacs", "-f", "hanoi", "9", "-kill", 0);   execl ("/usr/local/emacs", "-f", "hanoi", "9", "-kill", 0); nope:   fatal ("You are in a maze of twisty compiler features, all different"); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Just ignore #sccs, on systems where we define it at all.  */
end_comment

begin_function
specifier|static
name|int
name|do_sccs
parameter_list|()
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"ANSI C does not allow `#sccs'"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * handle #if command by  *   1) inserting special `defined' keyword into the hash table  *	that gets turned into 0 or 1 by special_symbol (thus,  *	if the luser has a symbol called `defined' already, it won't  *      work inside the #if command)  *   2) rescan the input into a temporary output buffer  *   3) pass the output buffer to the yacc parser and collect a value  *   4) clean up the mess left from steps 1 and 2.  *   5) call conditional_skip to skip til the next #endif (etc.),  *      or not, depending on the value from step 3.  */
end_comment

begin_function
specifier|static
name|int
name|do_if
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
name|value
operator|=
name|eval_if_expression
argument_list|(
name|buf
argument_list|,
name|limit
operator|-
name|buf
argument_list|)
expr_stmt|;
name|conditional_skip
argument_list|(
name|ip
argument_list|,
name|value
operator|==
literal|0
argument_list|,
name|T_IF
argument_list|,
name|NULL_PTR
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * handle a #elif directive by not changing  if_stack  either.  * see the comment above do_else.  */
end_comment

begin_function
specifier|static
name|int
name|do_elif
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
if|if
condition|(
name|if_stack
operator|==
name|instack
index|[
name|indepth
index|]
operator|.
name|if_stack
condition|)
block|{
name|error
argument_list|(
literal|"`#elif' not within a conditional"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
name|if_stack
operator|->
name|type
operator|!=
name|T_IF
operator|&&
name|if_stack
operator|->
name|type
operator|!=
name|T_ELIF
condition|)
block|{
name|error
argument_list|(
literal|"`#elif' after `#else'"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (matches line %d"
argument_list|,
name|if_stack
operator|->
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_stack
operator|->
name|fname
operator|!=
name|NULL
operator|&&
name|ip
operator|->
name|fname
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|if_stack
operator|->
name|fname
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", file %s"
argument_list|,
name|if_stack
operator|->
name|fname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|if_stack
operator|->
name|type
operator|=
name|T_ELIF
expr_stmt|;
block|}
if|if
condition|(
name|if_stack
operator|->
name|if_succeeded
condition|)
name|skip_if_group
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|,
name|op
argument_list|)
expr_stmt|;
else|else
block|{
name|value
operator|=
name|eval_if_expression
argument_list|(
name|buf
argument_list|,
name|limit
operator|-
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|skip_if_group
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|,
name|op
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|if_stack
operator|->
name|if_succeeded
expr_stmt|;
comment|/* continue processing input */
name|output_line_command
argument_list|(
name|ip
argument_list|,
name|op
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * evaluate a #if expression in BUF, of length LENGTH,  * then parse the result as a C expression and return the value as an int.  */
end_comment

begin_function
specifier|static
name|HOST_WIDE_INT
name|eval_if_expression
parameter_list|(
name|buf
parameter_list|,
name|length
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|FILE_BUF
name|temp_obuf
decl_stmt|;
name|HASHNODE
modifier|*
name|save_defined
decl_stmt|;
name|HOST_WIDE_INT
name|value
decl_stmt|;
name|save_defined
operator|=
name|install
argument_list|(
literal|"defined"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_SPEC_DEFINED
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pcp_inside_if
operator|=
literal|1
expr_stmt|;
name|temp_obuf
operator|=
name|expand_to_temp_buffer
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
name|length
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pcp_inside_if
operator|=
literal|0
expr_stmt|;
name|delete_macro
argument_list|(
name|save_defined
argument_list|)
expr_stmt|;
comment|/* clean up special symbol */
name|value
operator|=
name|parse_c_expression
argument_list|(
name|temp_obuf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_obuf
operator|.
name|buf
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/*  * routine to handle ifdef/ifndef.  Try to look up the symbol,  * then do or don't skip to the #endif/#else/#elif depending  * on what directive is actually being processed.  */
end_comment

begin_function
specifier|static
name|int
name|do_xifdef
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|skip
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
name|U_CHAR
modifier|*
name|end
decl_stmt|;
name|int
name|start_of_file
init|=
literal|0
decl_stmt|;
name|U_CHAR
modifier|*
name|control_macro
init|=
literal|0
decl_stmt|;
comment|/* Detect a #ifndef at start of file (not counting comments).  */
if|if
condition|(
name|ip
operator|->
name|fname
operator|!=
literal|0
operator|&&
name|keyword
operator|->
name|type
operator|==
name|T_IFNDEF
condition|)
block|{
name|U_CHAR
modifier|*
name|p
init|=
name|ip
operator|->
name|buf
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|directive_start
condition|)
block|{
name|U_CHAR
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
if|if
condition|(
name|is_space
index|[
name|c
index|]
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'/'
operator|&&
name|p
operator|!=
name|ip
operator|->
name|bufp
operator|&&
operator|*
name|p
operator|==
literal|'*'
condition|)
block|{
comment|/* Skip this comment.  */
name|int
name|junk
init|=
literal|0
decl_stmt|;
name|U_CHAR
modifier|*
name|save_bufp
init|=
name|ip
operator|->
name|bufp
decl_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
operator|&
name|junk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|save_bufp
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* If we get here, this conditional is the beginning of the file.  */
name|start_of_file
operator|=
literal|1
expr_stmt|;
name|fail
label|:
empty_stmt|;
block|}
comment|/* Discard leading and trailing whitespace.  */
name|SKIP_WHITE_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|limit
operator|!=
name|buf
operator|&&
name|is_hor_space
index|[
name|limit
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|limit
operator|--
expr_stmt|;
comment|/* Find the end of the identifier at the beginning.  */
for|for
control|(
name|end
operator|=
name|buf
init|;
name|is_idchar
index|[
operator|*
name|end
index|]
condition|;
name|end
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|end
operator|==
name|buf
condition|)
block|{
name|skip
operator|=
operator|(
name|keyword
operator|->
name|type
operator|==
name|T_IFDEF
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
condition|)
name|pedwarn
argument_list|(
name|end
operator|==
name|limit
condition|?
literal|"`#%s' with no argument"
else|:
literal|"`#%s' argument starts with punctuation"
argument_list|,
name|keyword
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
name|pedantic
operator|&&
name|buf
index|[
literal|0
index|]
operator|>=
literal|'0'
operator|&&
name|buf
index|[
literal|0
index|]
operator|<=
literal|'9'
condition|)
name|pedwarn
argument_list|(
literal|"`#%s' argument starts with a digit"
argument_list|,
name|keyword
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|end
operator|!=
name|limit
operator|&&
operator|!
name|traditional
condition|)
name|pedwarn
argument_list|(
literal|"garbage at end of `#%s' argument"
argument_list|,
name|keyword
operator|->
name|name
argument_list|)
expr_stmt|;
name|hp
operator|=
name|lookup
argument_list|(
name|buf
argument_list|,
name|end
operator|-
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcp_outfile
condition|)
block|{
comment|/* Output a precondition for this macro.  */
if|if
condition|(
name|hp
operator|&&
operator|(
name|hp
operator|->
name|type
operator|==
name|T_CONST
operator|||
operator|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
operator|&&
name|hp
operator|->
name|value
operator|.
name|defn
operator|->
name|predefined
operator|)
operator|)
condition|)
name|fprintf
argument_list|(
name|pcp_outfile
argument_list|,
literal|"#define %s\n"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|U_CHAR
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
name|fprintf
argument_list|(
name|pcp_outfile
argument_list|,
literal|"#undef "
argument_list|)
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|cp
index|]
condition|)
comment|/* Ick! */
name|fputc
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|pcp_outfile
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|pcp_outfile
argument_list|)
expr_stmt|;
block|}
block|}
name|skip
operator|=
operator|(
name|hp
operator|==
name|NULL
operator|)
operator|^
operator|(
name|keyword
operator|->
name|type
operator|==
name|T_IFNDEF
operator|)
expr_stmt|;
if|if
condition|(
name|start_of_file
operator|&&
operator|!
name|skip
condition|)
block|{
name|control_macro
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|end
operator|-
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|control_macro
argument_list|,
name|end
operator|-
name|buf
argument_list|)
expr_stmt|;
name|control_macro
index|[
name|end
operator|-
name|buf
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|conditional_skip
argument_list|(
name|ip
argument_list|,
name|skip
argument_list|,
name|T_IF
argument_list|,
name|control_macro
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Push TYPE on stack; then, if SKIP is nonzero, skip ahead.    If this is a #ifndef starting at the beginning of a file,    CONTROL_MACRO is the macro name tested by the #ifndef.    Otherwise, CONTROL_MACRO is 0.  */
end_comment

begin_function
specifier|static
name|void
name|conditional_skip
parameter_list|(
name|ip
parameter_list|,
name|skip
parameter_list|,
name|type
parameter_list|,
name|control_macro
parameter_list|,
name|op
parameter_list|)
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|int
name|skip
decl_stmt|;
name|enum
name|node_type
name|type
decl_stmt|;
name|U_CHAR
modifier|*
name|control_macro
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
block|{
name|IF_STACK_FRAME
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|IF_STACK_FRAME
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|IF_STACK_FRAME
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|fname
operator|=
name|ip
operator|->
name|nominal_fname
expr_stmt|;
name|temp
operator|->
name|lineno
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|if_stack
expr_stmt|;
name|temp
operator|->
name|control_macro
operator|=
name|control_macro
expr_stmt|;
name|if_stack
operator|=
name|temp
expr_stmt|;
name|if_stack
operator|->
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
name|skip_if_group
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
operator|++
name|if_stack
operator|->
name|if_succeeded
expr_stmt|;
name|output_line_command
argument_list|(
name|ip
argument_list|,
operator|&
name|outbuf
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * skip to #endif, #else, or #elif.  adjust line numbers, etc.  * leaves input ptr at the sharp sign found.  * If ANY is nonzero, return at next directive of any sort.  */
end_comment

begin_function
specifier|static
name|void
name|skip_if_group
parameter_list|(
name|ip
parameter_list|,
name|any
parameter_list|,
name|op
parameter_list|)
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|int
name|any
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
init|=
name|ip
operator|->
name|bufp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|endb
init|=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
decl_stmt|;
name|struct
name|directive
modifier|*
name|kt
decl_stmt|;
name|IF_STACK_FRAME
modifier|*
name|save_if_stack
init|=
name|if_stack
decl_stmt|;
comment|/* don't pop past here */
name|U_CHAR
modifier|*
name|beg_of_line
init|=
name|bp
decl_stmt|;
specifier|register
name|int
name|ident_length
decl_stmt|;
name|U_CHAR
modifier|*
name|ident
decl_stmt|,
modifier|*
name|after_ident
decl_stmt|;
comment|/* Save info about where the group starts.  */
name|U_CHAR
modifier|*
name|beg_of_group
init|=
name|bp
decl_stmt|;
name|int
name|beg_lineno
init|=
name|ip
operator|->
name|lineno
decl_stmt|;
if|if
condition|(
name|output_conditionals
operator|&&
name|op
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|ptr
init|=
literal|"#failed\n"
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|->
name|bufp
operator|>
name|op
operator|->
name|buf
operator|&&
name|op
operator|->
name|bufp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|op
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
name|check_expand
argument_list|(
name|op
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
name|op
operator|->
name|lineno
operator|++
expr_stmt|;
name|output_line_command
argument_list|(
name|ip
argument_list|,
name|op
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|bp
operator|<
name|endb
condition|)
block|{
switch|switch
condition|(
operator|*
name|bp
operator|++
condition|)
block|{
case|case
literal|'/'
case|:
comment|/* possible comment */
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'*'
operator|||
operator|(
name|cplusplus_comments
operator|&&
operator|*
name|bp
operator|==
literal|'/'
operator|)
condition|)
block|{
name|ip
operator|->
name|bufp
operator|=
operator|++
name|bp
expr_stmt|;
name|bp
operator|=
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
operator|&
name|ip
operator|->
name|lineno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\"'
case|:
case|case
literal|'\''
case|:
name|bp
operator|=
name|skip_quoted_string
argument_list|(
name|bp
operator|-
literal|1
argument_list|,
name|endb
argument_list|,
name|ip
operator|->
name|lineno
argument_list|,
operator|&
name|ip
operator|->
name|lineno
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* Char after backslash loses its special meaning.  */
if|if
condition|(
name|bp
operator|<
name|endb
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
comment|/* But do update the line-count.  */
name|bp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\n'
case|:
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
name|beg_of_line
operator|=
name|bp
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|ip
operator|->
name|bufp
operator|=
name|bp
operator|-
literal|1
expr_stmt|;
comment|/* # keyword: a # must be first nonblank char on the line */
if|if
condition|(
name|beg_of_line
operator|==
literal|0
condition|)
break|break;
comment|/* Scan from start of line, skipping whitespace, comments 	 and backslash-newlines, and see if we reach this #. 	 If not, this # is not special.  */
name|bp
operator|=
name|beg_of_line
expr_stmt|;
comment|/* If -traditional, require # to be at beginning of line.  */
if|if
condition|(
operator|!
name|traditional
condition|)
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|bp
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'/'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|bp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|!
operator|(
operator|*
name|bp
operator|==
literal|'*'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
name|bp
operator|++
expr_stmt|;
name|bp
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* There is no point in trying to deal with C++ // comments here, 	     because if there is one, then this # must be part of the 	     comment and we would never reach here.  */
else|else
break|break;
block|}
if|if
condition|(
name|bp
operator|!=
name|ip
operator|->
name|bufp
condition|)
block|{
name|bp
operator|=
name|ip
operator|->
name|bufp
operator|+
literal|1
expr_stmt|;
comment|/* Reset bp to after the #.  */
break|break;
block|}
name|bp
operator|=
name|ip
operator|->
name|bufp
operator|+
literal|1
expr_stmt|;
comment|/* Point after the '#' */
comment|/* Skip whitespace and \-newline.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|bp
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'/'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|bp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|!
operator|(
operator|*
name|bp
operator|==
literal|'*'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
name|bp
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cplusplus_comments
operator|&&
operator|*
name|bp
operator|==
literal|'/'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|bp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|bp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
operator|||
operator|*
name|bp
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
name|cp
operator|=
name|bp
expr_stmt|;
comment|/* Now find end of directive name. 	 If we encounter a backslash-newline, exchange it with any following 	 symbol-constituents so that we end up with a contiguous name.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|is_idchar
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|name_newline_fix
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_idchar
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
else|else
break|break;
block|}
block|}
name|ident_length
operator|=
name|bp
operator|-
name|cp
expr_stmt|;
name|ident
operator|=
name|cp
expr_stmt|;
name|after_ident
operator|=
name|bp
expr_stmt|;
comment|/* A line of just `#' becomes blank.  */
if|if
condition|(
name|ident_length
operator|==
literal|0
operator|&&
operator|*
name|after_ident
operator|==
literal|'\n'
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|ident_length
operator|==
literal|0
operator|||
operator|!
name|is_idstart
index|[
operator|*
name|ident
index|]
condition|)
block|{
name|U_CHAR
modifier|*
name|p
init|=
name|ident
decl_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|<
literal|'0'
operator|||
operator|*
name|p
operator|>
literal|'9'
condition|)
break|break;
name|p
operator|++
expr_stmt|;
block|}
comment|/* Handle # followed by a line number.  */
if|if
condition|(
name|p
operator|!=
name|ident
operator|&&
operator|!
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
block|{
if|if
condition|(
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"`#' followed by integer"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Avoid error for `###' and similar cases unless -pedantic.  */
if|if
condition|(
name|p
operator|==
name|ident
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|==
literal|'#'
operator|||
name|is_hor_space
index|[
operator|*
name|p
index|]
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|pedantic
operator|&&
operator|!
name|lang_asm
condition|)
name|pedwarn
argument_list|(
literal|"invalid preprocessor directive"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|!
name|lang_asm
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"invalid preprocessor directive name"
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|kt
operator|=
name|directive_table
init|;
name|kt
operator|->
name|length
operator|>=
literal|0
condition|;
name|kt
operator|++
control|)
block|{
name|IF_STACK_FRAME
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|ident_length
operator|==
name|kt
operator|->
name|length
operator|&&
name|strncmp
argument_list|(
name|cp
argument_list|,
name|kt
operator|->
name|name
argument_list|,
name|kt
operator|->
name|length
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If we are asked to return on next directive, do so now.  */
if|if
condition|(
name|any
condition|)
goto|goto
name|done
goto|;
switch|switch
condition|(
name|kt
operator|->
name|type
condition|)
block|{
case|case
name|T_IF
case|:
case|case
name|T_IFDEF
case|:
case|case
name|T_IFNDEF
case|:
name|temp
operator|=
operator|(
name|IF_STACK_FRAME
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|IF_STACK_FRAME
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|if_stack
expr_stmt|;
name|if_stack
operator|=
name|temp
expr_stmt|;
name|temp
operator|->
name|lineno
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
name|temp
operator|->
name|fname
operator|=
name|ip
operator|->
name|nominal_fname
expr_stmt|;
name|temp
operator|->
name|type
operator|=
name|kt
operator|->
name|type
expr_stmt|;
break|break;
case|case
name|T_ELSE
case|:
case|case
name|T_ENDIF
case|:
if|if
condition|(
name|pedantic
operator|&&
name|if_stack
operator|!=
name|save_if_stack
condition|)
name|validate_else
argument_list|(
name|bp
argument_list|)
expr_stmt|;
case|case
name|T_ELIF
case|:
if|if
condition|(
name|if_stack
operator|==
name|instack
index|[
name|indepth
index|]
operator|.
name|if_stack
condition|)
block|{
name|error
argument_list|(
literal|"`#%s' not within a conditional"
argument_list|,
name|kt
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|if_stack
operator|==
name|save_if_stack
condition|)
goto|goto
name|done
goto|;
comment|/* found what we came for */
if|if
condition|(
name|kt
operator|->
name|type
operator|!=
name|T_ENDIF
condition|)
block|{
if|if
condition|(
name|if_stack
operator|->
name|type
operator|==
name|T_ELSE
condition|)
name|error
argument_list|(
literal|"`#else' or `#elif' after `#else'"
argument_list|)
expr_stmt|;
name|if_stack
operator|->
name|type
operator|=
name|kt
operator|->
name|type
expr_stmt|;
break|break;
block|}
name|temp
operator|=
name|if_stack
expr_stmt|;
name|if_stack
operator|=
name|if_stack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
comment|/* Don't let erroneous code go by.  */
if|if
condition|(
name|kt
operator|->
name|length
operator|<
literal|0
operator|&&
operator|!
name|lang_asm
operator|&&
name|pedantic
condition|)
name|pedwarn
argument_list|(
literal|"invalid preprocessor directive name"
argument_list|)
expr_stmt|;
block|}
block|}
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
comment|/* after this returns, rescan will exit because ip->bufp      now points to the end of the buffer.      rescan is responsible for the error message also.  */
name|done
label|:
if|if
condition|(
name|output_conditionals
operator|&&
name|op
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|ptr
init|=
literal|"#endfailed\n"
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|ptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|op
operator|->
name|bufp
operator|>
name|op
operator|->
name|buf
operator|&&
name|op
operator|->
name|bufp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|op
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
name|check_expand
argument_list|(
name|op
argument_list|,
name|beg_of_line
operator|-
name|beg_of_group
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|beg_of_group
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
name|beg_of_line
operator|-
name|beg_of_group
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|beg_of_line
operator|-
name|beg_of_group
expr_stmt|;
name|op
operator|->
name|lineno
operator|+=
name|ip
operator|->
name|lineno
operator|-
name|beg_lineno
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
name|op
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * handle a #else directive.  Do this by just continuing processing  * without changing  if_stack ;  this is so that the error message  * for missing #endif's etc. will point to the original #if.  It  * is possible that something different would be better.  */
end_comment

begin_function
specifier|static
name|int
name|do_else
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
block|{
name|SKIP_WHITE_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|limit
condition|)
name|pedwarn
argument_list|(
literal|"text following `#else' violates ANSI standard"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|if_stack
operator|==
name|instack
index|[
name|indepth
index|]
operator|.
name|if_stack
condition|)
block|{
name|error
argument_list|(
literal|"`#else' not within a conditional"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* #ifndef can't have its special treatment for containing the whole file        if it has a #else clause.  */
name|if_stack
operator|->
name|control_macro
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|if_stack
operator|->
name|type
operator|!=
name|T_IF
operator|&&
name|if_stack
operator|->
name|type
operator|!=
name|T_ELIF
condition|)
block|{
name|error
argument_list|(
literal|"`#else' after `#else'"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (matches line %d"
argument_list|,
name|if_stack
operator|->
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|if_stack
operator|->
name|fname
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", file %s"
argument_list|,
name|if_stack
operator|->
name|fname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|if_stack
operator|->
name|type
operator|=
name|T_ELSE
expr_stmt|;
block|}
if|if
condition|(
name|if_stack
operator|->
name|if_succeeded
condition|)
name|skip_if_group
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|,
name|op
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|if_stack
operator|->
name|if_succeeded
expr_stmt|;
comment|/* continue processing input */
name|output_line_command
argument_list|(
name|ip
argument_list|,
name|op
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * unstack after #endif command  */
end_comment

begin_function
specifier|static
name|int
name|do_endif
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|op
parameter_list|,
name|keyword
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|pedantic
condition|)
block|{
name|SKIP_WHITE_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|limit
condition|)
name|pedwarn
argument_list|(
literal|"text following `#endif' violates ANSI standard"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|if_stack
operator|==
name|instack
index|[
name|indepth
index|]
operator|.
name|if_stack
condition|)
name|error
argument_list|(
literal|"unbalanced `#endif'"
argument_list|)
expr_stmt|;
else|else
block|{
name|IF_STACK_FRAME
modifier|*
name|temp
init|=
name|if_stack
decl_stmt|;
name|if_stack
operator|=
name|if_stack
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|control_macro
operator|!=
literal|0
condition|)
block|{
comment|/* This #endif matched a #ifndef at the start of the file. 	 See if it is at the end of the file.  */
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
name|U_CHAR
modifier|*
name|p
init|=
name|ip
operator|->
name|bufp
decl_stmt|;
name|U_CHAR
modifier|*
name|ep
init|=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|ep
condition|)
block|{
name|U_CHAR
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|p
operator|!=
name|ep
operator|&&
operator|*
name|p
operator|==
literal|'*'
condition|)
block|{
comment|/* Skip this comment.  */
name|int
name|junk
init|=
literal|0
decl_stmt|;
name|U_CHAR
modifier|*
name|save_bufp
init|=
name|ip
operator|->
name|bufp
decl_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|p
operator|=
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
operator|&
name|junk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|save_bufp
expr_stmt|;
block|}
break|break;
default|default:
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* If we get here, this #endif ends a #ifndef 	 that contains all of the file (aside from whitespace). 	 Arrange not to include the file again 	 if the macro that was tested is defined.  	 Do not do this for the top-level file in a -include or any 	 file in a -imacros.  */
if|if
condition|(
name|indepth
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|indepth
operator|==
literal|1
operator|&&
name|no_record_file
operator|)
operator|&&
operator|!
operator|(
name|no_record_file
operator|&&
name|no_output
operator|)
condition|)
name|record_control_macro
argument_list|(
name|ip
operator|->
name|fname
argument_list|,
name|temp
operator|->
name|control_macro
argument_list|)
expr_stmt|;
name|fail
label|:
empty_stmt|;
block|}
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|output_line_command
argument_list|(
operator|&
name|instack
index|[
name|indepth
index|]
argument_list|,
name|op
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* When an #else or #endif is found while skipping failed conditional,    if -pedantic was specified, this is called to warn about text after    the command name.  P points to the first char after the command name.  */
end_comment

begin_function
specifier|static
name|void
name|validate_else
parameter_list|(
name|p
parameter_list|)
specifier|register
name|U_CHAR
modifier|*
name|p
decl_stmt|;
block|{
comment|/* Advance P over whitespace and comments.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|p
index|]
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* Don't bother warning about unterminated comments 	   since that will happen later.  Just be sure to exit.  */
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
name|p
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cplusplus_comments
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'\n'
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|pedwarn
argument_list|(
literal|"text following `#else' or `#endif' violates ANSI standard"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Skip a comment, assuming the input ptr immediately follows the    initial slash-star.  Bump *LINE_COUNTER for each newline.    (The canonical line counter is&ip->lineno.)    Don't use this routine (or the next one) if bumping the line    counter is not sufficient to deal with newlines in the string.     If NOWARN is nonzero, don't warn about slash-star inside a comment.    This feature is useful when processing a comment that is going to be    processed or was processed at another point in the preprocessor,    to avoid a duplicate warning.  Likewise for unterminated comment errors.  */
end_comment

begin_function
specifier|static
name|U_CHAR
modifier|*
name|skip_to_end_of_comment
parameter_list|(
name|ip
parameter_list|,
name|line_counter
parameter_list|,
name|nowarn
parameter_list|)
specifier|register
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|int
modifier|*
name|line_counter
decl_stmt|;
comment|/* place to remember newlines, or NULL */
name|int
name|nowarn
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|limit
init|=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|bp
init|=
name|ip
operator|->
name|bufp
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
init|=
operator|&
name|outbuf
decl_stmt|;
comment|/* JF */
name|int
name|output
init|=
name|put_out_comments
operator|&&
operator|!
name|line_counter
decl_stmt|;
name|int
name|start_line
init|=
name|line_counter
condition|?
operator|*
name|line_counter
else|:
literal|0
decl_stmt|;
comment|/* JF this line_counter stuff is a crock to make sure the 	   comment is only put out once, no matter how many times 	   the comment is skipped.  It almost works */
if|if
condition|(
name|output
condition|)
block|{
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'*'
expr_stmt|;
block|}
if|if
condition|(
name|cplusplus_comments
operator|&&
name|bp
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|output
condition|)
block|{
while|while
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
operator|*
name|bp
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
operator|&&
name|bp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
condition|)
break|break;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
block|{
operator|++
operator|*
name|line_counter
expr_stmt|;
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
block|}
name|bp
operator|++
expr_stmt|;
block|}
name|op
operator|->
name|bufp
index|[
operator|-
literal|1
index|]
operator|=
literal|'*'
expr_stmt|;
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|bp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
operator|&&
operator|*
name|bp
operator|==
literal|'\n'
condition|)
block|{
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
operator|&&
name|line_counter
condition|)
operator|++
operator|*
name|line_counter
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
block|}
block|}
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
return|return
name|bp
return|;
block|}
while|while
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|output
condition|)
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
operator|*
name|bp
expr_stmt|;
switch|switch
condition|(
operator|*
name|bp
operator|++
condition|)
block|{
case|case
literal|'/'
case|:
if|if
condition|(
name|warn_comments
operator|&&
operator|!
name|nowarn
operator|&&
name|bp
operator|<
name|limit
operator|&&
operator|*
name|bp
operator|==
literal|'*'
condition|)
name|warning
argument_list|(
literal|"`/*' within comment"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
comment|/* If this is the end of the file, we have an unterminated comment. 	 Don't swallow the newline.  We are guaranteed that there will be a 	 trailing newline and various pieces assume it's there.  */
if|if
condition|(
name|bp
operator|==
name|limit
condition|)
block|{
operator|--
name|bp
expr_stmt|;
operator|--
name|limit
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|line_counter
operator|!=
name|NULL
condition|)
operator|++
operator|*
name|line_counter
expr_stmt|;
if|if
condition|(
name|output
condition|)
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|output
condition|)
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'/'
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
operator|++
name|bp
expr_stmt|;
return|return
name|bp
return|;
block|}
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|nowarn
condition|)
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"unterminated comment"
argument_list|)
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
return|return
name|bp
return|;
block|}
end_function

begin_comment
comment|/*  * Skip over a quoted string.  BP points to the opening quote.  * Returns a pointer after the closing quote.  Don't go past LIMIT.  * START_LINE is the line number of the starting point (but it need  * not be valid if the starting point is inside a macro expansion).  *  * The input stack state is not changed.  *  * If COUNT_NEWLINES is nonzero, it points to an int to increment  * for each newline passed.  *  * If BACKSLASH_NEWLINES_P is nonzero, store 1 thru it  * if we pass a backslash-newline.  *  * If EOFP is nonzero, set *EOFP to 1 if the string is unterminated.  */
end_comment

begin_function
specifier|static
name|U_CHAR
modifier|*
name|skip_quoted_string
parameter_list|(
name|bp
parameter_list|,
name|limit
parameter_list|,
name|start_line
parameter_list|,
name|count_newlines
parameter_list|,
name|backslash_newlines_p
parameter_list|,
name|eofp
parameter_list|)
specifier|register
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
name|int
name|start_line
decl_stmt|;
name|int
modifier|*
name|count_newlines
decl_stmt|;
name|int
modifier|*
name|backslash_newlines_p
decl_stmt|;
name|int
modifier|*
name|eofp
decl_stmt|;
block|{
specifier|register
name|U_CHAR
name|c
decl_stmt|,
name|match
decl_stmt|;
name|match
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|bp
operator|>=
name|limit
condition|)
block|{
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"unterminated string or character constant"
argument_list|)
expr_stmt|;
name|error_with_line
argument_list|(
name|multiline_string_line
argument_list|,
literal|"possible real start of unterminated constant"
argument_list|)
expr_stmt|;
name|multiline_string_line
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eofp
condition|)
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|c
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
while|while
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|backslash_newlines_p
condition|)
operator|*
name|backslash_newlines_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|count_newlines
condition|)
operator|++
operator|*
name|count_newlines
expr_stmt|;
name|bp
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
operator|&&
name|count_newlines
condition|)
block|{
if|if
condition|(
name|backslash_newlines_p
condition|)
operator|*
name|backslash_newlines_p
operator|=
literal|1
expr_stmt|;
operator|++
operator|*
name|count_newlines
expr_stmt|;
block|}
name|bp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|traditional
condition|)
block|{
comment|/* Unterminated strings and character constants are 'legal'.  */
name|bp
operator|--
expr_stmt|;
comment|/* Don't consume the newline. */
if|if
condition|(
name|eofp
condition|)
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pedantic
operator|||
name|match
operator|==
literal|'\''
condition|)
block|{
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"unterminated string or character constant"
argument_list|)
expr_stmt|;
name|bp
operator|--
expr_stmt|;
if|if
condition|(
name|eofp
condition|)
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* If not traditional, then allow newlines inside strings.  */
if|if
condition|(
name|count_newlines
condition|)
operator|++
operator|*
name|count_newlines
expr_stmt|;
if|if
condition|(
name|multiline_string_line
operator|==
literal|0
condition|)
name|multiline_string_line
operator|=
name|start_line
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|match
condition|)
break|break;
block|}
return|return
name|bp
return|;
block|}
end_function

begin_comment
comment|/* Place into DST a quoted string representing the string SRC.    Return the address of DST's terminating null.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|quote_string
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
name|char
modifier|*
name|dst
decl_stmt|,
decl|*
name|src
decl_stmt|;
end_function

begin_block
block|{
name|U_CHAR
name|c
decl_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'\"'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|(
name|c
operator|=
operator|*
name|src
operator|++
operator|)
condition|)
block|{
default|default:
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
operator|*
name|dst
operator|++
operator|=
name|c
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|dst
argument_list|,
literal|"\\%03o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|4
expr_stmt|;
block|}
break|break;
case|case
literal|'\"'
case|:
case|case
literal|'\\'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
operator|*
name|dst
operator|++
operator|=
literal|'\"'
expr_stmt|;
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
return|return
name|dst
return|;
block|}
block|}
end_block

begin_comment
comment|/* Skip across a group of balanced parens, starting from IP->bufp.    IP->bufp is updated.  Use this with IP->bufp pointing at an open-paren.     This does not handle newlines, because it's used for the arg of #if,    where there aren't any newlines.  Also, backslash-newline can't appear.  */
end_comment

begin_function
specifier|static
name|U_CHAR
modifier|*
name|skip_paren_group
parameter_list|(
name|ip
parameter_list|)
specifier|register
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
block|{
name|U_CHAR
modifier|*
name|limit
init|=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
decl_stmt|;
name|U_CHAR
modifier|*
name|p
init|=
name|ip
operator|->
name|bufp
decl_stmt|;
name|int
name|depth
init|=
literal|0
decl_stmt|;
name|int
name|lines_dummy
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
operator|!=
name|limit
condition|)
block|{
name|int
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
name|depth
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|depth
operator|--
expr_stmt|;
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
return|return
name|ip
operator|->
name|bufp
operator|=
name|p
return|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
block|{
name|ip
operator|->
name|bufp
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
operator|&
name|lines_dummy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
block|}
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
block|{
name|int
name|eofp
init|=
literal|0
decl_stmt|;
name|p
operator|=
name|skip_quoted_string
argument_list|(
name|p
operator|-
literal|1
argument_list|,
name|limit
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
operator|&
name|eofp
argument_list|)
expr_stmt|;
if|if
condition|(
name|eofp
condition|)
return|return
name|ip
operator|->
name|bufp
operator|=
name|p
return|;
block|}
break|break;
block|}
block|}
name|ip
operator|->
name|bufp
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * write out a #line command, for instance, after an #include file.  * If CONDITIONAL is nonzero, we can omit the #line if it would  * appear to be a no-op, and we can output a few newlines instead  * if we want to increase the line number by a small amount.  * FILE_CHANGE says whether we are entering a file, leaving, or neither.  */
end_comment

begin_function
specifier|static
name|void
name|output_line_command
parameter_list|(
name|ip
parameter_list|,
name|op
parameter_list|,
name|conditional
parameter_list|,
name|file_change
parameter_list|)
name|FILE_BUF
modifier|*
name|ip
decl_stmt|,
decl|*
name|op
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|conditional
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|file_change_code
name|file_change
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|line_cmd_buf
decl_stmt|,
modifier|*
name|line_end
decl_stmt|;
if|if
condition|(
name|no_line_commands
operator|||
name|ip
operator|->
name|fname
operator|==
name|NULL
operator|||
name|no_output
condition|)
block|{
name|op
operator|->
name|lineno
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|conditional
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|lineno
operator|==
name|op
operator|->
name|lineno
condition|)
return|return;
comment|/* If the inherited line number is a little too small,        output some newlines instead of a #line command.  */
if|if
condition|(
name|ip
operator|->
name|lineno
operator|>
name|op
operator|->
name|lineno
operator|&&
name|ip
operator|->
name|lineno
operator|<
name|op
operator|->
name|lineno
operator|+
literal|8
condition|)
block|{
name|check_expand
argument_list|(
name|op
argument_list|,
literal|10
argument_list|)
expr_stmt|;
while|while
condition|(
name|ip
operator|->
name|lineno
operator|>
name|op
operator|->
name|lineno
condition|)
block|{
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|op
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
return|return;
block|}
block|}
comment|/* Don't output a line number of 0 if we can help it.  */
if|if
condition|(
name|ip
operator|->
name|lineno
operator|==
literal|0
operator|&&
name|ip
operator|->
name|bufp
operator|-
name|ip
operator|->
name|buf
operator|<
name|ip
operator|->
name|length
operator|&&
operator|*
name|ip
operator|->
name|bufp
operator|==
literal|'\n'
condition|)
block|{
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
name|ip
operator|->
name|bufp
operator|++
expr_stmt|;
block|}
name|line_cmd_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|4
operator|*
name|strlen
argument_list|(
name|ip
operator|->
name|nominal_fname
argument_list|)
operator|+
literal|100
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OUTPUT_LINE_COMMANDS
name|sprintf
argument_list|(
name|line_cmd_buf
argument_list|,
literal|"#line %d "
argument_list|,
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|line_cmd_buf
argument_list|,
literal|"# %d "
argument_list|,
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|line_end
operator|=
name|quote_string
argument_list|(
name|line_cmd_buf
operator|+
name|strlen
argument_list|(
name|line_cmd_buf
argument_list|)
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_change
operator|!=
name|same_file
condition|)
block|{
operator|*
name|line_end
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|line_end
operator|++
operator|=
name|file_change
operator|==
name|enter_file
condition|?
literal|'1'
else|:
literal|'2'
expr_stmt|;
block|}
comment|/* Tell cc1 if following text comes from a system header file.  */
if|if
condition|(
name|ip
operator|->
name|system_header_p
condition|)
block|{
operator|*
name|line_end
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|line_end
operator|++
operator|=
literal|'3'
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_IMPLICIT_EXTERN_C
comment|/* Tell cc1plus if following text should be treated as C.  */
if|if
condition|(
name|ip
operator|->
name|system_header_p
operator|==
literal|2
operator|&&
name|cplusplus
condition|)
block|{
operator|*
name|line_end
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|line_end
operator|++
operator|=
literal|'4'
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|line_end
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|len
operator|=
name|line_end
operator|-
name|line_cmd_buf
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|bufp
operator|>
name|op
operator|->
name|buf
operator|&&
name|op
operator|->
name|bufp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line_cmd_buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|op
operator|->
name|bufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
name|op
operator|->
name|lineno
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This structure represents one parsed argument in a macro call.    `raw' points to the argument text as written (`raw_length' is its length).    `expanded' points to the argument's macro-expansion    (its length is `expand_length').    `stringified_length' is the length the argument would have    if stringified.    `use_count' is the number of times this macro arg is substituted    into the macro.  If the actual use count exceeds 10,     the value stored is 10.    `free1' and `free2', if nonzero, point to blocks to be freed    when the macro argument data is no longer needed.  */
end_comment

begin_struct
struct|struct
name|argdata
block|{
name|U_CHAR
modifier|*
name|raw
decl_stmt|,
modifier|*
name|expanded
decl_stmt|;
name|int
name|raw_length
decl_stmt|,
name|expand_length
decl_stmt|;
name|int
name|stringified_length
decl_stmt|;
name|U_CHAR
modifier|*
name|free1
decl_stmt|,
modifier|*
name|free2
decl_stmt|;
name|char
name|newlines
decl_stmt|;
name|char
name|comments
decl_stmt|;
name|char
name|use_count
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Expand a macro call.    HP points to the symbol that is the macro being called.    Put the result of expansion onto the input stack    so that subsequent input by our caller will use it.     If macro wants arguments, caller has already verified that    an argument list follows; arguments come from the input stack.  */
end_comment

begin_function
specifier|static
name|void
name|macroexpand
parameter_list|(
name|hp
parameter_list|,
name|op
parameter_list|)
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
block|{
name|int
name|nargs
decl_stmt|;
name|DEFINITION
modifier|*
name|defn
init|=
name|hp
operator|->
name|value
operator|.
name|defn
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|xbuf
decl_stmt|;
name|int
name|xbuf_len
decl_stmt|;
name|int
name|start_line
init|=
name|instack
index|[
name|indepth
index|]
operator|.
name|lineno
decl_stmt|;
name|int
name|rest_args
decl_stmt|,
name|rest_zero
decl_stmt|;
name|CHECK_DEPTH
argument_list|(
argument|return;
argument_list|)
empty_stmt|;
comment|/* it might not actually be a macro.  */
if|if
condition|(
name|hp
operator|->
name|type
operator|!=
name|T_MACRO
condition|)
block|{
name|special_symbol
argument_list|(
name|hp
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* This macro is being used inside a #if, which means it must be */
comment|/* recorded as a precondition.  */
if|if
condition|(
name|pcp_inside_if
operator|&&
name|pcp_outfile
operator|&&
name|defn
operator|->
name|predefined
condition|)
name|dump_single_macro
argument_list|(
name|hp
argument_list|,
name|pcp_outfile
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|defn
operator|->
name|nargs
expr_stmt|;
if|if
condition|(
name|nargs
operator|>=
literal|0
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|argdata
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
name|parse_error
init|=
literal|0
decl_stmt|;
name|args
operator|=
operator|(
expr|struct
name|argdata
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|nargs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|argdata
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|args
index|[
name|i
index|]
operator|.
name|raw
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
literal|""
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|expanded
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|raw_length
operator|=
name|args
index|[
name|i
index|]
operator|.
name|expand_length
operator|=
name|args
index|[
name|i
index|]
operator|.
name|stringified_length
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|free1
operator|=
name|args
index|[
name|i
index|]
operator|.
name|free2
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|use_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Parse all the macro args that are supplied.  I counts them.        The first NARGS args are stored in ARGS.        The rest are discarded.        If rest_args is set then we assume macarg absorbed the rest of the args.        */
name|i
operator|=
literal|0
expr_stmt|;
name|rest_args
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* Discard the open-parenthesis or comma before the next arg.  */
operator|++
name|instack
index|[
name|indepth
index|]
operator|.
name|bufp
expr_stmt|;
if|if
condition|(
name|rest_args
condition|)
continue|continue;
if|if
condition|(
name|i
operator|<
name|nargs
operator|||
operator|(
name|nargs
operator|==
literal|0
operator|&&
name|i
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* if we are working on last arg which absorbs rest of args... */
if|if
condition|(
name|i
operator|==
name|nargs
operator|-
literal|1
operator|&&
name|defn
operator|->
name|rest_args
condition|)
name|rest_args
operator|=
literal|1
expr_stmt|;
name|parse_error
operator|=
name|macarg
argument_list|(
operator|&
name|args
index|[
name|i
index|]
argument_list|,
name|rest_args
argument_list|)
expr_stmt|;
block|}
else|else
name|parse_error
operator|=
name|macarg
argument_list|(
name|NULL_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_error
condition|)
block|{
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
name|parse_error
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|instack
index|[
name|indepth
index|]
operator|.
name|bufp
operator|!=
literal|')'
condition|)
do|;
comment|/* If we got one arg but it was just whitespace, call that 0 args.  */
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
init|=
name|args
index|[
literal|0
index|]
operator|.
name|raw
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|lim
init|=
name|bp
operator|+
name|args
index|[
literal|0
index|]
operator|.
name|raw_length
decl_stmt|;
comment|/* cpp.texi says for foo ( ) we provide one argument. 	 However, if foo wants just 0 arguments, treat this as 0.  */
if|if
condition|(
name|nargs
operator|==
literal|0
condition|)
while|while
condition|(
name|bp
operator|!=
name|lim
operator|&&
name|is_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|lim
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Don't output an error message if we have already output one for        a parse error above.  */
name|rest_zero
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nargs
operator|==
literal|0
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|parse_error
condition|)
name|error
argument_list|(
literal|"arguments given to macro `%s'"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|<
name|nargs
condition|)
block|{
comment|/* traditional C allows foo() if foo wants one argument.  */
if|if
condition|(
name|nargs
operator|==
literal|1
operator|&&
name|i
operator|==
literal|0
operator|&&
name|traditional
condition|)
empty_stmt|;
comment|/* the rest args token is allowed to absorb 0 tokens */
elseif|else
if|if
condition|(
name|i
operator|==
name|nargs
operator|-
literal|1
operator|&&
name|defn
operator|->
name|rest_args
condition|)
name|rest_zero
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|parse_error
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"macro `%s' used without args"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|error
argument_list|(
literal|"macro `%s' used with just one arg"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"macro `%s' used with only %d args"
argument_list|,
name|hp
operator|->
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
name|nargs
condition|)
block|{
if|if
condition|(
operator|!
name|parse_error
condition|)
name|error
argument_list|(
literal|"macro `%s' used with too many (%d) args"
argument_list|,
name|hp
operator|->
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Swallow the closeparen.  */
operator|++
name|instack
index|[
name|indepth
index|]
operator|.
name|bufp
expr_stmt|;
comment|/* If macro wants zero args, we parsed the arglist for checking only.        Read directly from the macro definition.  */
if|if
condition|(
name|nargs
operator|==
literal|0
condition|)
block|{
name|xbuf
operator|=
name|defn
operator|->
name|expansion
expr_stmt|;
name|xbuf_len
operator|=
name|defn
operator|->
name|length
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|U_CHAR
modifier|*
name|exp
init|=
name|defn
operator|->
name|expansion
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|;
comment|/* offset in expansion, 				   copied a piece at a time */
specifier|register
name|int
name|totlen
decl_stmt|;
comment|/* total amount of exp buffer filled so far */
specifier|register
name|struct
name|reflist
modifier|*
name|ap
decl_stmt|,
modifier|*
name|last_ap
decl_stmt|;
comment|/* Macro really takes args.  Compute the expansion of this call.  */
comment|/* Compute length in characters of the macro's expansion. 	 Also count number of times each arg is used.  */
name|xbuf_len
operator|=
name|defn
operator|->
name|length
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|defn
operator|->
name|pattern
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|stringify
condition|)
name|xbuf_len
operator|+=
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|stringified_length
expr_stmt|;
elseif|else
if|if
condition|(
name|ap
operator|->
name|raw_before
operator|||
name|ap
operator|->
name|raw_after
operator|||
name|traditional
condition|)
comment|/* Add 4 for two newline-space markers to prevent 	     token concatenation.  */
name|xbuf_len
operator|+=
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|raw_length
operator|+
literal|4
expr_stmt|;
else|else
block|{
comment|/* We have an ordinary (expanded) occurrence of the arg. 	     So compute its expansion, if we have not already.  */
if|if
condition|(
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|expanded
operator|==
literal|0
condition|)
block|{
name|FILE_BUF
name|obuf
decl_stmt|;
name|obuf
operator|=
name|expand_to_temp_buffer
argument_list|(
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|raw
argument_list|,
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|raw
operator|+
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|raw_length
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|expanded
operator|=
name|obuf
operator|.
name|buf
expr_stmt|;
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|expand_length
operator|=
name|obuf
operator|.
name|length
expr_stmt|;
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|free2
operator|=
name|obuf
operator|.
name|buf
expr_stmt|;
block|}
comment|/* Add 4 for two newline-space markers to prevent 	     token concatenation.  */
name|xbuf_len
operator|+=
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|expand_length
operator|+
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|use_count
operator|<
literal|10
condition|)
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|use_count
operator|++
expr_stmt|;
block|}
name|xbuf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|xbuf_len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Generate in XBUF the complete expansion 	 with arguments substituted in. 	 TOTLEN is the total size generated so far. 	 OFFSET is the index in the definition 	 of where we are copying from.  */
name|offset
operator|=
name|totlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|last_ap
operator|=
name|NULL
operator|,
name|ap
operator|=
name|defn
operator|->
name|pattern
init|;
name|ap
operator|!=
name|NULL
condition|;
name|last_ap
operator|=
name|ap
operator|,
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
specifier|register
name|struct
name|argdata
modifier|*
name|arg
init|=
operator|&
name|args
index|[
name|ap
operator|->
name|argno
index|]
decl_stmt|;
name|int
name|count_before
init|=
name|totlen
decl_stmt|;
comment|/* Add chars to XBUF.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ap
operator|->
name|nchars
condition|;
name|i
operator|++
operator|,
name|offset
operator|++
control|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
name|exp
index|[
name|offset
index|]
expr_stmt|;
comment|/* If followed by an empty rest arg with concatenation, 	   delete the last run of nonwhite chars.  */
if|if
condition|(
name|rest_zero
operator|&&
name|totlen
operator|>
name|count_before
operator|&&
operator|(
operator|(
name|ap
operator|->
name|rest_args
operator|&&
name|ap
operator|->
name|raw_before
operator|)
operator|||
operator|(
name|last_ap
operator|!=
name|NULL
operator|&&
name|last_ap
operator|->
name|rest_args
operator|&&
name|last_ap
operator|->
name|raw_after
operator|)
operator|)
condition|)
block|{
comment|/* Delete final whitespace.  */
while|while
condition|(
name|totlen
operator|>
name|count_before
operator|&&
name|is_space
index|[
name|xbuf
index|[
name|totlen
operator|-
literal|1
index|]
index|]
condition|)
block|{
name|totlen
operator|--
expr_stmt|;
block|}
comment|/* Delete the nonwhites before them.  */
while|while
condition|(
name|totlen
operator|>
name|count_before
operator|&&
operator|!
name|is_space
index|[
name|xbuf
index|[
name|totlen
operator|-
literal|1
index|]
index|]
condition|)
block|{
name|totlen
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ap
operator|->
name|stringify
operator|!=
literal|0
condition|)
block|{
name|int
name|arglen
init|=
name|arg
operator|->
name|raw_length
decl_stmt|;
name|int
name|escaped
init|=
literal|0
decl_stmt|;
name|int
name|in_string
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|arglen
operator|&&
operator|(
name|c
operator|=
name|arg
operator|->
name|raw
index|[
name|i
index|]
operator|,
name|is_space
index|[
name|c
index|]
operator|)
condition|)
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|arglen
operator|&&
operator|(
name|c
operator|=
name|arg
operator|->
name|raw
index|[
name|arglen
operator|-
literal|1
index|]
operator|,
name|is_space
index|[
name|c
index|]
operator|)
condition|)
name|arglen
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
condition|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|'\"'
expr_stmt|;
comment|/* insert beginning quote */
for|for
control|(
init|;
name|i
operator|<
name|arglen
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|arg
operator|->
name|raw
index|[
name|i
index|]
expr_stmt|;
comment|/* Special markers Newline Space 	       generate nothing for a stringified argument.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|arg
operator|->
name|raw
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Internal sequences of whitespace are replaced by one space 	       except within an string or char token.  */
if|if
condition|(
operator|!
name|in_string
operator|&&
operator|(
name|c
operator|==
literal|'\n'
condition|?
name|arg
operator|->
name|raw
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\n'
else|:
name|is_space
index|[
name|c
index|]
operator|)
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Note that Newline Space does occur within whitespace 		   sequences; consider it part of the sequence.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|is_space
index|[
name|arg
operator|->
name|raw
index|[
name|i
operator|+
literal|1
index|]
index|]
condition|)
name|i
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|is_space
index|[
name|c
index|]
condition|)
name|i
operator|++
expr_stmt|;
else|else
break|break;
name|c
operator|=
name|arg
operator|->
name|raw
index|[
name|i
index|]
expr_stmt|;
block|}
name|i
operator|--
expr_stmt|;
name|c
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|escaped
condition|)
name|escaped
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|escaped
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|in_string
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|in_string
condition|)
name|in_string
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\''
condition|)
name|in_string
operator|=
name|c
expr_stmt|;
block|}
comment|/* Escape these chars */
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
operator|(
name|in_string
operator|&&
name|c
operator|==
literal|'\\'
operator|)
condition|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
name|c
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|xbuf
index|[
name|totlen
index|]
argument_list|,
literal|"\\%03o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
name|totlen
operator|+=
literal|4
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|traditional
condition|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|'\"'
expr_stmt|;
comment|/* insert ending quote */
block|}
elseif|else
if|if
condition|(
name|ap
operator|->
name|raw_before
operator|||
name|ap
operator|->
name|raw_after
operator|||
name|traditional
condition|)
block|{
name|U_CHAR
modifier|*
name|p1
init|=
name|arg
operator|->
name|raw
decl_stmt|;
name|U_CHAR
modifier|*
name|l1
init|=
name|p1
operator|+
name|arg
operator|->
name|raw_length
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|raw_before
condition|)
block|{
while|while
condition|(
name|p1
operator|!=
name|l1
operator|&&
name|is_space
index|[
operator|*
name|p1
index|]
condition|)
name|p1
operator|++
expr_stmt|;
while|while
condition|(
name|p1
operator|!=
name|l1
operator|&&
name|is_idchar
index|[
operator|*
name|p1
index|]
condition|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
comment|/* Delete any no-reexpansion marker that follows 	       an identifier at the beginning of the argument 	       if the argument is concatenated with what precedes it.  */
if|if
condition|(
name|p1
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|&&
name|p1
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
name|p1
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
comment|/* Ordinary expanded use of the argument. 	     Put in newline-space markers to prevent token pasting.  */
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|raw_after
condition|)
block|{
comment|/* Arg is concatenated after: delete trailing whitespace, 	       whitespace markers, and no-reexpansion markers.  */
while|while
condition|(
name|p1
operator|!=
name|l1
condition|)
block|{
if|if
condition|(
name|is_space
index|[
name|l1
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|l1
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|l1
index|[
operator|-
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|U_CHAR
modifier|*
name|p2
init|=
name|l1
operator|-
literal|1
decl_stmt|;
comment|/* If a `-' is preceded by an odd number of newlines then it 		   and the last newline are a no-reexpansion marker.  */
while|while
condition|(
name|p2
operator|!=
name|p1
operator|&&
name|p2
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|p2
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|l1
operator|-
literal|1
operator|-
name|p2
operator|)
operator|&
literal|1
condition|)
block|{
name|l1
operator|-=
literal|2
expr_stmt|;
block|}
else|else
break|break;
block|}
else|else
break|break;
block|}
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p1
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|xbuf
operator|+
name|totlen
operator|)
argument_list|,
name|l1
operator|-
name|p1
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|l1
operator|-
name|p1
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
operator|&&
operator|!
name|ap
operator|->
name|raw_after
condition|)
block|{
comment|/* Ordinary expanded use of the argument. 	       Put in newline-space markers to prevent token pasting.  */
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Ordinary expanded use of the argument. 	     Put in newline-space markers to prevent token pasting.  */
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|->
name|expanded
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|xbuf
operator|+
name|totlen
operator|)
argument_list|,
name|arg
operator|->
name|expand_length
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|arg
operator|->
name|expand_length
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
comment|/* If a macro argument with newlines is used multiple times, 	     then only expand the newlines once.  This avoids creating output 	     lines which don't correspond to any input line, which confuses 	     gdb and gcov.  */
if|if
condition|(
name|arg
operator|->
name|use_count
operator|>
literal|1
operator|&&
name|arg
operator|->
name|newlines
operator|>
literal|0
condition|)
block|{
comment|/* Don't bother doing change_newlines for subsequent 	       uses of arg.  */
name|arg
operator|->
name|use_count
operator|=
literal|1
expr_stmt|;
name|arg
operator|->
name|expand_length
operator|=
name|change_newlines
argument_list|(
name|arg
operator|->
name|expanded
argument_list|,
name|arg
operator|->
name|expand_length
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|totlen
operator|>
name|xbuf_len
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* if there is anything left of the definition 	 after handling the arg list, copy that in too. */
for|for
control|(
name|i
operator|=
name|offset
init|;
name|i
operator|<
name|defn
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
comment|/* if we've reached the end of the macro */
if|if
condition|(
name|exp
index|[
name|i
index|]
operator|==
literal|')'
condition|)
name|rest_zero
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rest_zero
operator|&&
name|last_ap
operator|!=
name|NULL
operator|&&
name|last_ap
operator|->
name|rest_args
operator|&&
name|last_ap
operator|->
name|raw_after
operator|)
condition|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
name|exp
index|[
name|i
index|]
expr_stmt|;
block|}
name|xbuf
index|[
name|totlen
index|]
operator|=
literal|0
expr_stmt|;
name|xbuf_len
operator|=
name|totlen
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|free1
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|free1
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|free2
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|free2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|xbuf
operator|=
name|defn
operator|->
name|expansion
expr_stmt|;
name|xbuf_len
operator|=
name|defn
operator|->
name|length
expr_stmt|;
block|}
comment|/* Now put the expansion on the input stack      so our caller will commence reading from it.  */
block|{
specifier|register
name|FILE_BUF
modifier|*
name|ip2
decl_stmt|;
name|ip2
operator|=
operator|&
name|instack
index|[
operator|++
name|indepth
index|]
expr_stmt|;
name|ip2
operator|->
name|fname
operator|=
literal|0
expr_stmt|;
name|ip2
operator|->
name|nominal_fname
operator|=
literal|0
expr_stmt|;
comment|/* This may not be exactly correct, but will give much better error        messages for nested macro calls than using a line number of zero.  */
name|ip2
operator|->
name|lineno
operator|=
name|start_line
expr_stmt|;
name|ip2
operator|->
name|buf
operator|=
name|xbuf
expr_stmt|;
name|ip2
operator|->
name|length
operator|=
name|xbuf_len
expr_stmt|;
name|ip2
operator|->
name|bufp
operator|=
name|xbuf
expr_stmt|;
name|ip2
operator|->
name|free_ptr
operator|=
operator|(
name|nargs
operator|>
literal|0
operator|)
condition|?
name|xbuf
else|:
literal|0
expr_stmt|;
name|ip2
operator|->
name|macro
operator|=
name|hp
expr_stmt|;
name|ip2
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
name|ip2
operator|->
name|system_header_p
operator|=
literal|0
expr_stmt|;
comment|/* Recursive macro use sometimes works traditionally.        #define foo(x,y) bar (x (y,0), y)        foo (foo, baz)  */
if|if
condition|(
operator|!
name|traditional
condition|)
name|hp
operator|->
name|type
operator|=
name|T_DISABLED
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Parse a macro argument and store the info on it into *ARGPTR.  * REST_ARGS is passed to macarg1 to make it absorb the rest of the args.  * Return nonzero to indicate a syntax error.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|macarg
parameter_list|(
name|argptr
parameter_list|,
name|rest_args
parameter_list|)
specifier|register
name|struct
name|argdata
modifier|*
name|argptr
decl_stmt|;
name|int
name|rest_args
decl_stmt|;
block|{
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
name|int
name|paren
init|=
literal|0
decl_stmt|;
name|int
name|newlines
init|=
literal|0
decl_stmt|;
name|int
name|comments
init|=
literal|0
decl_stmt|;
comment|/* Try to parse as much of the argument as exists at this      input stack level.  */
name|U_CHAR
modifier|*
name|bp
init|=
name|macarg1
argument_list|(
name|ip
operator|->
name|bufp
argument_list|,
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
argument_list|,
operator|&
name|paren
argument_list|,
operator|&
name|newlines
argument_list|,
operator|&
name|comments
argument_list|,
name|rest_args
argument_list|)
decl_stmt|;
comment|/* If we find the end of the argument at this level,      set up *ARGPTR to point at it in the input stack.  */
if|if
condition|(
operator|!
operator|(
name|ip
operator|->
name|fname
operator|!=
literal|0
operator|&&
operator|(
name|newlines
operator|!=
literal|0
operator|||
name|comments
operator|!=
literal|0
operator|)
operator|)
operator|&&
name|bp
operator|!=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
condition|)
block|{
if|if
condition|(
name|argptr
operator|!=
literal|0
condition|)
block|{
name|argptr
operator|->
name|raw
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
name|argptr
operator|->
name|raw_length
operator|=
name|bp
operator|-
name|ip
operator|->
name|bufp
expr_stmt|;
name|argptr
operator|->
name|newlines
operator|=
name|newlines
expr_stmt|;
block|}
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
block|}
else|else
block|{
comment|/* This input stack level ends before the macro argument does.        We must pop levels and keep parsing.        Therefore, we must allocate a temporary buffer and copy        the macro argument into it.  */
name|int
name|bufsize
init|=
name|bp
operator|-
name|ip
operator|->
name|bufp
decl_stmt|;
name|int
name|extra
init|=
name|newlines
decl_stmt|;
name|U_CHAR
modifier|*
name|buffer
init|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|bufsize
operator|+
name|extra
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|final_start
init|=
literal|0
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|->
name|bufp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
name|ip
operator|->
name|lineno
operator|+=
name|newlines
expr_stmt|;
while|while
condition|(
name|bp
operator|==
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
condition|)
block|{
if|if
condition|(
name|instack
index|[
name|indepth
index|]
operator|.
name|macro
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
literal|"unterminated macro call"
return|;
block|}
name|ip
operator|->
name|macro
operator|->
name|type
operator|=
name|T_MACRO
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|free_ptr
condition|)
name|free
argument_list|(
name|ip
operator|->
name|free_ptr
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|&
name|instack
index|[
operator|--
name|indepth
index|]
expr_stmt|;
name|newlines
operator|=
literal|0
expr_stmt|;
name|comments
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|macarg1
argument_list|(
name|ip
operator|->
name|bufp
argument_list|,
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
argument_list|,
operator|&
name|paren
argument_list|,
operator|&
name|newlines
argument_list|,
operator|&
name|comments
argument_list|,
name|rest_args
argument_list|)
expr_stmt|;
name|final_start
operator|=
name|bufsize
expr_stmt|;
name|bufsize
operator|+=
name|bp
operator|-
name|ip
operator|->
name|bufp
expr_stmt|;
name|extra
operator|+=
name|newlines
expr_stmt|;
name|buffer
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|bufsize
operator|+
name|extra
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|->
name|bufp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|buffer
operator|+
name|bufsize
operator|-
operator|(
name|bp
operator|-
name|ip
operator|->
name|bufp
operator|)
operator|)
argument_list|,
name|bp
operator|-
name|ip
operator|->
name|bufp
argument_list|)
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
name|ip
operator|->
name|lineno
operator|+=
name|newlines
expr_stmt|;
block|}
comment|/* Now, if arg is actually wanted, record its raw form,        discarding comments and duplicating newlines in whatever        part of it did not come from a macro expansion.        EXTRA space has been preallocated for duplicating the newlines.        FINAL_START is the index of the start of that part.  */
if|if
condition|(
name|argptr
operator|!=
literal|0
condition|)
block|{
name|argptr
operator|->
name|raw
operator|=
name|buffer
expr_stmt|;
name|argptr
operator|->
name|raw_length
operator|=
name|bufsize
expr_stmt|;
name|argptr
operator|->
name|free1
operator|=
name|buffer
expr_stmt|;
name|argptr
operator|->
name|newlines
operator|=
name|newlines
expr_stmt|;
name|argptr
operator|->
name|comments
operator|=
name|comments
expr_stmt|;
if|if
condition|(
operator|(
name|newlines
operator|||
name|comments
operator|)
operator|&&
name|ip
operator|->
name|fname
operator|!=
literal|0
condition|)
name|argptr
operator|->
name|raw_length
operator|=
name|final_start
operator|+
name|discard_comments
argument_list|(
name|argptr
operator|->
name|raw
operator|+
name|final_start
argument_list|,
name|argptr
operator|->
name|raw_length
operator|-
name|final_start
argument_list|,
name|newlines
argument_list|)
expr_stmt|;
name|argptr
operator|->
name|raw
index|[
name|argptr
operator|->
name|raw_length
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argptr
operator|->
name|raw_length
operator|>
name|bufsize
operator|+
name|extra
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If we are not discarding this argument,      macroexpand it and compute its length as stringified.      All this info goes into *ARGPTR.  */
if|if
condition|(
name|argptr
operator|!=
literal|0
condition|)
block|{
specifier|register
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|lim
decl_stmt|;
specifier|register
name|int
name|totlen
decl_stmt|;
name|buf
operator|=
name|argptr
operator|->
name|raw
expr_stmt|;
name|lim
operator|=
name|buf
operator|+
name|argptr
operator|->
name|raw_length
expr_stmt|;
while|while
condition|(
name|buf
operator|!=
name|lim
operator|&&
name|is_space
index|[
operator|*
name|buf
index|]
condition|)
name|buf
operator|++
expr_stmt|;
while|while
condition|(
name|buf
operator|!=
name|lim
operator|&&
name|is_space
index|[
name|lim
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|lim
operator|--
expr_stmt|;
name|totlen
operator|=
name|traditional
condition|?
literal|0
else|:
literal|2
expr_stmt|;
comment|/* Count opening and closing quote.  */
while|while
condition|(
name|buf
operator|!=
name|lim
condition|)
block|{
specifier|register
name|U_CHAR
name|c
init|=
operator|*
name|buf
operator|++
decl_stmt|;
name|totlen
operator|++
expr_stmt|;
comment|/* Internal sequences of whitespace are replaced by one space 	 in most cases, but not always.  So count all the whitespace 	 in case we need to keep it all.  */
if|#
directive|if
literal|0
block|if (is_space[c]) 	SKIP_ALL_WHITE_SPACE (buf);       else
endif|#
directive|endif
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\\'
condition|)
comment|/* escape these chars */
name|totlen
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|totlen
operator|+=
literal|3
expr_stmt|;
block|}
name|argptr
operator|->
name|stringified_length
operator|=
name|totlen
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Scan text from START (inclusive) up to LIMIT (exclusive),    counting parens in *DEPTHPTR,    and return if reach LIMIT    or before a `)' that would make *DEPTHPTR negative    or before a comma when *DEPTHPTR is zero.    Single and double quotes are matched and termination    is inhibited within them.  Comments also inhibit it.    Value returned is pointer to stopping place.     Increment *NEWLINES each time a newline is passed.    REST_ARGS notifies macarg1 that it should absorb the rest of the args.    Set *COMMENTS to 1 if a comment is seen.  */
end_comment

begin_function
specifier|static
name|U_CHAR
modifier|*
name|macarg1
parameter_list|(
name|start
parameter_list|,
name|limit
parameter_list|,
name|depthptr
parameter_list|,
name|newlines
parameter_list|,
name|comments
parameter_list|,
name|rest_args
parameter_list|)
name|U_CHAR
modifier|*
name|start
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
name|int
modifier|*
name|depthptr
decl_stmt|,
decl|*
name|newlines
decl_stmt|,
modifier|*
name|comments
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|rest_args
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
init|=
name|start
decl_stmt|;
while|while
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
switch|switch
condition|(
operator|*
name|bp
condition|)
block|{
case|case
literal|'('
case|:
operator|(
operator|*
name|depthptr
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
operator|--
operator|(
operator|*
name|depthptr
operator|)
operator|<
literal|0
condition|)
return|return
name|bp
return|;
break|break;
case|case
literal|'\\'
case|:
comment|/* Traditionally, backslash makes following char not special.  */
if|if
condition|(
name|bp
operator|+
literal|1
operator|<
name|limit
operator|&&
name|traditional
condition|)
block|{
name|bp
operator|++
expr_stmt|;
comment|/* But count source lines anyway.  */
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
operator|++
operator|*
name|newlines
expr_stmt|;
block|}
break|break;
case|case
literal|'\n'
case|:
operator|++
operator|*
name|newlines
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|bp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|bp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cplusplus_comments
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
operator|*
name|comments
operator|=
literal|1
expr_stmt|;
name|bp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|bp
operator|<
name|limit
operator|&&
operator|(
operator|*
name|bp
operator|!=
literal|'\n'
operator|||
name|bp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
operator|++
operator|*
name|newlines
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|bp
index|[
literal|1
index|]
operator|!=
literal|'*'
operator|||
name|bp
operator|+
literal|1
operator|>=
name|limit
condition|)
break|break;
operator|*
name|comments
operator|=
literal|1
expr_stmt|;
name|bp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|bp
operator|+
literal|1
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|bp
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|bp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
break|break;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
operator|++
operator|*
name|newlines
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
block|{
name|int
name|quotec
decl_stmt|;
for|for
control|(
name|quotec
operator|=
operator|*
name|bp
operator|++
init|;
name|bp
operator|+
literal|1
operator|<
name|limit
operator|&&
operator|*
name|bp
operator|!=
name|quotec
condition|;
name|bp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
condition|)
block|{
name|bp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
operator|++
operator|*
name|newlines
expr_stmt|;
while|while
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|bp
operator|+=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
block|{
operator|++
operator|*
name|newlines
expr_stmt|;
if|if
condition|(
name|quotec
operator|==
literal|'\''
condition|)
break|break;
block|}
block|}
block|}
break|break;
case|case
literal|','
case|:
comment|/* if we've returned to lowest level and we aren't absorbing all args */
if|if
condition|(
operator|(
operator|*
name|depthptr
operator|)
operator|==
literal|0
operator|&&
name|rest_args
operator|==
literal|0
condition|)
return|return
name|bp
return|;
break|break;
block|}
name|bp
operator|++
expr_stmt|;
block|}
return|return
name|bp
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Discard comments and duplicate newlines    in the string of length LENGTH at START,    except inside of string constants.    The string is copied into itself with its beginning staying fixed.       NEWLINES is the number of newlines that must be duplicated.    We assume that that much extra space is available past the end    of the string.  */
end_comment

begin_function
specifier|static
name|int
name|discard_comments
parameter_list|(
name|start
parameter_list|,
name|length
parameter_list|,
name|newlines
parameter_list|)
name|U_CHAR
modifier|*
name|start
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|newlines
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|ibp
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|obp
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
comment|/* If we have newlines to duplicate, copy everything      that many characters up.  Then, in the second part,      we will have room to insert the newlines      while copying down.      NEWLINES may actually be too large, because it counts      newlines in string constants, and we don't duplicate those.      But that does no harm.  */
if|if
condition|(
name|newlines
operator|>
literal|0
condition|)
block|{
name|ibp
operator|=
name|start
operator|+
name|length
expr_stmt|;
name|obp
operator|=
name|ibp
operator|+
name|newlines
expr_stmt|;
name|limit
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|limit
operator|!=
name|ibp
condition|)
operator|*
operator|--
name|obp
operator|=
operator|*
operator|--
name|ibp
expr_stmt|;
block|}
name|ibp
operator|=
name|start
operator|+
name|newlines
expr_stmt|;
name|limit
operator|=
name|start
operator|+
name|length
operator|+
name|newlines
expr_stmt|;
name|obp
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* Duplicate the newline.  */
operator|*
name|obp
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
block|{
name|obp
operator|--
expr_stmt|;
name|ibp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
comment|/* Delete any comment.  */
if|if
condition|(
name|cplusplus_comments
operator|&&
name|ibp
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* Comments are equivalent to spaces.  */
name|obp
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|ibp
operator|++
expr_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
operator|&&
operator|(
operator|*
name|ibp
operator|!=
literal|'\n'
operator|||
name|ibp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
operator|)
condition|)
name|ibp
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ibp
index|[
literal|0
index|]
operator|!=
literal|'*'
operator|||
name|ibp
operator|+
literal|1
operator|>=
name|limit
condition|)
break|break;
comment|/* Comments are equivalent to spaces.  */
name|obp
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|ibp
operator|++
expr_stmt|;
while|while
condition|(
name|ibp
operator|+
literal|1
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|ibp
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|ibp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibp
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
break|break;
name|ibp
operator|++
expr_stmt|;
block|}
name|ibp
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
comment|/* Notice and skip strings, so that we don't 	 think that comments start inside them, 	 and so we don't duplicate newlines in them.  */
block|{
name|int
name|quotec
init|=
name|c
decl_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|quotec
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|quotec
operator|==
literal|'\''
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|ibp
operator|<
name|limit
condition|)
block|{
while|while
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|ibp
operator|+=
literal|2
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
block|}
return|return
name|obp
operator|-
name|start
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Turn newlines to spaces in the string of length LENGTH at START,    except inside of string constants.    The string is copied into itself with its beginning staying fixed.  */
end_comment

begin_function
specifier|static
name|int
name|change_newlines
parameter_list|(
name|start
parameter_list|,
name|length
parameter_list|)
name|U_CHAR
modifier|*
name|start
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|ibp
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|obp
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|ibp
operator|=
name|start
expr_stmt|;
name|limit
operator|=
name|start
operator|+
name|length
expr_stmt|;
name|obp
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* If this is a NEWLINE NEWLINE, then this is a real newline in the 	 string.  Skip past the newline and its duplicate. 	 Put a space in the output.  */
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
block|{
name|ibp
operator|++
expr_stmt|;
name|obp
operator|--
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
break|break;
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
comment|/* Notice and skip strings, so that we don't delete newlines in them.  */
block|{
name|int
name|quotec
init|=
name|c
decl_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|quotec
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|quotec
operator|==
literal|'\''
condition|)
break|break;
block|}
block|}
break|break;
block|}
block|}
return|return
name|obp
operator|-
name|start
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * my_strerror - return the descriptive text associated with an `errno' code.  */
end_comment

begin_function
name|char
modifier|*
name|my_strerror
parameter_list|(
name|errnum
parameter_list|)
name|int
name|errnum
decl_stmt|;
block|{
name|char
modifier|*
name|result
decl_stmt|;
ifndef|#
directive|ifndef
name|VMS
ifndef|#
directive|ifndef
name|HAVE_STRERROR
name|result
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|errnum
operator|<
name|sys_nerr
operator|)
condition|?
name|sys_errlist
index|[
name|errnum
index|]
else|:
literal|0
operator|)
expr_stmt|;
else|#
directive|else
name|result
operator|=
name|strerror
argument_list|(
name|errnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* VMS */
comment|/* VAXCRTL's strerror() takes an optional second argument, which only      matters when the first argument is EVMSERR.  However, it's simplest      just to pass it unconditionally.  `vaxc$errno' is declared in<errno.h>, and maintained by the library in parallel with `errno'.      We assume that caller's `errnum' either matches the last setting of      `errno' by the library or else does not have the value `EVMSERR'.  */
name|result
operator|=
name|strerror
argument_list|(
name|errnum
argument_list|,
name|vaxc$errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|result
condition|)
name|result
operator|=
literal|"undocumented I/O error"
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * error - print error message and increment count of errors.  */
end_comment

begin_function
name|void
name|error
parameter_list|(
name|msg
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
name|char
modifier|*
name|arg1
decl_stmt|,
decl|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|print_containing_files
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|,
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Error including a message from `errno'.  */
end_comment

begin_function
specifier|static
name|void
name|error_from_errno
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|print_containing_files
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|,
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|name
argument_list|,
name|my_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print error message but don't count it.  */
end_comment

begin_function
name|void
name|warning
parameter_list|(
name|msg
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
name|char
modifier|*
name|arg1
decl_stmt|,
decl|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|inhibit_warnings
condition|)
return|return;
if|if
condition|(
name|warnings_are_errors
condition|)
name|errors
operator|++
expr_stmt|;
name|print_containing_files
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|,
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|error_with_line
parameter_list|(
name|line
parameter_list|,
name|msg
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|char
modifier|*
name|arg1
decl_stmt|,
decl|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|print_containing_files
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|warning_with_line
parameter_list|(
name|line
parameter_list|,
name|msg
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|char
modifier|*
name|arg1
decl_stmt|,
decl|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|inhibit_warnings
condition|)
return|return;
if|if
condition|(
name|warnings_are_errors
condition|)
name|errors
operator|++
expr_stmt|;
name|print_containing_files
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* print an error message and maybe count it.  */
end_comment

begin_function
name|void
name|pedwarn
parameter_list|(
name|msg
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
name|char
modifier|*
name|arg1
decl_stmt|,
decl|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|pedantic_errors
condition|)
name|error
argument_list|(
name|msg
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
name|msg
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|pedwarn_with_line
parameter_list|(
name|line
parameter_list|,
name|msg
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|char
modifier|*
name|arg1
decl_stmt|,
decl|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|pedantic_errors
condition|)
name|error_with_line
argument_list|(
name|line
argument_list|,
name|msg
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
else|else
name|warning_with_line
argument_list|(
name|line
argument_list|,
name|msg
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Report a warning (or an error if pedantic_errors)    giving specified file name and line number, not current.  */
end_comment

begin_function
specifier|static
name|void
name|pedwarn_with_file_and_line
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|,
name|msg
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|char
modifier|*
name|arg1
decl_stmt|,
decl|*
name|arg2
decl_stmt|,
modifier|*
name|arg3
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
operator|!
name|pedantic_errors
operator|&&
name|inhibit_warnings
condition|)
return|return;
if|if
condition|(
name|file
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|pedantic_errors
condition|)
name|errors
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|pedantic_errors
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Print the file names and line numbers of the #include    commands which led to the current file.  */
end_comment

begin_function
specifier|static
name|void
name|print_containing_files
parameter_list|()
block|{
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
comment|/* If stack of files hasn't changed since we last printed      this info, don't repeat it.  */
if|if
condition|(
name|last_error_tick
operator|==
name|input_file_stack_tick
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
comment|/* Give up if we don't find a source file.  */
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
return|return;
comment|/* Find the other, outer source files.  */
for|for
control|(
name|i
operator|--
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In file included"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|",\n                "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" from %s:%d"
argument_list|,
name|ip
operator|->
name|nominal_fname
argument_list|,
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|first
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|":\n"
argument_list|)
expr_stmt|;
comment|/* Record we have printed the status as of this time.  */
name|last_error_tick
operator|=
name|input_file_stack_tick
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the line at which an error occurred.    The error is not necessarily associated with the current spot    in the input stack, so LINE says where.  LINE will have been    copied from ip->lineno for the current input level.    If the current level is for a file, we return LINE.    But if the current level is not for a file, LINE is meaningless.    In that case, we return the lineno of the innermost file.  */
end_comment

begin_function
specifier|static
name|int
name|line_for_error
parameter_list|(
name|line
parameter_list|)
name|int
name|line
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|line1
init|=
name|line
decl_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
literal|0
condition|)
return|return
name|line1
return|;
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|line1
operator|=
name|instack
index|[
name|i
index|]
operator|.
name|lineno
expr_stmt|;
block|}
name|abort
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * If OBUF doesn't have NEEDED bytes after OPTR, make it bigger.  *  * As things stand, nothing is ever placed in the output buffer to be  * removed again except when it's KNOWN to be part of an identifier,  * so flushing and moving down everything left, instead of expanding,  * should work ok.  */
end_comment

begin_comment
comment|/* You might think void was cleaner for the return type,    but that would get type mismatch in check_expand in strict ANSI.  */
end_comment

begin_function
specifier|static
name|int
name|grow_outbuf
parameter_list|(
name|obuf
parameter_list|,
name|needed
parameter_list|)
specifier|register
name|FILE_BUF
modifier|*
name|obuf
decl_stmt|;
specifier|register
name|int
name|needed
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|p
decl_stmt|;
name|int
name|minsize
decl_stmt|;
if|if
condition|(
name|obuf
operator|->
name|length
operator|-
operator|(
name|obuf
operator|->
name|bufp
operator|-
name|obuf
operator|->
name|buf
operator|)
operator|>
name|needed
condition|)
return|return
literal|0
return|;
comment|/* Make it at least twice as big as it is now.  */
name|obuf
operator|->
name|length
operator|*=
literal|2
expr_stmt|;
comment|/* Make it have at least 150% of the free space we will need.  */
name|minsize
operator|=
operator|(
literal|3
operator|*
name|needed
operator|)
operator|/
literal|2
operator|+
operator|(
name|obuf
operator|->
name|bufp
operator|-
name|obuf
operator|->
name|buf
operator|)
expr_stmt|;
if|if
condition|(
name|minsize
operator|>
name|obuf
operator|->
name|length
condition|)
name|obuf
operator|->
name|length
operator|=
name|minsize
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|obuf
operator|->
name|buf
argument_list|,
name|obuf
operator|->
name|length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|obuf
operator|->
name|bufp
operator|=
name|p
operator|+
operator|(
name|obuf
operator|->
name|bufp
operator|-
name|obuf
operator|->
name|buf
operator|)
expr_stmt|;
name|obuf
operator|->
name|buf
operator|=
name|p
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Symbol table for macro names and special symbols */
end_comment

begin_comment
comment|/*  * install a name in the main hash table, even if it is already there.  *   name stops with first non alphanumeric, except leading '#'.  * caller must check against redefinition if that is desired.  * delete_macro () removes things installed by install () in fifo order.  * this is important because of the `defined' special symbol used  * in #if, and also if pushdef/popdef directives are ever implemented.  *  * If LEN is>= 0, it is the length of the name.  * Otherwise, compute the length by scanning the entire name.  *  * If HASH is>= 0, it is the precomputed hash code.  * Otherwise, compute the hash code.  */
end_comment

begin_function
specifier|static
name|HASHNODE
modifier|*
name|install
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|type
parameter_list|,
name|ivalue
parameter_list|,
name|value
parameter_list|,
name|hash
parameter_list|)
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|enum
name|node_type
name|type
decl_stmt|;
name|int
name|ivalue
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|hash
decl_stmt|;
block|{
specifier|register
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|bucket
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|p
operator|=
name|name
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
name|p
operator|++
expr_stmt|;
name|len
operator|=
name|p
operator|-
name|name
expr_stmt|;
block|}
if|if
condition|(
name|hash
operator|<
literal|0
condition|)
name|hash
operator|=
name|hashf
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|HASHSIZE
argument_list|)
expr_stmt|;
name|i
operator|=
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
operator|+
name|len
operator|+
literal|1
expr_stmt|;
name|hp
operator|=
operator|(
name|HASHNODE
operator|*
operator|)
name|xmalloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|hash
expr_stmt|;
name|hp
operator|->
name|bucket_hdr
operator|=
operator|&
name|hashtab
index|[
name|bucket
index|]
expr_stmt|;
name|hp
operator|->
name|next
operator|=
name|hashtab
index|[
name|bucket
index|]
expr_stmt|;
name|hashtab
index|[
name|bucket
index|]
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|next
operator|->
name|prev
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|hp
operator|->
name|length
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_CONST
condition|)
name|hp
operator|->
name|value
operator|.
name|ival
operator|=
name|ivalue
expr_stmt|;
else|else
name|hp
operator|->
name|value
operator|.
name|cpval
operator|=
name|value
expr_stmt|;
name|hp
operator|->
name|name
operator|=
operator|(
operator|(
name|U_CHAR
operator|*
operator|)
name|hp
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
expr_stmt|;
name|p
operator|=
name|hp
operator|->
name|name
expr_stmt|;
name|q
operator|=
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
name|hp
operator|->
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|hp
return|;
block|}
end_function

begin_comment
comment|/*  * find the most recent hash node for name name (ending with first  * non-identifier char) installed by install  *  * If LEN is>= 0, it is the length of the name.  * Otherwise, compute the length by scanning the entire name.  *  * If HASH is>= 0, it is the precomputed hash code.  * Otherwise, compute the hash code.  */
end_comment

begin_function
name|HASHNODE
modifier|*
name|lookup
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|hash
parameter_list|)
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|hash
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
specifier|register
name|HASHNODE
modifier|*
name|bucket
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|bp
operator|=
name|name
init|;
name|is_idchar
index|[
operator|*
name|bp
index|]
condition|;
name|bp
operator|++
control|)
empty_stmt|;
name|len
operator|=
name|bp
operator|-
name|name
expr_stmt|;
block|}
if|if
condition|(
name|hash
operator|<
literal|0
condition|)
name|hash
operator|=
name|hashf
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|HASHSIZE
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|hashtab
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|bucket
condition|)
block|{
if|if
condition|(
name|bucket
operator|->
name|length
operator|==
name|len
operator|&&
name|strncmp
argument_list|(
name|bucket
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|bucket
return|;
name|bucket
operator|=
name|bucket
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Delete a hash node.  Some weirdness to free junk from macros.  * More such weirdness will have to be added if you define more hash  * types that need it.  */
end_comment

begin_comment
comment|/* Note that the DEFINITION of a macro is removed from the hash table    but its storage is not freed.  This would be a storage leak    except that it is not reasonable to keep undefining and redefining    large numbers of macros many times.    In any case, this is necessary, because a macro can be #undef'd    in the middle of reading the arguments to a call to it.    If #undef freed the DEFINITION, that would crash.  */
end_comment

begin_function
specifier|static
name|void
name|delete_macro
parameter_list|(
name|hp
parameter_list|)
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
block|{
if|if
condition|(
name|hp
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|prev
operator|->
name|next
operator|=
name|hp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|next
operator|->
name|prev
operator|=
name|hp
operator|->
name|prev
expr_stmt|;
comment|/* make sure that the bucket chain header that      the deleted guy was on points to the right thing afterwards. */
if|if
condition|(
name|hp
operator|==
operator|*
name|hp
operator|->
name|bucket_hdr
condition|)
operator|*
name|hp
operator|->
name|bucket_hdr
operator|=
name|hp
operator|->
name|next
expr_stmt|;
if|#
directive|if
literal|0
block|if (hp->type == T_MACRO) {     DEFINITION *d = hp->value.defn;     struct reflist *ap, *nextap;      for (ap = d->pattern; ap != NULL; ap = nextap) {       nextap = ap->next;       free (ap);     }     free (d);   }
endif|#
directive|endif
name|free
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * return hash function on name.  must be compatible with the one  * computed a step at a time, elsewhere  */
end_comment

begin_function
specifier|static
name|int
name|hashf
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|hashsize
parameter_list|)
specifier|register
name|U_CHAR
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|int
name|hashsize
decl_stmt|;
block|{
specifier|register
name|int
name|r
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|r
operator|=
name|HASHSTEP
argument_list|(
name|r
argument_list|,
operator|*
name|name
operator|++
argument_list|)
expr_stmt|;
return|return
name|MAKE_POS
argument_list|(
name|r
argument_list|)
operator|%
name|hashsize
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Dump the definition of a single macro HP to OF.  */
end_comment

begin_function
specifier|static
name|void
name|dump_single_macro
parameter_list|(
name|hp
parameter_list|,
name|of
parameter_list|)
specifier|register
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|FILE
modifier|*
name|of
decl_stmt|;
block|{
specifier|register
name|DEFINITION
modifier|*
name|defn
init|=
name|hp
operator|->
name|value
operator|.
name|defn
decl_stmt|;
name|struct
name|reflist
modifier|*
name|ap
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|concat
decl_stmt|;
comment|/* Print the definition of the macro HP.  */
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"#define %s"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|defn
operator|->
name|nargs
operator|>=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|defn
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|dump_arg_n
argument_list|(
name|defn
argument_list|,
name|i
argument_list|,
name|of
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|defn
operator|->
name|nargs
condition|)
name|fprintf
argument_list|(
name|of
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|of
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|of
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|concat
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|defn
operator|->
name|pattern
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
name|dump_defn_1
argument_list|(
name|defn
operator|->
name|expansion
argument_list|,
name|offset
argument_list|,
name|ap
operator|->
name|nchars
argument_list|,
name|of
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ap
operator|->
name|nchars
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|nchars
operator|!=
literal|0
condition|)
name|concat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|stringify
condition|)
name|fprintf
argument_list|(
name|of
argument_list|,
literal|" #"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|raw_before
operator|&&
operator|!
name|concat
condition|)
name|fprintf
argument_list|(
name|of
argument_list|,
literal|" ## "
argument_list|)
expr_stmt|;
name|concat
operator|=
literal|0
expr_stmt|;
block|}
name|dump_arg_n
argument_list|(
name|defn
argument_list|,
name|ap
operator|->
name|argno
argument_list|,
name|of
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
operator|&&
name|ap
operator|->
name|raw_after
condition|)
block|{
name|fprintf
argument_list|(
name|of
argument_list|,
literal|" ## "
argument_list|)
expr_stmt|;
name|concat
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|dump_defn_1
argument_list|(
name|defn
operator|->
name|expansion
argument_list|,
name|offset
argument_list|,
name|defn
operator|->
name|length
operator|-
name|offset
argument_list|,
name|of
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|of
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dump all macro definitions as #defines to stdout.  */
end_comment

begin_function
specifier|static
name|void
name|dump_all_macros
parameter_list|()
block|{
name|int
name|bucket
decl_stmt|;
for|for
control|(
name|bucket
operator|=
literal|0
init|;
name|bucket
operator|<
name|HASHSIZE
condition|;
name|bucket
operator|++
control|)
block|{
specifier|register
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
for|for
control|(
name|hp
operator|=
name|hashtab
index|[
name|bucket
index|]
init|;
name|hp
condition|;
name|hp
operator|=
name|hp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
condition|)
name|dump_single_macro
argument_list|(
name|hp
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output to OF a substring of a macro definition.    BASE is the beginning of the definition.    Output characters START thru LENGTH.    Unless traditional, discard newlines outside of strings, thus    converting funny-space markers to ordinary spaces.  */
end_comment

begin_function
specifier|static
name|void
name|dump_defn_1
parameter_list|(
name|base
parameter_list|,
name|start
parameter_list|,
name|length
parameter_list|,
name|of
parameter_list|)
name|U_CHAR
modifier|*
name|base
decl_stmt|;
name|int
name|start
decl_stmt|;
name|int
name|length
decl_stmt|;
name|FILE
modifier|*
name|of
decl_stmt|;
block|{
name|U_CHAR
modifier|*
name|p
init|=
name|base
operator|+
name|start
decl_stmt|;
name|U_CHAR
modifier|*
name|limit
init|=
name|base
operator|+
name|start
operator|+
name|length
decl_stmt|;
if|if
condition|(
name|traditional
condition|)
name|fwrite
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|length
argument_list|,
name|of
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|p
operator|<
name|limit
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\"'
operator|||
operator|*
name|p
operator|==
literal|'\''
condition|)
block|{
name|U_CHAR
modifier|*
name|p1
init|=
name|skip_quoted_string
argument_list|(
name|p
argument_list|,
name|limit
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|)
decl_stmt|;
name|fwrite
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|p1
operator|-
name|p
argument_list|,
name|of
argument_list|)
expr_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|putc
argument_list|(
operator|*
name|p
argument_list|,
name|of
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Print the name of argument number ARGNUM of macro definition DEFN    to OF.    Recall that DEFN->args.argnames contains all the arg names    concatenated in reverse order with comma-space in between.  */
end_comment

begin_function
specifier|static
name|void
name|dump_arg_n
parameter_list|(
name|defn
parameter_list|,
name|argnum
parameter_list|,
name|of
parameter_list|)
name|DEFINITION
modifier|*
name|defn
decl_stmt|;
name|int
name|argnum
decl_stmt|;
name|FILE
modifier|*
name|of
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|p
init|=
name|defn
operator|->
name|args
operator|.
name|argnames
decl_stmt|;
while|while
condition|(
name|argnum
operator|+
literal|1
operator|<
name|defn
operator|->
name|nargs
condition|)
block|{
name|p
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|index
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
operator|+
literal|1
expr_stmt|;
name|argnum
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
block|{
name|putc
argument_list|(
operator|*
name|p
argument_list|,
name|of
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize syntactic classifications of characters.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_char_syntax
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/*    * Set up is_idchar and is_idstart tables.  These should be    * faster than saying (is_alpha (c) || c == '_'), etc.    * Set up these things before calling any routines tthat    * refer to them.    */
for|for
control|(
name|i
operator|=
literal|'a'
init|;
name|i
operator|<=
literal|'z'
condition|;
name|i
operator|++
control|)
block|{
name|is_idchar
index|[
name|i
operator|-
literal|'a'
operator|+
literal|'A'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
name|i
operator|-
literal|'a'
operator|+
literal|'A'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|'0'
init|;
name|i
operator|<=
literal|'9'
condition|;
name|i
operator|++
control|)
name|is_idchar
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'_'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'_'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'$'
index|]
operator|=
name|dollars_in_ident
expr_stmt|;
name|is_idstart
index|[
literal|'$'
index|]
operator|=
name|dollars_in_ident
expr_stmt|;
comment|/* horizontal space table */
name|is_hor_space
index|[
literal|' '
index|]
operator|=
literal|1
expr_stmt|;
name|is_hor_space
index|[
literal|'\t'
index|]
operator|=
literal|1
expr_stmt|;
name|is_hor_space
index|[
literal|'\v'
index|]
operator|=
literal|1
expr_stmt|;
name|is_hor_space
index|[
literal|'\f'
index|]
operator|=
literal|1
expr_stmt|;
name|is_hor_space
index|[
literal|'\r'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|' '
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\t'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\v'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\f'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\n'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\r'
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the built-in macros.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_builtins
parameter_list|(
name|inp
parameter_list|,
name|outp
parameter_list|)
name|FILE_BUF
modifier|*
name|inp
decl_stmt|;
name|FILE_BUF
modifier|*
name|outp
decl_stmt|;
block|{
name|install
argument_list|(
literal|"__LINE__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_SPECLINE
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
literal|"__DATE__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_DATE
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
literal|"__FILE__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_FILE
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
literal|"__BASE_FILE__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_BASE_FILE
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
literal|"__INCLUDE_LEVEL__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_INCLUDE_LEVEL
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
literal|"__VERSION__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_VERSION
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_BUILTIN_SIZE_TYPE
name|install
argument_list|(
literal|"__SIZE_TYPE__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_SIZE_TYPE
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_BUILTIN_PTRDIFF_TYPE
name|install
argument_list|(
literal|"__PTRDIFF_TYPE__ "
argument_list|,
operator|-
literal|1
argument_list|,
name|T_PTRDIFF_TYPE
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|install
argument_list|(
literal|"__WCHAR_TYPE__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_WCHAR_TYPE
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
literal|"__USER_LABEL_PREFIX__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_USER_LABEL_PREFIX_TYPE
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
literal|"__REGISTER_PREFIX__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_REGISTER_PREFIX_TYPE
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
literal|"__TIME__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_TIME
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
condition|)
name|install
argument_list|(
literal|"__STDC__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_CONST
argument_list|,
name|STDC_VALUE
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|objc
condition|)
name|install
argument_list|(
literal|"__OBJC__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_CONST
argument_list|,
literal|1
argument_list|,
name|NULL_PTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/*  This is supplied using a -D by the compiler driver     so that it is present only when truly compiling with GNU C.  */
comment|/*  install ("__GNUC__", -1, T_CONST, 2, NULL_PTR, -1);  */
if|if
condition|(
name|debug_output
condition|)
block|{
name|char
name|directive
index|[
literal|2048
index|]
decl_stmt|;
specifier|register
name|struct
name|directive
modifier|*
name|dp
init|=
operator|&
name|directive_table
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|tm
modifier|*
name|timebuf
init|=
name|timestamp
argument_list|()
decl_stmt|;
name|sprintf
argument_list|(
name|directive
argument_list|,
literal|" __BASE_FILE__ \"%s\"\n"
argument_list|,
name|instack
index|[
literal|0
index|]
operator|.
name|nominal_fname
argument_list|)
expr_stmt|;
name|output_line_command
argument_list|(
name|inp
argument_list|,
name|outp
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|pass_thru_directive
argument_list|(
name|directive
argument_list|,
operator|&
name|directive
index|[
name|strlen
argument_list|(
name|directive
argument_list|)
index|]
argument_list|,
name|outp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|directive
argument_list|,
literal|" __VERSION__ \"%s\"\n"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
name|output_line_command
argument_list|(
name|inp
argument_list|,
name|outp
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|pass_thru_directive
argument_list|(
name|directive
argument_list|,
operator|&
name|directive
index|[
name|strlen
argument_list|(
name|directive
argument_list|)
index|]
argument_list|,
name|outp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_BUILTIN_SIZE_TYPE
name|sprintf
argument_list|(
name|directive
argument_list|,
literal|" __SIZE_TYPE__ %s\n"
argument_list|,
name|SIZE_TYPE
argument_list|)
expr_stmt|;
name|output_line_command
argument_list|(
name|inp
argument_list|,
name|outp
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|pass_thru_directive
argument_list|(
name|directive
argument_list|,
operator|&
name|directive
index|[
name|strlen
argument_list|(
name|directive
argument_list|)
index|]
argument_list|,
name|outp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_BUILTIN_PTRDIFF_TYPE
name|sprintf
argument_list|(
name|directive
argument_list|,
literal|" __PTRDIFF_TYPE__ %s\n"
argument_list|,
name|PTRDIFF_TYPE
argument_list|)
expr_stmt|;
name|output_line_command
argument_list|(
name|inp
argument_list|,
name|outp
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|pass_thru_directive
argument_list|(
name|directive
argument_list|,
operator|&
name|directive
index|[
name|strlen
argument_list|(
name|directive
argument_list|)
index|]
argument_list|,
name|outp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sprintf
argument_list|(
name|directive
argument_list|,
literal|" __WCHAR_TYPE__ %s\n"
argument_list|,
name|wchar_type
argument_list|)
expr_stmt|;
name|output_line_command
argument_list|(
name|inp
argument_list|,
name|outp
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|pass_thru_directive
argument_list|(
name|directive
argument_list|,
operator|&
name|directive
index|[
name|strlen
argument_list|(
name|directive
argument_list|)
index|]
argument_list|,
name|outp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|directive
argument_list|,
literal|" __DATE__ \"%s %2d %4d\"\n"
argument_list|,
name|monthnames
index|[
name|timebuf
operator|->
name|tm_mon
index|]
argument_list|,
name|timebuf
operator|->
name|tm_mday
argument_list|,
name|timebuf
operator|->
name|tm_year
operator|+
literal|1900
argument_list|)
expr_stmt|;
name|output_line_command
argument_list|(
name|inp
argument_list|,
name|outp
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|pass_thru_directive
argument_list|(
name|directive
argument_list|,
operator|&
name|directive
index|[
name|strlen
argument_list|(
name|directive
argument_list|)
index|]
argument_list|,
name|outp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|directive
argument_list|,
literal|" __TIME__ \"%02d:%02d:%02d\"\n"
argument_list|,
name|timebuf
operator|->
name|tm_hour
argument_list|,
name|timebuf
operator|->
name|tm_min
argument_list|,
name|timebuf
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
name|output_line_command
argument_list|(
name|inp
argument_list|,
name|outp
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|pass_thru_directive
argument_list|(
name|directive
argument_list|,
operator|&
name|directive
index|[
name|strlen
argument_list|(
name|directive
argument_list|)
index|]
argument_list|,
name|outp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
name|sprintf
argument_list|(
name|directive
argument_list|,
literal|" __STDC__ 1"
argument_list|)
expr_stmt|;
name|output_line_command
argument_list|(
name|inp
argument_list|,
name|outp
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|pass_thru_directive
argument_list|(
name|directive
argument_list|,
operator|&
name|directive
index|[
name|strlen
argument_list|(
name|directive
argument_list|)
index|]
argument_list|,
name|outp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objc
condition|)
block|{
name|sprintf
argument_list|(
name|directive
argument_list|,
literal|" __OBJC__ 1"
argument_list|)
expr_stmt|;
name|output_line_command
argument_list|(
name|inp
argument_list|,
name|outp
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|pass_thru_directive
argument_list|(
name|directive
argument_list|,
operator|&
name|directive
index|[
name|strlen
argument_list|(
name|directive
argument_list|)
index|]
argument_list|,
name|outp
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * process a given definition string, for initialization  * If STR is just an identifier, define it with value 1.  * If STR has anything after the identifier, then it should  * be identifier=definition.  */
end_comment

begin_function
specifier|static
name|void
name|make_definition
parameter_list|(
name|str
parameter_list|,
name|op
parameter_list|)
name|U_CHAR
modifier|*
name|str
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
block|{
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|struct
name|directive
modifier|*
name|kt
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|buf
operator|=
name|str
expr_stmt|;
name|p
operator|=
name|str
expr_stmt|;
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|p
index|]
condition|)
block|{
name|error
argument_list|(
literal|"malformed option `-D %s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|is_idchar
index|[
operator|*
operator|++
name|p
index|]
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
condition|)
block|{
while|while
condition|(
name|is_idchar
index|[
operator|*
operator|++
name|p
index|]
operator|||
operator|*
name|p
operator|==
literal|','
operator|||
name|is_hor_space
index|[
operator|*
name|p
index|]
condition|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|')'
condition|)
name|p
operator|=
name|str
expr_stmt|;
comment|/* Error */
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|" 1"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|!=
literal|'='
condition|)
block|{
name|error
argument_list|(
literal|"malformed option `-D %s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|U_CHAR
modifier|*
name|q
decl_stmt|;
comment|/* Copy the entire option so we can modify it.  */
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
literal|2
operator|*
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
name|p
operator|-
name|str
argument_list|)
expr_stmt|;
comment|/* Change the = to a space.  */
name|buf
index|[
name|p
operator|-
name|str
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* Scan for any backslash-newline and remove it.  */
name|p
operator|++
expr_stmt|;
name|q
operator|=
operator|&
name|buf
index|[
name|p
operator|-
name|str
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\"'
operator|||
operator|*
name|p
operator|==
literal|'\''
condition|)
block|{
name|int
name|unterminated
init|=
literal|0
decl_stmt|;
name|U_CHAR
modifier|*
name|p1
init|=
name|skip_quoted_string
argument_list|(
name|p
argument_list|,
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL_PTR
argument_list|,
name|NULL_PTR
argument_list|,
operator|&
name|unterminated
argument_list|)
decl_stmt|;
if|if
condition|(
name|unterminated
condition|)
return|return;
while|while
condition|(
name|p
operator|!=
name|p1
condition|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* Change newline chars into newline-markers.  */
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|0
expr_stmt|;
block|}
name|ip
operator|=
operator|&
name|instack
index|[
operator|++
name|indepth
index|]
expr_stmt|;
name|ip
operator|->
name|nominal_fname
operator|=
name|ip
operator|->
name|fname
operator|=
literal|"*Initialization*"
expr_stmt|;
name|ip
operator|->
name|buf
operator|=
name|ip
operator|->
name|bufp
operator|=
name|buf
expr_stmt|;
name|ip
operator|->
name|length
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ip
operator|->
name|lineno
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|macro
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|free_ptr
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
name|ip
operator|->
name|system_header_p
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|kt
operator|=
name|directive_table
init|;
name|kt
operator|->
name|type
operator|!=
name|T_DEFINE
condition|;
name|kt
operator|++
control|)
empty_stmt|;
comment|/* Pass NULL instead of OP, since this is a "predefined" macro.  */
name|do_define
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|,
name|kt
argument_list|)
expr_stmt|;
operator|--
name|indepth
expr_stmt|;
block|}
end_function

begin_comment
comment|/* JF, this does the work for the -U option */
end_comment

begin_function
specifier|static
name|void
name|make_undef
parameter_list|(
name|str
parameter_list|,
name|op
parameter_list|)
name|U_CHAR
modifier|*
name|str
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
block|{
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|struct
name|directive
modifier|*
name|kt
decl_stmt|;
name|ip
operator|=
operator|&
name|instack
index|[
operator|++
name|indepth
index|]
expr_stmt|;
name|ip
operator|->
name|nominal_fname
operator|=
name|ip
operator|->
name|fname
operator|=
literal|"*undef*"
expr_stmt|;
name|ip
operator|->
name|buf
operator|=
name|ip
operator|->
name|bufp
operator|=
name|str
expr_stmt|;
name|ip
operator|->
name|length
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|ip
operator|->
name|lineno
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|macro
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|free_ptr
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
name|ip
operator|->
name|system_header_p
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|kt
operator|=
name|directive_table
init|;
name|kt
operator|->
name|type
operator|!=
name|T_UNDEF
condition|;
name|kt
operator|++
control|)
empty_stmt|;
name|do_undef
argument_list|(
name|str
argument_list|,
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|,
name|op
argument_list|,
name|kt
argument_list|)
expr_stmt|;
operator|--
name|indepth
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Process the string STR as if it appeared as the body of a #assert.    OPTION is the option name for which STR was the argument.  */
end_comment

begin_function
specifier|static
name|void
name|make_assertion
parameter_list|(
name|option
parameter_list|,
name|str
parameter_list|)
name|char
modifier|*
name|option
decl_stmt|;
name|U_CHAR
modifier|*
name|str
decl_stmt|;
block|{
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|struct
name|directive
modifier|*
name|kt
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* Copy the entire option so we can modify it.  */
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* Scan for any backslash-newline and remove it.  */
name|p
operator|=
name|q
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|p
index|]
condition|)
block|{
name|error
argument_list|(
literal|"malformed option `%s %s'"
argument_list|,
name|option
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|is_idchar
index|[
operator|*
operator|++
name|p
index|]
condition|)
empty_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|'('
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"malformed option `%s %s'"
argument_list|,
name|option
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip
operator|=
operator|&
name|instack
index|[
operator|++
name|indepth
index|]
expr_stmt|;
name|ip
operator|->
name|nominal_fname
operator|=
name|ip
operator|->
name|fname
operator|=
literal|"*Initialization*"
expr_stmt|;
name|ip
operator|->
name|buf
operator|=
name|ip
operator|->
name|bufp
operator|=
name|buf
expr_stmt|;
name|ip
operator|->
name|length
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ip
operator|->
name|lineno
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|macro
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|free_ptr
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
name|ip
operator|->
name|system_header_p
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|kt
operator|=
name|directive_table
init|;
name|kt
operator|->
name|type
operator|!=
name|T_ASSERT
condition|;
name|kt
operator|++
control|)
empty_stmt|;
comment|/* pass NULL as output ptr to do_define since we KNOW it never      does any output.... */
name|do_assert
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|NULL_PTR
argument_list|,
name|kt
argument_list|)
expr_stmt|;
operator|--
name|indepth
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Append a chain of `struct file_name_list's    to the end of the main include chain.    FIRST is the beginning of the chain to append, and LAST is the end.  */
end_comment

begin_function
specifier|static
name|void
name|append_include_chain
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|)
name|struct
name|file_name_list
modifier|*
name|first
decl_stmt|,
decl|*
name|last
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|file_name_list
modifier|*
name|dir
decl_stmt|;
if|if
condition|(
operator|!
name|first
operator|||
operator|!
name|last
condition|)
return|return;
if|if
condition|(
name|include
operator|==
literal|0
condition|)
name|include
operator|=
name|first
expr_stmt|;
else|else
name|last_include
operator|->
name|next
operator|=
name|first
expr_stmt|;
if|if
condition|(
name|first_bracket_include
operator|==
literal|0
condition|)
name|first_bracket_include
operator|=
name|first
expr_stmt|;
for|for
control|(
name|dir
operator|=
name|first
init|;
condition|;
name|dir
operator|=
name|dir
operator|->
name|next
control|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|dir
operator|->
name|fname
argument_list|)
operator|+
name|INCLUDE_LEN_FUDGE
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|max_include_len
condition|)
name|max_include_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|last
condition|)
break|break;
block|}
name|last
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|last_include
operator|=
name|last
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Add output to `deps_buffer' for the -M switch.    STRING points to the text to be output.    SPACER is ':' for targets, ' ' for dependencies, zero for text    to be inserted literally.  */
end_comment

begin_function
specifier|static
name|void
name|deps_output
parameter_list|(
name|string
parameter_list|,
name|spacer
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|spacer
decl_stmt|;
block|{
name|int
name|size
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return;
ifndef|#
directive|ifndef
name|MAX_OUTPUT_COLUMNS
define|#
directive|define
name|MAX_OUTPUT_COLUMNS
value|72
endif|#
directive|endif
if|if
condition|(
name|spacer
operator|&&
name|deps_column
operator|>
literal|0
operator|&&
operator|(
name|deps_column
operator|+
name|size
operator|)
operator|>
name|MAX_OUTPUT_COLUMNS
condition|)
block|{
name|deps_output
argument_list|(
literal|" \\\n  "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|deps_column
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|deps_size
operator|+
name|size
operator|+
literal|8
operator|>
name|deps_allocated_size
condition|)
block|{
name|deps_allocated_size
operator|=
operator|(
name|deps_size
operator|+
name|size
operator|+
literal|50
operator|)
operator|*
literal|2
expr_stmt|;
name|deps_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|deps_buffer
argument_list|,
name|deps_allocated_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spacer
operator|==
literal|' '
operator|&&
name|deps_column
operator|>
literal|0
condition|)
name|deps_buffer
index|[
name|deps_size
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|bcopy
argument_list|(
name|string
argument_list|,
operator|&
name|deps_buffer
index|[
name|deps_size
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|deps_size
operator|+=
name|size
expr_stmt|;
name|deps_column
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|spacer
operator|==
literal|':'
condition|)
name|deps_buffer
index|[
name|deps_size
operator|++
index|]
operator|=
literal|':'
expr_stmt|;
name|deps_buffer
index|[
name|deps_size
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|||
name|defined
argument_list|(
name|VMS
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|BSTRING
end_ifndef

begin_function
name|void
name|bzero
parameter_list|(
name|b
parameter_list|,
name|length
parameter_list|)
specifier|register
name|char
modifier|*
name|b
decl_stmt|;
specifier|register
name|unsigned
name|length
decl_stmt|;
block|{
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
operator|*
name|b
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bcopy
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|,
name|length
parameter_list|)
specifier|register
name|char
modifier|*
name|b1
decl_stmt|;
specifier|register
name|char
modifier|*
name|b2
decl_stmt|;
specifier|register
name|unsigned
name|length
decl_stmt|;
block|{
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
operator|*
name|b2
operator|++
operator|=
operator|*
name|b1
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bcmp
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|,
name|length
parameter_list|)
comment|/* This could be a macro! */
specifier|register
name|char
modifier|*
name|b1
decl_stmt|;
specifier|register
name|char
modifier|*
name|b2
decl_stmt|;
specifier|register
name|unsigned
name|length
decl_stmt|;
block|{
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
if|if
condition|(
operator|*
name|b1
operator|++
operator|!=
operator|*
name|b2
operator|++
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not BSTRING */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG or VMS */
end_comment

begin_escape
end_escape

begin_function
specifier|static
name|void
name|fatal
parameter_list|(
name|str
parameter_list|,
name|arg
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|,
decl|*
name|arg
decl_stmt|;
end_function

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|str
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FAILURE_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|perror_with_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|name
argument_list|,
name|my_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pfatal_with_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|exit
argument_list|(
name|vaxc$errno
argument_list|)
expr_stmt|;
else|#
directive|else
name|exit
argument_list|(
name|FAILURE_EXIT_CODE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Handler for SIGPIPE.  */
end_comment

begin_function
specifier|static
name|void
name|pipe_closed
parameter_list|(
name|signo
parameter_list|)
comment|/* If this is missing, some compilers complain.  */
name|int
name|signo
decl_stmt|;
block|{
name|fatal
argument_list|(
literal|"output pipe has been closed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|memory_full
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Memory exhausted."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|unsigned
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|!=
literal|0
condition|)
return|return
operator|(
name|ptr
operator|)
return|;
name|memory_full
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|xrealloc
parameter_list|(
name|old
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|old
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|old
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|!=
literal|0
condition|)
return|return
operator|(
name|ptr
operator|)
return|;
name|memory_full
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|xcalloc
parameter_list|(
name|number
parameter_list|,
name|size
parameter_list|)
name|unsigned
name|number
decl_stmt|,
name|size
decl_stmt|;
block|{
specifier|register
name|unsigned
name|total
init|=
name|number
operator|*
name|size
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|total
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|total
operator|>
literal|100
condition|)
name|bzero
argument_list|(
name|ptr
argument_list|,
name|total
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* It's not too long, so loop, zeroing by longs. 	 It must be safe because malloc values are always well aligned.  */
specifier|register
name|long
modifier|*
name|zp
init|=
operator|(
name|long
operator|*
operator|)
name|ptr
decl_stmt|;
specifier|register
name|long
modifier|*
name|zl
init|=
operator|(
name|long
operator|*
operator|)
operator|(
name|ptr
operator|+
name|total
operator|-
literal|4
operator|)
decl_stmt|;
specifier|register
name|int
name|i
init|=
name|total
operator|-
literal|4
decl_stmt|;
while|while
condition|(
name|zp
operator|<
name|zl
condition|)
operator|*
name|zp
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|total
condition|)
name|ptr
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ptr
return|;
block|}
name|memory_full
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|savestring
parameter_list|(
name|input
parameter_list|)
name|char
modifier|*
name|input
decl_stmt|;
block|{
name|unsigned
name|size
init|=
name|strlen
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|char
modifier|*
name|output
init|=
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|output
argument_list|,
name|input
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the file-mode and data size of the file open on FD    and store them in *MODE_POINTER and *SIZE_POINTER.  */
end_comment

begin_function
specifier|static
name|int
name|file_size_and_mode
parameter_list|(
name|fd
parameter_list|,
name|mode_pointer
parameter_list|,
name|size_pointer
parameter_list|)
name|int
name|fd
decl_stmt|;
name|int
modifier|*
name|mode_pointer
decl_stmt|;
name|long
name|int
modifier|*
name|size_pointer
decl_stmt|;
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|mode_pointer
condition|)
operator|*
name|mode_pointer
operator|=
name|sbuf
operator|.
name|st_mode
expr_stmt|;
if|if
condition|(
name|size_pointer
condition|)
operator|*
name|size_pointer
operator|=
name|sbuf
operator|.
name|st_size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_dots
parameter_list|(
name|fd
parameter_list|,
name|depth
parameter_list|)
name|FILE
modifier|*
name|fd
decl_stmt|;
name|int
name|depth
decl_stmt|;
block|{
while|while
condition|(
name|depth
operator|>
literal|0
condition|)
block|{
name|putc
argument_list|(
literal|'.'
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|depth
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/* Under VMS we need to fix up the "include" specification    filename so that everything following the 1st slash is    changed into its correct VMS file specification. */
end_comment

begin_function
specifier|static
name|void
name|hack_vms_include_specification
parameter_list|(
name|fname
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|int
name|f
decl_stmt|,
name|check_filename_before_returning
decl_stmt|,
name|no_prefix_seen
decl_stmt|;
name|char
name|Local
index|[
literal|512
index|]
decl_stmt|;
name|check_filename_before_returning
operator|=
literal|0
expr_stmt|;
name|no_prefix_seen
operator|=
literal|0
expr_stmt|;
comment|/* Ignore leading "./"s */
while|while
condition|(
name|fname
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|fname
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|strcpy
argument_list|(
name|fname
argument_list|,
name|fname
operator|+
literal|2
argument_list|)
expr_stmt|;
name|no_prefix_seen
operator|=
literal|1
expr_stmt|;
comment|/* mark this for later */
block|}
comment|/* Look for the boundary between the VMS and UNIX filespecs */
name|cp
operator|=
name|rindex
argument_list|(
name|fname
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
comment|/* Look for end of dirspec. */
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
name|cp
operator|=
name|rindex
argument_list|(
name|fname
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
comment|/* ... Ditto		    */
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
name|cp
operator|=
name|rindex
argument_list|(
name|fname
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
comment|/* Look for end of devspec. */
if|if
condition|(
name|cp
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|index
argument_list|(
name|fname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* Look for the "/" */
block|}
comment|/*    * Check if we have a vax-c style '#include filename'    * and add the missing .h    */
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
name|fname
argument_list|,
literal|'.'
argument_list|)
operator|==
literal|0
condition|)
name|strcat
argument_list|(
name|fname
argument_list|,
literal|".h"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|index
argument_list|(
name|cp
argument_list|,
literal|'.'
argument_list|)
operator|==
literal|0
condition|)
name|strcat
argument_list|(
name|cp
argument_list|,
literal|".h"
argument_list|)
expr_stmt|;
block|}
name|cp2
operator|=
name|Local
expr_stmt|;
comment|/* initialize */
comment|/* We are trying to do a number of things here.  First of all, we are      trying to hammer the filenames into a standard format, such that later      processing can handle them.            If the file name contains something like [dir.], then it recognizes this      as a root, and strips the ".]".  Later processing will add whatever is      needed to get things working properly.            If no device is specified, then the first directory name is taken to be      a device name (or a rooted logical). */
comment|/* See if we found that 1st slash */
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
return|return;
comment|/* Nothing to do!!! */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'/'
condition|)
return|return;
comment|/* Nothing to do!!! */
comment|/* Point to the UNIX filename part (which needs to be fixed!) */
name|cp1
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
comment|/* If the directory spec is not rooted, we can just copy      the UNIX filename part and we are done */
if|if
condition|(
operator|(
operator|(
name|cp
operator|-
name|fname
operator|)
operator|>
literal|1
operator|)
operator|&&
operator|(
operator|(
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|']'
operator|)
operator|||
operator|(
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'>'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|cp
index|[
operator|-
literal|2
index|]
operator|!=
literal|'.'
condition|)
block|{
comment|/*        * The VMS part ends in a `]', and the preceding character is not a `.'.        * We strip the `]', and then splice the two parts of the name in the        * usual way.  Given the default locations for include files in cccp.c,        * we will only use this code if the user specifies alternate locations        * with the /include (-I) switch on the command line.  */
name|cp
operator|-=
literal|1
expr_stmt|;
comment|/* Strip "]" */
name|cp1
operator|--
expr_stmt|;
comment|/* backspace */
block|}
else|else
block|{
comment|/*        * The VMS part has a ".]" at the end, and this will not do.  Later        * processing will add a second directory spec, and this would be a syntax        * error.  Thus we strip the ".]", and thus merge the directory specs.        * We also backspace cp1, so that it points to a '/'.  This inhibits the        * generation of the 000000 root directory spec (which does not belong here        * in this case).        */
name|cp
operator|-=
literal|2
expr_stmt|;
comment|/* Strip ".]" */
name|cp1
operator|--
expr_stmt|;
block|}
empty_stmt|;
comment|/* backspace */
block|}
else|else
block|{
comment|/* We drop in here if there is no VMS style directory specification yet.      * If there is no device specification either, we make the first dir a      * device and try that.  If we do not do this, then we will be essentially      * searching the users default directory (as if they did a #include "asdf.h").      *      * Then all we need to do is to push a '[' into the output string. Later      * processing will fill this in, and close the bracket.      */
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|!=
literal|':'
condition|)
operator|*
name|cp2
operator|++
operator|=
literal|':'
expr_stmt|;
comment|/* dev not in spec.  take first dir */
operator|*
name|cp2
operator|++
operator|=
literal|'['
expr_stmt|;
comment|/* Open the directory specification */
block|}
comment|/* at this point we assume that we have the device spec, and (at least      the opening "[" for a directory specification.  We may have directories      specified already */
comment|/* If there are no other slashes then the filename will be      in the "root" directory.  Otherwise, we need to add      directory specifications. */
if|if
condition|(
name|index
argument_list|(
name|cp1
argument_list|,
literal|'/'
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Just add "000000]" as the directory string */
name|strcpy
argument_list|(
name|cp2
argument_list|,
literal|"000000]"
argument_list|)
expr_stmt|;
name|cp2
operator|+=
name|strlen
argument_list|(
name|cp2
argument_list|)
expr_stmt|;
name|check_filename_before_returning
operator|=
literal|1
expr_stmt|;
comment|/* we might need to fool with this later */
block|}
else|else
block|{
comment|/* As long as there are still subdirectories to add, do them. */
while|while
condition|(
name|index
argument_list|(
name|cp1
argument_list|,
literal|'/'
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* If this token is "." we can ignore it */
if|if
condition|(
operator|(
name|cp1
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|cp1
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
name|cp1
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
comment|/* Add a subdirectory spec. Do not duplicate "." */
if|if
condition|(
name|cp2
index|[
operator|-
literal|1
index|]
operator|!=
literal|'.'
operator|&&
name|cp2
index|[
operator|-
literal|1
index|]
operator|!=
literal|'['
operator|&&
name|cp2
index|[
operator|-
literal|1
index|]
operator|!=
literal|'<'
condition|)
operator|*
name|cp2
operator|++
operator|=
literal|'.'
expr_stmt|;
comment|/* If this is ".." then the spec becomes "-" */
if|if
condition|(
operator|(
name|cp1
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|cp1
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|cp
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
comment|/* Add "-" and skip the ".." */
operator|*
name|cp2
operator|++
operator|=
literal|'-'
expr_stmt|;
name|cp1
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
comment|/* Copy the subdirectory */
while|while
condition|(
operator|*
name|cp1
operator|!=
literal|'/'
condition|)
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
name|cp1
operator|++
expr_stmt|;
comment|/* Skip the "/" */
block|}
comment|/* Close the directory specification */
if|if
condition|(
name|cp2
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
comment|/* no trailing periods */
name|cp2
operator|--
expr_stmt|;
operator|*
name|cp2
operator|++
operator|=
literal|']'
expr_stmt|;
block|}
comment|/* Now add the filename */
while|while
condition|(
operator|*
name|cp1
condition|)
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
operator|*
name|cp2
operator|=
literal|0
expr_stmt|;
comment|/* Now append it to the original VMS spec. */
name|strcpy
argument_list|(
name|cp
argument_list|,
name|Local
argument_list|)
expr_stmt|;
comment|/* If we put a [000000] in the filename, try to open it first. If this fails,      remove the [000000], and return that name.  This provides flexibility      to the user in that they can use both rooted and non-rooted logical names      to point to the location of the file.  */
if|if
condition|(
name|check_filename_before_returning
operator|&&
name|no_prefix_seen
condition|)
block|{
name|f
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
block|{
comment|/* The file name is OK as it is, so return it as is.  */
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The filename did not work.  Try to remove the [000000] from the name,        and return it.  */
name|cp
operator|=
name|index
argument_list|(
name|fname
argument_list|,
literal|'['
argument_list|)
expr_stmt|;
name|cp2
operator|=
name|index
argument_list|(
name|fname
argument_list|,
literal|']'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|strcpy
argument_list|(
name|cp
argument_list|,
name|cp2
argument_list|)
expr_stmt|;
comment|/* this gets rid of it */
block|}
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/* These are the read/write replacement routines for    VAX-11 "C".  They make read/write behave enough    like their UNIX counterparts that CCCP will work */
end_comment

begin_function
specifier|static
name|int
name|read
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
undef|#
directive|undef
name|read
comment|/* Get back the REAL read routine */
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|total
init|=
literal|0
decl_stmt|;
comment|/* Read until the buffer is exhausted */
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
comment|/* Limit each read to 32KB */
name|i
operator|=
operator|(
name|size
operator|>
operator|(
literal|32
operator|*
literal|1024
operator|)
operator|)
condition|?
operator|(
literal|32
operator|*
literal|1024
operator|)
else|:
name|size
expr_stmt|;
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|total
operator|)
return|;
return|return
operator|(
name|i
operator|)
return|;
block|}
comment|/* Account for this read */
name|total
operator|+=
name|i
expr_stmt|;
name|buf
operator|+=
name|i
expr_stmt|;
name|size
operator|-=
name|i
expr_stmt|;
block|}
return|return
operator|(
name|total
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|write
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
undef|#
directive|undef
name|write
comment|/* Get back the REAL write routine */
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Limit individual writes to 32Kb */
name|i
operator|=
name|size
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|j
operator|=
operator|(
name|i
operator|>
operator|(
literal|32
operator|*
literal|1024
operator|)
operator|)
condition|?
operator|(
literal|32
operator|*
literal|1024
operator|)
else|:
name|i
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|j
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Account for the data written */
name|buf
operator|+=
name|j
expr_stmt|;
name|i
operator|-=
name|j
expr_stmt|;
block|}
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The following wrapper functions supply additional arguments to the VMS    I/O routines to optimize performance with file handling.  The arguments    are:      "mbc=16" - Set multi-block count to 16 (use a 8192 byte buffer).      "deq=64" - When extending the file, extend it in chunks of 32Kbytes.      "fop=tef"- Truncate unused portions of file when closing file.      "shr=nil"- Disallow file sharing while file is open.  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|freopen
parameter_list|(
name|fname
parameter_list|,
name|type
parameter_list|,
name|oldfile
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|FILE
modifier|*
name|oldfile
decl_stmt|;
block|{
undef|#
directive|undef
name|freopen
comment|/* Get back the REAL fopen routine */
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"w"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|freopen
argument_list|(
name|fname
argument_list|,
name|type
argument_list|,
name|oldfile
argument_list|,
literal|"mbc=16"
argument_list|,
literal|"deq=64"
argument_list|,
literal|"fop=tef"
argument_list|,
literal|"shr=nil"
argument_list|)
return|;
return|return
name|freopen
argument_list|(
name|fname
argument_list|,
name|type
argument_list|,
name|oldfile
argument_list|,
literal|"mbc=16"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|FILE
modifier|*
name|fopen
parameter_list|(
name|fname
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
block|{
undef|#
directive|undef
name|fopen
comment|/* Get back the REAL fopen routine */
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"w"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|fopen
argument_list|(
name|fname
argument_list|,
name|type
argument_list|,
literal|"mbc=16"
argument_list|,
literal|"deq=64"
argument_list|,
literal|"fop=tef"
argument_list|,
literal|"shr=nil"
argument_list|)
return|;
return|return
name|fopen
argument_list|(
name|fname
argument_list|,
name|type
argument_list|,
literal|"mbc=16"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|open
parameter_list|(
name|fname
parameter_list|,
name|flags
parameter_list|,
name|prot
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|prot
decl_stmt|;
block|{
undef|#
directive|undef
name|open
comment|/* Get back the REAL open routine */
return|return
name|open
argument_list|(
name|fname
argument_list|,
name|flags
argument_list|,
name|prot
argument_list|,
literal|"mbc=16"
argument_list|,
literal|"deq=64"
argument_list|,
literal|"fop=tef"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Avoid run-time library bug, where copying M out of N+M characters with    N>= 65535 results in VAXCRTL's strncat falling into an infinite loop.    gcc-cpp exercises this particular bug.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|strncat
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|cnt
parameter_list|)
name|char
modifier|*
name|dst
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|;
name|unsigned
name|cnt
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|d
init|=
name|dst
decl_stmt|,
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|src
decl_stmt|;
specifier|register
name|int
name|n
init|=
name|cnt
decl_stmt|;
comment|/* convert to _signed_ type */
while|while
condition|(
operator|*
name|d
condition|)
name|d
operator|++
expr_stmt|;
comment|/* advance to end */
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
if|if
condition|(
operator|!
operator|(
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
operator|)
condition|)
break|break;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
return|return
name|dst
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

end_unit

