begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Medium-level subroutines: convert bit-field store and extract    and shifts, multiplies and divides to rtl instructions.    Copyright (C) 1987, 1988, 1989, 1992, 1993 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-flags.h"
end_include

begin_include
include|#
directive|include
file|"insn-codes.h"
end_include

begin_include
include|#
directive|include
file|"insn-config.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"real.h"
end_include

begin_include
include|#
directive|include
file|"recog.h"
end_include

begin_function_decl
specifier|static
name|rtx
name|extract_split_bit_field
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|extract_fixed_bit_field
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store_split_bit_field
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store_fixed_bit_field
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|mask_rtx
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|rtx
name|lshift_value
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|CEIL
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x) + (y) - 1) / (y))
end_define

begin_comment
comment|/* Non-zero means multiply instructions are cheaper than shifts.  */
end_comment

begin_decl_stmt
name|int
name|mult_is_very_cheap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means divides or modulus operations are relatively cheap for    powers of two, so don't use branches; emit the operation instead.     Usually, this will mean that the MD file will emit non-branch    sequences.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sdiv_pow2_cheap
decl_stmt|,
name|smod_pow2_cheap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For compilers that support multiple targets with different word sizes,    MAX_BITS_PER_WORD contains the biggest value of BITS_PER_WORD.  An example    is the H8/300(H) compiler.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_BITS_PER_WORD
end_ifndef

begin_define
define|#
directive|define
name|MAX_BITS_PER_WORD
value|BITS_PER_WORD
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Cost of various pieces of RTL.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|add_cost
decl_stmt|,
name|mult_cost
decl_stmt|,
name|negate_cost
decl_stmt|,
name|zero_cost
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|shift_cost
index|[
name|MAX_BITS_PER_WORD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|shiftadd_cost
index|[
name|MAX_BITS_PER_WORD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|shiftsub_cost
index|[
name|MAX_BITS_PER_WORD
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_expmed
parameter_list|()
block|{
name|char
modifier|*
name|free_point
decl_stmt|;
comment|/* This is "some random pseudo register" for purposes of calling recog      to see what insns exist.  */
name|rtx
name|reg
init|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|word_mode
argument_list|,
name|FIRST_PSEUDO_REGISTER
argument_list|)
decl_stmt|;
name|rtx
name|shift_insn
decl_stmt|,
name|shiftadd_insn
decl_stmt|,
name|shiftsub_insn
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|int
name|m
decl_stmt|;
name|start_sequence
argument_list|()
expr_stmt|;
comment|/* Since we are on the permanent obstack, we must be sure we save this      spot AFTER we call start_sequence, since it will reuse the rtl it      makes.  */
name|free_point
operator|=
operator|(
name|char
operator|*
operator|)
name|oballoc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|zero_cost
operator|=
name|rtx_cost
argument_list|(
name|const0_rtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_cost
operator|=
name|rtx_cost
argument_list|(
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|word_mode
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
name|shift_insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|ASHIFT
argument_list|,
name|word_mode
argument_list|,
name|reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|shiftadd_insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|word_mode
argument_list|,
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|word_mode
argument_list|,
name|reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|shiftsub_insn
operator|=
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|SET
argument_list|,
name|VOIDmode
argument_list|,
name|reg
argument_list|,
name|gen_rtx
argument_list|(
name|MINUS
argument_list|,
name|word_mode
argument_list|,
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|word_mode
argument_list|,
name|reg
argument_list|,
name|const0_rtx
argument_list|)
argument_list|,
name|reg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|init_recog
argument_list|()
expr_stmt|;
name|shift_cost
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|shiftadd_cost
index|[
literal|0
index|]
operator|=
name|shiftsub_cost
index|[
literal|0
index|]
operator|=
name|add_cost
expr_stmt|;
for|for
control|(
name|m
operator|=
literal|1
init|;
name|m
operator|<
name|BITS_PER_WORD
condition|;
name|m
operator|++
control|)
block|{
name|shift_cost
index|[
name|m
index|]
operator|=
name|shiftadd_cost
index|[
name|m
index|]
operator|=
name|shiftsub_cost
index|[
name|m
index|]
operator|=
literal|32000
expr_stmt|;
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|shift_insn
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|=
name|GEN_INT
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|shift_insn
argument_list|)
argument_list|,
name|shift_insn
argument_list|,
operator|&
name|dummy
argument_list|)
operator|>=
literal|0
condition|)
name|shift_cost
index|[
name|m
index|]
operator|=
name|rtx_cost
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|shift_insn
argument_list|)
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|shiftadd_insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|=
name|GEN_INT
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|shiftadd_insn
argument_list|)
argument_list|,
name|shiftadd_insn
argument_list|,
operator|&
name|dummy
argument_list|)
operator|>=
literal|0
condition|)
name|shiftadd_cost
index|[
name|m
index|]
operator|=
name|rtx_cost
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|shiftadd_insn
argument_list|)
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|shiftsub_insn
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|=
name|GEN_INT
argument_list|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|recog
argument_list|(
name|PATTERN
argument_list|(
name|shiftsub_insn
argument_list|)
argument_list|,
name|shiftsub_insn
argument_list|,
operator|&
name|dummy
argument_list|)
operator|>=
literal|0
condition|)
name|shiftsub_cost
index|[
name|m
index|]
operator|=
name|rtx_cost
argument_list|(
name|SET_SRC
argument_list|(
name|PATTERN
argument_list|(
name|shiftsub_insn
argument_list|)
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
block|}
name|mult_cost
operator|=
name|rtx_cost
argument_list|(
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|word_mode
argument_list|,
name|reg
argument_list|,
name|reg
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
comment|/* For gcc 2.4 keep MULT_COST small to avoid really slow searches      in synth_mult.  */
name|mult_cost
operator|=
name|MIN
argument_list|(
literal|12
operator|*
name|add_cost
argument_list|,
name|mult_cost
argument_list|)
expr_stmt|;
name|negate_cost
operator|=
name|rtx_cost
argument_list|(
name|gen_rtx
argument_list|(
name|NEG
argument_list|,
name|word_mode
argument_list|,
name|reg
argument_list|)
argument_list|,
name|SET
argument_list|)
expr_stmt|;
comment|/* 999999 is chosen to avoid any plausible faster special case.  */
name|mult_is_very_cheap
operator|=
operator|(
name|rtx_cost
argument_list|(
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|word_mode
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
literal|999999
argument_list|)
argument_list|)
argument_list|,
name|SET
argument_list|)
operator|<
name|rtx_cost
argument_list|(
name|gen_rtx
argument_list|(
name|ASHIFT
argument_list|,
name|word_mode
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
literal|7
argument_list|)
argument_list|)
argument_list|,
name|SET
argument_list|)
operator|)
expr_stmt|;
name|sdiv_pow2_cheap
operator|=
operator|(
name|rtx_cost
argument_list|(
name|gen_rtx
argument_list|(
name|DIV
argument_list|,
name|word_mode
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
literal|32
argument_list|)
argument_list|)
argument_list|,
name|SET
argument_list|)
operator|<=
literal|2
operator|*
name|add_cost
operator|)
expr_stmt|;
name|smod_pow2_cheap
operator|=
operator|(
name|rtx_cost
argument_list|(
name|gen_rtx
argument_list|(
name|MOD
argument_list|,
name|word_mode
argument_list|,
name|reg
argument_list|,
name|GEN_INT
argument_list|(
literal|32
argument_list|)
argument_list|)
argument_list|,
name|SET
argument_list|)
operator|<=
literal|2
operator|*
name|add_cost
operator|)
expr_stmt|;
comment|/* Free the objects we just allocated.  */
name|end_sequence
argument_list|()
expr_stmt|;
name|obfree
argument_list|(
name|free_point
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return an rtx representing minus the value of X.    MODE is the intended mode of the result,    useful if X is a CONST_INT.  */
end_comment

begin_function
name|rtx
name|negate_rtx
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|HOST_WIDE_INT
name|val
init|=
operator|-
name|INTVAL
argument_list|(
name|x
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
comment|/* Sign extend the value from the bits that are significant.  */
if|if
condition|(
name|val
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
name|val
operator||=
call|(
name|HOST_WIDE_INT
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|val
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|)
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|GEN_INT
argument_list|(
name|val
argument_list|)
return|;
block|}
else|else
return|return
name|expand_unop
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|neg_optab
argument_list|,
name|x
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to store value from rtx VALUE    into a bit-field within structure STR_RTX    containing BITSIZE bits starting at bit BITNUM.    FIELDMODE is the machine-mode of the FIELD_DECL node for this field.    ALIGN is the alignment that STR_RTX is known to have, measured in bytes.    TOTAL_SIZE is the size of the structure in bytes, or -1 if varying.  */
end_comment

begin_comment
comment|/* ??? Note that there are two different ideas here for how    to determine the size to count bits within, for a register.    One is BITS_PER_WORD, and the other is the size of operand 3    of the insv pattern.  (The latter assumes that an n-bit machine    will be able to insert bit fields up to n bits wide.)    It isn't certain that either of these is right.    extract_bit_field has the same quandary.  */
end_comment

begin_function
name|rtx
name|store_bit_field
parameter_list|(
name|str_rtx
parameter_list|,
name|bitsize
parameter_list|,
name|bitnum
parameter_list|,
name|fieldmode
parameter_list|,
name|value
parameter_list|,
name|align
parameter_list|,
name|total_size
parameter_list|)
name|rtx
name|str_rtx
decl_stmt|;
specifier|register
name|int
name|bitsize
decl_stmt|;
name|int
name|bitnum
decl_stmt|;
name|enum
name|machine_mode
name|fieldmode
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|total_size
decl_stmt|;
block|{
name|int
name|unit
init|=
operator|(
name|GET_CODE
argument_list|(
name|str_rtx
argument_list|)
operator|==
name|MEM
operator|)
condition|?
name|BITS_PER_UNIT
else|:
name|BITS_PER_WORD
decl_stmt|;
specifier|register
name|int
name|offset
init|=
name|bitnum
operator|/
name|unit
decl_stmt|;
specifier|register
name|int
name|bitpos
init|=
name|bitnum
operator|%
name|unit
decl_stmt|;
specifier|register
name|rtx
name|op0
init|=
name|str_rtx
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|str_rtx
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|MEM_IN_STRUCT_P
argument_list|(
name|str_rtx
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Discount the part of the structure before the desired byte.      We need to know how many bytes are safe to reference after it.  */
if|if
condition|(
name|total_size
operator|>=
literal|0
condition|)
name|total_size
operator|-=
operator|(
name|bitpos
operator|/
name|BIGGEST_ALIGNMENT
operator|*
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
comment|/* The following line once was done only if WORDS_BIG_ENDIAN, 	 but I think that is a mistake.  WORDS_BIG_ENDIAN is 	 meaningful at a much higher level; when structures are copied 	 between memory and regs, the higher-numbered regs 	 always get higher addresses.  */
name|offset
operator|+=
name|SUBREG_WORD
argument_list|(
name|op0
argument_list|)
expr_stmt|;
comment|/* We used to adjust BITPOS here, but now we do the whole adjustment 	 right after the loop.  */
name|op0
operator|=
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|BYTES_BIG_ENDIAN
comment|/* If OP0 is a register, BITPOS must count within a word.      But as we have it, it counts within whatever size OP0 now has.      On a bigendian machine, these are not the same, so convert.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
operator|&&
name|unit
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
name|bitpos
operator|+=
name|unit
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|value
operator|=
name|protect_from_queue
argument_list|(
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_force_mem
condition|)
name|value
operator|=
name|force_not_mem
argument_list|(
name|value
argument_list|)
expr_stmt|;
comment|/* Note that the adjustment of BITPOS above has no effect on whether      BITPOS is 0 in a REG bigger than a word.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|fieldmode
argument_list|)
operator|>=
name|UNITS_PER_WORD
operator|&&
operator|(
operator|!
name|STRICT_ALIGNMENT
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
operator|)
operator|&&
name|bitpos
operator|==
literal|0
operator|&&
name|bitsize
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|fieldmode
argument_list|)
condition|)
block|{
comment|/* Storing in a full-word or multi-word field in a register 	 can be done with just SUBREG.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|fieldmode
condition|)
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
name|op0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|fieldmode
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|fieldmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
comment|/* Storing an lsb-aligned field in a register      can be done with a movestrict instruction.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
if|#
directive|if
name|BYTES_BIG_ENDIAN
operator|&&
name|bitpos
operator|+
name|bitsize
operator|==
name|unit
else|#
directive|else
operator|&&
name|bitpos
operator|==
literal|0
endif|#
directive|endif
operator|&&
name|bitsize
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|fieldmode
argument_list|)
operator|&&
operator|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|fieldmode
operator|||
operator|(
name|movstrict_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|fieldmode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|)
operator|)
condition|)
block|{
comment|/* Get appropriate low part of the value being stored.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REG
condition|)
name|value
operator|=
name|gen_lowpart
argument_list|(
name|fieldmode
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|LABEL_REF
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST
operator|)
condition|)
name|value
operator|=
name|convert_to_mode
argument_list|(
name|fieldmode
argument_list|,
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|fieldmode
condition|)
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|icode
init|=
name|movstrict_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|fieldmode
index|]
operator|.
name|insn_code
decl_stmt|;
if|if
condition|(
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
name|icode
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|value
argument_list|,
name|fieldmode
argument_list|)
condition|)
name|value
operator|=
name|copy_to_mode_reg
argument_list|(
name|fieldmode
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|fieldmode
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|)
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
comment|/* Handle fields bigger than a word.  */
if|if
condition|(
name|bitsize
operator|>
name|BITS_PER_WORD
condition|)
block|{
comment|/* Here we transfer the words of the field 	 in the order least significant first. 	 This is because the most significant word is the one which may 	 be less than full.  */
name|int
name|nwords
init|=
operator|(
name|bitsize
operator|+
operator|(
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|BITS_PER_WORD
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* This is the mode we must force value to, so that there will be enough 	 subwords to extract.  Note that fieldmode will often (always?) be 	 VOIDmode, because that is what store_field uses to indicate that this 	 is a bit field, but passing VOIDmode to operand_subword_force will 	 result in an abort.  */
name|fieldmode
operator|=
name|mode_for_size
argument_list|(
name|nwords
operator|*
name|BITS_PER_WORD
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
comment|/* If I is 0, use the low-order word in both field and target; 	     if I is 1, use the next to lowest word; and so on.  */
name|int
name|wordnum
init|=
operator|(
name|WORDS_BIG_ENDIAN
condition|?
name|nwords
operator|-
name|i
operator|-
literal|1
else|:
name|i
operator|)
decl_stmt|;
name|int
name|bit_offset
init|=
operator|(
name|WORDS_BIG_ENDIAN
condition|?
name|MAX
argument_list|(
name|bitsize
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|BITS_PER_WORD
argument_list|,
literal|0
argument_list|)
else|:
name|i
operator|*
name|BITS_PER_WORD
operator|)
decl_stmt|;
name|store_bit_field
argument_list|(
name|op0
argument_list|,
name|MIN
argument_list|(
name|BITS_PER_WORD
argument_list|,
name|bitsize
operator|-
name|i
operator|*
name|BITS_PER_WORD
argument_list|)
argument_list|,
name|bitnum
operator|+
name|bit_offset
argument_list|,
name|word_mode
argument_list|,
name|operand_subword_force
argument_list|(
name|value
argument_list|,
name|wordnum
argument_list|,
name|fieldmode
argument_list|)
argument_list|,
name|align
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
comment|/* From here on we can assume that the field to be stored in is      a full-word (whatever type that is), since it is shorter than a word.  */
comment|/* OFFSET is the number of words or bytes (UNIT says which)      from STR_RTX to the first word or byte containing part of the field.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|offset
operator|!=
literal|0
operator|||
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
name|op0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|TYPE_MODE
argument_list|(
name|type_for_size
argument_list|(
name|BITS_PER_WORD
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now OFFSET is nonzero only if OP0 is memory      and is therefore always measured in bytes.  */
ifdef|#
directive|ifdef
name|HAVE_insv
if|if
condition|(
name|HAVE_insv
operator|&&
operator|!
operator|(
name|bitsize
operator|==
literal|1
operator|&&
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
operator|)
comment|/* Ensure insv's size is wide enough for this field.  */
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_insv
index|]
index|[
literal|3
index|]
argument_list|)
operator|>=
name|bitsize
operator|)
condition|)
block|{
name|int
name|xbitpos
init|=
name|bitpos
decl_stmt|;
name|rtx
name|value1
decl_stmt|;
name|rtx
name|xop0
init|=
name|op0
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|enum
name|machine_mode
name|maxmode
init|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_insv
index|]
index|[
literal|3
index|]
decl_stmt|;
name|int
name|save_volatile_ok
init|=
name|volatile_ok
decl_stmt|;
name|volatile_ok
operator|=
literal|1
expr_stmt|;
comment|/* If this machine's insv can only insert into a register, or if we 	 are to force MEMs into a register, copy OP0 into a register and 	 save it back later.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
operator|(
name|flag_force_mem
operator|||
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_insv
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|op0
argument_list|,
name|VOIDmode
argument_list|)
operator|)
operator|)
condition|)
block|{
name|rtx
name|tempreg
decl_stmt|;
name|enum
name|machine_mode
name|bestmode
decl_stmt|;
comment|/* Get the mode to use for inserting into this field.  If OP0 is 	     BLKmode, get the smallest mode consistent with the alignment. If 	     OP0 is a non-BLKmode object that is no wider than MAXMODE, use its 	     mode. Otherwise, use the smallest mode containing the field.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|==
name|BLKmode
operator|||
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|maxmode
argument_list|)
condition|)
name|bestmode
operator|=
name|get_best_mode
argument_list|(
name|bitsize
argument_list|,
name|bitnum
argument_list|,
name|align
operator|*
name|BITS_PER_UNIT
argument_list|,
name|maxmode
argument_list|,
name|MEM_VOLATILE_P
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bestmode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bestmode
operator|==
name|VOIDmode
condition|)
goto|goto
name|insv_loses
goto|;
comment|/* Adjust address to point to the containing unit of that mode.  */
name|unit
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|bestmode
argument_list|)
expr_stmt|;
comment|/* Compute offset as multiple of this unit, counting in bytes.  */
name|offset
operator|=
operator|(
name|bitnum
operator|/
name|unit
operator|)
operator|*
name|GET_MODE_SIZE
argument_list|(
name|bestmode
argument_list|)
expr_stmt|;
name|bitpos
operator|=
name|bitnum
operator|%
name|unit
expr_stmt|;
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|bestmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch that unit, store the bitfield in it, then store the unit.  */
name|tempreg
operator|=
name|copy_to_reg
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|store_bit_field
argument_list|(
name|tempreg
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|fieldmode
argument_list|,
name|value
argument_list|,
name|align
argument_list|,
name|total_size
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|tempreg
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
name|volatile_ok
operator|=
name|save_volatile_ok
expr_stmt|;
comment|/* Add OFFSET into OP0's address.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|MEM
condition|)
name|xop0
operator|=
name|change_address
argument_list|(
name|xop0
argument_list|,
name|byte_mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|xop0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If xop0 is a register, we need it in MAXMODE 	 to make it acceptable to the format of insv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|SUBREG
condition|)
name|PUT_MODE
argument_list|(
name|xop0
argument_list|,
name|maxmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|maxmode
condition|)
name|xop0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|maxmode
argument_list|,
name|xop0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* On big-endian machines, we count bits from the most significant. 	 If the bit field insn does not, we must invert.  */
if|#
directive|if
name|BITS_BIG_ENDIAN
operator|!=
name|BYTES_BIG_ENDIAN
name|xbitpos
operator|=
name|unit
operator|-
name|bitsize
operator|-
name|xbitpos
expr_stmt|;
endif|#
directive|endif
comment|/* We have been counting XBITPOS within UNIT. 	 Count instead within the size of the register.  */
if|#
directive|if
name|BITS_BIG_ENDIAN
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|MEM
condition|)
name|xbitpos
operator|+=
name|GET_MODE_BITSIZE
argument_list|(
name|maxmode
argument_list|)
operator|-
name|unit
expr_stmt|;
endif|#
directive|endif
name|unit
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|maxmode
argument_list|)
expr_stmt|;
comment|/* Convert VALUE to maxmode (which insv insn wants) in VALUE1.  */
name|value1
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|!=
name|maxmode
condition|)
block|{
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|>=
name|bitsize
condition|)
block|{
comment|/* Optimization: Don't bother really extending VALUE 		 if it has all the bits we will actually use.  However, 		 if we must narrow it, be sure we do it correctly.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|maxmode
argument_list|)
condition|)
block|{
comment|/* Avoid making subreg of a subreg, or of a mem.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|value1
argument_list|)
operator|!=
name|REG
condition|)
name|value1
operator|=
name|copy_to_reg
argument_list|(
name|value1
argument_list|)
expr_stmt|;
name|value1
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|maxmode
argument_list|,
name|value1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|value1
operator|=
name|gen_lowpart
argument_list|(
name|maxmode
argument_list|,
name|value1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|CONSTANT_P
argument_list|(
name|value
argument_list|)
condition|)
comment|/* Parse phase is supposed to make VALUE's data type 	       match that of the component reference, which is a type 	       at least as wide as the field; so VALUE should have 	       a mode that corresponds to that type.  */
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If this machine's insv insists on a register, 	 get VALUE1 into a register.  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_insv
index|]
index|[
literal|3
index|]
call|)
argument_list|(
name|value1
argument_list|,
name|maxmode
argument_list|)
operator|)
condition|)
name|value1
operator|=
name|force_reg
argument_list|(
name|maxmode
argument_list|,
name|value1
argument_list|)
expr_stmt|;
name|pat
operator|=
name|gen_insv
argument_list|(
name|xop0
argument_list|,
name|GEN_INT
argument_list|(
name|bitsize
argument_list|)
argument_list|,
name|GEN_INT
argument_list|(
name|xbitpos
argument_list|)
argument_list|,
name|value1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
else|else
block|{
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|store_fixed_bit_field
argument_list|(
name|op0
argument_list|,
name|offset
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|value
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|insv_loses
label|:
endif|#
directive|endif
comment|/* Insv is not available; store using shifts and boolean ops.  */
name|store_fixed_bit_field
argument_list|(
name|op0
argument_list|,
name|offset
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|value
argument_list|,
name|align
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Use shifts and boolean operations to store VALUE    into a bit field of width BITSIZE    in a memory location specified by OP0 except offset by OFFSET bytes.      (OFFSET must be 0 if OP0 is a register.)    The field starts at position BITPOS within the byte.     (If OP0 is a register, it may be a full word or a narrower mode,      but BITPOS still counts within a full word,      which is significant on bigendian machines.)    STRUCT_ALIGN is the alignment the structure is known to have (in bytes).     Note that protect_from_queue has already been done on OP0 and VALUE.  */
end_comment

begin_function
specifier|static
name|void
name|store_fixed_bit_field
parameter_list|(
name|op0
parameter_list|,
name|offset
parameter_list|,
name|bitsize
parameter_list|,
name|bitpos
parameter_list|,
name|value
parameter_list|,
name|struct_align
parameter_list|)
specifier|register
name|rtx
name|op0
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|,
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
specifier|register
name|rtx
name|value
decl_stmt|;
name|int
name|struct_align
decl_stmt|;
block|{
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|total_bits
init|=
name|BITS_PER_WORD
decl_stmt|;
name|rtx
name|subtarget
decl_stmt|,
name|temp
decl_stmt|;
name|int
name|all_zero
init|=
literal|0
decl_stmt|;
name|int
name|all_one
init|=
literal|0
decl_stmt|;
comment|/* Add OFFSET to OP0's address (if it is in memory)      and if a single byte contains the whole bit field      change OP0 to a byte.  */
comment|/* There is a case not handled here:      a structure with a known alignment of just a halfword      and a field split across two aligned halfwords within the structure.      Or likewise a structure with a known alignment of just a byte      and a field split across two bytes.      Such cases are not supposed to be able to occur.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Special treatment for a bit field split across two registers.  */
if|if
condition|(
name|bitsize
operator|+
name|bitpos
operator|>
name|BITS_PER_WORD
condition|)
block|{
name|store_split_bit_field
argument_list|(
name|op0
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|value
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* Get the proper mode to use for this field.  We want a mode that 	 includes the entire field.  If such a mode would be larger than 	 a word, we won't be doing the extraction the normal way.  */
name|mode
operator|=
name|get_best_mode
argument_list|(
name|bitsize
argument_list|,
name|bitpos
operator|+
name|offset
operator|*
name|BITS_PER_UNIT
argument_list|,
name|struct_align
operator|*
name|BITS_PER_UNIT
argument_list|,
name|word_mode
argument_list|,
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
block|{
comment|/* The only way this should occur is if the field spans word 	     boundaries.  */
name|store_split_bit_field
argument_list|(
name|op0
argument_list|,
name|bitsize
argument_list|,
name|bitpos
operator|+
name|offset
operator|*
name|BITS_PER_UNIT
argument_list|,
name|value
argument_list|,
name|struct_align
argument_list|)
expr_stmt|;
return|return;
block|}
name|total_bits
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Get ref to an aligned byte, halfword, or word containing the field. 	 Adjust BITPOS to be position within a word, 	 and OFFSET to be the offset of that word. 	 Then alter OP0 to refer to that word.  */
name|bitpos
operator|+=
operator|(
name|offset
operator|%
operator|(
name|total_bits
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|offset
operator|-=
operator|(
name|offset
operator|%
operator|(
name|total_bits
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
comment|/* Now MODE is either some integral mode for a MEM as OP0,      or is a full-word for a REG as OP0.  TOTAL_BITS corresponds.      The bit field is contained entirely within OP0.      BITPOS is the starting bit number within OP0.      (OP0's mode may actually be narrower than MODE.)  */
if|#
directive|if
name|BYTES_BIG_ENDIAN
comment|/* BITPOS is the distance between our msb      and that of the containing datum.      Convert it to the distance from the lsb.  */
name|bitpos
operator|=
name|total_bits
operator|-
name|bitsize
operator|-
name|bitpos
expr_stmt|;
endif|#
directive|endif
comment|/* Now BITPOS is always the distance between our lsb      and that of OP0.  */
comment|/* Shift VALUE left by BITPOS bits.  If VALUE is not constant,      we must first convert its mode to MODE.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
specifier|register
name|HOST_WIDE_INT
name|v
init|=
name|INTVAL
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|bitsize
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|v
operator|&=
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
name|all_zero
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bitsize
operator|<
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|v
operator|==
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bitsize
operator|)
operator|-
literal|1
operator|)
operator|||
operator|(
name|bitsize
operator|==
name|HOST_BITS_PER_WIDE_INT
operator|&&
name|v
operator|==
operator|-
literal|1
operator|)
condition|)
name|all_one
operator|=
literal|1
expr_stmt|;
name|value
operator|=
name|lshift_value
argument_list|(
name|mode
argument_list|,
name|value
argument_list|,
name|bitpos
argument_list|,
name|bitsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|must_and
init|=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|!=
name|bitsize
operator|&&
name|bitpos
operator|+
name|bitsize
operator|!=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|!=
name|mode
condition|)
block|{
comment|/* If VALUE is a floating-point mode, access it as an integer 	     of the corresponding size, then convert it.  This can occur on 	     a machine with 64 bit registers that uses SFmode for float.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|REG
condition|)
name|value
operator|=
name|copy_to_reg
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|value
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|word_mode
argument_list|,
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|REG
operator|||
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|SUBREG
operator|)
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
argument_list|)
condition|)
name|value
operator|=
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|must_and
condition|)
name|value
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|and_optab
argument_list|,
name|value
argument_list|,
name|mask_rtx
argument_list|(
name|mode
argument_list|,
literal|0
argument_list|,
name|bitsize
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitpos
operator|>
literal|0
condition|)
name|value
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|value
argument_list|,
name|build_int_2
argument_list|(
name|bitpos
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now clear the chosen bits in OP0,      except that if VALUE is -1 we need not bother.  */
name|subtarget
operator|=
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|||
operator|!
name|flag_force_mem
operator|)
condition|?
name|op0
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|all_one
condition|)
block|{
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|and_optab
argument_list|,
name|op0
argument_list|,
name|mask_rtx
argument_list|(
name|mode
argument_list|,
name|bitpos
argument_list|,
name|bitsize
argument_list|,
literal|1
argument_list|)
argument_list|,
name|subtarget
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
name|subtarget
operator|=
name|temp
expr_stmt|;
block|}
else|else
name|temp
operator|=
name|op0
expr_stmt|;
comment|/* Now logical-or VALUE into OP0, unless it is zero.  */
if|if
condition|(
operator|!
name|all_zero
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ior_optab
argument_list|,
name|temp
argument_list|,
name|value
argument_list|,
name|subtarget
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|op0
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store a bit field that is split across two words.     OP0 is the REG, SUBREG or MEM rtx for the first of the two words.    BITSIZE is the field width; BITPOS the position of its first bit    (within the word).    VALUE is the value to store.  */
end_comment

begin_function
specifier|static
name|void
name|store_split_bit_field
parameter_list|(
name|op0
parameter_list|,
name|bitsize
parameter_list|,
name|bitpos
parameter_list|,
name|value
parameter_list|,
name|align
parameter_list|)
name|rtx
name|op0
decl_stmt|;
name|int
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
comment|/* BITSIZE_1 is size of the part in the first word.  */
name|int
name|bitsize_1
init|=
name|BITS_PER_WORD
operator|-
name|bitpos
operator|%
name|BITS_PER_WORD
decl_stmt|;
comment|/* BITSIZE_2 is size of the rest (in the following word).  */
name|int
name|bitsize_2
init|=
name|bitsize
operator|-
name|bitsize_1
decl_stmt|;
name|rtx
name|part1
decl_stmt|,
name|part2
decl_stmt|;
name|int
name|unit
init|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|?
name|BITS_PER_UNIT
else|:
name|BITS_PER_WORD
decl_stmt|;
name|int
name|offset
init|=
name|bitpos
operator|/
name|unit
decl_stmt|;
name|rtx
name|word
decl_stmt|;
comment|/* The field must span exactly one word boundary.  */
if|if
condition|(
name|bitpos
operator|/
name|BITS_PER_WORD
operator|!=
operator|(
name|bitpos
operator|+
name|bitsize
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_WORD
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|value
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|value
operator|=
name|convert_to_mode
argument_list|(
name|word_mode
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
operator|(
name|part1
operator|=
name|gen_lowpart_common
argument_list|(
name|word_mode
argument_list|,
name|value
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|value
operator|=
name|part1
expr_stmt|;
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|value
argument_list|)
operator|&&
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|value
operator|=
name|copy_to_mode_reg
argument_list|(
name|word_mode
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Split the value into two parts:      PART1 gets that which goes in the first word; PART2 the other.  */
if|#
directive|if
name|BYTES_BIG_ENDIAN
comment|/* PART1 gets the more significant part.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|part1
operator|=
name|GEN_INT
argument_list|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|INTVAL
argument_list|(
name|value
argument_list|)
argument_list|)
operator|>>
name|bitsize_2
argument_list|)
expr_stmt|;
name|part2
operator|=
name|GEN_INT
argument_list|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|INTVAL
argument_list|(
name|value
argument_list|)
argument_list|)
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bitsize_2
operator|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|part1
operator|=
name|extract_fixed_bit_field
argument_list|(
name|word_mode
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|bitsize_1
argument_list|,
name|BITS_PER_WORD
operator|-
name|bitsize
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
name|part2
operator|=
name|extract_fixed_bit_field
argument_list|(
name|word_mode
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|bitsize_2
argument_list|,
name|BITS_PER_WORD
operator|-
name|bitsize_2
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* PART1 gets the less significant part.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|value
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|part1
operator|=
name|GEN_INT
argument_list|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|INTVAL
argument_list|(
name|value
argument_list|)
argument_list|)
operator|&
operator|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|bitsize_1
operator|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|part2
operator|=
name|GEN_INT
argument_list|(
call|(
name|unsigned
name|HOST_WIDE_INT
call|)
argument_list|(
name|INTVAL
argument_list|(
name|value
argument_list|)
argument_list|)
operator|>>
name|bitsize_1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|part1
operator|=
name|extract_fixed_bit_field
argument_list|(
name|word_mode
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|bitsize_1
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
name|part2
operator|=
name|extract_fixed_bit_field
argument_list|(
name|word_mode
argument_list|,
name|value
argument_list|,
literal|0
argument_list|,
name|bitsize_2
argument_list|,
name|bitsize_1
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|BITS_PER_WORD
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Store PART1 into the first word.  If OP0 is a MEM, pass OP0 and the      offset computed above.  Otherwise, get the proper word and pass an      offset of zero.  */
name|word
operator|=
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|?
name|op0
else|:
name|operand_subword
argument_list|(
name|op0
argument_list|,
name|offset
argument_list|,
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|word
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|store_fixed_bit_field
argument_list|(
name|word
argument_list|,
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|?
name|offset
else|:
literal|0
argument_list|,
name|bitsize_1
argument_list|,
name|bitpos
operator|%
name|unit
argument_list|,
name|part1
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* Offset op0 by 1 word to get to the following one.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
name|word
operator|=
name|operand_subword
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|,
name|SUBREG_WORD
argument_list|(
name|op0
argument_list|)
operator|+
name|offset
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|)
name|word
operator|=
name|op0
expr_stmt|;
else|else
name|word
operator|=
name|operand_subword
argument_list|(
name|op0
argument_list|,
name|offset
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|word
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Store PART2 into the second word.  */
name|store_fixed_bit_field
argument_list|(
name|word
argument_list|,
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|?
name|CEIL
argument_list|(
name|offset
operator|+
literal|1
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|*
name|UNITS_PER_WORD
else|:
literal|0
operator|)
argument_list|,
name|bitsize_2
argument_list|,
literal|0
argument_list|,
name|part2
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generate code to extract a byte-field from STR_RTX    containing BITSIZE bits, starting at BITNUM,    and put it in TARGET if possible (if TARGET is nonzero).    Regardless of TARGET, we return the rtx for where the value is placed.    It may be a QUEUED.     STR_RTX is the structure containing the byte (a REG or MEM).    UNSIGNEDP is nonzero if this is an unsigned bit field.    MODE is the natural mode of the field value once extracted.    TMODE is the mode the caller would like the value to have;    but the value may be returned with type MODE instead.     ALIGN is the alignment that STR_RTX is known to have, measured in bytes.    TOTAL_SIZE is the size in bytes of the containing structure,    or -1 if varying.     If a TARGET is specified and we can store in it at no extra cost,    we do so, and return TARGET.    Otherwise, we return a REG of mode TMODE or MODE, with TMODE preferred    if they are equally easy.  */
end_comment

begin_function
name|rtx
name|extract_bit_field
parameter_list|(
name|str_rtx
parameter_list|,
name|bitsize
parameter_list|,
name|bitnum
parameter_list|,
name|unsignedp
parameter_list|,
name|target
parameter_list|,
name|mode
parameter_list|,
name|tmode
parameter_list|,
name|align
parameter_list|,
name|total_size
parameter_list|)
name|rtx
name|str_rtx
decl_stmt|;
specifier|register
name|int
name|bitsize
decl_stmt|;
name|int
name|bitnum
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|,
name|tmode
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|total_size
decl_stmt|;
block|{
name|int
name|unit
init|=
operator|(
name|GET_CODE
argument_list|(
name|str_rtx
argument_list|)
operator|==
name|MEM
operator|)
condition|?
name|BITS_PER_UNIT
else|:
name|BITS_PER_WORD
decl_stmt|;
specifier|register
name|int
name|offset
init|=
name|bitnum
operator|/
name|unit
decl_stmt|;
specifier|register
name|int
name|bitpos
init|=
name|bitnum
operator|%
name|unit
decl_stmt|;
specifier|register
name|rtx
name|op0
init|=
name|str_rtx
decl_stmt|;
name|rtx
name|spec_target
init|=
name|target
decl_stmt|;
name|rtx
name|spec_target_subreg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|str_rtx
argument_list|)
operator|==
name|MEM
operator|&&
operator|!
name|MEM_IN_STRUCT_P
argument_list|(
name|str_rtx
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Discount the part of the structure before the desired byte.      We need to know how many bytes are safe to reference after it.  */
if|if
condition|(
name|total_size
operator|>=
literal|0
condition|)
name|total_size
operator|-=
operator|(
name|bitpos
operator|/
name|BIGGEST_ALIGNMENT
operator|*
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|tmode
operator|==
name|VOIDmode
condition|)
name|tmode
operator|=
name|mode
expr_stmt|;
while|while
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
block|{
name|offset
operator|+=
name|SUBREG_WORD
argument_list|(
name|op0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|BYTES_BIG_ENDIAN
comment|/* If OP0 is a register, BITPOS must count within a word.      But as we have it, it counts within whatever size OP0 now has.      On a bigendian machine, these are not the same, so convert.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|MEM
operator|&&
name|unit
operator|>
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
condition|)
name|bitpos
operator|+=
name|unit
operator|-
name|GET_MODE_BITSIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Extracting a full-word or multi-word value      from a structure in a register.      This can be done with just SUBREG.      So too extracting a subword value in      the least significant part of the register.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|&&
operator|(
operator|(
name|bitsize
operator|>=
name|BITS_PER_WORD
operator|&&
name|bitsize
operator|==
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|&&
name|bitpos
operator|%
name|BITS_PER_WORD
operator|==
literal|0
operator|)
operator|||
operator|(
name|mode_for_size
argument_list|(
name|bitsize
argument_list|,
name|GET_MODE_CLASS
argument_list|(
name|tmode
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|BLKmode
if|#
directive|if
name|BYTES_BIG_ENDIAN
operator|&&
name|bitpos
operator|+
name|bitsize
operator|==
name|BITS_PER_WORD
else|#
directive|else
operator|&&
name|bitpos
operator|==
literal|0
endif|#
directive|endif
operator|)
operator|)
condition|)
block|{
name|enum
name|machine_mode
name|mode1
init|=
name|mode_for_size
argument_list|(
name|bitsize
argument_list|,
name|GET_MODE_CLASS
argument_list|(
name|tmode
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode1
operator|!=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
condition|)
name|op0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|mode1
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode1
operator|!=
name|mode
condition|)
return|return
name|convert_to_mode
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
return|;
return|return
name|op0
return|;
block|}
comment|/* Handle fields bigger than a word.  */
if|if
condition|(
name|bitsize
operator|>
name|BITS_PER_WORD
condition|)
block|{
comment|/* Here we transfer the words of the field 	 in the order least significant first. 	 This is because the most significant word is the one which may 	 be less than full.  */
name|int
name|nwords
init|=
operator|(
name|bitsize
operator|+
operator|(
name|BITS_PER_WORD
operator|-
literal|1
operator|)
operator|)
operator|/
name|BITS_PER_WORD
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
block|{
comment|/* If I is 0, use the low-order word in both field and target; 	     if I is 1, use the next to lowest word; and so on.  */
name|int
name|wordnum
init|=
operator|(
name|WORDS_BIG_ENDIAN
condition|?
name|nwords
operator|-
name|i
operator|-
literal|1
else|:
name|i
operator|)
decl_stmt|;
name|int
name|bit_offset
init|=
operator|(
name|WORDS_BIG_ENDIAN
condition|?
name|MAX
argument_list|(
literal|0
argument_list|,
name|bitsize
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|BITS_PER_WORD
argument_list|)
else|:
name|i
operator|*
name|BITS_PER_WORD
operator|)
decl_stmt|;
name|rtx
name|target_part
init|=
name|operand_subword
argument_list|(
name|target
argument_list|,
name|wordnum
argument_list|,
literal|1
argument_list|,
name|VOIDmode
argument_list|)
decl_stmt|;
name|rtx
name|result_part
init|=
name|extract_bit_field
argument_list|(
name|op0
argument_list|,
name|MIN
argument_list|(
name|BITS_PER_WORD
argument_list|,
name|bitsize
operator|-
name|i
operator|*
name|BITS_PER_WORD
argument_list|)
argument_list|,
name|bitnum
operator|+
name|bit_offset
argument_list|,
literal|1
argument_list|,
name|target_part
argument_list|,
name|mode
argument_list|,
name|word_mode
argument_list|,
name|align
argument_list|,
name|total_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|target_part
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|result_part
operator|!=
name|target_part
condition|)
name|emit_move_insn
argument_list|(
name|target_part
argument_list|,
name|result_part
argument_list|)
expr_stmt|;
block|}
return|return
name|target
return|;
block|}
comment|/* From here on we know the desired field is smaller than a word      so we can assume it is an integer.  So we can safely extract it as one      size of integer, if necessary, and then truncate or extend      to the size that is wanted.  */
comment|/* OFFSET is the number of words or bytes (UNIT says which)      from STR_RTX to the first word or byte containing part of the field.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|offset
operator|!=
literal|0
operator|||
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|>
name|UNITS_PER_WORD
condition|)
name|op0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|TYPE_MODE
argument_list|(
name|type_for_size
argument_list|(
name|BITS_PER_WORD
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|str_rtx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now OFFSET is nonzero only for memory operands.  */
if|if
condition|(
name|unsignedp
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_extzv
if|if
condition|(
name|HAVE_extzv
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|0
index|]
argument_list|)
operator|>=
name|bitsize
operator|)
condition|)
block|{
name|int
name|xbitpos
init|=
name|bitpos
decl_stmt|,
name|xoffset
init|=
name|offset
decl_stmt|;
name|rtx
name|bitsize_rtx
decl_stmt|,
name|bitpos_rtx
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|xop0
init|=
name|op0
decl_stmt|;
name|rtx
name|xtarget
init|=
name|target
decl_stmt|;
name|rtx
name|xspec_target
init|=
name|spec_target
decl_stmt|;
name|rtx
name|xspec_target_subreg
init|=
name|spec_target_subreg
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|enum
name|machine_mode
name|maxmode
init|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|MEM
condition|)
block|{
name|int
name|save_volatile_ok
init|=
name|volatile_ok
decl_stmt|;
name|volatile_ok
operator|=
literal|1
expr_stmt|;
comment|/* Is the memory operand acceptable?  */
if|if
condition|(
name|flag_force_mem
operator|||
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|xop0
argument_list|,
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* No, load into a reg and extract from there.  */
name|enum
name|machine_mode
name|bestmode
decl_stmt|;
comment|/* Get the mode to use for inserting into this field.  If 		     OP0 is BLKmode, get the smallest mode consistent with the 		     alignment. If OP0 is a non-BLKmode object that is no 		     wider than MAXMODE, use its mode. Otherwise, use the 		     smallest mode containing the field.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|BLKmode
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|maxmode
argument_list|)
operator|)
condition|)
name|bestmode
operator|=
name|get_best_mode
argument_list|(
name|bitsize
argument_list|,
name|bitnum
argument_list|,
name|align
operator|*
name|BITS_PER_UNIT
argument_list|,
name|maxmode
argument_list|,
name|MEM_VOLATILE_P
argument_list|(
name|xop0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bestmode
operator|=
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bestmode
operator|==
name|VOIDmode
condition|)
goto|goto
name|extzv_loses
goto|;
comment|/* Compute offset as multiple of this unit, 		     counting in bytes.  */
name|unit
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|bestmode
argument_list|)
expr_stmt|;
name|xoffset
operator|=
operator|(
name|bitnum
operator|/
name|unit
operator|)
operator|*
name|GET_MODE_SIZE
argument_list|(
name|bestmode
argument_list|)
expr_stmt|;
name|xbitpos
operator|=
name|bitnum
operator|%
name|unit
expr_stmt|;
name|xop0
operator|=
name|change_address
argument_list|(
name|xop0
argument_list|,
name|bestmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|xop0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|xoffset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch it to a register in that size.  */
name|xop0
operator|=
name|force_reg
argument_list|(
name|bestmode
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
comment|/* XBITPOS counts within UNIT, which is what is expected.  */
block|}
else|else
comment|/* Get ref to first byte containing part of the field.  */
name|xop0
operator|=
name|change_address
argument_list|(
name|xop0
argument_list|,
name|byte_mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|xop0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|xoffset
argument_list|)
argument_list|)
expr_stmt|;
name|volatile_ok
operator|=
name|save_volatile_ok
expr_stmt|;
block|}
comment|/* If op0 is a register, we need it in MAXMODE (which is usually 	     SImode). to make it acceptable to the format of extzv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|maxmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|maxmode
condition|)
name|xop0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|maxmode
argument_list|,
name|xop0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* On big-endian machines, we count bits from the most significant. 	     If the bit field insn does not, we must invert.  */
if|#
directive|if
name|BITS_BIG_ENDIAN
operator|!=
name|BYTES_BIG_ENDIAN
name|xbitpos
operator|=
name|unit
operator|-
name|bitsize
operator|-
name|xbitpos
expr_stmt|;
endif|#
directive|endif
comment|/* Now convert from counting within UNIT to counting in MAXMODE.  */
if|#
directive|if
name|BITS_BIG_ENDIAN
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|MEM
condition|)
name|xbitpos
operator|+=
name|GET_MODE_BITSIZE
argument_list|(
name|maxmode
argument_list|)
operator|-
name|unit
expr_stmt|;
endif|#
directive|endif
name|unit
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|maxmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|xtarget
operator|==
literal|0
operator|||
operator|(
name|flag_force_mem
operator|&&
name|GET_CODE
argument_list|(
name|xtarget
argument_list|)
operator|==
name|MEM
operator|)
condition|)
name|xtarget
operator|=
name|xspec_target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|xtarget
argument_list|)
operator|!=
name|maxmode
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|xtarget
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|wider
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|maxmode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|xtarget
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|xtarget
operator|=
name|gen_lowpart
argument_list|(
name|maxmode
argument_list|,
name|xtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|wider
condition|)
name|xspec_target_subreg
operator|=
name|xtarget
expr_stmt|;
block|}
else|else
name|xtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|maxmode
argument_list|)
expr_stmt|;
block|}
comment|/* If this machine's extzv insists on a register target, 	     make sure we have one.  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|xtarget
argument_list|,
name|maxmode
argument_list|)
operator|)
condition|)
name|xtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|maxmode
argument_list|)
expr_stmt|;
name|bitsize_rtx
operator|=
name|GEN_INT
argument_list|(
name|bitsize
argument_list|)
expr_stmt|;
name|bitpos_rtx
operator|=
name|GEN_INT
argument_list|(
name|xbitpos
argument_list|)
expr_stmt|;
name|pat
operator|=
name|gen_extzv
argument_list|(
name|protect_from_queue
argument_list|(
name|xtarget
argument_list|,
literal|1
argument_list|)
argument_list|,
name|xop0
argument_list|,
name|bitsize_rtx
argument_list|,
name|bitpos_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|target
operator|=
name|xtarget
expr_stmt|;
name|spec_target
operator|=
name|xspec_target
expr_stmt|;
name|spec_target_subreg
operator|=
name|xspec_target_subreg
expr_stmt|;
block|}
else|else
block|{
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|target
operator|=
name|extract_fixed_bit_field
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|extzv_loses
label|:
endif|#
directive|endif
name|target
operator|=
name|extract_fixed_bit_field
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_extv
if|if
condition|(
name|HAVE_extv
operator|&&
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extv
index|]
index|[
literal|0
index|]
argument_list|)
operator|>=
name|bitsize
operator|)
condition|)
block|{
name|int
name|xbitpos
init|=
name|bitpos
decl_stmt|,
name|xoffset
init|=
name|offset
decl_stmt|;
name|rtx
name|bitsize_rtx
decl_stmt|,
name|bitpos_rtx
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|xop0
init|=
name|op0
decl_stmt|,
name|xtarget
init|=
name|target
decl_stmt|;
name|rtx
name|xspec_target
init|=
name|spec_target
decl_stmt|;
name|rtx
name|xspec_target_subreg
init|=
name|spec_target_subreg
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
name|enum
name|machine_mode
name|maxmode
init|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extv
index|]
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|MEM
condition|)
block|{
comment|/* Is the memory operand acceptable?  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extv
index|]
index|[
literal|1
index|]
call|)
argument_list|(
name|xop0
argument_list|,
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
argument_list|)
operator|)
condition|)
block|{
comment|/* No, load into a reg and extract from there.  */
name|enum
name|machine_mode
name|bestmode
decl_stmt|;
comment|/* Get the mode to use for inserting into this field.  If 		     OP0 is BLKmode, get the smallest mode consistent with the 		     alignment. If OP0 is a non-BLKmode object that is no 		     wider than MAXMODE, use its mode. Otherwise, use the 		     smallest mode containing the field.  */
if|if
condition|(
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|BLKmode
operator|||
operator|(
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|maxmode
argument_list|)
operator|)
condition|)
name|bestmode
operator|=
name|get_best_mode
argument_list|(
name|bitsize
argument_list|,
name|bitnum
argument_list|,
name|align
operator|*
name|BITS_PER_UNIT
argument_list|,
name|maxmode
argument_list|,
name|MEM_VOLATILE_P
argument_list|(
name|xop0
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bestmode
operator|=
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bestmode
operator|==
name|VOIDmode
condition|)
goto|goto
name|extv_loses
goto|;
comment|/* Compute offset as multiple of this unit, 		     counting in bytes.  */
name|unit
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|bestmode
argument_list|)
expr_stmt|;
name|xoffset
operator|=
operator|(
name|bitnum
operator|/
name|unit
operator|)
operator|*
name|GET_MODE_SIZE
argument_list|(
name|bestmode
argument_list|)
expr_stmt|;
name|xbitpos
operator|=
name|bitnum
operator|%
name|unit
expr_stmt|;
name|xop0
operator|=
name|change_address
argument_list|(
name|xop0
argument_list|,
name|bestmode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|xop0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|xoffset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch it to a register in that size.  */
name|xop0
operator|=
name|force_reg
argument_list|(
name|bestmode
argument_list|,
name|xop0
argument_list|)
expr_stmt|;
comment|/* XBITPOS counts within UNIT, which is what is expected.  */
block|}
else|else
comment|/* Get ref to first byte containing part of the field.  */
name|xop0
operator|=
name|change_address
argument_list|(
name|xop0
argument_list|,
name|byte_mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|xop0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|xoffset
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If op0 is a register, we need it in MAXMODE (which is usually 	     SImode) to make it acceptable to the format of extv.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|SUBREG
operator|&&
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|maxmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|==
name|REG
operator|&&
name|GET_MODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|maxmode
condition|)
name|xop0
operator|=
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|maxmode
argument_list|,
name|xop0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* On big-endian machines, we count bits from the most significant. 	     If the bit field insn does not, we must invert.  */
if|#
directive|if
name|BITS_BIG_ENDIAN
operator|!=
name|BYTES_BIG_ENDIAN
name|xbitpos
operator|=
name|unit
operator|-
name|bitsize
operator|-
name|xbitpos
expr_stmt|;
endif|#
directive|endif
comment|/* XBITPOS counts within a size of UNIT. 	     Adjust to count within a size of MAXMODE.  */
if|#
directive|if
name|BITS_BIG_ENDIAN
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop0
argument_list|)
operator|!=
name|MEM
condition|)
name|xbitpos
operator|+=
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|maxmode
argument_list|)
operator|-
name|unit
operator|)
expr_stmt|;
endif|#
directive|endif
name|unit
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|maxmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|xtarget
operator|==
literal|0
operator|||
operator|(
name|flag_force_mem
operator|&&
name|GET_CODE
argument_list|(
name|xtarget
argument_list|)
operator|==
name|MEM
operator|)
condition|)
name|xtarget
operator|=
name|xspec_target
operator|=
name|gen_reg_rtx
argument_list|(
name|tmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|xtarget
argument_list|)
operator|!=
name|maxmode
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|xtarget
argument_list|)
operator|==
name|REG
condition|)
block|{
name|int
name|wider
init|=
operator|(
name|GET_MODE_SIZE
argument_list|(
name|maxmode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|GET_MODE
argument_list|(
name|xtarget
argument_list|)
argument_list|)
operator|)
decl_stmt|;
name|xtarget
operator|=
name|gen_lowpart
argument_list|(
name|maxmode
argument_list|,
name|xtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|wider
condition|)
name|xspec_target_subreg
operator|=
name|xtarget
expr_stmt|;
block|}
else|else
name|xtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|maxmode
argument_list|)
expr_stmt|;
block|}
comment|/* If this machine's extv insists on a register target, 	     make sure we have one.  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extv
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|xtarget
argument_list|,
name|maxmode
argument_list|)
operator|)
condition|)
name|xtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|maxmode
argument_list|)
expr_stmt|;
name|bitsize_rtx
operator|=
name|GEN_INT
argument_list|(
name|bitsize
argument_list|)
expr_stmt|;
name|bitpos_rtx
operator|=
name|GEN_INT
argument_list|(
name|xbitpos
argument_list|)
expr_stmt|;
name|pat
operator|=
name|gen_extv
argument_list|(
name|protect_from_queue
argument_list|(
name|xtarget
argument_list|,
literal|1
argument_list|)
argument_list|,
name|xop0
argument_list|,
name|bitsize_rtx
argument_list|,
name|bitpos_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|target
operator|=
name|xtarget
expr_stmt|;
name|spec_target
operator|=
name|xspec_target
expr_stmt|;
name|spec_target_subreg
operator|=
name|xspec_target_subreg
expr_stmt|;
block|}
else|else
block|{
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|target
operator|=
name|extract_fixed_bit_field
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|extv_loses
label|:
endif|#
directive|endif
name|target
operator|=
name|extract_fixed_bit_field
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|,
name|offset
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target
operator|==
name|spec_target
condition|)
return|return
name|target
return|;
if|if
condition|(
name|target
operator|==
name|spec_target_subreg
condition|)
return|return
name|spec_target
return|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|tmode
operator|&&
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|mode
condition|)
block|{
comment|/* If the target mode is floating-point, first convert to the 	 integer mode of that size and then access it as a floating-point 	 value via a SUBREG.  */
if|if
condition|(
name|GET_MODE_CLASS
argument_list|(
name|tmode
argument_list|)
operator|==
name|MODE_FLOAT
condition|)
block|{
name|target
operator|=
name|convert_to_mode
argument_list|(
name|mode_for_size
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|tmode
argument_list|)
argument_list|,
name|MODE_INT
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|!=
name|REG
condition|)
name|target
operator|=
name|copy_to_reg
argument_list|(
name|target
argument_list|)
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|SUBREG
argument_list|,
name|tmode
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
block|}
else|else
return|return
name|convert_to_mode
argument_list|(
name|tmode
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
return|;
block|}
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Extract a bit field using shifts and boolean operations    Returns an rtx to represent the value.    OP0 addresses a register (word) or memory (byte).    BITPOS says which bit within the word or byte the bit field starts in.    OFFSET says how many bytes farther the bit field starts;     it is 0 if OP0 is a register.    BITSIZE says how many bits long the bit field is.     (If OP0 is a register, it may be narrower than a full word,      but BITPOS still counts within a full word,      which is significant on bigendian machines.)     UNSIGNEDP is nonzero for an unsigned bit field (don't sign-extend value).    If TARGET is nonzero, attempts to store the value there    and return TARGET, but this is not guaranteed.    If TARGET is not used, create a pseudo-reg of mode TMODE for the value.     ALIGN is the alignment that STR_RTX is known to have, measured in bytes.  */
end_comment

begin_function
specifier|static
name|rtx
name|extract_fixed_bit_field
parameter_list|(
name|tmode
parameter_list|,
name|op0
parameter_list|,
name|offset
parameter_list|,
name|bitsize
parameter_list|,
name|bitpos
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|,
name|align
parameter_list|)
name|enum
name|machine_mode
name|tmode
decl_stmt|;
specifier|register
name|rtx
name|op0
decl_stmt|,
name|target
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|,
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|int
name|align
decl_stmt|;
block|{
name|int
name|total_bits
init|=
name|BITS_PER_WORD
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
operator|||
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
condition|)
block|{
comment|/* Special treatment for a bit field split across two registers.  */
if|if
condition|(
name|bitsize
operator|+
name|bitpos
operator|>
name|BITS_PER_WORD
condition|)
return|return
name|extract_split_bit_field
argument_list|(
name|op0
argument_list|,
name|bitsize
argument_list|,
name|bitpos
argument_list|,
name|unsignedp
argument_list|,
name|align
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Get the proper mode to use for this field.  We want a mode that 	 includes the entire field.  If such a mode would be larger than 	 a word, we won't be doing the extraction the normal way.  */
name|mode
operator|=
name|get_best_mode
argument_list|(
name|bitsize
argument_list|,
name|bitpos
operator|+
name|offset
operator|*
name|BITS_PER_UNIT
argument_list|,
name|align
operator|*
name|BITS_PER_UNIT
argument_list|,
name|word_mode
argument_list|,
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
comment|/* The only way this should occur is if the field spans word 	   boundaries.  */
return|return
name|extract_split_bit_field
argument_list|(
name|op0
argument_list|,
name|bitsize
argument_list|,
name|bitpos
operator|+
name|offset
operator|*
name|BITS_PER_UNIT
argument_list|,
name|unsignedp
argument_list|,
name|align
argument_list|)
return|;
name|total_bits
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Make sure bitpos is valid for the chosen mode.  Adjust BITPOS to 	 be be in the range 0 to total_bits-1, and put any excess bytes in 	 OFFSET.  */
if|if
condition|(
name|bitpos
operator|>=
name|total_bits
condition|)
block|{
name|offset
operator|+=
operator|(
name|bitpos
operator|/
name|total_bits
operator|)
operator|*
operator|(
name|total_bits
operator|/
name|BITS_PER_UNIT
operator|)
expr_stmt|;
name|bitpos
operator|-=
operator|(
operator|(
name|bitpos
operator|/
name|total_bits
operator|)
operator|*
operator|(
name|total_bits
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
name|BITS_PER_UNIT
operator|)
expr_stmt|;
block|}
comment|/* Get ref to an aligned byte, halfword, or word containing the field. 	 Adjust BITPOS to be position within a word, 	 and OFFSET to be the offset of that word. 	 Then alter OP0 to refer to that word.  */
name|bitpos
operator|+=
operator|(
name|offset
operator|%
operator|(
name|total_bits
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
operator|*
name|BITS_PER_UNIT
expr_stmt|;
name|offset
operator|-=
operator|(
name|offset
operator|%
operator|(
name|total_bits
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
name|op0
operator|=
name|change_address
argument_list|(
name|op0
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
if|#
directive|if
name|BYTES_BIG_ENDIAN
comment|/* BITPOS is the distance between our msb and that of OP0.      Convert it to the distance from the lsb.  */
name|bitpos
operator|=
name|total_bits
operator|-
name|bitsize
operator|-
name|bitpos
expr_stmt|;
endif|#
directive|endif
comment|/* Now BITPOS is always the distance between the field's lsb and that of OP0.      We have reduced the big-endian case to the little-endian case.  */
if|if
condition|(
name|unsignedp
condition|)
block|{
if|if
condition|(
name|bitpos
condition|)
block|{
comment|/* If the field does not already start at the lsb, 	     shift it so it does.  */
name|tree
name|amount
init|=
name|build_int_2
argument_list|(
name|bitpos
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Maybe propagate the target for the shift.  */
comment|/* But not if we will return it--could confuse integrate.c.  */
name|rtx
name|subtarget
init|=
operator|(
name|target
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|REG_FUNCTION_VALUE_P
argument_list|(
name|target
argument_list|)
condition|?
name|target
else|:
literal|0
operator|)
decl_stmt|;
if|if
condition|(
name|tmode
operator|!=
name|mode
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|op0
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|amount
argument_list|,
name|subtarget
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Convert the value to the desired mode.  */
if|if
condition|(
name|mode
operator|!=
name|tmode
condition|)
name|op0
operator|=
name|convert_to_mode
argument_list|(
name|tmode
argument_list|,
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Unless the msb of the field used to be the msb when we shifted, 	 mask out the upper bits.  */
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|!=
name|bitpos
operator|+
name|bitsize
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|SLOW_ZERO_EXTEND
comment|/* Always generate an `and' if 	     we just zero-extended op0 and SLOW_ZERO_EXTEND, since it 	     will combine fruitfully with the zero-extend. */
condition||| tmode != mode
endif|#
directive|endif
endif|#
directive|endif
condition|)
return|return
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
name|and_optab
argument_list|,
name|op0
argument_list|,
name|mask_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|bitsize
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
return|;
return|return
name|op0
return|;
block|}
comment|/* To extract a signed bit-field, first shift its msb to the msb of the word,      then arithmetic-shift its lsb to the lsb of the word.  */
name|op0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|tmode
condition|)
name|target
operator|=
literal|0
expr_stmt|;
comment|/* Find the narrowest integer mode that contains the field.  */
for|for
control|(
name|mode
operator|=
name|GET_CLASS_NARROWEST_MODE
argument_list|(
name|MODE_INT
argument_list|)
init|;
name|mode
operator|!=
name|VOIDmode
condition|;
name|mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|mode
argument_list|)
control|)
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|>=
name|bitsize
operator|+
name|bitpos
condition|)
block|{
name|op0
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|!=
operator|(
name|bitsize
operator|+
name|bitpos
operator|)
condition|)
block|{
name|tree
name|amount
init|=
name|build_int_2
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
operator|(
name|bitsize
operator|+
name|bitpos
operator|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* Maybe propagate the target for the shift.  */
comment|/* But not if we will return the result--could confuse integrate.c.  */
name|rtx
name|subtarget
init|=
operator|(
name|target
operator|!=
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
operator|&&
operator|!
name|REG_FUNCTION_VALUE_P
argument_list|(
name|target
argument_list|)
condition|?
name|target
else|:
literal|0
operator|)
decl_stmt|;
name|op0
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|amount
argument_list|,
name|subtarget
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|build_int_2
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|bitsize
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a constant integer (CONST_INT or CONST_DOUBLE) mask value    of mode MODE with BITSIZE ones followed by BITPOS zeros, or the    complement of that if COMPLEMENT.  The mask is truncated if    necessary to the width of mode MODE.  */
end_comment

begin_function
specifier|static
name|rtx
name|mask_rtx
parameter_list|(
name|mode
parameter_list|,
name|bitpos
parameter_list|,
name|bitsize
parameter_list|,
name|complement
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|bitpos
decl_stmt|,
name|bitsize
decl_stmt|,
name|complement
decl_stmt|;
block|{
name|HOST_WIDE_INT
name|masklow
decl_stmt|,
name|maskhigh
decl_stmt|;
if|if
condition|(
name|bitpos
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|masklow
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|<<
name|bitpos
expr_stmt|;
else|else
name|masklow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bitpos
operator|+
name|bitsize
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|masklow
operator|&=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|bitpos
operator|-
name|bitsize
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|bitpos
operator|<=
name|HOST_BITS_PER_WIDE_INT
condition|)
name|maskhigh
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|maskhigh
operator|=
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|<<
operator|(
name|bitpos
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
if|if
condition|(
name|bitpos
operator|+
name|bitsize
operator|>
name|HOST_BITS_PER_WIDE_INT
condition|)
name|maskhigh
operator|&=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|>>
operator|(
literal|2
operator|*
name|HOST_BITS_PER_WIDE_INT
operator|-
name|bitpos
operator|-
name|bitsize
operator|)
operator|)
expr_stmt|;
else|else
name|maskhigh
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|complement
condition|)
block|{
name|maskhigh
operator|=
operator|~
name|maskhigh
expr_stmt|;
name|masklow
operator|=
operator|~
name|masklow
expr_stmt|;
block|}
return|return
name|immed_double_const
argument_list|(
name|masklow
argument_list|,
name|maskhigh
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a constant integer (CONST_INT or CONST_DOUBLE) rtx with the value    VALUE truncated to BITSIZE bits and then shifted left BITPOS bits.  */
end_comment

begin_function
specifier|static
name|rtx
name|lshift_value
parameter_list|(
name|mode
parameter_list|,
name|value
parameter_list|,
name|bitpos
parameter_list|,
name|bitsize
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|value
decl_stmt|;
name|int
name|bitpos
decl_stmt|,
name|bitsize
decl_stmt|;
block|{
name|unsigned
name|HOST_WIDE_INT
name|v
init|=
name|INTVAL
argument_list|(
name|value
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|low
decl_stmt|,
name|high
decl_stmt|;
if|if
condition|(
name|bitsize
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
name|v
operator|&=
operator|~
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
operator|-
literal|1
operator|<<
name|bitsize
operator|)
expr_stmt|;
if|if
condition|(
name|bitpos
operator|<
name|HOST_BITS_PER_WIDE_INT
condition|)
block|{
name|low
operator|=
name|v
operator|<<
name|bitpos
expr_stmt|;
name|high
operator|=
operator|(
name|bitpos
operator|>
literal|0
condition|?
operator|(
name|v
operator|>>
operator|(
name|HOST_BITS_PER_WIDE_INT
operator|-
name|bitpos
operator|)
operator|)
else|:
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|low
operator|=
literal|0
expr_stmt|;
name|high
operator|=
name|v
operator|<<
operator|(
name|bitpos
operator|-
name|HOST_BITS_PER_WIDE_INT
operator|)
expr_stmt|;
block|}
return|return
name|immed_double_const
argument_list|(
name|low
argument_list|,
name|high
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Extract a bit field that is split across two words    and return an RTX for the result.     OP0 is the REG, SUBREG or MEM rtx for the first of the two words.    BITSIZE is the field width; BITPOS, position of its first bit, in the word.    UNSIGNEDP is 1 if should zero-extend the contents; else sign-extend.  */
end_comment

begin_function
specifier|static
name|rtx
name|extract_split_bit_field
parameter_list|(
name|op0
parameter_list|,
name|bitsize
parameter_list|,
name|bitpos
parameter_list|,
name|unsignedp
parameter_list|,
name|align
parameter_list|)
name|rtx
name|op0
decl_stmt|;
name|int
name|bitsize
decl_stmt|,
name|bitpos
decl_stmt|,
name|unsignedp
decl_stmt|,
name|align
decl_stmt|;
block|{
comment|/* BITSIZE_1 is size of the part in the first word.  */
name|int
name|bitsize_1
init|=
name|BITS_PER_WORD
operator|-
name|bitpos
operator|%
name|BITS_PER_WORD
decl_stmt|;
comment|/* BITSIZE_2 is size of the rest (in the following word).  */
name|int
name|bitsize_2
init|=
name|bitsize
operator|-
name|bitsize_1
decl_stmt|;
name|rtx
name|part1
decl_stmt|,
name|part2
decl_stmt|,
name|result
decl_stmt|;
name|int
name|unit
init|=
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|?
name|BITS_PER_UNIT
else|:
name|BITS_PER_WORD
decl_stmt|;
name|int
name|offset
init|=
name|bitpos
operator|/
name|unit
decl_stmt|;
name|rtx
name|word
decl_stmt|;
comment|/* The field must span exactly one word boundary.  */
if|if
condition|(
name|bitpos
operator|/
name|BITS_PER_WORD
operator|!=
operator|(
name|bitpos
operator|+
name|bitsize
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_WORD
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Get the part of the bit field from the first word.  If OP0 is a MEM,      pass OP0 and the offset computed above.  Otherwise, get the proper      word and pass an offset of zero.  */
name|word
operator|=
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|?
name|op0
else|:
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|offset
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|part1
operator|=
name|extract_fixed_bit_field
argument_list|(
name|word_mode
argument_list|,
name|word
argument_list|,
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|?
name|offset
else|:
literal|0
argument_list|,
name|bitsize_1
argument_list|,
name|bitpos
operator|%
name|unit
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* Offset op0 by 1 word to get to the following one.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|SUBREG
condition|)
name|word
operator|=
name|operand_subword_force
argument_list|(
name|SUBREG_REG
argument_list|(
name|op0
argument_list|)
argument_list|,
name|SUBREG_WORD
argument_list|(
name|op0
argument_list|)
operator|+
name|offset
operator|+
literal|1
argument_list|,
name|VOIDmode
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|)
name|word
operator|=
name|op0
expr_stmt|;
else|else
name|word
operator|=
name|operand_subword_force
argument_list|(
name|op0
argument_list|,
name|offset
operator|+
literal|1
argument_list|,
name|GET_MODE
argument_list|(
name|op0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the part of the bit field from the second word.  */
name|part2
operator|=
name|extract_fixed_bit_field
argument_list|(
name|word_mode
argument_list|,
name|word
argument_list|,
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|?
name|CEIL
argument_list|(
name|offset
operator|+
literal|1
argument_list|,
name|UNITS_PER_WORD
argument_list|)
operator|*
name|UNITS_PER_WORD
else|:
literal|0
operator|)
argument_list|,
name|bitsize_2
argument_list|,
literal|0
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|align
argument_list|)
expr_stmt|;
comment|/* Shift the more significant part up to fit above the other part.  */
if|#
directive|if
name|BYTES_BIG_ENDIAN
name|part1
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|word_mode
argument_list|,
name|part1
argument_list|,
name|build_int_2
argument_list|(
name|bitsize_2
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|part2
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|word_mode
argument_list|,
name|part2
argument_list|,
name|build_int_2
argument_list|(
name|bitsize_1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Combine the two parts with bitwise or.  This works      because we extracted both parts as unsigned bit fields.  */
name|result
operator|=
name|expand_binop
argument_list|(
name|word_mode
argument_list|,
name|ior_optab
argument_list|,
name|part1
argument_list|,
name|part2
argument_list|,
name|NULL_RTX
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
comment|/* Unsigned bit field: we are done.  */
if|if
condition|(
name|unsignedp
condition|)
return|return
name|result
return|;
comment|/* Signed bit field: sign-extend with two arithmetic shifts.  */
name|result
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|word_mode
argument_list|,
name|result
argument_list|,
name|build_int_2
argument_list|(
name|BITS_PER_WORD
operator|-
name|bitsize
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|word_mode
argument_list|,
name|result
argument_list|,
name|build_int_2
argument_list|(
name|BITS_PER_WORD
operator|-
name|bitsize
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add INC into TARGET.  */
end_comment

begin_function
name|void
name|expand_inc
parameter_list|(
name|target
parameter_list|,
name|inc
parameter_list|)
name|rtx
name|target
decl_stmt|,
name|inc
decl_stmt|;
block|{
name|rtx
name|value
init|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|add_optab
argument_list|,
name|target
argument_list|,
name|inc
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subtract DEC from TARGET.  */
end_comment

begin_function
name|void
name|expand_dec
parameter_list|(
name|target
parameter_list|,
name|dec
parameter_list|)
name|rtx
name|target
decl_stmt|,
name|dec
decl_stmt|;
block|{
name|rtx
name|value
init|=
name|expand_binop
argument_list|(
name|GET_MODE
argument_list|(
name|target
argument_list|)
argument_list|,
name|sub_optab
argument_list|,
name|target
argument_list|,
name|dec
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a shift instruction for expression code CODE,    with SHIFTED being the rtx for the value to shift,    and AMOUNT the tree for the amount to shift by.    Store the result in the rtx TARGET, if that is convenient.    If UNSIGNEDP is nonzero, do a logical shift; otherwise, arithmetic.    Return the rtx for where the value is.  */
end_comment

begin_function
name|rtx
name|expand_shift
parameter_list|(
name|code
parameter_list|,
name|mode
parameter_list|,
name|shifted
parameter_list|,
name|amount
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|tree_code
name|code
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|shifted
decl_stmt|;
name|tree
name|amount
decl_stmt|;
specifier|register
name|rtx
name|target
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
specifier|register
name|rtx
name|op1
decl_stmt|,
name|temp
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|left
init|=
operator|(
name|code
operator|==
name|LSHIFT_EXPR
operator|||
name|code
operator|==
name|LROTATE_EXPR
operator|)
decl_stmt|;
specifier|register
name|int
name|rotate
init|=
operator|(
name|code
operator|==
name|LROTATE_EXPR
operator|||
name|code
operator|==
name|RROTATE_EXPR
operator|)
decl_stmt|;
name|int
name|try
decl_stmt|;
comment|/* Previously detected shift-counts computed by NEGATE_EXPR      and shifted in the other direction; but that does not work      on all machines.  */
name|op1
operator|=
name|expand_expr
argument_list|(
name|amount
argument_list|,
name|NULL_RTX
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|op1
operator|==
name|const0_rtx
condition|)
return|return
name|shifted
return|;
for|for
control|(
name|try
operator|=
literal|0
init|;
name|temp
operator|==
literal|0
operator|&&
name|try
operator|<
literal|3
condition|;
name|try
operator|++
control|)
block|{
name|enum
name|optab_methods
name|methods
decl_stmt|;
if|if
condition|(
name|try
operator|==
literal|0
condition|)
name|methods
operator|=
name|OPTAB_DIRECT
expr_stmt|;
elseif|else
if|if
condition|(
name|try
operator|==
literal|1
condition|)
name|methods
operator|=
name|OPTAB_WIDEN
expr_stmt|;
else|else
name|methods
operator|=
name|OPTAB_LIB_WIDEN
expr_stmt|;
if|if
condition|(
name|rotate
condition|)
block|{
comment|/* Widening does not work for rotation.  */
if|if
condition|(
name|methods
operator|==
name|OPTAB_WIDEN
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|methods
operator|==
name|OPTAB_LIB_WIDEN
condition|)
block|{
comment|/* If we are rotating by a constant that is valid and 		 we have been unable to open-code this by a rotation, 		 do it as the IOR of two shifts.  I.e., to rotate A 		 by N bits, compute (A<< N) | ((unsigned) A>> (C - N)) 		 where C is the bitsize of A.  		 It is theoretically possible that the target machine might 		 not be able to perform either shift and hence we would 		 be making two libcalls rather than just the one for the 		 shift (similarly if IOR could not be done).  We will allow 		 this extremely unlikely lossage to avoid complicating the 		 code below.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|rtx
name|subtarget
init|=
name|target
operator|==
name|shifted
condition|?
literal|0
else|:
name|target
decl_stmt|;
name|rtx
name|temp1
decl_stmt|;
name|tree
name|other_amount
init|=
name|build_int_2
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|shifted
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|shifted
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_shift
argument_list|(
name|left
condition|?
name|LSHIFT_EXPR
else|:
name|RSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|shifted
argument_list|,
name|amount
argument_list|,
name|subtarget
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|temp1
operator|=
name|expand_shift
argument_list|(
name|left
condition|?
name|RSHIFT_EXPR
else|:
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|shifted
argument_list|,
name|other_amount
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ior_optab
argument_list|,
name|temp
argument_list|,
name|temp1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
return|;
block|}
else|else
name|methods
operator|=
name|OPTAB_LIB
expr_stmt|;
block|}
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|left
condition|?
name|rotl_optab
else|:
name|rotr_optab
argument_list|,
name|shifted
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
comment|/* If we don't have the rotate, but we are rotating by a constant 	     that is in range, try a rotate in the opposite direction.  */
if|if
condition|(
name|temp
operator|==
literal|0
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|>
literal|0
operator|&&
name|INTVAL
argument_list|(
name|op1
argument_list|)
operator|<
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|left
condition|?
name|rotr_optab
else|:
name|rotl_optab
argument_list|,
name|shifted
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unsignedp
condition|)
block|{
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|left
condition|?
name|lshl_optab
else|:
name|lshr_optab
argument_list|,
name|shifted
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
literal|0
operator|&&
name|left
condition|)
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ashl_optab
argument_list|,
name|shifted
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods
argument_list|)
expr_stmt|;
block|}
comment|/* Do arithmetic shifts. 	 Also, if we are going to widen the operand, we can just as well 	 use an arithmetic right-shift instead of a logical one.  */
if|if
condition|(
name|temp
operator|==
literal|0
operator|&&
operator|!
name|rotate
operator|&&
operator|(
operator|!
name|unsignedp
operator|||
operator|(
operator|!
name|left
operator|&&
name|methods
operator|==
name|OPTAB_WIDEN
operator|)
operator|)
condition|)
block|{
name|enum
name|optab_methods
name|methods1
init|=
name|methods
decl_stmt|;
comment|/* If trying to widen a log shift to an arithmetic shift, 	     don't accept an arithmetic shift of the same size.  */
if|if
condition|(
name|unsignedp
condition|)
name|methods1
operator|=
name|OPTAB_MUST_WIDEN
expr_stmt|;
comment|/* Arithmetic shift */
name|temp
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|left
condition|?
name|ashl_optab
else|:
name|ashr_optab
argument_list|,
name|shifted
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|methods1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_extzv
comment|/* We can do a logical (unsigned) right shift with a bit-field 	 extract insn.  But first check if one of the above methods worked.  */
if|if
condition|(
name|temp
operator|!=
literal|0
condition|)
return|return
name|temp
return|;
if|if
condition|(
name|unsignedp
operator|&&
name|code
operator|==
name|RSHIFT_EXPR
operator|&&
operator|!
name|BITS_BIG_ENDIAN
operator|&&
name|HAVE_extzv
condition|)
block|{
name|enum
name|machine_mode
name|output_mode
init|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|methods
operator|==
name|OPTAB_DIRECT
operator|&&
name|mode
operator|==
name|output_mode
operator|)
operator|||
operator|(
name|methods
operator|==
name|OPTAB_WIDEN
operator|&&
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|GET_MODE_SIZE
argument_list|(
name|output_mode
argument_list|)
operator|)
condition|)
block|{
name|rtx
name|shifted1
init|=
name|convert_to_mode
argument_list|(
name|output_mode
argument_list|,
name|protect_from_queue
argument_list|(
name|shifted
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|enum
name|machine_mode
name|length_mode
init|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|2
index|]
decl_stmt|;
name|enum
name|machine_mode
name|pos_mode
init|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|3
index|]
decl_stmt|;
name|rtx
name|target1
init|=
literal|0
decl_stmt|;
name|rtx
name|last
init|=
name|get_last_insn
argument_list|()
decl_stmt|;
name|rtx
name|width
decl_stmt|;
name|rtx
name|xop1
init|=
name|op1
decl_stmt|;
name|rtx
name|pat
decl_stmt|;
if|if
condition|(
name|target
operator|!=
literal|0
condition|)
name|target1
operator|=
name|protect_from_queue
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We define extract insns as having OUTPUT_MODE in a register 		 and the mode of operand 1 in memory.  Since we want 		 OUTPUT_MODE, we will always force the operand into a 		 register.  At some point we might want to support MEM 		 directly. */
name|shifted1
operator|=
name|force_reg
argument_list|(
name|output_mode
argument_list|,
name|shifted1
argument_list|)
expr_stmt|;
comment|/* If we don't have or cannot use a suggested target, 		 make a place for the result, in the proper mode.  */
if|if
condition|(
name|methods
operator|==
name|OPTAB_WIDEN
operator|||
name|target1
operator|==
literal|0
operator|||
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|target1
argument_list|,
name|output_mode
argument_list|)
operator|)
condition|)
name|target1
operator|=
name|gen_reg_rtx
argument_list|(
name|output_mode
argument_list|)
expr_stmt|;
name|xop1
operator|=
name|protect_from_queue
argument_list|(
name|xop1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xop1
operator|=
name|convert_to_mode
argument_list|(
name|pos_mode
argument_list|,
name|xop1
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this machine's extzv insists on a register for 		 operand 3 (position), arrange for that.  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|3
index|]
call|)
argument_list|(
name|xop1
argument_list|,
name|pos_mode
argument_list|)
operator|)
condition|)
name|xop1
operator|=
name|force_reg
argument_list|(
name|pos_mode
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
comment|/* WIDTH gets the width of the bit field to extract: 		 wordsize minus # bits to shift by.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|xop1
argument_list|)
operator|==
name|CONST_INT
condition|)
name|width
operator|=
name|GEN_INT
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Now get the width in the proper mode.  */
name|op1
operator|=
name|protect_from_queue
argument_list|(
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|width
operator|=
name|convert_to_mode
argument_list|(
name|length_mode
argument_list|,
name|op1
argument_list|,
name|TREE_UNSIGNED
argument_list|(
name|TREE_TYPE
argument_list|(
name|amount
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|width
operator|=
name|expand_binop
argument_list|(
name|length_mode
argument_list|,
name|sub_optab
argument_list|,
name|GEN_INT
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
argument_list|)
argument_list|,
name|width
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
comment|/* If this machine's extzv insists on a register for 		 operand 2 (length), arrange for that.  */
if|if
condition|(
operator|!
operator|(
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|CODE_FOR_extzv
index|]
index|[
literal|2
index|]
call|)
argument_list|(
name|width
argument_list|,
name|length_mode
argument_list|)
operator|)
condition|)
name|width
operator|=
name|force_reg
argument_list|(
name|length_mode
argument_list|,
name|width
argument_list|)
expr_stmt|;
comment|/* Now extract with WIDTH, omitting OP1 least sig bits.  */
name|pat
operator|=
name|gen_extzv
argument_list|(
name|target1
argument_list|,
name|shifted1
argument_list|,
name|width
argument_list|,
name|xop1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
condition|)
block|{
name|emit_insn
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|temp
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|target1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
comment|/* Can also do logical shift with signed bit-field extract 	     followed by inserting the bit-field at a different position. 	     That strategy is not yet implemented.  */
block|}
endif|#
directive|endif
comment|/* HAVE_extzv */
block|}
if|if
condition|(
name|temp
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_escape
end_escape

begin_enum
enum|enum
name|alg_code
block|{
name|alg_zero
block|,
name|alg_m
block|,
name|alg_shift
block|,
name|alg_add_t_m2
block|,
name|alg_sub_t_m2
block|,
name|alg_add_factor
block|,
name|alg_sub_factor
block|,
name|alg_add_t2_m
block|,
name|alg_sub_t2_m
block|,
name|alg_add
block|,
name|alg_subtract
block|,
name|alg_factor
block|,
name|alg_shiftop
block|}
enum|;
end_enum

begin_comment
comment|/* This structure records a sequence of operations.    `ops' is the number of operations recorded.    `cost' is their total cost.    The operations are stored in `op' and the corresponding    logarithms of the integer coefficients in `log'.     These are the operations:    alg_zero		total := 0;    alg_m		total := multiplicand;    alg_shift		total := total * coeff    alg_add_t_m2		total := total + multiplicand * coeff;    alg_sub_t_m2		total := total - multiplicand * coeff;    alg_add_factor	total := total * coeff + total;    alg_sub_factor	total := total * coeff - total;    alg_add_t2_m		total := total * coeff + multiplicand;    alg_sub_t2_m		total := total * coeff - multiplicand;     The first operand must be either alg_zero or alg_m.  */
end_comment

begin_struct
struct|struct
name|algorithm
block|{
name|short
name|cost
decl_stmt|;
name|short
name|ops
decl_stmt|;
comment|/* The size of the OP and LOG fields are not directly related to the      word size, but the worst-case algorithms will be if we have few      consecutive ones or zeros, i.e., a multiplicand like 10101010101...      In that case we will generate shift-by-2, add, shift-by-2, add,...,      in total wordsize operations.  */
name|enum
name|alg_code
name|op
index|[
name|MAX_BITS_PER_WORD
index|]
decl_stmt|;
name|char
name|log
index|[
name|MAX_BITS_PER_WORD
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Compute and return the best algorithm for multiplying by T.    The algorithm must cost less than cost_limit    If retval.cost>= COST_LIMIT, no algorithm was found and all    other field of the returned struct are undefined.  */
end_comment

begin_function
specifier|static
name|struct
name|algorithm
name|synth_mult
parameter_list|(
name|t
parameter_list|,
name|cost_limit
parameter_list|)
name|unsigned
name|HOST_WIDE_INT
name|t
decl_stmt|;
name|int
name|cost_limit
decl_stmt|;
block|{
name|int
name|m
decl_stmt|;
name|struct
name|algorithm
modifier|*
name|best_alg
init|=
operator|(
expr|struct
name|algorithm
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|algorithm
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|algorithm
modifier|*
name|alg_in
init|=
operator|(
expr|struct
name|algorithm
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|algorithm
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|cost
decl_stmt|;
name|unsigned
name|HOST_WIDE_INT
name|q
decl_stmt|;
comment|/* Indicate that no algorithm is yet found.  If no algorithm      is found, this value will be returned and indicate failure.  */
name|best_alg
operator|->
name|cost
operator|=
name|cost_limit
expr_stmt|;
if|if
condition|(
name|cost_limit
operator|<=
literal|0
condition|)
return|return
operator|*
name|best_alg
return|;
comment|/* t == 1 can be done in zero cost.  */
if|if
condition|(
name|t
operator|==
literal|1
condition|)
block|{
name|best_alg
operator|->
name|ops
operator|=
literal|1
expr_stmt|;
name|best_alg
operator|->
name|cost
operator|=
literal|0
expr_stmt|;
name|best_alg
operator|->
name|op
index|[
literal|0
index|]
operator|=
name|alg_m
expr_stmt|;
return|return
operator|*
name|best_alg
return|;
block|}
comment|/* t == 0 sometimes has a cost.  If it does and it exceeds our limit,      fail now.  */
elseif|else
if|if
condition|(
name|t
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|zero_cost
operator|>=
name|cost_limit
condition|)
return|return
operator|*
name|best_alg
return|;
else|else
block|{
name|best_alg
operator|->
name|ops
operator|=
literal|1
expr_stmt|;
name|best_alg
operator|->
name|cost
operator|=
name|zero_cost
expr_stmt|;
name|best_alg
operator|->
name|op
index|[
literal|0
index|]
operator|=
name|alg_zero
expr_stmt|;
return|return
operator|*
name|best_alg
return|;
block|}
block|}
comment|/* If we have a group of zero bits at the low-order part of T, try      multiplying by the remaining bits and then doing a shift.  */
if|if
condition|(
operator|(
name|t
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|floor_log2
argument_list|(
name|t
operator|&
operator|-
name|t
argument_list|)
expr_stmt|;
comment|/* m = number of low zero bits */
name|q
operator|=
name|t
operator|>>
name|m
expr_stmt|;
name|cost
operator|=
name|shift_cost
index|[
name|m
index|]
expr_stmt|;
if|if
condition|(
name|cost
operator|<
name|cost_limit
condition|)
block|{
operator|*
name|alg_in
operator|=
name|synth_mult
argument_list|(
name|q
argument_list|,
name|cost_limit
operator|-
name|cost
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|alg_in
operator|->
name|cost
expr_stmt|;
if|if
condition|(
name|cost
operator|<
name|best_alg
operator|->
name|cost
condition|)
block|{
name|struct
name|algorithm
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|alg_in
operator|,
name|alg_in
operator|=
name|best_alg
operator|,
name|best_alg
operator|=
name|x
expr_stmt|;
name|best_alg
operator|->
name|log
index|[
name|best_alg
operator|->
name|ops
index|]
operator|=
name|m
expr_stmt|;
name|best_alg
operator|->
name|op
index|[
name|best_alg
operator|->
name|ops
operator|++
index|]
operator|=
name|alg_shift
expr_stmt|;
name|best_alg
operator|->
name|cost
operator|=
name|cost_limit
operator|=
name|cost
expr_stmt|;
block|}
block|}
block|}
comment|/* If we have an odd number, add or subtract one.  */
if|if
condition|(
operator|(
name|t
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|w
decl_stmt|;
for|for
control|(
name|w
operator|=
literal|1
init|;
operator|(
name|w
operator|&
name|t
operator|)
operator|!=
literal|0
condition|;
name|w
operator|<<=
literal|1
control|)
empty_stmt|;
if|if
condition|(
name|w
operator|>
literal|2
comment|/* Reject the case where t is 3. 	   Thus we prefer addition in that case.  */
operator|&&
name|t
operator|!=
literal|3
condition|)
block|{
comment|/* T ends with ...111.  Multiply by (T + 1) and subtract 1.  */
name|cost
operator|=
name|add_cost
expr_stmt|;
operator|*
name|alg_in
operator|=
name|synth_mult
argument_list|(
name|t
operator|+
literal|1
argument_list|,
name|cost_limit
operator|-
name|cost
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|alg_in
operator|->
name|cost
expr_stmt|;
if|if
condition|(
name|cost
operator|<
name|best_alg
operator|->
name|cost
condition|)
block|{
name|struct
name|algorithm
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|alg_in
operator|,
name|alg_in
operator|=
name|best_alg
operator|,
name|best_alg
operator|=
name|x
expr_stmt|;
name|best_alg
operator|->
name|log
index|[
name|best_alg
operator|->
name|ops
index|]
operator|=
literal|0
expr_stmt|;
name|best_alg
operator|->
name|op
index|[
name|best_alg
operator|->
name|ops
operator|++
index|]
operator|=
name|alg_sub_t_m2
expr_stmt|;
name|best_alg
operator|->
name|cost
operator|=
name|cost_limit
operator|=
name|cost
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* T ends with ...01 or ...011.  Multiply by (T - 1) and add 1.  */
name|cost
operator|=
name|add_cost
expr_stmt|;
operator|*
name|alg_in
operator|=
name|synth_mult
argument_list|(
name|t
operator|-
literal|1
argument_list|,
name|cost_limit
operator|-
name|cost
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|alg_in
operator|->
name|cost
expr_stmt|;
if|if
condition|(
name|cost
operator|<
name|best_alg
operator|->
name|cost
condition|)
block|{
name|struct
name|algorithm
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|alg_in
operator|,
name|alg_in
operator|=
name|best_alg
operator|,
name|best_alg
operator|=
name|x
expr_stmt|;
name|best_alg
operator|->
name|log
index|[
name|best_alg
operator|->
name|ops
index|]
operator|=
literal|0
expr_stmt|;
name|best_alg
operator|->
name|op
index|[
name|best_alg
operator|->
name|ops
operator|++
index|]
operator|=
name|alg_add_t_m2
expr_stmt|;
name|best_alg
operator|->
name|cost
operator|=
name|cost_limit
operator|=
name|cost
expr_stmt|;
block|}
block|}
block|}
comment|/* Look for factors of t of the form      t = q(2**m +- 1), 2<= m<= floor(log2(t - 1)).      If we find such a factor, we can multiply by t using an algorithm that      multiplies by q, shift the result by m and add/subtract it to itself.       We search for large factors first and loop down, even if large factors      are less probable than small; if we find a large factor we will find a      good sequence quickly, and therefore be able to prune (by decreasing      COST_LIMIT) the search.  */
for|for
control|(
name|m
operator|=
name|floor_log2
argument_list|(
name|t
operator|-
literal|1
argument_list|)
init|;
name|m
operator|>=
literal|2
condition|;
name|m
operator|--
control|)
block|{
name|unsigned
name|HOST_WIDE_INT
name|d
decl_stmt|;
name|d
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|m
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|t
operator|%
name|d
operator|==
literal|0
operator|&&
name|t
operator|>
name|d
condition|)
block|{
name|cost
operator|=
name|MIN
argument_list|(
name|shiftadd_cost
index|[
name|m
index|]
argument_list|,
name|add_cost
operator|+
name|shift_cost
index|[
name|m
index|]
argument_list|)
expr_stmt|;
operator|*
name|alg_in
operator|=
name|synth_mult
argument_list|(
name|t
operator|/
name|d
argument_list|,
name|cost_limit
operator|-
name|cost
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|alg_in
operator|->
name|cost
expr_stmt|;
if|if
condition|(
name|cost
operator|<
name|best_alg
operator|->
name|cost
condition|)
block|{
name|struct
name|algorithm
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|alg_in
operator|,
name|alg_in
operator|=
name|best_alg
operator|,
name|best_alg
operator|=
name|x
expr_stmt|;
name|best_alg
operator|->
name|log
index|[
name|best_alg
operator|->
name|ops
index|]
operator|=
name|m
expr_stmt|;
name|best_alg
operator|->
name|op
index|[
name|best_alg
operator|->
name|ops
operator|++
index|]
operator|=
name|alg_add_factor
expr_stmt|;
name|best_alg
operator|->
name|cost
operator|=
name|cost_limit
operator|=
name|cost
expr_stmt|;
block|}
block|}
name|d
operator|=
operator|(
operator|(
name|unsigned
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|m
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|t
operator|%
name|d
operator|==
literal|0
operator|&&
name|t
operator|>
name|d
condition|)
block|{
name|cost
operator|=
name|MIN
argument_list|(
name|shiftsub_cost
index|[
name|m
index|]
argument_list|,
name|add_cost
operator|+
name|shift_cost
index|[
name|m
index|]
argument_list|)
expr_stmt|;
operator|*
name|alg_in
operator|=
name|synth_mult
argument_list|(
name|t
operator|/
name|d
argument_list|,
name|cost_limit
operator|-
name|cost
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|alg_in
operator|->
name|cost
expr_stmt|;
if|if
condition|(
name|cost
operator|<
name|best_alg
operator|->
name|cost
condition|)
block|{
name|struct
name|algorithm
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|alg_in
operator|,
name|alg_in
operator|=
name|best_alg
operator|,
name|best_alg
operator|=
name|x
expr_stmt|;
name|best_alg
operator|->
name|log
index|[
name|best_alg
operator|->
name|ops
index|]
operator|=
name|m
expr_stmt|;
name|best_alg
operator|->
name|op
index|[
name|best_alg
operator|->
name|ops
operator|++
index|]
operator|=
name|alg_sub_factor
expr_stmt|;
name|best_alg
operator|->
name|cost
operator|=
name|cost_limit
operator|=
name|cost
expr_stmt|;
block|}
block|}
block|}
comment|/* Try shift-and-add (load effective address) instructions,      i.e. do a*3, a*5, a*9.  */
if|if
condition|(
operator|(
name|t
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|q
operator|=
name|t
operator|-
literal|1
expr_stmt|;
name|q
operator|=
name|q
operator|&
operator|-
name|q
expr_stmt|;
name|m
operator|=
name|exact_log2
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|>=
literal|0
condition|)
block|{
name|cost
operator|=
name|shiftadd_cost
index|[
name|m
index|]
expr_stmt|;
operator|*
name|alg_in
operator|=
name|synth_mult
argument_list|(
operator|(
name|t
operator|-
literal|1
operator|)
operator|>>
name|m
argument_list|,
name|cost_limit
operator|-
name|cost
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|alg_in
operator|->
name|cost
expr_stmt|;
if|if
condition|(
name|cost
operator|<
name|best_alg
operator|->
name|cost
condition|)
block|{
name|struct
name|algorithm
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|alg_in
operator|,
name|alg_in
operator|=
name|best_alg
operator|,
name|best_alg
operator|=
name|x
expr_stmt|;
name|best_alg
operator|->
name|log
index|[
name|best_alg
operator|->
name|ops
index|]
operator|=
name|m
expr_stmt|;
name|best_alg
operator|->
name|op
index|[
name|best_alg
operator|->
name|ops
operator|++
index|]
operator|=
name|alg_add_t2_m
expr_stmt|;
name|best_alg
operator|->
name|cost
operator|=
name|cost_limit
operator|=
name|cost
expr_stmt|;
block|}
block|}
name|q
operator|=
name|t
operator|+
literal|1
expr_stmt|;
name|q
operator|=
name|q
operator|&
operator|-
name|q
expr_stmt|;
name|m
operator|=
name|exact_log2
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|>=
literal|0
condition|)
block|{
name|cost
operator|=
name|shiftsub_cost
index|[
name|m
index|]
expr_stmt|;
operator|*
name|alg_in
operator|=
name|synth_mult
argument_list|(
operator|(
name|t
operator|+
literal|1
operator|)
operator|>>
name|m
argument_list|,
name|cost_limit
operator|-
name|cost
argument_list|)
expr_stmt|;
name|cost
operator|+=
name|alg_in
operator|->
name|cost
expr_stmt|;
if|if
condition|(
name|cost
operator|<
name|best_alg
operator|->
name|cost
condition|)
block|{
name|struct
name|algorithm
modifier|*
name|x
decl_stmt|;
name|x
operator|=
name|alg_in
operator|,
name|alg_in
operator|=
name|best_alg
operator|,
name|best_alg
operator|=
name|x
expr_stmt|;
name|best_alg
operator|->
name|log
index|[
name|best_alg
operator|->
name|ops
index|]
operator|=
name|m
expr_stmt|;
name|best_alg
operator|->
name|op
index|[
name|best_alg
operator|->
name|ops
operator|++
index|]
operator|=
name|alg_sub_t2_m
expr_stmt|;
name|best_alg
operator|->
name|cost
operator|=
name|cost_limit
operator|=
name|cost
expr_stmt|;
block|}
block|}
block|}
comment|/* If we are getting a too long sequence for `struct algorithm'      to record, store a fake cost to make this search fail.  */
if|if
condition|(
name|best_alg
operator|->
name|ops
operator|==
name|MAX_BITS_PER_WORD
condition|)
name|best_alg
operator|->
name|cost
operator|=
name|cost_limit
expr_stmt|;
return|return
operator|*
name|best_alg
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Perform a multiplication and return an rtx for the result.    MODE is mode of value; OP0 and OP1 are what to multiply (rtx's);    TARGET is a suggestion for where to store the result (an rtx).     We check specially for a constant integer as OP1.    If you want this check for OP0 as well, then before calling    you should swap the two operands if OP0 would be constant.  */
end_comment

begin_function
name|rtx
name|expand_mult
parameter_list|(
name|mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|target
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|rtx
name|const_op1
init|=
name|op1
decl_stmt|;
comment|/* If we are multiplying in DImode, it may still be a win      to try to work with shifts and adds.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
argument_list|)
operator|==
name|MODE_INT
operator|&&
name|HOST_BITS_PER_INT
operator|<=
name|BITS_PER_WORD
condition|)
block|{
if|if
condition|(
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op1
argument_list|)
operator|==
literal|0
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|op1
argument_list|)
operator|>=
literal|0
operator|)
operator|||
operator|(
name|CONST_DOUBLE_HIGH
argument_list|(
name|op1
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|CONST_DOUBLE_LOW
argument_list|(
name|op1
argument_list|)
operator|<
literal|0
operator|)
condition|)
name|const_op1
operator|=
name|GEN_INT
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We used to test optimize here, on the grounds that it's better to      produce a smaller program when -O is not used.      But this causes such a terrible slowdown sometimes      that it seems better to use synth_mult always.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|const_op1
argument_list|)
operator|==
name|CONST_INT
operator|&&
operator|!
name|mult_is_very_cheap
condition|)
block|{
name|struct
name|algorithm
name|alg
decl_stmt|;
name|struct
name|algorithm
name|neg_alg
decl_stmt|;
name|int
name|negate
init|=
literal|0
decl_stmt|;
name|HOST_WIDE_INT
name|val
init|=
name|INTVAL
argument_list|(
name|op1
argument_list|)
decl_stmt|;
name|HOST_WIDE_INT
name|val_so_far
decl_stmt|;
name|rtx
name|insn
decl_stmt|;
comment|/* Try to do the computation two ways: multiply by the negative of OP1 	 and then negate, or do the multiplication directly.  The latter is 	 usually faster for positive numbers and the former for negative 	 numbers, but the opposite can be faster if the original value 	 has a factor of 2**m +/- 1, while the negated value does not or 	 vice versa.  */
name|alg
operator|=
name|synth_mult
argument_list|(
name|val
argument_list|,
name|mult_cost
argument_list|)
expr_stmt|;
name|neg_alg
operator|=
name|synth_mult
argument_list|(
operator|-
name|val
argument_list|,
operator|(
name|alg
operator|.
name|cost
operator|<
name|mult_cost
condition|?
name|alg
operator|.
name|cost
else|:
name|mult_cost
operator|)
operator|-
name|negate_cost
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg_alg
operator|.
name|cost
operator|+
name|negate_cost
operator|<
name|alg
operator|.
name|cost
condition|)
name|alg
operator|=
name|neg_alg
operator|,
name|negate
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|alg
operator|.
name|cost
operator|<
name|mult_cost
condition|)
block|{
comment|/* We found something cheaper than a multiply insn.  */
name|int
name|opno
decl_stmt|;
name|rtx
name|accum
decl_stmt|,
name|tem
decl_stmt|;
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Avoid referencing memory over and over. 	     For speed, but also for correctness when mem is volatile.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
condition|)
name|op0
operator|=
name|force_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
comment|/* ACCUM starts out either as OP0 or as a zero, depending on 	     the first operation.  */
if|if
condition|(
name|alg
operator|.
name|op
index|[
literal|0
index|]
operator|==
name|alg_zero
condition|)
block|{
name|accum
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
name|val_so_far
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alg
operator|.
name|op
index|[
literal|0
index|]
operator|==
name|alg_m
condition|)
block|{
name|accum
operator|=
name|copy_to_mode_reg
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|val_so_far
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
for|for
control|(
name|opno
operator|=
literal|1
init|;
name|opno
operator|<
name|alg
operator|.
name|ops
condition|;
name|opno
operator|++
control|)
block|{
name|int
name|log
init|=
name|alg
operator|.
name|log
index|[
name|opno
index|]
decl_stmt|;
name|rtx
name|shift_subtarget
init|=
name|preserve_subexpressions_p
argument_list|()
condition|?
literal|0
else|:
name|accum
decl_stmt|;
name|rtx
name|add_target
init|=
name|opno
operator|==
name|alg
operator|.
name|ops
operator|-
literal|1
operator|&&
name|target
operator|!=
literal|0
condition|?
name|target
else|:
literal|0
decl_stmt|;
switch|switch
condition|(
name|alg
operator|.
name|op
index|[
name|opno
index|]
condition|)
block|{
case|case
name|alg_shift
case|:
name|accum
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|accum
argument_list|,
name|build_int_2
argument_list|(
name|log
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val_so_far
operator|<<=
name|log
expr_stmt|;
break|break;
case|case
name|alg_add_t_m2
case|:
name|tem
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|build_int_2
argument_list|(
name|log
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|accum
operator|=
name|force_operand
argument_list|(
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|accum
argument_list|,
name|tem
argument_list|)
argument_list|,
name|add_target
condition|?
name|add_target
else|:
name|accum
argument_list|)
expr_stmt|;
name|val_so_far
operator|+=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|log
expr_stmt|;
break|break;
case|case
name|alg_sub_t_m2
case|:
name|tem
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|build_int_2
argument_list|(
name|log
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|accum
operator|=
name|force_operand
argument_list|(
name|gen_rtx
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|accum
argument_list|,
name|tem
argument_list|)
argument_list|,
name|add_target
condition|?
name|add_target
else|:
name|accum
argument_list|)
expr_stmt|;
name|val_so_far
operator|-=
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|log
expr_stmt|;
break|break;
case|case
name|alg_add_t2_m
case|:
name|accum
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|accum
argument_list|,
name|build_int_2
argument_list|(
name|log
argument_list|,
literal|0
argument_list|)
argument_list|,
name|accum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|accum
operator|=
name|force_operand
argument_list|(
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|accum
argument_list|,
name|op0
argument_list|)
argument_list|,
name|add_target
condition|?
name|add_target
else|:
name|accum
argument_list|)
expr_stmt|;
name|val_so_far
operator|=
operator|(
name|val_so_far
operator|<<
name|log
operator|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|alg_sub_t2_m
case|:
name|accum
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|accum
argument_list|,
name|build_int_2
argument_list|(
name|log
argument_list|,
literal|0
argument_list|)
argument_list|,
name|accum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|accum
operator|=
name|force_operand
argument_list|(
name|gen_rtx
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|accum
argument_list|,
name|op0
argument_list|)
argument_list|,
name|add_target
condition|?
name|add_target
else|:
name|accum
argument_list|)
expr_stmt|;
name|val_so_far
operator|=
operator|(
name|val_so_far
operator|<<
name|log
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|alg_add_factor
case|:
name|tem
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|accum
argument_list|,
name|build_int_2
argument_list|(
name|log
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|accum
operator|=
name|force_operand
argument_list|(
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|accum
argument_list|,
name|tem
argument_list|)
argument_list|,
name|add_target
condition|?
name|add_target
else|:
name|accum
argument_list|)
expr_stmt|;
name|val_so_far
operator|+=
name|val_so_far
operator|<<
name|log
expr_stmt|;
break|break;
case|case
name|alg_sub_factor
case|:
name|tem
operator|=
name|expand_shift
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|accum
argument_list|,
name|build_int_2
argument_list|(
name|log
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|accum
operator|=
name|force_operand
argument_list|(
name|gen_rtx
argument_list|(
name|MINUS
argument_list|,
name|mode
argument_list|,
name|tem
argument_list|,
name|accum
argument_list|)
argument_list|,
name|add_target
condition|?
name|add_target
else|:
name|tem
argument_list|)
expr_stmt|;
name|val_so_far
operator|=
operator|(
name|val_so_far
operator|<<
name|log
operator|)
operator|-
name|val_so_far
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
empty_stmt|;
block|}
comment|/* Write a REG_EQUAL note on the last insn so that we can cse 		 multiplication sequences.  */
name|insn
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUAL
argument_list|,
name|gen_rtx
argument_list|(
name|MULT
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|GEN_INT
argument_list|(
name|val_so_far
argument_list|)
argument_list|)
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|negate
condition|)
block|{
name|val_so_far
operator|=
operator|-
name|val_so_far
expr_stmt|;
name|accum
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|neg_optab
argument_list|,
name|accum
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
name|val_so_far
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|accum
return|;
block|}
block|}
comment|/* This used to use umul_optab if unsigned,      but for non-widening multiply there is no difference      between signed and unsigned.  */
name|op0
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|smul_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|op0
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|op0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit the code to divide OP0 by OP1, putting the result in TARGET    if that is convenient, and returning where the result is.    You may request either the quotient or the remainder as the result;    specify REM_FLAG nonzero to get the remainder.     CODE is the expression code for which kind of division this is;    it controls how rounding is done.  MODE is the machine mode to use.    UNSIGNEDP nonzero means do unsigned division.  */
end_comment

begin_comment
comment|/* ??? For CEIL_MOD_EXPR, can compute incorrect remainder with ANDI    and then correct it by or'ing in missing high bits    if result of ANDI is nonzero.    For ROUND_MOD_EXPR, can use ANDI and then sign-extend the result.    This could optimize to a bfexts instruction.    But C doesn't use these operations, so their optimizations are    left for later.  */
end_comment

begin_function
name|rtx
name|expand_divmod
parameter_list|(
name|rem_flag
parameter_list|,
name|code
parameter_list|,
name|mode
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|target
parameter_list|,
name|unsignedp
parameter_list|)
name|int
name|rem_flag
decl_stmt|;
name|enum
name|tree_code
name|code
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|target
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
specifier|register
name|rtx
name|result
init|=
literal|0
decl_stmt|;
name|enum
name|machine_mode
name|compute_mode
decl_stmt|;
name|int
name|log
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|can_clobber_op0
decl_stmt|;
name|int
name|mod_insn_no_good
init|=
literal|0
decl_stmt|;
name|rtx
name|adjusted_op0
init|=
name|op0
decl_stmt|;
name|optab
name|optab1
decl_stmt|,
name|optab2
decl_stmt|;
comment|/* We shouldn't be called with op1 == const1_rtx, but some of the      code below will malfunction if we are, so check here and handle      the special case if so.  */
if|if
condition|(
name|op1
operator|==
name|const1_rtx
condition|)
return|return
name|rem_flag
condition|?
name|const0_rtx
else|:
name|op0
return|;
comment|/* Don't use the function value register as a target      since we have to read it as well as write it,      and function-inlining gets confused by this.  */
if|if
condition|(
name|target
operator|&&
name|REG_P
argument_list|(
name|target
argument_list|)
operator|&&
name|REG_FUNCTION_VALUE_P
argument_list|(
name|target
argument_list|)
condition|)
name|target
operator|=
literal|0
expr_stmt|;
comment|/* Don't clobber an operand while doing a multi-step calculation.  */
if|if
condition|(
name|target
condition|)
if|if
condition|(
operator|(
name|rem_flag
operator|&&
operator|(
name|reg_mentioned_p
argument_list|(
name|target
argument_list|,
name|op0
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|)
operator|)
operator|)
operator|||
name|reg_mentioned_p
argument_list|(
name|target
argument_list|,
name|op1
argument_list|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|MEM
operator|)
condition|)
name|target
operator|=
literal|0
expr_stmt|;
name|can_clobber_op0
operator|=
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|REG
operator|&&
name|op0
operator|==
name|target
operator|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
name|log
operator|=
name|exact_log2
argument_list|(
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If log is>= 0, we are dividing by 2**log, and will do it by shifting,      which is really floor-division.  Otherwise we will really do a divide,      and we assume that is trunc-division.       We must correct the dividend by adding or subtracting something      based on the divisor, in order to do the kind of rounding specified      by CODE.  The correction depends on what kind of rounding is actually      available, and that depends on whether we will shift or divide.       In many of these cases it is possible to perform the operation by a      clever series of logical operations (shifts and/or exclusive-ors).      Although avoiding the jump has the advantage that it extends the basic      block and allows further optimization, the branch-free code is normally      at least one instruction longer in the (most common) case where the      dividend is non-negative.  Performance measurements of the two      alternatives show that the branch-free code is slightly faster on the      IBM ROMP but slower on CISC processors (significantly slower on the      VAX).  Accordingly, the jump code has been retained.       On machines where the jump code is slower, the cost of a DIV or MOD      operation can be set small (less than twice that of an addition); in       that case, we pretend that we don't have a power of two and perform      a normal division or modulus operation.  */
if|if
condition|(
operator|(
name|code
operator|==
name|TRUNC_MOD_EXPR
operator|||
name|code
operator|==
name|TRUNC_DIV_EXPR
operator|)
operator|&&
operator|!
name|unsignedp
operator|&&
operator|(
name|rem_flag
condition|?
name|smod_pow2_cheap
else|:
name|sdiv_pow2_cheap
operator|)
condition|)
name|log
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Get the mode in which to perform this computation.  Normally it will      be MODE, but sometimes we can't do the desired operation in MODE.      If so, pick a wider mode in which we can do the operation.  Convert      to that mode at the start to avoid repeated conversions.       First see what operations we need.  These depend on the expression      we are evaluating.  (We assume that divxx3 insns exist under the      same conditions that modxx3 insns and that these insns don't normally      fail.  If these assumptions are not correct, we may generate less      efficient code in some cases.)       Then see if we find a mode in which we can open-code that operation      (either a division, modulus, or shift).  Finally, check for the smallest      mode for which we can do the operation with a library call.  */
name|optab1
operator|=
operator|(
name|log
operator|>=
literal|0
condition|?
operator|(
name|unsignedp
condition|?
name|lshr_optab
else|:
name|ashr_optab
operator|)
else|:
operator|(
name|unsignedp
condition|?
name|udiv_optab
else|:
name|sdiv_optab
operator|)
operator|)
expr_stmt|;
name|optab2
operator|=
operator|(
name|log
operator|>=
literal|0
condition|?
name|optab1
else|:
operator|(
name|unsignedp
condition|?
name|udivmod_optab
else|:
name|sdivmod_optab
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|compute_mode
operator|=
name|mode
init|;
name|compute_mode
operator|!=
name|VOIDmode
condition|;
name|compute_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|compute_mode
argument_list|)
control|)
if|if
condition|(
name|optab1
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|compute_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
operator|||
name|optab2
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|compute_mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
break|break;
if|if
condition|(
name|compute_mode
operator|==
name|VOIDmode
condition|)
for|for
control|(
name|compute_mode
operator|=
name|mode
init|;
name|compute_mode
operator|!=
name|VOIDmode
condition|;
name|compute_mode
operator|=
name|GET_MODE_WIDER_MODE
argument_list|(
name|compute_mode
argument_list|)
control|)
if|if
condition|(
name|optab1
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|compute_mode
index|]
operator|.
name|libfunc
operator|||
name|optab2
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|compute_mode
index|]
operator|.
name|libfunc
condition|)
break|break;
comment|/* If we still couldn't find a mode, use MODE; we'll probably abort in      expand_binop.  */
if|if
condition|(
name|compute_mode
operator|==
name|VOIDmode
condition|)
name|compute_mode
operator|=
name|mode
expr_stmt|;
name|size
operator|=
name|GET_MODE_BITSIZE
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
comment|/* Now convert to the best mode to use.  Show we made a copy of OP0      and hence we can clobber it (we cannot use a SUBREG to widen      something.  */
if|if
condition|(
name|compute_mode
operator|!=
name|mode
condition|)
block|{
name|adjusted_op0
operator|=
name|op0
operator|=
name|convert_to_mode
argument_list|(
name|compute_mode
argument_list|,
name|op0
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
name|can_clobber_op0
operator|=
literal|1
expr_stmt|;
name|op1
operator|=
name|convert_to_mode
argument_list|(
name|compute_mode
argument_list|,
name|op1
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
block|}
comment|/* If we are computing the remainder and one of the operands is a volatile      MEM, copy it into a register.  */
if|if
condition|(
name|rem_flag
operator|&&
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|op0
argument_list|)
condition|)
name|adjusted_op0
operator|=
name|op0
operator|=
name|force_reg
argument_list|(
name|compute_mode
argument_list|,
name|op0
argument_list|)
operator|,
name|can_clobber_op0
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rem_flag
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|MEM
operator|&&
name|MEM_VOLATILE_P
argument_list|(
name|op1
argument_list|)
condition|)
name|op1
operator|=
name|force_reg
argument_list|(
name|compute_mode
argument_list|,
name|op1
argument_list|)
expr_stmt|;
comment|/* If we are computing the remainder, op0 will be needed later to calculate      X - Y * (X / Y), therefore cannot be clobbered. */
if|if
condition|(
name|rem_flag
condition|)
name|can_clobber_op0
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|target
argument_list|)
operator|!=
name|compute_mode
condition|)
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TRUNC_MOD_EXPR
case|:
case|case
name|TRUNC_DIV_EXPR
case|:
if|if
condition|(
name|log
operator|>=
literal|0
operator|&&
operator|!
name|unsignedp
condition|)
block|{
comment|/* Here we need to add OP1-1 if OP0 is negative, 0 otherwise. 	     This can be computed without jumps by arithmetically shifting 	     OP0 right LOG-1 places and then shifting right logically 	     SIZE-LOG bits.  The resulting value is unconditionally added 	     to OP0.  */
if|if
condition|(
name|log
operator|==
literal|1
operator|||
name|BRANCH_COST
operator|>=
literal|3
condition|)
block|{
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|can_clobber_op0
condition|)
comment|/* Copy op0 to a reg, to play safe, 		   since this is done in the other path.  */
name|op0
operator|=
name|force_reg
argument_list|(
name|compute_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|copy_to_suggested_reg
argument_list|(
name|adjusted_op0
argument_list|,
name|temp
argument_list|,
name|compute_mode
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|temp
argument_list|,
name|build_int_2
argument_list|(
name|log
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|temp
argument_list|,
name|build_int_2
argument_list|(
name|size
operator|-
name|log
argument_list|,
literal|0
argument_list|)
argument_list|,
name|temp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We supply 0 as the target to make a new pseudo 		 for the value; that helps loop.c optimize the result.  */
name|adjusted_op0
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|add_optab
argument_list|,
name|adjusted_op0
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|can_clobber_op0
condition|)
block|{
name|adjusted_op0
operator|=
name|copy_to_suggested_reg
argument_list|(
name|adjusted_op0
argument_list|,
name|target
argument_list|,
name|compute_mode
argument_list|)
expr_stmt|;
comment|/* Copy op0 to a reg, since emit_cmp_insn will call emit_queue 		     which will screw up mem refs for autoincrements.  */
name|op0
operator|=
name|force_reg
argument_list|(
name|compute_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
name|emit_cmp_insn
argument_list|(
name|adjusted_op0
argument_list|,
name|const0_rtx
argument_list|,
name|GE
argument_list|,
name|NULL_RTX
argument_list|,
name|compute_mode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_bge
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|expand_inc
argument_list|(
name|adjusted_op0
argument_list|,
name|plus_constant
argument_list|(
name|op1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
name|mod_insn_no_good
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|FLOOR_DIV_EXPR
case|:
case|case
name|FLOOR_MOD_EXPR
case|:
if|if
condition|(
name|log
operator|<
literal|0
operator|&&
operator|!
name|unsignedp
condition|)
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|can_clobber_op0
condition|)
block|{
name|adjusted_op0
operator|=
name|copy_to_suggested_reg
argument_list|(
name|adjusted_op0
argument_list|,
name|target
argument_list|,
name|compute_mode
argument_list|)
expr_stmt|;
comment|/* Copy op0 to a reg, since emit_cmp_insn will call emit_queue 		 which will screw up mem refs for autoincrements.  */
name|op0
operator|=
name|force_reg
argument_list|(
name|compute_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
name|emit_cmp_insn
argument_list|(
name|adjusted_op0
argument_list|,
name|const0_rtx
argument_list|,
name|GE
argument_list|,
name|NULL_RTX
argument_list|,
name|compute_mode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_bge
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|expand_dec
argument_list|(
name|adjusted_op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|expand_inc
argument_list|(
name|adjusted_op0
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|mod_insn_no_good
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|CEIL_DIV_EXPR
case|:
case|case
name|CEIL_MOD_EXPR
case|:
if|if
condition|(
operator|!
name|can_clobber_op0
condition|)
block|{
name|adjusted_op0
operator|=
name|copy_to_suggested_reg
argument_list|(
name|adjusted_op0
argument_list|,
name|target
argument_list|,
name|compute_mode
argument_list|)
expr_stmt|;
comment|/* Copy op0 to a reg, since emit_cmp_insn will call emit_queue 	     which will screw up mem refs for autoincrements.  */
name|op0
operator|=
name|force_reg
argument_list|(
name|compute_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log
operator|<
literal|0
condition|)
block|{
name|rtx
name|label
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|unsignedp
condition|)
block|{
name|label
operator|=
name|gen_label_rtx
argument_list|()
expr_stmt|;
name|emit_cmp_insn
argument_list|(
name|adjusted_op0
argument_list|,
name|const0_rtx
argument_list|,
name|LE
argument_list|,
name|NULL_RTX
argument_list|,
name|compute_mode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_ble
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|expand_inc
argument_list|(
name|adjusted_op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
name|expand_dec
argument_list|(
name|adjusted_op0
argument_list|,
name|const1_rtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unsignedp
condition|)
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|adjusted_op0
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|add_optab
argument_list|,
name|adjusted_op0
argument_list|,
name|plus_constant
argument_list|(
name|op1
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
name|mod_insn_no_good
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ROUND_DIV_EXPR
case|:
case|case
name|ROUND_MOD_EXPR
case|:
if|if
condition|(
operator|!
name|can_clobber_op0
condition|)
block|{
name|adjusted_op0
operator|=
name|copy_to_suggested_reg
argument_list|(
name|adjusted_op0
argument_list|,
name|target
argument_list|,
name|compute_mode
argument_list|)
expr_stmt|;
comment|/* Copy op0 to a reg, since emit_cmp_insn will call emit_queue 	     which will screw up mem refs for autoincrements.  */
name|op0
operator|=
name|force_reg
argument_list|(
name|compute_mode
argument_list|,
name|op0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log
operator|<
literal|0
condition|)
block|{
name|op1
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|op1
argument_list|,
name|integer_one_node
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unsignedp
condition|)
block|{
if|if
condition|(
name|BRANCH_COST
operator|>=
literal|2
condition|)
block|{
comment|/* Negate OP1 if OP0< 0.  Do this by computing a temporary 		     that has all bits equal to the sign bit and exclusive 		     or-ing it with OP1.  */
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
decl_stmt|;
name|temp
operator|=
name|copy_to_suggested_reg
argument_list|(
name|adjusted_op0
argument_list|,
name|temp
argument_list|,
name|compute_mode
argument_list|)
expr_stmt|;
name|temp
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|temp
argument_list|,
name|build_int_2
argument_list|(
name|size
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op1
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|xor_optab
argument_list|,
name|op1
argument_list|,
name|temp
argument_list|,
name|op1
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtx
name|label
init|=
name|gen_label_rtx
argument_list|()
decl_stmt|;
name|emit_cmp_insn
argument_list|(
name|adjusted_op0
argument_list|,
name|const0_rtx
argument_list|,
name|GE
argument_list|,
name|NULL_RTX
argument_list|,
name|compute_mode
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_jump_insn
argument_list|(
name|gen_bge
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|expand_unop
argument_list|(
name|compute_mode
argument_list|,
name|neg_optab
argument_list|,
name|op1
argument_list|,
name|op1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|emit_label
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
block|}
name|expand_inc
argument_list|(
name|adjusted_op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|op1
operator|=
name|GEN_INT
argument_list|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|log
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|expand_inc
argument_list|(
name|adjusted_op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
name|mod_insn_no_good
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rem_flag
operator|&&
operator|!
name|mod_insn_no_good
condition|)
block|{
comment|/* Try to produce the remainder directly */
if|if
condition|(
name|log
operator|>=
literal|0
condition|)
name|result
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|and_optab
argument_list|,
name|adjusted_op0
argument_list|,
name|GEN_INT
argument_list|(
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
name|log
operator|)
operator|-
literal|1
argument_list|)
argument_list|,
name|target
argument_list|,
literal|1
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* See if we can do remainder without a library call.  */
name|result
operator|=
name|sign_expand_binop
argument_list|(
name|mode
argument_list|,
name|umod_optab
argument_list|,
name|smod_optab
argument_list|,
name|adjusted_op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
comment|/* No luck there.  Can we do remainder and divide at once 		 without a library call?  */
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|compute_mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expand_twoval_binop
argument_list|(
name|unsignedp
condition|?
name|udivmod_optab
else|:
name|sdivmod_optab
argument_list|,
name|adjusted_op0
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
name|result
argument_list|,
name|unsignedp
argument_list|)
condition|)
name|result
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|result
condition|)
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|result
argument_list|)
return|;
comment|/* Produce the quotient.  */
if|if
condition|(
name|log
operator|>=
literal|0
condition|)
name|result
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compute_mode
argument_list|,
name|adjusted_op0
argument_list|,
name|build_int_2
argument_list|(
name|log
argument_list|,
literal|0
argument_list|)
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rem_flag
operator|&&
operator|!
name|mod_insn_no_good
condition|)
comment|/* If producing quotient in order to subtract for remainder,        and a remainder subroutine would be ok,        don't use a divide subroutine.  */
name|result
operator|=
name|sign_expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|udiv_optab
argument_list|,
name|sdiv_optab
argument_list|,
name|adjusted_op0
argument_list|,
name|op1
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Try a quotient insn, but not a library call.  */
name|result
operator|=
name|sign_expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|udiv_optab
argument_list|,
name|sdiv_optab
argument_list|,
name|adjusted_op0
argument_list|,
name|op1
argument_list|,
name|rem_flag
condition|?
name|NULL_RTX
else|:
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
block|{
comment|/* No luck there.  Try a quotient-and-remainder insn, 	     keeping the quotient alone.  */
name|result
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|expand_twoval_binop
argument_list|(
name|unsignedp
condition|?
name|udivmod_optab
else|:
name|sdivmod_optab
argument_list|,
name|adjusted_op0
argument_list|,
name|op1
argument_list|,
name|result
argument_list|,
name|NULL_RTX
argument_list|,
name|unsignedp
argument_list|)
condition|)
name|result
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If still no luck, use a library call.  */
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|result
operator|=
name|sign_expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|udiv_optab
argument_list|,
name|sdiv_optab
argument_list|,
name|adjusted_op0
argument_list|,
name|op1
argument_list|,
name|rem_flag
condition|?
name|NULL_RTX
else|:
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
comment|/* If we really want the remainder, get it by subtraction.  */
if|if
condition|(
name|rem_flag
condition|)
block|{
if|if
condition|(
name|result
operator|==
literal|0
condition|)
comment|/* No divide instruction either.  Use library for remainder.  */
name|result
operator|=
name|sign_expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|umod_optab
argument_list|,
name|smod_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We divided.  Now finish doing X - Y * (X / Y).  */
name|result
operator|=
name|expand_mult
argument_list|(
name|compute_mode
argument_list|,
name|result
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|abort
argument_list|()
expr_stmt|;
name|result
operator|=
name|expand_binop
argument_list|(
name|compute_mode
argument_list|,
name|sub_optab
argument_list|,
name|op0
argument_list|,
name|result
argument_list|,
name|target
argument_list|,
name|unsignedp
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
name|gen_lowpart
argument_list|(
name|mode
argument_list|,
name|result
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a tree node with data type TYPE, describing the value of X.    Usually this is an RTL_EXPR, if there is no obvious better choice.    X may be an expression, however we only support those expressions    generated by loop.c.   */
end_comment

begin_function
name|tree
name|make_tree
parameter_list|(
name|type
parameter_list|,
name|x
parameter_list|)
name|tree
name|type
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|tree
name|t
decl_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST_INT
case|:
name|t
operator|=
name|build_int_2
argument_list|(
name|INTVAL
argument_list|(
name|x
argument_list|)
argument_list|,
operator|!
name|TREE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|>=
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|t
return|;
case|case
name|CONST_DOUBLE
case|:
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|==
name|VOIDmode
condition|)
block|{
name|t
operator|=
name|build_int_2
argument_list|(
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|,
name|CONST_DOUBLE_HIGH
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
block|}
else|else
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|REAL_VALUE_FROM_CONST_DOUBLE
argument_list|(
name|d
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|t
operator|=
name|build_real
argument_list|(
name|type
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
case|case
name|PLUS
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|MINUS
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MINUS_EXPR
argument_list|,
name|type
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|NEG
case|:
return|return
name|fold
argument_list|(
name|build1
argument_list|(
name|NEGATE_EXPR
argument_list|,
name|type
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|MULT
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|ASHIFT
case|:
return|return
name|fold
argument_list|(
name|build
argument_list|(
name|LSHIFT_EXPR
argument_list|,
name|type
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|LSHIFTRT
case|:
return|return
name|fold
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|build
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|unsigned_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|unsigned_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|ASHIFTRT
case|:
return|return
name|fold
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|build
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|signed_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|signed_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|DIV
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|REAL_TYPE
condition|)
name|t
operator|=
name|signed_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|type
expr_stmt|;
return|return
name|fold
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|build
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|t
argument_list|,
name|make_tree
argument_list|(
name|t
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|t
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|UDIV
case|:
name|t
operator|=
name|unsigned_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|fold
argument_list|(
name|convert
argument_list|(
name|type
argument_list|,
name|build
argument_list|(
name|TRUNC_DIV_EXPR
argument_list|,
name|t
argument_list|,
name|make_tree
argument_list|(
name|t
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|t
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
default|default:
name|t
operator|=
name|make_node
argument_list|(
name|RTL_EXPR
argument_list|)
expr_stmt|;
name|TREE_TYPE
argument_list|(
name|t
argument_list|)
operator|=
name|type
expr_stmt|;
name|RTL_EXPR_RTL
argument_list|(
name|t
argument_list|)
operator|=
name|x
expr_stmt|;
comment|/* There are no insns to be output 	 when this rtl_expr is used.  */
name|RTL_EXPR_SEQUENCE
argument_list|(
name|t
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
name|t
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return an rtx representing the value of X * MULT + ADD.    TARGET is a suggestion for where to store the result (an rtx).    MODE is the machine mode for the computation.    X and MULT must have mode MODE.  ADD may have a different mode.    So can X (defaults to same as MODE).    UNSIGNEDP is non-zero to do unsigned multiplication.    This may emit insns.  */
end_comment

begin_function
name|rtx
name|expand_mult_add
parameter_list|(
name|x
parameter_list|,
name|target
parameter_list|,
name|mult
parameter_list|,
name|add
parameter_list|,
name|mode
parameter_list|,
name|unsignedp
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|target
decl_stmt|,
name|mult
decl_stmt|,
name|add
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
block|{
name|tree
name|type
init|=
name|type_for_mode
argument_list|(
name|mode
argument_list|,
name|unsignedp
argument_list|)
decl_stmt|;
name|tree
name|add_type
init|=
operator|(
name|GET_MODE
argument_list|(
name|add
argument_list|)
operator|==
name|VOIDmode
condition|?
name|type
else|:
name|type_for_mode
argument_list|(
name|GET_MODE
argument_list|(
name|add
argument_list|)
argument_list|,
name|unsignedp
argument_list|)
operator|)
decl_stmt|;
name|tree
name|result
init|=
name|fold
argument_list|(
name|build
argument_list|(
name|PLUS_EXPR
argument_list|,
name|type
argument_list|,
name|fold
argument_list|(
name|build
argument_list|(
name|MULT_EXPR
argument_list|,
name|type
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|x
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|type
argument_list|,
name|mult
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|make_tree
argument_list|(
name|add_type
argument_list|,
name|add
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|expand_expr
argument_list|(
name|result
argument_list|,
name|target
argument_list|,
name|VOIDmode
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute the logical-and of OP0 and OP1, storing it in TARGET    and returning TARGET.     If TARGET is 0, a pseudo-register or constant is returned.  */
end_comment

begin_function
name|rtx
name|expand_and
parameter_list|(
name|op0
parameter_list|,
name|op1
parameter_list|,
name|target
parameter_list|)
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|target
decl_stmt|;
block|{
name|enum
name|machine_mode
name|mode
init|=
name|VOIDmode
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|op0
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|VOIDmode
condition|)
name|tem
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|and_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|target
argument_list|,
literal|0
argument_list|,
name|OPTAB_LIB_WIDEN
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|==
name|CONST_INT
condition|)
name|tem
operator|=
name|GEN_INT
argument_list|(
name|INTVAL
argument_list|(
name|op0
argument_list|)
operator|&
name|INTVAL
argument_list|(
name|op1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
name|target
operator|=
name|tem
expr_stmt|;
elseif|else
if|if
condition|(
name|tem
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|target
argument_list|,
name|tem
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Emit a store-flags instruction for comparison CODE on OP0 and OP1    and storing in TARGET.  Normally return TARGET.    Return 0 if that cannot be done.     MODE is the mode to use for OP0 and OP1 should they be CONST_INTs.  If    it is VOIDmode, they cannot both be CONST_INT.       UNSIGNEDP is for the case where we have to widen the operands    to perform the operation.  It says to use zero-extension.     NORMALIZEP is 1 if we should convert the result to be either zero    or one one.  Normalize is -1 if we should convert the result to be    either zero or -1.  If NORMALIZEP is zero, the result will be left    "raw" out of the scc insn.  */
end_comment

begin_function
name|rtx
name|emit_store_flag
parameter_list|(
name|target
parameter_list|,
name|code
parameter_list|,
name|op0
parameter_list|,
name|op1
parameter_list|,
name|mode
parameter_list|,
name|unsignedp
parameter_list|,
name|normalizep
parameter_list|)
name|rtx
name|target
decl_stmt|;
name|enum
name|rtx_code
name|code
decl_stmt|;
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|int
name|unsignedp
decl_stmt|;
name|int
name|normalizep
decl_stmt|;
block|{
name|rtx
name|subtarget
decl_stmt|;
name|enum
name|insn_code
name|icode
decl_stmt|;
name|enum
name|machine_mode
name|compare_mode
decl_stmt|;
name|enum
name|machine_mode
name|target_mode
init|=
name|GET_MODE
argument_list|(
name|target
argument_list|)
decl_stmt|;
name|rtx
name|tem
decl_stmt|;
name|rtx
name|last
init|=
literal|0
decl_stmt|;
name|rtx
name|pattern
decl_stmt|,
name|comparison
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|VOIDmode
condition|)
name|mode
operator|=
name|GET_MODE
argument_list|(
name|op0
argument_list|)
expr_stmt|;
comment|/* If one operand is constant, make it the second one.  Only do this      if the other operand is not constant as well.  */
if|if
condition|(
operator|(
name|CONSTANT_P
argument_list|(
name|op0
argument_list|)
operator|&&
operator|!
name|CONSTANT_P
argument_list|(
name|op1
argument_list|)
operator|)
operator|||
operator|(
name|GET_CODE
argument_list|(
name|op0
argument_list|)
operator|==
name|CONST_INT
operator|&&
name|GET_CODE
argument_list|(
name|op1
argument_list|)
operator|!=
name|CONST_INT
operator|)
condition|)
block|{
name|tem
operator|=
name|op0
expr_stmt|;
name|op0
operator|=
name|op1
expr_stmt|;
name|op1
operator|=
name|tem
expr_stmt|;
name|code
operator|=
name|swap_condition
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
comment|/* For some comparisons with 1 and -1, we can convert this to       comparisons with zero.  This will often produce more opportunities for      store-flag insns. */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|LT
case|:
if|if
condition|(
name|op1
operator|==
name|const1_rtx
condition|)
name|op1
operator|=
name|const0_rtx
operator|,
name|code
operator|=
name|LE
expr_stmt|;
break|break;
case|case
name|LE
case|:
if|if
condition|(
name|op1
operator|==
name|constm1_rtx
condition|)
name|op1
operator|=
name|const0_rtx
operator|,
name|code
operator|=
name|LT
expr_stmt|;
break|break;
case|case
name|GE
case|:
if|if
condition|(
name|op1
operator|==
name|const1_rtx
condition|)
name|op1
operator|=
name|const0_rtx
operator|,
name|code
operator|=
name|GT
expr_stmt|;
break|break;
case|case
name|GT
case|:
if|if
condition|(
name|op1
operator|==
name|constm1_rtx
condition|)
name|op1
operator|=
name|const0_rtx
operator|,
name|code
operator|=
name|GE
expr_stmt|;
break|break;
case|case
name|GEU
case|:
if|if
condition|(
name|op1
operator|==
name|const1_rtx
condition|)
name|op1
operator|=
name|const0_rtx
operator|,
name|code
operator|=
name|NE
expr_stmt|;
break|break;
case|case
name|LTU
case|:
if|if
condition|(
name|op1
operator|==
name|const1_rtx
condition|)
name|op1
operator|=
name|const0_rtx
operator|,
name|code
operator|=
name|EQ
expr_stmt|;
break|break;
block|}
comment|/* From now on, we won't change CODE, so set ICODE now.  */
name|icode
operator|=
name|setcc_gen_code
index|[
operator|(
name|int
operator|)
name|code
index|]
expr_stmt|;
comment|/* If this is A< 0 or A>= 0, we can do this by taking the ones      complement of A (for GE) and shifting the sign bit to the low bit.  */
if|if
condition|(
name|op1
operator|==
name|const0_rtx
operator|&&
operator|(
name|code
operator|==
name|LT
operator|||
name|code
operator|==
name|GE
operator|)
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|normalizep
operator|||
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|||
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|subtarget
operator|=
name|target
expr_stmt|;
comment|/* If the result is to be wider than OP0, it is best to convert it 	 first.  If it is to be narrower, it is *incorrect* to convert it 	 first.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|target_mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|op0
operator|=
name|convert_to_mode
argument_list|(
name|target_mode
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode
operator|=
name|target_mode
expr_stmt|;
block|}
if|if
condition|(
name|target_mode
operator|!=
name|mode
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|GE
condition|)
name|op0
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|one_cmpl_optab
argument_list|,
name|op0
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|normalizep
operator|||
name|STORE_FLAG_VALUE
operator|==
literal|1
condition|)
comment|/* If we are supposed to produce a 0/1 value, we want to do 	   a logical shift from the sign bit to the low-order bit; for 	   a -1/0 value, we do an arithmetic shift.  */
name|op0
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|normalizep
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|target_mode
condition|)
name|op0
operator|=
name|convert_to_mode
argument_list|(
name|target_mode
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|op0
return|;
block|}
if|if
condition|(
name|icode
operator|!=
name|CODE_FOR_nothing
condition|)
block|{
comment|/* We think we may be able to do this with a scc insn.  Emit the 	 comparison and then the scc insn.  	 compare_from_rtx may call emit_queue, which would be deleted below 	 if the scc insn fails.  So call it ourselves before setting LAST.  */
name|emit_queue
argument_list|()
expr_stmt|;
name|last
operator|=
name|get_last_insn
argument_list|()
expr_stmt|;
name|comparison
operator|=
name|compare_from_rtx
argument_list|(
name|op0
argument_list|,
name|op1
argument_list|,
name|code
argument_list|,
name|unsignedp
argument_list|,
name|mode
argument_list|,
name|NULL_RTX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|==
name|CONST_INT
condition|)
return|return
operator|(
name|comparison
operator|==
name|const0_rtx
condition|?
name|const0_rtx
else|:
name|normalizep
operator|==
literal|1
condition|?
name|const1_rtx
else|:
name|normalizep
operator|==
operator|-
literal|1
condition|?
name|constm1_rtx
else|:
name|const_true_rtx
operator|)
return|;
comment|/* If the code of COMPARISON doesn't match CODE, something is 	 wrong; we can no longer be sure that we have the operation.   	 We could handle this case, but it should not happen.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|comparison
argument_list|)
operator|!=
name|code
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Get a reference to the target in the proper mode for this insn.  */
name|compare_mode
operator|=
name|insn_operand_mode
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
literal|0
index|]
expr_stmt|;
name|subtarget
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|preserve_subexpressions_p
argument_list|()
operator|||
operator|!
call|(
modifier|*
name|insn_operand_predicate
index|[
operator|(
name|int
operator|)
name|icode
index|]
index|[
literal|0
index|]
call|)
argument_list|(
name|subtarget
argument_list|,
name|compare_mode
argument_list|)
condition|)
name|subtarget
operator|=
name|gen_reg_rtx
argument_list|(
name|compare_mode
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|GEN_FCN
argument_list|(
name|icode
argument_list|)
argument_list|(
name|subtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|pattern
condition|)
block|{
name|emit_insn
argument_list|(
name|pattern
argument_list|)
expr_stmt|;
comment|/* If we are converting to a wider mode, first convert to 	     TARGET_MODE, then normalize.  This produces better combining 	     opportunities on machines that have a SIGN_EXTRACT when we are 	     testing a single bit.  This mostly benefits the 68k.  	     If STORE_FLAG_VALUE does not have the sign bit set when 	     interpreted in COMPARE_MODE, we can do this conversion as 	     unsigned, which is usually more efficient.  */
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|target_mode
argument_list|)
operator|>
name|GET_MODE_SIZE
argument_list|(
name|compare_mode
argument_list|)
condition|)
block|{
name|convert_move
argument_list|(
name|target
argument_list|,
name|subtarget
argument_list|,
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|compare_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|)
operator|&&
literal|0
operator|==
operator|(
name|STORE_FLAG_VALUE
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|compare_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|op0
operator|=
name|target
expr_stmt|;
name|compare_mode
operator|=
name|target_mode
expr_stmt|;
block|}
else|else
name|op0
operator|=
name|subtarget
expr_stmt|;
comment|/* If we want to keep subexpressions around, don't reuse our 	     last target.  */
if|if
condition|(
name|preserve_subexpressions_p
argument_list|()
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
comment|/* Now normalize to the proper value in COMPARE_MODE.  Sometimes 	     we don't have to do anything.  */
if|if
condition|(
name|normalizep
operator|==
literal|0
operator|||
name|normalizep
operator|==
name|STORE_FLAG_VALUE
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|normalizep
operator|==
operator|-
name|STORE_FLAG_VALUE
condition|)
name|op0
operator|=
name|expand_unop
argument_list|(
name|compare_mode
argument_list|,
name|neg_optab
argument_list|,
name|op0
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We don't want to use STORE_FLAG_VALUE< 0 below since this 	     makes it hard to use a value of just the sign bit due to 	     ANSI integer constant typing rules.  */
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|compare_mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|&
operator|(
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|compare_mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|op0
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|compare_mode
argument_list|,
name|op0
argument_list|,
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|compare_mode
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|subtarget
argument_list|,
name|normalizep
operator|==
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STORE_FLAG_VALUE
operator|&
literal|1
condition|)
block|{
name|op0
operator|=
name|expand_and
argument_list|(
name|op0
argument_list|,
name|const1_rtx
argument_list|,
name|subtarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|normalizep
operator|==
operator|-
literal|1
condition|)
name|op0
operator|=
name|expand_unop
argument_list|(
name|compare_mode
argument_list|,
name|neg_optab
argument_list|,
name|op0
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* If we were converting to a smaller mode, do the  	     conversion now.  */
if|if
condition|(
name|target_mode
operator|!=
name|compare_mode
condition|)
block|{
name|convert_move
argument_list|(
name|target
argument_list|,
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|target
return|;
block|}
else|else
return|return
name|op0
return|;
block|}
block|}
if|if
condition|(
name|last
condition|)
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|subtarget
operator|=
name|target_mode
operator|==
name|mode
condition|?
name|target
else|:
literal|0
expr_stmt|;
comment|/* If we reached here, we can't do this with a scc insn.  However, there      are some comparisons that can be done directly.  For example, if      this is an equality comparison of integers, we can try to exclusive-or      (or subtract) the two operands and use a recursive call to try the      comparison with zero.  Don't do any of these cases if branches are      very cheap.  */
if|if
condition|(
name|BRANCH_COST
operator|>
literal|0
operator|&&
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|==
name|MODE_INT
operator|&&
operator|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
operator|)
operator|&&
name|op1
operator|!=
name|const0_rtx
condition|)
block|{
name|tem
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|xor_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|subtarget
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
name|tem
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|sub_optab
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|,
name|subtarget
argument_list|,
literal|1
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
name|tem
operator|=
name|emit_store_flag
argument_list|(
name|target
argument_list|,
name|code
argument_list|,
name|tem
argument_list|,
name|const0_rtx
argument_list|,
name|mode
argument_list|,
name|unsignedp
argument_list|,
name|normalizep
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
comment|/* Some other cases we can do are EQ, NE, LE, and GT comparisons with       the constant zero.  Reject all other comparisons at this point.  Only      do LE and GT if branches are expensive since they are expensive on      2-operand machines.  */
if|if
condition|(
name|BRANCH_COST
operator|==
literal|0
operator|||
name|GET_MODE_CLASS
argument_list|(
name|mode
argument_list|)
operator|!=
name|MODE_INT
operator|||
name|op1
operator|!=
name|const0_rtx
operator|||
operator|(
name|code
operator|!=
name|EQ
operator|&&
name|code
operator|!=
name|NE
operator|&&
operator|(
name|BRANCH_COST
operator|<=
literal|1
operator|||
operator|(
name|code
operator|!=
name|LE
operator|&&
name|code
operator|!=
name|GT
operator|)
operator|)
operator|)
condition|)
return|return
literal|0
return|;
comment|/* See what we need to return.  We can only return a 1, -1, or the      sign bit.  */
if|if
condition|(
name|normalizep
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|STORE_FLAG_VALUE
operator|==
literal|1
operator|||
name|STORE_FLAG_VALUE
operator|==
operator|-
literal|1
condition|)
name|normalizep
operator|=
name|STORE_FLAG_VALUE
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|<=
name|HOST_BITS_PER_WIDE_INT
operator|&&
operator|(
name|STORE_FLAG_VALUE
operator|==
operator|(
name|HOST_WIDE_INT
operator|)
literal|1
operator|<<
operator|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
empty_stmt|;
else|else
return|return
literal|0
return|;
block|}
comment|/* Try to put the result of the comparison in the sign bit.  Assume we can't      do the necessary operation below.  */
name|tem
operator|=
literal|0
expr_stmt|;
comment|/* To see if A<= 0, compute (A | (A - 1)).  A<= 0 iff that result has      the sign bit set.  */
if|if
condition|(
name|code
operator|==
name|LE
condition|)
block|{
comment|/* This is destructive, so SUBTARGET can't be OP0.  */
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|subtarget
argument_list|,
name|op0
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|tem
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|sub_optab
argument_list|,
name|op0
argument_list|,
name|const1_rtx
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
condition|)
name|tem
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ior_optab
argument_list|,
name|op0
argument_list|,
name|tem
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
comment|/* To see if A> 0, compute (((signed) A)<< BITS) - A, where BITS is the      number of bits in the mode of OP0, minus one.  */
if|if
condition|(
name|code
operator|==
name|GT
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|subtarget
argument_list|,
name|op0
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|tem
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|op0
argument_list|,
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|sub_optab
argument_list|,
name|tem
argument_list|,
name|op0
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|code
operator|==
name|EQ
operator|||
name|code
operator|==
name|NE
condition|)
block|{
comment|/* For EQ or NE, one way to do the comparison is to apply an operation 	 that converts the operand into a positive number if it is non-zero 	 or zero if it was originally zero.  Then, for EQ, we subtract 1 and 	 for NE we negate.  This puts the result in the sign bit.  Then we 	 normalize with a shift, if needed.   	 Two operations that can do the above actions are ABS and FFS, so try 	 them.  If that doesn't work, and MODE is smaller than a full word, 	 we can use zero-extension to the wider mode (an unsigned conversion) 	 as the operation.  */
if|if
condition|(
name|abs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
name|tem
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|abs_optab
argument_list|,
name|op0
argument_list|,
name|subtarget
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ffs_optab
operator|->
name|handlers
index|[
operator|(
name|int
operator|)
name|mode
index|]
operator|.
name|insn_code
operator|!=
name|CODE_FOR_nothing
condition|)
name|tem
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|ffs_optab
argument_list|,
name|op0
argument_list|,
name|subtarget
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
operator|<
name|UNITS_PER_WORD
condition|)
block|{
name|mode
operator|=
name|word_mode
expr_stmt|;
name|op0
operator|=
name|protect_from_queue
argument_list|(
name|op0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|convert_to_mode
argument_list|(
name|mode
argument_list|,
name|op0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|code
operator|==
name|EQ
condition|)
name|tem
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|sub_optab
argument_list|,
name|tem
argument_list|,
name|const1_rtx
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
else|else
name|tem
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|neg_optab
argument_list|,
name|tem
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If we couldn't do it that way, for NE we can "or" the two's complement 	 of the value with itself.  For EQ, we take the one's complement of 	 that "or", which is an extra insn, so we only handle EQ if branches 	 are expensive.  */
if|if
condition|(
name|tem
operator|==
literal|0
operator|&&
operator|(
name|code
operator|==
name|NE
operator|||
name|BRANCH_COST
operator|>
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|rtx_equal_p
argument_list|(
name|subtarget
argument_list|,
name|op0
argument_list|)
condition|)
name|subtarget
operator|=
literal|0
expr_stmt|;
name|tem
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|neg_optab
argument_list|,
name|op0
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|expand_binop
argument_list|(
name|mode
argument_list|,
name|ior_optab
argument_list|,
name|tem
argument_list|,
name|op0
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|,
name|OPTAB_WIDEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|&&
name|code
operator|==
name|EQ
condition|)
name|tem
operator|=
name|expand_unop
argument_list|(
name|mode
argument_list|,
name|one_cmpl_optab
argument_list|,
name|tem
argument_list|,
name|subtarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tem
operator|&&
name|normalizep
condition|)
name|tem
operator|=
name|expand_shift
argument_list|(
name|RSHIFT_EXPR
argument_list|,
name|mode
argument_list|,
name|tem
argument_list|,
name|size_int
argument_list|(
name|GET_MODE_BITSIZE
argument_list|(
name|mode
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|,
name|tem
argument_list|,
name|normalizep
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|&&
name|GET_MODE
argument_list|(
name|tem
argument_list|)
operator|!=
name|target_mode
condition|)
block|{
name|convert_move
argument_list|(
name|target
argument_list|,
name|tem
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tem
operator|=
name|target
expr_stmt|;
block|}
if|if
condition|(
name|tem
operator|==
literal|0
condition|)
name|delete_insns_since
argument_list|(
name|last
argument_list|)
expr_stmt|;
return|return
name|tem
return|;
block|}
end_function

end_unit

